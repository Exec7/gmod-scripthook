--Stealed clientside server code by exechack.cc
--Hostname: [TR] Venom Roleplay | DarkRP #venom25 - discord.gg/eniyisi  - Part 10/12 - 06/04/2025


--PATH lua/autorun/!0_zclib_load.lua:
return gluapack()()
--lua/zclib/sh_main_config.lua:
zclib = zclib or {}
zclib.config = zclib.config or {}

// Used for debugging the script
zclib.config.Debug = false

zclib.config.NoPrint = true

// By default i disable the net track system since if it doesent find any supported script hook then its gonna overwrite the net.Incoming function which could cause problems for other scripts who overwrite this too.
// Currently Supported Scripts: eProtect(eP:PreNetworking)
zclib.config.NetTrack = false

// The Currency
zclib.config.Currency = "$"

// Should the Currency symbol be in front or after the money value?
zclib.config.CurrencyInvert = true

// These Ranks are admins
// If xAdmin, sAdmin or SAM is installed then this table can be ignored
zclib.config.AdminRanks = {
	["owner"] = true,
	["superadmin"] = true,
	["Super Admin"] = true,
}


// The path from which we try to download the uploaded image
// Examble https://i.imgur.com/ == https://i.imgur.com/imageid.png
zclib.config.ImageSizeLimit = 5000
zclib.config.ImageServices = {
	["imgur"] = "https://i.imgur.com/",
	["imgpile"] = "https://imgpile.com/images/"
}

// zclib.config.ImageServices["folder"] = "https://AdresseToImage/"
/*
	Examble:
		Addresse to a imagefile: > https://imgpile.com/images/nnHvi2.jpg
		ImageService would be that > zclib.config.ImageServices["imgpile"] = "https://imgpile.com/images/"
		ImageID would be that > nnHvi2
*/

zclib.config.ActiveImageService = "imgur"


zclib.config.Police = {
	Jobs = {}
}

zclib.config.CleanUp = {
	SkipOnTeamChange = {}
}
//zclib.config.CleanUp.SkipOnTeamChange[TEAM_STAFF] = true

zclib.config.Inventory = {

	// If set to true then the player will get his own inventory assigned on join
	PlayerInv = false,

	// If true then items that can be picked up in the inventory will be displayed
	ShowItemPickup = false,

	// Should we drop all the players inventory in a bag once he dies?
	DropOnDeath = false,

	// What entities can be stored inside the inventory
	// NOTE Some entities will need a custom module in order to save / load all its data correctly
	AllowedItems = {
		"prop_physics",
		"weapon_",
		"weapons_",
		"durgz_",
		"drug_",
		"drugs_",
		"item_health",
		"item_battery",
		"item_ammo",
		"item_box",
		"item_rpg_round",
		"spawned_shipment",
		"spawned_weapon",
		"spawned_food",
		"food",
		"spawned_ammo",
		"m9k_",
		"ls_sniper",
		"bb_",
		"manhack_welder",
		"tfa_",
		"zss_mine",
		"combine_mine",
	},

	// Entities which we dont allow to be stored
	BannedItems = {"sent_ball"},
}


// Here you can pre define names for Classes which get used instead.
zclib.config.PredefinedNames = {
	["sent_ball"] = "Super Bouncer",
	["item_healthkit"] = "Health Kit",
	["item_ammo_357"] = "357 Ammo",
	["item_ammo_357_large"] = "357 Ammo (Large)",
	["item_ammo_ar2"] = "AR2 Ammo",
	["item_ammo_ar2_large"] = "AR2 Ammo (Large)",
	["item_ammo_ar2_altfire"] = "AR2 Orb",
	["item_ammo_crossbow"] = "Crossbow Bolts",
	["item_healthvial"] = "Health Viral",
	["item_ammo_pistol"] = "Pistol Ammo",
	["item_ammo_pistol_large"] = "Pistol Ammo (Large)",
	["item_rpg_round"] = "RPG Round",
	["item_box_buckshot"] = "Shotgun Ammo",
	["item_ammo_smg1"] = "SMG Ammo",
	["item_ammo_smg1_large"] = "SMG Ammo (Large)",
	["item_ammo_smg1_grenade"] = "SMG Grenade",
	["item_battery"] = "Suit Battery"
}

--lua/zclib/util/sh_atracker.lua:
zclib = zclib or {}

if CLIENT then
	/*
		Keep track on cached fonts which are created
	*/
	zclib.CachedFonts = zclib.CachedFonts or {}
	local oldFontFunc = surface.CreateFont
	function surface.CreateFont(name,data)
		//print("surface.CreateFont: "..name)
		zclib.CachedFonts[name] = true
		oldFontFunc(name,data)
	end
	concommand.Add("zclib_print_fonts", function(ply, cmd, args)
		PrintTable(zclib.CachedFonts)
	end)
end


/*
	Keep track on cached fonts which are created
*/
zclib.CachedEffects = zclib.CachedEffects or {}
local oldPrecacheFunc = PrecacheParticleSystem
function PrecacheParticleSystem(name)
	zclib.CachedEffects[name] = true
	hook.Run("zclib_OnParticleSystemPrecached", name)
	oldPrecacheFunc(name)
end

function zclib.GetCachedEffects()
	local FoundEffects = {}

	for k, v in pairs(zclib.CachedEffects) do
		table.insert(FoundEffects, k)
	end

	return FoundEffects
end

timer.Simple(2,function()
	for k,v in pairs(zclib.CachedEffects) do
		hook.Run("zclib_OnParticleSystemPrecached", k)
	end
end)
concommand.Add("zclib_print_effects", function(ply, cmd, args)
	PrintTable(zclib.CachedEffects)
end)

--lua/zclib/util/sh_draw.lua:
return gluapack()()
--lua/zclib/util/sh_materials.lua:
zclib = zclib or {}
zclib.Materials = zclib.Materials or {}
zclib.Materials.List = zclib.Materials.List or {}

function zclib.Materials.Add(index,mat)
    zclib.Materials.List[index] = mat
end

function zclib.Materials.Get(index)
    return zclib.Materials.List[index]
end

zclib.Materials.Add("blur",Material("pp/blurscreen"))
zclib.Materials.Add("highlight",Material("zerochain/zerolib/shader/zlib_highlight"))
zclib.Materials.Add("beam01",Material("zerochain/zerolib/cable/zlib_beam"))
zclib.Materials.Add("glow01",Material("zerochain/zerolib/sprites/zlib_glow01"))
zclib.Materials.Add("light_sprite",Material("sprites/light_ignorez"))

zclib.Materials.Add("close",Material("materials/zerochain/zerolib/ui/icon_close.png", "noclamp smooth"))
zclib.Materials.Add("radial_shadow",Material("materials/zerochain/zerolib/ui/radial_shadow.png", "noclamp smooth"))
zclib.Materials.Add("linear_gradient",Material("materials/zerochain/zerolib/ui/linear_gradient.png", "smooth"))
zclib.Materials.Add("linear_gradient_a",Material("materials/zerochain/zerolib/ui/linear_gradient_a.png", "smooth"))
zclib.Materials.Add("scanlines",Material("materials/zerochain/zerolib/ui/scanlines.png", "smooth"))
zclib.Materials.Add("item_bg",Material("materials/zerochain/zerolib/ui/item_bg.png", "smooth"))
zclib.Materials.Add("icon_box01",Material("materials/zerochain/zerolib/ui/icon_box01.png", "smooth"))
zclib.Materials.Add("icon_loading",Material("materials/zerochain/zerolib/ui/icon_loading.png", "smooth"))
zclib.Materials.Add("icon_E",Material("materials/zerochain/zerolib/ui/icon_E.png", "smooth"))
zclib.Materials.Add("icon_mouse_left",Material("materials/zerochain/zerolib/ui/icon_mouse_left.png", "smooth"))
zclib.Materials.Add("icon_mouse_right",Material("materials/zerochain/zerolib/ui/icon_mouse_right.png", "smooth"))
zclib.Materials.Add("icon_locked",Material("materials/zerochain/zerolib/ui/icon_locked.png", "smooth"))
zclib.Materials.Add("radial_invert_glow",Material("materials/zerochain/zerolib/ui/radial_invert_glow.png", "smooth"))

zclib.Materials.Add("grib_horizontal",Material("materials/zerochain/zerolib/ui/grib_horizontal.png", "smooth noclamp"))
zclib.Materials.Add("circle_thick",Material("materials/zerochain/zerolib/ui/circle_thick.png", "noclamp smooth"))
zclib.Materials.Add("square_glow",Material("materials/zerochain/zerolib/ui/square_glow.png", "smooth noclamp"))

zclib.Materials.Add("edit",Material("materials/zerochain/zerolib/ui/edit.png", "smooth"))
zclib.Materials.Add("delete",Material("materials/zerochain/zerolib/ui/delete.png", "smooth"))
zclib.Materials.Add("plus",Material("materials/zerochain/zerolib/ui/plus.png", "smooth"))
zclib.Materials.Add("save",Material("materials/zerochain/zerolib/ui/save.png", "smooth"))
zclib.Materials.Add("duplicate",Material("materials/zerochain/zerolib/ui/duplicate.png", "smooth"))
zclib.Materials.Add("clipboard",Material("materials/zerochain/zerolib/ui/clipboard.png", "smooth"))

zclib.Materials.Add("repair",Material("materials/zerochain/zerolib/ui/repair.png", "smooth"))
zclib.Materials.Add("move",Material("materials/zerochain/zerolib/ui/move.png", "smooth"))

zclib.Materials.Add("refresh",Material("materials/zerochain/zerolib/ui/refresh.png", "smooth"))
zclib.Materials.Add("bottomshadow",Material("materials/zerochain/zerolib/ui/bottomshadow.png", "smooth"))
zclib.Materials.Add("accept",Material("materials/zerochain/zerolib/ui/icon_accept.png", "smooth"))

zclib.Materials.Add("star01",Material("materials/zerochain/zerolib/ui/star01.png", "smooth"))
zclib.Materials.Add("icon_hot",Material("materials/zerochain/zerolib/ui/icon_hot.png", "smooth"))

zclib.Materials.Add("whitelist",Material("materials/zerochain/zerolib/ui/whitelist.png", "smooth"))
zclib.Materials.Add("appearance",Material("materials/zerochain/zerolib/ui/appearance.png", "smooth"))

zclib.Materials.Add("time",Material("materials/zerochain/zerolib/ui/icon_time.png", "smooth"))
zclib.Materials.Add("mass",Material("materials/zerochain/zerolib/ui/icon_mass.png", "smooth"))

zclib.Materials.Add("money",Material("materials/zerochain/zerolib/ui/money.png", "smooth"))
zclib.Materials.Add("knob",Material("materials/zerochain/zerolib/ui/knob.png", "smooth"))

zclib.Materials.Add("info",Material("materials/zerochain/zerolib/ui/icon_info.png", "smooth"))
zclib.Materials.Add("robot",Material("materials/zerochain/zerolib/ui/robot.png", "smooth"))

zclib.Materials.Add("switch",Material("materials/zerochain/zerolib/ui/switch.png", "smooth"))

zclib.Materials.Add("warnstripes",Material("materials/zerochain/zerolib/ui/warnstripes.png", "smooth"))
zclib.Materials.Add("warnstripes_white",Material("materials/zerochain/zerolib/ui/warnstripes_white.png", "smooth"))

zclib.Materials.Add("infopointer",Material("materials/zerochain/zerolib/ui/hud_infopointer.png", "noclamp smooth"))

zclib.Materials.Add("back",Material("materials/zerochain/zerolib/ui/icon_back.png", "noclamp smooth"))
zclib.Materials.Add("next",Material("materials/zerochain/zerolib/ui/icon_next.png", "noclamp smooth"))

zclib.Materials.Add("upgrade",Material("materials/zerochain/zerolib/ui/icon_upgrade.png", "noclamp smooth"))

zclib.Materials.Add("rank",Material("materials/zerochain/zerolib/ui/icon_rank.png", "noclamp smooth"))
zclib.Materials.Add("job",Material("materials/zerochain/zerolib/ui/icon_job.png", "noclamp smooth"))


zclib.Materials.Add("mute",Material("materials/zerochain/zerolib/ui/icon_mute.png", "noclamp smooth"))
zclib.Materials.Add("volume",Material("materials/zerochain/zerolib/ui/icon_volume.png", "noclamp smooth"))

zclib.Materials.Add("minus",Material("materials/zerochain/zerolib/ui/minus.png", "noclamp smooth"))
zclib.Materials.Add("drop",Material("materials/zerochain/zerolib/ui/icon_drop.png", "noclamp smooth"))

zclib.Materials.Add("image",Material("materials/zerochain/zerolib/ui/icon_image.png", "noclamp smooth"))

zclib.Materials.Add("minimize",Material("materials/zerochain/zerolib/ui/icon_window02.png", "noclamp smooth"))
zclib.Materials.Add("fullscreen",Material("materials/zerochain/zerolib/ui/icon_window01.png", "noclamp smooth"))

zclib.Materials.Add("random",Material("materials/zerochain/zerolib/ui/random.png", "noclamp smooth"))
zclib.Materials.Add("statistic",Material("materials/zerochain/zerolib/ui/statistic.png", "noclamp smooth"))
zclib.Materials.Add("random_style",Material("materials/zerochain/zerolib/ui/random_style.png", "noclamp smooth"))

zclib.Materials.Add("audio_play",Material("materials/zerochain/zerolib/ui/play.png", "noclamp smooth"))
zclib.Materials.Add("audio_stop",Material("materials/zerochain/zerolib/ui/stop.png", "noclamp smooth"))

zclib.Materials.Add("circle_512",Material("materials/zerochain/zerolib/ui/circle_512.png", "noclamp smooth"))
zclib.Materials.Add("circle_48",Material("materials/zerochain/zerolib/ui/circle_48.png", "noclamp smooth"))
zclib.Materials.Add("circle_32",Material("materials/zerochain/zerolib/ui/circle_32.png", "noclamp smooth"))

zclib.Materials.Add("share",Material("materials/zerochain/zerolib/ui/icon_share.png", "noclamp smooth"))
zclib.Materials.Add("contract",Material("materials/zerochain/zerolib/ui/contract.png", "noclamp smooth"))
zclib.Materials.Add("link",Material("materials/zerochain/zerolib/ui/link.png", "noclamp smooth"))

zclib.colors = zclib.colors or {}

zclib.colors["black_a25"] = Color(0, 0, 0, 25)
zclib.colors["black_a50"] = Color(0, 0, 0, 50)
zclib.colors["black_a100"] = Color(0, 0, 0, 100)
zclib.colors["black_a150"] = Color(0, 0, 0, 150)
zclib.colors["black_a200"] = Color(0, 0, 0, 200)

zclib.colors["white_a100"] = Color(255, 255, 255, 100)
zclib.colors["white_a50"] = Color(255, 255, 255, 50)

zclib.colors["white_a15"] = Color(255, 255, 255, 15)
zclib.colors["white_a5"] = Color(255, 255, 255, 5)
zclib.colors["white_a2"] = Color(255, 255, 255, 2)

zclib.colors["textentry"] = Color(149, 152, 154)

zclib.colors["ui00"] = Color(33, 37, 43)
zclib.colors["ui01"] = Color(40, 44, 52)
zclib.colors["ui02"] = Color(54, 59, 69)
zclib.colors["ui03"] = Color(85, 95, 112)
zclib.colors["ui04"] = Color(45, 48, 56)
zclib.colors["ui_highlight"] = Color(62, 68, 81)
zclib.colors["text01"] = Color(144, 150, 162)
zclib.colors["ui02_grey"] = Color(72, 72, 72)



zclib.colors["red01"] = Color(224, 108, 117)
zclib.colors["red02"] = Color(164, 59, 59)
zclib.colors["green01"] = Color(152, 195, 121)
zclib.colors["green01_dark"] = Color(41, 52, 40)

zclib.colors["orange01"] = Color(209, 154, 102)
zclib.colors["orange02"] = Color(209, 130, 102)

zclib.colors["yellow01"] = Color(209, 185, 102)

zclib.colors["blue01"] = Color(86, 182, 194)
zclib.colors["blue02"] = Color(86, 114, 194)
zclib.colors["gmod_blue"] = Color(18, 149, 241)

zclib.colors["zone_red01"] = Color(224, 108, 117,100)
zclib.colors["zone_green01"] = Color(152, 195, 121,100)
zclib.colors["zone_white"] = Color(255, 255, 255, 100)

zclib.colors["slot_normal"] = Color(61, 66, 75)
zclib.colors["slot_selected"] = Color(70, 75, 85)

// Sets up static colors if they dont exist yet
if color_red == nil then color_red =  Color(255,0,0,255) end
if color_green == nil then color_green =  Color(0,255,0,255) end
if color_blue == nil then color_blue =  Color(0,0,255,255) end



if color_white == nil then color_white =  Color(255,255,255,255) end
if color_black == nil then color_black =  Color(0,0,0,255) end

--lua/zclib/util/sh_timer.lua:
zclib = zclib or {}
zclib.Timer = zclib.Timer or {}

////////////////////////////////////////////
///////////////// Timer ////////////////////
////////////////////////////////////////////
zclib.Timer.List = zclib.Timer.List or {}

function zclib.Timer.PrintAll()
	PrintTable(zclib.Timer.List)
end

function zclib.Timer.Create(timerid,time,rep,func)

	if zclib.util.FunctionValidater(func) then
		timer.Create(timerid, time, rep,func)
		table.insert(zclib.Timer.List, timerid)
	end
end

function zclib.Timer.Remove(timerid)
	if timer.Exists(timerid) then
		timer.Remove(timerid)
		table.RemoveByValue(zclib.Timer.List, timerid)
	end
end

concommand.Add("zclib_print_timer", function(ply, cmd, args)
	if zclib.Player.IsAdmin(ply) then
		zclib.Timer.PrintAll()
	end
end)

--lua/zclib/util/cl_masks.lua:
if SERVER then return end

// Blues Masks and Shadows
//https://forum.facepunch.com/f/gmoddev/oaxt/Blue-s-Masks-and-Shadows/1/

//This code can be improved alot.
//Feel free to improve, use or modify in anyway altough credit would be apreciated.

// This will be used in the future as it has custom stuff and i dont want it to collide with the original blues masks

zclib.BMASKS = zclib.BMASKS or {} //Global table, access the functions here
zclib.BMASKS.Materials = zclib.BMASKS.Materials or {} //Cache materials so they dont need to be reloaded
zclib.BMASKS.Masks = zclib.BMASKS.Masks or {} //A table of all active mask objects, you should destroy a mask object when done with it

//The material used to draw the render targets
zclib.BMASKS.MaskMaterial = CreateMaterial("!bluemask", "UnlitGeneric", {
	[ "$translucent" ] = 1,
	[ "$vertexalpha" ] = 1,
	[ "$alpha" ] = 1,
})

//Creates a mask with the specified options
//Be sure to pass a unique maskName for each mask, otherwise they will override each other
zclib.BMASKS.CreateMask = function(maskName, maskPath, maskProperties)
	local mask = {}

	//Set mask name
	mask.name = maskName

	//Load materials
	if zclib.BMASKS.Materials[ maskPath ] == nil then
		zclib.BMASKS.Materials[ maskPath ] = Material(maskPath, maskProperties)
	end

	//Set the mask material
	mask.material = zclib.BMASKS.Materials[ maskPath ]

	//Create the render target
	mask.renderTarget = GetRenderTargetEx("zclib.BMASKS:" .. maskName, ScrW(), ScrH(), RT_SIZE_FULL_FRAME_BUFFER, MATERIAL_RT_DEPTH_NONE, 2, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGBA8888)
	zclib.BMASKS.Masks[ maskName ] = mask

	return maskName
end

//Call this to begin drawing with a mask.
//After calling this any draw call will be masked until you call EndMask(maskName)
zclib.BMASKS.BeginMask = function(maskName)

	//FindMask
	if zclib.BMASKS.Masks[ maskName ] == nil then
		print("Cannot begin a mask without creating it first!")

		return false
	end

	//Store current render target
	zclib.BMASKS.Masks[ maskName ].previousRenderTarget = render.GetRenderTarget()

	render.SetWriteDepthToDestAlpha( false )

	//Confirgure drawing so that we write to the masks render target
	render.PushRenderTarget(zclib.BMASKS.Masks[ maskName ].renderTarget)
	render.OverrideAlphaWriteEnable(true, true)
	render.Clear(0, 0, 0, 0)
end

//Ends the mask and draws it
//Not calling this after calling BeginMask will cause some really bad effects
//This done return the render target used, using this you can create other effects such as drop shadows without problems
//Passes true for dontDraw will result in it not being render and only returning the texture of the result (which is ScrW()xScrH())
local CachedOpacities = {}
zclib.BMASKS.EndMask = function(maskName, x, y, sizex, sizey, opacity, rotation, dontDraw , MakeTile)
	dontDraw = dontDraw or false
	opacity = opacity or 255

	render.OverrideBlend(true, BLEND_ZERO, BLEND_ONE, BLENDFUNC_ADD, BLEND_DST_ALPHA, BLEND_ZERO, BLENDFUNC_ADD)
	//render.OverrideBlend( true, BLEND_SRC_COLOR, BLEND_SRC_ALPHA, BLENDFUNC_MIN )

	// Cache that color, no reason to spamm
	if CachedOpacities[ opacity ] == nil then CachedOpacities[ opacity ] = Color(255, 255, 255, opacity) end


	surface.SetDrawColor(CachedOpacities[ opacity ])
	surface.SetMaterial(zclib.BMASKS.Masks[ maskName ].material)

	if MakeTile then
		local u0, v0 = 0 + x, 0 + y
		local u1, v1 = 1 + x, 1 + y
		surface.DrawTexturedRectUV(0, 0, sizex, sizex, u0, v0, u1, v1)
	else
		if rotation == nil then
			surface.DrawTexturedRect(x, y , sizex, sizey)
		else
			surface.DrawTexturedRectRotated(x, y, sizex, sizey, rotation)
		end
	end

	render.OverrideBlend( false )
	render.SetWriteDepthToDestAlpha( true )

	render.OverrideAlphaWriteEnable(false)
	render.PopRenderTarget()

	//Update material
	zclib.BMASKS.MaskMaterial:SetTexture('$basetexture', zclib.BMASKS.Masks[ maskName ].renderTarget)

	//Clear material for upcoming draw calls
	draw.NoTexture()

	//Only draw if they want it to
	if not dontDraw then

		//Now draw finished result
		surface.SetDrawColor(color_white)
		surface.SetMaterial(zclib.BMASKS.MaskMaterial)

		render.SetMaterial(zclib.BMASKS.MaskMaterial)
		render.DrawScreenQuad()
	end



	return zclib.BMASKS.Masks[ maskName ].renderTarget
end


zclib.BMASKS.CreateMask("zclib_Circle", "materials/zerochain/zerolib/mask/mask_circle.png", "smooth")
zclib.BMASKS.CreateMask("zclib_gradient_topdown", "materials/zerochain/zerolib/mask/gradient_topdown.png", "smooth")
zclib.BMASKS.CreateMask("zclib_gradient_topdown_border", "materials/zerochain/zerolib/mask/gradient_topdown_border.png", "smooth")
zclib.BMASKS.CreateMask("zclib_radial_invert_glow", "materials/zerochain/zerolib/mask/radial_invert_glow.png", "smooth")
zclib.BMASKS.CreateMask("radial_shadow", "materials/zerochain/zerolib/mask/radial_shadow.png", "smooth")
zclib.BMASKS.CreateMask("mask_roundbox", "materials/zerochain/zerolib/mask/mask_roundbox.png", "smooth")

--lua/zclib/util/player/cl_player.lua:
return gluapack()()
--lua/zclib/generic/sh_entity.lua:
zclib = zclib or {}
zclib.Entity = zclib.Entity or {}

if SERVER then
	local GettingRemovedList = {}
    function zclib.Entity.GettingRemoved(ent)
        return GettingRemovedList[ent] == true
    end

    // Removes a entity safely without hurting its feelings
    function zclib.Entity.SafeRemove(ent)
        if zclib.Entity.GettingRemoved(ent) then return end

		GettingRemovedList[ent] = true

        // Hide entity
        if ent.SetNoDraw then ent:SetNoDraw(true) end

		SafeRemoveEntityDelayed(ent, 0)
    end
else

    // Scales one entity relative to the model bounds of another entity
    function zclib.Entity.RelativeScale(ToScale,ent02,val)
        if not IsValid(ToScale) then return end
        if not IsValid(ent02) then return end
        local pmin,pmax = ent02:GetModelBounds()
        local fmin,fmax = ToScale:GetModelBounds()
        local fscale = (fmin - fmax):Length()
        local pscale = (pmin - pmax):Length()
        local nscale = (1 / fscale) * pscale
        nscale = nscale * val
        ToScale:SetModelScale(nscale)
    end

    // Returns which entity the player is currently looking at
    local LookTarget
    function zclib.Entity.GetLookTarget()
        return LookTarget
    end

    local timerid = "zclib.Entity.GetLookTarget"
    zclib.Timer.Remove(timerid)
    zclib.Timer.Create(timerid,0.1,0,function()
        if not IsValid(LocalPlayer()) then return end
        local tr = LocalPlayer():GetEyeTrace()
        if tr and tr.Hit then
            LookTarget = tr.Entity
        else
            LookTarget = nil
        end
    end)
end

zclib.Entity.List = zclib.Entity.List or {}

function zclib.Entity.GetAll()
	local clean = {}
	for k,v in pairs(zclib.Entity.List) do
		if IsValid(k) then
			table.insert(clean,k)
		else
			zclib.Entity.List[k] = nil
		end
	end
	return clean
end

zclib.Hook.Add("OnEntityCreated", "zclib_EntityTracker_add", function(ent)
	if IsValid(ent) then
		zclib.Entity.List[ent] = true
	end
end)

zclib.Hook.Add("EntityRemoved", "zclib_EntityTracker_remove", function(ent)
	if IsValid(ent) then
		zclib.Entity.List[ent] = nil
	end
end)

local function GetListSortedByCount(list,limit)
	local nList = {}

	for k, v in pairs(list) do
		table.insert(nList, {
			class = k,
			count = v
		})
	end

	table.sort(nList, function(a, b) return a.count > b.count end)
	return nList
end

function zclib.Entity.GetEntityCountSorted()
	local countList = {}
	local total = 0

	for k, v in pairs(zclib.Entity.GetAll()) do
		if not IsValid(v) then continue end
		local class = v:GetClass()
		countList[ class ] = (countList[ class ] or 0) + 1
		total = total + 1
	end

	countList = GetListSortedByCount(countList)

	return countList, total
end

local StartEntityTrackState = {}
local JoinTime = 0
function zclib.Entity.GetEntityCountDiffrence()
	local nList = zclib.Entity.GetEntityCountSorted()
	local prevList = {}
	for k,v in pairs(StartEntityTrackState) do
		prevList[v.class] = v.count
	end

	local winnerClass,winnerCount = "" , 0

	local diffList = {}

	for k,v in pairs(nList) do
		local prev_val = (prevList[v.class] or 0)
		local diff = v.count - prev_val

		diffList[ v.class ] = diff

		if diff > winnerCount then
			winnerClass = v.class
			winnerCount = diff
		end
	end

	diffList = GetListSortedByCount(diffList)

	return winnerClass , winnerCount , diffList
end

local function PrintListColored(limitMax,list,IsDiffrence,limit)
	for k, v in ipairs(list) do
		if v == nil or v.count == nil or v.count == 0 then continue end
		if v.count < limit then continue end
		local fract = 1 / (limitMax * 2) * math.Clamp(v.count - limitMax, 0, limitMax)
		local col = zclib.util.LerpColor(fract, color_white, color_red)

		local count = v.count
		if IsDiffrence and v.count > 0 then
			count = "+" .. count
		end

		MsgC(col, string.sub(v.class, 1, 38) .. string.rep(" ", 38 - v.class:len()) .. count .. "\n")
	end
end

function zclib.Entity.Print(limit)
	print(" ")
	MsgC(color_black, "-------------------------------------------" .. "\n")

	local domain = "SERVER"
	local domain_color = Color(108,163,255)
	if CLIENT then
		domain = "CLIENT"
		domain_color = Color(255,212,108)
	end
	MsgC(domain_color, "zcLib - Entity Count - " .. domain .. "\n")

	local nList, total = zclib.Entity.GetEntityCountSorted()

	if SERVER then
		MsgC(domain_color, "There are currently " .. total .. " entities on the server!" .. "\n")
	else
		MsgC(domain_color, "There are currently " .. total .. " entities in your game!" .. "\n")
	end

	PrintListColored(100,nList,false,limit)

	MsgC(color_black, "-------------------------------------------" .. "\n")

	local winnerClass , winnerCount , diffList = zclib.Entity.GetEntityCountDiffrence()

	if SERVER then
		MsgC(domain_color, "Since server start ("..zclib.util.FormatTime(CurTime()).." ago) the entity that increased the most in count is " .. winnerClass .." with " .. winnerCount .. "!" .. "\n")
	else
		MsgC(domain_color, "Since you joined ("..zclib.util.FormatTime(SysTime() - JoinTime).." ago) the entity that increased the most in count is " .. winnerClass .." with " .. winnerCount .. "!" .. "\n")
	end
	PrintListColored(50,diffList,true,limit)

	MsgC(color_black, "-------------------------------------------" .. "\n")
	print(" ")
end

if SERVER then
	util.AddNetworkString("zclib.Entity.Print")

	// Lets use the first playing joining as a init function
	zclib.Hook.Add("zclib_PlayerJoined", "zclib_PlayerJoined_EntityTracker", function(ply)

		local tbl = zclib.Entity.GetEntityCountSorted(1)
		StartEntityTrackState = table.Copy(tbl)

		zclib.Hook.Remove("zclib_PlayerJoined", "zclib_PlayerJoined_EntityTracker")
	end)
else
	net.Receive("zclib.Entity.Print", function(len, ply)
		local limit = net.ReadFloat()
		zclib.Entity.Print(limit)
	end)

	zclib.Hook.Add("zclib_PlayerInitialized", "zclib_PlayerInitialized_EntityTracker", function()
		timer.Simple(3,function()
			local tbl = zclib.Entity.GetEntityCountSorted(1)
			StartEntityTrackState = table.Copy(tbl)
			JoinTime = SysTime()
		end)
	end)
end

/*
	Prints out on how many entities did exist when the player join / server started
*/
concommand.Add("zclib_print_entities", function(ply, cmd, args)
	if zclib.Player.IsAdmin(ply) or not IsValid(ply) then
		local limit = tonumber(args[1] or 1)
		zclib.Entity.Print(limit)

		if SERVER and IsValid(ply) and zclib.Player.IsAdmin(ply) then
			net.Start("zclib.Entity.Print")
			net.WriteFloat(limit)
			net.Send(ply)
		end
	end
end)

if SERVER then

	local CachedEntityList = {}
	local NextCache = 0
	local NextID = 1
	local function CatchNextEntity(class)
		if CurTime() > NextCache then
			CachedEntityList = zclib.Entity.GetAll()
			NextCache = CurTime() + 15
		end

		local clean = {}
		for k,v in pairs(CachedEntityList) do
			if IsValid(v) and v:GetClass() == class then
				table.insert(clean,v)
			end
		end

		print("Found " .. #clean .. " " .. class)
		//PrintTable(clean)

		if NextID > #clean then NextID = 1 end

		print("Go to > " .. NextID)
		local target = clean[NextID]
		NextID = NextID + 1
		if IsValid(target) then
			return target
		else
			NextID = 0
		end
	end

	util.AddNetworkString("zclib.Entity.GoTo")
	net.Receive("zclib.Entity.GoTo", function(len, ply)
		if not zclib.Player.IsAdmin(ply) then return end
		local class = net.ReadString()

		if class == nil then return end
		local target = CatchNextEntity(class)
		if IsValid(target) then
			ply:SetPos(target:GetPos())
		end
	end)

	util.AddNetworkString("zclib.Entity.CleanUp")
	net.Receive("zclib.Entity.CleanUp", function(len, ply)
		if not zclib.Player.IsAdmin(ply) then return end
		local class = net.ReadString()
		if class == nil then return end

		for k,v in pairs(zclib.Entity.GetAll()) do
			if IsValid(v) and v:GetClass() == class then
				if class == "predicted_viewmodel" then
					local owner = v:GetOwner()
					print(tostring(v),"Owner: "..tostring(owner))
					if not IsValid(owner) then
						print(tostring(v), "Removed!")
						SafeRemoveEntityDelayed(v,0.1)
					end
				elseif class == "phys_lengthconstraint" then
					local parent = v:GetParent()
					print(tostring(v),"Parent: "..tostring(parent))

					print(tostring(v), "Removed!")
					SafeRemoveEntityDelayed(v,0.1)
				else
					print(tostring(v), "Removed!")
					SafeRemoveEntityDelayed(v,0.1)
				end
			end
		end
	end)
else
	/*
		Teleports the player to the specified class
	*/
	concommand.Add("zclib_goto_entityclass", function(ply, cmd, args)
		if zclib.Player.IsAdmin(ply) then
			local class = args[1]
			if class then
				net.Start("zclib.Entity.GoTo")
				net.WriteString(class)
				net.SendToServer()
			end
		end
	end)

	/*
		Cleanup entities
	*/
	concommand.Add("zclib_cleanup_entityclass", function(ply, cmd, args)
		if zclib.Player.IsAdmin(ply) then
			local class = args[1]
			if class then
				net.Start("zclib.Entity.CleanUp")
				net.WriteString(class)
				net.SendToServer()
			end
		end
	end)
end

concommand.Add("zclib_debug_entity", function(ply, cmd, args)
	if zclib.Player.IsAdmin(ply) then
		local tr = ply:GetEyeTrace()
		local ent = tr.Entity
		if IsValid(ent) then
			print("HammerID: ",tostring( ent:GetInternalVariable("hammerid")))
			print("Parent: ",tostring(ent:GetParent()))
			print("PhysObject: ",tostring(ent:GetPhysicsObject()))
			PrintTable(ent:GetKeyValues())
		end
	end
end)

--lua/zclib/generic/cl_blendmodes.lua:
return gluapack()()
--lua/zclib/generic/cl_hud.lua:
if SERVER then return end
zclib = zclib or {}
zclib.HUD = zclib.HUD or {}

// Returns the angles which makes the hud look at the players view pos
function zclib.HUD.GetLookAngles()
    local ang = Angle(0, LocalPlayer():EyeAngles().y - 90, 90)
    if LocalPlayer():InVehicle() then
        local veh = LocalPlayer():GetVehicle()
        if IsValid(veh) then
            local _, vang = veh:GetVehicleViewPosition(0)
            ang = Angle(0, vang.y - 90, 90)
        end
    end
    return ang
end

--lua/zclib/generic/cl_vgui.lua:
return gluapack()()
--lua/zclib/data/sh_data.lua:

/*

    This system will handle the loading / saving / sending / receiving and updating of Config data

*/

zclib = zclib or {}
zclib.Data = zclib.Data or {}

zclib.Data.Entrys = zclib.Data.Entrys or {}

function zclib.Data.RebuildListIDs(id)
	local entry = zclib.Data.Entrys[ id ]

	if not entry or not entry.Get then
		zclib.ErrorPrint("[" .. id .. "] > Data entry invalid!")

		return
	end

	local data = entry.Get()

	if not data then
		zclib.ErrorPrint("[" .. id .. "] > Returned Data invalid!")

		return
	end

	local list = {}

	for k, v in pairs(data) do
		if v == nil then continue end
		local uniqueid = v.uniqueid or zclib.util.GenerateUniqueID("xxxxxxxxxx")

		if istable(v) and v.uniqueid == nil then
			v.uniqueid = uniqueid
		end

		list[ uniqueid ] = k
	end

	entry.ListIDs = table.Copy(list)
	entry.OnIDListRebuild(list)
	zclib.Debug("zclib.Data.RebuildListIDs " .. entry.script .. " " .. id)
end

if CLIENT then

    // Called from interface after config change
    function zclib.Data.UpdateConfig(id)
        local entry = zclib.Data.Entrys[id]

        local e_String = util.TableToJSON(entry.Get())
        local e_Compressed = util.Compress(e_String)
        net.Start("zclib_Data_Update")
        net.WriteUInt(#e_Compressed,16)
        net.WriteData(e_Compressed,#e_Compressed)
        net.WriteString(id)
        net.SendToServer()

        zclib.Debug("zclib.Data.UpdateConfig " .. entry.script .. " " .. id .. " " .. tostring(LocalPlayer()))
    end

    // Called from SERVER after config UPDATE
    net.Receive("zclib_Data_Update", function(len)
        zclib.Debug_Net("zclib_Data_Update", len)

        local dataLength = net.ReadUInt(16)
        local dataDecompressed = util.Decompress(net.ReadData(dataLength))
        local config = util.JSONToTable(dataDecompressed)
        local id = net.ReadString()

        local entry = zclib.Data.Entrys[id]
        if entry == nil then
            zclib.Debug("zclib_Data_Update for " .. id .. " failed!")
            return
        end
		zclib.Debug("zclib_Data_Update " .. entry.script .. " " .. id .. " " .. tostring(LocalPlayer()) .. "[" .. (len / 8) .. " Bytes]")

        entry.OnReceived(config)

        zclib.Data.RebuildListIDs(id)
    end)

    for k,v in pairs(zclib.Data.Entrys) do
        zclib.Data.RebuildListIDs(k)
    end
else

	// Loads the Data Configs once the SERVER finished loading
	timer.Simple(2,function()
		zclib.Print("Setting up Data Entrys")
		for k,v in pairs(zclib.Data.Entrys) do

			if file.Exists(v.path, "DATA") then
				local config = file.Read(v.path,"DATA")
				if config then

					config = util.JSONToTable(config)

					zclib.Print(v.script .. " " .. k .. " - Data Config loaded!")

					v.OnLoaded(config)

					zclib.Data.UpdateConfig(k)
				end
			end

			zclib.Data.RebuildListIDs(k)
		end
	end)

    // Saves the Data config
    util.AddNetworkString("zclib_Data_Update")
    net.Receive("zclib_Data_Update", function(len,ply)
        zclib.Debug_Net("zclib_Data_Update", len)

        if zclib.Player.Timeout(nil,ply) == true then
            return
        end
        if zclib.Player.IsAdmin(ply) == false then
            return
        end

        local dataLength = net.ReadUInt(16)
        local dataDecompressed = util.Decompress(net.ReadData(dataLength))
        local config = util.JSONToTable(dataDecompressed)
        local id = net.ReadString()

        zclib.Data.Save(ply,id,config)
    end)

    function zclib.Data.Save(ply,id,config)
        local entry = zclib.Data.Entrys[id]

        zclib.Debug("zclib_Data_Update " .. entry.script .. " " .. id .. " " .. tostring(ply))

        entry.OnReceived(config)

		if entry.OnPreSave then config = entry.OnPreSave(config) end

        // Save to file
        file.Write(entry.path, util.TableToJSON(config,true))

        zclib.Data.RebuildListIDs(id)

        // Inform CLIENTS
        zclib.Data.UpdateConfig(id)
    end

	// Remove the whole file
	function zclib.Data.Remove(ply,id)
		if zclib.Player.IsAdmin(ply) == false then
			return
		end

		local entry = zclib.Data.Entrys[id]

		// Save to file
		file.Delete(entry.path)
	end

    // Informs all CLIENTS about the config change, This is usally only needed if the config gets changed mid game without a restart
    function zclib.Data.UpdateConfig(id)
        local entry = zclib.Data.Entrys[id]
        local e_String = util.TableToJSON(entry.Get())
        local e_Compressed = util.Compress(e_String)
        net.Start("zclib_Data_Update")
        net.WriteUInt(#e_Compressed,16)
        net.WriteData(e_Compressed,#e_Compressed)
        net.WriteString(id)
        net.Broadcast()

        entry.OnSend()
        zclib.Debug("zclib.Data.UpdateConfig " .. entry.script .. " " .. id)
    end

    function zclib.Data.Send(id,ply)
        local entry = zclib.Data.Entrys[id]
        if entry == nil then
            zclib.Debug("zclib.Data.Send Entry not found! " .. id .. tostring(ply))
            return
        end
        local data = entry.Get()
        if data == nil then
            zclib.Debug("zclib.Data.Send Data not found! " .. id .. tostring(ply))
            return
        end

        local e_String = util.TableToJSON(data)
        local e_Compressed = util.Compress(e_String)
        net.Start("zclib_Data_Update")
        net.WriteUInt(#e_Compressed,16)
        net.WriteData(e_Compressed,#e_Compressed)
        net.WriteString(id)
        net.Send(ply)

        entry.OnSend()

        zclib.Debug("zclib.Data.Send " .. entry.script .. " " .. id .. " " .. tostring(ply))
    end
end

function zclib.Data.Setup(id,script,path,Get,OnLoaded,OnSend,OnReceived,OnIDListRebuild,OnPreSave)
    zclib.Debug("zclib.Data.Setup " .. script .. " " .. id)
    zclib.Data.Entrys[id] = {
        // Returns the var of data
        Get = Get,

        // The name of the script
        script = script,

        // The path we save the data to
        path = path,

        // Run stuff after we loaded the data
        OnLoaded = OnLoaded,

        // Run stuff after we send the data
        OnSend = OnSend,

        // Run stuff after we received the data
        OnReceived = OnReceived,

        // Run stuff after we rebuild the id list
        OnIDListRebuild = OnIDListRebuild,

		// Can be used to modify the data before its getting saved
		OnPreSave = OnPreSave,
    }
end

--lua/zclib/inventory/sh_item.lua:
zclib = zclib or {}
zclib.ItemDefinition = zclib.ItemDefinition or {}
zclib.ItemDefinition.List = zclib.ItemDefinition.List or {}

/*
zclib.ItemDefinition.Register({
    class = "ent_class",

    // Overwrites the Items name
    Name = function(ItemData) return "name" end,
    or Name = "name",

    // Specifies the money value of the item
    Price = function(ItemData)
        local ItemID = isentity(ItemData) and ItemData:GetItemID() or ItemData.Data.ItemID
        local ItemAmount = isentity(ItemData) and ItemData:GetItemAmount() or ItemData.Amount
        return zmb.Item.GetPrice(ItemID) * ItemAmount
    end,

    // Gets called when the entity being picked up
    GetData = function(ent)
        return {ItemID = ent:GetItemID()}
    end,

    // Gets called when the entity being spawned in the world
    SetData = function(ItemData, ent)
        ent:SetItemID(ItemData.Data.ItemID)
        ent:SetItemAmount(ItemData.Amount)
    end,

    // Returns the value which makes the item identify between other items of the same class
    GetUniqueID = function(ItemData)
        return ItemData.Data.ItemID
    end,

    // Gets used to figure out the Amount var
    GetAmount = function(ItemData)
        return isentity(ItemData) and ItemData:GetItemAmount() or ItemData.Amount
    end,

    // Returns how many of those item classes which have the same GetUniqueID can be stacked
    GetStackLimit = function(ItemData)
        return 50
    end,

    // If defined overwrites the model
    Image = "materials/image.png",

    // Overwrites the Items model data
    Model = "model path",
    Skin = 0,
    BodyG = {},
    Color = Color(),
    Material = "",

    // This can be used to give the Item a custom background and color
    BG_Image = zclib.Materials.Get("star01"),
    BG_Color = color_red,

    // Gets called when the item being picked up
    OnPickup = function(ent,ply)

    end,

    // This will add the Drop/throw option in the optionbox
    OnDrop = function()
    end,

    // This will add the destroy option in the optionbox
    OnDestroy = function()
    end,

    // This will add the use option in the optionbox
    // NOTE This gets called on CLIENT first and returning will prevent it being called on SERVER afterwards
    OnUse = function(ply)

    end,
})
*/

// Registers a item definition
function zclib.ItemDefinition.Register(data)
    // Precache the model so util.IsValidModel works correctly for clients
    if data.Model and not isfunction(data.Model) then util.PrecacheModel(data.Model) end

    zclib.ItemDefinition.List[data.Class] = data
    //table.insert(zclib.ItemDefinition.List,data)
end

// Returns the Item definition by ID
function zclib.ItemDefinition.Get(class)
    return zclib.ItemDefinition.List[class]
end

// Only allow entity classes which have a
function zclib.ItemDefinition.IsAllowed(class)
    return zclib.ItemDefinition.List[class] ~= nil
end



function zclib.ItemDefinition.GetModel(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)
    if dat == nil then return SlotData.Model or "error.mdl" end

	if dat.Model and isfunction(dat.Model) then return dat.Model(Class,SlotData) or "error.mdl" end

    return dat.Model or SlotData.Model or "error.mdl"
end

function zclib.ItemDefinition.GetSkin(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)
    if dat == nil then return SlotData.Skin or 0 end

	if dat.Skin and isfunction(dat.Skin) then return dat.Skin(Class,SlotData) or 0 end

    return dat.Skin or SlotData.Skin or 0
end

function zclib.ItemDefinition.GetBodyGroups(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)

    if dat == nil then return SlotData.BodyG or {} end

	if dat.BodyG and isfunction(dat.BodyG) then return dat.BodyG(Class,SlotData) or {} end

    return dat.BodyG or SlotData.BodyG or {}
end

function zclib.ItemDefinition.GetColor(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)

    if dat == nil then return SlotData.Color or color_white end

	if dat.Color and isfunction(dat.Color) then return dat.Color(Class,SlotData) or color_white end

    return dat.Color or SlotData.Color or color_white
end

function zclib.ItemDefinition.GetMaterial(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)

    if dat == nil then return SlotData.Material or "" end

	if dat.Material and isfunction(dat.Material) then return dat.Material(Class,SlotData) or "" end

    return dat.Material or SlotData.Material or ""
end



function zclib.ItemDefinition.GetName(Class,SlotData)
    if zclib.config.PredefinedNames[Class] then return zclib.config.PredefinedNames[Class] end

    if SlotData and SlotData.Name then
        return SlotData.Name
    end

    // Is there a Item definition for that class and does it want to overwrite the name
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.Name then
        // The name can be defined as a function or as a string
        return isfunction(DefinitionData.Name) and DefinitionData.Name(SlotData) or DefinitionData.Name
    end

    return Class
end

function zclib.ItemDefinition.GetAmount(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetAmount then return DefinitionData.GetAmount(SlotData) end
    return 1
end

function zclib.ItemDefinition.GetData(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetData then return DefinitionData.GetData(SlotData) end
    return {}
end

function zclib.ItemDefinition.SetData(ent,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(ent:GetClass())
    if DefinitionData and DefinitionData.SetData then return DefinitionData.SetData(SlotData,ent) end
    return {}
end

function zclib.ItemDefinition.GetStackLimit(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetStackLimit then return DefinitionData.GetStackLimit(SlotData) end
end

function zclib.ItemDefinition.GetUniqueID(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetUniqueID then
        return DefinitionData.GetUniqueID(SlotData)
    end
end

// Compares two items and returns true if they are the same
function zclib.ItemDefinition.Compare(ItemData01, ItemData02)
    if ItemData01.Class ~= ItemData02.Class then return false end
    if zclib.ItemDefinition.GetUniqueID(ItemData01.Class, ItemData01) ~= zclib.ItemDefinition.GetUniqueID(ItemData02.Class, ItemData02) then return false end
    return true
end

function zclib.ItemDefinition.GetPrice(class,SlotData)

    // Is there a Item definition for that class and does it want to overwrite the name
    local DefinitionData = zclib.ItemDefinition.Get(class)
    if DefinitionData and DefinitionData.Price then
        // The name can be defined as a function or as a string
        return isfunction(DefinitionData.Price) and DefinitionData.Price(SlotData) or DefinitionData.Price
    end

    return SlotData.Price or 10
end

// Specifies if the Item has a body and can be dropped in the world if its just some lua funciton in Item form
function zclib.ItemDefinition.IsObject(Class)
    local DefinitionData = zclib.ItemDefinition.Get(Class)

    // A weapon is just a diffrent type of object
    if zclib.ItemDefinition.IsWeapon(Class) then return true end

    // We dont have this item registrated so it only can be a entity since powers need to be predefined
    if DefinitionData == nil then return true end

    return DefinitionData.IsObject == true
end

// Specifies that the entity class is of type weapon
function zclib.ItemDefinition.IsWeapon(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.IsWeapon ~= nil then return DefinitionData.IsWeapon end
    if SlotData then return SlotData.IsWeapon == true end
    return false
end

/*
	Returns the background image of the item slot
*/
function zclib.ItemDefinition.GetBG_Image(Class,SlotData)

    // Is there a Item definition for that class and does it want to overwrite the BG_Image
    local DefinitionData = zclib.ItemDefinition.Get(Class)
	if not DefinitionData then return end
	if not DefinitionData.BG_Image then return end

    // The BG_Image can be defined as a function or as a string
	if isfunction(DefinitionData.BG_Image) then
		return DefinitionData.BG_Image(SlotData)
	end

    return DefinitionData.BG_Image
end

/*
	Returns the background image color of the item slot
*/
function zclib.ItemDefinition.GetBG_Color(Class,SlotData)

    // Is there a Item definition for that class and does it want to overwrite the BG_Color
    local DefinitionData = zclib.ItemDefinition.Get(Class)
	if not DefinitionData then return end
	if not DefinitionData.BG_Color then return end

	// The BG_Color can be defined as a function or as a string
	if isfunction(DefinitionData.BG_Color) then
		return DefinitionData.BG_Color(SlotData)
	end

    return DefinitionData.BG_Color
end

--lua/zclib/inventory/sh_item_config.lua:
return gluapack()()
--lua/zclib/inventory/sh_item_config.lua:
zclib = zclib or {}
zclib.ItemDefinition = zclib.ItemDefinition or {}
zclib.ItemDefinition.List = {}

zclib.ItemDefinition.Register({
    Name = "HealthKit",
    Class = "item_healthkit",
    Model = "models/weapons/w_medkit.mdl",
    IsObject = true,
})

--addons/darkrpadvancedkeys/lua/autorun/advkeys_darkrpadds.lua:
function ADVKEYS_DarkRPAdds()
	if not CH_ADVKeys.Config.ALARM_AlwaysActive then
		DarkRP.createCategory{
			name = "Arac aksesuarlari",
			categorises = "entities",
			startExpanded = true,
			color = Color(0, 107, 0, 255),
			canSee = function(ply) return true end,
			sortOrder = 70,
		}
	
		AddEntity("Araba Alarmi", {
			ent = "adv_veh_alarm",
			model = "models/craphead_scripts/adv_keys/props/alarm.mdl",
			price = 10000,
			max = 2,
			category = "Arac aksesuarlari",
			cmd = "buyvehiclealarm"
		})
	end
end
hook.Add( "loadCustomDarkRPItems", "ADVKEYS_DarkRPAdds", ADVKEYS_DarkRPAdds )
--addons/aphone/lua/aphone/_libs/__header/sh_language.lua:
function aphone.L(key, ...)
    if !aphone.LanguageTable[key] then
        print("[APhone] There a error with the language's text : " .. key)
    end

    return ... and string.format( aphone.LanguageTable[key], ... ) or aphone.LanguageTable[key]
end
--addons/aphone/lua/aphone/_libs/_utilities/cl__lib.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/gamemodes_related/sh_basewars.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/gamemodes_related/sh_flux.lua:
// You won't find this gamemode online, it's my private gm
hook.Add("Flux_LoadedGamemode", "aphone_LoadGMFlux", function()
    aphone.Gamemode = {}

    function aphone.Gamemode.Afford(ply, amt)
        return ply:canAfford(amt)
    end

    function aphone.Gamemode.AddMoney(ply, amt)
        return !ply:ChangeMoney(amt)
    end

    function aphone.Gamemode.Format(amt)
        return Flux:FormatMoney(amt)
    end

    function aphone.Gamemode.GetMoney(ply)
        return ply:GetMoney()
    end
end)

--addons/aphone/lua/aphone/_libs/panels/cl_applist.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/panels/cl_call.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/call/cl_init.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/contacts/cl_contacts.lua:
-- Load/Variables
sql.Query("CREATE TABLE IF NOT EXISTS aphone_Contacts(id INTEGER, name TEXT, ip TEXT)")
aphone.Contacts = aphone.Contacts or {}
local c = {}

for k, v in ipairs(sql.Query("SELECT id, name FROM aphone_Contacts WHERE ip = " .. sql.SQLStr(game.GetIPAddress())) or {}) do
    c[tonumber(v.id)] = v.name
end

-- Functions
function aphone.Contacts.GetName(userid)
    return c[userid]
end

function aphone.GetName(e)
    local n = aphone.Contacts.GetName(e)
    if n then return n end

    local is_ply = IsValid(e) and e:IsPlayer()

    if is_ply then
        return aphone.never_realname and e:aphone_GetNumber() or e:Nick()
    end

    return aphone.GetNumber(is_ply and e:aphone_GetID() or e)
end

function aphone.Contacts.Add(id, name)
    if c[id] then return true end
    sql.Query("INSERT INTO aphone_Contacts(id, name, ip) VALUES(" .. id .. ", " .. sql.SQLStr(name) .. "," .. sql.SQLStr(game.GetIPAddress()) .. ")")
    c[id] = name
end

function aphone.Contacts.ChangeName(id, name)
    if not c[id] then return end
    sql.Query("UPDATE aphone_Contacts SET name = " .. sql.SQLStr(name) .. " WHERE ip = " .. sql.SQLStr(game.GetIPAddress()) .. " AND id = " .. id)
    c[id] = name
end

function aphone.Contacts.Remove(id)
    if not c[id] then return end
    sql.Query("DELETE FROM aphone_Contacts WHERE id = " .. id .. " AND ip = " .. sql.SQLStr(game.GetIPAddress()) .. ")")
    c[id] = nil
end

function aphone.Contacts.GetContacts()
    return c
end
--addons/aphone/lua/aphone/apps/contacts/cl_main.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/settings/cl_main.lua:
local APP = {}

APP.name = aphone.L("Options")
APP.icon = "akulla/aphone/app_settings.png"
APP.Default = true // You shouldn't use this flag, it's only for "system app" that got a special display at the bottom of the menu

local stencil_clr = Color(1, 1, 1, 1)
local clr_blue = Color(93,207,202)


function APP:Open(main, main_x, main_y)
    local color_black1 = aphone:Color("Black1")
    local color_black2 = aphone:Color("Black2")
    local color_black3 = aphone:Color("Black3")
    local color_white120 = aphone:Color("Text_White120")
    local color_white180 = aphone:Color("Text_White180")
    local color_white = aphone:Color("Text_White")
    local color_orange = aphone:Color("Text_Orange")
    local font_mediumheader = aphone:GetFont("MediumHeader")
    local font_big = aphone:GetFont("Roboto80")
    local color_gps = aphone:Color("GPS_Line")
    local font_bold = aphone:GetFont("Roboto45_700")

    local local_player = LocalPlayer()
    local local_playernick = local_player:Nick()

    function main:Paint(w, h)
        surface.SetDrawColor(color_black2)
        surface.DrawRect(0,0,w,h)
    end

    local top_app = vgui.Create("DPanel", main)
    top_app:Dock(TOP)
    top_app:DockMargin(main_y * 0.03, main_y * 0.05, main_y * 0.03, 0)
    top_app:SetTall(main_y * 0.075)
    top_app:SetPaintBackground(false)

    local avatar = vgui.Create("aphone_CircleAvatar", top_app)
    avatar:Dock(LEFT)
    avatar:SetWide(top_app:GetTall())
    avatar:SetPlayer(local_player, 128)

    local local_num = local_player:aphone_GetNumber()

    function top_app:Paint(w, h)
        draw.SimpleText(local_playernick, font_mediumheader, top_app:GetTall() * 1.25, h / 2, color_white, 0, TEXT_ALIGN_BOTTOM)
        draw.SimpleText(local_num, font_mediumheader, top_app:GetTall() * 1.25, h / 2, color_white120, 0, TEXT_ALIGN_TOP)
    end

    local select_scroll = vgui.Create("DPanel", main)
    select_scroll:Dock(TOP)
    select_scroll:SetTall(main_y * 0.10)
    select_scroll:SetPaintBackground(false)
    select_scroll:DockMargin(0, main_y * 0.01, 0, 0)

    local main_scroll = vgui.Create("DScrollPanel", main)
    main_scroll:SetPos(main_x * 0.07, main_y * 0.24)
    main_scroll:SetSize(main_x * 0.86, main_y * 0.785 - main_y * 0.05)
    main_scroll:aphone_PaintScroll()

    // Used later for sliders params
    local wide = (main_x - aphone.GUI.ScaledSizeX(160) - main_y * 0.06) / 3

    surface.SetFont(font_mediumheader)

    for k, v in pairs(aphone.Params) do
        local cat_title = main_scroll:Add("DLabel")
        cat_title:Dock(TOP)
        cat_title:SetFont(font_mediumheader)
        cat_title:SetText(aphone.L(k))
        cat_title:SetTextColor(color_orange)
        cat_title:DockMargin(aphone.GUI.ScaledSize(5, 10, 0, 5))
        cat_title:Toggle()
        cat_title:SetAutoStretchVertical(true)

        local listpanel = vgui.Create("DPanel", main_scroll)
        listpanel:Dock(TOP)
        listpanel:DockMargin(aphone.GUI.ScaledSize(0, 5, 0, 0))
        listpanel:SetTall(0)

        function listpanel:Paint(w, h)
            draw.RoundedBox(8, 0, 0, w, h, color_black3)
        end

        for i, j in pairs(v) do
            local sub_panel = vgui.Create("DPanel", listpanel)
            sub_panel:Dock(TOP)
            sub_panel:SetPaintBackground(false)

            local sub_txt = vgui.Create("DLabel", sub_panel)
            sub_txt:SetMouseInputEnabled(true)
            sub_txt:SetTextColor(color_white180)
            sub_txt:SetFont(font_mediumheader)
            sub_txt:SetTall(select(2, sub_txt:GetContentSize()) * 1.5)
            sub_txt:SetText(j.full_name)
            sub_txt:DockMargin(main_y * 0.02, 0, 0, 0)
            sub_txt:SetIsToggle(true)
            sub_txt:Dock(TOP)

            if j.var_type == "string" or j.var_type == "num" then
                local panel_but = vgui.Create("DLabel", sub_panel)
                panel_but:Dock(TOP)
                panel_but:SetTall(sub_txt:GetTall())
                panel_but:SetFont(font_mediumheader)
                panel_but:SetTextColor(color_white)
                panel_but:SetIsToggle(true)
                panel_but:DockMargin(main_y * 0.02, 0, 0, 0)
                panel_but:SetText(aphone:GetParameters(k, i, j.def))
                panel_but:SetMouseInputEnabled(true)

                function panel_but:DoClick()
                    local text_entry = self:Phone_AskTextEntry(self:GetText())
                    text_entry:SetNumeric(j.var_type == "num")
                end

                function sub_txt:DoClick()
                    if !self:GetToggle() then
                        sub_panel:SetTall(sub_txt:GetTall() + panel_but:GetTall())
                        listpanel:SetTall(listpanel:GetTall() + panel_but:GetTall())
                    else
                        sub_panel:SetTall(sub_txt:GetTall())
                        listpanel:SetTall(listpanel:GetTall() - panel_but:GetTall())
                    end

                    self:Toggle()
                end

            elseif j.var_type == "color" then
                local panel_but = vgui.Create("DPanel", sub_panel)
                panel_but:Dock(TOP)
                panel_but:SetTall(sub_txt:GetTall() * 0.5)
                panel_but:SetPaintBackground(false)

                sub_txt:SetText(aphone.L(i))

                local clr = aphone:Color(i)

                for a, b in ipairs({"r", "g", "b"}) do
                    local p = vgui.Create("DSlider", panel_but)
                    p:Dock(LEFT)
                    p:SetWide( wide )
                    p:DockMargin(aphone.GUI.ScaledSize(20, 0, 20, 0))
                    p:SetSlideX(clr[b] / 255)

                    function p:Paint(w, h)
                        draw.RoundedBox(4, 0, h / 2-4, w, 8, color_white)
                        draw.RoundedBox(4, 0, h / 2-4, w * self:GetSlideX(), 8, color_orange)
                    end
                    function p.Knob:Paint(w, h) end

                    function p:Think()
                        if self:IsEditing() then
                            local new_clr = table.Copy(aphone:Color(i))
                            new_clr[b] = self:GetSlideX() * 255
                            aphone.Clientside.SaveSetting(i, Color(new_clr.r, new_clr.g, new_clr.b, new_clr.a or 255))
                        end
                    end
                end

                function sub_txt:DoClick()
                    if !self:GetToggle() then
                        sub_panel:SetTall(sub_txt:GetTall() + panel_but:GetTall())
                        listpanel:SetTall(listpanel:GetTall() + panel_but:GetTall())
                    else
                        sub_panel:SetTall(sub_txt:GetTall())
                        listpanel:SetTall(listpanel:GetTall() - panel_but:GetTall())
                    end

                    self:Toggle()
                end

                local reset_but = vgui.Create("DButton", sub_txt)
                reset_but:Dock(RIGHT)
                reset_but:SetWide(sub_txt:GetTall())
                reset_but:SetText("")

                function reset_but:Paint(w, h)
                    if self:IsHovered() or sub_txt:IsHovered() then
                        draw.SimpleText("j", aphone:GetFont("SVG_25"), w / 2, h / 2, color_white, 1, 1)
                    end
                end

                function reset_but:DoClick()
                    local default_clr = aphone:DefaultClr(i)
                    aphone.Clientside.SaveSetting(i, default_clr)

                    for a, b in ipairs({"r", "g", "b"}) do
                        panel_but:GetChildren()[a]:SetSlideX(default_clr[b] / 255)
                    end
                end
            elseif j.var_type == "bool" then
                sub_txt:SetTextColor(aphone:GetParameters(k, i, false) and color_white or color_white120)

                function sub_txt:DoClick()
                    local new_value = aphone:ChangeParameters(k, i, !aphone:GetParameters(k, i, false))
                    self:SetTextColor(new_value and color_white or color_white120)
                end
            elseif j.var_type == "sound" then
                -- same as bool, just disable himself after a change
                function sub_txt:DoClick()
                    self:SetTextColor(aphone:ChangeParameters(k, i, !aphone:GetParameters(k, i, false)) and color_white or color_white120)
                end

                hook.Add("APhone_SettingChange", i, function(cat, short_name)
                    if IsValid(sub_txt) then
                        if short_name != i then
                            aphone:ChangeParameters(k, i, false, true)
                        end
                        sub_txt:SetTextColor(short_name == i and color_white or color_white120)
                    end
                end)

                sub_txt:SetTextColor(aphone:GetParameters(k, i, false) and color_white or color_white120)
            end

            sub_panel:SetTall(sub_txt:GetTall())
        end

        // SizeToContent and children not working
        local height = 0

        for i, j in ipairs(listpanel:GetChildren()) do
            height = height + j:GetTall()
        end

        listpanel:SetTall(height)
    end

    local main_scrollbg = vgui.Create("DPanel", main)
    main_scrollbg:SetPos(main_x * 1.07, main_y * 0.25)
    main_scrollbg:SetSize(main_x * 0.86, main_y * 0.76 - main_y * 0.05)

    function main_scrollbg:Paint(w, h)
        draw.RoundedBox(8, 0, 0, w, h, color_black3)
    end

    local main_scrollbg_scroll = vgui.Create( "DScrollPanel", main_scrollbg ) // Create the Scroll panel
    main_scrollbg_scroll:Dock( FILL )
    main_scrollbg_scroll:DockMargin(8, 8, 8, 8)
    main_scrollbg_scroll:aphone_PaintScroll()

    local main_scrollbg_layout = main_scrollbg_scroll:Add("DIconLayout")
    main_scrollbg_layout:Dock(FILL)
    main_scrollbg_layout:SetSpaceX(aphone.GUI.ScaledSize(10))
    main_scrollbg_layout:SetSpaceY(main_scrollbg_layout:GetSpaceX())

    local size_bgw = main_scrollbg:GetWide() / 3 - 12 - main_scrollbg_layout:GetSpaceX() / 2
    local size_bgh = size_bgw * 2.1375
    local rb = aphone.GUI.RoundedBox(0, 0, size_bgw, size_bgh, 8)

    local actual_bg = aphone.Clientside.GetSetting("Background")

    local function addbg(v)
        local bg = main_scrollbg_layout:Add("DButton")
        bg:SetSize(size_bgw, size_bgh)
        bg:SetText("")

        function bg:Paint(w, h)
            local mat = aphone.GetImgurMat(v)

            if mat and !mat:IsError() then
                aphone.Stencils.Start()
                    surface.SetDrawColor(stencil_clr)
                    surface.DrawPoly(rb)
                aphone.Stencils.AfterMask(false)
                    render.SetStencilPassOperation(STENCILOPERATION_KEEP)

                    surface.SetMaterial(mat)
                    surface.SetDrawColor(color_white)
                    surface.DrawTexturedRect(0, 0, w, h)

                    if actual_bg == v then
                        draw.SimpleText("r", aphone:GetFont("SVG_60"), w / 2, h / 2, color_white, 1, 1)
                    end
                aphone.Stencils.End()
            else
                // Loading animation
                draw.RoundedBox(8, 0, 0, w, h, color_black2)

                if !self.circle1 then
                    self.circle1 = aphone.GUI.GenerateCircle(w / 2, h / 2, w / 4)
                    self.circle2 = aphone.GUI.GenerateCircle(w / 2, h / 2, w / 4 - 4)
                end

                local rad = CurTime() * 6

                aphone.Stencils.Start()
                    draw.NoTexture()
                    surface.SetDrawColor(stencil_clr)
                    surface.DrawPoly(self.circle1)
                aphone.Stencils.AfterMask(false)
                    draw.NoTexture()
                    surface.DrawPoly(self.circle2)

                    render.SetStencilPassOperation(STENCILOPERATION_KEEP)

                    surface.SetDrawColor(color_white120)
                    surface.DrawRect(0, 0, w, h)

                    surface.SetDrawColor(color_gps)
                    draw.SimpleText("d", aphone:GetFont("SVG_40"), math.cos( rad ) * (w / 4) + w / 2, math.sin(rad) * (w / 4) + h / 2, color_gps, 1, 1)
                aphone.Stencils.End()
            end
        end

        function bg:DoClick()
            local is_bg = aphone.Clientside.GetSetting("Background") == v
            aphone.Clientside.SaveSetting("Background", !is_bg and v or nil)
            actual_bg = aphone.Clientside.GetSetting("Background")
            hook.Run("APhone_ChangedBackground")
        end
    end

    for k, v in ipairs(aphone.backgrounds_imgur) do
        addbg(v)
    end

    for k, v in ipairs(aphone.Clientside.GetSetting("userbg", {})) do
        addbg(v)
    end

    local bg = main_scrollbg_layout:Add("DButton")
    bg:SetSize(size_bgw, size_bgh)
    bg:SetText("+")
    bg:SetFont(font_big)
    bg:Phone_AlphaHover()

    function bg:Paint(w, h)
        draw.RoundedBox(8, 0, 0, w, h, color_black2)
    end

    function bg:DoClick()
        local bigpnl = vgui.Create("DButton", main)
        bigpnl:SetSize(main_x, main_y)
        bigpnl:SetPaintBackground(false)
        bigpnl:SetText("")
        bigpnl.open = CurTime()
    
        local subpnl = vgui.Create("DPanel", bigpnl)
        subpnl:SetPos(0, main_y)
        subpnl:SetSize(main_x, main_y*0.30)
        subpnl:MoveTo(0, main_y - subpnl:GetTall(), 0.5, 0, 0.2)
    
        function bigpnl:DoClick()
            bigpnl.closing = CurTime()
            subpnl:MoveTo(0, main_y, 0.5, 0, 0.2, function()
                bigpnl:Remove()
            end)
        end

        function bigpnl:Paint(w, h)
            render.SetStencilEnable(false)
            local ratio = !bigpnl.closing and (CurTime() - bigpnl.open)*3 or 1 - (CurTime() - bigpnl.closing)*3
    
            if ratio > 1 then
                ratio = 1
            elseif ratio < 0 then
                ratio = 0
            end
    
            surface.SetDrawColor(0, 0, 0, 230 * ratio)
            surface.DrawRect(0, 0, w, h)
        end
    
        function subpnl:Paint(w, h)
            draw.RoundedBoxEx(32, 0, 0, w, h, clr_blue, true, true, false, false)
            draw.RoundedBoxEx(32, 0, 10, w, h, color_black1, true, true, false, false)
        end

        local title = vgui.Create("DLabel", subpnl)
        title:Dock(TOP)
        title:SetText("Imgur ID")
        title:SetFont(font_bold)
        title:SetContentAlignment(5)
        title:DockMargin(0, main_y*0.03, 0, 0)
        title:SetTextColor(clr_blue)
        title:SetAutoStretchVertical(true)

        local imgur_entry = vgui.Create("DLabel", subpnl)
        imgur_entry:Dock(TOP)
        imgur_entry:DockMargin(main_x*0.1, main_y*0.02, main_x*0.1, 0)
        imgur_entry:SetFont(font_mediumheader)
        imgur_entry:SetText("ID")
        imgur_entry:SetMouseInputEnabled(true)
        imgur_entry:SetAutoStretchVertical(true)
        imgur_entry:Phone_AlphaHover()
    
        function imgur_entry:DoClick()
            top_pnl:SetText(top_pnl:GetText() == "n" and "" or "n")
        end
    
        function imgur_entry:Paint(w, h)
            surface.SetDrawColor(imgur_entry:GetTextColor())
            surface.DrawLine(0, h-1, w, h-1)
        end
    
        function imgur_entry:DoClick()
            self:Phone_AskTextEntry(self:GetText(), 12)
        end

        local imgur_valid = vgui.Create("DLabel", subpnl)
        imgur_valid:Dock(FILL)
        imgur_valid:SetText("r")
        imgur_valid:SetFont(aphone:GetFont("SVG_40"))
        imgur_valid:SetContentAlignment(5)
        imgur_valid:Phone_AlphaHover()
        imgur_valid:SetMouseInputEnabled(true)
    
        function imgur_valid:DoClick()
            local self_bg = aphone.Clientside.GetSetting("userbg", {})
            local imgur_id = imgur_entry:GetText()
            local match = string.match(imgur_id or "", "[%a%d]+")

            if !self_bg[imgur_id] and imgur_id and imgur_id != "ID" and match and match == imgur_id then
                table.insert(self_bg, imgur_id)
                aphone.Clientside.SaveSetting("userbg", self_bg)
                addbg(imgur_id)
            end
            bigpnl:DoClick()
        end

        bigpnl:aphone_RemoveCursor()
    end

    local select_scroll_switchmain = vgui.Create("DButton", select_scroll)
    select_scroll_switchmain:Dock(LEFT)
    select_scroll_switchmain:SetWide(main_x / 2)
    select_scroll_switchmain:SetFont(aphone:GetFont("SVG_40"))
    select_scroll_switchmain:SetText("C")
    select_scroll_switchmain:Phone_AlphaHover()
    select_scroll_switchmain:SetPaintBackground(false)
    select_scroll_switchmain:TDLib()
    select_scroll_switchmain:BarHover(aphone:Color("mat_orange"))

    function select_scroll_switchmain:DoClick()
        main_scroll:MoveTo(main_x * 0.07, main_y * 0.24, 0.5, 0, 0.5)
        main_scrollbg:MoveTo(main_x * 1.07, main_y * 0.25, 0.5, 0, 0.5)
    end

    local select_scroll_switchbg = vgui.Create("DButton", select_scroll)
    select_scroll_switchbg:Dock(FILL)
    select_scroll_switchbg:SetFont(aphone:GetFont("SVG_40"))
    select_scroll_switchbg:SetText("Y")
    select_scroll_switchbg:Phone_AlphaHover()
    select_scroll_switchbg:SetPaintBackground(false)
    select_scroll_switchbg:TDLib()
    select_scroll_switchbg:BarHover(aphone:Color("mat_orange"))

    function select_scroll_switchbg:DoClick()
        main_scroll:MoveTo(-main_x * 1.07, main_y * 0.24, 0.5, 0, 0.5)
        main_scrollbg:MoveTo(main_x * 0.07, main_y * 0.25, 0.5, 0, 0.5)
    end

    main:aphone_RemoveCursor()
end

aphone.RegisterApp(APP)






/*

function dial:DoClick()
    local button_call = vgui.Create("DLabel", dial_keys)
    button_call:Dock(FILL)
    button_call:SetText("o")
    button_call:SetFont(dial:GetFont())
    button_call:SetContentAlignment(5)
    button_call:Phone_AlphaHover()
    button_call:SetVisible(false)
    button_call:SetMouseInputEnabled(true)

    function button_call:DoClick()
        if !IsValid(already_num[dial_number:GetText()]) then return end

        net.Start("aphone_Phone")
            net.WriteUInt(1, 4)
            net.WriteEntity(already_num[dial_number:GetText()])
        net.SendToServer()

        dial_bigpanel:DoClick()
    end

    local roboto40 = aphone:GetFont("Roboto40")
    local pnl_0

    local remove = vgui.Create("DButton", pnl_0)
    remove:SetSize(main_x*0.2, main_y*0.25 / 3)
    remove:SetText("<")
    remove:SetPaintBackground(false)
    remove:SetFont(roboto40)
    remove:Phone_AlphaHover()
    remove:Dock(RIGHT)

    function remove:DoClick()
        if tonumber(number) == 0 then return end
        local formatted = string.sub(tostring(number), 1, -2)
        formatted = (formatted != "" and formatted or "0")

        number = tonumber(formatted)
        dial_number:SetText(aphone.FormatNumber(formatted))

        if already_num[dial_number:GetText()] then
            dial_name:SetText(aphone.GetName(already_num[dial_number:GetText()]))
            button_call:SetVisible(true)
        else
            dial_name:SetText(lang_unknown)
            button_call:SetVisible(false)
        end
    end

    dial_bigpanel:aphone_RemoveCursor()
end
*/
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_controls.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_integrallaser.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_wepcamo_thunderstorm.lua:
att.PrintName = "Thunderstorm"
att.Icon = Material("entities/mw2_wepcamo_thunderstorm.png", "smooth"
)
att.Description = "Flashy.\nUnofficial."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "mw2_wepcamo"
att.Free = true

att.ActivateElements = {"wepcamo-thunderstorm"}

att.SortOrder = 12 *-1
--lua/arccw/shared/attachments/optic_mw2_tuna.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_ammo_blank.lua:
att.PrintName = "\"BLNK\" Blank Cartridges"
att.AbbrevName = "\"BLNK\" Blanks"
att.SortOrder = -2
att.Icon = Material("entities/att/arccw_uc_ammo_blank.png", "mips smooth")
att.Description = [[Cartridges sealed without a solid projectile. Performance is otherwise identical. Used when the muzzle report of a gunshot is necessary without the bullet, such as in filming, ceremonies, sports, and combat training.

In real life, blanks are not harmless. The muzzle shockwave or discharged wadding can and have killed people who do not exercise standard firearm precautions.]]
att.Desc_Pros = {
    "uc.infiniteammo"
}
att.Desc_Cons = {
    "uc.noprojectile"
}
att.Desc_Neutrals = {
}
att.Slot = {"uc_ammo","ud_ammo_shotgun"}

att.SortOrder = -9001
att.AutoStats = true
att.NotForNPCs = true

att.Override_Num = 0
att.Override_Num_Priority = 9001
att.Override_InfiniteAmmo = true

att.Override_UC_ShellColor = Color(0.3 * 255, 0.3 * 255, 0.3 * 255)

--lua/arccw/shared/attachments/uc_ammo_sg_baton.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_charm_urbancharm_ordinance.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_choke_rifled.lua:
att.PrintName = "Rifled Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A special choke that improves the aerodynamics of slug rounds. It is not as effective as a fully rifled barrel."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "uc.reqslug"
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_AccuracyMOA = .7
att.Mult_HipDispersion = 1.15
att.Mult_Recoil = 1.05

att.RequireFlags = {"uc_slug"}
att.GivesFlags = {"uc_choke_rifled"}
att.ExcludeFlags = {"uc_fg_sg_rifled"}
--lua/arccw/shared/attachments/uc_fg_longrifling.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_fg_lubedparts.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_fg_match_single.lua:
att.PrintName = "Match Trigger"

att.Icon = Material("entities/att/arccw_uc_matchgradetrigger.png", "mips smooth")
att.Description = "Hair trigger for competition shooting allows crisp trigger pulls, improving first shot performance."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"uc_fg_singleshot"}
att.SortOrder = 2
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() or wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = .75

--[[]
att.M_Hook_Mult_AccuracyMOA = function(wep, data)
    if wep:GetBurstCount() == 0 then
        data.mult = data.mult * 0.5
    end
end
]]

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"

att.Ignore = true
--lua/arccw/shared/attachments/uc_fg_slamfire.lua:
att.PrintName = "Slamfire Kit"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "Reckless removal of trigger safety features allows shells to fire immediately upon being cycled while the trigger is held. This enables rapid \"rack and fire\" behavior similar to old trench guns, but impacts weapon performance."
att.Desc_Pros = {
    "uc.slam"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
    if wep:GetBuff_Override("Override_ManualAction", wep.ManualAction) then return end
    for i, v in pairs(wep.Firemodes) do
        if !v then continue end
        if v.Mode and v.Override_ManualAction then
            return
        end
    end
    return false
end

att.Mult_Recoil = 1.2
att.Mult_RecoilSide = 1.5

att.Override_Firemodes = {
    {
        Mode = 2,
        PrintName = "fcg.slam",
        Override_ManualAction = true,
    },
    {
        Mode = 0
    }
}
att.Override_Firemodes_Priority = 11 -- higher than spas-12 manual

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_grip_handstop.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_grip_mafg2.lua:
att.PrintName = "MAGPUL AFG-2 Angled Fore Grip"
att.AbbrevName = "Magpul Angled Foregrip"
att.Icon = Material("entities/att/acwatt_uc_grip_magpul_afg2.png", "mips smooth")
att.Description = "An ergonomically angled grip surface reduces wrist strain, increasing maneuverability."

att.SortOrder = 1201

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, -0.75)

att.Model = "models/weapons/arccw/atts/uc_magpul_afg2.mdl"
att.ModelSkin = 1

att.Mult_SightTime = 0.8
att.Mult_Sway = 1.15
att.Mult_Recoil = 1.20
--lua/arccw/shared/attachments/uc_grip_tdvfg.lua:
att.PrintName = "TangoDown Vertical Foregrip"
att.AbbrevName = "TangoDown Stubby Foregrip"
att.Icon = Material("entities/att/acwatt_uc_grip_tdvfg.png", "mips smooth")
att.Description = "Write me up, I dare you."

att.SortOrder = 1400

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/weapons/arccw/atts/uc_tdvfg1.mdl"

att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.06
att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.1

att.Override_HoldtypeActive = "smg"
att.Override_HoldtypeActive_Priority = 2

att.Ignore = true
--lua/arccw/shared/attachments/uc_muzzle_supp_ga9.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_muzzle_supp_salvo.lua:
att.PrintName = "Salvo 12 Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_salvo.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nLow profile and relatively lightweight, with no negative ballistic impact."
att.Desc_Neutrals = {"uc.muzzleblocking", "uc.exclusive.shotgun"}

att.AutoStats = true
att.Slot = {"muzzle_shotgun","muzzle"}

att.GivesFlags = {"muzzleblocking"}
att.ExcludeFlags = {"nomuzzleblocking"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_salvo.mdl"
att.ModelOffset = Vector(-1, 0, -0.12)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.05
att.Mult_ShootVol = 0.8

att.Add_BarrelLength = 8
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_holosun2.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_nvis.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_pso1.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_powder_low.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tac_anpeq2.lua:
att.PrintName = "Insight Technologies ATPIAL AN/PEQ-2"
att.AbbrevName = "AN/PEQ-2"
att.Icon = Material("entities/att/acwatt_uc_tac_anpeq2.png", "mips smooth")
att.Description = "Large flashlight and laser module for rifles, with a stronger, more effective laser that also aids target acquisition.\nThe laser and flashlight can be toggled individually."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac"}
att.SortOrder = 20+3

att.Model = "models/weapons/arccw/atts/uc_anpeq2.mdl"
att.ModelOffset = Vector(0, 0.01, 0.35)
att.OffsetAng = Angle(0, 0,180)
att.ModelScale = Vector(1.2, 1.2, 1.2)
att.ModelSkin = 1

att.Laser = false
att.LaserStrength = 3.5 / 5
att.LaserBone = "laser"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.Mult_SightTime = 1.1
att.Mult_SightedSpeedMult = 0.9
att.Mult_MoveSpeed = 1

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 512 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 235, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 2
att.FlashlightBone = "laser"

att.ToggleStats = {
    {
        PrintName = "Laser",
        Laser = true,
        Mult_HipDispersion = 0.7,
        Mult_MoveDispersion = 0.8,
        Mult_SightTime = .9,
        Mult_SightedSpeedMult = .75
    },
    {
        PrintName = "Both",
        Laser = true,
        Flashlight = true,
        Mult_HipDispersion = 0.7,
        Mult_MoveDispersion = 0.8,
        Mult_SightTime = .9,
        Mult_SightedSpeedMult = .75
    },
    {
        PrintName = "Light",
        Flashlight = true,
    },
    {
        PrintName = "Off",
    }
}
--lua/arccw/shared/attachments/uc_tac_laser_green.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tac_tlr2hl.lua:
att.PrintName = "TLR-2 HL Pistol Flashlight"
att.AbbrevName = "TLR-2 HL"
att.Icon = Material("entities/att/acwatt_uc_tac_tlr2hl.png", "mips smooth")
att.Description = "A combined flashlight and laser module for pistols.\nThe laser and flashlight can be toggled individually."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac","tac_pistol"}
att.SortOrder = 20+4

att.Model = "models/weapons/arccw/atts/uc_tlr2hl.mdl"
att.ModelOffset = Vector(0.75, 0, -0.1)
att.OffsetAng = Angle(0,0,0)
att.ModelScale = Vector(0.75, 0.75, 0.75)

att.Laser = false
att.LaserStrength = 2 / 5
att.LaserBone = "laser"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.Mult_SightTime = 1.05
att.Mult_SightedSpeedMult = 0.95
att.Mult_MoveSpeed = 1

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 1024 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 235, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 0.5
att.FlashlightBone = "laser"

att.ToggleStats = {
    {
        PrintName = "Laser",
        Laser = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Both",
        Laser = true,
        Flashlight = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Light",
        Flashlight = true,
    },
    {
        PrintName = "Off",
    }
}
--lua/arccw/shared/attachments/uc_tp_bruiser.lua:
att.PrintName = "Bruiser"

att.Icon = Material("entities/att/arccw_uc_tp_bruiser.png", "smooth mips")
att.Description = "With the proper technique and upper body strength, you can more quickly and effectively use your weapon as a bludgeon."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 19

att.Mult_MeleeDamage = 1.35
att.Mult_MeleeTime = .67

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_ubgl_gp25.lua:
att.PrintName = "GP-25 Underbarrel Grenade Launcher"
att.AbbrevName = "GP-25 Grenade Launcher"
att.Icon = Material("entities/att/acwatt_uc_ubgl_gp25.png", "mips smooth")
att.Description = "Single-shot long-barreled underbarrel grenade launcher designed for the AK. The VOG-25 caseless projectiles can be reloaded faster, but hold less propellant and explosive yield."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "uc_ubgl"
att.ExcludeFlags = {"uc_noubgl"}

att.LHIK = true

att.ModelOffset = Vector(0.2, 0, -1.2)
att.Model = "models/weapons/arccw/atts/uc_ubgl_gp25_2.mdl"

att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""

att.UBGL = true

att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "muzzleflash_m79"
att.UBGL_Ammo = "smg1_grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.LHIK_GunDriver = 2
att.LHIK_CamDriver = nil--3

local pretty = GetConVar("arccw_uc_infiniteubwammo")

att.Hook_ModifyAttBodygroups = function(wep, data)
    if wep:GetBuff_Override("UC_UseClassicGP25Mount") then
        data.element.Model:SetBodygroup(1, 1)
    end
end

local function Ammo(wep)
    return (pretty:GetBool() and 9999 or wep:GetOwner():GetAmmoCount("smg1_grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "arccw_uc_40mm_he"

    local vel, dmg = 2500, 130

    -- hacky
    if class == "arccw_uc_40mm_he" then
        vel = vel * 0.85
        dmg = dmg * 0.75
    --elseif class == "arccw_uc_40mm_stun" then
    --    dmg = dmg * 0.6
    --elseif class == "arccw_uc_40mm_incendiary" then
    --    vel = vel * 0.75
    end

    local proj = wep:FireRocket(class, vel)
    if SERVER then
        proj.Damage = dmg -- lower than the m79 (200) for balance reasons
    end
    wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
    wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
    wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.2},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.0},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.3},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.9},
        })
    end

    local reserve = Ammo(wep)
    reserve = reserve + wep:Clip2()
    local clip = 1
    local load = math.Clamp(clip, 0, reserve)
    if (!pretty:GetBool()) then
        wep:GetOwner():RemoveAmmo(1, "smg1_grenade")
    end
    wep:SetClip2(load)
end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "Caseless",
        UBGL_Entity = "arccw_uc_40mm_he"
    },
    {
        PrintName = "Stun",
        UBGL_Entity = "arccw_uc_40mm_flash"
    },
    {
        PrintName = "Incendiary",
        UBGL_Entity = "arccw_uc_40mm_incendiary"
    },
}
--lua/arccw/shared/attachments/uc_usp_slide_cs.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_870_barrel_sawnoff.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_870_skin_dirty.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_870_slide_poly.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_870_tube_reduced.lua:
att.PrintName = "Express-12 4 Shell Tube"
att.AbbrevName = "4 Shell Tube"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Remington 870 4 Shell Tube"
end

att.Icon = Material("entities/att/acwatt_ud_870_tube_reduced.png", "smooth mips")
att.Description = "Shortened shell tube that holds fewer rounds, but reduces weapon weight."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "ud_870_tube"

att.AutoStats = true

att.Override_ClipSize = 4
att.Mult_Sway = 0.75
att.Mult_SightedSpeedMult = 1.1
att.Mult_SightTime = 0.85
att.Mult_ReloadTime = 0.9

att.ActivateElements = {"ud_870_tube_reduced"}
--lua/arccw/shared/attachments/ud_glock_caliber_22lr.lua:
att.PrintName = "Glock .22 LR Conversion"
att.AbbrevName = ".22 LR"

if not GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "GEN3 .22 LR Conversion"
end

att.SortOrder = 00
att.Icon = Material("entities/att/uc_bullets/22lr.png", "smooth mips")
att.Description = "A plinking cartridge that is easy to handle but not very lethal.\nIts form factor allows more rounds to be stuffed into magazines."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_glock_caliber"

att.AutoStats = true

att.Override_Trivia_Calibre = ".22 Long Rifle"
att.Override_Ammo = "plinking"

att.Mult_Damage = ArcCW.UC.CalConv("9mm", "22lr", "max")
att.Mult_DamageMin = ArcCW.UC.CalConv("9mm", "22lr", "min")
att.Mult_Penetration = ArcCW.UC.CalConv("9mm", "22lr", "pen")

att.Mult_Recoil = 0.25
att.Mult_VisualRecoilMult = 0.25
att.Mult_RPM = 1.5
att.Mult_Penetration = 0.1
att.Mult_ShootSpeedMult = 1.2

att.Override_PhysTracerProfile = "uc_plinking"
att.Mult_PhysBulletMuzzleVelocity = 325 / 375

att.Mult_ClipSize = 1.2

att.Override_ShellModel = "models/weapons/arccw/uc_shells/22lr.mdl"
att.Override_ShellScale = 1
att.Override_ShellSounds = ArcCW.TinyShellSoundsTable

local path = "arccw_uc/common/"
local fire22 = {path .. "fire-22-01.ogg",path .. "fire-22-02.ogg",path .. "fire-22-03.ogg",path .. "fire-22-04.ogg",path .. "fire-22-05.ogg",path .. "fire-22-06.ogg"}
local fire22sup = {path .. "fire-22-sup-01.ogg",path .. "fire-22-sup-02.ogg",path .. "fire-22-sup-03.ogg",path .. "fire-22-sup-04.ogg",path .. "fire-22-sup-05.ogg",path .. "fire-22-sup-06.ogg"}
local fire22dist = {path .. "fire-22-dist-01.ogg", path .. "fire-22-dist-02.ogg", path .. "fire-22-dist-03.ogg", path .. "fire-22-dist-04.ogg", path .. "fire-22-dist-05.ogg", path .. "fire-22-dist-06.ogg"}
local fire22distint = {path .. "fire-dist-int-pistol-light-01.ogg", path .. "fire-dist-int-pistol-light-02.ogg", path .. "fire-dist-int-pistol-light-03.ogg", path .. "fire-dist-int-pistol-light-04.ogg", path .. "fire-dist-int-pistol-light-05.ogg", path .. "fire-dist-int-pistol-light-06.ogg"}

att.Hook_GetShootSound = function(wep, sound)
    if wep:GetBuff_Override("Silencer") then
        return fire22sup
    else
        return fire22
    end
end


att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire22dist
    end
end


att.Hook_GetDistantShootSoundIndoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire22distint
    end
end

--lua/arccw/shared/attachments/ud_glock_slide_nytesyte.lua:
att.PrintName = "GEN3 Homeboy Slide"
att.AbbrevName = "Homeboy Slide"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "G17 NyteSite Slide"
end

att.Icon = Material("entities/att/acwatt_ud_glock_slide_nytesyte.png", "smooth mips")
att.Description = "Be the first in the hood to have the HoMeBoY brand Night Sights installed on your New-Model Glock!"
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "ud.glock.nytesyte.1",
    "ud.glock.nytesyte.2",
}
att.Slot = "ud_glock_slide"

att.AutoStats = true

att.ActivateElements = {"ud_glock_slide_nytesyte"}

att.O_Hook_Override_RecoilDirection = function(wep, data)
    if wep:GetState() == ArcCW.STATE_SIGHTS then
        return {current = Angle(0, -1, 0)}
    end
end

att.O_Hook_Override_RecoilDirectionSide = function(wep, data)
    if wep:GetState() == ArcCW.STATE_SIGHTS then
        return {current = Angle(1, 0, 0)}
    end
end
--lua/arccw/shared/attachments/ud_m1014_tube_ext.lua:
att.PrintName = "FC1040 7 Shell Tube"
att.AbbrevName = "7 Shell Tube"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "M4 Super 90 7 Shell Tube"
end

att.Icon = Material("entities/att/acwatt_ud_m1014_tube_ext.png", "smooth mips")
att.Description = "Military-grade extended shell tube that adds weight to the weapon."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "ud_1014_tube"

att.Override_ClipSize = 7

att.AutoStats = true

att.Override_ClipSize = 7
att.Mult_Sway = 1.5
att.Mult_SightTime = 1.15
att.Mult_ReloadTime = 1.15
att.Mult_SightedSpeedMult = 0.75


att.ActivateElements = {"ud_autoshotgun_tube_long"}
--lua/arccw/shared/attachments/ud_m16_fs_magpul.lua:
att.PrintName = "Magpul Flip-Up Front Sight"
att.AbbrevName = "Magpul Front Sight"
att.Icon = Material("entities/att/acwatt_ud_m16_fs_magpul.png", "mips smooth")
att.Description = [[Removable front sight made by Magpul. Designed to be mounted on forend rails.]]
att.Desc_Neutrals = {"uc.cosmetic"}
att.SortOrder = 1
att.IgnorePickX = true

att.Model = "models/weapons/arccw/atts/magpul_fs.mdl"
att.ModelScale = Vector(0.73, 0.73, 0.73)
att.Slot = {"ud_m16_fs"}
att.RequireFlags = {"ud_m16_rscompatible"}
att.GivesFlags = {"ud_m16_rs"}

att.FrontSight = 1
--lua/arccw/shared/attachments/ud_m16_fs_sclr.lua:
att.PrintName = "Scalarworks Front Sight"
att.AbbrevName = "Scalarworks Front Sight"
att.Icon = Material("entities/att/acwatt_ud_m16_fs_sclr.png", "mips smooth")
att.Description = [[Removable front sight made by Knight's Armament Company. Designed to be mounted on forend rails.]]
att.Desc_Neutrals = {"uc.cosmetic"}
att.SortOrder = 1
att.IgnorePickX = true

att.Model = "models/weapons/arccw/atts/scalerworks_fs.mdl"
att.ModelOffset = Vector(0, 0.01, -0.1)
att.ModelScale = Vector(0.95, 0.95, 0.95)
att.Slot = {"ud_m16_fs"}
att.RequireFlags = {"ud_m16_rscompatible"}
att.GivesFlags = {"ud_m16_rs"}

att.FrontSight = 1
--lua/arccw/shared/attachments/ud_m16_grip_ergo.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_grip_wood.lua:
att.PrintName = "Wooden Grip"
att.Icon = Material("entities/att/acwatt_ud_m16_grip_default.png", "smooth mips")
att.Description = "For a classy look."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_m16_grip"

att.AutoStats = true

att.Mult_RecoilSide = 0.85
att.Mult_SightedSpeedMult = 0.95
--att.Mult_Recoil = 1
--att.Mult_SpeedMult = 1

att.ActivateElements = {"grip_wood"}
--lua/arccw/shared/attachments/ud_m16_receiver_22lr.lua:
att.PrintName = "AMCAR-NG .22 LR Upper Receiver"
att.AbbrevName = ".22 LR Upper"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "AR-15 .22 LR Upper Receiver"
end

att.Icon = Material("entities/att/uc_bullets/22lr.png", "smooth mips")
att.Description = "Civilian model firing a low power cartridge.\nVery controllable recoil, but not much lethality."
att.Desc_Pros = {
    --"uc.auto",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_m16_receiver"
att.SortOrder = -12

att.AutoStats = true
att.SortOrder = 3

att.Mult_RPM = 1 / .85

att.Mult_Damage = ArcCW.UC.CalConv("556", "22lr", "max")
att.Mult_DamageMin = ArcCW.UC.CalConv("556", "22lr", "min")
att.Mult_Penetration = ArcCW.UC.CalConv("556", "22lr", "pen")

att.Mult_Range = 0.5
att.Mult_ShootSpeedMult = 1.2
att.Mult_Recoil = 0.2
att.Mult_VisualRecoilMult = 0.2
att.Mult_ClipSize = 1.2

att.Mult_HeatCapacity = 2

att.Override_PhysTracerProfile = "uc_plinking"
att.Override_PhysBulletMuzzleVelocity = 375 / 0.8333

att.Override_Ammo = "plinking"
att.Override_Trivia_Calibre = ".22 Long Rifle"

att.Override_ShellModel = "models/weapons/arccw/uc_shells/22lr.mdl"
att.Override_ShellScale = 1
att.Override_ShellSounds = ArcCW.TinyShellSoundsTable

local path = "arccw_uc/common/"

local fire22 = {path .. "fire-22-01.ogg",path .. "fire-22-02.ogg",path .. "fire-22-03.ogg",path .. "fire-22-04.ogg",path .. "fire-22-05.ogg",path .. "fire-22-06.ogg"}
local fire22sup = {path .. "fire-22-sup-01.ogg",path .. "fire-22-sup-02.ogg",path .. "fire-22-sup-03.ogg",path .. "fire-22-sup-04.ogg",path .. "fire-22-sup-05.ogg",path .. "fire-22-sup-06.ogg"}

att.Hook_GetShootSound = function(wep, sound)
    if wep:GetBuff_Override("Silencer") then
        return fire22sup
    else
        return fire22
    end
end

local fire22dist = {path .. "fire-22-dist-01.ogg", path .. "fire-22-dist-02.ogg", path .. "fire-22-dist-03.ogg", path .. "fire-22-dist-04.ogg", path .. "fire-22-dist-05.ogg", path .. "fire-22-dist-06.ogg"}

att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire22dist
    end
end


local fire22distint = {path .. "fire-dist-int-pistol-light-01.ogg", path .. "fire-dist-int-pistol-light-02.ogg", path .. "fire-dist-int-pistol-light-03.ogg", path .. "fire-dist-int-pistol-light-04.ogg", path .. "fire-dist-int-pistol-light-05.ogg", path .. "fire-dist-int-pistol-light-06.ogg"}

att.Hook_GetDistantShootSoundIndoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire22distint
    end
end
--lua/arccw/shared/attachments/ud_m16_receiver_semi.lua:
att.PrintName = "AMCAR-NG Sporter Receiver"
att.AbbrevName = "Sporter Lower"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "AR-15 Sporter Receiver"
end

att.Description = "A semi-automatic receiver sold in civilian markets. Designed for sport shooting, this receiver is more accurate and lightweight."

att.Icon = Material("entities/att/acwatt_ud_m16_receiver_semi.png", "smooth mips")
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.semionly"
}
att.Desc_Neutrals = {
}
att.Slot = "ud_m16_fcg"

att.AutoStats = true
att.SortOrder = -1

att.Mult_RPM = 600 / 900
att.Mult_Recoil = 0.8
att.Mult_AccuracyMOA = 0.75
att.Mult_Range = 1.15
att.Mult_MoveDispersion = 0.5

att.Mult_PhysBulletMuzzleVelocity = 1.15

att.Override_Firemodes_Priority = 0.5
att.Override_Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

att.Override_Trivia_Class = "Semi-Automatic Rifle"
--lua/arccw/shared/attachments/ud_m16_rs_sclr.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_stock_607.lua:
att.PrintName = "AMCAR 607 Stock"
att.AbbrevName = "M607 Slide Stock"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "M16 Model 607 Stock"
end

att.Icon = Material("entities/att/acwatt_ud_m16_stock_607.png", "smooth mips")
att.Description = "Collapsable combat stock used on the Model 607 SMG. While not as steady as a full stock, it allows for quick target acquisition when collapsed.\n\nToggling this stock modifies performance accordingly."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_m16_stock"

att.AutoStats = true
att.SortOrder = 5

att.Mult_Sway = 1.25
att.Mult_MoveDispersion = 0.9

att.ToggleSound = "arccw_uc/common/stockslide.ogg"

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "Extended",
        AutoStats = true,
        ActivateElements = {"stock_607_ex"},
    },
    {
        PrintName = "Collapsed",
        AutoStats = true,
        ActivateElements = {"stock_607_in"},
        Mult_SightTime = 0.8,
        Mult_Recoil = 1.15,
        Add_BarrelLength = -4,
    },
}
--lua/arccw/shared/attachments/ud_m79_stock_sawn.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_mag_10_762.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_stock_polymer.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_uzi_body_carbine.lua:
att.PrintName = "Uzi 13\" Carbine Barrel"
att.AbbrevName = "13\" Carbine Barrel"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "STAP 13\" Carbine Barrel"
end

att.Icon = Material("entities/att/acwatt_ud_uzi_body_carbine.png", "smooth mips")
att.Description = "Long barrel for the Uzi, built for long range patrols. Improves range and recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_uzi_frame"

att.AutoStats = true
att.SortOrder = 13

att.Mult_AccuracyMOA = 0.75
att.Mult_SightTime = 1.15
att.Mult_Recoil = 0.9
att.Mult_RecoilSide = 0.75
att.Mult_RPM = 0.9
att.Mult_Range = 1.25
att.Mult_Sway = 1.5

att.Mult_TriggerDelayTime = 1.15

att.Add_BarrelLength = 5

att.ActivateElements = {"ud_uzi_body_carbine"}
--lua/arccw/shared/attachments/ud_uzi_mag_40.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_uzi_mag_45_12.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_uzi_stock_wood.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_1911_cal_10auto.lua:
att.PrintName = "Delta Elite 10mm Auto Conversion"
att.AbbrevName = "10mm Auto"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "AMAS-FBI 10mm Auto Conversion"
end

-- att.Hook_NameChange = function(wep,name)
-- 	name = "Ruger SR1911"
-- end

att.SortOrder = 10
att.Icon = Material("entities/att/uc_bullets/10.png", "smooth mips")
att.Description = "The FBI's preferred caliber of choice.\nDespite its distinctive power, it's not as large as .45 ACP, though its damage curve is more balanced."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ur_m1911_caliber"

att.AutoStats = true

att.Override_Trivia_Calibre = "10mm Auto"
-- att.Override_Trivia_Manufacturer = "Ruger"

att.Mult_Damage = 35 / 45
att.Mult_DamageMin = 20 / 15
att.Mult_Penetration = 8 / 9
att.Mult_RangeMin = 1.5

-- att.Mult_Recoil = 1.3
-- att.Mult_RecoilSide = 1.25
-- att.Mult_ReloadTime = 1.2
-- att.Mult_MalfunctionMean = 0.75

att.Mult_PhysBulletMuzzleVelocity = 1.5 --380 / 253
att.Override_TracerNum = 1
att.Override_TracerNum_Priority = 0.5 -- subsonic can override

att.Mult_ClipSize = 8 / 7
att.Override_ShellScale = 1

local path = ")^weapons/arccw_ur/1911/"

att.Hook_GetShootSound = function(wep, sound) -- Temporary
    if wep:GetBuff_Override("Silencer") then
        return {
            path .. "fire-sup-01.ogg",
            path .. "fire-sup-02.ogg",
            path .. "fire-sup-03.ogg",
            path .. "fire-sup-04.ogg",
            path .. "fire-sup-05.ogg",
            path .. "fire-sup-06.ogg"
        }
    else
        return {path .. "fire-10-01.ogg", path .. "fire-10-02.ogg", path .. "fire-10-03.ogg", path .. "fire-10-04.ogg", path .. "fire-10-05.ogg", path .. "fire-10-06.ogg"}
    end
end

att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        return -- fallback to script
    else
        return {path .. "fire-10-dist-01.ogg", path .. "fire-10-dist-02.ogg", path .. "fire-10-dist-03.ogg", path .. "fire-10-dist-04.ogg", path .. "fire-10-dist-05.ogg", path .. "fire-10-dist-06.ogg"}
    end
end

--[[
att.Override_ClipSize = 15
att.Override_ClipSize_Priority = -1
local slotinfo = {
    [7] = {"15-Round Mag", "15-Round Mag", nil},
}
att.Hook_GetDefaultAttName = function(wep, slot)
    if slotinfo[slot] then
        return GetConVar("arccw_truenames"):GetBool() and slotinfo[slot][2] or slotinfo[slot][1]
    end
end
att.Hook_GetDefaultAttIcon = function(wep, slot)
    if slotinfo[slot] then
        return slotinfo[slot][3]
    end
end
]]
--lua/arccw/shared/attachments/ur_329_caliber_snakeshot.lua:
att.PrintName = "Model 329PD .44 Snakeshot Chambering"
att.AbbrevName = ".44 Snakeshot"
att.Icon = Material("entities/att/uc_bullets/44special.png","smooth mips")
att.Description = "Rounds containing small lead shots. Due to bullet diameter and barrel length, this round has an extremely low effective range.\nAs its name implies, it's mostly useful for shooting snakes and rodents only."

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Enforcement .44 Snakeshot Chambering"
end
-- Todo: alt shoot sound

att.AutoStats = true
att.Desc_Pros = {
    "ur.329.snakeshot.1"
}
att.Desc_Cons = {
    "ur.329.snakeshot.2",
    "ur.329.snakeshot.3"
}
att.Slot = "ur_329_caliber"
att.SortOrder = -1

att.Override_Num = 4
att.Override_AccuracyMOA = 65
att.Override_AccuracyMOA_Priority = 0

att.Override_HullSize = 0.1
att.Override_BodyDamageMults = ArcCW.UC.BodyDamageMults_Shotgun
att.Override_Penetration = 1

att.Mult_Damage = 70 / 60

att.Mult_Range = 0.4
att.Mult_RangeMin = 2

att.Mult_PhysBulletMuzzleVelocity = 0.6

-- att.Override_IsShotgun = true
-- att.Override_Ammo = "buckshot"
-- att.Override_ShellModel = "models/weapons/arccw/uc_shells/410bore.mdl"
-- att.Override_ShellScale = 0.8
-- att.Override_ShellSounds = ArcCW.ShotgunShellSoundsTable
att.Override_Trivia_Calibre = att.AbbrevName -- E F F I C I E N C Y

local slotinfo = {
    [6] = {"\"SS\" Snakeshot", "\"SS\" Snakeshot", Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")},
}
att.Hook_GetDefaultAttName = function(wep, slot)
    if slotinfo[slot] then
        return GetConVar("arccw_truenames"):GetBool() and slotinfo[slot][2] or slotinfo[slot][1]
    end
end
-- att.Hook_GetDefaultAttIcon = function(wep, slot)
--     if slotinfo[slot] then
--         return slotinfo[slot][3]
--     end
-- end

att.Hook_GetShootSound = function(wep, sound)
    if wep:GetBuff_Override("Silencer") then
        return "weapons/arccw_ur/deagle/fire_supp_10.ogg" -- Placeholder
    else
        return {"weapons/arccw_ur/deagle/fire-410-01.ogg", "weapons/arccw_ur/deagle/fire-410-02.ogg", "weapons/arccw_ur/deagle/fire-410-03.ogg", "weapons/arccw_ur/deagle/fire-410-04.ogg", "weapons/arccw_ur/deagle/fire-410-05.ogg", "weapons/arccw_ur/deagle/fire-410-06.ogg"} -- Not Placeholder
    end
end

att.GivesFlags = {"329_ss"}
--lua/arccw/shared/attachments/ur_ak_barrel_t56.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_cal_545.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_cover_smooth.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_hg_74m.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_hg_74m.lua:
att.PrintName = "Polymer Handguard"
att.Icon = Material("entities/att/ur_ak/handguards/poly.png", "mips smooth")
att.Description = "Light polymer handguard with superior agility, but higher recoil from the reduced counterweight."
att.Slot = {"ur_ak_hg"}
att.AutoStats = true

att.SortOrder = 16

att.Mult_Sway = 0.9
att.Mult_SightTime = 0.9
att.Mult_Recoil = 1.1

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "Black",
        ActivateElements = {"barrel_74m"},
    },
    {
        PrintName = "Plum",
        ActivateElements = {"barrel_74m_red"},
    },
    {
        PrintName = "Olive Drab",
        ActivateElements = {"barrel_74m_green"},
    },
}
--lua/arccw/shared/attachments/ur_ak_mag_762_pmag.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_barrel_long.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_cal_338.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_muzzle_brake_sights.lua:
att.PrintName = "AI Ironsight Brake"
att.Icon = Material("entities/att/ur_aw/muzzle_sights.png", "mips smooth")
att.Description = "Light muzzle brake unique to the AW platform.\n\nEquips alternative \"compact\" iron sights."
att.AutoStats = true
att.Slot = {"ur_aw_muzzle"}

att.Mult_Recoil = .9
att.Mult_RecoilSide = .9

att.Add_BarrelLength = 2
att.Mult_SightTime = 1.05
att.Mult_Sway = 1.05

att.SortOrder = 998

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"
att.Model = "models/weapons/arccw/ur_aw_muzzlesight.mdl"
att.ModelScale = Vector(2/3,2/3,2/3)
att.ModelOffset = Vector(0,0,-.075)

att.GivesFlags = {"sights_compact"}
--lua/arccw/shared/attachments/ur_aw_skin_custom.lua:
att.PrintName = "Custom Finish"
att.AbbrevName = "Custom"
att.Icon = Material("entities/att/ur_aw/skin_rainbow.png", "mips smooth")
att.Description = "A customizable finish. Let your imagination run wild."
att.Slot = "ur_aw_skin"
att.Desc_Neutrals = {
    "uc.cosmetic",
    "uc.custcolor",
}
att.SortOrder = 1

att.IgnorePickX = true
att.ActivateElements = {"skin_cust"}
--lua/arccw/shared/attachments/ur_aw_stock_ru_rubber.lua:
att.PrintName = "RU556 Fixed-Adjustable Stock (Rubberized)"
att.AbbrevName = "Rubberized Carbine Stock"

att.Icon = Material("entities/att/ur_aw/stock_rurubber.png", "mips smooth")
if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Magpul UBR GEN2 Stock (Rubberized)"
end

att.Description = "Polymer stock designed for assault rifles. Rubber accents reduce the impact on aim sway, but weigh the stock down."
att.Slot = {"ur_aw_stock"}
att.AutoStats = true

att.SortOrder = 2

att.Mult_MoveDispersion = .6

att.Mult_Sway = 1.25
att.Mult_RecoilSide = 1.2

att.ActivateElements = {"stock_ru_rubber"}
att.GivesFlags = {"pistolgrip"}
--lua/arccw/shared/attachments/ur_deagle_barrel_annihilator.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_deagle_mag_10.lua:
att.PrintName = "Desert Eagle 10-Round Extended Magazine"
if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Predator 10-Round Extended Magazine"
end
att.AbbrevName = "10-Round Extended Mag"
att.Icon = Material("entities/att/acwatt_ur_deagle_mag_10.png","mips smooth")
att.Description = "A higher capacity magazine increases the time you can spend without reloading. However, the extra rounds add even more weight to an already unwieldy weapon."
att.Slot = "ur_deagle_mag"
att.AutoStats = true

att.Override_ClipSize = 10
att.Mult_SightTime = 1.1
att.Mult_ReloadTime = 1.15
att.Mult_Sway = 1.5
att.Mult_SpeedMult = 0.98
att.Mult_ShootSpeedMult = 0.95

att.Mult_HipDispersion = 1.25

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_10"
end
-- 10-round anims don't exist yet
-- now exist

att.ActivateElements = {"ur_deagle_mag_ext"}
--lua/arccw/shared/attachments/ur_g3_barrel_12.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_g3_bayobipod_bipod.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_g3_hg_pica.lua:
att.PrintName = "RIS Handguard"
att.Icon = Material("entities/att/ur_g3/hg_pica.png","smooth mips")
att.Description = "A handguard with three picatinny rails extending down the barrel, enabling higher modularity."
att.AutoStats = true
att.Desc_Neutrals = {
    "uc.cosmetic"
}

att.Slot = "ur_g3_handguard"

att.SortOrder = 5



--lua/arccw/shared/attachments/ur_g3_mag_20_556.lua:
att.PrintName = "HK33 20-Round Compact Mag"
att.AbbrevName = "20-Round Compact Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "CN66 20-Round Compact Mag"
end

att.Icon = Material("entities/att/ur_g3/mag556_20.png","smooth mips")
att.Description = "Low-capacity magazine for the 5.56 variant of the rifle. The lighter load makes the weapon more ergonomic."
att.Slot = {"ur_g3_mag"}
att.AutoStats = true

att.HideIfBlocked = true
att.SortOrder = 10

att.Override_ClipSize = 20
att.Override_ClipSize_Priority = 2

att.Mult_SightTime = 0.85
att.Mult_ReloadTime = 0.9
att.Mult_Sway = 0.75

att.Mult_SpeedMult = 1.025
att.Mult_SightedSpeedMult = 1.05
att.Mult_ShootSpeedMult = 1.05

att.RequireFlags = {"cal_556"}

-- att.Hook_SelectReloadAnimation = function(wep, anim)
--     return anim
-- end
--lua/arccw/shared/attachments/ur_g3_optic_psg1.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_g3_stock_psg.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_g3_stock_sg.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_caliber_noburst.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_ub_ris.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_spas12_tube_reduced.lua:
att.PrintName = "Martello 12/70 6 Shell Tube"
att.AbbrevName = "6 Shell Tube"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "SPAS-12 6 Shell Tube"
end

att.Icon = Material("entities/att/acwatt_ud_870_tube_reduced.png", "smooth mips")
att.Description = "Shortened shell tube that holds fewer rounds, but reduces weapon weight."
att.Icon = Material("entities/att/ur_spas/magsmall.png", "smooth mips")
att.Slot = "ur_spas12_tube"

att.AutoStats = true

att.Override_ClipSize = 6
att.Mult_Sway = 0.75
att.Mult_SightedSpeedMult = 1.1
att.Mult_SightTime = 0.85
att.Mult_ReloadTime = 0.9

att.ActivateElements = {"ud_870_tube_reduced"}
--lua/arccw/shared/attachments_bulk/uc_myt_scar.lua:
return gluapack()()
--lua/arccw/shared/languages/uc_es.lua:
L = {}

L["uc.auto"] = "Conversion a automático"

L["uc.nofs"] = "Difícil saber donde apuntas"
L["uc.jam"] = "Se atascará tras un uso prolongado"
L["uc.homeboy"] = "Vuelve el retroceso diagonal"
L["uc.pointman"] = "+25% Cadencia en pistolas semi-automáticas"
--lua/arccw/shared/languages/ur_en.lua:
L = {}

L["ur.compen"] = "+50% Visual recoil"
L["ur.deagle.410.1"] = "Fires 4 pellets instead of one round"
L["ur.deagle.410.2"] = "35MOA Imprecision"

L["ur.ak.12g.1"] = "Fires 8 pellets instead of one round"
L["ur.ak.12g.2"] = "40MOA Imprecision"
L["ur.ak.alpha"] = "Optics become mounted on the upper rail instead of a rail adapter."
L["ur.ak.tl.1"] = "Mount tactical lasers on a rail adapter instead of the handguard."
L["ur.ak.tl.2"] = "The sight is changed to a point shooting stance."
L["ur.ak.burst"] = "Two-round burst mode"

L["ur.ak.userail"] = "Use a railed dust cover for a modern rear sight aperture."

L["ur.aw.velocity"] = "Increased muzzle velocity"

L["ur.mp5.noburst"] = "Disables burst mode"
L["ur.mp5.sd"] = "No distant firing sound"

L["ur.spas12.pump"] = "Manual action only"
L["ur.spas12.dbl"] = "2-round burst"
L["ur.spas12.dbl.abbrev"] = "2-BST"
L["ur.spas12.folded"] = "Cannot use optics or iron sights"

L["ur.329.sact"] = "Single-action"
L["ur.329.sact.abbrev"] = "SACT"
L["ur.329.dact"] = "Double-action"
L["ur.329.dact.abbrev"] = "DACT"

L["ur.329.snakeshot.1"] = "Fires 4 pellets instead of one round"
L["ur.329.snakeshot.2"] = "Disables Ammo Type attachments"
L["ur.329.snakeshot.3"] = "65MOA Base imprecision"

L["ur.g3.8"] = "Accepts MP5 handguards"
--addons/[binbon]arccw_modify/lua/arccw/client/cl_darkrp_performance.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/client/cl_ttt.lua:
return gluapack()()
--addons/policearmorylocker/lua/autorun/armory_locker_initialize.lua:
-- INITIALIZE SCRIPT
if SERVER then
	for k, v in pairs( file.Find( "armory_locker/server/*.lua", "LUA" ) ) do
		include( "armory_locker/server/" .. v )
		--print("server: ".. v)
	end
	
	for k, v in pairs( file.Find( "armory_locker/client/*.lua", "LUA" ) ) do
		AddCSLuaFile( "armory_locker/client/" .. v )
		--print("cs client: ".. v)
	end
	
	for k, v in pairs( file.Find( "armory_locker/shared/*.lua", "LUA" ) ) do
		include( "armory_locker/shared/" .. v )
		--print("shared: ".. v)
	end
	
	for k, v in pairs( file.Find( "armory_locker/shared/*.lua", "LUA" ) ) do
		AddCSLuaFile( "armory_locker/shared/" .. v )
		--print("cs shared: ".. v)
	end
end

if CLIENT then
	for k, v in pairs( file.Find( "armory_locker/client/*.lua", "LUA" ) ) do
		include( "armory_locker/client/" .. v )
		--print("client: ".. v)
	end
	
	for k, v in pairs( file.Find( "armory_locker/shared/*.lua", "LUA" ) ) do
		include( "armory_locker/shared/" .. v )
		--print("shared client: ".. v)
	end
end
--addons/ashop/lua/autorun/ashop_load.lua:
// I'm a pretty autorun ! //
ashop = ashop or {
    LoadState = {
        AutorunTrigger = 0,
        CreatedSQLTables = 1,
        EverythingLoaded = 2
    }
}

local function include_dir(dir)
    local files, folders = file.Find(dir .. "*", "LUA")

    for k,v in ipairs(files) do
        local prefix = string.sub(v, 1, 3)
        local file_dir = dir .. v

        if prefix == "sh_" then
            if SERVER then
                AddCSLuaFile(file_dir)
            end
            include(file_dir)
        elseif prefix == "sv_" and SERVER then
            include(file_dir)
        elseif prefix == "cl_" then
            if SERVER then
                AddCSLuaFile(file_dir)
            else
                include(file_dir)
            end
        else
            print("[AShop] Can't include " .. v .. ", wrong prefix")
            continue
        end
    end

    for k, v in ipairs(folders) do
        include_dir(dir .. v .. "/")
    end
end

include_dir("ashop/config/")

if !ashop.Config.Language then
    print("------ AShop ------")
    print("You got a issue with installation, the config file can't be loaded")
    print("Follow these instructions to debug the config file")
    print("Check before this message in your console if there any errors OR paste your config in this file : https://fptje.github.io/glualint-web/")
    print("Most of the time, it's a missing comma or quotation marks")
    print("To prevent any issues, AShop will stop loading")
    print("--------------------")
    return
end

if SERVER then
    AddCSLuaFile("ashop/lang/sh_" .. ashop.Config.Language .. ".lua")
    //resource.AddWorkshop( "2485178558" )
end

ashop.lang = ashop.lang or {}
ashop.lang.l = include("ashop/lang/sh_" .. ashop.Config.Language .. ".lua")
include_dir("ashop/code/")

hook.Run("ashop_load", ashop.LoadState.AutorunTrigger)

ashop.Loaded = true
--addons/ashop/lua/ashop/code/_kernel/sh_colors.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/_kernel/lang/sh_lang.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/gamemodes/currencies/integrations/sh_helix.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/gamemodes/logs_integration_name/sh_nutscript.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/commandes/cl_commandes.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/commandes/sh_commandes.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/kill_card/sh_killcard.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/title_code/text/cl_text.lua:
local OBJECT_TYPE = {}
OBJECT_TYPE.Name = ashop.L('TextClass')
OBJECT_TYPE.UniqueIdentifier = "TitleText"

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h)
    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:Dock(FILL)
    circleParent:SetMouseInputEnabled(false)

    local t = {}
    local str = item.metadata[1]
    
    for i = 1, string.len(str) do
        t[i] = utf8.sub(str, i, i )
    end

    function circleParent:Paint(w, h)
        //surface.SetDrawColor(ashop.rarity[item.rarity])
        //surface.SetMaterial(circle)
        //surface.DrawTexturedRect(w*0.1, h*0.1, w*0.8, h*0.8)

        ashop.DrawTitle(t, color_white, nil, w/2, h/2, item.metadata[1], TEXT_ALIGN_CENTER)
    end
end

function OBJECT_TYPE.OnLocalEquip(ply, plyItem, item)
    OBJECT_TYPE.OnEquip(ply, plyItem, item)
end

function OBJECT_TYPE.OnEquip(ply, plyItem, item)
    local t = {}

    for i = 1, string.len(item.metadata[1]) do
        t[i] = utf8.sub( item.metadata[1], i, i )
    end

    ply.ashop_splittedTitle = t
    ply.ashop_title = item.metadata[1]
end

function OBJECT_TYPE.OnMetadataUpdate(ply, plyItem, item)
    OBJECT_TYPE.OnEquip(ply, plyItem, item)
end

function OBJECT_TYPE.OnLocalRemove(ply)
    OBJECT_TYPE.OnRemove(ply)
end

function OBJECT_TYPE.OnLocalFPDraw(ply)
end

function OBJECT_TYPE.OnRemove(ply)
    ply.ashop_splittedTitle = nil
    ply.ashop_title = nil
end

local function drawTitle(ply, font, fontHeight)
    if ply.ashop_splittedTitle then
        ashop.DrawTitle(ply.ashop_splittedTitle, ply.ashop_titlecolor, ply.ashop_titlestyle, 0, -fontHeight*1.25, ply.ashop_title, nil, font)
    end
end

local offset = Vector( 0, 0, 75 )
local offsetHead = Vector(0, 0, 15)
local angHead = Angle( 0, 0, 90 )

local drawTbl = {}

hook.Add("PostDrawTranslucentRenderables", "AShop:DrawTitle", function()
    for k, v in ipairs(drawTbl) do
        cam.Start3D2D( v[1], v[2], 0.05 )
            drawTitle(v[3], v[4], v[5])
        cam.End3D2D()
    end

    drawTbl = {}
end)

local addVec = Vector(0, 0, ashop.Config.TitleVerticalPosAdd or 0)
function OBJECT_TYPE.OnPostPlayerDraw(ply, plyItem, item, inModelPanel)
    if inModelPanel then
        cam.Start2D()
            cam.IgnoreZ(true)

            ashop.DrawTitle(ply.ashop_splittedTitle, ply.ashop_titlecolor, ply.ashop_titlestyle, ScrW()/2, ScrH()*0.15, item.metadata[1])
            cam.IgnoreZ(false)
        cam.End2D()
    elseif hook.Run("ashop_OverrideTitleDrawingCam", ply, plyItem, item, inModelPanel) then
        return
    else
        local l = LocalPlayer()
        if ( l:GetPos():DistToSqr( ply:GetPos() ) > 300 * 300 ) then return end

        local ang = l:EyeAngles()
        local pos = ply:GetPos() + offset
        local targethead = ply:LookupBone("ValveBiped.Bip01_Head1")
        if isnumber(targethead) then
            local targetheadpos = ply:GetBonePosition(targethead)
            pos = targetheadpos + offsetHead
        end

        if l:InVehicle() then
            ang = l:GetVehicle():LocalToWorldAngles( l:EyeAngles() )
        end

        ang:RotateAroundAxis( ang:Forward(), 90 )
        ang:RotateAroundAxis( ang:Right(), 90 )

        angHead.y = ang.y

        if Flux then
            table.insert(drawTbl, {pos + Vector(0, 0, 0.5), angHead, ply, "ashop_3D2D_" .. ashop.Config.FontSizeTitle, 18})
        else
            table.insert(drawTbl, {pos + addVec, angHead, ply, "ashop_3D2D_" .. ashop.Config.FontSizeTitle, 18})
        end
    end
end

hook.Add('ahud_afterSHUDDraw', "AShopDrawTitle", drawTitle)

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/title_code/text/sh_text.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/players/equip/cl_init.lua:
function ashop.EquipChange(e, plyItemID, slot, is_remove)
    e:AShop_ItemEquip(plyItemID, slot, is_remove)
end

function ashop.UnequipAll(e)
    if !e or !e.ashop_data or !e.ashop_data.equipped then return end

    // UnequipAll is called every SetModel
    // UnequippAll will call PlayerModel Unequip
    // That will call SetModel
    // = infinite loop
    local good, objectTypeID, objectType = pcall(ashop.GetObjectTypeIDByUID, 'PlayerModel')
    for object_typeID, v in pairs(e.ashop_data.equipped) do
        if object_typeID == objectTypeID then continue end
        for sub_type, j in pairs(v) do
            for slot, plyItemID in pairs(j) do
                ashop.EquipChange(e, plyItemID, slot, true)
            end
        end
    end
end

hook.Add('ashop_unequip', 'ashop_callobjecttype', function(e, slot, item, plyItem)
    local object_type = ashop.object_types[item.object_types]
    assert(object_type, "Object_type does not exist")

    if e == LocalPlayer() and object_type.OnLocalRemove then
        if object_type.OnLocalRemove then
            object_type.OnLocalRemove(e, plyItem, item)
        end
    else
        if object_type.OnRemove then
            object_type.OnRemove(e, plyItem, item)
        end
    end
end)

// TODO: Cache player value, if he didn't changed items
local function loopHook(ply, isModelPanel, funcName, ...)
    if !ply.ashop_data or !ply.ashop_data.items then return end
    
    local fired = false
    for objectTypeID, subCatTable in pairs(ply.ashop_data.equipped or {}) do
        local o = ashop.object_types[objectTypeID]
        if !o[funcName] then continue end
    
        for subCatID, slots in pairs(subCatTable) do
            for slotID, plyItemID in pairs(slots) do
                local plyItem = ply.ashop_data.items[plyItemID]
                o[funcName](ply, plyItem, ashop.items[plyItem.item_id], isModelPanel, slotID, ...)
                fired = true
            end
        end
    end

    return fired
end

function ashop.OnViewModelChanged(vm, wep)
    local fired = loopHook(LocalPlayer(), false, 'OnViewModelChanged', vm, wep)

    if !fired then
        // Fallback for skins, reset it.
        local b = ashop.GetObjectTypeIDByUID('WeaponSkins', true)
        if !b then return end

        ashop.object_types[b].OnViewModelChanged(LocalPlayer(), nil, nil, nil, nil, vm, wep)
        ashop.WeaponSkinApply(LocalPlayer(), wep)
    end
end

net.Receive('ashop_fireSetActiveWeapon', function()
    timer.Simple(0.8, function()
        local ply = LocalPlayer()
        if !IsValid(ply) then return end
        local wep = ply:GetActiveWeapon()
    
        if !IsValid(wep) then return end
        ashop.OnViewModelChanged(ply:GetViewModel(wep:ViewModelIndex()), ply:GetActiveWeapon())
    end)
end)

function ashop.PostPlayerDraw(ply, flags, isModelPanel)
    loopHook(ply, isModelPanel, 'OnPostPlayerDraw', flags)
end

hook.Add("PostPlayerDraw", "ashop_draw", ashop.PostPlayerDraw)
hook.Add("OnViewModelChanged", "ashop_draw", function(vm)
    timer.Simple(0.25, function()
        local wep = LocalPlayer():GetActiveWeapon()
        ashop.OnViewModelChanged(vm, wep)
    end)
end)

hook.Add("PostDrawTranslucentRenderables", "ashop_draw", function()
    local p = LocalPlayer()
    if !p:ShouldDrawLocalPlayer() then
        loopHook(p, false, 'OnLocalFPDraw')
    end
end)
--addons/ashop/lua/ashop/code/ui/cl_material-avatar.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/item_shop_effects/sh_glitch.lua:
ashop.itemShopEffects = ashop.itemShopEffects or {}
ashop.itemShopEffects[5] = ashop.itemShopEffects[5] or {}

if SERVER then return end

local tex = GetRenderTarget( "AShopGlitch", ScrW(), ScrH() )

local myMat = CreateMaterial( "AShopGlitch2", "UnlitGeneric", {
	["$basetexture"] = tex:GetName(),
    ["$vertexalpha"] = 1,
    ["$vertexcolor"] = 1
} )

local rands = {
    x = math.random(),
    y = math.random(),
    w = math.random(0, 20),
    h = math.random(0, 20)
}

local lastRand = 0

local function refreshRands()
    rands = {
        x = math.random(-0.05, 1.05),
        y = math.random(),
        w = math.random(),
        h = math.random(),
        xPos = math.random(),
        yPos = math.random()
    }
end

refreshRands()

ashop.itemShopEffects[5].preDraw = function(pnl, w, h, equipped, clr)
    local c = CurTime()
    if lastRand < c then
        // TODO: Check Epilepsy warning, we make the colors less flashy ?
        // Time should be fine, I think ?
        lastRand = c + 0.1
        refreshRands()
    end

    local xS, yS = pnl:LocalToScreen(0, 0)
    local cursorX = math.max(rands.x * (w - rands.w*w), 0)
    local cursorY = math.max(rands.y * (h - rands.h*w), 0)

    surface.SetDrawColor(ColorRand())
    surface.SetMaterial(myMat)
    surface.DrawTexturedRectUV(0, 0, w, h, 
        (cursorX + xS) / ScrW(), (cursorY + yS)/ScrH(), (cursorX + xS + rands.w*w) / ScrW(), (cursorY + yS + rands.h*h)/ScrH())

    surface.SetDrawColor(ColorRand())
    surface.DrawTexturedRectUV(rands.xPos*(w - rands.w*w), rands.yPos * (h - rands.h*w), rands.w*w, rands.h*w, 
        (cursorX + xS) / ScrW(), (cursorY + yS)/ScrH(), (cursorX + xS + rands.w*w) / ScrW(), (cursorY + yS + rands.h*h)/ScrH())
end

hook.Add('PostRender', 'ashop_copyRT', function()
    render.CopyRenderTargetToTexture( tex )
end)
--addons/ashop/lua/ashop/code/ui/panels/cl_config.lua:
ashop.UIOptions = ashop.UIOptions or {}
ashop.UIUserOptions = ashop.UIUserOptions or {}

local stateOn = ashop.GetColor('StateOn')
local stateOnR, stateOnG, stateOnB = ashop.GetColor('StateOn'):Unpack()
local stateOffR, stateOffG, stateOffB = ashop.GetColor('StateOff'):Unpack()
local Grad2_0 = ashop.GetColor('Grad2_0')
local white50 = ashop.GetColor('White50')
local white25 = ashop.GetColor('White25')
local white = ashop.GetColor('White')

local PANEL = {}

function ashop.registerParameter(name, getOptionsFunc, interior, createButton, afterCreation)
    ashop.UIOptions[name] = {getOptionsFunc, interior, createButton, afterCreation}
end

function ashop.registerUserParameter(name, getOptionsFunc, interior, createButton, afterCreation, shouldBeDrawn)
    ashop.UIUserOptions[name] = {getOptionsFunc, interior, createButton, afterCreation}
end

function PANEL:Init()
end

function PANEL:TableFill(tableFill)
    self:SetPaintBackground(false)
    local horizontalMargin = ashop.GetSize(64)
    local marginVertical = ashop.GetSize(20)

    self:SetMouseInputEnabled(true)
    self:SetKeyboardInputEnabled(true)
    
    // setting Init
    local setting = vgui.Create("DPanel", self)
    setting:Dock(LEFT)
    setting:SetWide(ashop.GetSize(220))
    setting:DockMargin(0, 0, 0, 0)
    setting:SetPaintBackground(false)

    local settingContainer = vgui.Create("DScrollPanel", setting)
    settingContainer:Dock(FILL)
    ashop.ui.SkinScrollPanel(settingContainer, stateOn)

    function settingContainer:Paint(w, h)
        surface.SetDrawColor(Grad2_0)
        surface.DrawRect(w-2, 0, 2, h)
    end

    local settingSingle = vgui.Create("EditablePanel", self)
    settingSingle:Dock(FILL)
    settingSingle:DockMargin(horizontalMargin, 0, horizontalMargin, 0)

    local holder = {}

    local but

    local function initChilds(childContainer, name, lbl, p, oldID, refresh)
        childContainer:SetTall(0)
        local v = tableFill[name]
        if v[2] then
            for i, j in SortedPairs(v[2]()) do
                local settingTitle = vgui.Create("DButton", childContainer)
                settingTitle:Dock(TOP)
                settingTitle:SetText(j[1])
                settingTitle:SetFont("ashop_14_600")
                settingTitle:SetTall(select(2, settingTitle:GetContentSize())*1.75)
                settingTitle:SetTextColor(white50)
                settingTitle:DockMargin(0, i != 1 and 0 or marginVertical, 0, 0)
                settingTitle:SetContentAlignment(4)
                settingTitle:SetPaintBackground(false)
                settingTitle:SetTextInset(16, 0)
                settingTitle.id = i
                settingTitle.settingName = name

                function settingTitle:Paint(w, h)
                    if but == self then
                        surface.SetDrawColor(stateOnR, stateOnG, stateOnB)
                    else
                        surface.SetDrawColor(stateOffR, stateOffG, stateOffB)
                    end

                    surface.DrawRect(8, 0, 2, h)
                end
                
                function settingTitle:DoClick()
                    settingSingle:Clear()
                    v[1](settingSingle, j[2], j[3], settingTitle)
                    if IsValid(but) then
                        but:SetTextColor(white50)
                    end
                    settingTitle:SetTextColor(stateOn)
                    but = settingTitle
                end

                if oldID and i == oldID then
                    timer.Simple(0, function()
                        settingTitle:DoClick()
                    end)
                end

                childContainer:SetTall(settingTitle:GetTall() + childContainer:GetTall() + (i != 1 and 0 or marginVertical))

                if v[4] then
                    v[4](settingTitle, tableFill[name], j[3], j)
                end
            end
        end

        if !refresh and v[3] then
            local add = vgui.Create('DButton', p)
            add:Dock(RIGHT)
            add:SetText('+')
            add:SetFont('ashop_20_600')
            add:SetTextColor(white25)
            add:DockMargin(0, 0, marginVertical, 0)
            add:SetPaintBackground(false)
            add:SetMouseInputEnabled(true)

            // Not doing OnEnterd/exited since there also childs
            function add:Think()
                local b = (lbl:IsChildHovered() or lbl:IsHovered())
                add:SetTextColor(b and white25 or color_transparent)
            end

            function add:DoClick()
                v[3]()
            end
        end
    end

    for k, v in SortedPairs(tableFill) do
        local function cb()
            local lbl = vgui.Create("DLabel", settingContainer)
            lbl:SetFont('ashop_20_600')
            lbl:SetText(k)
            lbl:SetContentAlignment(4)
            lbl:Dock(TOP)
            lbl:SetTall(select(2, lbl:GetContentSize()))
            lbl:SetTextColor(white50)
            lbl:SetPaintBackground(false)
            lbl:DockMargin(0, marginVertical/2, 0, 0)
            lbl:SetContentAlignment(7)
            lbl:SetMouseInputEnabled(true)

            local realTall = select(2, lbl:GetContentSize())

            local p = vgui.Create('DButton', lbl)
            p:Dock(TOP)
            p:SetTall(realTall)
            p:SetText('')
            p:SetPaintBackground(false)
            lbl.p = p
        
            function p:DoClick()
                if lbl:GetTall() == realTall then
                    lbl:SizeTo(-1, select(2, lbl:ChildrenSize()) + realTall, 0.5, 0, 0.5)
                    lbl:SetTextColor(white)
                    lbl.deployed = true
                else
                    lbl:SetTextColor(white50)
                    lbl:SizeTo(-1, realTall, 0.5, 0, 0.5)
                    lbl.deployed = false
                end
            end

            // Ghetto trick for below
            function lbl:DoClick()
                p:DoClick()
            end

            if v[2] then
                local childContainer = vgui.Create("EditablePanel", lbl)
                childContainer:Dock(TOP)
                childContainer:SetTall(0)
                holder[k] = childContainer

                initChilds(childContainer, k, lbl, p)
            else
                function p:DoClick()
                    settingSingle:SetMouseInputEnabled(true)
                    settingSingle:Clear()
                    v[1](settingSingle)
                    if IsValid(but) then
                        but:SetTextColor(white50)
                    end
                    lbl:SetTextColor(stateOn)
                    but = lbl
                end
            end

            lbl.realtall = realTall
        end

        // This is a weird pattern, should think about that before
        if k == 'Logs' then
            CAMI.PlayerHasAccess(LocalPlayer(), 'ashop_logs', function(b, str)
                if b then
                    cb()
                end
            end)
        else
            cb()
        end
    end

    hook.Add("ashop_refreshSettingsUI", "ACoolUI", function(name)
        if !IsValid(self) then return end

        local lbl = holder[name]:GetParent()
        local id

        if (IsValid(but) and but.settingName == name) then
            id = but.id
        end

        holder[name]:Clear()

        initChilds(holder[name], name, lbl, lbl.p, id, true)

        if lbl.deployed then
            lbl:SetTall(select(2, lbl:ChildrenSize()) + lbl.realtall)
        end
    end)
end

derma.DefineControl( "AShop_ConfigDisplay", "", PANEL, "DPanel" )
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_externalweaponskin.lua:
if !Flux then return end

ashop.RegisterPremade("External Weapon Skins", {
    requireWorkshop = "",

    objectTypes = {
        {
            "WeaponSkins",
            // {} metadatas,
        }
    },

    items = {
        {
            metadata = {"z_easyskins/camo/bloodshot"},
            name = "Red Camo",
            rendering = 1
        },

        {
            metadata = {"z_easyskins/camo/devgru"},
            name = "Camo",
            rendering = 1
        },

        {
            name = "Digital Camo",
            metadata = {"z_easyskins/camo/digital"},
            rendering = 1
        },

        {
            name = "Mango Camo",
            metadata = {"z_easyskins/camo/mango"},
            rendering = 1
        },
        {
            name = "Sahara Camo",
            metadata = { "z_easyskins/camo/sahara"},
            rendering = 1,
        },
        {
            name = "ATACS",
            metadata = { "z_easyskins/camo/atacs"},
            rendering = 1,
        },
        {
            name = "ACU",
            metadata = { "skins/acu"},
            rendering = 1,
        },
    
        {
            name = "CityWhite",
            metadata = { "skins/citywhite"},
            rendering = 1,
        },
    
        {
            name = "clearsky",
            metadata = { "skins/clearsky"},
            rendering = 1,
        },
    
        {
            name = "desert",
            metadata = { "skins/desert"},
            rendering = 1,
        },
    
        {
            name = "erdl",
            metadata = { "skins/erdl"},
            rendering = 1,
        },
    
        {
            name = "flek",
            metadata = { "skins/flek"},
            rendering = 1,
        },
    
        {
            name = "german",
            metadata = { "skins/german"},
            rendering = 1,
        },
    
        {
            name = "gorka",
            metadata = { "skins/gorka"},
            rendering = 1,
        },
    
        {
            name = "jungle",
            metadata = { "skins/jungle"},
            rendering = 1,
        },
    
        {
            name = "multicam",
            metadata = { "skins/multicam"},
            rendering = 1,
        },
    
        {
            name = "pinkddpat",
            metadata = { "skins/pinkddpat"},
            rendering = 1,
        },
    
        {
            name = "russia",
            metadata = { "skins/russia"},
            rendering = 1,
        },
    
        {
            name = "ruswood",
            metadata = { "skins/ruswood"},
            rendering = 1,
        },
    
        {
            name = "snake",
            metadata = { "skins/snake"},
            rendering = 1,
        },
    
        {
            name = "urban",
            metadata = { "skins/urban"},
            rendering = 1,
        },
    
        {
            name = "vega",
            metadata = { "skins/vega"},
            rendering = 1,
        },
    
        {
            name = "woodland",
            metadata = { "skins/woodland"},
            rendering = 1,
        },
    
    
        -- Patterns
        {
            name = "Bananes",
            metadata = { "skins/banana"},
            rendering = 1,
        },
        {
            name = "Zebra",
            metadata = { "z_easyskins/camo/craze"},
            rendering = 1,
        },

        {
            name = "Dollars",
            metadata = { "z_easyskins/camo/dollars"},
            rendering = 1,
        },
        {
            name = "Gold",
            metadata = { "z_easyskins/camo/gold"},
            rendering = 1,
        },
        {
            name = "Aqua",
            metadata = { "z_easyskins/camo/aqua"},
            rendering = 1,
        },
        {
            name = "Wired",
            metadata = { "z_easyskins/camo/wired"},
            rendering = 1,
        },
        {
            name = "Flora",
            metadata = { "z_easyskins/camo/flora"},
            rendering = 1,
        },
        {
            name = "Day Of The Dead",
            metadata = { "z_easyskins/camo/dayofdead"},
            rendering = 1,
        },
        {
            name = "Coyote",
            metadata = { "z_easyskins/camo/coyote"},
            rendering = 1,
        },
        {
            name = "Breach",
            metadata = { "z_easyskins/camo/breach"},
            rendering = 1,
        },
        {
            name = "Color Blitz",
            metadata = { "z_easyskins/camo/blitz"},
            rendering = 1,
        },
        {
            name = "Blackops",
            metadata = { "z_easyskins/camo/blackops"},
            rendering = 1,
        },

        
        -- Better patterns
        {
            name = "shit",
            metadata = { "skins/shit"},
            rendering = 1,
        },
        {
            name = "Kawai",
            metadata = { "z_easyskins/camo/kawai"},
            rendering = 1,
        },
        {
            name = "Rainbow Zebra",
            metadata = { "z_easyskins/camo/zebra"},
            rendering = 1,
        },
        {
            name = "Graffiti",
            metadata = { "z_easyskins/camo/graffiti"},
            rendering = 1,
        },
        {
            name = "Ronin",
            metadata = { "z_easyskins/camo/ronin"},
            rendering = 1,
        },
        {
            name = "Comic",
            metadata = { "z_easyskins/camo/comic"},
            rendering = 1,
        },
        {
            name = "Der Riese",
            metadata = { "z_easyskins/camo/der_riese"},
            rendering = 1,
        },

        {
            name = "gold",
            metadata = { "skins/gold"},
            rendering = 1,
        },
        
        
        -- Animated
        {
            name = "Blackhole",
            metadata = { "z_easyskins/camo/blackhole"},
            rendering = 1,
        },

        {
            name = "Blue Wave",
            metadata = { "z_easyskins/camo/blue_wave"},
            rendering = 1,
        },
        {
            name = "Burn",
            metadata = { "z_easyskins/camo/burn"},
            rendering = 1,
        },
        {
            name = "Void",
            metadata = { "z_easyskins/camo/dark_matter"},
            rendering = 1,
        },
        {
            name = "Void Wave",
            metadata = { "z_easyskins/camo/dark_pulse"},
            rendering = 1,
        },
        {
            name = "Dragon Scales",
            metadata = { "z_easyskins/camo/dragon"},
            rendering = 1,
        },
        {
            name = "Gold Matter",
            metadata = { "z_easyskins/camo/gold_matter"},
            rendering = 1,
        },
        {
            name = "Stars",
            metadata = { "z_easyskins/camo/stars"},
            rendering = 1,
        },
        {
            name = "Ripple",
            metadata = { "z_easyskins/camo/ripple"},
            rendering = 1,
        },
    }
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_fc3_head.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_fortnitebag.lua:
ashop.RegisterPremade("Fortnite Bag", {
        requireWorkshop = "2808525184",

        objectTypes = {
            {
                "Wearables",
                {"ValveBiped.Bip01_Spine2"},
                ashop.L('ClothesDefaultBack')
            },
        },

        items = {
            {
                name = "Adventure Bag",
                rendering = 1,
                metadata = {
                    [1] = 'models/adventure bag/adventure bag.mdl',
                    [3] = Vector(5.375, -0.75, 0),
                    [4] = Angle(0, 90.3125, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Adventure Bag 2",
                rendering = 1,
                metadata = {
                    [1] = 'models/adventure bag/adventure bag.mdl',
                    [3] = Vector(5.375, -0.75, 0),
                    [4] = Angle(0, 90.3125, 89.875),
                    [10] = false,
                    [11] = 0
                },
            },

            {
                name = "Adventure Bag 3",
                rendering = 1,
                metadata = {
                    [1] = 'models/adventure bag/adventure bag.mdl',
                    [3] = Vector(5.375, -0.75, 0),
                    [4] = Angle(0, 90.3125, 89.875),
                    [10] = false,
                    [11] = 2
                },
            },

            {
                name = "Alien Bag",
                rendering = 1,
                metadata = {
                    [1] = 'models/alien backpack/alien backpack.mdl',
                    [4] = Angle(0, 90.3125, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Antidote Bag",
                rendering = 1,
                metadata = {
                    [1] = 'models/antidote/antidote.mdl',
                    [3] = Vector(4.8125, 0, 0),
                    [4] = Angle(0, 90.3125, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Antidote Purple Bag",
                rendering = 1,
                metadata = {
                    [1] = 'models/antidote purple/antidote purple.mdl',
                    [3] = Vector(-5.375, 0, 0),
                    [4] = Angle(0, 90.3125, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Antidote Toxin Bag",
                rendering = 1,
                metadata = {
                    [1] = 'models/antidote toxin/antidote toxin.mdl',
                    [3] = Vector(-5.375, -0.75, 0),
                    [4] = Angle(0, 94.90625, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Basecamp Bag Hazard",
                rendering = 1,
                metadata = {
                    [1] = 'models/basecamp bag hazard/basecamp bag hazard.mdl',
                    [3] = Vector(5.5, 0, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Blade Bag",
                rendering = 1,
                metadata = {
                    [1] = 'models/blade bag/blade bag.mdl',
                    [3] = Vector(5.09375, 0.0625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Blade Bag Chic",
                rendering = 1,
                metadata = {
                    [1] = 'models/blade bag chic/blade bag chic.mdl',
                    [3] = Vector(5.09375, -0.90625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Blade Bag Yellow",
                rendering = 1,
                metadata = {
                    [1] = 'models/blade bag yellow/blade bag yellow.mdl',
                    [3] = Vector(5.09375, -0.90625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Cryo Chamber",
                rendering = 1,
                metadata = {
                    [1] = 'models/cryo chamber/cryo chamber.mdl',
                    [3] = Vector(1.3125, -0.90625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Double Play",
                rendering = 1,
                metadata = {
                    [1] = 'models/double play/double play.mdl',
                    [3] = Vector(4.375, 0.625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Foundations Cape",
                rendering = 1,
                metadata = {
                    [1] = 'models/foundations cape/foundations cape.mdl',
                    [3] = Vector(-55, 4.9375, 3.96875),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Foxbow Quivers",
                rendering = 1,
                metadata = {
                    [1] = 'models/foxbow quivers/foxbow quivers.mdl',
                    [3] = Vector(5.65625, -0.46875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                },
            },

            {
                name = "Foxbow Quivers 2",
                rendering = 1,
                metadata = {
                    [1] = 'models/foxbow quivers/foxbow quivers.mdl',
                    [3] = Vector(5.65625, -0.46875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Hot Wings",
                rendering = 1,
                metadata = {
                    [1] = 'models/hot wings/hot wings.mdl',
                    [3] = Vector(4.375, 0.625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Hot Wings 2",
                rendering = 1,
                metadata = {
                    [1] = 'models/hot wings/hot wings.mdl',
                    [3] = Vector(4.375, 0.625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 1,
                },
            },

            {
                name = "Mechafusion Interface",
                rendering = 1,
                metadata = {
                    [1] = 'models/mechafusion interface/mechafusion interface.mdl',
                    [3] = Vector(4.375, 0.625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Mechafusion Interface 2",
                rendering = 1,
                metadata = {
                    [1] = 'models/mechafusion interface/mechafusion interface.mdl',
                    [3] = Vector(4.375, 0.625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 1,
                },
            },

            {
                name = "Mechafusion Interface 3",
                rendering = 1,
                metadata = {
                    [1] = 'models/mechafusion interface/mechafusion interface.mdl',
                    [3] = Vector(4.375, 0.625, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 2,
                },
            },

            {
                name = "Jumpkit",
                rendering = 1,
                metadata = {
                    [1] = 'models/mechafusion jumpkit/mechafusion jumpkit.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 2,
                },
            },

            {
                name = "Offworld Rig",
                rendering = 1,
                metadata = {
                    [1] = 'models/offworld rig/offworld rig.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 2,
                },
            },

            {
                name = "Ooze Chamber",
                rendering = 1,
                metadata = {
                    [1] = 'models/ooze chamber/ooze chamber.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Ooze Chamber 2",
                rendering = 1,
                metadata = {
                    [1] = 'models/ooze chamber/ooze chamber.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 1,
                },
            },

            {
                name = "Ooze Chamber 3",
                rendering = 1,
                metadata = {
                    [1] = 'models/ooze chamber/ooze chamber.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 2,
                },
            },

            {
                name = "Prospecte",
                rendering = 1,
                metadata = {
                    [1] = 'models/prospect/prospecte.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Psytronic Bow",
                rendering = 1,
                metadata = {
                    [1] = 'models/psytronic bow/psytronic bow.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Psytronic Bow 2",
                rendering = 1,
                metadata = {
                    [1] = 'models/psytronic bow/psytronic bow.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 1,
                },
            },

            {
                name = "Psytronic Bow 3",
                rendering = 1,
                metadata = {
                    [1] = 'models/psytronic bow/psytronic bow.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 2,
                },
            },

            {
                name = "Ready Ruck",
                rendering = 1,
                metadata = {
                    [1] = 'models/ready ruck/ready ruck.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Ready Ruck Green",
                rendering = 1,
                metadata = {
                    [1] = 'models/ready ruck/ready ruck green.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Ready Ruck White",
                rendering = 1,
                metadata = {
                    [1] = 'models/ready ruck/ready ruck white.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Shattered Wings",
                rendering = 1,
                metadata = {
                    [1] = 'models/shattered wings/shattered wings.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 89.875, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Shots and shells",
                rendering = 1,
                metadata = {
                    [1] = 'models/shots and shells/shots and shells.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 101.3125, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Slashed",
                rendering = 1,
                metadata = {
                    [1] = 'models/slashed/slashed.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 101.3125, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Star Surge",
                rendering = 1,
                metadata = {
                    [1] = 'models/star surge/star surge.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 83.9375, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Star Surge 2",
                rendering = 1,
                metadata = {
                    [1] = 'models/star surge/star surge.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 83.9375, 89.875),
                    [10] = false,
                    [11] = 1,
                },
            },

            {
                name = "Tackle Box",
                rendering = 1,
                metadata = {
                    [1] = 'models/tackle box/tackle box.mdl',
                    [3] = Vector(4.375, -1.1875, 0),
                    [4] = Angle(-0.21875, 83.9375, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Tahna",
                rendering = 1,
                metadata = {
                    [1] = 'models/tahna/tahna.mdl',
                    [3] = Vector(3.125, -1.875, 0),
                    [4] = Angle(-0.21875, 83.9375, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Tackle Box Riptide",
                rendering = 1,
                metadata = {
                    [1] = 'models/tackle box riptide/tackle box riptide.mdl',
                    [3] = Vector(3.125, -1.875, 0),
                    [4] = Angle(-0.21875, 83.9375, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Trendsetter",
                rendering = 1,
                metadata = {
                    [1] = 'models/trendsetter/trendsetter.mdl',
                    [3] = Vector(6.34375, -1.59375, 0),
                    [4] = Angle(-0.21875, 83.9375, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },

            {
                name = "Vintage",
                rendering = 1,
                metadata = {
                    [1] = 'models/vintage/vintage.mdl',
                    [3] = Vector(6.34375, -1.59375, 0),
                    [4] = Angle(-0.21875, 83.9375, 89.875),
                    [10] = false,
                    [11] = 0,
                },
            },
        }
    }
)
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gtav_facemask.lua:
ashop.RegisterPremade("GTAV Facemask", {
    requireWorkshop = "572310302",

    objectTypes = {
        {
            "Wearables",
            {"ValveBiped.Bip01_Head1"},
            "Facemask"
        }
    },

    items = {
        {
            name = "Bandana",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/bandana.mdl',
                [3] = Vector(-1.125, -0.625, -0.0625),
                [4] = Angle(0, -90.3125, -90.3125),
                [7] = Vector(1, 1, 1),

                [10] = false,
                [12] = 150,
                [13] = Vector(200, 200, 200)
            }
        },

        {
            name = "Mask",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/mask5.mdl',
                [3] = Vector(-0.21875, -0.96875, -0.125),
                [4] = Angle(-3.375, -67, -90.3125),
                [7] = Vector(1, 1, 1),

                [10] = false,
                [12] = 150,
                [13] = Vector(200, 131, 105)
            }
        },

        {
            name = "Mask 2",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/mask6.mdl',
                [3] = Vector(-0.21875, -0.96875, -0.125),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.875, 0.9375, 0.875),

                [10] = false,
                [12] = 150,
                [13] = Vector(200, 134, 101)
            }
        },

        {
            name = "Mask 3",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/mask6.mdl',
                [3] = Vector(-0.21875, -0.96875, -0.125),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.875, 0.9375, 0.875),

                [10] = false,
                [11] = 2,
                [12] = 150,
                [13] = Vector(200, 134, 101)
            }
        },

        {
            name = "Mask 4",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/mask6.mdl',
                [3] = Vector(-0.21875, -0.96875, -0.125),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.875, 0.9375, 0.875),

                [10] = false,
                [11] = 0,
                [12] = 150,
                [13] = Vector(200, 134, 101)
            }
        },

        {
            name = "Mask 5",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/mask6.mdl',
                [3] = Vector(-0.21875, -0.96875, -0.125),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.875, 0.9375, 0.875),

                [10] = false,
                [11] = 3,
                [12] = 150,
                [13] = Vector(200, 134, 101)
            }
        },

        {
            name = "Bear",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/bear.mdl',
                [3] = Vector(1.46875, 0, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.96875, 0.96875, 0.96875),
                [10] = false,
                [11] = 3,
                [12] = 190,
                [13] = Vector(200, 132, 44)
            }
        },

        {
            name = "Cat",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/cat.mdl',
                [3] = Vector(1.46875, 0, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.96875, 0.96875, 0.96875),
                [10] = false,
                [11] = 3,
                [12] = 160,
                [13] = Vector(200, 125, 51)
            }
        },

        {
            name = "Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/fox.mdl',
                [3] = Vector(1.46875, 0, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [10] = false,
                [11] = 3,
                [12] = 180,
                [13] = Vector(200, 119, 24)
            }
        },

        {
            name = "Gingerbread",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/gingerbread.mdl',
                [3] = Vector(1.46875, 0, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [10] = false,
                [11] = 3,
                [12] = 150,
                [13] = Vector(200, 130, 115)
            }
        },

        {
            name = "Hawk",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/hawk_1.mdl',
                [3] = Vector(-1.59375, -0.71875, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [10] = false,
                [11] = 0,
                [12] = 180,
                [13] = Vector(200, 130, 92)
            }
        },

        {
            name = "Hawk 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/hawk_2.mdl',
                [3] = Vector(-1.59375, -0.71875, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [10] = false,
                [11] = 0,
                [12] = 200,
                [13] = Vector(200, 130, 94)
            }
        },

        {
            name = "Owl",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/owl.mdl',
                [3] = Vector(0.3125, -0.65625, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [10] = false,
                [11] = 0,
                [12] = 160,
                [13] = Vector(200, 139, 52)
            }
        },

        {
            name = "Penguin",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/penguin.mdl',
                [3] = Vector(1.1875, 0.0625, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.96875, 1.03125, 1),
                [10] = false,
                [11] = 0,
                [12] = 150,
                [13] = Vector(200, 126, 104)
            }
        },

        {
            name = "Pig",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/pig.mdl',
                [3] = Vector(-0.0625, -0.78125, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.96875, 1.03125, 1),
                [10] = false,
                [11] = 0,
            }
        },

        {
            name = "Pig 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/pig.mdl',
                [3] = Vector(-0.0625, -0.78125, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.96875, 1.03125, 1),
                [10] = false,
                [11] = 1,
                [12] = 150,
                [13] = Vector(200, 81, 100)
            }
        },

        {
            name = "Wolf",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/wolf.mdl',
                [3] = Vector(-0.0625, -0.78125, 0),
                [4] = Angle(-0.21875, -66.5, -90.3125),
                [7] = Vector(0.96875, 0.96875, 1),
                [10] = false,
                [11] = 0,
                [12] = 180,
                [13] = Vector(200, 135, 57)
            }
        },

        {
            name = "Mask 6",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(-0.125, -0.96875, -0.125),
                [4] = Angle(-3.375, -67, -90.3125),
                [10] = false,
                [11] = 0,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 7",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.125, -0.9375, -0.125),
                [4] = Angle(-3.375, -67, -90.3125),
                [10] = false,
                [11] = 1,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 8",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 2,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 9",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 3,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 10",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 4,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 11",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 5,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 12",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 6,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 13",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 7,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 14",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 8,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 15",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 9,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 16",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 10,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 17",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 11,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 18",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 12,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 19",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 13,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 20",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_2.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 14,
                [12] = 150,
                [13] = Vector(200, 132, 105)
            }
        },

        {
            name = "Mask 21",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 0,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 22",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 1,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 23",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 2,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 24",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 3,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 25",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 4,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 26",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 5,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 27",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 6,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 28",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 7,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 29",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 8,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Mask 29",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/mask_4.mdl',
                [3] = Vector(0.0625, -0.78125, -0.15625),
                [4] = Angle(-0.21875, -67, -89.875),
                [10] = false,
                [11] = 8,
                [12] = 150,
                [13] = Vector(200, 131, 119)
            }
        },

        {
            name = "Head Wrap 1",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/headwrap1.mdl',
                [4] = Angle(180, 89.875, 90.3125),
                [10] = false,
            },
        },

        {
            name = "Head Wrap 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/headwrap1.mdl',
                [4] = Angle(180, 89.875, 90.3125),
                [10] = false,
                [11] = 4,
            },
        },

        {
            name = "Head Wrap 3",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/headwrap2.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
            },
        },

        {
            name = "Head Wrap 4",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/headwrap2.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 1,
            },
        },

        {
            name = "Head Wrap 5",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/headwrap2.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 2,
            },
        },

        {
            name = "Head Wrap 6",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/headwrap2.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 3,
            },
        },

        {
            name = "Monkey",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/monkey.mdl',
                [3] = Vector(0.46875, -1.03125, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
            },
        },

        {
            name = "Monkey 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/monkey.mdl',
                [3] = Vector(0.46875, -1.03125, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 1,
            },
        },

        {
            name = "Monkey 3",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/monkey.mdl',
                [3] = Vector(0.46875, -1.03125, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 2,
            },
        },

        {
            name = "Monkey 4",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/monkey.mdl',
                [3] = Vector(0.46875, -1.03125, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 3,
            },
        },

        {
            name = "Ninja",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 0,
            },
        },

        {
            name = "Ninja 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 1,
            },
        },

        {
            name = "Ninja 3",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 2,
            },
        },

        {
            name = "Ninja 4",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 3,
            },
        },

        {
            name = "Ninja 5",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 4,
            },
        },

        {
            name = "Ninja 6",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 5,
            },
        },

        {
            name = "Ninja 7",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 6,
            },
        },

        {
            name = "Ninja 8",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 7,
            },
        },

        {
            name = "Ninja 9",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 8,
            },
        },

        {
            name = "Ninja 10",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 9,
            },
        },

        {
            name = "Ninja 11",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/ninja.mdl',
                [3] = Vector(-0.0625, -1.1875, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 10,
            },
        },

        {
            name = "Skull",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/skull.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
            },
        },

        {
            name = "Skull 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/skull.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 1,
            },
        },

        {
            name = "Skull 3",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/skull.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 2,
            },
        },

        {
            name = "Skull 4",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/skull.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 3,
            },
        },

        {
            name = "Frankenstein",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/zombie.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 0,
            },
        },

        {
            name = "Frankenstein 1",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/zombie.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 1,
            },
        },

        {
            name = "Bag",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/bag.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
            },
        },

        {
            name = "Bag 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/bag.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 1,
            },
        },

        {
            name = "Bag 3",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/bag.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 2,
            },
        },

        {
            name = "Bag 4",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/bag.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 3,
            },
        },

        {
            name = "Bag 5",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/bag.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 11,
            },
        },

        {
            name = "Bag 6",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/bag.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 16,
            },
        },

        {
            name = "Bag 7",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/halloween/bag.mdl',
                [3] = Vector(1.3125, -0.90625, 0.0625),
                [4] = Angle(-0.21875, -74.78125, -90.3125),
                [10] = false,
                [11] = 22,
            },
        },
    },
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gtav_glasses.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_kf2_hats.lua:
ashop.RegisterPremade("KF2 Hats", {
        requireWorkshop = "438680332",

        objectTypes = {
            {
                "Wearables",
                {"ValveBiped.Bip01_Head1"},
                "Hat"
            },

            {
                "Wearables",
                {"ValveBiped.Bip01_Head1"},
                "Facemask"
            },
        },

        items = {
        {
            name = "Scully Beanie",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scully_beanie.mdl',
                [10] = true,
            },
        },

        {
            name = "Scully Beanie 2",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scully_beanie.mdl',
                [10] = true,
                [11] = 1
            },
        },

        {
            name = "Scully Beanie 3",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scully_beanie.mdl',
                [10] = true,
                [11] = 2
            },
        },

        {
            name = "Scully Beanie 4",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scully_beanie.mdl',
                [10] = true,
                [11] = 3
            },
        },

        {
            name = "Scully Beanie 5",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scully_beanie.mdl',
                [10] = true,
                [11] = 4
            },
        },

        {
            name = "Scully Headphones",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scullyphones.mdl',
                [10] = true,
            },
        },

        {
            name = "Scully Headphones 2",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scullyphones.mdl',
                [10] = true,
                [11] = 1
            },
        },

        {
            name = "Scully Headphones 3",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scullyphones.mdl',
                [10] = true,
                [11] = 2
            },
        },

        {
            name = "Scully Headphones 4",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scullyphones.mdl',
                [10] = true,
                [11] = 3
            },
        },

        {
            name = "Scully Headphones 5",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scullyphones.mdl',
                [10] = true,
                [11] = 4
            },
        },

        {
            name = "Scully Headphones 6",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/scullyphones.mdl',
                [10] = true,
                [11] = 5
            },
        },

        {
            name = "Tanaka Bandana",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/tanaka_bandana.mdl',
                [10] = true,
            },
        },

        {
            name = "Tanaka Bandana 2",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/tanaka_bandana.mdl',
                [10] = true,
                [11] = 1
            },
        },

        {
            name = "Tanaka Bandana 3",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/tanaka_bandana.mdl',
                [10] = true,
                [11] = 2
            },
        },

        {
            name = "Tanaka Bandana 4",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/tanaka_bandana.mdl',
                [10] = true,
                [11] = 3
            },
        },

        {
            name = "Gaz Mask",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/gas_mask.mdl',
                [10] = true,
            },
        },

        {
            name = "Gaz Mask 2",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/gas_mask.mdl',
                [10] = true,
                [11] = 1,
            },
        },

        {
            name = "Gaz Mask 3",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/gas_mask.mdl',
                [10] = true,
                [11] = 2,
            },
        },

        {
            name = "Gaz Mask 4",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/gas_mask.mdl',
                [10] = true,
                [11] = 3,
            },
        },

        {
            name = "Coleman Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/coleman_hat.mdl',
                [10] = true,
            },
        },

        {
            name = "Coleman Hat 2",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/coleman_hat.mdl',
                [10] = true,
                [11] = 1,
            },
        },

        {
            name = "Coleman Hat 3",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/coleman_hat.mdl',
                [10] = true,
                [11] = 2,
            },
        },

        {
            name = "Coleman Hat 4",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/coleman_hat.mdl',
                [10] = true,
                [11] = 3,
            },
        },

        {
            name = "Police Helmet",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/briars_helmet.mdl',
                [10] = true,
            },
        },

        {
            name = "Briars Helmet",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/briars_helmet.mdl',
                [10] = true,
            },
        },

        {
            name = "Briars Helmet 2",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/briars_helmet.mdl',
                [10] = true,
                [11] = 1
            },
        },

        {
            name = "Briars Helmet 3",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/briars_helmet.mdl',
                [10] = true,
                [11] = 2
            },
        },

        {
            name = "Briars Helmet 4",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/briars_helmet.mdl',
                [10] = true,
                [11] = 3
            },
        },

        {
            name = "Briars Helmet 5",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/briars_helmet.mdl',
                [10] = true,
                [11] = 4
            },
        },

        {
            name = "Briars Helmet 6",
            rendering = 2,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/briars_helmet.mdl',
                [10] = true,
                [11] = 5
            },
        },

        {
            name = "Albert\'s Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/albert_hat.mdl',
                [10] = true,
            },
        },

        {
            name = "Albert\'s Hat 2",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/albert_hat.mdl',
                [10] = true,
                [11] = 1
            },
        },

        {
            name = "Albert\'s Hat 3",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/albert_hat.mdl',
                [10] = true,
                [11] = 2
            },
        },

        {
            name = "Albert\'s Hat 4",
            rendering = 1,
            metadata = {
                [1] = 'models/splinks/kf2/cosmetics/albert_hat.mdl',
                [10] = true,
                [11] = 3
            },
        },
    }
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_lol_pets.lua:
ashop.RegisterPremade("LoL Pets", {
    requireWorkshop = "2051999464",

    objectTypes = {
        {
            "Pets",
        }
    },

    items = {
        {
            name = "Green Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/fox_pet.mdl',
                [2] = 0,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Blue Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/fox_pet.mdl',
                [2] = 1,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Pink Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/fox_pet.mdl',
                [2] = 2,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Red Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/fox_pet.mdl',
                [2] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "White Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/fox_pet.mdl',
                [2] = 4,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Autumn Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/fox_pet.mdl',
                [2] = 5,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Purple Fox",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/fox_pet.mdl',
                [2] = 6,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Blue Gargoyle",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/gargoyle_pet.mdl',
                [2] = 0,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "White-Orange Gargoyle",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/gargoyle_pet.mdl',
                [2] = 1,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Ghost Gargoyle",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/gargoyle_pet.mdl',
                [2] = 2,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Red Gargoyle",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/gargoyle_pet.mdl',
                [2] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Gold Gargoyle",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/gargoyle_pet.mdl',
                [2] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Light blue Gargoyle",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/gargoyle_pet.mdl',
                [2] = 4,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Orange Tiger",
            rendering = 0,
            metadata = {
                [1] = 'models/gonzo/tiger_pet.mdl',
                [2] = 0,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Red Tiger",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/tiger_pet.mdl',
                [2] = 1,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Red/Gold Tiger",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/tiger_pet.mdl',
                [2] = 2,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Light Tiger",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/tiger_pet.mdl',
                [2] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Dark Tiger",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/tiger_pet.mdl',
                [2] = 4,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Griffin",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/griffin_pet.mdl',
                [2] = 0,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Yellow Griffin",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/griffin_pet.mdl',
                [2] = 1,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Macao Griffin",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/griffin_pet.mdl',
                [2] = 2,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Red/White Griffin",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/griffin_pet.mdl',
                [2] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Pink Griffin",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/griffin_pet.mdl',
                [2] = 4,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Dark Griffin",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/griffin_pet.mdl',
                [2] = 5,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Blue Buglet",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/buglet_pet.mdl',
                [2] = 0,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Sand Buglet",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/buglet_pet.mdl',
                [2] = 1,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Red Buglet",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/buglet_pet.mdl',
                [2] = 2,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Green Buglet",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/buglet_pet.mdl',
                [2] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Yellow Buglet",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/buglet_pet.mdl',
                [2] = 4,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Purple Buglet",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/buglet_pet.mdl',
                [2] = 5,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Akalid",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/akalid_pet.mdl',
                [2] = 0,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Red Akalid",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/akalid_pet.mdl',
                [2] = 1,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "White Akalid",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/akalid_pet.mdl',
                [2] = 2,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Blue Akalid",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/akalid_pet.mdl',
                [2] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Yellow Akalid",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/akalid_pet.mdl',
                [2] = 4,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },

        {
            name = "Night Akalid",
            rendering = 1,
            metadata = {
                [1] = 'models/gonzo/akalid_pet.mdl',
                [2] = 5,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 1,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 1,
                    },
                },
                [6] = {
                },
                [7] = {
                },
                [9] = 0.40000000596046,
            },
        },
    }
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_simsbob.lua:
return gluapack()()
--addons/sh_reports/lua/reports_config.lua:
/**
* General configuration
**/

-- Usergroups allowed to view/handle reports
SH_REPORTS.Usergroups = {
    ["denemerehber"] = true,
    ["rehber"] = true,
    ["rehber1"] = true,
    ["rehber2"] = true,
    ["rehber3"] = true,
    ["rehber4"] = true,
    ["denememoderator"] = true,
    ["moderator"] = true,
    ["moderator2"] = true,
    ["eventmanager"] = true,
    ["moderator3"] = true,
    ["denetmen"] = true,
    ["superyetki"] = true,
    ["genelyetkili"] = true,
    ["toplulukyoneticisi"] = true,
    ["admin"] = true, 
    ["superadmin"] = true,
}

-- Usergroups allowed to view performance reports
SH_REPORTS.UsergroupsPerformance = {
    ["denemerehber"] = true,
    ["rehber"] = true,
    ["rehber1"] = true,
    ["rehber2"] = true,
    ["rehber3"] = true,
    ["rehber4"] = true,
    ["superyetki"] = true,
    ["denememoderator"] = true,
    ["moderator"] = true,
    ["moderator2"] = true,
    ["eventmanager"] = true,
    ["moderator3"] = true,
    ["denetmen"] = true,
    ["genelyetkili"] = true,
    ["toplulukyoneticisi"] = true,
    ["admin"] = true, 
    ["superadmin"] = true,
}

-- Customize your report reasons here.
-- Try to keep them short as they appear in full in the reports list.
SH_REPORTS.ReportReasons = {
    "RDM",
    "RDA",
    "FailRP",
    "Küfür",
    "NLR",
    "Diğer", 
    "MassRDM",
    "FearRP",
    "Troll",
    "SelfySupply",
}
-- How many reports can a player make?
SH_REPORTS.MaxReportsPerPlayer = 1

-- Play a sound to admins whenever a report is made?
SH_REPORTS.NewReportSound = {
	enabled = true,
	path = Sound("buttons/button16.wav"),
}

-- Enable ServerLog support? Any actions related to reports will be ServerLog'd IN ENGLISH if true.
-- NOTE: ServerLogs are in English.
SH_REPORTS.UseServerLog = true

-- Should admins be able to create reports?
SH_REPORTS.StaffCanReport = true

-- Can players report admins?
SH_REPORTS.StaffCanBeReported = true

-- Should admins be able to delete unclaimed reports?
SH_REPORTS.CanDeleteWhenUnclaimed = false

-- Notify admins when they connect of any unclaimed reports?
SH_REPORTS.NotifyAdminsOnConnect = true

-- Can players report "Other"?
-- Other is no player in particular; but players can make a report with Other if they want a sit or something.
SH_REPORTS.CanReportOther = true

-- Use ULX commands for teleporting? (allows returning etc.)
SH_REPORTS.UseULXCommands = false

-- Key binding to open the Make Report menu.
SH_REPORTS.ReportKey = KEY_F10

-- Key binding to open the Report List menu.
SH_REPORTS.ReportsKey = KEY_F11

-- Should players be asked for rating the admin after their report gets closed?
SH_REPORTS.AskRating = true

-- Should admins know whenever a player rates them?
SH_REPORTS.NotifyRating = false

-- Should players be teleported back to their position after their report gets closed?
SH_REPORTS.TeleportPlayersBack = true

-- How many pending reports to show on admin's screen?
SH_REPORTS.PendingReportsDispNumber = 3

-- Allows admins to claim reports without teleporting?
-- If true, the Goto and Bring commands will be hidden.
SH_REPORTS.ClaimNoTeleport = false

-- Use Steam Workshop for the custom content?
-- If false, custom content will be downloaded through FastDL.
SH_REPORTS.UseWorkshop = true

/**
* Command configuration
**/

-- Chat commands which can open the View Reports menu (for admins)
-- ! are automatically replaced by / and inputs are made lowercase for convenience.
SH_REPORTS.AdminCommands = {
	["/reports"] = true,
	["/reportlist"] = true,
}

-- Chat commands which can open the Make Report menu (for players)
-- ! are automatically replaced by / and inputs are made lowercase for convenience.
SH_REPORTS.ReportCommands = {
	["!calladmin"] = true,
	["/calladmin"] = true,
    ["!destek"] = true,
    ["@"] = true,
    ["/destek"] = true,
}

-- Enable quick reporting with @?
-- Typing "@this guy RDM'd me" would open the Make Report menu with the text as a comment.
-- Might conflict with add-ons relying on @ commands.
-- NOTE: Admins cannot use this feature.
SH_REPORTS.EnableQuickReport = true

/**
* Performance reports configuration
**/

-- How should performance reports be saved?
-- Possible options: sqlite, mysqloo
-- mysqloo requires gmsv_mysqloo to be installed on your server.
-- You can configure MySQL credentials in reports/lib_database.lua
SH_REPORTS.DatabaseMode = "sqlite"

-- What should be the frequency of performance reports?
-- Possible options: daily, weekly, monthly
SH_REPORTS.PerformanceFrequency = "daily"

-- If the above option is weekly, on what day of the week
-- should new performance reports be created? (always at midnight)
-- 0: Sunday
-- 1: Monday
-- 2: Tuesday
-- 3: Wednesday
-- 4: Thursday
-- 5: Friday
-- 6: Saturday
SH_REPORTS.PerformanceWeekDay = 1

-- Should reports created by admins count for the performance reports and ratings?
SH_REPORTS.AdminReportsCount = false

/**
* Storage configuration
**/

-- Should reports closed by an admin be stored?
-- Useful if you want to see a past report, and what rating the admin got.
-- Possible options: none, sqlite, mysqloo
-- none disables this feature.
SH_REPORTS.StoreCompletedReports = "mysqloo"

-- Should reports be purged after some time? In seconds.
-- Purges are done on map start to avoid performance loss.
-- Set to 0 to make stored reports never expire.
-- Beware! Too many reports may prevent you from seeing the history properly due to large amounts of data to send.
SH_REPORTS.StorageExpiryTime = 86400 * 7

/**
* Advanced configuration
* Edit at your own risk!
**/

SH_REPORTS.MaxCommentLength = 2048

SH_REPORTS.DateFormat = "%Y/%m/%d"

SH_REPORTS.TimeFormat = "%Y/%m/%d %H:%M:%S"

-- When making a report with the "RDM" reason
-- it will automatically select the player who last killed you.
-- If you modify the report reasons above make sure to modify those here as well for convenience.
SH_REPORTS.ReasonAutoTarget = {
	["RDM"] = "killer",
	["RDA"] = "arrester",
}

/**
* Theme configuration
**/

-- Font to use for normal text throughout the interface.
SH_REPORTS.Font = "Circular Std Medium"

-- Font to use for bold text throughout the interface.
SH_REPORTS.FontBold = "Circular Std Bold"

-- Color sheet. Only modify if you know what you're doing
SH_REPORTS.Style = {
	header = Color(52, 152, 219, 255),
	bg = Color(52, 73, 94, 255),
	inbg = Color(44, 62, 80, 255),

	close_hover = Color(231, 76, 60, 255),
	hover = Color(255, 255, 255, 10, 255),
	hover2 = Color(255, 255, 255, 5, 255),

	text = Color(255, 255, 255, 255),
	text_down = Color(0, 0, 0),
	textentry = Color(44, 62, 80),
	menu = Color(127, 140, 141),

	success = Color(46, 204, 113),
	failure = Color(231, 76, 60),
	rating = Color(241, 196, 15),
}

/**
* Language configuration
**/

-- Various strings used throughout the add-on.
-- Available languages: english, french, german
-- To add your own language, see the reports/language folder
-- You may need to restart the map after changing the language!
SH_REPORTS.LanguageName = "english"
--addons/sh_reports/lua/reports/cl_main.lua:
return gluapack()()
--addons/sh_reports/lua/reports/cl_menu_main.lua:
return gluapack()()
--addons/sh_reports/lua/reports/cl_menu_main.lua:
local function L(...) return SH_REPORTS:L(...) end

local matBack = Material("shenesis/general/back.png")

function SH_REPORTS:ShowReport(report)
	if (IsValid(_SH_REPORTS_VIEW)) then
		_SH_REPORTS_VIEW:Remove()
	end

	local styl = self.Style
	local th, m = self:GetPadding(), self:GetMargin()
	local m2 = m * 0.5
	local ss = self:GetScreenScale()

	local frame = self:MakeWindow(L"view_report")
	frame:SetSize(500 * ss, 400 * ss)
	frame:Center()
	frame:MakePopup()
	_SH_REPORTS_VIEW = frame

		frame:AddHeaderButton(matBack, function()
			frame:Close()
			self:ShowReports()
		end)

		local body = vgui.Create("DPanel", frame)
		body:SetDrawBackground(false)
		body:DockPadding(m, m, m, m)
		body:Dock(FILL)

			local players = vgui.Create("DPanel", body)
			players:SetDrawBackground(false)
			players:SetWide(frame:GetWide() - m * 2)
			players:Dock(TOP)

				local lbl1 = self:QuickLabel(L"reporter", "{prefix}Large", styl.text, players)
				lbl1:SetContentAlignment(7)
				lbl1:SetTextInset(m2, m2)
				lbl1:SetWide(frame:GetWide() * 0.5 - m2)
				lbl1:Dock(LEFT)
				lbl1:DockPadding(m2, lbl1:GetTall() + m * 1.5, m2, m2)
				lbl1.Paint = function(me, w, h)
					draw.RoundedBox(4, 0, 0, w, h, styl.inbg)
				end

					local avi = self:Avatar(report.reporter_id, 32, lbl1)
					avi:Dock(LEFT)
					avi:DockMargin(0, 0, m2, 0)

					local nic = self:QuickButton(report.reporter_name, function()
						SetClipboardText(report.reporter_name)
						surface.PlaySound("common/bugreporter_succeeded.wav")
					end, lbl1)
					nic:SetContentAlignment(4)
					nic:Dock(TOP)

					local s1 = util.SteamIDFrom64(report.reporter_id)
					local steamid = self:QuickButton(s1, function()
						SetClipboardText(s1)
						surface.PlaySound("common/bugreporter_succeeded.wav")
					end, lbl1)
					steamid:SetContentAlignment(4)
					steamid:Dock(TOP)

				local lbl = self:QuickLabel(L"reported_player", "{prefix}Large", styl.text, players)
				lbl:SetContentAlignment(9)
				lbl:SetTextInset(m2, m2)
				lbl:Dock(FILL)
				lbl:DockPadding(m2, lbl1:GetTall() + m * 1.5, m2, m2)
				lbl.Paint = lbl1.Paint

					local avi = self:Avatar(report.reported_id, 32, lbl)
					avi:Dock(RIGHT)
					avi:DockMargin(m2, 0, 0, 0)

					local nic = self:QuickButton(report.reported_name, function()
						SetClipboardText(report.reported_name)
						surface.PlaySound("common/bugreporter_succeeded.wav")
					end, lbl)
					nic:SetContentAlignment(6)
					nic:Dock(TOP)
					nic.Think = function(me)
						me:SetTextColor(IsValid(player.GetBySteamID64(report.reported_id)) and styl.text or styl.failure)
					end

					local s2 = util.SteamIDFrom64(report.reported_id)
					local steamid = self:QuickButton(s2, function()
						SetClipboardText(s2)
						surface.PlaySound("common/bugreporter_succeeded.wav")
					end, lbl)
					steamid:SetContentAlignment(6)
					steamid:Dock(TOP)

					if (report.reported_id == "0") then
						nic.Think = function() end
						nic:Dock(FILL)
						steamid:SetVisible(false)
						avi:SetVisible(false)
					end

				players:SetTall(lbl1:GetTall() + m * 2.5 + 32)

			local reason = self:QuickLabel(L("reason") .. ":", "{prefix}Medium", styl.text, body)
			reason:Dock(TOP)
			reason:DockMargin(0, m, 0, 0)
			reason:DockPadding(reason:GetWide() + m2, 0, 0, 0)

				local r = self:QuickEntry(self.ReportReasons[report.reason_id], reason)
				r:SetEnabled(false)
				r:SetContentAlignment(6)
				r:Dock(FILL)

			local comment = self:QuickLabel(L("comment") .. ":", "{prefix}Medium", styl.text, body)
			comment:SetContentAlignment(7)
			comment:Dock(FILL)
			comment:DockMargin(0, m, 0, m2)

				local tx = self:QuickEntry("", comment)
				tx:SetEnabled(false)
				tx:SetMultiline(true)
				tx:SetValue(report.comment)
				tx:Dock(FILL)
				tx:DockMargin(0, comment:GetTall() + m2, 0, 0)

			local actions = vgui.Create("DPanel", body)
			actions:SetDrawBackground(false)
			actions:Dock(BOTTOM)

				if (self:IsAdmin(LocalPlayer())) then
					if (report.admin_id == "") then
						if (self.ClaimNoTeleport) then
							local claim = self:QuickButton(L"claim_report", function()
								easynet.SendToServer("SH_REPORTS.Claim", {id = report.id})
							end, actions)
							claim:Dock(LEFT)
						else
							local lbl = self:QuickLabel(L("claim_report") .. ":", "{prefix}Medium", styl.text, actions)
							lbl:SetContentAlignment(4)
							lbl:Dock(LEFT)
							lbl:DockMargin(0, 0, m2, 0)

							local goto = self:QuickButton(L"goto", function()
								if (IsValid(player.GetBySteamID64(report.reported_id))) then
									local m = self:Menu()
									m:AddOption("bring_reported_player"):SetMouseInputEnabled(false)
									m:AddOption("yes", function()
										easynet.SendToServer("SH_REPORTS.ClaimAndTeleport", {id = report.id, bring = false, bring_reported = true /* 76561198347218024 */})
									end)
									m:AddOption("no", function()
										easynet.SendToServer("SH_REPORTS.ClaimAndTeleport", {id = report.id, bring = false, bring_reported = false})
									end)
									m:Open()
								else
									easynet.SendToServer("SH_REPORTS.ClaimAndTeleport", {id = report.id, bring = false, bring_reported = false})
								end
							end, actions)
							goto:Dock(LEFT)

							local bring = self:QuickButton(L"bring", function()
								if (IsValid(player.GetBySteamID64(report.reported_id))) then
									local m = self:Menu()
									m:AddOption("bring_reported_player"):SetMouseInputEnabled(false)
									m:AddOption("yes", function()
										easynet.SendToServer("SH_REPORTS.ClaimAndTeleport", {id = report.id, bring = true, bring_reported = true})
									end)
									m:AddOption("no", function()
										easynet.SendToServer("SH_REPORTS.ClaimAndTeleport", {id = report.id, bring = true, bring_reported = false})
									end)
									m:Open()
								else
									easynet.SendToServer("SH_REPORTS.ClaimAndTeleport", {id = report.id, bring = true, bring_reported = false})
								end
							end, actions)
							bring:Dock(LEFT)
							bring:DockMargin(m2, 0, 0, 0)
						end

						if (sitsys) then
							local session = self:QuickButton(L"start_sit_session", function()
								easynet.SendToServer("SH_REPORTS.ClaimAndCSit", {id = report.id})
							end, actions)
							session:Dock(LEFT)
							session:DockMargin(m2, 0, 0, 0)
						end
					else
						local lbl = self:QuickLabel(L("claimed_by_x", ""), "{prefix}Medium", styl.text, actions)
						lbl:SetContentAlignment(4)
						lbl:Dock(LEFT)
						lbl:DockMargin(0, 0, m2, 0)

						self:GetName(report.admin_id, function(nick)
							if (IsValid(lbl)) then
								lbl:SetText(L("claimed_by_x", nick))
								lbl:SizeToContents()
							end
						end)
					end
				end

				if (report.reporter_id == LocalPlayer():SteamID64()) or (report.admin_id == "" and self.CanDeleteWhenUnclaimed) or (report.admin_id == LocalPlayer():SteamID64() /* 76561198347218033 */) then
					local close = self:QuickButton(L"close_report", function()
						easynet.SendToServer("SH_REPORTS.CloseReport", {id = report.id})
						frame:Close()
					end, actions, nil, self.Style.close_hover)
					close:Dock(RIGHT)
				end

	frame:SetAlpha(0)
	frame:AlphaTo(255, 0.1)
end

local matStats = Material("shenesis/reports/stats.png")
local matAdd = Material("shenesis/reports/add.png")

function SH_REPORTS:ShowReports()
	if (IsValid(_SH_REPORTS)) then
		_SH_REPORTS:Remove()
	end
	if (IsValid(_SH_REPORTS_VIEW)) then
		_SH_REPORTS_VIEW:Remove()
	end

	local styl = self.Style
	local th, m = self:GetPadding(), self:GetMargin()
	local ss = self:GetScreenScale()

	local delay = 0
	if (self.ServerTime) then
		delay = self.ServerTime - os.time()
	end

	local frame = self:MakeWindow(self:IsAdmin(LocalPlayer()) and L"report_list" or L"your_reports")
	frame:SetSize(900 * ss, 600 * ss)
	frame:Center()
	frame:MakePopup()
	_SH_REPORTS = frame

		if (self.UsergroupsPerformance[LocalPlayer():GetUserGroup()]) then
			local btn = frame:AddHeaderButton(matStats, function()
				easynet.SendToServer("SH_REPORTS.RequestPerfReports")
				frame:Close()
			end)
			btn:SetToolTip(L"performance_reports")
		end
		if (!self:IsAdmin(LocalPlayer()) or self.StaffCanReport) then
			local btn = frame:AddHeaderButton(matAdd, function()
				self:ShowMakeReports()
				frame:Close()
			end)
			btn:SetToolTip(L"new_report")
		end

		local ilist = vgui.Create("DListView", frame)
		ilist:SetSortable(false)
		ilist:SetDrawBackground(false)
		ilist:SetDataHeight(32)
		ilist:Dock(FILL)
		ilist:AddColumn(L"reporter")
		ilist:AddColumn(L"reported_player")
		ilist:AddColumn(L"reason")
		ilist:AddColumn(L"waiting_time")
		ilist:AddColumn(L"claimed")
		ilist:AddColumn(L"actions")
		self:PaintList(ilist)

			for _, report in SortedPairsByMemberValue (self.ActiveReports, "time", true) do
				local reporter = vgui.Create("DPanel", frame)
				reporter:SetDrawBackground(false)

					local avi = self:Avatar(report.reporter_id, 24, reporter)
					avi:SetPos(4, 4)

					local name = self:QuickLabel(report.reporter_name, "{prefix}Medium", styl.text, reporter)
					name:Dock(FILL)
					name:SetTextInset(ilist:GetDataHeight(), 0)

				local reported = vgui.Create("DPanel", frame)
				reported:SetDrawBackground(false)

					local avi = self:Avatar(report.reported_id, 24, reported)
					avi:SetPos(4, 4)

					local name = self:QuickLabel(report.reported_name, "{prefix}Medium", styl.text, reported)
					name:Dock(FILL)
					name:SetTextInset(32, 0)

					if (report.reported_id ~= "0") then
						name.Think = function(me)
							me:SetTextColor(IsValid(player.GetBySteamID64(report.reported_id)) and styl.text or styl.failure)
						end
					else
						avi:SetVisible(false)
						name:SetContentAlignment(5)
						name:SetTextInset(0, 0)
					end

				local claimed = vgui.Create("DPanel", frame)
				claimed:SetDrawBackground(false)

					local avi = self:Avatar("", 24, claimed)
					avi:SetPos(4, 4)
					claimed.avi = avi

					local name = self:QuickLabel(L"unclaimed", "{prefix}Medium", styl.text, claimed)
					name:Dock(FILL)
					name:SetTextInset(32, 0)
					claimed.name = name

					if (report.admin_id ~= "") then
						avi:SetSteamID(report.admin_id)

						self:GetName(report.admin_id, function(nick)
							if (IsValid(name)) then
								name:SetText(nick)
							end
						end)
					else
						avi:SetVisible(false)
						name:SetContentAlignment(5)
						name:SetTextInset(0, 0)
					end

				local actions = vgui.Create("DPanel", frame)
				actions:SetDrawBackground(false)
				actions:SetTall(32)
				actions:DockPadding(4, 4, 4, 4)

					local act_view = self:QuickButton(L"view", function() end, actions)
					act_view:Dock(LEFT)
					act_view:DockMargin(0, 0, 4, 0)
					act_view.DoClick = function()
						frame:Close()
						self:ShowReport(report)
					end

					local act_delete
					if (report.admin_id == "" and self.CanDeleteWhenUnclaimed) or (report.admin_id == LocalPlayer():SteamID64()) then
						act_delete = self:QuickButton(L"close_report", function() end, actions, nil, self.Style.close_hover /* 76561198347218024 */)
						act_delete:Dock(LEFT)
						act_delete.DoClick = function()
							easynet.SendToServer("SH_REPORTS.CloseReport", {id = report.id})
						end
					end

				local time = self:QuickLabel("", "{prefix}Medium", styl.text, frame)
				time:SetContentAlignment(5)
				time.Think = function(me)
					if (!me.m_fNextRefresh or RealTime() >= me.m_fNextRefresh) then
						me.m_fNextRefresh = RealTime() + 5
						me:SetText(self:FullFormatTime(os.time() + delay - report.time))
					end
				end

			local line = ilist:AddLine(reporter, reported, self.ReportReasons[report.reason_id], time, claimed, actions)
			-- line:SetSelectable(false)
			line.claimed = claimed
			line.delete = act_delete
			line.Close = function(me)
				me:AlphaTo(0, 0.2, nil, function()
					if (!ilist.Lines[me:GetID()]) then
						return end

					ilist:RemoveLine(me:GetID())
				end)
			end
			self:LineStyle(line)

			for _, rep in pairs (self.ActiveReports) do
				if (rep.id == report.id) then
					rep.line = line
				end
			end
		end

	frame:SetAlpha(0)
	frame:AlphaTo(255, 0.1)
end

function SH_REPORTS:MakeTab(report)
	if (IsValid(_SH_REPORTS_TAB)) then
		_SH_REPORTS_TAB:Close()
	end

	local styl = self.Style
	local th, m = self:GetPadding(), self:GetMargin()
	local m2 = m * 0.5

	local rep = vgui.Create("DButton")
	rep:SetText("")
	rep:SetSize(160, 32 + m)
	rep:SetPos(ScrW() * 0.5, ScrH())
	rep:MoveToFront()
	rep:DockPadding(m2, m2, m2, m2)
	rep.Paint = function(me, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, h, styl.header, true, true, false, false)
	end
	rep.DoClick = function(me)
		if (me.m_bClosing) then
			return end

		self:ShowReport(report)
	end
	rep.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:Stop()
		me:MoveTo(rep.x, ScrH(), 0.2, 0, -1, function()
			me:Remove()
		end)
	end
	rep.id = report.id
	_SH_REPORTS_TAB = rep

		local avi = self:Avatar(report.reporter_id, 32, rep)
		avi:SetMouseInputEnabled(false)
		avi:Dock(LEFT)
		avi:DockMargin(0, 0, m2, 0)

		local name = self:QuickLabel(L("report_of_x", report.reporter_name), "{prefix}Large", styl.text, rep)
		name:Dock(FILL)

	rep:SetWide(name:GetWide() + avi:GetWide() + m * 1.5)
	rep:CenterHorizontal()
	rep:MoveTo(rep.x, ScrH() - rep:GetTall(), 0.2)
end

function SH_REPORTS:MakeNotification(report)
	if (IsValid(report.notif)) then
		report.notif:Close()
	end

	local styl = self.Style
	local th, m = self:GetPadding(), self:GetMargin()
	local m2 = m * 0.5

	local rep = vgui.Create("DButton")
	rep:SetText("")
	rep:SetSize(160, 32 + m)
	rep:SetPos(ScrW() * 0.5, -rep:GetTall())
	rep:MoveToFront()
	rep:DockPadding(m2, m2, m2, m2)
	rep.Paint = function(me, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, h, styl.header, false, false, true, true)
	end
	rep.DoClick = function(me)
		if (me.m_bClosing) then
			return end

		self:ShowReport(report)
		me:Close()
	end
	rep.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:Stop()
		me:MoveTo(rep.x, -me:GetTall(), 0.2, 0, -1, function()
			me:Remove()
		end)
	end
	report.notif = rep

		local avi = self:Avatar(report.reporter_id, 32, rep)
		avi:SetMouseInputEnabled(false)
		avi:Dock(LEFT)
		avi:DockMargin(0, 0, m2, 0)

		local name = self:QuickLabel(L("report_received", report.reporter_name, report.reported_name, self.ReportReasons[report.reason_id]), "{prefix}Large", /* 76561198347218033 */ styl.text, rep)
		name:Dock(FILL)

	rep:SetWide(name:GetWide() + avi:GetWide() + m * 1.5)
	rep:CenterHorizontal()
	rep:MoveTo(rep.x, 0, 0.2, nil, nil, function()
		rep:MoveTo(rep.x, -rep:GetTall(), 0.2, 7.5, nil, function()
			rep:Remove()
		end)
	end)
end

SH_REPORTS.PendingPanels = SH_REPORTS.PendingPanels or {}

function SH_REPORTS:ClosePendingPanel(id)
	local cleaned = {}
	
	-- Clean closed reports
	for k, v in pairs (self.PendingPanels) do
		if (!IsValid(v)) then
			continue end

		local found = false
		for _, rep in pairs (SH_REPORTS.ActiveReports) do
			if (rep.id == v.m_iReportID) then
				found = true
			end
		end

		if (!found) or (v.m_iReportID == id) then
			v:Close()
			continue
		end

		table.insert(cleaned, v)
	end

	self.PendingPanels = cleaned
end

function SH_REPORTS:MakePending(report)
	if (IsValid(report.pending)) then
		report.pending:Remove()
	end

	local num = 0
	for _, w in pairs (self.PendingPanels) do
		if (IsValid(w) and !w.m_bClosing) then
			num = num + 1
		end
	end

	if (num >= self.PendingReportsDispNumber) then
		return end

	local styl = self.Style
	local th, m = self:GetPadding(), self:GetMargin()
	local hh = th * 0.66
	local m2, m3 = m * 0.5, m * 0.66
	local ss = self:GetScreenScale()

	local wnd = vgui.Create("DPanel")
	wnd:SetSize(300 * ss, 112 * ss)
	wnd:DockPadding(m3, hh + m3, m3, m3)
	wnd.Paint = function(me, w, h)
		if not hh or not m2 then return end 
		draw.RoundedBoxEx(4, 0, 0, w, hh, styl.header, true, true, false, false)
		draw.RoundedBoxEx(4, 0, hh, w, h - hh, styl.inbg, false, false, true, true)
		draw.SimpleText("[" .. L"unclaimed" .. "] " .. L("report_of_x", report.reporter_name), "SH_REPORTS.MediumB", m2, hh * 0.5, styl.text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
	wnd.m_iReportID = report.id
	report.pending = wnd

		local lbl = self:QuickLabel(L"reported_player" .. ":", "{prefix}Medium", styl.text, wnd)
		lbl:Dock(TOP)

			local reported = self:QuickLabel(report.reported_name, "{prefix}Medium", styl.text, lbl)
			reported:Dock(RIGHT)

		local lbl = self:QuickLabel(L"reason" .. ":", "{prefix}Medium", styl.text, wnd)
		lbl:Dock(TOP)
		lbl:DockMargin(0, m3, 0, 0)

			local reason = self:QuickLabel(self.ReportReasons[report.reason_id], "{prefix}Medium", styl.text, lbl)
			reason:Dock(RIGHT)

		local buttons = vgui.Create("DPanel", wnd)
		buttons:SetDrawBackground(false)
		buttons:SetTall(20 * ss)
		buttons:Dock(BOTTOM)

			local close = self:QuickButton("✕", function()
				wnd:Close()
				report.ignored = true
			end, buttons)
			close:SetWide(buttons:GetTall())
			close:Dock(LEFT)
			close.m_Background = styl.close_hover

			local view = self:QuickButton(L"view", function()
				self:ShowReport(report)
			end, buttons)
			view:Dock(RIGHT)
			view.m_Background = styl.header

	local i = table.insert(self.PendingPanels, wnd)
	wnd:SetPos(m, m + (i - 1) * wnd:GetTall() + (i - 1) * m)
	wnd:SetAlpha(0)
	wnd:AlphaTo(255, 0.1)

	wnd.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:AlphaTo(0, 0.1, 0, function()
			local ma = #self.PendingPanels
			table.RemoveByValue(self.PendingPanels, me)
			me:Remove()

			local o = 0
			for j = i - 1, ma do
				local w = self.PendingPanels[j]
				if (IsValid(w) and w ~= me) then
					w:Stop()
					w:MoveTo(w.x, m + o * wnd:GetTall() + o * m, 0.2)
					o = o + 1
				end
			end

			-- Display any hidden panels
			for _, r in pairs (self.ActiveReports) do
				if (!IsValid(r.pending) and !r.ignored and r.admin_id == "") then
					self:MakePending(r)
				end
			end
		end)
	end
end
--addons/sh_reports/lua/reports/cl_menu_performance.lua:
return gluapack()()
--addons/safezone-sh/lua/safezones/cl_main.lua:
return gluapack()()
--addons/bodygroupr/lua/autorun/bodyman_init.lua:
return gluapack()()
--addons/bodygroupr/lua/bodyman/bodyman_config.lua:
return gluapack()()
--addons/ch_atm/lua/autorun/ch_atm_initialize.lua:
return gluapack()()
--addons/ch_atm/lua/ch_atm/shared/currencies/basewars.lua:
return gluapack()()
--addons/ch_atm/lua/ch_atm/shared/currencies/helix.lua:
CH_ATM.Currencies[ "helix" ] = {
	Name = "Helix Money",
	
	AddMoney = function( ply, amount )
		ply:GetCharacter():GiveMoney( amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:GetCharacter():TakeMoney( amount )
	end,
	
	GetMoney = function( ply )
		return ply:GetCharacter():GetMoney()
	end,
	
	CanAfford = function( ply, amount )
		return ply:GetCharacter():HasMoney( amount )
	end,
	
	FormatMoney = function( amount )
		return ix.currency.Get( amount or 0 )
	end,
	
	CurrencyAbbreviation = function()
		return "USD"
	end,
}
--addons/ch_atm/lua/ch_atm/shared/currencies/underdone.lua:
return gluapack()()
--addons/ch_atm/lua/ch_atm/shared/currencies/underdone.lua:
CH_ATM.Currencies[ "underdone" ] = {
	Name = "Underdone Money",
	
	AddMoney = function( ply, amount )
		ply:AddItem( "money", amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:RemoveItem( "money", -amount )
	end,
	
	GetMoney = function( ply )
		return ply.Data.Inventory["money"] or 0
	end,
	
	CanAfford = function( ply, amount )
		local cur_money = ply.Data.Inventory["money"] or 0
		
		return cur_money >= amount
	end,
	
	FormatMoney = function( amount )
		return "$" .. string.Comma( amount )
	end,
	
	CurrencyAbbreviation = function()
		return "USD"
	end,
}
--addons/ch_atm/lua/ch_atm/client/ch_atm_fonts.lua:
surface.CreateFont( "CH_ATM_Font_CardScanner_Size25", {
    font = "Montserrat", 
    size = 25,
    weight = 100
} )

surface.CreateFont( "CH_ATM_Font_CardScanner_Size20", {
    font = "Montserrat", 
    size = 20,
    weight = 100
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size20", {
    font = "Roboto Condensed", 
    size = 20,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size25", {
    font = "Roboto Condensed", 
    size = 25,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size30", {
    font = "Roboto Condensed", 
    size = 30,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size35", {
    font = "Roboto Condensed", 
    size = 35,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size40", {
    font = "Roboto Condensed", 
    size = 40,
    weight = 600
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size45", {
    font = "Roboto Condensed", 
    size = 45,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size50", {
    font = "Roboto Condensed", 
    size = 50,
    weight = 700
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size55", {
    font = "Roboto Condensed", 
    size = 55,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size60", {
    font = "Roboto Condensed", 
    size = 60,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size70", {
    font = "Roboto Condensed", 
    size = 70,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size80", { -- might not be in use atm
    font = "Roboto Condensed", 
    size = 80,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_ATMScreen_Size100", {
    font = "Roboto Condensed", 
    size = 100,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_Leaderboard_Header", {
    font = "Roboto Condensed", 
    size = 40,
    weight = 500
} )

surface.CreateFont( "CH_ATM_Font_Leaderboard_Title", {
    font = "Roboto Condensed", 
    size = 35,
    weight = 500
} )
--addons/ch_atm/lua/ch_atm/client/ch_atm_hacking.lua:
return gluapack()()
--addons/darkrpbankrobbery2/lua/ch_bank_robbery/shared/bank_utils.lua:
--[[
	Get amount of active government officials
--]]
function CH_BankVault.GetTotalGovernmentOfficials()
	local count = 0
	
	for k, ply in ipairs( player.GetAll() ) do
		if ply:CH_BankVault_IsPoliceOfficer() then
			count = count + 1
		end
	end
	
	return count
end
--addons/ch_bitminers/lua/ch_bitminers/client/bitminers_fonts.lua:
-- Bitminer Fonts
surface.CreateFont( "BITMINER_ScreenText20b", {
    font = "Roboto Condensed", 
    size = 60,
    weight = 800
} )

surface.CreateFont( "BITMINER_ScreenText23b", {
    font = "Roboto Condensed", 
    size = 85,
    weight = 800
} )

surface.CreateFont( "BITMINER_ScreenText25b", {
    font = "Roboto Condensed", 
    size = 100,
    weight = 800
} )

surface.CreateFont( "BITMINER_ScreenText30b", {
    font = "Roboto Condensed", 
    size = 135,
    weight = 800
} )

-- Bitcoin Rate Screen
surface.CreateFont( "BITMINER_RateScreenText", {
    font = "Roboto Condensed", 
    size = 115,
    weight = 600
} )
--addons/ch_bitminers/lua/ch_bitminers/client/bitminers_ui_crypto_integration.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/shared/config/upgrades/upgrade_kevlar.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_fonts.lua:
--[[
	Create scaled fonts
--]]
local CH_Mayor_FontSizes = { "7", "8", "9", "10", "12", "14", "18" }

local function CH_Mayor_CreateFonts()
	for k, font in ipairs( CH_Mayor_FontSizes ) do
		local font_path = "Open Sans"
		local boldness = 500
		
		-- Mayor Fonts
		surface.CreateFont( "CH_Mayor_Font_Size".. font, {
			font = font_path, 
			size = ScreenScale( font ), 
			extended = true,
			weight = boldness
		} )
	end
end

CH_Mayor_CreateFonts()

--[[
	Update when screen sizes changes
--]]
local function CH_Mayor_OnScreenSizeChanged()
	CH_Mayor.ScrW = ScrW()
	CH_Mayor.ScrH = ScrH()
	
	-- Recreate fonts
    CH_Mayor_CreateFonts()
end
hook.Add( "OnScreenSizeChanged", "CH_Mayor_OnScreenSizeChanged", CH_Mayor_OnScreenSizeChanged )

--[[
	Create non-scaled fonts
--]]
surface.CreateFont( "CH_Mayor_Font_3D2D_300", {
	font = "Open Sans", 
    size = 300,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_175", {
	font = "Open Sans", 
    size = 175,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_30", {
	font = "Open Sans", 
    size = 30,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_40", {
	font = "Open Sans", 
    size = 40,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_45", {
	font = "Open Sans", 
    size = 45,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_50", {
	font = "Open Sans", 
    size = 50,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_60", {
	font = "Open Sans", 
    size = 60,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_70", {
	font = "Open Sans", 
    size = 70,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_80", {
	font = "Open Sans", 
    size = 80,
    weight = 500
} )

surface.CreateFont( "CH_Mayor_Font_3D2D_110", {
	font = "Open Sans", 
    size = 110,
    weight = 500
} )
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_imgui.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_imgui.lua:
--[[
IMGUI by Wyozi - https://github.com/wyozi-gmod/imgui

MIT License

Copyright (c) 2019 wyozi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

local imgui = {}

imgui.skin = {
	background = Color(0, 0, 0, 0),
	backgroundHover = Color(0, 0, 0, 0),

	border = Color(255, 255, 255),
	borderHover = Color(255, 127, 0),
	borderPress = Color(255, 80, 0),

	foreground = Color(255, 255, 255),
	foregroundHover = Color(255, 127, 0),
	foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")
function imgui.IsDeveloperMode()
	return not imgui.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function imgui.Hook(name, id, callback)
	local hookUniqifier = debug.getinfo(4).short_src
	hook.Add(name, "IMGUI / " .. id .. " / " .. hookUniqifier, callback)
end

local localPlayer
local gState = {}

local function shouldAcceptInput()
	-- don't process input during non-main renderpass
	if render.GetRenderTarget() ~= nil then
		return false
	end

	-- don't process input if we're doing VGUI stuff (and not in context menu)
	if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then
		return false
	end
	
	if localPlayer and localPlayer.ATM_LastUsed and localPlayer.ATM_LastUsed > CurTime() then
		return false
	end
	
	return true
end

local function apply_screen_cooldown()
	if localPlayer then
		localPlayer.ATM_LastUsed = CurTime() + 0.2
		return
	end
end

imgui.Hook("PreRender", "Input", function()
	-- calculate mouse state
	if shouldAcceptInput() then
		local useBind = input.LookupBinding("+use", true)
		local USE = useBind and input.GetKeyCode(useBind)

		local wasPressing = gState.pressing
		gState.pressing = (USE and input.IsButtonDown(USE))
		gState.pressed = not wasPressing and gState.pressing
		
		if wasPressing then
			apply_screen_cooldown()
		end
	end
end)

hook.Add("NotifyShouldTransmit", "IMGUI / ClearRenderBounds", function(ent, shouldTransmit)
	if shouldTransmit and ent._imguiRBExpansion then
		ent._imguiRBExpansion = nil
	end
end)

local traceResultTable = {}
local traceQueryTable = { output = traceResultTable, filter = {} }
local function isObstructed(eyePos, hitPos, ignoredEntity)
	local q = traceQueryTable
	q.start = eyePos
	q.endpos = hitPos
	q.filter[1] = localPlayer
	q.filter[2] = ignoredEntity

	local tr = util.TraceLine(q)
	if tr.Hit then
		return true, tr.Entity
	else
		return false
	end
end

function imgui.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
	if not IsValid(localPlayer) then
		localPlayer = LocalPlayer()
	end

	if gState.shutdown == true then
		return
	end

	if gState.rendering == true then
		print(
			"[IMGUI] Starting a new IMGUI context when previous one is still rendering" ..
			"Shutting down rendering pipeline to prevent crashes.."
		)
		gState.shutdown = true
		return false
	end

	_devMode = imgui.IsDeveloperMode()

	local eyePos = localPlayer:EyePos()
	local eyePosToPos = pos - eyePos

	-- OPTIMIZATION: Test that we are in front of the UI
	do
		local normal = angles:Up()
		local dot = eyePosToPos:Dot(normal)

		if _devMode then gState._devDot = dot end

		-- since normal is pointing away from surface towards viewer, dot<0 is visible
		if dot >= 0 then
			return false
		end
	end

	-- OPTIMIZATION: Distance based fade/hide
	if distanceHide then
		local distance = eyePosToPos:Length()
		if distance > distanceHide then
			return false
		end

		if _devMode then
			gState._devDist = distance
			gState._devHideDist = distanceHide
		end

		if distanceHide and distanceFadeStart and distance > distanceFadeStart then
			local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
			render.SetBlend(blend)
			surface.SetAlphaMultiplier(blend)
		end
	end

	gState.rendering = true
	gState.pos = pos
	gState.angles = angles
	gState.scale = scale

	cam.Start3D2D(pos, angles, scale)

	-- calculate mousepos
	if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
		local tr = localPlayer:GetEyeTrace()
		local eyepos = tr.StartPos
		local eyenormal

		if vgui.CursorVisible() and vgui.IsHoveringWorld() then
			eyenormal = gui.ScreenToVector(gui.MousePos())
		else
			eyenormal = tr.Normal
		end

		local planeNormal = angles:Up()

		local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)
		if hitPos then
			local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)
			if obstructed then
				gState.mx = nil
				gState.my = nil

				if _devMode then gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex() end
			else
				local diff = pos - hitPos

				-- This cool code is from Willox's keypad CalculateCursorPos
				local x = diff:Dot(-angles:Forward()) / scale
				local y = diff:Dot(-angles:Right()) / scale

				gState.mx = x
				gState.my = y
			end
		else
			gState.mx = nil
			gState.my = nil

			if _devMode then gState._devInputBlocker = "not looking at plane" end
		end
	else
		gState.mx = nil
		gState.my = nil

		if _devMode then gState._devInputBlocker = "not hovering world" end
	end

	if _devMode then gState._renderStarted = SysTime() end

	return true
end

function imgui.Entity3D2D(ent, lpos, lang, scale, ...)
	gState.entity = ent
	local ret = imgui.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)
	if not ret then
		gState.entity = nil
	end
	return ret
end

local function calculateRenderBounds(x, y, w, h)
	local pos = gState.pos
	local fwd, right = gState.angles:Forward(), gState.angles:Right()
	local scale = gState.scale
	local firstCorner, secondCorner =
		pos + fwd * x * scale + right * y * scale,
		pos + fwd * (x + w) * scale + right * (y + h) * scale

	local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)

	minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
	minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
	minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
	maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
	maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
	maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

	return minrb, maxrb
end

function imgui.ExpandRenderBoundsFromRect(x, y, w, h)
	local ent = gState.entity
	if IsValid(ent) then
		-- make sure we're not applying same expansion twice
		local expansion = ent._imguiRBExpansion
		if expansion then
			local ex, ey, ew, eh = unpack(expansion)
			if ex == x and ey == y and ew == w and eh == h then
				return
			end
		end

		local minrb, maxrb = calculateRenderBounds(x, y, w, h)

		ent:SetRenderBoundsWS(minrb, maxrb)
		if _devMode then
			print("[IMGUI] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
		end

		ent._imguiRBExpansion = {x, y, w, h}
	else
		if _devMode then
			print("[IMGUI] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
		end
	end
end

local devOffset = Vector(0, 0, 30)
local devColours = {
	background = Color(0, 0, 0, 200),
	title = Color(78, 205, 196),
	mouseHovered = Color(0, 255, 0),
	mouseUnhovered = Color(255, 0, 0),
	pos = Color(255, 255, 255),
	distance = Color(200, 200, 200, 200),
	ang = Color(255, 255, 255),
	dot = Color(200, 200, 200, 200),
	angleToEye = Color(200, 200, 200, 200),
	renderTime = Color(255, 255, 255),
	renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
	draw.SimpleText(
		str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil
	)
end

local function drawDeveloperInfo()
	local camAng = localPlayer:EyeAngles()
	camAng:RotateAroundAxis(camAng:Right(), 90)
	camAng:RotateAroundAxis(camAng:Up(), -90)

	cam.IgnoreZ(true)
	cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)

	local bgCol = devColours["background"]
	surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
	surface.DrawRect(-100, 0, 200, 140)

	local titleCol = devColours["title"]
	developerText("imgui developer", 0, 5, titleCol)

	surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
	surface.DrawLine(-50, 16, 50, 16)

	local mx, my = gState.mx, gState.my
	if mx and my then
		developerText(
			string.format("mouse: hovering %d x %d", mx, my),
			0, 20, devColours["mouseHovered"]
		)
	else
		developerText(
			string.format("mouse: %s", gState._devInputBlocker or ""),
			0, 20, devColours["mouseUnhovered"]
		)
	end

	local pos = gState.pos
	developerText(
		string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z),
		0, 40, devColours["pos"]
	)

	developerText(
		string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0),
		0, 53, devColours["distance"]
	)

	local ang = gState.angles
	developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
	developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])

	local angToEye = (pos - localPlayer:EyePos()):Angle()
	angToEye:RotateAroundAxis(ang:Up(), -90)
	angToEye:RotateAroundAxis(ang:Right(), 90)

	developerText(
		string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r),
		0, 100, devColours["angleToEye"]
	)

	developerText(
		string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000),
		0, 120, devColours["renderTime"]
	)

	cam.End3D2D()
	cam.IgnoreZ(false)

	local ent = gState.entity
	if IsValid(ent) and ent._imguiRBExpansion then
		local ex, ey, ew, eh = unpack(ent._imguiRBExpansion)
		local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
		render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
	end
end

function imgui.End3D2D()
	if gState then
		if _devMode then
			local renderTook = SysTime() - gState._renderStarted
			gState._devBenchTests = (gState._devBenchTests or 0) + 1
			gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook
			if gState._devBenchTests == 100 then
				gState._devBenchAveraged = gState._devBenchTaken / 100
				gState._devBenchTests = 0
				gState._devBenchTaken = 0
			end
		end

		gState.rendering = false
		cam.End3D2D()
		render.SetBlend(1)
		surface.SetAlphaMultiplier(1)

		if _devMode then
			drawDeveloperInfo()
		end

		gState.entity = nil
	end
end

function imgui.CursorPos()
	local mx, my = gState.mx, gState.my
	return mx, my
end

function imgui.IsHovering(x, y, w, h)
	local mx, my = gState.mx, gState.my
	return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end
function imgui.IsPressing()
	return shouldAcceptInput() and gState.pressing
end
function imgui.IsPressed()
	return shouldAcceptInput() and gState.pressed
end

-- String->Bool mappings for whether font has been created
local _createdFonts = {}

-- Cached IMGUIFontNamd->GModFontName
local _imguiFontToGmodFont = {}

local EXCLAMATION_BYTE = string.byte("!")
function imgui.xFont(font, defaultSize)
	-- special font
	if string.byte(font, 1) == EXCLAMATION_BYTE then

		local existingGFont = _imguiFontToGmodFont[font]
		if existingGFont then
			return existingGFont
		end

		-- Font not cached; parse the font
		local name, size = font:match("!([^@]+)@(.+)")
		if size then size = tonumber(size) end

		if not size and defaultSize then
			name = font:match("^!([^@]+)$")
			size = defaultSize
		end

		local fontName = string.format("IMGUI_%s_%d", name, size)
		_imguiFontToGmodFont[font] = fontName
		if not _createdFonts[fontName] then
			surface.CreateFont(fontName, {
				font = name,
				size = size
			})
			_createdFonts[fontName] = true
		end

		return fontName
	end
	return font
end

function imgui.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
	local bw = borderWidth or 1

	local bgColor = imgui.IsHovering(x, y, w, h) and imgui.skin.backgroundHover or imgui.skin.background
	local borderColor =
		((imgui.IsPressing() and imgui.IsHovering(x, y, w, h)) and (pressColor or imgui.skin.borderPress))
		or (imgui.IsHovering(x, y, w, h) and (hoverClr or imgui.skin.borderHover))
		or (borderClr or imgui.skin.border)

	surface.SetDrawColor(bgColor)
	surface.DrawRect(x, y, w, h)

	if bw > 0 then
		surface.SetDrawColor(borderColor)

		surface.DrawRect(x, y, w, bw)
		surface.DrawRect(x, y + bw, bw, h - bw * 2)
		surface.DrawRect(x, y + h-bw, w, bw)
		surface.DrawRect(x + w - bw + 1, y, bw, h)
	end

	return shouldAcceptInput() and imgui.IsHovering(x, y, w, h) and gState.pressed
end

function imgui.xCursor(x, y, w, h)
	local fgColor = imgui.IsPressing() and imgui.skin.foregroundPress or imgui.skin.foreground
	local mx, my = gState.mx, gState.my

	if not mx or not my then return end

	if x and w and (mx < x or mx > x + w) then return end
	if y and h and (my < y or my > y + h) then return end
	
	local cursorSize = math.ceil( 0.3 / gState.scale )
	
	surface.SetDrawColor( color_white )
	surface.SetMaterial( CH_Mayor.Materials.Cursor )
	surface.DrawTexturedRect( mx - cursorSize + 8, my, 24, 24 )
end

function imgui.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
	local fgColor =
		((imgui.IsPressing() and imgui.IsHovering(x, y, w, h)) and (pressColor or imgui.skin.foregroundPress))
		or (imgui.IsHovering(x, y, w, h) and (hoverClr or imgui.skin.foregroundHover))
		or (color or imgui.skin.foreground)

	local clicked = imgui.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)

	font = imgui.xFont(font, math.floor(h * 0.618))
	draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	return clicked
end

return imgui
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_money.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_money.lua:
CH_Mayor.VaultMoney = CH_Mayor.VaultMoney or 0
CH_Mayor.MaxVaultMoney = CH_Mayor.Config.VaultDefaultMax

net.Receive( "CH_Mayor_Net_MayorVault", function( length, ply )
	local amount = net.ReadUInt( 32 )
	local max = net.ReadUInt( 32 )
	
	CH_Mayor.VaultMoney = amount
	CH_Mayor.MaxVaultMoney = max
end )
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu_licenses.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu_taxes.lua:
CH_Mayor.TeamTaxes = CH_Mayor.TeamTaxes or {}

net.Receive( "CH_Mayor_Net_NetworkTeamTaxes", function( len, ply )
	local amount_of_entries = net.ReadUInt( 6 )
	
	for i = 1, amount_of_entries do
		local team = net.ReadString()
		local salary = net.ReadUInt( 32 )
		local tax = net.ReadUInt( 32 )
		local model = net.ReadString()
		local name = net.ReadString()
		
		CH_Mayor.TeamTaxes[ team ] = {
			team_salary = salary,
			team_tax = tax,
			team_model = model,
			team_name = name,
		}
	end
end )

--[[
	MAYOR TAXES MENU
--]]
function CH_Mayor.TaxesMenu()
	local ply = LocalPlayer()

	local GUI_TaxesFrame = vgui.Create( "DFrame" )
	GUI_TaxesFrame:SetTitle( "" )
	GUI_TaxesFrame:SetSize( CH_Mayor.ScrW * 0.6, CH_Mayor.ScrH * 0.665 )
	GUI_TaxesFrame:Center()
	GUI_TaxesFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.059 )
		
		-- Draw the top title.
		draw.SimpleText( CH_Mayor.LangString( "City Management" ), "CH_Mayor_Font_Size10", w / 2, h * 0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	GUI_TaxesFrame:MakePopup()
	GUI_TaxesFrame:SetDraggable( false )
	GUI_TaxesFrame:ShowCloseButton( false )
	
	local GUI_CloseMenu = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_CloseMenu:SetPos( CH_Mayor.ScrW * 0.582, CH_Mayor.ScrH * 0.01 )
	GUI_CloseMenu:SetSize( CH_Mayor.ScrW * 0.0125, CH_Mayor.ScrH * 0.02223 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.Red or color_white )
		surface.SetMaterial( CH_Mayor.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, CH_Mayor.ScrW * 0.0125, CH_Mayor.ScrH * 0.02223 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_TaxesFrame:Remove()
	end
	
	local GUI_DashboardFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_DashboardFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_DashboardFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.0475 )
	GUI_DashboardFrameBtn:SetText( "" )
	GUI_DashboardFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Dashboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Dashboard" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_DashboardFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.DashboardMenu()
	end

	local GUI_UpgradesFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_UpgradesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_UpgradesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.095 )
	GUI_UpgradesFrameBtn:SetText( "" )
	GUI_UpgradesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Upgrades )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Upgrades" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_UpgradesFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.UpgradesMenu()
	end
	
	local GUI_TaxesFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_TaxesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_TaxesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.1425 )
	GUI_TaxesFrameBtn:SetText( "" )
	GUI_TaxesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( CH_Mayor.Colors.GMSBlue )
		surface.DrawRect( 0, 0, 2, h )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Taxes )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Taxes" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TaxesFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.TaxesMenu()
	end

	local GUI_CatalogFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_CatalogFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_CatalogFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.19 )
	GUI_CatalogFrameBtn:SetText( "" )
	GUI_CatalogFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Catalog )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Catalog" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CatalogFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.CatalogMenu()
	end
	
	local GUI_LawsFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_LawsFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_LawsFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.2375 )
	GUI_LawsFrameBtn:SetText( "" )
	GUI_LawsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Laws )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Laws" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LawsFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.LawsMenu()
	end
	
	local GUI_TaxesFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_TaxesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_TaxesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.285 )
	GUI_TaxesFrameBtn:SetText( "" )
	GUI_TaxesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Licenses )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Licenses" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TaxesFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.LicensesMenu( )
	end
	
	local GUI_OfficialsManagementFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_OfficialsManagementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_OfficialsManagementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.3325 )
	GUI_OfficialsManagementFrameBtn:SetText( "" )
	GUI_OfficialsManagementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_OfficialsManagement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Officials" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_OfficialsManagementFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.OfficialsMenu()
	end
	
	local GUI_CiviliansManagementFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_CiviliansManagementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_CiviliansManagementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.38 )
	GUI_CiviliansManagementFrameBtn:SetText( "" )
	GUI_CiviliansManagementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_CivilianManagement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Civilians" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CiviliansManagementFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.CiviliansMenu()
	end
	
	local GUI_TaxesFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_TaxesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_TaxesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.4275 )
	GUI_TaxesFrameBtn:SetText( "" )
	GUI_TaxesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Wanted )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Wanted" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TaxesFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.WantedMenu()
	end
	
	local GUI_WarrantFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_WarrantFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_WarrantFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.475 )
	GUI_WarrantFrameBtn:SetText( "" )
	GUI_WarrantFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Warrant )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Warrant" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_WarrantFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.WarrantMenu()
	end
	
	local GUI_AnnouncementFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_AnnouncementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_AnnouncementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.5225 )
	GUI_AnnouncementFrameBtn:SetText( "" )
	GUI_AnnouncementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Announcement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Announcement" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_AnnouncementFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.AnnouncementMenu()
	end
	
	local GUI_LockdownFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_LockdownFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_LockdownFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.57 )
	GUI_LockdownFrameBtn:SetText( "" )
	GUI_LockdownFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Lockdown )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Lockdown" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LockdownFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.LockdownMenu()
	end
	
	local GUI_StatsFrameBtn = vgui.Create( "DButton", GUI_TaxesFrame )
	GUI_StatsFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_StatsFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.6175 )
	GUI_StatsFrameBtn:SetText( "" )
	GUI_StatsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Economy )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Statistics" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_StatsFrameBtn.DoClick = function()
		GUI_TaxesFrame:Remove()
		
		CH_Mayor.StatisticsMenu()
	end
	
	-- The list of taxed teams
	local GUI_PlayerList = vgui.Create( "DPanelList", GUI_TaxesFrame )
	GUI_PlayerList:SetSize( CH_Mayor.ScrW * 0.491, CH_Mayor.ScrH * 0.61 )
	GUI_PlayerList:SetPos( CH_Mayor.ScrW * 0.109, CH_Mayor.ScrH * 0.0475 )
	GUI_PlayerList:EnableVerticalScrollbar( true )
	GUI_PlayerList:EnableHorizontal( true )
	GUI_PlayerList:SetSpacing( 8.4 )
	GUI_PlayerList.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_transparent )
	end
	if ( GUI_PlayerList.VBar ) then
		GUI_PlayerList.VBar.Paint = function( self, w, h ) -- BG
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnUp.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnGrip.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GMSBlue )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnDown.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
	end
	
	for k, v in pairs( CH_Mayor.TeamTaxes ) do
		local GUI_PlayerPanel = vgui.Create( "DPanelList" )
		GUI_PlayerPanel:SetSize( CH_Mayor.ScrW * 0.2415, CH_Mayor.ScrH * 0.0879 )
		GUI_PlayerPanel.Paint = function( self, w, h )
			-- Background
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, w, h )
			
			-- Name
			draw.SimpleText( k, "CH_Mayor_Font_Size10", w * 0.2, h * 0.35, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			
			-- Salary
			draw.SimpleText( CH_Mayor.LangString( "Salary" ) ..": ".. DarkRP.formatMoney( v.team_salary ), "CH_Mayor_Font_Size9", w * 0.2, h * 0.65, CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			
			-- Draw tax percentage
			draw.SimpleText( "%", "CH_Mayor_Font_Size18", w * 0.91, h * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			
			surface.SetDrawColor( CH_Mayor.Colors.WhiteAlpha2 )
			surface.DrawRect( w * 0.75, h * 0.775, w * 0.15, h * 0.03 )
		end

		local GUI_TeamModelSpawnI = vgui.Create( "SpawnIcon", GUI_PlayerPanel )
		GUI_TeamModelSpawnI:SetSize( CH_Mayor.ScrW * 0.0425, CH_Mayor.ScrH * 0.07 )
		GUI_TeamModelSpawnI:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.0115 )
		GUI_TeamModelSpawnI:SetModel( v.team_model )
		GUI_TeamModelSpawnI:SetVisible( true )
		GUI_TeamModelSpawnI.PaintOver = function( self )
			EndTooltip( self )
		end
		GUI_TeamModelSpawnI.OnMousePressed = function()
			return
		end
	
		local GUI_TeamTaxField = vgui.Create( "DTextEntry", GUI_PlayerPanel )
		GUI_TeamTaxField:RequestFocus()
		GUI_TeamTaxField:SetPos( CH_Mayor.ScrW * 0.18, CH_Mayor.ScrH * 0.024 )
		GUI_TeamTaxField:SetSize( CH_Mayor.ScrW * 0.04, CH_Mayor.ScrH * 0.04 )
		GUI_TeamTaxField:SetFont( "CH_Mayor_Font_Size18" )
		GUI_TeamTaxField:SetTextColor( color_white )
		GUI_TeamTaxField:SetValue( v.team_tax )
		GUI_TeamTaxField:SetAllowNonAsciiCharacters( CH_Mayor.Config.UsingSetAllowNonAsciiCharacters ) -- When allowing non-ASCII characters, a small box appears inside the text entry, indicating your keyboard's current language.  That makes the user unable to input some letters from German, French, Swedish, etc. alphabet. 
		GUI_TeamTaxField:SetMultiline( false )
		GUI_TeamTaxField:SetNumeric( true )
		GUI_TeamTaxField:SetDrawBackground( false )
		GUI_TeamTaxField.OnEnter = function( self )
			local tax = tonumber( self:GetValue() )
			
			if not isnumber( tax ) then
				ply:ChatPrint( "You must insert a number to update the taxes." )
				return
			end
			
			if tax <= 0 then
				ply:ChatPrint( "The tax must be a positive number." )
				return
			end
			
			-- Update the taxes for this team
			net.Start( "CH_Mayor_Net_UpdateTeamTax" )
				net.WriteString( k )
				net.WriteUInt( tax, 7 )
			net.SendToServer()
		end
		
		GUI_PlayerList:AddItem( GUI_PlayerPanel )
	end
end
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu_wanted.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/config/ch_mining_config.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/config/ch_mining_config.lua:
CH_Mining = CH_Mining or {}
CH_Mining.Config = CH_Mining.Config or {}
CH_Mining.Currencies = CH_Mining.Currencies or {}

-- SET LANGUAGE
-- Available languages: English: en - French: fr
CH_Mining.Config.Language = "tr" -- Set the language of the script.

--[[
	GENERAL CONFIG
--]]
CH_Mining.Config.Currency = "darkrp" -- What gamemode/currency do you want to use with the addon? Supported are basewars, bricks_credit_store, darkrp, helix, mtokens, pointshop2, pointshop2_premium, santosrp, sh_pointshop, sh_pointshop_premium, underdone

CH_Mining.Config.NotificationTime = 5 -- Amount of seconds the notification display for DarkRP
CH_Mining.Config.DistanceToRockMining = 10000 -- How far away from a rock can the player mine it?

CH_Mining.Config.UseMiningTeams = true -- If the teams below should be the only teams that can mine? Set to false to allow everyone.
CH_Mining.Config.MiningTeams = { -- Teams that are considered green-lighted to mine.
	["Madenci"] = true,
}

CH_Mining.Config.WeaponSoundLevel = 50 -- Set the volume for the weapon sounds (draw, hit/swing pickaxe and jackhammer sound) - https://wiki.facepunch.com/gmod/Enums/SNDLVL

--[[
	PICKAXE CONFIG
--]]
CH_Mining.Config.PickaxeSkinLevels = {
	["Gold"] = 20, -- At level 20 the player gets the gold pickaxe
	["Diamond"] = 50, -- At level 50 the player gets the diamond pickaxe
}

CH_Mining.Config.PickaxeExtractionMultiplier = {
	["Gold"] = 1, -- With the gold pickaxe the players total mineral extraction is multiplied by 1.2
	["Diamond"] = 1.2, -- With the diamond pickaxe the players total mineral extraction is multiplied by 1.5
}

CH_Mining.Config.TakeDurabilityPerHitPickaxe = 1.75 -- How much durability do we remove from the rock per hit with the pickaxe?

--[[
	AFK PICKAXE CONFIG
--]]
CH_Mining.Config.GodModeAFKMiners = true -- Should players that are AFK mining be godmoded?
CH_Mining.Config.StopArrestingAFKMiners = true -- If true then cops cannot arrest AFK miners.

--[[
	JACKHAMMER CONFIG
--]]
CH_Mining.Config.GiveJackhammerAtLevel = 0 -- If we should give the jackhammer to people of a certain mining level? Set to 0 to disable
CH_Mining.Config.F4MenuJackhammer = false -- Should the jackhammer be purchaseable through the F4 menu?

CH_Mining.Config.GiveJackhammerRanks = true
CH_Mining.Config.JackhammerRanks = { -- List the ranks that should receive the jackhammer and set them to true
	["donator+"] = true,
	["superadmin"] = true,
	["denetmen"] = true,
	["genelyetkili"] = true,
	["user"] = false,
}

CH_Mining.Config.TakeDurabilityPerHitJackhammer = 0.25 -- How much durability do we remove from the rock per hit with the jackhammer?

CH_Mining.Config.IncreaseTemperaturePerHit = 2.5 -- How much temperature to add every time the jackhammer hits? Can be a float value as well.
CH_Mining.Config.RegainAfterOverheatingTemperature = 15 -- After having overheated, at what temperature is the jackhammer cooled off again?

CH_Mining.Config.DecreaseTemperaturePerTick = { -- How much temperature is added when cooling off? This is fast, so I recommend a small float value. Increase to make it cool of faster, decrease to cool of slower.
	[1] = 0.03, -- So at level 3 it's 0.03
	[10] = 0.135, -- When they reach level 10 it cools off faster
	[20] = 0.24, -- At level 20 it's evne faster and so on
	[30] = 0.45,
	[40] = 0.5,
	[50] = 0.7,
}

--[[
	3D2D CONFIG
--]]
CH_Mining.Config.DistanceTo3D2D = 100000 -- Distance to draw 3d2d above rocks
CH_Mining.Config.DrawDetailed3D2D = true -- If using the NPC then draw detailed 3d2d above head?
CH_Mining.Config.DrawSimplistc3D2D = false -- If using the NPC then draw a simplistic 3d2d above head?

--[[
	ROCKS CONFIG
--]]
CH_Mining.Config.MinimumMinerals = 100 -- Minimum amount of minerals a rock can have (actual amount is set when using toolgun to setup)
CH_Mining.Config.MaximumMinerals = 10000 -- Maximum amount of minerals a rock can have (actual amount is set when using toolgun to setup)

CH_Mining.Config.MinimumDurability = 100
CH_Mining.Config.MaximumDurability = 1000

CH_Mining.Config.RockDisappearSpeed = 2.95 -- How fast does rocks fade out? Increase this to make it faster, lower to make it slower. It supports float values.

CH_Mining.Config.RockRespawnTime = 300 -- After how long time should a rock respawn if it dies?

CH_Mining.Config.RestockInterval = 10 -- After how many seconds do we try to restock minerals in the rock?
CH_Mining.Config.RestockUpToPercentage = 50 -- This will restock minerals up until 50% of the total minerals that the rock can have.
CH_Mining.Config.RestockValue = 5 -- How many percentage of the total minerals do we add back per RestockInterval. Default will add 5% of the original minerals every minute once we're under 50%

--[[
	PRICES CONFIG
--]]
CH_Mining.Config.UpdatePricesTimer = 3000000 -- Adjust all prices for minerals every x seconds
CH_Mining.Config.NotifyOnUpdate = false -- Notify everyone when prices are updated

CH_Mining.Config.EnableSellBonusPerLevel = false -- Should there be a multiplier bonus when selling minerals per mining level?
CH_Mining.Config.SellLevelMultiplier = { -- The multipliers based on the players level. This will be multiplied by the total sell value.
	[1] = 0.03, -- So at level 1 and until the next value it will be multiplied by 0.03 (or in other words 3%)
	[10] = 0.05, -- So this is 5% extra when they reach level 10 and until the next which is 20 by default.
	[20] = 0.075,
	[30] = 0.1,
	[40] = 0.15,
	[50] = 0.2, -- 20% bonus at level 50
}

CH_Mining.Config.MinMineralPrice = 50 -- The minimum price a mineral can drop to (it cant drop lower) Price adjustments are made in ch_mining_config_rocks MaxPriceAdjust
CH_Mining.Config.MaxMineralPrice = 150 -- The maximum price a mineral can go to (it wont get higher)

CH_Mining.Config.ResetMineralPriceTarget = 0 -- If set then price will reset to BasePrice for the mineral if it hits this target (0 to disable this)

--[[
	NPC/CHAT COMMAND CONFIG
--]]
CH_Mining.Config.UseMiningNPC = true -- Should the mining NPC spawn? It allows for opening the mining menu.
CH_Mining.Config.NPCModel = "models/breen.mdl" -- If using NPC which model should it have?

CH_Mining.Config.UseMiningChatCommand = true -- Should the chat command be enabled to open the mining menu?
CH_Mining.Config.MiningMenuChatCommand = "!mining" -- If enabled then this is the chat command to open the mining menu.

--[[
	XP CONFIG
--]]
CH_Mining.Config.RankXPMultiplier = { -- How much XP is multiplied when receiving it based on their rank. Any other rank just returns 1 (normal amounts)
	["owner"] = 3,
	["superadmin"] = 3,
	["admin"] = 2,
	["goldmember"] = 2,
	["vip"] = 1.5,
}

CH_Mining.Config.XPRequiredForLevelDefault = 1000 -- The default amount of XP required to level up
CH_Mining.Config.PercentIncreasePerLevel = 15 -- For every level the required XP is increased by this percentage and multiplied by the level. So for level 10 it would be 1000 + ( 200 * 10 ) = 3000XP to level up to level 10

--[[
	SKILL CONFIG
--]]
CH_Mining.Config.DefaultSkillPoints = 1 -- How many skill points does a player start with?

CH_Mining.Config.AbilityToDecreaseSkills = true -- Should players be able to go down a skill level (the minus button) after having upgraded a skill? This avoids possible abuse of switching skills when needed.

CH_Mining.Config.EnableSkillResetButton = true -- Should the button to reset skills be shown?
CH_Mining.Config.RefundAllSkillPointsOnReset = true -- If true then it will calculate how many points they've spent and refund all. If false then it will give CH_Mining.Config.DefaultSkillPoints
CH_Mining.Config.SkillResetPrice = 10000 -- The price to reset skills

CH_Mining.Config.ShouldCostToUpgradeSkills = false -- Should it cost money to upgrade skills?
CH_Mining.Config.CostToUpgradeSkillPerLevel = 2500 -- How much does it cost per level? 1 = 2500, 2 = 5000, etc

--[[
	HUD CONFIG
--]]
CH_Mining.Config.BGColor = Color( 25, 25, 25, 150 ) -- The background color for the mining inventory on the HUD
CH_Mining.Config.InventoryXPos = 0.01 -- The vertical position for the inventory HUD (default - player can edit in-game)
CH_Mining.Config.InventoryYPos = 0.27 -- The horizontal position for the inventory HUD (default - player can edit in-game)

CH_Mining.Config.LevelXPos = 0.50 -- The vertical position for the level/xp HUD (default - player can edit in-game)
CH_Mining.Config.LevelYPos = 0.03 -- The horizontal position for the level/xp HUD (default - player can edit in-game)

CH_Mining.Config.OnlyShowHUDOnXPEarn = true -- Should the HUD only appear when you hear XP and stay for a certain amount of time?
CH_Mining.Config.HUDShowTime = 30 -- For how many seconds will it stay on screen (if enabled above)?

--[[
	TRANSACTIONS CONFIG
--]]
CH_Mining.Config.TransactionsLimit = 30 -- Maximum amount of transactions to query and network for the client

--[[
	BONUSES CONFIG
--]]
CH_Mining.Config.BonusChance = 2 -- What is the chance that a bonus will trigger? In percentage
CH_Mining.Config.BonusEffect = true -- Play a bonus effect from the rock when triggered

--[[
	CRAFTING MENU
--]]
CH_Mining.Config.SortCraftingBy = "RequiredLevel" -- How should we sort the crafting menu? You can sort by any value from the ch_mining_config_crafting.lua file!
CH_Mining.Config.SortCraftingDescending = false -- Whether the crafting menu should sort in descending order or not.
--addons/ch_mining/lua/ch_mining/shared/config/ch_mining_config_lang.lua:
-- I DO NOT ADVISE YOU TRY TO EDIT BELOW THIS LINE UNLESS YOU UNDERSTAND HOW THIS WORKS!
-- IF YOU WANT TO ADD A LANGUAGE PLEASE OPEN A SUPPORT TICKET ON GMODSTORE.
-- I WILL HELP YOU WITH ANYTHING YOU NEED AND ADD THE LANGUAGE TO THE OFFICIAL SCRIPT.
CH_Mining.Config.Lang = CH_Mining.Config.Lang or {}

CH_Mining.Config.Lang["minerals"] = { -- "You have 52 minerals" or "You have received 20 minerals"
	["en"] = "minerals",
	["fr"] = "minerais",
	["da"] = "",
	["de"] = "Mineralien",
	["pl"] = "minerałów",
	["ru"] = "минералы",
	["es"] = "minerales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "mineral",
	["no"] = "",
}

CH_Mining.Config.Lang["Minerals"] = { -- Same but capitalized
	["en"] = "Minerals",
	["fr"] = "Minerais",
	["da"] = "",
	["de"] = "Mineralien",
	["pl"] = "Minerałów",
	["ru"] = "Минералы",
	["es"] = "Minerales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Mineral",
	["no"] = "",
}

CH_Mining.Config.Lang["You don't have that many"] = { -- You don't have that many Diamond minerals
	["en"] = "You don't have that many",
	["fr"] = "Vous n'avez pas autant de",
	["da"] = "",
	["de"] = "Du hast nicht genug",
	["pl"] = "Nie masz tylu",
	["ru"] = "У тебя не достаточно",
	["es"] = "No tienes esa cantidad de",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sahip olduğun mineraller yetersiz:",
	["no"] = "",
}

CH_Mining.Config.Lang["for selling minerals."] = { -- + $25,000 for selling minerals.
	["en"] = "for selling minerals.",
	["fr"] = "pour la vente de minerais.",
	["da"] = "",
	["de"] = "für den Verkauf von Mineralien.",
	["pl"] = "za sprzedaż minerałów.",
	["ru"] = "за продажу минералов",
	["es"] = "por vender minerales.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Mineral satarak kazandın.",
	["no"] = "",
}

CH_Mining.Config.Lang["as a bonus due to your skill level."] = { -- + $4,000 as a bonus due to your skill level.
	["en"] = "as a bonus due to your skill level.",
	["fr"] = "de bonus dû à votre niveau de compétence.",
	["da"] = "",
	["de"] = "als Bonus für deine Fertigkeiten.",
	["pl"] = "jako bonus wynikający z twojego poziomu umiejętnośći.",
	["ru"] = "в качестве бонуса из-за вашего уровня.",
	["es"] = "como extra por tu nivel de habilidad",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Yetenek seviyeniz nedeniyle aldığınız ilave maaş.",
	["no"] = "",
}

CH_Mining.Config.Lang["Manage Skills"] = {
	["en"] = "Manage Skills",
	["fr"] = "Gestion des Compétences",
	["da"] = "",
	["de"] = "Verwalte Fertigkeiten",
	["pl"] = "Zarządzaj Umiejętnościami",
	["ru"] = "Управление скилами",
	["es"] = "Gestión de Habilidades",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Yetenekleri Yönet",
	["no"] = "",
}

CH_Mining.Config.Lang["Points"] = {
	["en"] = "Points",
	["fr"] = "Points",
	["da"] = "",
	["de"] = "Punkte",
	["pl"] = "Punktów",
	["ru"] = "Поинты",
	["es"] = "Puntos",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Puanlar",
	["no"] = "",
}

CH_Mining.Config.Lang["Dashboard"] = {
	["en"] = "Dashboard",
	["fr"] = "Tableau de Bord",
	["da"] = "",
	["de"] = "Startseite",
	["pl"] = "Panel",
	["ru"] = "Панель",
	["es"] = "Tablón",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Gösterge Paneli",
	["no"] = "",
}

CH_Mining.Config.Lang["Inventory"] = {
	["en"] = "Inventory",
	["fr"] = "Inventaire",
	["da"] = "",
	["de"] = "Inventar",
	["pl"] = "Ekwipunek",
	["ru"] = "Инвентарь",
	["es"] = "Inventario",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Envanter",
	["no"] = "",
}

CH_Mining.Config.Lang["Skills"] = {
	["en"] = "Skills",
	["fr"] = "Compétences",
	["da"] = "",
	["de"] = "Fertigkeiten",
	["pl"] = "Umiejętności",
	["ru"] = "Скилы",
	["es"] = "Habilidades",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Yetenekler",
	["no"] = "",
}

CH_Mining.Config.Lang["Crafting"] = {
	["en"] = "Crafting",
	["fr"] = "Fabrication",
	["da"] = "",
	["de"] = "Herstellung",
	["pl"] = "Wytwarzanie",
	["ru"] = "Крафт",
	["es"] = "Fabricación",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Üretim",
	["no"] = "",
}

CH_Mining.Config.Lang["Leaderboards"] = {
	["en"] = "Leaderboards",
	["fr"] = "Classement",
	["da"] = "",
	["de"] = "Bestenliste",
	["pl"] = "Ranking",
	["ru"] = "Лидеры",
	["es"] = "Tabla de Puntajes",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Lider Tablosu",
	["no"] = "",
}

CH_Mining.Config.Lang["Transactions"] = {
	["en"] = "Transactions",
	["fr"] = "Transactions",
	["da"] = "",
	["de"] = "Transaktionen",
	["pl"] = "Transakcje",
	["ru"] = "Транзакции",
	["es"] = "Transacciones",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Alışverişler",
	["no"] = "",
}

CH_Mining.Config.Lang["Statistics"] = {
	["en"] = "Statistics",
	["fr"] = "Statistiques",
	["da"] = "",
	["de"] = "Statistiken",
	["pl"] = "Statystyki",
	["ru"] = "Статистика",
	["es"] = "Estadísticas",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "İstatistikler",
	["no"] = "",
}

CH_Mining.Config.Lang["Options"] = {
	["en"] = "Options",
	["fr"] = "Options",
	["da"] = "",
	["de"] = "Optionen",
	["pl"] = "Opcje",
	["ru"] = "Параметры",
	["es"] = "Opciones",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Ayarlar",
	["no"] = "",
}

CH_Mining.Config.Lang["Current level"] = {
	["en"] = "Current level",
	["fr"] = "Niveau actuel",
	["da"] = "",
	["de"] = "Aktuelles Level",
	["pl"] = "Obecny poziom",
	["ru"] = "Текущий лвл",
	["es"] = "Nivel actual",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şuanki seviye",
	["no"] = "",
}

CH_Mining.Config.Lang["Max"] = {
	["en"] = "Max",
	["fr"] = "Max",
	["da"] = "",
	["de"] = "Max",
	["pl"] = "Max",
	["ru"] = "Макс",
	["es"] = "Máx",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Azami",
	["no"] = "",
}

CH_Mining.Config.Lang["Your current level allows you to carry"] = {
	["en"] = "Your current level allows you to carry",
	["fr"] = "Votre niveau actuel vous permet de porter",
	["da"] = "",
	["de"] = "Dein aktuelles Level erlaubt es dir das Tragen von",
	["pl"] = "Twój obecny poziom pozwala ci na noszenie",
	["ru"] = "Ваш текущий уровень позволяет вам нести",
	["es"] = "Tu nivel actual te permite cargar",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Mevcut seviyeniz belirtilen eşyaları taşımanıza olanak sağlıyor:",
	["no"] = "",
}

CH_Mining.Config.Lang["Upgrading to the next level will allow you to carry"] = {
	["en"] = "Upgrading to the next level will allow you to carry",
	["fr"] = "Passer au niveau supérieur vous permettra de porter",
	["da"] = "",
	["de"] = "Die Verbesserung auf das nächste Level erlaubt dir das Tragen von",
	["pl"] = "Ulepszenie do następnego poziomu pozwoli ci nosić",
	["ru"] = "Переход на следующий уровень позволит вам носить",
	["es"] = "Mejorar al siguiente nivel te permitirá cargar",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sonraki seviyeye geliştirmek belirtilen eşyaları taşımanıza izin verecek:",
	["no"] = "",
}

CH_Mining.Config.Lang["At your current level you mine between"] = {
	["en"] = "At your current level you mine between",
	["fr"] = "À votre niveau actuel, vous minez entre",
	["da"] = "",
	["de"] = "Mit deinem aktuellen Level förderst du zwischen",
	["pl"] = "Na twoim obecnym poziomie wydobywasz między",
	["ru"] = "На вашем текущем уровне вы добываете",
	["es"] = "En tu nivel actual minas entre",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şuanki seviyenizde belirtilen seviyeler arasında madenler kazıyorsunuz:",
	["no"] = "",
}

CH_Mining.Config.Lang["minerals per hit."] = {
	["en"] = "minerals per hit.",
	["fr"] = "minerais par coup.",
	["da"] = "",
	["de"] = "Mineralien pro Schlag.",
	["pl"] = "minerałów na uderzenie.",
	["ru"] = "минералы за попадание",
	["es"] = "minerales por picada.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "vuruşta alınan mineral sayısı",
	["no"] = "",
}

CH_Mining.Config.Lang["At the next level you will mine between"] = {
	["en"] = "At the next level you will mine between",
	["fr"] = "Au niveau suivant, vous minerez entre",
	["da"] = "",
	["de"] = "Mit dem nächsten Level förderst du zwischen",
	["pl"] = "Na następnym poziomie będziesz wydobywać między",
	["ru"] = "На следующем уровне вы будете добывать",
	["es"] = "En el siguiente nivel minarás entre",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sonraki seviyenizde belirtilen miktar arasında mineral alacaksınız:",
	["no"] = "",
}

CH_Mining.Config.Lang["At your current level you receive between"] = {
	["en"] = "At your current level you receive between",
	["fr"] = "À votre niveau actuel, vous recevez entre",
	["da"] = "",
	["de"] = "Mit deinem aktuellen Level erhältst du zwischen",
	["pl"] = "Na twoim obecnym poziomie otrzymujesz między",
	["ru"] = "На вашем текущем уровне вы получаете между",
	["es"] = "En tu nivel actual recibes entre",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şuanki seviyede belirtilen miktar arasında",
	["no"] = "",
}

CH_Mining.Config.Lang["experience per hit."] = {
	["en"] = "experience per hit.",
	["fr"] = "expérience par coup.",
	["da"] = "",
	["de"] = "Erfahrungspunkte pro Schlag.",
	["pl"] = "doświadczenia na uderzenie.",
	["ru"] = "опыт за удар.",
	["es"] = "experiencia por picada",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Vuruş başı tecrübe.",
	["no"] = "",
}

CH_Mining.Config.Lang["At the next level you will receive between"] = {
	["en"] = "At the next level you will receive between",
	["fr"] = "Au niveau suivant, vous recevrez entre",
	["da"] = "",
	["de"] = "Mit dem nächsten Level erhältst du zwischen",
	["pl"] = "Na następnym poziomie będzie otrzymywać między",
	["ru"] = "На следующем уровне вы будете получать",
	["es"] = "En el siguiente nivel recibirás entre",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şuanki seviyede belirtilen miktarlar arasında",
	["no"] = "",
}

CH_Mining.Config.Lang["At your current level you have a"] = {
	["en"] = "At your current level you have a",
	["fr"] = "A votre niveau actuel, vous avez",
	["da"] = "",
	["de"] = "Mit deinem aktuellen Level hast du einen",
	["pl"] = "Na twoim obecnym poziomie masz",
	["ru"] = "На вашем текущем лвле у вас есть",
	["es"] = "En tu nivel actual tienes",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şuanki seviyede",
	["no"] = "",
}

CH_Mining.Config.Lang["seconds delay for the pickaxe."] = {
	["en"] = "seconds delay for the pickaxe.",
	["fr"] = "secondes de délai pour la pioche.",
	["da"] = "",
	["de"] = "Sekunden Cooldown für deine Spitzhacke.",
	["pl"] = "sekundowe opóźnienie dla kilofa.",
	["ru"] = "секундная задержка для кирки.",
	["es"] = "segundos de enfriamiento en el pico.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Saniye kazma ertelemesi var.",
	["no"] = "",
}

CH_Mining.Config.Lang["Upgrading to the next level will decrease your delay to"] = {
	["en"] = "Upgrading to the next level will decrease your delay to",
	["fr"] = "Passer au niveau suivant réduira votre délai de",
	["da"] = "",
	["de"] = "Mit einem Levelaufstieg verringerst du den Cooldown um",
	["pl"] = "Ulepszenie do następnego poziomiu obniży twoje opóźnienie do",
	["ru"] = "Переход на следующий уровень уменьшит вашу задержку на",
	["es"] = "Mejorar al siguiente nivel reducirá tu enfriamiento a",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sonraki seviyeye geliştirmek bu ertelemeyi",
	["no"] = "",
}

CH_Mining.Config.Lang["seconds."] = {
	["en"] = "seconds.",
	["fr"] = "secondes.",
	["da"] = "",
	["de"] = "Sekunden.",
	["pl"] = "sekund.",
	["ru"] = "секунд.",
	["es"] = "segundos.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Saniye.",
	["no"] = "",
}

CH_Mining.Config.Lang["You currently receive"] = {
	["en"] = "You currently receive",
	["fr"] = "Vous recevez actuellement",
	["da"] = "",
	["de"] = "Derzeit erhältst du",
	["pl"] = "Obecnie otrzymujesz",
	["ru"] = "В настоящее время вы получаете",
	["es"] = "Actualmente recibes",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şuanda mineral satışlarınız size",
	["no"] = "",
}

CH_Mining.Config.Lang["extra when selling minerals."] = {
	["en"] = "extra when selling minerals.",
	["fr"] = "supplémentaires lors de la vente de minerais.",
	["da"] = "",
	["de"] = "Extra beim Verkauf von Mineralien.",
	["pl"] = "dodatkowo przy sprzedawaniu minerałów.",
	["ru"] = "дополнительно при продаже минералов",
	["es"] = "extra cuando vendes minerales.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "TL ek gelir sağlıyor.",
	["no"] = "",
}

CH_Mining.Config.Lang["Upgrading to the next level will increase your bonus to"] = {
	["en"] = "Upgrading to the next level will increase your bonus to",
	["fr"] = "Passer au niveau suivant augmentera votre bonus de",
	["da"] = "",
	["de"] = "Mit einem Levelaufstieg erhöhst du den Bonus um",
	["pl"] = "Ulepszenie do następnego poziomu zwiększy twój bonus do",
	["ru"] = "Переход на следующий уровень увеличит ваш бонус до",
	["es"] = "Mejorar al siguiente nivel incrementará tu extra a",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sonraki seviyeye geçmeniz bu bonusu belirtilen miktara yükseltecek:",
	["no"] = "",
}

CH_Mining.Config.Lang["You currently have a"] = {
	["en"] = "You currently have a",
	["fr"] = "Vous avez actuellement un",
	["da"] = "",
	["de"] = "Du hast derzeit eine",
	["pl"] = "Obecnie masz",
	["ru"] = "В настоящее время у вас есть",
	["es"] = "Actualmente tienes un",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şuanda kazarken mineral elde etme şansınız",
	["no"] = "",
}

CH_Mining.Config.Lang["chance of receiving minerals when mining."] = {
	["en"] = "chance of receiving minerals when mining.",
	["fr"] = "chance de recevoir des minerais en minant.",
	["da"] = "",
	["de"] = "Chance beim Abbau Mineralien zu erhalten. ",
	["pl"] = "szans na otrzymanie minerałów podczas kopania.",
	["ru"] = "вероятность получения полезных ископаемых при добыче полезных ископаемых.",
	["es"] = "de chances de recibir minerales al minar.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "",
	["no"] = "",
}

CH_Mining.Config.Lang["Upgrading to the next level will increase your chance to"] = {
	["en"] = "Upgrading to the next level will increase your chance to",
	["fr"] = "Passer au niveau supérieur augmentera vos chances de",
	["da"] = "",
	["de"] = "Mit einem Levelaufstieg erhöht sich die Chance um",
	["pl"] = "Ulepszenie do następnego poziomiu zwiększy twoje szanse do",
	["ru"] = "Переход на следующий уровень увеличит ваши шансы на",
	["es"] = "Mejorar al siguiente nivel incrementará tu chance de",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sonraki seviyeye geliştirmeniz bu şansı belirtilen seviyeye yükseltecek:",
	["no"] = "",
}

CH_Mining.Config.Lang["Name"] = { -- crafting menu
	["en"] = "Name",
	["fr"] = "Nom",
	["da"] = "",
	["de"] = "Name",
	["pl"] = "Nazwa",
	["ru"] = "Имя",
	["es"] = "Nombre",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "İsim",
	["no"] = "",
}

CH_Mining.Config.Lang["Required"] = { -- crafting menu
	["en"] = "Required",
	["fr"] = "Requis",
	["da"] = "",
	["de"] = "Erforderlich",
	["pl"] = "Wymaga",
	["ru"] = "Нужен",
	["es"] = "Requerido",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Gerekli",
	["no"] = "",
}

CH_Mining.Config.Lang["Total"] = { -- crafting menu
	["en"] = "Total",
	["fr"] = "Total",
	["da"] = "",
	["de"] = "Gesamt",
	["pl"] = "Suma",
	["ru"] = "Итог",
	["es"] = "Total",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Toplam",
	["no"] = "",
}

CH_Mining.Config.Lang["Level"] = {
	["en"] = "Level",
	["fr"] = "Niveau",
	["da"] = "",
	["de"] = "Level",
	["pl"] = "Poziom",
	["ru"] = "Лвл",
	["es"] = "Nivel",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Seviye",
	["no"] = "",
}

CH_Mining.Config.Lang["Select an item to craft"] = {
	["en"] = "Select an item to craft",
	["fr"] = "Sélectionnez un objet à fabriquer",
	["da"] = "",
	["de"] = "Wähle ein Item zur Herstellung",
	["pl"] = "Wybierz przedmiot do wytworzenia",
	["ru"] = "Выберите предмет для крафта",
	["es"] = "Elige un objeto para fabricar",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Üretmek istediğiniz eşyayı seçin",
	["no"] = "",
}

CH_Mining.Config.Lang["Required Minerals"] = {
	["en"] = "Required Minerals",
	["fr"] = "Minerais Requis",
	["da"] = "",
	["de"] = "Benötigt Mineralien",
	["pl"] = "Wymagane minerały",
	["ru"] = "Необходимые минералы",
	["es"] = "Minerales Requeridos",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Gerekli Mineraller",
	["no"] = "",
}

CH_Mining.Config.Lang["Craft"] = { -- Craft Ak-47
	["en"] = "Craft",
	["fr"] = "Fabriquer",
	["da"] = "",
	["de"] = "Herstellen",
	["pl"] = "Wytwórz",
	["ru"] = "Крафт",
	["es"] = "Fabricar",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Üret",
	["no"] = "",
}

CH_Mining.Config.Lang["You don't have the required minerals to craft this item!"] = {
	["en"] = "You don't have the required minerals to craft this item!",
	["fr"] = "Vous n'avez pas les minerais nécessaires pour fabriquer cet objet !",
	["da"] = "",
	["de"] = "Dir fehlen die für diesen Gegenstand erforderlichen Mineralien.",
	["pl"] = "Nie posiadasz wymaganych minerałów do wytworzenia tego przedmiotu!",
	["ru"] = "У вас нет необходимых минералов для изготовления этого предмета!",
	["es"] = "¡No tienes los minerales requeridos para fabricar este objeto!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eşyayı üretmek için gerekli minerallere sahip değilsiniz.",
	["no"] = "",
}

CH_Mining.Config.Lang["You don't have enough money to craft this item!"] = {
	["en"] = "You don't have enough money to craft this item!",
	["fr"] = "Vous n'avez pas assez d'argent pour fabriquer cet objet !",
	["da"] = "",
	["de"] = "Du hast nicht genügend Geld, um diesen Gegenstand herzustellen!",
	["pl"] = "Nie posiadasz wystarczająco pieniędzy do wytworzenia tego przedmiotu!",
	["ru"] = "У вас недостаточно денег, чтобы создать этот предмет!",
	["es"] = "¡No tienes suficiente dinero para fabricar este objeto!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eşyayı üretmek için yeterli paranız yok.",
	["no"] = "",
}

CH_Mining.Config.Lang["You don't have the required level to craft this item!"] = {
	["en"] = "You don't have the required level to craft this item!",
	["fr"] = "Vous n'avez pas le niveau requis pour fabriquer cet objet !",
	["da"] = "",
	["de"] = "Du hast nicht das erforderliche Level, um diesen Gegenstand herzustellen!",
	["pl"] = "Nie posiadasz wymaganego poziomu do wytworzenia tego przedmiotu!",
	["ru"] = "У вас нет необходимого уровня для создания этого предмета!",
	["es"] = "¡No tienes el nivel suficiente para fabricar este objeto!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eşyayı üretmek için yeterli seviyeniz yok.",
	["no"] = "",
}

CH_Mining.Config.Lang["You don't have enough XP to craft this item!"] = {
	["en"] = "You don't have enough XP to craft this item!",
	["fr"] = "Vous n'avez pas assez d'XP pour fabriquer cet objet !",
	["da"] = "",
	["de"] = "Du hast nicht die erforderlichen XP, um diesen Gegenstand herzustellen!",
	["pl"] = "Nie posiadasz wystarczająco XP do wytworzenia tego przedmiotu!",
	["ru"] = "У вас недостаточно опыта, чтобы создать этот предмет!",
	["es"] = "¡No tienes suficiente EXP para fabricar este objeto!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eşyayı üretmek için yeterince tecrübeniz yok.",
	["no"] = "",
}

CH_Mining.Config.Lang["Crafting the item cost you"] = { -- .. cost you $5,000
	["en"] = "Crafting the item cost you",
	["fr"] = "Fabriquer l'objet vous coûte",
	["da"] = "",
	["de"] = "Die Herstellung kostet dich",
	["pl"] = "Wytworzenie tego przedmiotu będzie cie kosztować",
	["ru"] = "Изготовление предмета обошлось вам",
	["es"] = "Fabricar este objeto te costará",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eşyayı üretmek size mal oldu:",
	["no"] = "",
}

CH_Mining.Config.Lang["You have successfully crafted"] = {
	["en"] = "You have successfully crafted",
	["fr"] = "Vous avez fabriqué avec succès",
	["da"] = "",
	["de"] = "Du erstelltest erfolgreich ein ",
	["pl"] = "Pomyślnie wytworzyłeś",
	["ru"] = "Вы успешно скрафтили",
	["es"] = "Has fabricado",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Başarıyla ürettiniz:",
	["no"] = "",
}

CH_Mining.Config.Lang["Only administrators can perform this action."] = {
	["en"] = "Only administrators can perform this action.",
	["fr"] = "Seuls les administrateurs peuvent effectuer cette action.",
	["da"] = "",
	["de"] = "Nur Administratoren können diese Aktion ausführen.",
	["pl"] = "Tylko administratorzy mogą wykonać tę akcję.",
	["ru"] = "Это действие могут выполнять только администраторы.",
	["es"] = "Sólo los administradores pueden hacer esto.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eylemi sadece yöneticiler gerçekleştirebilir.",
	["no"] = "",
}

CH_Mining.Config.Lang["New position for the NPC has been succesfully set."] = {
	["en"] = "New position for the NPC has been succesfully set.",
	["fr"] = "La nouvelle position du PNJ a été définie avec succès.",
	["da"] = "",
	["de"] = "Es wurde eine neue Position für den NPC gesetzt.",
	["pl"] = "Nowa pozycja dla NPC została pomyślnie ustawiona.",
	["ru"] = "Новая позиция для NPC была успешно установлена",
	["es"] = "Nueva posición del NPC establecida correctamente.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "NPC'nin yeni konumu başarıyla ayarlandı.",
	["no"] = "",
}

CH_Mining.Config.Lang["The NPC will respawn in 5 seconds. Move out the way."] = {
	["en"] = "The NPC will respawn in 5 seconds. Move out the way.",
	["fr"] = "Le PNJ réapparaîtra dans 5 secondes. Déplacez-vous.",
	["da"] = "",
	["de"] = "Der NPC wird in 5 Sekunden respawnen. Geh etwas weg.",
	["pl"] = "NPC zrespawnuje się za 5 sekund. Przesuń się.",
	["ru"] = "NPC возродится через 5 секунд. Отойди с дороги.",
	["es"] = "El NPC reaparecerá en 5 segundos. Muévete del punto de reaparición",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "NPC 5 saniye içerisinde yeniden doğacak. Yoldan çekilin.",
	["no"] = "",
}

CH_Mining.Config.Lang["All mining entities have been saved to the map."] = {
	["en"] = "All mining entities have been saved to the map.",
	["fr"] = "Toutes les entités minière ont été enregistrées sur la carte.",
	["da"] = "",
	["de"] = "Alle Bergbauunternehmen wurden auf der Karte gespeichert.",
	["pl"] = "Wszystkie podmioty wydobywcze zostały zapisane na mapie.",
	["ru"] = "Все объекты копания были сохранены на карте.",
	["es"] = "Todas las entidades mineras se han guardado en el mapa.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Tüm madencilik varlıkları haritaya kaydedildi.",
	["no"] = "",
}

CH_Mining.Config.Lang["Mining failed because there are no more minerals in the rock!"] = {
	["en"] = "Mining failed because there are no more minerals in the rock!",
	["fr"] = "Le minage a échoué car il n'y a plus de minerais dans la roche !",
	["da"] = "",
	["de"] = "Der Abbau scheiterte, da es nicht genug Mineralien im Gestein gibt!",
	["pl"] = "Nie udało się wykopać ponieważ nie ma już minerałów w tej skale!",
	["ru"] = "Добыча провалилась, потому что в породе больше нет минералов!",
	["es"] = "¡El minado falló porque no hay minerales en la roca!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kazma başarısız çünkü bu kaya içerisinde mineral kalmadı.",
	["no"] = "",
}

CH_Mining.Config.Lang["Mining failed because your inventory does not have enough space!"] = {
	["en"] = "Mining failed because your inventory does not have enough space!",
	["fr"] = "Le minage a échoué car votre inventaire n'a pas assez d'espace !",
	["da"] = "",
	["de"] = "Der Abbau scheiterte, da du nicht mehr genug Platz in deinem Inventar hast!",
	["pl"] = "Nie udało się wykopać ponieważ twój ekwipunek nie ma wystarczająco miejsca!",
	["ru"] = "Копание не удалось, потому что в вашем инвентаре недостаточно места!",
	["es"] = "¡El minado falló porque no tienes suficiente espacio en el inventario!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kazma başarısız çünkü envanterinde yer yok.",
	["no"] = "",
}

CH_Mining.Config.Lang["Prices for minerals have been updated!"] = {
	["en"] = "Prices for minerals have been updated!",
	["fr"] = "Les prix des minerais ont été mis à jour !",
	["da"] = "",
	["de"] = "Die Preise für Mineralien wurden aktualisiert!",
	["pl"] = "Ceny dla minerałów zostały zaaktualizowane!",
	["ru"] = "Цены на полезные ископаемые были обновлены!",
	["es"] = "¡Los precios de los minerales han sido actualizados!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Minerallerin fiyatları güncellendi.",
	["no"] = "",
}

CH_Mining.Config.Lang["You don't have skill points to upgrade this skill."] = {
	["en"] = "You don't have skill points to upgrade this skill.",
	["fr"] = "Vous n'avez pas de points de compétence pour améliorer cette compétence.",
	["da"] = "",
	["de"] = "Du hast keine Skill-Punkte um diese Fähigkeit zu erlernen.",
	["pl"] = "Nie masz wystarczająco punktów umiejętności aby ulepszyć tą umiejętność.",
	["ru"] = "У вас нет очков навыков, чтобы улучшить этот навык.",
	["es"] = "No tienes suficientes puntos de habilidad para mejorarla.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu yeteneği geliştirmek için yetenek puanın yok.",
	["no"] = "",
}

CH_Mining.Config.Lang["You are already maxed out with this skill."] = {
	["en"] = "You are already maxed out with this skill.",
	["fr"] = "Vous avez déjà atteint le maximum de cette compétence.",
	["da"] = "",
	["de"] = "Du hast diese Fähigkeit bereits perfektioniert.",
	["pl"] = "Masz już maksymalny poziom tej umięjętności.",
	["ru"] = "Вы уже достигли максимума в этом навыке.",
	["es"] = "Ya has alcanzado el nivel máximo de esta habilidad.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu yeteneğiniz zaten son seviyede.",
	["no"] = "",
}

CH_Mining.Config.Lang["You have successfully upgraded this skill to level"] = {
	["en"] = "You have successfully upgraded this skill to level",
	["fr"] = "Vous avez réussi à améliorer cette compétence au niveau",
	["da"] = "",
	["de"] = "Du hast deine Fähigkeit verbessert. Neue Stufe:",
	["pl"] = "Pomyślnie ulepszyłeś tą umiejętność do poziomu",
	["ru"] = "Вы успешно повысили этот навык до уровня",
	["es"] = "Has mejorado esta habilidad al nivel",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Yeteneğiniz başarıyla seviye atladı:",
	["no"] = "",
}

CH_Mining.Config.Lang["You don't have enough of this skill to downgrade it further."] = {
	["en"] = "You don't have enough of this skill to downgrade it further.",
	["fr"] = "Vous n'avez pas assez de cette compétence pour la rétrograder davantage.",
	["da"] = "",
	["de"] = "Du kannst die Fähigkeit nicht noch weiter hinabstufen.",
	["pl"] = "Nie możesz jeszcze bardziej obniżyć tej umiejętności.",
	["ru"] = "У вас недостаточно этого навыка, чтобы понизить его еще больше.",
	["es"] = "No tienes suficiente de esta habilidad como para degradarla más.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu yeteneğin seviyesini düşürmek için yeterli seviyede değilsiniz",
	["no"] = "",
}

CH_Mining.Config.Lang["You have successfully downgraded this skill to level"] = {
	["en"] = "You have successfully downgraded this skill to level",
	["fr"] = "Vous avez réussi à rétrograder cette compétence au niveau",
	["da"] = "",
	["de"] = "Du hast die Fähigkeit herabgestuft. Neue Stufe:",
	["pl"] = "Pomyślnie obniżyłeś tą umiejętność do poziomu",
	["ru"] = "Вы успешно понизили этот навык до уровня",
	["es"] = "Has degradado esta habilidad al nivel",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Yeteneğin seviyesi başarıyla belirtilen seviyeye düşürüldü:",
	["no"] = "",
}

CH_Mining.Config.Lang["experience gained."] = { -- +10 experiene gained.
	["en"] = "experience gained.",
	["fr"] = "expérience acquise.",
	["da"] = "",
	["de"] = "Erfahrungspunkte erhalten.",
	["pl"] = "doświadczenia.",
	["ru"] = "полученный опыт.",
	["es"] = "experiencia obtenida.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Tecrübe kazanıldı",
	["no"] = "",
}

CH_Mining.Config.Lang["experience lost."] = { -- -10 experience lost.
	["en"] = "experience lost.",
	["fr"] = "expérience perdue.",
	["da"] = "",
	["de"] = "Erfahrungspunkte verloren.",
	["pl"] = "doświadczenia.",
	["ru"] = "Потеряно опыта",
	["es"] = "experiencia perdida.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Tecrübe kaybedildi",
	["no"] = "",
}

CH_Mining.Config.Lang["Congratulations! You have reached a new mining level."] = {
	["en"] = "Congratulations! You have reached a new mining level.",
	["fr"] = "Félicitations ! Vous avez atteint un nouveau niveau de minage.",
	["da"] = "",
	["de"] = "Herzlichen Glückwunsch! Du hast ein neues Bergbau Level erreicht.",
	["pl"] = "Gratulacje! Osiągnąłeś nowy poziom górnictwa.",
	["ru"] = "Поздравляю! Вы достигли нового уровня копания.",
	["es"] = "¡Felicitaciones! Has alcanzado un nuevo nivel de minado.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Tebrikler, yeni kazma seviyesine ulaştınız",
	["no"] = "",
}

CH_Mining.Config.Lang["Mining Dashboard"] = {
	["en"] = "Mining Dashboard",
	["fr"] = "Tableau de bord Minage",
	["da"] = "",
	["de"] = "Bergbau Startseite",
	["pl"] = "Panel Górnictwa",
	["ru"] = "Панель копания",
	["es"] = "Tablón de Minado",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Maden Gösterge Paneli",
	["no"] = "",
}

CH_Mining.Config.Lang["You have"] = { -- You have 100 / 1000 XP and are level 7
	["en"] = "You have",
	["fr"] = "Vous avez",
	["da"] = "",
	["de"] = "Du hast",
	["pl"] = "Posiadasz",
	["ru"] = "У вас",
	["es"] = "Tienes",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sahip olduğunuz tecrübe puanı",
	["no"] = "",
}

CH_Mining.Config.Lang["and are level"] = { -- You have 100 / 1000 XP and are level 7
	["en"] = "and are level",
	["fr"] = "et êtes niveau",
	["da"] = "",
	["de"] = "und bist Level",
	["pl"] = "i jesteś na poziomie",
	["ru"] = "и уровень",
	["es"] = "y eres nivel",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "ve seviyeniz",
	["no"] = "",
}

CH_Mining.Config.Lang["Your Inventory"] = {
	["en"] = "Your Inventory",
	["fr"] = "Votre Inventaire",
	["da"] = "",
	["de"] = "Dein Inventar",
	["pl"] = "Twój Ekwipunek",
	["ru"] = "Ваш инвентарь",
	["es"] = "Tu Inventario",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Envanteriniz",
	["no"] = "",
}

CH_Mining.Config.Lang["per mineral"] = { -- shows price of mineral
	["en"] = "per mineral",
	["fr"] = "par minerai",
	["da"] = "",
	["de"] = "pro Mineral",
	["pl"] = "za minerał",
	["ru"] = "за минерал",
	["es"] = "por mineral",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Mineral başı.",
	["no"] = "",
}

CH_Mining.Config.Lang["since update"] = { -- +0.023 since update
	["en"] = "since update",
	["fr"] = "depuis la mise à jour",
	["da"] = "",
	["de"] = "seit Aktualisierung",
	["pl"] = "od aktualizacji",
	["ru"] = "с запуска сервера",
	["es"] = "desde la actualización",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Güncellemeden beri",
	["no"] = "",
}

CH_Mining.Config.Lang["Sell Minerals"] = {
	["en"] = "Sell Minerals",
	["fr"] = "Vendre Minerais",
	["da"] = "",
	["de"] = "Mineralien verkaufen",
	["pl"] = "Sprzedaj Minerały",
	["ru"] = "Продать",
	["es"] = "Vender Minerales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Mineralleri Sat",
	["no"] = "",
}

CH_Mining.Config.Lang["Sell"] = { -- Sell Diamond
	["en"] = "Sell",
	["fr"] = "Vendre",
	["da"] = "",
	["de"] = "Verkaufen",
	["pl"] = "Sprzedaj",
	["ru"] = "Продать",
	["es"] = "Vender",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sat",
	["no"] = "",
}

CH_Mining.Config.Lang["Mineral Sold"] = { -- Transaction menu
	["en"] = "Mineral Sold",
	["fr"] = "Minerai Vendu",
	["da"] = "",
	["de"] = "Mineralien verkauft",
	["pl"] = "Sprzedany Minerał",
	["ru"] = "Продано",
	["es"] = "Mineral Vendido",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Mineraller Satıldı",
	["no"] = "",
}

CH_Mining.Config.Lang["Amount"] = { -- Transaction menu
	["en"] = "Amount",
	["fr"] = "Montant",
	["da"] = "",
	["de"] = "Anzahl",
	["pl"] = "Ilość",
	["ru"] = "Кол-во",
	["es"] = "Cantidad",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Miktar",
	["no"] = "",
}

CH_Mining.Config.Lang["Earnings"] = { -- Transaction menu
	["en"] = "Earnings",
	["fr"] = "Gains",
	["da"] = "",
	["de"] = "Ergebnis",
	["pl"] = "Zysk",
	["ru"] = "Заработано",
	["es"] = "Ganancias",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kazanç",
	["no"] = "",
}

CH_Mining.Config.Lang["Timestamp"] = { -- Transaction menu
	["en"] = "Timestamp",
	["fr"] = "Horodatage",
	["da"] = "",
	["de"] = "Zeitpunkt",
	["pl"] = "Data",
	["ru"] = "Время продажи",
	["es"] = "Fecha y Horario",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Zaman",
	["no"] = "",
}

CH_Mining.Config.Lang["View your mining dashboard"] = {
	["en"] = "View your mining dashboard",
	["fr"] = "Afficher votre tableau de bord de minage",
	["da"] = "",
	["de"] = "Deine Bergbau-Startseite anzeigen",
	["pl"] = "Wyświetl swój panel górnictwa",
	["ru"] = "Просмотр вашей панели",
	["es"] = "Ver tu tablón de minado",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Maden gösterge panelinizi görüntüleyin",
	["no"] = "",
}

CH_Mining.Config.Lang["View inventory & leaderboards"] = {
	["en"] = "View inventory & leaderboards",
	["fr"] = "Afficher l'inventaire & les classements",
	["da"] = "",
	["de"] = "Dein Inventar und Bestenlisten",
	["pl"] = "Wyświetl ekwipunek i ranking",
	["ru"] = "Просмотр инвентаря",
	["es"] = "Ver inventario y tablón de puntajes",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Envanterinizi ve lider tablonuzu görüntüleyin",
	["no"] = "",
}

CH_Mining.Config.Lang["Crafting items & upgrade skills"] = {
	["en"] = "Crafting items & upgrade skills",
	["fr"] = "Fabriquer des objets & améliorer les compétences",
	["da"] = "",
	["de"] = "Stelle Items her und verbessere Fähigkeiten",
	["pl"] = "Wytwórz przedmioty & ulepsz umiejętności",
	["ru"] = "Улучшение навыков",
	["es"] = "Fabricar objetos y mejorar habilidades",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Eşya üretim & yetenek geliştirme",
	["no"] = "",
}

CH_Mining.Config.Lang["Mining"] = {
	["en"] = "Mining",
	["fr"] = "Minage",
	["da"] = "",
	["de"] = "Bergbau",
	["pl"] = "Górnictwo",
	["ru"] = "Копание",
	["es"] = "Minando",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Madencilik",
	["no"] = "",
}

CH_Mining.Config.Lang["Durability"] = {
	["en"] = "Durability",
	["fr"] = "Durabilité",
	["da"] = "",
	["de"] = "Haltbarkeit",
	["pl"] = "Wytrzymałość",
	["ru"] = "Долговечность",
	["es"] = "Durabilidad",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Dayanıklılık",
	["no"] = "",
}

CH_Mining.Config.Lang["You are level"] = {
	["en"] = "You are level",
	["fr"] = "Vous êtes niveau",
	["da"] = "",
	["de"] = "Du bist Level",
	["pl"] = "Po",
	["ru"] = "Ваш уровень ",
	["es"] = "Eres nivel",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Seviyeniz",
	["no"] = "",
}

CH_Mining.Config.Lang["Welcome back"] = {
	["en"] = "Welcome back",
	["fr"] = "Bon retour",
	["da"] = "",
	["de"] = "Willkommen zurück",
	["pl"] = "Witaj ponownie",
	["ru"] = "Добро пожаловать",
	["es"] = "Bienvenido de vuelta",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Hoş geldiniz",
	["no"] = "",
}

CH_Mining.Config.Lang["Hey"] = { -- Hey Crap-Head,
	["en"] = "Hey",
	["fr"] = "Hé",
	["da"] = "",
	["de"] = "Hey",
	["pl"] = "Hej",
	["ru"] = "Хей",
	["es"] = "Ey",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Hey",
	["no"] = "",
}

CH_Mining.Config.Lang["These options allow you to customize your mining experience."] = {
	["en"] = "These options allow you to customize your mining experience.",
	["fr"] = "Ces options vous permettent de personnaliser votre expérience de minage.",
	["da"] = "",
	["de"] = "Mit dieser Option kannst du dein Bergbau Erlegnis individuell gestalten.",
	["pl"] = "Te opcje pozwalają ci na dostosowanie swojego doświadczenia górnictwa.",
	["ru"] = "Эти опции позволяют вам настроить свой опыт копания.",
	["es"] = "Estas opciones te permitirán personalizar tu experiencia de minado.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu ayarlar madencilik tecrübenizi düzenlemenizi sağlar.",
	["no"] = "",
}

CH_Mining.Config.Lang["Here are your overall personal mining statistics."] = {
	["en"] = "Here are your overall personal mining statistics.",
	["fr"] = "Voici vos statistiques globales de minage personnel.",
	["da"] = "",
	["de"] = "Hier sind deine persönlichen Bergbaustatistiken.",
	["pl"] = "Tu są twoje ogólne statystyki górnictwa.",
	["ru"] = "Вот ваша общая личная статистика копания.",
	["es"] = "Aquí están todas las estadísticas personales de minado.",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bunlar size ait madencilik istatistikleri",
	["no"] = "",
}

CH_Mining.Config.Lang["rocks"] = { -- Total rocks emptied: 502 rocks
	["en"] = "rocks",
	["fr"] = "roches",
	["da"] = "",
	["de"] = "Felsen",
	["pl"] = "skał",
	["ru"] = "камней",
	["es"] = "rocas",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kaya",
	["no"] = "",
}

CH_Mining.Config.Lang["items"] = { -- Total items crafted: 120 items
	["en"] = "items",
	["fr"] = "objets",
	["da"] = "",
	["de"] = "Gegenstände",
	["pl"] = "przedmiotów",
	["ru"] = "предметов",
	["es"] = "objetos",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Eşyalar",
	["no"] = "",
}

CH_Mining.Config.Lang["Total minerals mined"] = {
	["en"] = "Total minerals mined",
	["fr"] = "Total des minerais extraits",
	["da"] = "",
	["de"] = "Insgesamt abgebaute Mineralien",
	["pl"] = "Suma wydobytych minerałów",
	["ru"] = "Общее кол-во добытых минералов",
	["es"] = "Minerales minados totales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kazılan toplam mineral",
	["no"] = "",
}

CH_Mining.Config.Lang["Total rocks destroyed"] = {
	["en"] = "Total rocks destroyed",
	["fr"] = "Total des roches détruites",
	["da"] = "",
	["de"] = "Insgesamt zerstörte Felsen",
	["pl"] = "Suma zniszczonych skał",
	["ru"] = "Всего разрушенных камней",
	["es"] = "Rocas destruídas totales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Yok edilen toplam kaya",
	["no"] = "",
}

CH_Mining.Config.Lang["Total rocks emptied"] = {
	["en"] = "Total rocks emptied",
	["fr"] = "Total des roches vidées",
	["da"] = "",
	["de"] = "Insgesamt geleerte Felsen",
	["pl"] = "Suma opróżnionych skał",
	["ru"] = "Всего опустошенных камней",
	["es"] = "Rocas vaciadas totales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Boşaltılan toplam kaya",
	["no"] = "",
}

CH_Mining.Config.Lang["Total minerals sold"] = {
	["en"] = "Total minerals sold",
	["fr"] = "Total des minerais vendus",
	["da"] = "",
	["de"] = "Insgesamt verkaufte Mineralien",
	["pl"] = "Suma sprzedanych minerałów",
	["ru"] = "Всего проданных минералов",
	["es"] = "Minerales vendidos totales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Satılan toplam mineral",
	["no"] = "",
}

CH_Mining.Config.Lang["Total money earned"] = {
	["en"] = "Total money earned",
	["fr"] = "Total de l'argent gagné",
	["da"] = "",
	["de"] = "Insgesamt verdientes Geld",
	["pl"] = "Suma zarobionych pieniędzy",
	["ru"] = "Общая сумма заработанных денег",
	["es"] = "Dinero ganado total",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kazanılan toplam para",
	["no"] = "",
}

CH_Mining.Config.Lang["Total items crafted"] = {
	["en"] = "Total items crafted",
	["fr"] = "Total des objets fabriqués",
	["da"] = "",
	["de"] = "Insgesamt hergestellte Items",
	["pl"] = "Suma wytworzonych przedmiotów",
	["ru"] = "Общее количество созданных предметов",
	["es"] = "Objetos fabricados totales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Üretilen toplam eşya",
	["no"] = "",
}

-- ORE NAMES
-- ORE NAMES
CH_Mining.Config.Lang["Gold"] = {
	["en"] = "Gold",
	["fr"] = "Or",
	["da"] = "",
	["de"] = "Gold",
	["pl"] = "Złoto",
	["ru"] = "Золото",
	["es"] = "Oro",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Altın",
	["no"] = "",
}

CH_Mining.Config.Lang["Stone"] = {
	["en"] = "Stone",
	["fr"] = "Pierre",
	["da"] = "",
	["de"] = "Stein",
	["pl"] = "Złóg",
	["ru"] = "Камень",
	["es"] = "Piedra",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Taş",
	["no"] = "",
}

CH_Mining.Config.Lang["Iron"] = {
	["en"] = "Iron",
	["fr"] = "Fer",
	["da"] = "",
	["de"] = "Eisen",
	["pl"] = "Żelazo",
	["ru"] = "Железо",
	["es"] = "Hierro",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Demir",
	["no"] = "",
}

CH_Mining.Config.Lang["Diamond"] = {
	["en"] = "Diamond",
	["fr"] = "Diamant",
	["da"] = "",
	["de"] = "Diamant",
	["pl"] = "Diament",
	["ru"] = "Алмаз",
	["es"] = "Diamante",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Elmas",
	["no"] = "",
}

CH_Mining.Config.Lang["Ruby"] = {
	["en"] = "Ruby",
	["fr"] = "Rubis",
	["da"] = "",
	["de"] = "",
	["pl"] = "",
	["ru"] = "Рубин",
	["es"] = "",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Yakut",
	["no"] = "",
}

CH_Mining.Config.Lang["Amethyst"] = {
	["en"] = "Amethyst",
	["fr"] = "Améthyste",
	["da"] = "",
	["de"] = "Rubin",
	["pl"] = "Rubin",
	["ru"] = "Аметист",
	["es"] = "Rubí",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Ametist",
	["no"] = "",
}

CH_Mining.Config.Lang["Rare"] = {
	["en"] = "Rare",
	["fr"] = "Rare",
	["da"] = "",
	["de"] = "Selten",
	["pl"] = "Rzadki",
	["ru"] = "Редкий",
	["es"] = "Extraño",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Nadir",
	["no"] = "",
}

CH_Mining.Config.Lang["Emerald"] = {
	["en"] = "Emerald",
	["fr"] = "Émeraude",
	["da"] = "",
	["de"] = "Smaragd",
	["pl"] = "Szmaragd",
	["ru"] = "Эмеральд",
	["es"] = "Esmeralda",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Zümrüt",
	["no"] = "",
}

CH_Mining.Config.Lang["Bloodstone"] = {
	["en"] = "Bloodstone",
	["fr"] = "Pierre de sang",
	["da"] = "",
	["de"] = "Blutstein",
	["pl"] = "Krwawnik",
	["ru"] = "Кровавый",
	["es"] = "Sanguinaria",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kantaşı",
	["no"] = "",
}

-- Skills
CH_Mining.Config.Lang["Chance"] = {
	["en"] = "Chance",
	["fr"] = "Chance",
	["da"] = "",
	["de"] = "Chance",
	["pl"] = "Szansa",
	["ru"] = "Шанс",
	["es"] = "Oportunidad",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Şans",
	["no"] = "",
}

CH_Mining.Config.Lang["Speed"] = {
	["en"] = "Speed",
	["fr"] = "Rapidité", -- The word Speed can be translated in two ways, 'Rapidité' or 'Vitesse' depending on your taste.
	["da"] = "",
	["de"] = "Geschwindigkeit",
	["pl"] = "Prędkość",
	["ru"] = "Скорость",
	["es"] = "Velocidad",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Hız",
	["no"] = "",
}

CH_Mining.Config.Lang["Extraction"] = {
	["en"] = "Extraction",
	["fr"] = "Extraction",
	["da"] = "",
	["de"] = "Extraktion",
	["pl"] = "Ekstrakcja",
	["ru"] = "Добыча",
	["es"] = "Extracción",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Çıkarma",
	["no"] = "",
}

CH_Mining.Config.Lang["Capacity"] = {
	["en"] = "Capacity",
	["fr"] = "Capacité",
	["da"] = "",
	["de"] = "Kapazität",
	["pl"] = "Pojemność",
	["ru"] = "Вместимость",
	["es"] = "Capacidad",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kapasite",
	["no"] = "",
}

CH_Mining.Config.Lang["Experience"] = {
	["en"] = "Experience",
	["fr"] = "Expérience",
	["da"] = "",
	["de"] = "Erfahrung",
	["pl"] = "Doświadczenie",
	["ru"] = "Опыт",
	["es"] = "Experiencia",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Deneyim",
	["no"] = "",
}

CH_Mining.Config.Lang["Payout"] = {
	["en"] = "Payout",
	["fr"] = "Paiement",
	["da"] = "",
	["de"] = "Auszahlung",
	["pl"] = "Wypłata",
	["ru"] = "Выплата",
	["es"] = "Pagar",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Ödeme",
	["no"] = "",
}

CH_Mining.Config.Lang["required to mine this type of mineral!"] = { -- Level 10 required to mine this type of mineral!
	["en"] = "required to mine this type of mineral!",
	["fr"] = "nécessaire pour extraire ce type de minerai !",
	["da"] = "",
	["de"] = "erforderlich, um diese Art von Mineralien abzubauen!",
	["pl"] = "wymagane do wydobycia tego rodzaju minerału!",
	["ru"] = "требуется для добычи этого вида минерала!",
	["es"] = "necesario para extraer este tipo de mineral!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu tür mineralleri çıkarmak için gereklidir!",
	["no"] = "",
}

CH_Mining.Config.Lang["ERROR: The amount must be positive!"] = {
	["en"] = "ERROR: The amount must be positive!",
	["fr"] = "ERREUR : La valeur doit être positive!",
	["da"] = "",
	["de"] = "ERROR: Der Betrag muss positiv sein!",
	["pl"] = "BŁĄD: Kwota musi być dodatnia!",
	["ru"] = "ОШИБКА: Сумма должна быть положительной!",
	["es"] = "ERROR: ¡La cantidad debe ser positiva!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "HATA: Tutar pozitif olmalı!",
	["no"] = "",
}

CH_Mining.Config.Lang["ERROR: Player not found!"] = {
	["en"] = "ERROR: Player not found!",
	["fr"] = "ERREUR: Joueur non trouvé!",
	["da"] = "",
	["de"] = "ERROR: Spieler nicht gefunden!",
	["pl"] = "BŁĄD: Nie znaleziono gracza!",
	["ru"] = "Игрок не найден",
	["es"] = "ERROR: ¡Jugador no encontrado!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "HATA: Oyuncu bulunamadı!",
	["no"] = "",
}

CH_Mining.Config.Lang["You have sent"] = { -- You have sent 0.0023 Gold to Crap-Head
	["en"] = "You have sent",
	["fr"] = "Vous avez envoyé",
	["da"] = "",
	["de"] = "Sie haben gesendet",
	["pl"] = "Wysłałeś",
	["ru"] = "Вы отправили",
	["es"] = "Has enviado",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Gönderdiğiniz miktar",
	["no"] = "",
}

CH_Mining.Config.Lang["You have received"] = { -- You have received 0.0023 Gold from Crap-Head
	["en"] = "You have received",
	["fr"] = "Vous avez reçu",
	["da"] = "",
	["de"] = "Sie haben erhalten",
	["pl"] = "Otrzymałeś",
	["ru"] = "Вы получили",
	["es"] = "Has recibido",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Almış olduğunuz miktar",
	["no"] = "",
}

CH_Mining.Config.Lang["to"] = {
	["en"] = "to",
	["fr"] = "à",
	["da"] = "",
	["de"] = "zu",
	["pl"] = "do",
	["ru"] = "к",
	["es"] = "a",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "ile",
	["no"] = "",
}

CH_Mining.Config.Lang["from"] = {
	["en"] = "from",
	["fr"] = "de",
	["da"] = "",
	["de"] = "aus",
	["pl"] = "z",
	["ru"] = "От",
	["es"] = "de",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "itibaren",
	["no"] = "",
}

CH_Mining.Config.Lang["Send"] = { -- MAX 8 CHARCATERS INCLUDING SPACES
	["en"] = "Send",
	["fr"] = "Envoyer",
	["da"] = "",
	["de"] = "Senden",
	["pl"] = "Wyślij",
	["ru"] = "Отправить",
	["es"] = "Enviar",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Gönder",
	["no"] = "",
}

CH_Mining.Config.Lang["Send Minerals"] = {
	["en"] = "Send Minerals",
	["fr"] = "",
	["da"] = "",
	["de"] = "",
	["pl"] = "",
	["ru"] = "Отправить",
	["es"] = "",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "",
	["no"] = "",
}

CH_Mining.Config.Lang["Select Player"] = {
	["en"] = "Select Player",
	["fr"] = "Selectionner Joueur",
	["da"] = "",
	["de"] = "Spieler auswählen",
	["pl"] = "Wybierz gracza",
	["ru"] = "Выбрать игрока",
	["es"] = "Seleccionar Jugador",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Oyuncu seç",
	["no"] = "",
}

CH_Mining.Config.Lang["Mining failed because your team does not allow it!"] = {
	["en"] = "Mining failed because your team does not allow it!",
	["fr"] = "Le minage a échoué car votre équipe ne le permet pas !",
	["da"] = "",
	["de"] = "Das Mining ist fehlgeschlagen, weil Ihr Team es nicht zulässt!",
	["pl"] = "Wydobywanie nie powiodło się, ponieważ Twój zespół na to nie zezwala!",
	["ru"] = "Копание не удалось, потому что ваша работа этого не разрешает!",
	["es"] = "¡La minería falló porque tu equipo no lo permite!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Ekibiniz izin vermediği için madencilik başarısız oldu!",
	["no"] = "",
}

CH_Mining.Config.Lang["Minerals Mined"] = {
	["en"] = "Minerals Mined",
	["fr"] = "Minéraux extraits",
	["da"] = "",
	["de"] = "Mineralien abgebaut",
	["pl"] = "Minerały wydobywane",
	["ru"] = "Добытые полезные ископаемые",
	["es"] = "minerales extraídos",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Çıkarılan Mineraller",
	["no"] = "",
}

CH_Mining.Config.Lang["Rocks Destroyed"] = {
	["en"] = "Rocks Destroyed",
	["fr"] = "Roches détruites",
	["da"] = "",
	["de"] = "Felsen zerstört",
	["pl"] = "Skały zniszczone",
	["ru"] = "Разрушенные камни",
	["es"] = "rocas destruidas",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kayalar Yok Edildi",
	["no"] = "",
}

CH_Mining.Config.Lang["Rocks Emptied"] = {
	["en"] = "Rocks Emptied",
	["fr"] = "Roches vidées",
	["da"] = "",
	["de"] = "Felsen geleert",
	["pl"] = "Skały opróżnione",
	["ru"] = "Скалы опустошены",
	["es"] = "rocas vaciadas",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kayalar Boşaldı",
	["no"] = "",
}

CH_Mining.Config.Lang["Minerals Sold"] = {
	["en"] = "Minerals Sold",
	["fr"] = "Minéraux vendus",
	["da"] = "",
	["de"] = "Mineralien verkauft",
	["pl"] = "Minerały sprzedane",
	["ru"] = "Минералы проданы",
	["es"] = "Minerales vendidos",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Satılan Mineraller",
	["no"] = "",
}

CH_Mining.Config.Lang["Money Earned"] = {
	["en"] = "Money Earned",
	["fr"] = "L'argent gagné",
	["da"] = "",
	["de"] = "Verdientes Geld",
	["pl"] = "Zarobione pieniądze",
	["ru"] = "Заработанные деньги",
	["es"] = "Dinero ganado",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Kazanılan Para",
	["no"] = "",
}

CH_Mining.Config.Lang["Items Crafted"] = {
	["en"] = "Items Crafted",
	["fr"] = "Objets fabriqués",
	["da"] = "",
	["de"] = "Gegenstände hergestellt",
	["pl"] = "Wytworzone przedmioty",
	["ru"] = "Создаваемые предметы",
	["es"] = "Objetos elaborados",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Üretilen Öğeler",
	["no"] = "",
}

CH_Mining.Config.Lang["Congratulations! You received the bonus"] = {
	["en"] = "Congratulations! You received the bonus",
	["fr"] = "Toutes nos félicitations! Vous avez reçu le bonus",
	["da"] = "",
	["de"] = "Glückwunsch! Sie haben den Bonus erhalten",
	["pl"] = "Gratulacje! Otrzymałeś bonus",
	["ru"] = "Поздравляем! Вы получили бонус",
	["es"] = "¡Felicidades! Recibiste el bono",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Tebrikler! bonusu aldın",
	["no"] = "",
}

CH_Mining.Config.Lang["Sell All Minerals"] = {
	["en"] = "Sell All Minerals",
	["fr"] = "Vendre des minéraux",
	["da"] = "",
	["de"] = "Verkaufe Mineralien",
	["pl"] = "Sprzedam minerały",
	["ru"] = "Продать полезные ископаемые",
	["es"] = "Vender minerales",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Mineral sat",
	["no"] = "",
}

CH_Mining.Config.Lang["for selling all your minerals (including bonuses)"] = {
	["en"] = "for selling all your minerals (including bonuses)",
	["fr"] = "pour vendre tous vos minerais (y compris les bonus)",
	["da"] = "",
	["de"] = "für den Verkauf aller Ihrer Mineralien (einschließlich Boni)",
	["pl"] = "za sprzedaż wszystkich posiadanych minerałów (w tym premii)",
	["ru"] = "за продажу всех ваших минералов (включая бонусы)",
	["es"] = "por vender todos tus minerales (incluyendo bonos)",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "tüm minerallerinizi sattığınız için (ikramiyeler dahil)",
	["no"] = "",
}

CH_Mining.Config.Lang["Reset Skills"] = {
	["en"] = "Reset Skills",
	["fr"] = "Réinitialiser",
	["da"] = "",
	["de"] = "Zurücksetzen",
	["pl"] = "Resetowanie",
	["ru"] = "Перезагрузить",
	["es"] = "Reiniciar",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Sıfırla",
	["no"] = "",
}

CH_Mining.Config.Lang["You cannot afford to reset your skills!"] = {
	["en"] = "You cannot afford to reset your skills!",
	["fr"] = "Vous ne pouvez pas vous permettre de réinitialiser vos compétences !",
	["da"] = "",
	["de"] = "Sie können es sich nicht leisten, Ihre Fähigkeiten neu zu erlernen!",
	["pl"] = "Nie możesz sobie pozwolić na zresetowanie swoich umiejętności!",
	["ru"] = "Вы не можете позволить себе сбросить свои навыки!",
	["es"] = "¡No puedes darte el lujo de restablecer tus habilidades!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Becerilerinizi sıfırlamayı göze alamazsınız!",
	["no"] = "",
}

CH_Mining.Config.Lang["All your skills have been reset! It cost you"] = {
	["en"] = "All your skills have been reset! It cost you",
	["fr"] = "Toutes vos compétences ont été réinitialisées ! Ça t'a coûté",
	["da"] = "",
	["de"] = "Alle deine Fähigkeiten wurden zurückgesetzt! Es hat dich gekostet",
	["pl"] = "Wszystkie Twoje umiejętności zostały zresetowane! To cię kosztowało",
	["ru"] = "Все ваши навыки были сброшены! Это стоило тебе",
	["es"] = "¡Todas tus habilidades han sido reiniciadas! te costó",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Tüm becerileriniz sıfırlandı! Bu sana pahalıya mal oldu",
	["no"] = "",
}

CH_Mining.Config.Lang["You are missing minerals to craft this item!"] = {
	["en"] = "You are missing minerals to craft this item!",
	["fr"] = "Il vous manque des minéraux pour fabriquer cet objet !",
	["da"] = "",
	["de"] = "Dir fehlen Mineralien, um diesen Gegenstand herzustellen!",
	["pl"] = "Brakuje Ci minerałów, aby wytworzyć ten przedmiot!",
	["ru"] = "Для создания этого предмета вам не хватает минералов!",
	["es"] = "¡Te faltan minerales para elaborar este artículo!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eşyayı üretmek için mineralleriniz eksik!",
	["no"] = "",
}

CH_Mining.Config.Lang["Cannot craft because your level is too low!"] = {
	["en"] = "Cannot craft because your level is too low!",
	["fr"] = "Impossible de fabriquer car votre niveau est trop bas !",
	["da"] = "",
	["de"] = "Kann nicht hergestellt werden, weil dein Level zu niedrig ist!",
	["pl"] = "Nie możesz tworzyć, ponieważ twój poziom jest zbyt niski!",
	["ru"] = "Невозможно создать, потому что ваш уровень слишком низок!",
	["es"] = "¡No puedes crear porque tu nivel es demasiado bajo!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Seviyeniz çok düşük olduğundan zanaat yapılamıyor!",
	["no"] = "",
}

CH_Mining.Config.Lang["Cannot craft due to missing XP!"] = {
	["en"] = "Cannot craft due to missing XP!",
	["fr"] = "Impossible de fabriquer à cause d'XP manquant !",
	["da"] = "",
	["de"] = "Herstellung aufgrund fehlender XP nicht möglich!",
	["pl"] = "Nie można wytwarzać z powodu braku XP!",
	["ru"] = "Невозможно создать из-за отсутствия опыта!",
	["es"] = "¡No se puede crear debido a que falta XP!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Eksik XP nedeniyle üretim yapılamıyor!",
	["no"] = "",
}

CH_Mining.Config.Lang["You cannot afford to craft this item!"] = {
	["en"] = "You cannot afford to craft this item!",
	["fr"] = "Vous ne pouvez pas vous permettre de fabriquer cet objet !",
	["da"] = "",
	["de"] = "Sie können es sich nicht leisten, diesen Gegenstand herzustellen!",
	["pl"] = "Nie możesz sobie pozwolić na wytworzenie tego przedmiotu!",
	["ru"] = "Вы не можете себе позволить создать этот предмет!",
	["es"] = "¡No puedes darte el lujo de fabricar este artículo!",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "Bu eşyayı üretmeye gücünüz yetmez!",
	["no"] = "",
}

CH_Mining.Config.Lang["Price to upgrade"] = {
    ["en"] = "Price to upgrade",
    ["fr"] = "Prix pour améliorer",
    ["da"] = "",
    ["de"] = "Preis für das Upgrade",
    ["pl"] = "Cena za ulepszenie",
    ["ru"] = "Цена за улучшение",
    ["es"] = "Precio para mejorar",
    ["pt"] = "",
	["cn"] = "",
    ["tr"] = "Yükseltme fiyatı",
    ["no"] = "",
}

CH_Mining.Config.Lang["You cannot afford to upgrade this skill!"] = {
    ["en"] = "You cannot afford to upgrade this skill!",
    ["fr"] = "Vous ne pouvez pas vous permettre d'améliorer cette compétence !",
    ["da"] = "",
    ["de"] = "Du kannst es dir nicht leisten, diese Fähigkeit zu verbessern!",
    ["pl"] = "Nie stać cię na ulepszenie tej umiejętności!",
    ["ru"] = "У вас нет средств на улучшение этого навыка!",
    ["es"] = "No puedes permitirte mejorar esta habilidad.",
    ["pt"] = "",
	["cn"] = "",
    ["tr"] = "Bu yeteneği yükseltmeye gücün yetmiyor!",
    ["no"] = "",
}

CH_Mining.Config.Lang["for upgrading this skill."] = {
    ["en"] = "for upgrading this skill.",
    ["fr"] = "pour améliorer cette compétence.",
    ["da"] = "",
    ["de"] = "für das Upgrade dieser Fähigkeit.",
    ["pl"] = "za ulepszenie tej umiejętności.",
    ["ru"] = "за улучшение этого навыка.",
    ["es"] = "para mejorar esta habilidad.",
	["pt"] = "",
	["cn"] = "",
    ["tr"] = "bu yeteneği yükseltmek için.",
    ["no"] = "",
}


--[[
CH_Mining.Config.Lang["for upgrading this skill."] = {
	["en"] = "for upgrading this skill.",
	["fr"] = "",
	["da"] = "",
	["de"] = "",
	["pl"] = "",
	["ru"] = "",
	["es"] = "",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "",
	["no"] = "",
}
--]]
--addons/ch_mining/lua/ch_mining/shared/config/ch_mining_config_skills.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/currencies/basewars.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/currencies/darkrp.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/currencies/santosrp.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/currencies/santosrp.lua:
CH_Mining.Currencies[ "santosrp" ] = {
	Name = "SantosRP Money",
	
	AddMoney = function( ply, amount )
		ply:AddMoney( amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:AddMoney( -amount )
	end,
	
	GetMoney = function( ply )
		return ply:GetMoney()
	end,
	
	CanAfford = function( ply, amount )
		return ply:CanAfford( amount )
	end,
	
	FormatMoney = function( amount )
		return "$" .. string.Comma( amount )
	end,
}
--addons/ch_mining/lua/ch_mining/client/ch_mining_skills.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_dashboard.lua:
--[[
	MINING MENU
--]]
function CH_Mining.DashboardMenu()
	local ply = LocalPlayer()
	
	local mineral1 = table.Random( CH_Mining.MineralPrices )
	local mineral2 = table.Random( CH_Mining.MineralPrices )
	local mineral3 = table.Random( CH_Mining.MineralPrices )
	local mineral4 = table.Random( CH_Mining.MineralPrices )
	
	local GUI_DashboardFrame = vgui.Create( "DFrame" )
	GUI_DashboardFrame:SetTitle( "" )
	GUI_DashboardFrame:SetSize( CH_Mining.ScrW * 0.6, CH_Mining.ScrH * 0.6875 )
	GUI_DashboardFrame:Center()
	GUI_DashboardFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mining.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.059 )
		
		-- Draw the top title.
		draw.SimpleText( CH_Mining.LangString( "Mining Dashboard" ), "CH_Mining_Font_Size10", w / 2, h * 0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	GUI_DashboardFrame:MakePopup()
	GUI_DashboardFrame:SetDraggable( false )
	GUI_DashboardFrame:ShowCloseButton( false )
	
	local GUI_CloseMenu = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_CloseMenu:SetPos( CH_Mining.ScrW * 0.582, CH_Mining.ScrH * 0.01 )
	GUI_CloseMenu:SetSize( 24, 24 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.Red or color_white )
		surface.SetMaterial( CH_Mining.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, CH_Mining.ScrW * 0.0125, CH_Mining.ScrH * 0.02223 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_DashboardFrame:Remove()
	end
	
	local GUI_DashboardFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_DashboardFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_DashboardFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.0475 )
	GUI_DashboardFrameBtn:SetText( "" )
	GUI_DashboardFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( CH_Mining.Colors.GMSBlue )
		surface.DrawRect( 0, 0, 2, h )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuDashboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Dashboard" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_DashboardFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.DashboardMenu()
	end

	local GUI_InventoryFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_InventoryFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_InventoryFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.095 )
	GUI_InventoryFrameBtn:SetText( "" )
	GUI_InventoryFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuInventory )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Inventory" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_InventoryFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.InventoryMenu()
	end
	
	local GUI_SkillsFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_SkillsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_SkillsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.1425 )
	GUI_SkillsFrameBtn:SetText( "" )
	GUI_SkillsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuSkills )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Skills" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_SkillsFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.SkillsMenu()
	end

	local GUI_CraftingFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_CraftingFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_CraftingFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.19 )
	GUI_CraftingFrameBtn:SetText( "" )
	GUI_CraftingFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuCrafting )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Crafting" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CraftingFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.CraftingMenu()
	end
	
	local GUI_TransactionsFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_TransactionsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_TransactionsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.2375 )
	GUI_TransactionsFrameBtn:SetText( "" )
	GUI_TransactionsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuTransactions )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Transactions" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TransactionsFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.TransactionsMenu()
	end
	
	local GUI_LeaderboardsFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_LeaderboardsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_LeaderboardsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.285 )
	GUI_LeaderboardsFrameBtn:SetText( "" )
	GUI_LeaderboardsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuLeaderboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Leaderboards" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LeaderboardsFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.LeaderboardsMenu( "MineralsMined" )
	end
	
	local GUI_StatsFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_StatsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_StatsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.3325 )
	GUI_StatsFrameBtn:SetText( "" )
	GUI_StatsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuStats )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Statistics" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_StatsFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.StatsMenu()
	end
	
	local GUI_OptionsFrameBtn = vgui.Create( "DButton", GUI_DashboardFrame )
	GUI_OptionsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_OptionsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.38 )
	GUI_OptionsFrameBtn:SetText( "" )
	GUI_OptionsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuOptions )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Options" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_OptionsFrameBtn.DoClick = function()
		GUI_DashboardFrame:Remove()
		
		CH_Mining.OptionsMenu()
	end
	
	-- The dashboard panel
	local GUI_DashboardPanel = vgui.Create( "DPanel", GUI_DashboardFrame )
	GUI_DashboardPanel:SetSize( CH_Mining.ScrW * 0.487, CH_Mining.ScrW * 0.356 )
	GUI_DashboardPanel:SetPos( CH_Mining.ScrW * 0.109, CH_Mining.ScrH * 0.0475 )
	GUI_DashboardPanel.Paint = function( self, w, h )
		-- Background
		surface.SetDrawColor( color_transparent )
		surface.DrawRect( 0, 0, w, h )
		
		-- Top box with info
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.215 )
		
		surface.SetFont( "CH_Mining_Font_Size14" )
		local welcome_back = CH_Mining.LangString( "Welcome back" ) ..", ".. ply:Nick()
		local x, y = surface.GetTextSize( welcome_back )

		draw.SimpleText( welcome_back, "CH_Mining_Font_Size14", w * 0.01, h * 0.04, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.WavingHand )
		surface.DrawTexturedRect( w * 0.01 + ( x + CH_Mining.ScrW * 0.005 ), h * 0.0225, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		-- Draw XP
		draw.SimpleText( CH_Mining.LangString( "You have" ) .." ".. ply:CH_Mining_GetXP() .." / ".. ply:CH_Mining_XPRequiredForLevel() .." XP ".. CH_Mining.LangString( "and are level" ) .." ".. ply:CH_Mining_GetLevel(), "CH_Mining_Font_Size10", w * 0.01, h * 0.1, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		local size_of_bar = w * 0.98
		local size_per_xp = size_of_bar / ply:CH_Mining_XPRequiredForLevel()
		local bar_lenght = size_per_xp * ply:CH_Mining_GetXP()
		
		draw.RoundedBox( 3, w * 0.01, h * 0.1425, bar_lenght, h * 0.055, CH_Mining.Colors.GMSBlue )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.StripesBG )
		surface.DrawTexturedRect( w * 0.01, h * 0.1425, size_of_bar, h * 0.055 )
		
		draw.SimpleText( math.Round( ply:CH_Mining_GetXP() / ply:CH_Mining_XPRequiredForLevel() * 100 ) .."%", "CH_Mining_Font_Size12", w / 2, h * 0.167, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		-- 1/4 random minerals
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, h * 0.226, w * 0.249, h * 0.213 )
		
		surface.SetDrawColor( CH_Mining.Rocks[ mineral1.Name ].Color )
		surface.SetMaterial( CH_Mining.Materials.Diamond )
		surface.DrawTexturedRect( w * 0.012, h * 0.242, CH_Mining.ScrW * 0.026045, CH_Mining.ScrH * 0.0463 )

		draw.SimpleText( CH_Mining.LangString( mineral1.Name ), "CH_Mining_Font_Size9", w * 0.075, h * 0.2595, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		draw.SimpleText( ply.CH_Mining_Inventory[ mineral1.Name ] .. " ".. CH_Mining.LangString( "minerals" ), "CH_Mining_Font_Size9", w * 0.075, h * 0.292, CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mining.FormatMoney( mineral1.Price ), "CH_Mining_Font_Size12", w * 0.015, h * 0.343, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		local price_change = mineral1.Change
		local price_change_color = CH_Mining.Colors.Green
		if price_change < 0 then
			price_change_color = CH_Mining.Colors.Red
		end
		local no_change = false
		surface.SetDrawColor( color_white )
		if price_change == 0 then
			no_change = true
		elseif price_change > 0 then
			surface.SetMaterial( CH_Mining.Materials.ArrowUpIcon )
		else
			surface.SetMaterial( CH_Mining.Materials.ArrowDownIcon )
		end
		if not no_change then
			surface.DrawTexturedRect( w * 0.015, h * 0.3865, CH_Mining.ScrW * 0.01044, CH_Mining.ScrH * 0.01854 )
			draw.SimpleText( price_change .."%", "CH_Mining_Font_Size10", w * 0.04, h * 0.398, price_change_color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		
		-- 2/4 random minerals
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( w * 0.2575, h * 0.226, w * 0.249, h * 0.213 )
		
		surface.SetDrawColor( CH_Mining.Rocks[ mineral2.Name ].Color )
		surface.SetMaterial( CH_Mining.Materials.Diamond )
		surface.DrawTexturedRect( w * 0.2675, h * 0.242, CH_Mining.ScrW * 0.026045, CH_Mining.ScrH * 0.0463 )
		
		draw.SimpleText( CH_Mining.LangString( mineral2.Name ), "CH_Mining_Font_Size9", w * 0.33, h * 0.2595, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		draw.SimpleText( ply.CH_Mining_Inventory[ mineral2.Name ] .. " ".. CH_Mining.LangString( "minerals" ), "CH_Mining_Font_Size9", w * 0.33, h * 0.292, CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mining.FormatMoney( mineral2.Price ), "CH_Mining_Font_Size12", w * 0.2695, h * 0.343, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		local price_change = mineral2.Change
		local price_change_color = CH_Mining.Colors.Green
		if price_change < 0 then
			price_change_color = CH_Mining.Colors.Red
		end
		local no_change = false
		surface.SetDrawColor( color_white )
		if price_change == 0 then
			no_change = true
		elseif price_change > 0 then
			surface.SetMaterial( CH_Mining.Materials.ArrowUpIcon )
		else
			surface.SetMaterial( CH_Mining.Materials.ArrowDownIcon )
		end
		if not no_change then
			surface.DrawTexturedRect( w * 0.2695, h * 0.3865, CH_Mining.ScrW * 0.01044, CH_Mining.ScrH * 0.01854 )
			draw.SimpleText( price_change .."%", "CH_Mining_Font_Size10", w * 0.2945, h * 0.398, price_change_color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		
		-- 3/4 random minerals
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( w * 0.514, h * 0.226, w * 0.249, h * 0.213 )
		
		surface.SetDrawColor( CH_Mining.Rocks[ mineral3.Name ].Color )
		surface.SetMaterial( CH_Mining.Materials.Diamond )
		surface.DrawTexturedRect( w * 0.525, h * 0.242, CH_Mining.ScrW * 0.026045, CH_Mining.ScrH * 0.0463 )
		
		draw.SimpleText( CH_Mining.LangString( mineral3.Name ), "CH_Mining_Font_Size9", w * 0.585, h * 0.2595, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		draw.SimpleText( ply.CH_Mining_Inventory[ mineral3.Name ] .. " ".. CH_Mining.LangString( "minerals" ), "CH_Mining_Font_Size9", w * 0.585, h * 0.292, CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mining.FormatMoney( mineral3.Price ), "CH_Mining_Font_Size12", w * 0.527, h * 0.343, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		local price_change = mineral3.Change
		local price_change_color = CH_Mining.Colors.Green
		if price_change < 0 then
			price_change_color = CH_Mining.Colors.Red
		end
		local no_change = false
		surface.SetDrawColor( color_white )
		if price_change == 0 then
			no_change = true
		elseif price_change > 0 then
			surface.SetMaterial( CH_Mining.Materials.ArrowUpIcon )
		else
			surface.SetMaterial( CH_Mining.Materials.ArrowDownIcon )
		end
		if not no_change then
			surface.DrawTexturedRect( w * 0.527, h * 0.3865, CH_Mining.ScrW * 0.01044, CH_Mining.ScrH * 0.01854 )
			draw.SimpleText( price_change .."%", "CH_Mining_Font_Size10", w * 0.552, h * 0.398, price_change_color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		
		-- 4/4 random minerals
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( w * 0.77, h * 0.226, w * 0.249, h * 0.213 )
		
		surface.SetDrawColor( CH_Mining.Rocks[ mineral4.Name ].Color )
		surface.SetMaterial( CH_Mining.Materials.Diamond )
		surface.DrawTexturedRect( w * 0.78, h * 0.242, CH_Mining.ScrW * 0.026045, CH_Mining.ScrH * 0.0463 )
		
		draw.SimpleText( CH_Mining.LangString( mineral4.Name ), "CH_Mining_Font_Size9", w * 0.8425, h * 0.2595, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		draw.SimpleText( ply.CH_Mining_Inventory[ mineral4.Name ] .. " ".. CH_Mining.LangString( "minerals" ), "CH_Mining_Font_Size9", w * 0.8425, h * 0.292, CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mining.FormatMoney( mineral4.Price ), "CH_Mining_Font_Size12", w * 0.782, h * 0.343, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		local price_change = mineral4.Change
		local price_change_color = CH_Mining.Colors.Green
		if price_change < 0 then
			price_change_color = CH_Mining.Colors.Red
		end
		local no_change = false
		surface.SetDrawColor( color_white )
		if price_change == 0 then
			no_change = true
		elseif price_change > 0 then
			surface.SetMaterial( CH_Mining.Materials.ArrowUpIcon )
		else
			surface.SetMaterial( CH_Mining.Materials.ArrowDownIcon )
		end
		if not no_change then
			surface.DrawTexturedRect( w * 0.782, h * 0.3865, CH_Mining.ScrW * 0.01044, CH_Mining.ScrH * 0.01854 )
			draw.SimpleText( price_change .."%", "CH_Mining_Font_Size10", w * 0.807, h * 0.398, price_change_color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
	end
end
--addons/executioner/lua/autorun/executioner_language.lua:
return gluapack()()
--addons/executioner_v2/lua/executioner_v2/executioner_v2_config.lua:
    --[[
        Executioner V2 Configuration file.
    --]]

    --[[
        Do not touch these tables.
    --]]
    TSS = TSS or {}
    TSS.Executioner = TSS.Executioner or {}
    TSS.Executioner.Config = TSS.Executioner.Config or {}
    TSS.Executioner.Bounties = TSS.Executioner.Bounties or {}
    TSS.Executioner.Store = TSS.Executioner.Store or {}
    TSS.Executioner.XP = TSS.Executioner.XP or {}

    --[[
        Start of configuration.
    --]]

    TSS.Executioner.Config.Developer_Mode = false
    TSS.Executioner.Config.Script_Name = "[Profesyonel Hitman]"
    TSS.Executioner.Config.Phone_Enabled = true
    -- How long in minutes until a target can have another Hit placed against them?
    TSS.Executioner.Config.Hit_Cooldown_Period = 60 * 5
    -- The command a user needs to type in to see their active hit
    TSS.Executioner.Config.Hit_Status_Command = "!hits"

    -- How much of a % does the customer get from the final Hit price when they tip?
    -- Example: Total hit payout is $10,000 at 10% the customer gets $1,000 back.
    -- Set to 0 to disable this feature.
    TSS.Executioner.Config.Tip_Bonus = 10

    -- How much XP does a Hitman earn per hit?
    TSS.Executioner.Config.XP_Gain = 90
    -- The level a Hitman starts at.
    TSS.Executioner.XP.Starting_Level = 1
    -- Their starting XP.
    TSS.Executioner.XP.Starting_XP = 0
    -- The XP forumla to follow.
    TSS.Executioner.XP.Level_Data = { 0, 600, 1200, 2500, 5000 }
    -- The max level, in this case 5
    TSS.Executioner.XP.Max_Level = #TSS.Executioner.XP.Level_Data

    -- What teams are classed as Hitmen?
    TSS.Executioner.Config.Hitmen = {
        [ "Profesyonel Hitman" ] = true
    }
    -- What jobs offer a bonus payout?
    TSS.Executioner.Config.Bonus_Payouts = {
        [ "Gangster" ] = 800
    }
    -- What teams can not have a hit placed against them?
    TSS.Executioner.Config.Restricted_Teams = {
        [ "Yetkili Görevde" ] = true
    }

    -- What usergroups can not have a hit placed against them?
    TSS.Executioner.Config.Restricted_Groups = {

    }

    -- Can a hit be placed on another Hitman?
    TSS.Executioner.Config.Hits_On_Hitmen = false

    -- What guns can be given as a random weapon?
    TSS.Executioner.Config.Mystery_Weapons = {
        "arccw_bo1_hk21",
        "arccw_bo1_aug",
        "arccw_bo1_famas",
        "arccw_bo1_car15"
    }

    -- How much each perk pays out on a successful hit.
    TSS.Executioner.Config.Perk_Payouts = {
        [ "BOOM_HEADSHOT" ] = 12750,
        [ "MYSTERY_ITEM" ] = 1750,
        [ "SPEEDRUN" ] = 4250,
        [ "SNEAKY_SNEAKY" ] = 3000,
        [ "COLD_BLOODED" ] = 2500,
        [ "ZERO_DAMAGE" ] = 3000
    }

    --[[
        Here you can define the perks in the perk shop.
        Please note without Lua knowledge you won't be able to create custom perks.
        If you don't know what you're doing, do not touch this section.
    --]]
    TSS.Executioner.Config.Hitman_Perks = {
        -- Seviye 1
        [ "increased_health" ] = { 
            name = "Artan Can", 
            icon = Material( "executioner_heart.png", "noclamp smooth" ), 
            description = "Bir suikast kabul edildiğinde mevcut canınızı %25 artırır", 
            level = 1, 
            price = 35000 
        },
        [ "increased_armor" ] = { 
            name = "Önce Güvenlik", 
            icon = Material( "executioner_no_damage.png", "noclamp smooth" ), 
            description = "Bir suikast kabul edildiğinde zırhınızı %100 olarak ayarlar", 
            level = 1, 
            price = 35000 
        },
        [ "tip_bonus" ] = { 
            name = "Beni Bahşişle", 
            icon = Material( "executioner_money.png", "noclamp smooth" ), 
            description = "Başarılı bir suikast sonrasında bahşiş ödemelerinden %5 bonus kazanırsınız", 
            level = 1, 
            price = 80000 
        },
        -- Seviye 3
        [ "bonus_xp" ] = { 
            name = "XP Güçlendirici", 
            icon = Material( "executioner_xp_up.png", "noclamp smooth" ), 
            description = "Hitman XP kazandıran her işlem %5 artırılır", 
            level = 3, 
            price = 120000 
        },
        [ "tick_tock" ] = { 
            name = "Zaman İşliyor", 
            icon = Material( "executioner_speedrun.png", "noclamp smooth" ), 
            description = "Hız Koşusu (Speedrun) kullanırken toplam süre sınırını 30 saniye artırır", 
            level = 3, 
            price = 120000 
        },
        [ "max_health" ] = { 
            name = "Önce Güvenlik", 
            icon = Material( "executioner_heart.png", "noclamp smooth" ), 
            description = "Bir suikast kabul edildiğinde mevcut canınızı %35 artırır", 
            level = 3, 
            price = 120000 
        },
        -- Seviye 5
        [ "income_boost" ] = { 
            name = "Parayı Severim", 
            icon = Material( "executioner_money.png", "noclamp smooth" ), 
            description = "Bir suikast tamamlandığında, %10 daha fazla ödül alırsınız.", 
            level = 5, 
            price = 150000 
        },
        [ "toughness" ] = { 
            name = "Çelikten Yapılmış", 
            icon = Material( "executioner_damage_reduction.png", "noclamp smooth" ), 
            description = "Hedefinizden aldığınız hasar %10 azaltılır", 
            level = 5, 
            price = 400000 
        },
        [ "redemption" ] = { 
            name = "Kurtuluş", 
            icon = Material( "executioner_redemption.png", "noclamp smooth" ), 
            description = "Hedefinize öldüğünüzde, ona hasar verme şansınız %5 olur", 
            level = 5, 
            price = 400000 
        },
        [ "gun_master" ] = { 
            name = "Usta Suikastçı", 
            icon = Material( "executioner_knowledge.png", "noclamp smooth" ), 
            description = "Tüm silahlarla hedefinize verdiğiniz hasar %5 artırılır", 
            level = 5, 
            price = 600000 
        }
    }
    

    -- How much does does it cost to place a Hit?
    TSS.Executioner.Config.Base_Hit_Price = 25000
    -- How long does the Hitman get to complete a hit in seconds?
    TSS.Executioner.Config.Speedrun_Time_Limit = 20

    -- Enables players to build up a Bounty
    TSS.Executioner.Bounties.Enabled = false
    -- How many kills are needed before a Bounty is set to active?
    TSS.Executioner.Bounties.Kills_Threshold = 3
    -- How much does a Bounty give when killed?
    TSS.Executioner.Bounties.Kills_Payout = 25750

    -- Enable the Store system for Hitmen?
    TSS.Executioner.Store.Enabled = true

    --[[
        entity_type is either "npc" or "entity"
        to get the spawn position, type getpos in your console,
        stand in the position you want the npc to spawn, and face the direction you want the npc to be.
        the output will be something like:
        -1717.822998 -1456.022705 18.751095;setang 1.100091 48.791618 0.000000
        Using this example, it should look like:
        pos = Vector( -1717.822998, -1456.022705, 18.751095 ), angle = Angle( 1.100091, 48.791618, 0.000000 )
    --]]

    TSS.Executioner.Config.Entities_To_Spawn = {
        [ "phone_box" ] = {
            entity_type = "entity",
            model = "models/props_trainstation/payphone001a.mdl",
            locations = {
                { pos = Vector( 621.954834, -655.094727, -160.968750 ), angle = Angle( 0.439998, -90.079666, -0.000000 ) },
            }
        },
        [ "hitman_perks_npc" ] = {
            entity_type = "npc",
            model = "models/Humans/Group01/male_03.mdl",
            locations = {
                { pos = Vector( 491.341034, -654.913818, -131.968750 ), angle = Angle( 0.439998, -90.079666, -0.000000 ) },
            }
        }
    }

    TSS.Executioner.Config.Language = {
        --> Genel 
        UI_ACCEPT_HIT = "Suikastı Kabul Et",
        UI_DENY_HIT = "Suikastı Reddet",
        NOT_ENOUGH_FUNDS = "Bu işlemi karşılayacak paranız yok",
        HIT_COMPLETED = "Suikast Tamamlandı",
        HIT_COMPLETED_LONG = " suikast isteğinizi tamamladı.", 
        UI_HIT_PAYOUT = "Ödeme: +$",
        HIT_ALREADY_ACTIVE = "Bu kullanıcıya karşı zaten bir suikast var.",
        -- Yerleştirme Menüsü
        UI_LOW_PLAYERS = "Suikast başlatmak için yeterli oyuncu çevrimiçi değil :(",
        UI_HELP_HEADER = "Temel Bilgiler",
        UI_HIT_BASICS = "Burada belirli bir hedefe karşı suikast başlatabilirsiniz. Bazı hedefler popülerliklerine ve zorluklarına göre daha fazla para gerektirebilir.\n\nBazı oyuncuların ödülleri olacak, bu da suikast fiyatını artıracak. Eğer Suikastçı onları öldürürse, ödülün bir kısmını alırsınız.\n\nSuikastçınıza bahşiş vermeyi seçebilirsiniz. Bunu yapmak, suikast başarılı olursa size ekstra para kazandırır.",
        UI_TIP_HITMAN  = "Suikastçınıza Bahşiş Verin",
        UI_PLACE_HIT = "Suikast Teklif Et",
        -- Onay Menüsünün Başlangıcı
        UI_HIT_OFFERED = "%s size bir hedef teklif etti..",
        UI_HITMAN_BASICS = "Bir müşteriden bir suikast teklifi aldınız. Bu suikastı kabul etmeyi veya reddetmeyi seçebilirsiniz.\n\nSuikastınızın zorluğunu ayarlamak için etkinleştirip/devre dışı bırakabileceğiniz modifikasyonlara sahipsiniz. Etkinleştirdiğiniz modifikasyonlara bağlı olarak ödemeniz de artırılacaktır.\n\nMüşteriler işiniz için size bahşiş verebilir, ancak ölmek size hiçbir ödül kazandırmaz.",
        UI_HIT_MODIFIERS = "Suikast Modifikasyonları",
        UI_PAYOUT_BREAKDOWN = "Ödeme Ayrıntıları",
        UI_BASE_HIT_PRICE = "Temel Suikast Fiyatı: +$",
        UI_CUSTOMER_TIP = "Müşteri Bahşişi: +$",
        UI_ACTIVE_MODIFIFERS = "Etkin Modifikasyonlarınız: +$",
        UI_TARGET_BOUNTY = "Hedefin Ödülü: +$",
        UI_JOB_BONUS = "Görev Ücreti: $",
        -- Suikastçı HUD
        UI_HIT_INFORMATION = "Suikast Bilgileri ",
        UI_HIT_TARGET = "Hedef: ",
        UI_HIT_OCCUPTATION = "Meslek: ",
        UI_HIT_DISTANCE = "Mesafe: ",
        UI_HIT_TIME_LEFT = "Kalan Süre: ",
        UI_HIT_SPEEDRUN_FAIL = "Hızlı Koşu Başarısız",
        -- Telefon Arayüzü
        UI_ERROR_NO_CONTRACTS = "Şu anda aktif sözleşme yok. :(",
        UI_ACTIVE_CONTRACTS = "Aktif Sözleşmeler",
        -- Yetenek Menüsü
        UI_CURRENT_LEVEL = "Şu anda seviye ",
        UI_PERK_CATEGORY = "Seviye %s Yetenekleri",
        UI_PERK_ACTIVE = "Aktif",
        UI_PERK_OWNED = "Bu yeteneğe sahipsiniz",
        UI_PERK_BUY = "Satın almak için Sol Tık",
        UI_PERK_ERROR = "Bu yeteneği henüz satın alamazsınız",
        -- Sunucu Taraflı Çevirinin Başlangıcı
        -- Ödül 
        SS_BOUNTY_ACTIVE = " aktif bir ödüle sahip.",
        SS_BOUNTY_CLAIMED = "%s, %s'nin ödülünü aldı.",
        SS_BOUNTY_COMPLETED = "Suikastçınız suikast talebinizi tamamladı. Ödül Bonusu: $",
        -- Modifikasyonlar
        SS_MODIFIERS_FAILED = "Modifikasyonlar başarısız oldu: ",
        SS_MODIFIERS_COMPLETED = "%s aktif modifikasyondan %s tanesini tamamladınız. Ödemeniz buna göre ayarlanacak.",
        SS_SPEEDRUN_FAILED = "Hızlı Koşu modifikasyonu başarısız oldu, bir dahaki sefere daha iyi şanslar.",
        -- Telefon
        SS_REQUEST_SUBMITTED = "Suikast talebiniz gönderildi.",
        SS_REQUEST_ALERT = " bir suikast talebi oluşturdu. Görmek için en yakın telefon kutusuna gidin.",
        SS_CUSTOMER_OFFLINE = "Müşteri artık sunucuya bağlı değil.",
        SS_HIT_TAKEN = "Bu sözleşme başka bir Suikastçı tarafından alındı.",
        SS_TARGET_OFFLINE = "Hedef artık sunucuya bağlı değil.",
        SS_HIT_ALREADY_ACTIVE = "Zaten bir suikast başlattınız, başka bir tane başlatamazsınız.",
        -- Yetenek Mağazası
        SS_PERK_NULL = "İstenen yetenek satın alınırken hata oluştu. Lütfen bir yöneticiye bildirin.",
        SS_NO_ACCESS = "Suikastçı değilsiniz, bu mağazayı kullanamazsınız.",
        SS_BOUGHT_PERK = "Bu yeteneği satın aldınız: ",
        -- XP
        SS_LEVEL_UP = "Seviye %s'ye ilerlediniz. %s XP'ye sahipsiniz ve bir sonraki seviyeye ulaşmak için %s XP'ye ihtiyacınız var.",
        -- Çekirdek
        SS_OFFER_SENT = "Talebiniz Suikastçıya gönderildi. Eğer reddederse, para iadesi alacaksınız.",
        SS_TAX_PERCENT_CUT = "Suikastçınıza bahşiş verdiğiniz için toplam ödemenin %s'si size geri verildi.",
        SS_USER_LEFT = " bağlantıyı kesti. Suikastınız iptal edildi.",
        SS_HITMAN_BUSY = " şu anda meşgul.",
        SS_USER_OFFLINE = "Bu kullanıcı artık sunucuya bağlı değil.",
        SS_HIT_AGAINST_USER_ACCEPTED = "%s'ye karşı suikast kabul edildi",
        SS_HIT_ACCEPTED_ALERT = " bir suikastı kabul etti. Dikkat edin, hedef siz olabilirsiniz!",
        SS_HIT_DECLINED = " suikastınızı reddetti. Para iadesi aldınız.",
        SS_HIT_COMPLETED = " suikastını tamamladı.",
        SS_HITMAN_WIN = " size karşı bir suikast vardı. Önce onları alt ettiniz. Tebrikler.",
        SS_HITMAN_FAIL = " aktif suikastında başarısız oldu ",
        HITMAN_SWITCHED_JOBS = "Suikastçı iş değiştirdi. Suikastınız iade edildi.",
        SELF_HITMAN_SWITCHED_JOBS = "İş değiştirdiniz. Suikastınız iade edildi.",
        TARGET_SWITCHED_JOBS_REFUND = "Hedefiniz bir Suikastçı olmak için iş değiştirdi. Suikastınız iade edildi.",
        TARGET_SWITCHED_JOBS_DESTROY = "Hedefiniz bir Suikastçı olmak için iş değiştirdi. Suikastınız iptal edildi.",
        CUSTOMER_SWITCH_JOBS = "Müşteri iş değiştirdi. Suikastınız iptal edildi.",
        SS_HITMEN_CANNOT_HIT = "Bir Suikastçı olarak suikast başlatamazsınız."
    }
    
--lua/autorun/franklin_playermodel.lua:
player_manager.AddValidModel( "Franklin", 				"models/GrandTheftAuto5/Franklin.mdl" )

list.Set( "PlayerOptionsModel",  "Franklin", 				"models/GrandTheftAuto5/Franklin.mdl" )

--lua/includes/modules/billyserrors.lua:
AddCSLuaFile()

local BillysErrors_Version = 1
if (BillysErrors) then
	if (BillysErrors.Version >= BillysErrors_Version) then
		return
	elseif (CLIENT and IsValid(BillysErrors.Menu)) then
		BillysErrors.Menu:Close()
	end
end

BillysErrors = {}
BillysErrors.Version = BillysErrors_Version

BillysErrors.IMPORTANCE_NOTICE  = 0
BillysErrors.IMPORTANCE_WARNING = 1
BillysErrors.IMPORTANCE_FATAL   = 2

BillysErrors.COLOR_RED        = Color(255,0,0)
BillysErrors.COLOR_YELLOW     = Color(255,255,0)
BillysErrors.COLOR_LIGHT_BLUE = Color(0,255,255)
BillysErrors.COLOR_WHITE      = Color(255,255,255)

local function UnvectorizeColor(col)
	return col.r, col.g, col.b, col.a
end

function BillysErrors:ProcessConsoleMsg(print_items, msg)
	if (msg.Importance == BillysErrors.IMPORTANCE_NOTICE) then
		table.insert(print_items, BillysErrors.COLOR_LIGHT_BLUE)
		table.insert(print_items, "[NOTICE] ")
	elseif (msg.Importance == BillysErrors.IMPORTANCE_WARNING) then
		table.insert(print_items, BillysErrors.COLOR_YELLOW)
		table.insert(print_items, "[WARNING] ")
	elseif (msg.Importance == BillysErrors.IMPORTANCE_FATAL) then
		table.insert(print_items, BillysErrors.COLOR_RED)
		table.insert(print_items, "[FATAL] ")
	end
	if (#msg.TextItems > 0) then
		local prev_color
		if (not IsColor(msg.TextItems[1])) then
			table.insert(print_items, BillysErrors.COLOR_WHITE)
			prev_color = BillysErrors.COLOR_WHITE
		else
			prev_color = msg.TextItems[1]
		end
		for _,item in ipairs(msg.TextItems) do
			if (type(item) == "string") then
				table.insert(print_items, item)
			elseif (IsColor(item)) then
				table.insert(print_items, item)
				prev_color = item
			elseif (type(item) == "table" and item.Link ~= nil) then
				table.insert(print_items, BillysErrors.COLOR_LIGHT_BLUE)
				table.insert(print_items, item.Link)
				table.insert(print_items, prev_color)
			end
		end
	end
end

if (CLIENT) then
	function BillysErrors:ProcessRichTextMsg(rich_text, msg)
		if (msg.Importance == BillysErrors.IMPORTANCE_NOTICE) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_LIGHT_BLUE))
			rich_text:AppendText("[NOTICE] ")
		elseif (msg.Importance == BillysErrors.IMPORTANCE_WARNING) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_YELLOW))
			rich_text:AppendText("[WARNING] ")
		elseif (msg.Importance == BillysErrors.IMPORTANCE_FATAL) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_RED))
			rich_text:AppendText("[FATAL] ")
		end
		if (#msg.TextItems > 0) then
			local prev_color
			if (not IsColor(msg.TextItems[1])) then
				rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_WHITE))
				prev_color = BillysErrors.COLOR_WHITE
			else
				prev_color = msg.TextItems[1]
			end
			for i,item in ipairs(msg.TextItems) do
				if (IsColor(item)) then
					rich_text:InsertColorChange(UnvectorizeColor(item))
					prev_color = item
				elseif (type(item) == "table") then
					rich_text:InsertColorChange(0,125,255,255)
					rich_text:InsertClickableTextStart("OpenURL " .. item.Link)
					rich_text:AppendText(item.Link)
					rich_text:InsertClickableTextEnd()
					rich_text:InsertColorChange(UnvectorizeColor(prev_color))
				else
					rich_text:AppendText(tostring(item))
				end
			end
		end
	end
end

if (SERVER) then
	util.AddNetworkString("billyserrors")

	BillysErrors.Addons = {}
	BillysErrors.HasMessage = false

	local ADDON = {}
	function ADDON:Init(options)
		self.Name = options.Name
		self.Color = options.Color
		self.Icon = options.Icon
		self.Messages = options.Messages or {}
	end
	function ADDON:AddMessage(importance, ...)
		local msg = {
			Importance = importance,
			TextItems = {...}
		}
		table.insert(self.Messages, msg)

		local print_items = {}
		BillysErrors:ProcessConsoleMsg(print_items, msg)
		table.insert(print_items, "\n")
		MsgC(unpack(print_items))

		BillysErrors.HasMessage = true
		BillysErrors:SendData()
	end

	function BillysErrors:AddAddon(options)
		local addon = table.Copy(ADDON)
		addon:Init(options)
		table.insert(BillysErrors.Addons, addon)
		return addon
	end

	function BillysErrors:SendData(ply)
		if (not BillysErrors.HasMessage) then return end
		local data = util.Compress(util.TableToJSON(BillysErrors.Addons))
		if (ply ~= nil) then
			if (not IsValid(ply) or not ply:IsSuperAdmin()) then return end
			net.Start("billyserrors")
				net.WriteData(data, #data)
			net.Send(ply)
		else
			for _,ply in ipairs(player.GetHumans()) do
				if (not ply:IsSuperAdmin()) then continue end
				net.Start("billyserrors")
					net.WriteData(data, #data)
				net.Send(ply)
			end
		end
	end
	net.Receive("billyserrors", function(_, ply)
		BillysErrors:SendData(ply)
	end)
else
	function BillysErrors:OpenMenu()
		if (IsValid(BillysErrors.Menu)) then
			BillysErrors.Menu.Categories:Remove()
			BillysErrors.Menu.Categories = vgui.Create("bVGUI.Categories", BillysErrors.Menu.Content)
			BillysErrors.Menu.Categories:Dock(LEFT)
			BillysErrors.Menu.Categories:SetWide(175)
			BillysErrors.Menu.Categories:MoveToBefore(BillysErrors.Menu.Header)

			BillysErrors.Menu:LoadMessages(true)
			return
		end

		BillysErrors.Menu = vgui.Create("bVGUI.Frame")
		BillysErrors.Menu:SetSize(600,500)
		BillysErrors.Menu:SetMinimumSize(600,500)
		BillysErrors.Menu:Center()
		BillysErrors.Menu:SetTitle("BillysErrors")
		BillysErrors.Menu:MakePopup()
		function BillysErrors.Menu:OnClose()
			hook.Remove("SetupMove", "BillysErrors:ScrollRichText")
		end

		BillysErrors.Menu.Content = vgui.Create("bVGUI.BlankPanel", BillysErrors.Menu)
		BillysErrors.Menu.Content:Dock(FILL)
		function BillysErrors.Menu.Content:PaintOver(w,h)
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
			surface.DrawTexturedRect(175,0,10,h)
		end

		BillysErrors.Menu.Categories = vgui.Create("bVGUI.Categories", BillysErrors.Menu.Content)
		BillysErrors.Menu.Categories:Dock(LEFT)
		BillysErrors.Menu.Categories:SetWide(175)

		BillysErrors.Menu.Header = vgui.Create("bVGUI.Header", BillysErrors.Menu.Content)
		BillysErrors.Menu.Header:Dock(TOP)
		BillysErrors.Menu.Header:SetText("Help")
		BillysErrors.Menu.Header:SetColor(Color(76,216,76))
		BillysErrors.Menu.Header:SetIcon("icon16/help.png")

		local function CreateRichText()
			if (IsValid(BillysErrors.Menu.Text)) then
				BillysErrors.Menu.Text:Remove()
			end
			BillysErrors.Menu.Text = vgui.Create("RichText", BillysErrors.Menu.Content)
			BillysErrors.Menu.Text:Dock(FILL)
			BillysErrors.Menu.Text:DockMargin(10,10,10,10)
			BillysErrors.Menu.Text:SetVerticalScrollbarEnabled(true)
			BillysErrors.Menu.Text:InsertColorChange(255,255,255,255)

			local font_name = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14)
			function BillysErrors.Menu.Text:PerformLayout()
				self:SetFontInternal(font_name)
			end

			function BillysErrors.Menu.Text:ActionSignal(signalName, signalValue)
				if (signalName == "TextClicked" and signalValue:sub(1,8) == "OpenURL ") then
					if (GAS) then
						GAS:OpenURL(signalValue:sub(9))
					else
						gui.OpenURL(signalValue:sub(9))
					end
				end
			end
		end

		function BillysErrors.Menu:LoadMessages(is_refresh)
			BillysErrors.Menu.Categories:Clear()

			local function ShowHelpText()
				if (not is_refresh) then
					BillysErrors.LastSelectedAddon = nil
				end

				CreateRichText()
				BillysErrors.Menu.Text:InsertColorChange(255,0,0,255)
				BillysErrors.Menu.Text:AppendText("(This window is only visible to superadmins)\n\n")
				BillysErrors.Menu.Text:InsertColorChange(255,255,255,255)
				BillysErrors.Menu.Text:AppendText(([[

					Uh oh! Something's wrong with an addon you have installed to your server.

					Click the addon's name on the left to see what's wrong, and how to fix the problem.

				]]):gsub("\t", ""):gsub("^%s",""):gsub("%s$",""))

				BillysErrors.Menu.Header:SetText("Help")
				BillysErrors.Menu.Header:SetColor(Color(76,216,76))
				BillysErrors.Menu.Header:SetIcon("icon16/help.png")
			end
			BillysErrors.Menu.Categories:AddItem("Help", ShowHelpText, Color(76,216,76)):SetActive(not is_refresh or BillysErrors.LastSelectedAddon == nil)

			ShowHelpText()

			local category_col = Color(216,76,76)
			if (BillysErrors.Addons[1] ~= nil and BillysErrors.Addons[1].Color ~= nil) then
				category_col = BillysErrors.Addons[1].Color
			end
			local category = BillysErrors.Menu.Categories:AddCategory("Addons", category_col)
			for _,addon in ipairs(BillysErrors.Addons) do
				if (#addon.Messages == 0) then continue end
				local item = category:AddItem(addon.Name, function()

					BillysErrors.LastSelectedAddon = addon.Name

					BillysErrors.Menu.Header:SetText(addon.Name)
					BillysErrors.Menu.Header:SetColor(addon.Color or Color(0,125,255))
					BillysErrors.Menu.Header:SetIcon(addon.Icon or false)

					CreateRichText()
					for i,msg in ipairs(addon.Messages) do
						local print_items = {}
						BillysErrors:ProcessConsoleMsg(print_items, msg)
						table.insert(print_items, "\n\n")
						MsgC(unpack(print_items))

						BillysErrors:ProcessRichTextMsg(BillysErrors.Menu.Text, msg)
						if (i ~= #msg) then BillysErrors.Menu.Text:AppendText("\n\n") end
					end

				end, addon.Color, addon.Icon)
				if (BillysErrors.LastSelectedAddon == addon.Name) then
					item:OnMouseReleased(MOUSE_LEFT)
				end
			end
		end
		BillysErrors.Menu:LoadMessages()

		BillysErrors.Menu:EnableUserResize()
		surface.PlaySound("gmodadminsuite/oof.mp3")
	end

	net.Receive("billyserrors", function(l)
		BillysErrors.Addons = util.JSONToTable(util.Decompress(net.ReadData(l)))
		BillysErrors:OpenMenu()
	end)

	if (BillysErrors_InitPostEntity) then
		net.Start("billyserrors")
		net.SendToServer()
	else
		hook.Add("InitPostEntity", "BillysErrors:InitPostEntity", function()
			BillysErrors_InitPostEntity = true

			net.Start("billyserrors")
			net.SendToServer()

			hook.Remove("InitPostEntity", "BillysErrors:InitPostEntity")
		end)
	end
end
--lua/gmodadminsuite/thirdparty/von.lua:
--[[	vON 1.3.4

	Copyright 2012-2014 Alexandru-Mihai Maftei
					aka Vercas

	GitHub Repository:
		https://github.com/vercas/vON

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author (Vercas) if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above obligations still apply.
	If you make any interesting modifications, try forking the GitHub repository instead.

	Instead of copying this code over for sharing, rather use the link:
		https://github.com/vercas/vON/blob/master/von.lua

	The author may not be held responsible for any damage or losses directly or indirectly caused by
	the use of vON.

	If you disagree with the above, don't use the code.

-----------------------------------------------------------------------------------------------------------------------------
	
	Thanks to the following people for their contribution:
		-	Divran						Suggested improvements for making the code quicker.
										Suggested an excellent new way of deserializing strings.
										Lead me to finding an extreme flaw in string parsing.
		-	pennerlord					Provided some performance tests to help me improve the code.
		-	Chessnut					Reported bug with handling of nil values when deserializing array components.

		-	People who contributed on the GitHub repository by reporting bugs, posting fixes, etc.

-----------------------------------------------------------------------------------------------------------------------------
	
	The vanilla types supported in this release of vON are:
		-	table
		-	number
		-	boolean
		-	string
		-	nil

	The Garry's Mod-specific types supported in this release are:
		-	Vector
		-	Angle
		+	Entities:
			-	Entity
			-	Vehicle
			-	Weapon
			-	NPC
			-	Player
			-	NextBot

	These are the types one would normally serialize.

-----------------------------------------------------------------------------------------------------------------------------
	
	New in this version:
		-	Fixed addition of extra entity types. I messed up really badly.
--]]



local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable
local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next



--[[    This section contains localized functions which (de)serialize
        variables according to the types found.                          ]]



--	This is kept away from the table for speed.
function d_findVariable(s, i, len, lastType, jobstate)
	local i, c, typeRead, val = i or 1

	--	Keep looping through the string.
	while true do
		--	Stop at the end. Throw an error. This function MUST NOT meet the end!
		if i > len then
			error("vON: Reached end of string, cannot form proper variable.")
		end

		--	Cache the character. Nobody wants to look for the same character ten times.
		c = sub(s, i, i)

		--	If it just read a type definition, then a variable HAS to come after it.
		if typeRead then
			--	Attempt to deserialize a variable of the freshly read type.
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			--	Return the value read, the index of the last processed character, and the type of the last read variable.
			return val, i, lastType

		--	@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.
		elseif c == "@" then
			return nil, i, lastType

		--	$ means a table reference will follow - a number basically.
		elseif c == "$" then
			lastType = "table_reference"
			typeRead = true

		--	n means a number will follow. Base 10... :C
		elseif c == "n" then
			lastType = "number"
			typeRead = true

		--	b means boolean flags.
		elseif c == "b" then
			lastType = "boolean"
			typeRead = true

		--	' means the start of a string.
		elseif c == "'" then
			lastType = "string"
			typeRead = true

		--	" means the start of a string prior to version 1.2.0.
		elseif c == "\"" then
			lastType = "oldstring"
			typeRead = true

		--	{ means the start of a table!
		elseif c == "{" then
			lastType = "table"
			typeRead = true


--[[    Garry's Mod types go here    ]]

		--	e means an entity ID will follow.
		elseif c == "e" then
			lastType = "Entity"
			typeRead = true
--[[
		--	c means a vehicle ID will follow.
		elseif c == "c" then
			lastType = "Vehicle"
			typeRead = true

		--	w means a weapon entity ID will follow.
		elseif c == "w" then
			lastType = "Weapon"
			typeRead = true

		--	x means a NPC ID will follow.
		elseif c == "x" then
			lastType = "NPC"
			typeRead = true
--]]
		--	p means a player ID will follow.
		--	Kept for backwards compatibility.
		elseif c == "p" then
			lastType = "Entity"
			typeRead = true

		--	v means a vector will follow. 3 numbers.
		elseif c == "v" then
			lastType = "Vector"
			typeRead = true

		--	a means an Euler angle will follow. 3 numbers.
		elseif c == "a" then
			lastType = "Angle"
			typeRead = true

--[[    Garry's Mod types end here    ]]


		--	If no type has been found, attempt to deserialize the last type read.
		elseif lastType then
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			return val, i, lastType

		--	This will occur if the very first character in the vON code is wrong.
		else
			error("vON: Malformed data... Can't find a proper type definition. Char#" .. i .. ":" .. c)
		end

		--	Move the pointer one step forward.
		i = i + 1
	end
end

--	This is kept away from the table for speed.
--	Yeah, ton of parameters.
function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)
	local tp = type(data)

	if jobstate[1] and jobstate[2][data] then
		tp = "table_reference"
	end

	--	Basically, if the type changes.
	if lastType ~= tp then
		--	Remember the new type. Caching the type is useless.
		lastType = tp

		if _serialize[lastType] then
			--	Return the serialized data and the (new) last type.
			--	The second argument, which is true now, means that the data type was just changed.
			return _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType
		else
			error("vON: No serializer defined for type \"" .. lastType .. "\"!")
		end
	end

	--	Otherwise, simply serialize the data.
	return _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType
end



--[[    This section contains the tables with the functions necessary
        for decoding basic Lua data types.                               ]]



_deserialize = {
--	Well, tables are very loose...
--	The first table doesn't have to begin and end with { and }.
	["table"] = function(s, i, len, unnecessaryEnd, jobstate)
		local ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1
		--	Locals, locals, locals, locals, locals, locals, locals, locals and locals.

		if sub(s, i, i) == "#" then
			local e = find(s, "#", i + 2, true)

			if e then
				local id = tonumber(sub(s, i + 1, e - 1))

				if id then
					if jobstate[1][id] and not jobstate[2] then
						error("vON: There already is a table of reference #" .. id .. "! Missing an option maybe?")
					end

					jobstate[1][id] = ret

					i = e + 1
				else
					error("vON: Malformed table! Reference ID starting at char #" .. i .. " doesn't contain a number!")
				end
			else
				error("vON: Malformed table! Cannot find end of reference ID start at char #" .. i .. "!")
			end
		end

		--	Keep looping.
		while true do
			--	Until it meets the end.
			if i > len then
				--	Yeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.
				if unnecessaryEnd then
					return ret, i

				--	Otherwise, the data has to be damaged.
				else
					error("vON: Reached end of string, incomplete table definition.")
				end
			end

			--	Cache the character.
			c = sub(s, i, i)
			--print(i, "table char:", c, tostring(unnecessaryEnd))

			--	If it's the end of a table definition, return.
			if c == "}" then
				return ret, i

			--	If it's the component separator, switch to key:value pairs.
			elseif c == "~" then
				numeric = false

			elseif c == ";" then
				--	Lol, nothing!
				--	Remenant from numbers, for faster parsing.

			--	OK, now, if it's on the numeric component, simply add everything encountered.
			elseif numeric then
				--	Find a variable and it's value
				val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				--	Add it to the table.
				ret[ind] = val

				ind = ind + 1

			--	Otherwise, if it's the key:value component...
			else
				--	If a value is expected...
				if expectValue then
					--	Read it.
					val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
					--	Add it?
					ret[key] = val
					--	Clean up.
					expectValue, key = false, nil

				--	If it's the separator...
				elseif c == ":" then
					--	Expect a value next.
					expectValue = true

				--	But, if there's a key read already...
				elseif key then
					--	Then this is malformed.
					error("vON: Malformed table... Two keys declared successively? Char#" .. i .. ":" .. c)

				--	Otherwise the key will be read.
				else
					--	I love multi-return and multi-assignement.
					key, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				end
			end

			i = i + 1
		end

		return nil, i
	end,

--	Just a number which points to a table.
	["table_reference"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1
		--	Locals, locals, locals, locals

		a = find(s, "[;:}~]", i)

		if a then
			local n = tonumber(sub(s, i, a - 1))

			if n then
				return jobstate[1][n] or error("vON: Table reference does not point to a (yet) known table!"), a - 1
			else
				error("vON: Table reference definition does not contain a valid number!")
			end
		end

		--	Using %D breaks identification of negative numbers. :(

		error("vON: Number definition started... Found no end.")
	end,


--	Numbers are weakly defined.
--	The declaration is not very explicit. It'll do it's best to parse the number.
--	Has various endings: \n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.
	["number"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1
		--	Locals, locals, locals, locals

		a = find(s, "[;:}~]", i)

		if a then
			return tonumber(sub(s, i, a - 1)) or error("vON: Number definition does not contain a valid number!"), a - 1
		end

		--	Using %D breaks identification of negative numbers. :(

		error("vON: Number definition started... Found no end.")
	end,


--	A boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.
--	Any other attempt at boolean declaration will result in a failure.
	["boolean"] = function(s, i, len, unnecessaryEnd, jobstate)
		local c = sub(s,i,i)
		--	Only one character is needed.

		--	If it's 1, then it's true
		if c == "1" then
			return true, i

		--	If it's 0, then it's false.
		elseif c == "0" then
			return false, i
		end

		--	Any other supposely "boolean" is just a sign of malformed data.
		error("vON: Invalid value on boolean type... Char#" .. i .. ": " .. c)
	end,


--	Strings prior to 1.2.0
	["oldstring"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1
		--	Locals, locals, locals, locals

		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 2), a
				end
			else
				error("vON: Old string definition started... Found no end.")
			end
		end
	end,

--	Strings after 1.2.0
	["string"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1
		--	Locals, locals, locals, locals

		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 1), a
				end
			else
				error("vON: String definition started... Found no end.")
			end
		end
	end,
}



_serialize = {
--	Uh. Nothing to comment.
--	Ton of parameters.
--	Makes stuff faster than simply passing it around in locals.
--	table.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.
	["table"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--print(string.format("data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))

		local result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0
		--	Locals, locals, locals, locals, locals, locals, locals, locals, locals and locals.

		--	First thing to be done is separate the numeric and key:value components of the given table in two tables.
		--	pairs(data) is slower than next, data as far as my tests tell me.
		for k, v in next, data do
			--	Skip the numeric keyz.
			if type(k) ~= "number" or k < 1 or k > len or (k % 1 ~= 0) then	--	k % 1 == 0 is, as proven by personal benchmarks,
				keyvals[#keyvals + 1] = k									--	the quickest way to check if a number is an integer.
			end																--	k % 1 ~= 0 is the fastest way to check if a number
		end																	--	is NOT an integer. > is proven slower.

		keyvalsLen = #keyvals

		--	Main chunk - no initial character.
		if not first then
			result[#result + 1] = "{"
		end

		if jobstate[1] and jobstate[1][data] then
			if jobstate[2][data] then
				error("vON: Table #" .. jobstate[1][data] .. " written twice..?")
			end

			result[#result + 1] = "#"
			result[#result + 1] = jobstate[1][data]
			result[#result + 1] = "#"

			jobstate[2][data] = true
		end

		--	Add numeric values.
		if len > 0 then
			for i = 1, len do
				val, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)
				result[#result + 1] = val
			end
		end

		--	If there are key:value pairs.
		if keyvalsLen > 0 then
			--	Insert delimiter.
			result[#result + 1] = "~"

			--	Insert key:value pairs.
			for _i = 1, keyvalsLen do
				keyvalsProgress = keyvalsProgress + 1

				val, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)

				result[#result + 1] = val..":"

				val, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)
				
				result[#result + 1] = val
			end
		end

		--	Main chunk needs no ending character.
		if not first then
			result[#result + 1] = "}"
		end

		return concat(result)
	end,

--	Number which points to table.
	["table_reference"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		data = jobstate[1][data]

		--	If a number hasn't been written before, add the type prefix.
		if mustInitiate then
			if isKey or isLast then
				return "$"..data
			else
				return "$"..data..";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data..";"
		end
	end,


--	Normal concatenations is a lot faster with small strings than table.concat
--	Also, not so branched-ish.
	["number"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--	If a number hasn't been written before, add the type prefix.
		if mustInitiate then
			if isKey or isLast then
				return "n"..data
			else
				return "n"..data..";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data..";"
		end
	end,


--	I hope gsub is fast enough.
	["string"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		if sub(data, #data, #data) == "\\" then	--	Hah, old strings fix this best.
			return "\"" .. gsub(data, "\"", "\\\"") .. "v\""
		end

		return "'" .. gsub(data, "\"", "\\\"") .. "\""
	end,


--	Fastest.
	["boolean"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--	Prefix if we must.
		if mustInitiate then
			if data then
				return "b1"
			else
				return "b0"
			end
		end

		if data then
			return "1"
		else
			return "0"
		end
	end,


--	Fastest.
	["nil"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		return "@"
	end,
}



--[[    This section handles additions necessary for Garry's Mod.    ]]



if gmod then	--	Luckily, a specific table named after the game is present in Garry's Mod.
	local Entity = Entity



	local extra_deserialize = {
--	Entities are stored simply by the ID. They're meant to be transfered, not stored anyway.
--	Exactly like a number definition, except it begins with "e".
		["Entity"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a = i or 1
			--	Locals, locals, locals, locals

			a = find(s, "[;:}~]", i)

			if a then
				return Entity(tonumber(sub(s, i, a - 1))), a - 1
			end

			error("vON: Entity ID definition started... Found no end.")
		end,


--	A pair of 3 numbers separated by a comma (,).
		["Vector"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, x, y, z = i or 1
			--	Locals, locals, locals, locals

			a = find(s, ",", i)

			if a then
				x = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				z = tonumber(sub(s, i, a - 1))
			end

			if x and y and z then
				return Vector(x, y, z), a - 1
			end

			error("vON: Vector definition started... Found no end.")
		end,


--	A pair of 3 numbers separated by a comma (,).
		["Angle"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, p, y, r = i or 1
			--	Locals, locals, locals, locals

			a = find(s, ",", i)

			if a then
				p = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				r = tonumber(sub(s, i, a - 1))
			end

			if p and y and r then
				return Angle(p, y, r), a - 1
			end

			error("vON: Angle definition started... Found no end.")
		end,
	}

	local extra_serialize = {
--	Same as numbers, except they start with "e" instead of "n".
		["Entity"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			data = data:EntIndex()

			if mustInitiate then
				if isKey or isLast then
					return "e"..data
				else
					return "e"..data..";"
				end
			end

			if isKey or isLast then
				return data
			else
				return data..";"
			end
		end,


--	3 numbers separated by a comma.
		["Vector"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "v"..data.x..","..data.y..","..data.z
				else
					return "v"..data.x..","..data.y..","..data.z..";"
				end
			end

			if isKey or isLast then
				return data.x..","..data.y..","..data.z
			else
				return data.x..","..data.y..","..data.z..";"
			end
		end,


--	3 numbers separated by a comma.
		["Angle"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "a"..data.p..","..data.y..","..data.r
				else
					return "a"..data.p..","..data.y..","..data.r..";"
				end
			end

			if isKey or isLast then
				return data.p..","..data.y..","..data.r
			else
				return data.p..","..data.y..","..data.r..";"
			end
		end,
	}

	for k, v in pairs(extra_serialize) do
		_serialize[k] = v
	end

	for k, v in pairs(extra_deserialize) do
		_deserialize[k] = v
	end

	local extraEntityTypes = { "Vehicle", "Weapon", "NPC", "Player", "NextBot" }

	for i = 1, #extraEntityTypes do
		_serialize[extraEntityTypes[i]] = _serialize.Entity
	end
end



--[[    This section exposes the functions of the library.    ]]



local function checkTableForRecursion(tab, checked, assoc)
	local id = checked.ID

	if not checked[tab] and not assoc[tab] then
		assoc[tab] = id
		checked.ID = id + 1
	else
		checked[tab] = true
	end

	for k, v in pairs(tab) do
		if type(k) == "table" and not checked[k] then
			checkTableForRecursion(k, checked, assoc)
		end
		
		if type(v) == "table" and not checked[v] then
			checkTableForRecursion(v, checked, assoc)
		end
	end
end



local _s_table = _serialize.table
local _d_table = _deserialize.table

_d_meta = {
	__call = function(self, str, allowIdRewriting)
		if type(str) == "string" then
			return _d_table(str, nil, #str, true, {{}, allowIdRewriting})
		end

		error("vON: You must deserialize a string, not a "..type(str))
	end
}
_s_meta = {
	__call = function(self, data, checkRecursion)
		if type(data) == "table" then
			if checkRecursion then
				local assoc, checked = {}, {ID = 1}

				checkTableForRecursion(data, checked, assoc)

				return _s_table(data, nil, nil, nil, nil, true, {assoc, {}})
			end

			return _s_table(data, nil, nil, nil, nil, true, {false})
		end

		error("vON: You must serialize a table, not a "..type(data))
	end
}



von = {
	version = "1.3.4",
	versionNumber = 1003004,	--	Reserving 3 digits per version component.

	deserialize = setmetatable(_deserialize,_d_meta),
	serialize = setmetatable(_serialize,_s_meta)
}



return von
--lua/gmodadminsuite/modules/fpsbooster/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            module_name = "FPS提升器",

            fps_booster = "FPS提升器",
            never_show_again = "不再显示",
            never_show_again_tip = "您将失去此菜单的好处！将来可以在控制台中输入“gmodadminsuite fpsbooster”来打开此菜单。",

            show_fps = "显示FPS",
            multicore_rendering = "启用多核渲染",
            multicore_rendering_help = "这是GMod的一个实验性功能，通过使用多个CPU核心渲染帧来提升FPS。",
            hardware_acceleration = "启用硬件加速",
            shadows = "禁用阴影",
            disable_skybox = "禁用天空盒",
            sprays = "禁用玩家喷漆",
            gibs = "禁用碎片",
            gibs_help = "“碎片”是可以从尸体和布娃娃上飞出的粒子和物体。",
        }
    end
}

--lua/gmodadminsuite/modules/commands/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Command Manager",
	Category = GAS.MODULE_CATEGORY_UTILITIES,
	OperatorOnly = true,
	Wiki = "https://gmodsto.re/gmodadminsuite-commands-wiki",
	Icon = "icon16/script_gear.png",
}
--lua/gmodadminsuite/modules/secondaryusergroups/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Secondary Usergroups",
	Category = GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT,
	Wiki = "https://gmodsto.re/gmodadminsuite-secondaryusergroups-wiki",
	Icon = "icon16/group.png",
}
--addons/gprofiler/lua/gprofiler/sh_config.lua:
-- 1.6.0 | c779571d-0ec5-4d87-830d-1246d79e19ef | 4c6780542bbfaecf703b0192b6184209457cd4e6f156066f4d336d68 | 76561199225769214

GProfiler.Version = "1.6.0"
GProfiler.Config.VersionCheck = true -- Should we check for updates on gmodstore?

-- Available languages: english, french, german, dutch, russian, italian
GProfiler.Config.Language = "english"

-- Enable/Disable Log Types
GProfiler.Config.LOG_DEBUG = true
GProfiler.Config.LOG_INFO = true
GProfiler.Config.LOG_WARNING = true
GProfiler.Config.LOG_ERROR = true
GProfiler.Config.LOG_LOAD = false

GProfiler.Config.AllowedSteamIDs = { -- SteamIDs that can access GProfiler
	["76561199225769214"] = true
}

if CLIENT then
	GProfiler.MenuColors = {
		White = Color(255, 255, 255),
		Blue = Color(91, 118, 255),

		-- Menu
		Background = Color(8, 27, 48, 220),
		OpaqueBlack = Color(0, 0, 0, 200),
		TopBarSeparator = Color(91, 118, 255, 10),
		HeaderSeparator = Color(91, 118, 255, 50),
		RealmSelectorBackground = Color(38, 57, 78),
		RealmSelectorOutline = Color(88, 107, 138),
		ActiveProfile = Color(10, 155, 10),

		-- Lists
		DListBackground = Color(18, 37, 58),
		DListColumnBackground = Color(68, 87, 108),
		DListColumnOutline = Color(88, 107, 138),
		DListRowBackground = Color(48, 67, 88),
		DListRowHover = Color(68, 87, 108),
		DListRowTextColor = Color(235, 235, 235),
		DListRowSelected = Color(91, 118, 255, 50),

		-- Scrollbars
		ScrollBar = Color(38, 57, 78),
		ScrollBarGrip = Color(68, 87, 108),
		ScrollBarGripOutline = Color(88, 107, 138),

		-- Buttons
		ButtonOutline = Color(88, 107, 138),
		ButtonBackground = Color(38, 57, 78),
		ButtonHover = Color(58, 77, 98),

		CodeBackground = Color(45, 45, 45)
	}

	GProfiler.Config.MenuCommands = {
		Chat = '!gprofiler', -- False to disable
		Console = 'gprofiler', -- False to disable
		Closekey = KEY_F4 -- False to disable
	}
else
	local URL = "https://fastdl.zarpgaming.com/callum/gprofiler/version.txt"
	if GProfiler.Config.VersionCheck then
		hook.Add("PlayerInitialSpawn", "GProfiler_VersionCheck", function()
			http.Fetch(URL, function(body, _, __, code)
				if code == 200 and body ~= GProfiler.Version then
					GProfiler.Log(string.format("You are running an outdated version of GProfiler! (Current: %s, Latest: %s)", GProfiler.Version, body), 3)
				end
			end)
			hook.Remove("PlayerInitialSpawn", "GProfiler_VersionCheck")
		end)
	end
end

--addons/gprofiler/lua/gprofiler/cl_language.lua:
GProfiler.Language = GProfiler.Language or {}
GProfiler.Language.Langs = GProfiler.Language.Langs or {}

function GProfiler.Language:AddLanguage(lang, cb)
	GProfiler.Language.Langs[lang] = {}

	local LangGroup = {}

	function LangGroup:AddPhrase(key, phrase)
		self[key] = phrase
	end

	function LangGroup:Save()
		GProfiler.Language.Langs[lang] = self
	end

	cb(LangGroup)
end

function GProfiler.Language.GetPhrase(key)
	local Lang = GProfiler.Language.Langs[GProfiler.Config.Language]
	if not Lang then Lang = GProfiler.Language.Langs["english"] end

	return Lang[key] or (GProfiler.Config.Language ~= "english" and GProfiler.Language.Langs["english"][key] or key) or key
end

GProfiler.Language:AddLanguage("english", function(Lang)
	-- General
	Lang:AddPhrase("profiler_results", "Profiler Results")
	Lang:AddPhrase("profiler_start", "Start Profiling")
	Lang:AddPhrase("profiler_stop", "Stop Profiling")
	Lang:AddPhrase("realm_client", "Client")
	Lang:AddPhrase("realm_server", "Server")
	Lang:AddPhrase("copy", "Copy")

	-- Column Names
	Lang:AddPhrase("file", "File")
	Lang:AddPhrase("name", "Name")
	Lang:AddPhrase("type", "Type")
	Lang:AddPhrase("lines", "Lines")
	Lang:AddPhrase("realm", "Realm")
	Lang:AddPhrase("focus", "Focus")
	Lang:AddPhrase("remove", "Remove")
	Lang:AddPhrase("function", "Function")
	Lang:AddPhrase("receivers", "Receivers")
	Lang:AddPhrase("receiver", "Receiver")
	Lang:AddPhrase("total_time", "Total Time")
	Lang:AddPhrase("times_called", "Times Called")
	Lang:AddPhrase("times_run", "Times Run")
	Lang:AddPhrase("times_received", "Times Received")
	Lang:AddPhrase("largest_size", "Largest Size")
	Lang:AddPhrase("total_size", "Total Size")
	Lang:AddPhrase("delay", "Delay")
	Lang:AddPhrase("timer", "Timer")
	Lang:AddPhrase("command", "Command")
	Lang:AddPhrase("average_time", "Average Time")
	Lang:AddPhrase("longest_time", "Longest Time")
	Lang:AddPhrase("entity", "Entity")
	Lang:AddPhrase("variable", "Variable")
	Lang:AddPhrase("times_updated", "Times Updated")
	Lang:AddPhrase("current_value", "Current Value")

	-- Profiler Specific
	Lang:AddPhrase("timer_function", "Timer Function")
	Lang:AddPhrase("timer_select", "Select a timer to view its code")
	Lang:AddPhrase("function_details", "Function Details")
	Lang:AddPhrase("function_select", "Select a function to view its code")
	Lang:AddPhrase("command_function", "Command Function")
	Lang:AddPhrase("command_select", "Select a command to view its code")
	Lang:AddPhrase("print_details", "Print Details")
	Lang:AddPhrase("printed", "Printed to Console")
	Lang:AddPhrase("requesting_source", "Requesting source from server...")
	Lang:AddPhrase("hook_select", "Select a hook to view its code")
	Lang:AddPhrase("receiver_select", "Select a receiver to view its code")

	-- Tab Names
	Lang:AddPhrase("tab_hooks", "Hooks")
	Lang:AddPhrase("tab_networking", "Networking")
	Lang:AddPhrase("tab_functions", "Functions")
	Lang:AddPhrase("tab_commands", "Commands")
	Lang:AddPhrase("tab_timers", "Timers")
	Lang:AddPhrase("tab_entity_variables", "Entity Variables")
	Lang:AddPhrase("tab_network_variables", "Network Variables")
	Lang:AddPhrase("tab_auto_profile", "Auto Profiling")


	Lang:Save()
end)

GProfiler.Language:AddLanguage("french", function(Lang)
	-- General
	Lang:AddPhrase("profiler_results", "Résultat du Profiler")
	Lang:AddPhrase("profiler_start", "Commencer le profilage")
	Lang:AddPhrase("profiler_stop", "Terminer le profilage")
	Lang:AddPhrase("realm_client", "Client")
	Lang:AddPhrase("realm_server", "Serveur")
	Lang:AddPhrase("copy", "Copier")

	-- Column Names
	Lang:AddPhrase("file", "Fichier")
	Lang:AddPhrase("name", "Noms")
	Lang:AddPhrase("type", "Type")
	Lang:AddPhrase("lines", "Lignes")
	Lang:AddPhrase("realm", "Realm")
	Lang:AddPhrase("focus", "Focus")
	Lang:AddPhrase("remove", "Supprimer")
	Lang:AddPhrase("function", "Fonction")
	Lang:AddPhrase("receivers", "Receveurs")
	Lang:AddPhrase("receiver", "Receveur")
	Lang:AddPhrase("total_time", "Temps total")
	Lang:AddPhrase("times_called", "Horaires appelés")
	Lang:AddPhrase("times_run", "Horaires Exécuté")
	Lang:AddPhrase("times_received", "Horaires Recu")
	Lang:AddPhrase("largest_size", "Tailles le plus large")
	Lang:AddPhrase("total_size", "Taille Total")
	Lang:AddPhrase("delay", "Delaie")
	Lang:AddPhrase("timer", "Minuterie")
	Lang:AddPhrase("command", "Commande")
	Lang:AddPhrase("average_time", "Temps Moyen")
	Lang:AddPhrase("longest_time", "Temps le plus long")
	Lang:AddPhrase("entity", "Entité")
	Lang:AddPhrase("variable", "Variable")
	Lang:AddPhrase("times_updated", "Horaires mis à jour")
	Lang:AddPhrase("current_value", "Valeur Actuelle")

	-- Profiler Specific
	Lang:AddPhrase("timer_function", "Fonctions Minuteries")
	Lang:AddPhrase("timer_select", "Selectionnez une Minuterie pour voir sa fonction")
	Lang:AddPhrase("function_details", "Détails de la Fonction")
	Lang:AddPhrase("function_select", "Selectionne une fonction pour voir sa minuterie")
	Lang:AddPhrase("command_function", "Fonction de commande")
	Lang:AddPhrase("command_select", "Selectionnez une fonction pour voir sa commande")
	Lang:AddPhrase("print_details", "Imprimer les details")
	Lang:AddPhrase("printed", "Imprimé dans la console (F10)")
	Lang:AddPhrase("requesting_source", "Demande de source au serveur...")
	Lang:AddPhrase("hook_select", "Selectionnez un hook pour voir sa fonction")
	Lang:AddPhrase("receiver_select", "Selectionnez un receveur pour voir sa fonction")

	-- Tab Names
	Lang:AddPhrase("tab_hooks", "HOOKS")
	Lang:AddPhrase("tab_networking", "Réseau")
	Lang:AddPhrase("tab_functions", "Fonctions")
	Lang:AddPhrase("tab_commands", "Commandes")
	Lang:AddPhrase("tab_timers", "Minuteries")
	Lang:AddPhrase("tab_entity_variables", "Variables des Entités")
	Lang:AddPhrase("tab_network_variables", "Variables du Réseau")

	Lang:Save()
end)

GProfiler.Language:AddLanguage("german", function(Lang)
	-- General
	Lang:AddPhrase("profiler_results", "Profiler-Ergebnisse")
	Lang:AddPhrase("profiler_start", "Profiler starten")
	Lang:AddPhrase("profiler_stop", "Profiler stoppen")
	Lang:AddPhrase("realm_client", "Klient")
	Lang:AddPhrase("realm_server", "Server")
	Lang:AddPhrase("copy", "Kopieren")

	-- Column Names
	Lang:AddPhrase("file", "Dateipfad")
	Lang:AddPhrase("name", "Name")
	Lang:AddPhrase("type", "Typ")
	Lang:AddPhrase("lines", "Zeilen")
	Lang:AddPhrase("realm", "Umgebung")
	Lang:AddPhrase("focus", "Fokus")
	Lang:AddPhrase("remove", "Entfernen")
	Lang:AddPhrase("function", "Funktion")
	Lang:AddPhrase("receivers", "Empfänger")
	Lang:AddPhrase("receiver", "Empfänger")
	Lang:AddPhrase("total_time", "Aggregierte Dauer")
	Lang:AddPhrase("times_called", "Aufrufe")
	Lang:AddPhrase("times_run", "Aufrufe")
	Lang:AddPhrase("times_received", "Erhalten")
	Lang:AddPhrase("largest_size", "Maximale Größe")
	Lang:AddPhrase("total_size", "Aggregierte Größe")
	Lang:AddPhrase("delay", "Intervall")
	Lang:AddPhrase("timer", "Timer")
	Lang:AddPhrase("command", "Befehl")
	Lang:AddPhrase("average_time", "Durchschnittliche Dauer")
	Lang:AddPhrase("longest_time", "Längste Dauer")
	Lang:AddPhrase("entity", "Entität")
	Lang:AddPhrase("variable", "Variable")
	Lang:AddPhrase("times_updated", "Änderungen")
	Lang:AddPhrase("current_value", "Aktueller Wert")

	-- Profiler Specific
	Lang:AddPhrase("timer_function", "Quellcode des Timers")
	Lang:AddPhrase("timer_select", "Wähle einen Timer, zu dem du den Quellcode sehen willst.")
	Lang:AddPhrase("function_details", "Quellcode der Funktion")
	Lang:AddPhrase("function_select", "Wähle eine Funktion, zu der du den Quellcode sehen willst.")
	Lang:AddPhrase("command_function", "Quellcode des Befehls")
	Lang:AddPhrase("command_select", "Wähle einen Befehl, zu dem du den Quellcode sehen willst.")
	Lang:AddPhrase("print_details", "Details ausgeben")
	Lang:AddPhrase("printed", "Details wurden in der Konsole ausgegeben!")
	Lang:AddPhrase("requesting_source", "Quellcode wird abgefragt...")
	Lang:AddPhrase("hook_select", "Wähle einen Hook, zu dem du den Quellcode sehen willst.")
	Lang:AddPhrase("receiver_select", "Wähle einen Empfänger, zu dem du den Quellcode sehen willst.")

	-- Tab Names
	Lang:AddPhrase("tab_hooks", "Hooks")
	Lang:AddPhrase("tab_networking", "Netzwerk")
	Lang:AddPhrase("tab_functions", "Funktionen")
	Lang:AddPhrase("tab_commands", "Befehle")
	Lang:AddPhrase("tab_timers", "Timer")
	Lang:AddPhrase("tab_entity_variables", "Entitätsvariablen")
	Lang:AddPhrase("tab_network_variables", "Netzwerkvariablen")

	Lang:Save()
end)

GProfiler.Language:AddLanguage("dutch", function(Lang)
	-- General
	Lang:AddPhrase("profiler_results", "Profiler Resultaten")
	Lang:AddPhrase("profiler_start", "Start Profiling")
	Lang:AddPhrase("profiler_stop", "Stop Profiling")
	Lang:AddPhrase("realm_client", "Client")
	Lang:AddPhrase("realm_server", "Server")
	Lang:AddPhrase("copy", "KopiÃ«ren")

	-- Column Names
	Lang:AddPhrase("file", "Document")
	Lang:AddPhrase("name", "Naam")
	Lang:AddPhrase("type", "Type")
	Lang:AddPhrase("lines", "Lijnen")
	Lang:AddPhrase("realm", "Realm")
	Lang:AddPhrase("focus", "Focus")
	Lang:AddPhrase("remove", "Verwijderen")
	Lang:AddPhrase("function", "Functie")
	Lang:AddPhrase("receivers", "Ontvangers")
	Lang:AddPhrase("receiver", "Ontvanger")
	Lang:AddPhrase("total_time", "Totale tijd")
	Lang:AddPhrase("times_called", "Aantal Keer Opgeroepen")
	Lang:AddPhrase("times_run", "Aantal Keer Gerunt")
	Lang:AddPhrase("times_received", "Aantal Keer Ontvangen")
	Lang:AddPhrase("largest_size", "Grootste Formaat")
	Lang:AddPhrase("total_size", "Totale Grote")
	Lang:AddPhrase("delay", "Delay")
	Lang:AddPhrase("timer", "Timer")
	Lang:AddPhrase("command", "Command")
	Lang:AddPhrase("average_time", "Gemiddelde Tijd")
	Lang:AddPhrase("longest_time", "Langste Tijd")
	Lang:AddPhrase("entity", "Entiteit")
	Lang:AddPhrase("variable", "Variabelen")
	Lang:AddPhrase("times_updated", "Aantal Keer Geupdate")
	Lang:AddPhrase("current_value", "Huidige Waarde")

	-- Profiler Specific
	Lang:AddPhrase("timer_function", "Timer Functie")
	Lang:AddPhrase("timer_select", "Selecteer een timer om de code te bekijken")
	Lang:AddPhrase("function_details", "Functie Details")
	Lang:AddPhrase("function_select", "Selecteer een functie om de code te bekijken")
	Lang:AddPhrase("command_function", "Command Functie")
	Lang:AddPhrase("command_select", "Selecteer een command om de code te bekijken")
	Lang:AddPhrase("print_details", "Afdruk Details")
	Lang:AddPhrase("printed", "Afgedrukt Naar Console")
	Lang:AddPhrase("requesting_source", "Bron opvragen bij server...")
	Lang:AddPhrase("hook_select", "Selecteer een hook om de code te bekijken")
	Lang:AddPhrase("receiver_select", "Selecteer een ontvanger om de code te bekijken")

	-- Tab Names
	Lang:AddPhrase("tab_hooks", "Hooks")
	Lang:AddPhrase("tab_networking", "Networking")
	Lang:AddPhrase("tab_functions", "Functies")
	Lang:AddPhrase("tab_commands", "Commands")
	Lang:AddPhrase("tab_timers", "Timers")
	Lang:AddPhrase("tab_entity_variables", "Entiteit Variabelen")
	Lang:AddPhrase("tab_network_variables", "Network Variabelen")

	Lang:Save()
end)

GProfiler.Language:AddLanguage("russian", function(Lang)
	-- General
	Lang:AddPhrase("profiler_results", "Результаты профилирования")
	Lang:AddPhrase("profiler_start", "Начать профилирование")
	Lang:AddPhrase("profiler_stop", "Остановить профилирование")
	Lang:AddPhrase("realm_client", "Клиент")
	Lang:AddPhrase("realm_server", "Сервер")
	Lang:AddPhrase("copy", "Копировать")

	-- Column Names
	Lang:AddPhrase("file", "Файл")
	Lang:AddPhrase("name", "Имя")
	Lang:AddPhrase("type", "Тип")
	Lang:AddPhrase("lines", "Строки")
	Lang:AddPhrase("realm", "Область")
	Lang:AddPhrase("focus", "Фокус")
	Lang:AddPhrase("remove", "Удалить")
	Lang:AddPhrase("function", "Функция")
	Lang:AddPhrase("receivers", "Получатели")
	Lang:AddPhrase("receiver", "Получатель")
	Lang:AddPhrase("total_time", "Общее время")
	Lang:AddPhrase("times_called", "Время вызова")
	Lang:AddPhrase("times_run", "Время работы")
	Lang:AddPhrase("times_received", "Время получения")
	Lang:AddPhrase("largest_size", "Наибольший размер")
	Lang:AddPhrase("total_size", "Общий размер")
	Lang:AddPhrase("delay", "Задержка")
	Lang:AddPhrase("timer", "Таймер")
	Lang:AddPhrase("command", "Команда")
	Lang:AddPhrase("average_time", "Среднее время")
	Lang:AddPhrase("longest_time", "Самое продолжительное время")
	Lang:AddPhrase("entity", "Сущность")
	Lang:AddPhrase("variable", "Переменная")
	Lang:AddPhrase("times_updated", "Время обновления")
	Lang:AddPhrase("current_value", "Текущее значение")

	-- Profiler Specific
	Lang:AddPhrase("timer_function", "Функция таймера")
	Lang:AddPhrase("timer_select", "Выберите таймер для просмотра его кода")
	Lang:AddPhrase("function_details", "Детали функции")
	Lang:AddPhrase("function_select", "Выберите функцию для просмотра ее кода")
	Lang:AddPhrase("command_function", "Командная функция")
	Lang:AddPhrase("command_select", "Выберите команду для просмотра ее кода")
	Lang:AddPhrase("print_details", "Подробные сведения о печати")
	Lang:AddPhrase("printed", "Напечатано в консоли")
	Lang:AddPhrase("requesting_source", "Запрос исходного кода с сервера...")
	Lang:AddPhrase("hook_select", "Выберите хук для просмотра его кода")
	Lang:AddPhrase("receiver_select", "Выберите получателя для просмотра его кода")

	-- Tab Names
	Lang:AddPhrase("tab_hooks", "Хуки")
	Lang:AddPhrase("tab_networking", "Сетевые параметры")
	Lang:AddPhrase("tab_functions", "Функции")
	Lang:AddPhrase("tab_commands", "Команды")
	Lang:AddPhrase("tab_timers", "Таймеры")
	Lang:AddPhrase("tab_entity_variables", "Переменные сущности")
	Lang:AddPhrase("tab_network_variables", "Сетевые переменные")

	Lang:Save()
end)

GProfiler.Language:AddLanguage("italian", function(Lang)
	-- General
	Lang:AddPhrase("profiler_results", "Risultato Profilo")
	Lang:AddPhrase("profiler_start", "Starta Profilo")
	Lang:AddPhrase("profiler_stop", "Stop Profilo")
	Lang:AddPhrase("realm_client", "Client")
	Lang:AddPhrase("realm_server", "Server")
	Lang:AddPhrase("copy", "Copia")

	-- Column Names
	Lang:AddPhrase("file", "File")
	Lang:AddPhrase("name", "Nome")
	Lang:AddPhrase("type", "Tipo")
	Lang:AddPhrase("lines", "Linee")
	Lang:AddPhrase("realm", "Nazione")
	Lang:AddPhrase("focus", "Focus")
	Lang:AddPhrase("remove", "Rimuovi")
	Lang:AddPhrase("function", "Funzione")
	Lang:AddPhrase("receivers", "Ricevitori")
	Lang:AddPhrase("receiver", "Ricevitore")
	Lang:AddPhrase("total_time", "Tempo Totale")
	Lang:AddPhrase("times_called", "Tempo chiamato")
	Lang:AddPhrase("times_run", "Tempo trascorso")
	Lang:AddPhrase("times_received", "Tempo ricevuto")
	Lang:AddPhrase("largest_size", "Dimensione più grande")
	Lang:AddPhrase("total_size", "Dimensione Totale")
	Lang:AddPhrase("delay", "Ritardo")
	Lang:AddPhrase("timer", "Tempo")
	Lang:AddPhrase("command", "Commando")
	Lang:AddPhrase("average_time", "Tempo medio")
	Lang:AddPhrase("longest_time", "Tempo più Lungo")
	Lang:AddPhrase("entity", "Entità")
	Lang:AddPhrase("variable", "Variabile")
	Lang:AddPhrase("times_updated", "Tempo Aggiornato")
	Lang:AddPhrase("current_value", "Valore corrente")

	-- Profiler Specific
	Lang:AddPhrase("timer_function", "Funzione timer")
	Lang:AddPhrase("timer_select", "Seleziona un timer per visualizzarne il codice")
	Lang:AddPhrase("function_details", "Dettagli funzione")
	Lang:AddPhrase("function_select", "Seleziona una funzione per visualizzarne il codice")
	Lang:AddPhrase("command_function", "Funzione di comando")
	Lang:AddPhrase("command_select", "Seleziona un comando per visualizzarne il codice")
	Lang:AddPhrase("print_details", "Stampa dettagli")
	Lang:AddPhrase("printed", "Stampato su Console")
	Lang:AddPhrase("requesting_source", "Richiesta di origine dal server...")
	Lang:AddPhrase("hook_select", "Seleziona un hook per visualizzarne il codice")
	Lang:AddPhrase("receiver_select", "Seleziona un ricevitore per visualizzarne il codice")

	-- Tab Names
	Lang:AddPhrase("tab_hooks", "Hooks")
	Lang:AddPhrase("tab_networking", "Rete")
	Lang:AddPhrase("tab_functions", "Funzione")
	Lang:AddPhrase("tab_commands", "Comandi")
	Lang:AddPhrase("tab_timers", "Tempo")
	Lang:AddPhrase("tab_entity_variables", "Variabile Entità")
	Lang:AddPhrase("tab_network_variables", "Variabili di rete")

	Lang:Save()
end)
--addons/gprofiler/lua/gprofiler/cl_menu.lua:
GProfiler.Menu.Tabs = GProfiler.Menu.Tabs or {}
GProfiler.Menu.Background = GProfiler.Menu.Background or nil
GProfiler.Menu.Content = GProfiler.Menu.Content or nil
GProfiler.Menu.LastTab = GProfiler.Menu.LastTab or 1

local MenuColors = GProfiler.MenuColors

local function GetTabName(tabName)
	tabName = string.gsub(string.lower(tabName), " ", "_")
	return GProfiler.Language.GetPhrase(string.format("tab_%s", tabName))
end

local function formatTime(seconds)
	local days = math.floor(seconds / 86400)
	if days > 0 then
		local hours = math.floor((seconds - days * 86400) / 3600)
		local minutes = math.floor((seconds - days * 86400 - hours * 3600) / 60)
		local seconds = math.floor(seconds - days * 86400 - hours * 3600 - minutes * 60)
		return string.format("%dd %02d:%02d:%02d", days, hours, minutes, seconds)
	else
		local hours = math.floor(seconds / 3600)
		local minutes = math.floor((seconds - hours * 3600) / 60)
		local seconds = math.floor(seconds - hours * 3600 - minutes * 60)
		return string.format("%02d:%02d:%02d", hours, minutes, seconds)
	end
end

function GProfiler.Menu:Open()
	if not GProfiler.Access.HasAccess(LocalPlayer()) then return end
	if IsValid(GProfiler.Menu.Background) then GProfiler.Menu.Background:Remove() end

	local SColor = MenuColors.HeaderSeparator

	local MenuBackground = vgui.Create("DFrame")
	MenuBackground:SetSize(ScrW(), ScrH())
	MenuBackground:Center()
	MenuBackground:SetDraggable(false)
	MenuBackground:ShowCloseButton(false)
	MenuBackground:SetTitle("")
	MenuBackground:MakePopup()
	MenuBackground:SetMouseInputEnabled(false)
	MenuBackground.Paint = function(s) Derma_DrawBackgroundBlur(s) end
	if GProfiler.Config.MenuCommands.Closekey then
		MenuBackground.Think = function(s)
			if input.IsKeyDown(GProfiler.Config.MenuCommands.Closekey) then
				s:Close()
			end
		end
	end
	GProfiler.Menu.Background = MenuBackground

	local Menu = vgui.Create("DFrame", MenuBackground)
	Menu:SetSize(ScrW() * 0.8, ScrH() * 0.8)
	Menu:Center()
	Menu:SetDraggable(false)
	Menu:ShowCloseButton(false)
	Menu:SetTitle("")
	Menu:MakePopup()
	Menu.Paint = function(s, w, h) draw.RoundedBox(4, 0, 0, w, h, MenuColors.Background) end
	Menu.OnClose = function() MenuBackground:Remove() end

	local MenuTopBar = vgui.Create("DPanel", Menu)
	MenuTopBar:SetSize(Menu:GetWide(), 40)
	MenuTopBar:SetPos(0, 0)
	MenuTopBar.Paint = function(s, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, h, MenuColors.OpaqueBlack, true, true, false, false)
		surface.SetDrawColor(SColor.r, SColor.g, SColor.b, SColor.a)
		surface.DrawLine(0, h - 1, w, h - 1)
	end

	local MenuTitle = vgui.Create("DLabel", MenuTopBar)
	MenuTitle:SetSize(MenuTopBar:GetWide(), MenuTopBar:GetTall())
	MenuTitle:SetPos(0, 0)
	MenuTitle:SetFont("GProfiler.Menu.Title")
	MenuTitle:SetTextColor(MenuColors.White)
	MenuTitle:SetText("GProfiler")
	MenuTitle:SizeToContents()
	MenuTitle:SetPos(5, MenuTopBar:GetTall() / 2 - MenuTitle:GetTall() / 2)

	GProfiler.Menu.Title = MenuTitle

	local LeftSideBar = vgui.Create("DPanel", Menu)
	LeftSideBar:SetSize(250, Menu:GetTall() - MenuTopBar:GetTall() - 35)
	LeftSideBar:SetPos(0, MenuTopBar:GetTall())
	LeftSideBar.Paint = function(s, w, h) draw.RoundedBoxEx(4, 0, 0, w, h, MenuColors.OpaqueBlack, false, false, true, false) end

	local UptimeBar = vgui.Create("DPanel", Menu)
	UptimeBar:SetSize(LeftSideBar:GetWide(), 35)
	UptimeBar:SetPos(0, Menu:GetTall() - UptimeBar:GetTall())
	UptimeBar.Paint = function(s, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, h, MenuColors.OpaqueBlack, false, false, false, true)
		surface.SetDrawColor(SColor.r, SColor.g, SColor.b, SColor.a)
		surface.DrawLine(0, 0, w, 0)
	end

	local VersionLbl = vgui.Create("DLabel", UptimeBar)
	VersionLbl:SetSize(UptimeBar:GetWide(), UptimeBar:GetTall())
	VersionLbl:SetPos(0, 0)
	VersionLbl:SetFont("GProfiler.Menu.VersionLbl")
	VersionLbl:SetTextColor(MenuColors.White)
	VersionLbl:SetText("GProfiler • v" .. GProfiler.Version)
	VersionLbl:SetContentAlignment(5)
	VersionLbl.Paint = nil

	local CloseButton = vgui.Create("DButton", MenuTopBar)
	CloseButton:SetSize(MenuTopBar:GetTall(), MenuTopBar:GetTall())
	CloseButton:SetPos(Menu:GetWide() - CloseButton:GetWide(), 0)
	CloseButton:SetText("X")
	CloseButton:SetFont("GProfiler.Menu.SectionHeader")
	CloseButton:SetTextColor(MenuColors.White)
	CloseButton.Paint = nil
	CloseButton.DoClick = function() Menu:Close() end

	local MenuContent = vgui.Create("DPanel", Menu)
	MenuContent:SetSize(Menu:GetWide() - LeftSideBar:GetWide(), Menu:GetTall() - MenuTopBar:GetTall())
	MenuContent:SetPos(LeftSideBar:GetWide(), MenuTopBar:GetTall())
	MenuContent.Paint = nil

	GProfiler.Menu.Content = MenuContent

	local TabList = vgui.Create("DPanelList", LeftSideBar)
	TabList:SetSize(LeftSideBar:GetWide(), LeftSideBar:GetTall())
	TabList:SetPos(0, 0)
	TabList:EnableVerticalScrollbar(true)
	TabList:SetSpacing(0)
	TabList.Paint = nil

	local padding = 10

	local activeTab = nil
	local BottomTabs = {}

	local function AddTab(k, v, alt)
		local Tab = vgui.Create("DButton")
		Tab.Lerped = 0
		Tab:SetSize(TabList:GetWide(), 50)
		Tab:SetText("")
		Tab.Paint = function(s, w, h)
			if alt then
				draw.RoundedBox(4, 0, 0, w, h, MenuColors.HeaderSeparator)
				draw.RoundedBox(4, 2, 2, w - 4, h - 4, MenuColors.OpaqueBlack)

				if s:IsHovered() or activeTab == s then
					draw.RoundedBox(4, 0, 0, w, h, MenuColors.HeaderSeparator)
				end
				return
			end
			surface.SetDrawColor(SColor.r, SColor.g, SColor.b, SColor.a)
			surface.DrawLine(0, h - 1, w, h - 1)

			if s:IsHovered() or activeTab == s then
				s.Lerped = Lerp(FrameTime() * 5, s.Lerped, w + 2)
			else
				s.Lerped = Lerp(FrameTime() * 5, s.Lerped, 0)
			end

			draw.RoundedBox(0, 0, 0, s.Lerped, h, MenuColors.TopBarSeparator)
		end
		Tab.DoClick = function()
			GProfiler.Menu.OpenTab(v.Name, v.Function)
			activeTab = Tab
			GProfiler.Menu.LastTab = k
		end

		local TabIcon = vgui.Create("DImage", Tab)
		TabIcon:SetSize(Tab:GetTall() - padding * 2, Tab:GetTall() - padding * 2)
		TabIcon:SetPos(padding, padding)
		TabIcon:SetImage(v.Icon)

		local TabText = vgui.Create("DLabel", Tab)
		TabText:SetFont("GProfiler.Menu.TabText")
		TabText:SetText(GetTabName(v.Name))
		TabText:SetTextColor(MenuColors.White)
		TabText:SizeToContents()
		TabText:SetPos(TabIcon:GetWide() + padding * 2, Tab:GetTall() / 2 - TabText:GetTall() / 2)
		TabText:SetContentAlignment(5)

		if v.BadgeFunc then
			local TabBadge = vgui.Create("DLabel", Tab)
			TabBadge:SetSize(1, 1)
			TabBadge:SetText("")
			TabBadge:SetFont("GProfiler.Menu.TabText")
			TabBadge:SetPos(Tab:GetWide() - TabBadge:GetWide() - padding, Tab:GetTall() / 2 - TabBadge:GetTall() / 2)
			TabBadge:SetContentAlignment(5)
			TabBadge.Think = function(s)
				local text = v.BadgeFunc()
				if not s.CurrentText or s.CurrentText ~= text then
					s.CurrentText = text
					surface.SetFont(s:GetFont())
					local w, h = surface.GetTextSize(text or "")
					if text == "" then
						s:SetSize(h / 2, h / 2)
					else
						s:SetSize(w + 5, h + 5)
					end
					s:SetPos(Tab:GetWide() - s:GetWide() - padding, Tab:GetTall() / 2 - s:GetTall() / 2)
				end
			end
			TabBadge.Paint = function(s, w, h)
				local text, color = v.BadgeFunc()
				if text and color then
					if text == "" then
						draw.RoundedBox(h / 2, 0, 0, w, h, color)
					else
						draw.RoundedBox(4, 0, 0, w, h, color)
						draw.SimpleText(text, "GProfiler.Menu.TabBadge", w / 2, h / 2, MenuColors.White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
				end
			end
		end

		return Tab
	end

	for k, v in ipairs(GProfiler.Menu.Tabs) do
		if v.Weight == 999 then
			table.insert(BottomTabs, v)
			continue
		end

		local Tab = AddTab(k, v)
		TabList:AddItem(Tab)
	end

	if #BottomTabs > 0 then
		local BottomTabList = vgui.Create("DPanelList", LeftSideBar)
		BottomTabList:SetSize(LeftSideBar:GetWide() - 6, 50 * #BottomTabs)
		BottomTabList:SetPos(3, LeftSideBar:GetTall() - BottomTabList:GetTall() - 5)
		BottomTabList:EnableVerticalScrollbar(true)
		BottomTabList:SetSpacing(0)
		BottomTabList.Paint = nil

		for k, v in ipairs(BottomTabs) do
			local Tab = AddTab(k, v, true)
			BottomTabList:AddItem(Tab)
		end
	end

	TabList:GetItems()[GProfiler.Menu.LastTab]:DoClick()
end

function GProfiler.Menu.RegisterTab(name, icon, weight, func, badgeFunc)
	local tbl = {
		["Name"] = name,
		["Icon"] = icon,
		["Weight"] = weight,
		["Function"] = func,
		["BadgeFunc"] = badgeFunc
	}

	for k, v in ipairs(GProfiler.Menu.Tabs) do
		if v.Name == name then
			GProfiler.Menu.Tabs[k] = tbl
			table.sort(GProfiler.Menu.Tabs, function(a, b) return a.Weight < b.Weight end)
			return
		end
	end

	table.insert(GProfiler.Menu.Tabs, tbl)
	table.sort(GProfiler.Menu.Tabs, function(a, b) return a.Weight < b.Weight end)
end

function GProfiler.Menu.OpenTab(name, func)
	if not IsValid(GProfiler.Menu.Content) then return end
	if not name or not func then return end

	GProfiler.Menu.Content:Clear()

	local Tab = vgui.Create("DPanel", GProfiler.Menu.Content)
	Tab:SetSize(GProfiler.Menu.Content:GetWide(), GProfiler.Menu.Content:GetTall())
	Tab.Paint = nil

	func(Tab)

	if GProfiler.Menu.Title then
		GProfiler.Menu.Title:SetText("GProfiler - " .. GetTabName(name))
		GProfiler.Menu.Title:SizeToContents()
	end
end

if isstring(GProfiler.Config.MenuCommands.Chat) then
	hook.Add("OnPlayerChat", "GProfiler.MenuCommands.Chat", function(ply, text)
		if text == GProfiler.Config.MenuCommands.Chat then
			if ply == LocalPlayer() then GProfiler.Menu.Open() end
			return true
		end
	end)
else hook.Remove("OnPlayerChat", "GProfiler.MenuCommands.Chat") end

if isstring(GProfiler.Config.MenuCommands.Console) then
	concommand.Add(GProfiler.Config.MenuCommands.Console, GProfiler.Menu.Open)
end

local function CreateFonts()
	surface.CreateFont("GProfiler.Menu.Title", { font = "Roboto", size = 26, weight = 500, antialias = true })
	surface.CreateFont("GProfiler.Menu.SectionHeader", { font = "Roboto", size = 18, weight = 500, antialias = true })
	surface.CreateFont("GProfiler.Menu.TabText", { font = "Roboto", size = 20, weight = 400, antialias = true })
	surface.CreateFont("GProfiler.Menu.TabBadge", { font = "Roboto", size = 18, weight = 400, antialias = true })
	surface.CreateFont("GProfiler.Menu.VersionLbl", { font = "Roboto", size = 18, weight = 400, antialias = true })
	surface.CreateFont("GProfiler.Menu.RealmSelector", { font = "Roboto", size = 18, weight = 500, antialias = true })
	surface.CreateFont("GProfiler.Menu.StartButton", { font = "Roboto", size = 16, weight = 500, antialias = true })
	surface.CreateFont("GProfiler.Menu.ListHeader", { font = "Roboto", size = ScreenScale(4), weight = 400,	antialias = true })
	surface.CreateFont("GProfiler.Menu.FunctionDetails", { font = "Roboto", size = 16, weight = 400, antialias = true })
	surface.CreateFont("GProfiler.Menu.FocusEntry", { font = "Roboto", size = 16, weight = 500, antialias = true })
end
CreateFonts()
hook.Add("OnScreenSizeChanged", "GProfiler.Menu.RescaleFonts", CreateFonts)

net.Receive("GProfiler.SendState", function()
	local count = net.ReadUInt(4)
	for i = 1, count do
		local Profiler = net.ReadString()
		local StartedAt = net.ReadFloat()

		local Tbl = GProfiler[Profiler]
		if not Tbl then continue end

		Tbl.ProfileActive = true
		Tbl.Realm = "Server"
		Tbl.StartTime = SysTime() - StartedAt
	end
end)
--addons/gprofiler/lua/gprofiler/profilers/concommands/cl_concommands.lua:
return gluapack()()
--addons/gprofiler/lua/gprofiler/profilers/concommands/sh_concommands.lua:
return gluapack()()
--addons/gprofiler/lua/gprofiler/profilers/functions/cl_functions.lua:
GProfiler.Functions = GProfiler.Functions or {}
GProfiler.Functions.Realm = GProfiler.Functions.Realm or "Client"
GProfiler.Functions.ProfileActive = GProfiler.Functions.ProfileActive or false
GProfiler.Functions.StartTime = GProfiler.Functions.StartTime or 0
GProfiler.Functions.EndTime = GProfiler.Functions.EndTime or 0

GProfiler.Functions.ActiveFocus = GProfiler.Functions.ActiveFocus or {}

local TabPadding = 10
local MenuColors = GProfiler.MenuColors
local IsReceivingData = false

local function ValidateFocus(foc)
	return string.find(foc or "", "function: 0x") != nil
end

local FocusColors = {
	Valid = Color(0, 255, 0),
	Invalid = Color(255, 0, 0)
}

-- Hacky solution for functions that have no signature but are mutually the same
local function CombineDuplicates()
	local combined = {}
	for k, v in pairs(GProfiler.Functions.ProfileData) do
		local lines = string.Split(v.lines, " - ")
		local key = v.source .. lines[1] .. lines[2]
		if not combined[key] then
			combined[key] = {
				name = v.name, source = v.source,
				lines = v.lines, calls = v.calls,
				time = v.time, average = v.average,
				focus = v.focus
			}
		else
			combined[key].calls = combined[key].calls + v.calls
			combined[key].time = combined[key].time + v.time
			combined[key].average = combined[key].average + v.average
		end
	end

	GProfiler.Functions.ProfileData = combined
end

function GProfiler.Functions.DoTab(Content)
	local Header = vgui.Create("DPanel", Content)
	Header:SetSize(Content:GetWide(), 40)
	Header:SetPos(0, 10)
	Header.Paint = nil

	local RealmSelector = GProfiler.Menu.CreateRealmSelector(Header, "Functions", Header:GetWide() - 110 - TabPadding, Header:GetTall() / 2 - 30 / 2, function(s, _, value)
		GProfiler.Functions.Realm = value
		GProfiler.Menu.OpenTab("Functions", GProfiler.Functions.DoTab)
	end)
	RealmSelector:SetPos(Header:GetWide() - RealmSelector:GetWide() - TabPadding, Header:GetTall() / 2 - RealmSelector:GetTall() / 2)

	local StartButton = vgui.Create("DButton", Header)
	StartButton:SetText(GProfiler.Functions.ProfileActive and GProfiler.Language.GetPhrase("profiler_stop") or GProfiler.Language.GetPhrase("profiler_start"))
	StartButton:SetTextColor(MenuColors.White)
	StartButton:SetFont("GProfiler.Menu.StartButton")
	StartButton:SizeToContents()
	StartButton:SetTall(RealmSelector:GetTall())
	StartButton:SetPos(Header:GetWide() - StartButton:GetWide() - RealmSelector:GetWide() - TabPadding * 2, Header:GetTall() / 2 - StartButton:GetTall() / 2)
	StartButton.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, MenuColors.ButtonOutline)
		draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonBackground)

		if s:IsHovered() then
			draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonHover)
		end
	end

	local FunctionTimeRunning = vgui.Create("DLabel", Header)
	FunctionTimeRunning:SetFont("GProfiler.Menu.SectionHeader")
	FunctionTimeRunning:SetText(GProfiler.TimeRunning(GProfiler.Functions.StartTime, GProfiler.Functions.EndTime, GProfiler.Functions.ProfileActive) .. "s")
	FunctionTimeRunning:SizeToContents()
	FunctionTimeRunning:SetPos(Header:GetWide() - FunctionTimeRunning:GetWide() - RealmSelector:GetWide() - StartButton:GetWide() - TabPadding * 3, Header:GetTall() / 2 - FunctionTimeRunning:GetTall() / 2)
	FunctionTimeRunning:SetTextColor(MenuColors.White)
	function FunctionTimeRunning:Think()
		if GProfiler.Functions.ProfileActive then
			self:SetText(GProfiler.TimeRunning(GProfiler.Functions.StartTime, 0, GProfiler.Functions.ProfileActive) .. "s")
			self:SizeToContents()
			self:SetPos(Header:GetWide() - self:GetWide() - RealmSelector:GetWide() - StartButton:GetWide() - TabPadding * 3, Header:GetTall() / 2 - self:GetTall() / 2)
		end
	end

	local ReceivingData = vgui.Create("DLabel", Header)
	ReceivingData:SetFont("GProfiler.Menu.SectionHeader")
	ReceivingData:SetText("Receiving data...    ")
	ReceivingData:SizeToContents()
	ReceivingData:SetPos(Header:GetWide() - ReceivingData:GetWide() - RealmSelector:GetWide() - StartButton:GetWide() - FunctionTimeRunning:GetWide() - TabPadding * 3, Header:GetTall() / 2 - ReceivingData:GetTall() / 2)
	ReceivingData:SetTextColor(Color(225, 66, 66))
	function ReceivingData:Think()
		if IsReceivingData then
			self:SetVisible(true)
		else
			self:SetVisible(false)
		end
	end

	StartButton.DoClick = function()
		if GProfiler.Functions.ProfileActive then
			GProfiler.Functions.EndTime = SysTime()
			if GProfiler.Functions.Realm == "Server" then
				net.Start("GProfiler_Functions_ToggleServerProfile")
				net.WriteBool(false)
				net.SendToServer()
			else
				GProfiler.Functions:RestoreFunctions()
				GProfiler.Functions.ProfileActive = false
				GProfiler.Menu.OpenTab("Functions", GProfiler.Functions.DoTab)
			end
		else
			GProfiler.Functions.StartTime = SysTime()
			GProfiler.Functions.EndTime = 0
			if GProfiler.Functions.Realm == "Server" then
				net.Start("GProfiler_Functions_ToggleServerProfile")
				net.WriteBool(true)
				if not table.IsEmpty(GProfiler.Functions.ActiveFocus) then
					net.WriteBool(true)
					net.WriteUInt(#GProfiler.Functions.ActiveFocus, 5)
					for k, v in ipairs(GProfiler.Functions.ActiveFocus) do
						net.WriteString(v)
					end
				else
					net.WriteBool(false)
				end
				net.SendToServer()
			else
				GProfiler.Functions.Focus = {}
				for k, v in pairs(GProfiler.Functions.ActiveFocus or {}) do
					GProfiler.Functions.Focus[v] = true
				end

				if table.IsEmpty(GProfiler.Functions.ActiveFocus) then
					GProfiler.Functions.Focus = false
				end

				GProfiler.Functions:StartProfiler()
				GProfiler.Functions.ProfileActive = true
				StartButton:SetText(GProfiler.Language.GetPhrase("profiler_stop"))
			end
		end
	end

	local FunctionsFocusLabel = vgui.Create("DLabel", Header)
	FunctionsFocusLabel:SetFont("GProfiler.Menu.SectionHeader")
	FunctionsFocusLabel:SetText(string.format("%s:", GProfiler.Language.GetPhrase("focus")))
	FunctionsFocusLabel:SizeToContents()
	FunctionsFocusLabel:SetPos(TabPadding, Header:GetTall() / 2 - FunctionsFocusLabel:GetTall() / 2)
	FunctionsFocusLabel:SetTextColor(MenuColors.White)

	local AddFocus = vgui.Create("DTextEntry", Header)
	AddFocus:SetFont("GProfiler.Menu.SectionHeader")
	AddFocus:SetText("")
	AddFocus:SetMouseInputEnabled(true)
	AddFocus:SetSize(150, Header:GetTall() - TabPadding * 1.5)
	AddFocus:SetPos(FunctionsFocusLabel:GetWide() + FunctionsFocusLabel:GetPos() + 5, Header:GetTall() / 2 - AddFocus:GetTall() / 2)
	AddFocus:SetTextColor(MenuColors.White)

	local FocusList = vgui.Create("DIconLayout", Header)
	FocusList:SetSpaceX(5)
	FocusList:SetSize(Header:GetWide() - AddFocus:GetWide() - FunctionsFocusLabel:GetWide() - StartButton:GetWide() - RealmSelector:GetWide() - TabPadding * 5, Header:GetTall() - TabPadding)
	FocusList:SetPos(AddFocus:GetWide() + FunctionsFocusLabel:GetWide() + FunctionsFocusLabel:GetPos() + 10, Header:GetTall() / 2 - FocusList:GetTall() / 2)
	FocusList.Paint = nil

	local function AddFocusToList(value)
		local Pnl = FocusList:Add("DPanel")
		Pnl:SetSize(20, FocusList:GetTall())
		Pnl.Paint = function(s, w, h)
			draw.RoundedBox(4, 2, 2, w - 4, h - 4, MenuColors.RealmSelectorBackground)
		end

		local lbl = vgui.Create("DLabel", Pnl)
		lbl:SetFont("GProfiler.Menu.RealmSelector")
		lbl:SetText(string.Split(value, "function: ")[2])
		lbl:SizeToContents()
		lbl:SetPos(5, FocusList:GetTall() / 2 - lbl:GetTall() / 2)
		lbl:SetTextColor(MenuColors.White)

		local remove = vgui.Create("DButton", Pnl)
		remove:SetSize(20, 20)
		remove:SetPos(lbl:GetWide() + 10, FocusList:GetTall() / 2 - remove:GetTall() / 2)
		remove:SetText("X")
		remove:SetTextColor(MenuColors.White)
		remove:SetFont("GProfiler.Menu.RealmSelector")
		remove.Paint = function(s, w, h)
			draw.RoundedBox(4, 0, 0, w, h, MenuColors.ButtonOutline)
			draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonBackground)

			if s:IsHovered() then
				draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonHover)
			end
		end
		remove.DoClick = function()
			table.RemoveByValue(GProfiler.Functions.ActiveFocus, value)
		end

		Pnl:SizeToChildren(true, false)
		Pnl:SetWide(Pnl:GetWide() + 5)
	end

	for k, v in ipairs(GProfiler.Functions.ActiveFocus) do
		AddFocusToList(v)
	end

	AddFocus.OnEnter = function()
		if ValidateFocus(AddFocus:GetText()) and not table.HasValue(GProfiler.Functions.ActiveFocus, AddFocus:GetText()) then
			table.insert(GProfiler.Functions.ActiveFocus, AddFocus:GetText())
			AddFocus:SetText("")
		end
	end

	local IsValidInput = false
	function AddFocus:Paint(w, h)
		draw.RoundedBox(4, 0, 0, w, h, MenuColors.RealmSelectorOutline)
		draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.RealmSelectorBackground)
		draw.RoundedBox(4, 1, 1, 10, h - 2, IsValidInput and FocusColors.Valid or FocusColors.Invalid)
		local x = draw.SimpleText(self:GetText(), "GProfiler.Menu.FocusEntry", 15, h / 2, MenuColors.White, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		if self:IsEditing() and (x < w - 15) and (SysTime() % 1 > 0.5) then
			local caretPos = self:GetCaretPos()
			local text = self:GetText()
			surface.SetFont("GProfiler.Menu.FocusEntry")
			local textWidth = surface.GetTextSize(text)
			local textWidthBeforeCaret = surface.GetTextSize(string.sub(text, 1, caretPos))
			draw.RoundedBox(0, textWidthBeforeCaret + 15, 1, 2, h - 2, MenuColors.White)
		end
	end

	function AddFocus:OnTextChanged()
		IsValidInput = ValidateFocus(self:GetText())
	end

	local prevAmount = 0
	FocusList.Think = function()
		if prevAmount != #GProfiler.Functions.ActiveFocus then
			prevAmount = #GProfiler.Functions.ActiveFocus
			FocusList:Clear()
			FocusList:SetSize(Header:GetWide() - AddFocus:GetWide() - FunctionsFocusLabel:GetWide() - StartButton:GetWide() - RealmSelector:GetWide() - TabPadding * 5, Header:GetTall() - TabPadding)
			FocusList:SetPos(AddFocus:GetWide() + FunctionsFocusLabel:GetWide() + FunctionsFocusLabel:GetPos() + 10, Header:GetTall() / 2 - FocusList:GetTall() / 2)
			for k, v in ipairs(GProfiler.Functions.ActiveFocus) do
				AddFocusToList(v)
			end
		end
	end

	local SectionHeader = vgui.Create("DPanel", Content)
	SectionHeader:SetSize(Content:GetWide(), 40)
	SectionHeader:SetPos(0, Header:GetTall())
	SectionHeader.Paint = nil

	local leftFraction = .7
	local rightFraction = .3

	local LeftHeader, LeftHeaderText = GProfiler.Menu.CreateHeader(SectionHeader, GProfiler.Language.GetPhrase("profiler_results"), 0, 0, SectionHeader:GetWide() * leftFraction - 5, SectionHeader:GetTall())
	local RightHeader, RightHeaderText = GProfiler.Menu.CreateHeader(SectionHeader, GProfiler.Language.GetPhrase("function_details"), LeftHeader:GetWide() + 10, 0, SectionHeader:GetWide() * rightFraction - 5, LeftHeader:GetTall())

	local LeftContent = vgui.Create("DPanel", Content)
	LeftContent:SetSize(Content:GetWide() * leftFraction - 5, Content:GetTall() - SectionHeader:GetTall() - Header:GetTall())
	LeftContent:SetPos(0, SectionHeader:GetTall() + Header:GetTall())
	LeftContent.Paint = nil

	local RightContent = vgui.Create("DPanel", Content)
	RightContent:SetSize(Content:GetWide() * rightFraction - 5, Content:GetTall() - SectionHeader:GetTall() - Header:GetTall())
	RightContent:SetPos(LeftContent:GetWide() + 10, SectionHeader:GetTall() + Header:GetTall())
	RightContent.Paint = nil

	local FunctionDetailsBackground = vgui.Create("DPanel", RightContent)
	FunctionDetailsBackground:SetSize(RightContent:GetWide() - TabPadding * 2, RightContent:GetTall() - TabPadding * 2 - 50)
	FunctionDetailsBackground:SetPos(TabPadding, TabPadding)
	FunctionDetailsBackground.Paint = function(s, w, h) draw.RoundedBox(4, 0, 0, w, h, MenuColors.CodeBackground) end

	local FunctionDetails = vgui.Create("DTextEntry", FunctionDetailsBackground)
	FunctionDetails:Dock(FILL)
	FunctionDetails:SetMultiline(true)
	FunctionDetails:SetKeyboardInputEnabled(false)
	FunctionDetails:SetVerticalScrollbarEnabled(true)
	FunctionDetails:SetDrawBackground(false)
	FunctionDetails:SetTextColor(MenuColors.White)
	FunctionDetails:SetFont("GProfiler.Menu.FunctionDetails")
	FunctionDetails:SetText(GProfiler.Language.GetPhrase("function_select"))

	local FunctionDetailsSeparator = vgui.Create("DPanel", RightContent)
	FunctionDetailsSeparator:SetSize(RightContent:GetWide() - TabPadding * 2, 1)
	FunctionDetailsSeparator:SetPos(TabPadding, FunctionDetailsBackground:GetTall() + TabPadding * 2)
	FunctionDetailsSeparator.Paint = function(self, w, h) draw.RoundedBox(4, 0, 0, w, h, MenuColors.HeaderSeparator) end

	local BottomSection = vgui.Create("DPanel", RightContent)
	BottomSection:SetSize(RightContent:GetWide() - TabPadding * 2, RightContent:GetTall() - FunctionDetailsBackground:GetTall() - FunctionDetailsSeparator:GetTall() - TabPadding * 3)
	BottomSection:SetPos(TabPadding, FunctionDetailsBackground:GetTall() + FunctionDetailsSeparator:GetTall() + TabPadding * 3)
	BottomSection.Paint = nil

	local SelectedProfile = nil
	local Buttons = {
		[GProfiler.Language.GetPhrase("focus")] = function()
			if not SelectedProfile then return end
			if table.HasValue(GProfiler.Functions.ActiveFocus, SelectedProfile.focus) then
				table.RemoveByValue(GProfiler.Functions.ActiveFocus, SelectedProfile.focus)
			else
				table.insert(GProfiler.Functions.ActiveFocus, SelectedProfile.focus)
			end
		end,
		[GProfiler.Language.GetPhrase("print_details")] = function(b)
			if not SelectedProfile then return end

			MsgC(MenuColors.Blue, GProfiler.Language.GetPhrase("function"), ": ", MenuColors.White, SelectedProfile.name, "\n")
			MsgC(MenuColors.Blue, GProfiler.Language.GetPhrase("file"), ": ", MenuColors.White, SelectedProfile.source, "\n")
			MsgC(MenuColors.Blue, GProfiler.Language.GetPhrase("lines"), ": ", MenuColors.White, SelectedProfile.lines, "\n")
			MsgC(MenuColors.Blue, GProfiler.Language.GetPhrase("times_called"), ": ", MenuColors.White, SelectedProfile.calls, "\n")
			MsgC(MenuColors.Blue, GProfiler.Language.GetPhrase("total_time"), ": ", MenuColors.White, SelectedProfile.time, "\n")
			MsgC(MenuColors.Blue, GProfiler.Language.GetPhrase("average_time"), ": ", MenuColors.White, SelectedProfile.average, "\n")

			b:SetText(GProfiler.Language.GetPhrase("printed"))
			timer.Simple(2, function()
				if not IsValid(b) then return end
				b:SetText(GProfiler.Language.GetPhrase("print_details"))
			end)
		end
	}

	local ButtonWidth = BottomSection:GetWide() / table.Count(Buttons)
	local ButtonHeight = BottomSection:GetTall() - TabPadding

	local i = 0
	for k, v in pairs(Buttons) do
		local Button = vgui.Create("DButton", BottomSection)
		Button:SetSize(ButtonWidth - 5, ButtonHeight)
		Button:SetPos(i * ButtonWidth + (i * 5), 0)
		Button:SetText(k)
		Button:SetTextColor(MenuColors.White)
		Button:SetFont("GProfiler.Menu.RealmSelector")
		Button.Paint = function(self, w, h)
			draw.RoundedBox(4, 0, 0, w, h, MenuColors.ButtonOutline)
			draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonBackground)

			if self:IsHovered() then
				draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonHover)
			end
		end
		Button.DoClick = v
		i = i + 1
	end

	local FunctionProfiler = vgui.Create("DListView", LeftContent)
	FunctionProfiler:SetSize(LeftContent:GetWide() - TabPadding * 2, LeftContent:GetTall() - TabPadding * 2)
	FunctionProfiler:SetPos(TabPadding, TabPadding)
	FunctionProfiler:SetMultiSelect(false)
	FunctionProfiler:AddColumn(GProfiler.Language.GetPhrase("function"))
	FunctionProfiler:AddColumn(GProfiler.Language.GetPhrase("file"))
	FunctionProfiler:AddColumn(GProfiler.Language.GetPhrase("times_called"))
	FunctionProfiler:AddColumn(string.format("%s (ms)", GProfiler.Language.GetPhrase("total_time")))
	FunctionProfiler:AddColumn(string.format("%s (ms)", GProfiler.Language.GetPhrase("average_time")))

	CombineDuplicates()

	for k, v in pairs(GProfiler.Functions.ProfileData) do
		if GProfiler.Functions.ProfileActive and GProfiler.Functions.Realm == "Client" then break end
		local line = FunctionProfiler:AddLine(v.name or "Unknown", string.format("%s (%s)", v.source, v.lines), v.calls, v.time, v.average)
		line.OnMousePressed = function(s, l)
			if l == 108 then
				local menu = DermaMenu()
				menu:AddOption(GProfiler.Language.GetPhrase("focus"), function()
					if table.HasValue(GProfiler.Functions.ActiveFocus, v.focus) then
						table.RemoveByValue(GProfiler.Functions.ActiveFocus, v.focus)
					else
						table.insert(GProfiler.Functions.ActiveFocus, v.focus)
					end
				end):SetIcon("icon16/zoom.png")
				menu:AddOption(GProfiler.CopyLang("name"), function() SetClipboardText(v.name) end):SetIcon("icon16/page_copy.png")
				menu:AddOption(GProfiler.CopyLang("file"), function() SetClipboardText(v.source) end):SetIcon("icon16/page_copy.png")
				menu:AddOption(GProfiler.CopyLang("times_called"), function() SetClipboardText(v.calls) end):SetIcon("icon16/page_copy.png")
				menu:AddOption(GProfiler.CopyLang("total_time"), function() SetClipboardText(v.time) end):SetIcon("icon16/page_copy.png")
				menu:AddOption(GProfiler.CopyLang("average_time"), function() SetClipboardText(v.average) end):SetIcon("icon16/page_copy.png")
				menu:Open()
				return
			end

			SelectedProfile = v
			for k, v in ipairs(FunctionProfiler.Lines) do
				v:SetSelected(false)
			end
			line:SetSelected(true)

			local lines = string.Split(v.lines, " - ")
			GProfiler.RequestFunctionSource(v.source, lines[1], lines[2], function(source)
				if not IsValid(FunctionDetails) then return end
				FunctionDetails:SetText(table.concat(source, "\n"))
			end)
		end
	end

	FunctionProfiler:SortByColumn(5, true)

	GProfiler.StyleDListView(FunctionProfiler)
end

GProfiler.Menu.RegisterTab("Functions", "icon16/bug.png", 3, GProfiler.Functions.DoTab, function()
	if GProfiler.Functions.ProfileActive then
		return "", MenuColors.ActiveProfile
	end
	return nil
end)

net.Receive("GProfiler_Functions_ServerProfileStatus", function()
	local status = net.ReadBool()
	local ply = net.ReadEntity()
	GProfiler.Functions.ProfileActive = status

	if ply == LocalPlayer() then
		GProfiler.Menu.OpenTab("Functions", GProfiler.Functions.DoTab)
	end
end)

net.Receive("GProfiler_Functions_SendData", function(len, ply)
	local first = net.ReadBool()

	if first then
		GProfiler.Functions.ProfileData = {}
		IsReceivingData = true
	end

	local last = net.ReadBool()
	local count = net.ReadUInt(32)
	for i = 1, count do
		local name = net.ReadString()
		local source = net.ReadString()
		local lines = net.ReadString()
		local calls = net.ReadUInt(22)
		local time = net.ReadFloat()
		local average = net.ReadFloat()
		local focus = net.ReadString()

		if not GProfiler.Functions.ProfileData[name] then
			GProfiler.Functions.ProfileData[name] = {
				name = name,
				source = source,
				lines = lines,
				calls = 0,
				time = 0,
				average = 0,
				focus = focus
			}
		end

		GProfiler.Functions.ProfileData[name].calls = GProfiler.Functions.ProfileData[name].calls + calls
		GProfiler.Functions.ProfileData[name].time = GProfiler.Functions.ProfileData[name].time + time
		GProfiler.Functions.ProfileData[name].average = GProfiler.Functions.ProfileData[name].average + average
	end

	if last then
		GProfiler.Menu.OpenTab("Functions", GProfiler.Functions.DoTab)
		IsReceivingData = false
	end
end)

--addons/gprofiler/lua/gprofiler/profilers/hooks/cl_hooks.lua:
GProfiler.Hooks = GProfiler.Hooks or {}
GProfiler.Hooks.Realm = GProfiler.Hooks.Realm or "Client"
GProfiler.Hooks.ProfileActive = GProfiler.Hooks.ProfileActive or false
GProfiler.Hooks.StartTime = GProfiler.Hooks.StartTime or 0
GProfiler.Hooks.EndTime = GProfiler.Hooks.EndTime or 0

local TabPadding = 10
local MenuColors = GProfiler.MenuColors

local function GetHookTable(realm, callback)
	if realm == "Server" then
		net.Start("GProfiler_Hooks_HookTbl")
		net.SendToServer()
		net.Receive("GProfiler_Hooks_HookTbl", function()
			local hookCount = net.ReadUInt(15)
			local hookTable = {}
			for i = 1, hookCount do
				hookTable[net.ReadString()] = net.ReadUInt(10)
			end
			callback(hookTable)
		end)
	else
		local hookTbl = {}
		local hooks = hook.GetTable()
		for hookName, hookReceivers in pairs(hooks) do
			hookTbl[hookName] = table.Count(hookReceivers)
		end

		callback(hookTbl)
	end
end

function GProfiler.Hooks.DoTab(Content)
	local Header = vgui.Create("DPanel", Content)
	Header:SetSize(Content:GetWide(), 40)
	Header:SetPos(0, 10)
	Header.Paint = nil

	local RealmSelector = GProfiler.Menu.CreateRealmSelector(Header, "Hooks", Header:GetWide() - TabPadding - 110, Header:GetTall() / 2 - 30 / 2, function(s, _, value)
		GProfiler.Hooks.Realm = value
		GProfiler.Menu.OpenTab("Hooks", GProfiler.Hooks.DoTab)
	end)
	RealmSelector:SetPos(Header:GetWide() - RealmSelector:GetWide() - TabPadding, Header:GetTall() / 2 - RealmSelector:GetTall() / 2)

	local StartButton = vgui.Create("DButton", Header)
	StartButton:SetText(GProfiler.Hooks.ProfileActive and GProfiler.Language.GetPhrase("profiler_stop") or GProfiler.Language.GetPhrase("profiler_start"))
	StartButton:SetTextColor(MenuColors.White)
	StartButton:SetFont("GProfiler.Menu.StartButton")
	StartButton:SizeToContents()
	StartButton:SetTall(RealmSelector:GetTall())
	StartButton:SetPos(Header:GetWide() - StartButton:GetWide() - RealmSelector:GetWide() - TabPadding * 2, Header:GetTall() / 2 - StartButton:GetTall() / 2)
	StartButton.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, MenuColors.ButtonOutline)
		draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonBackground)

		if s:IsHovered() then
			draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonHover)
		end
	end

	local HookTimeRunning = vgui.Create("DLabel", Header)
	HookTimeRunning:SetFont("GProfiler.Menu.SectionHeader")
	HookTimeRunning:SetText(GProfiler.TimeRunning(GProfiler.Hooks.StartTime, GProfiler.Hooks.EndTime, GProfiler.Hooks.ProfileActive) .. "s")
	HookTimeRunning:SizeToContents()
	HookTimeRunning:SetPos(Header:GetWide() - HookTimeRunning:GetWide() - RealmSelector:GetWide() - StartButton:GetWide() - TabPadding * 3, Header:GetTall() / 2 - HookTimeRunning:GetTall() / 2)
	HookTimeRunning:SetTextColor(MenuColors.White)
	function HookTimeRunning:Think()
		if GProfiler.Hooks.ProfileActive then
			self:SetText(GProfiler.TimeRunning(GProfiler.Hooks.StartTime, 0, GProfiler.Hooks.ProfileActive) .. "s")
			self:SizeToContents()
			self:SetPos(Header:GetWide() - self:GetWide() - RealmSelector:GetWide() - StartButton:GetWide() - TabPadding * 3, Header:GetTall() / 2 - self:GetTall() / 2)
		end
	end

	StartButton.DoClick = function()
		if GProfiler.Hooks.ProfileActive then
			GProfiler.Hooks.EndTime = SysTime()
			if GProfiler.Hooks.Realm == "Server" then
				net.Start("GProfiler_Hooks_ToggleServerProfile")
					net.WriteBool(false)
				net.SendToServer()
			else
				GProfiler.Hooks:RestoreHooks()
				GProfiler.Hooks.ProfileActive = false
				GProfiler.Menu.OpenTab("Hooks", GProfiler.Hooks.DoTab)
			end

			if timer.Exists("GProfiler.Hooks.Time") then
				timer.Remove("GProfiler.Hooks.Time")
			end
		else
			GProfiler.Hooks.StartTime = SysTime()
			GProfiler.Hooks.EndTime = 0
			if GProfiler.Hooks.Realm == "Server" then
				net.Start("GProfiler_Hooks_ToggleServerProfile")
					net.WriteBool(true)
				net.SendToServer()
			else
				GProfiler.Hooks:StartProfiler()
				GProfiler.Hooks.ProfileActive = true
				StartButton:SetText(GProfiler.Language.GetPhrase("profiler_stop"))
			end
		end
	end

	local SectionHeader = vgui.Create("DPanel", Content)
	SectionHeader:SetSize(Content:GetWide(), 40)
	SectionHeader:SetPos(0, Header:GetTall())
	SectionHeader.Paint = nil

	local leftFraction = .7
	local rightFraction = .3

	local LeftHeader, LeftHeaderText = GProfiler.Menu.CreateHeader(SectionHeader, GProfiler.Language.GetPhrase("profiler_results"), 0, 0, SectionHeader:GetWide() * leftFraction - 5, SectionHeader:GetTall())
	local RightHeader, RightHeaderText = GProfiler.Menu.CreateHeader(SectionHeader, GProfiler.Language.GetPhrase("Hook Function"), LeftHeader:GetWide() + 10, 0, SectionHeader:GetWide() * rightFraction - 5, LeftHeader:GetTall())

	local LeftContent = vgui.Create("DPanel", Content)
	LeftContent:SetSize(LeftHeader:GetWide(), Content:GetTall() - SectionHeader:GetTall() - Header:GetTall())
	LeftContent:SetPos(0, SectionHeader:GetTall() + Header:GetTall())
	LeftContent.Paint = nil

	local RightContent = vgui.Create("DPanel", Content)
	RightContent:SetSize(RightHeader:GetWide(), Content:GetTall() - SectionHeader:GetTall() - Header:GetTall())
	RightContent:SetPos(LeftContent:GetWide() + 10, SectionHeader:GetTall() + Header:GetTall())
	RightContent.Paint = nil

	local HookProfiler = vgui.Create("DListView", LeftContent)
	HookProfiler:SetSize(LeftContent:GetWide() - TabPadding * 2, (LeftContent:GetTall() - TabPadding * 2) / 2 - 10)
	HookProfiler:SetPos(TabPadding, TabPadding)
	HookProfiler:SetMultiSelect(false)
	HookProfiler:AddColumn(GProfiler.Language.GetPhrase("name"))
	HookProfiler:AddColumn(GProfiler.Language.GetPhrase("receiver"))
	HookProfiler:AddColumn(GProfiler.Language.GetPhrase("file"))
	HookProfiler:AddColumn(GProfiler.Language.GetPhrase("total_time"))
	HookProfiler:AddColumn(GProfiler.Language.GetPhrase("times_called"))

	local HookList = vgui.Create("DListView", LeftContent)
	HookList:SetSize(HookProfiler:GetWide(), HookProfiler:GetTall())
	HookList:SetPos(TabPadding, HookProfiler:GetTall() + TabPadding * 2)
	HookList:SetMultiSelect(false)
	HookList:AddColumn(GProfiler.Language.GetPhrase("name"))
	HookList:AddColumn(GProfiler.Language.GetPhrase("receivers"))

	local FunctionDetailsBackground = vgui.Create("DPanel", RightContent)
	FunctionDetailsBackground:SetSize(RightContent:GetWide() - TabPadding * 2, RightContent:GetTall() - TabPadding * 2)
	FunctionDetailsBackground:SetPos(TabPadding, TabPadding)
	FunctionDetailsBackground.Paint = function(s, w, h) draw.RoundedBox(4, 0, 0, w, h, MenuColors.CodeBackground) end

	local FunctionDetails = vgui.Create("DTextEntry", FunctionDetailsBackground)
	FunctionDetails:Dock(FILL)
	FunctionDetails:SetMultiline(true)
	FunctionDetails:SetKeyboardInputEnabled(false)
	FunctionDetails:SetVerticalScrollbarEnabled(true)
	FunctionDetails:SetDrawBackground(false)
	FunctionDetails:SetTextColor(MenuColors.White)
	FunctionDetails:SetFont("GProfiler.Menu.FunctionDetails")
	FunctionDetails:SetText(GProfiler.Language.GetPhrase("hook_select"))

	table.sort(GProfiler.Hooks.ProfileData, function(a, b) return a.t > b.t end)
	local LastSelected = ""
	for k, v in pairs(GProfiler.Hooks.ProfileData) do
		if v.c == 0 then continue end
		local Line = HookProfiler:AddLine(v.h, v.r, v.Source, v.t, v.c)
		Line.OnRightClick = function()
			local menu = DermaMenu()
			menu:AddOption(GProfiler.CopyLang("name"), function() SetClipboardText(v.h) end):SetIcon("icon16/page_copy.png")
			menu:AddOption(GProfiler.CopyLang("receiver"), function() SetClipboardText(v.r) end):SetIcon("icon16/page_copy.png")
			menu:AddOption(GProfiler.CopyLang("total_time"), function() SetClipboardText(v.t) end):SetIcon("icon16/page_copy.png")
			menu:AddOption(GProfiler.CopyLang("times_called"), function() SetClipboardText(v.c) end):SetIcon("icon16/page_copy.png")
			menu:AddOption(GProfiler.Language.GetPhrase("remove"), function()
				if GProfiler.Hooks.Realm == "Server" then
					net.Start("GProfiler_Hooks_RemoveHook")
						net.WriteString(v.h)
						net.WriteString(v.r)
					net.SendToServer()
					HookProfiler:RemoveLine(Line:GetID())
				else
					hook.Remove(v.h, v.r)
					HookProfiler:RemoveLine(Line:GetID())
				end
			end):SetIcon("icon16/delete.png")
			menu:Open()
		end

		Line.OnSelect = function()
			if LastSelected == v.h..v.r then return end
			LastSelected = v.h..v.r

			FunctionDetails:SetText(GProfiler.Language.GetPhrase("requesting_source"))
			GProfiler.RequestFunctionSource(v.Source, tonumber(v.Lines[1]), tonumber(v.Lines[2]), function(source)
				if not IsValid(FunctionDetails) then return end
				FunctionDetails:SetText(table.concat(source, "\n"))
			end)
		end
	end

	HookProfiler:SortByColumn(3, true)

	local function UpdateLists()
		GProfiler.StyleDListView(HookList)
		GProfiler.StyleDListView(HookProfiler)
	end
	UpdateLists()

	GetHookTable(GProfiler.Hooks.Realm, function(hookTable)
		if not IsValid(HookList) then return end
		local hookTableSorted = {}
		for k, v in pairs(hookTable) do table.insert(hookTableSorted, {k, v}) end
		table.sort(hookTableSorted, function(a, b) return a[2] > b[2] end)

		for k, v in pairs(hookTableSorted) do
			local Line = HookList:AddLine(v[1], v[2])
			Line.OnRightClick = function()
				local menu = DermaMenu()
				menu:AddOption(GProfiler.CopyLang("name"), function() SetClipboardText(v[1]) end):SetIcon("icon16/page_copy.png")
				menu:AddOption(GProfiler.CopyLang("receivers"), function() SetClipboardText(v[2]) end):SetIcon("icon16/page_copy.png")
				menu:Open()
			end
		end

		UpdateLists()
	end)
end

GProfiler.Menu.RegisterTab("Hooks", "icon16/bricks.png", 1, GProfiler.Hooks.DoTab, function()
	if GProfiler.Hooks.ProfileActive then
		return "", MenuColors.ActiveProfile
	end
end)

net.Receive("GProfiler_Hooks_ServerProfileStatus", function()
	local status = net.ReadBool()
	local ply = net.ReadEntity()
	GProfiler.Hooks.ProfileActive = status

	if ply == LocalPlayer() then
		GProfiler.Menu.OpenTab("Hooks", GProfiler.Hooks.DoTab)
	end
end)

net.Receive("GProfiler_Hooks_SendData", function()
	local data = {}
	for i = 1, net.ReadUInt(20) do
		local hookName = net.ReadString()
		data[hookName] = {
			h = net.ReadString(),
			r = hookName,
			c = net.ReadUInt(32),
			t = net.ReadFloat(),
			Source = net.ReadString(),
			Lines = {net.ReadUInt(16), net.ReadUInt(16)}
		}
	end
	GProfiler.Hooks.ProfileData = data
end)

--addons/status_do/lua/autorun/holochat.lua:
return gluapack()()
--lua/vgui/stackerdnumslider.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local math = math
local vgui = vgui
local tonumber = tonumber

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:SetValue( string, boolean )
--
--]]--
function PANEL:SetValue( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )

	if ( val == nil ) then return end
	if ( self:GetValue() == val ) then return end

	self.Scratch:SetFloatValue( val )
	self:ValueChanged( self:GetValue(), bSuppress )
end

--[[--------------------------------------------------------------------------
--
--	PANEL:ValueChanged( string, value)
--
--]]--
function PANEL:ValueChanged( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )
	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )	
	if ( self.TextArea ~= vgui.GetKeyboardFocus() ) then
		self.TextArea:SetValue( self.Scratch:GetTextValue() )
	end
	if ( not bSuppress ) then
		self:OnValueChanged( val )
	end
end

vgui.Register( "StackerDNumSlider", PANEL, "DNumSlider" )
--addons/xenin-inventory/lua/autorun/inventory_load.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

XeninInventory = XeninInventory || {}

local function Load()
  XeninUI.Loader():setName("Xenin Inventory"):setAcronym("XeninInv"):setDirectory("inventory"):setColor(XeninUI.Theme.Blue):loadFile("classes/database", XENINUI_SERVER):load("classes", XENINUI_SHARED, true):load("entities", XENINUI_SHARED):loadFile("essentials/helper", XENINUI_SHARED):loadFile("essentials/player", XENINUI_SERVER):loadFile("essentials/languages", XENINUI_SHARED):load("essentials", XENINUI_CLIENT):load("languages", XENINUI_SHARED):load("configuration", XENINUI_SHARED, true):load("importer", XENINUI_SHARED, true):loadFile("networking/inventory_server", XENINUI_SERVER):loadFile("networking/inventory_client", XENINUI_CLIENT):load("ui", XENINUI_CLIENT, true):done()

  XeninInventory.FinishedLoading = true
end

if XeninUI then
  Load()
else
  hook.Add("XeninUI.Loaded", "XeninInventory", Load)
end

if SERVER then
  resource.AddFile("resource/fonts/Montserrat-Bold.ttf")
  resource.AddFile("resource/fonts/Montserrat-Regular.ttf")

  resource.AddWorkshop("1900562881")
  resource.AddWorkshop("1902931848")
end

--lua/autorun/keegan.lua:
return gluapack()()
--lua/autorun/kowalskianalysis.lua:
player_manager.AddValidModel( "Kowalski", "models/cktheamazingfrog/player/kowalski/kowalski.mdl" )
player_manager.AddValidHands( "Kowalski", "models/cktheamazingfrog/player/kowalski/kowalskiarms.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Kowalski", "models/cktheamazingfrog/player/kowalski/kowalski.mdl" )

local Category = "The Penguins"

local NPC = {   
        Name = "Kowalski Hostile", 
        Class = "npc_combine_s", 
        Model = "models/cktheamazingfrog/player/kowalski/kowalski.mdl",              
        Health = "100",                 
        KeyValues = { citizentype = 4 },                 
        Category = Category,
        Squadname = "Bad Penguin"
}

list.Set( "NPC", "npc_kowalskienemy", NPC ) 

local NPC = {   
        Name = "Kowalski Friendly", 
        Class = "npc_citizen", 
        Model = "models/cktheamazingfrog/player/kowalski/kowalski.mdl",                
        Health = "100",                 
        KeyValues = { citizentype = 4 },                 
        Category = Category,
        Squadname = "Good Penguin"
}

list.Set( "NPC", "npc_kowalskifriend", NPC )
--addons/minigame-tool-assistant/lua/minigames/vgui/playerlist.lua:
--[[--------------------------------------------
              Minigame Setup Menu
--------------------------------------------]]--

local Background = Color(30, 30, 30, 180)
local Grayest = Color(170, 170, 170, 40)

local PLAYER_OWNER = 1
local PLAYER_INGAME = 2
local PLAYER_INGAME_OTHER = 3
local PLAYER_NOT_INGAME = 4

local PlayerPaintColor = {
    [PLAYER_OWNER]          = Color(0, 140, 140, 215),
    [PLAYER_INGAME]         = Color(0, 200, 0, 215),
    [PLAYER_INGAME_OTHER]   = Color(140, 140, 0, 215),
    [PLAYER_NOT_INGAME]     = Color(100, 100, 100, 215),
}

local PlayerButtonPaint = function(self, w, h)
    draw.RoundedBox( 4, 0, 0, w, h, Background )
    draw.RoundedBox( 4, 0, 0, 16, h, PlayerPaintColor[self.State] )
end


local ButtonStyleBackground = Color(58, 58, 58, 150)
local ButtonStyleDisabled = Color(0, 0, 0, 100)
local BlackBackground = Color(0, 0, 0, 40)

local ShadingColor = {}
for i = 1, 16 do
    ShadingColor[i] = Color(0, 158, 185, (i * 160) / 16)
end

local ButtonPaint = function(self, w, h)
    draw.RoundedBox(4, 0, 0, w, h, self:IsEnabled() and ButtonStyleBackground or ButtonStyleDisabled)

    if self:IsEnabled() then
        if self:IsHovered() then
            draw.RoundedBox(4, 0, 0, w, h, BlackBackground)

            for i = 1, 16 do
                draw.RoundedBox(0, 0, h + i - 16, w, 1, ShadingColor[i])
            end
        end
    else
        draw.RoundedBox(4, 0, 0, w, h, Color(0, 0, 0, 100))
    end
end

local PlayersCanHeardOwner = CreateClientConVar("minigames_playerscanhearowner", "1", true, false, "Can players hear the owner of the minigame?")
local MuteAllPlayers = CreateClientConVar("minigames_muteallplayers", "0", true, false, "Mute all players in the minigame?")
local PlayersCanHeardThemselves = CreateClientConVar("minigames_playerscanhearthemselves", "1", true, false, "Can players hear themselves?")

--[[----------------------------
       Player Action Enum
----------------------------]]--

local PlayerListAction = {
    ADD = 1,
    REMOVE = 2,
    TOGGLE = 3,
    SENDTOGAME = 4,
    SENDTOOLDPOS = 5,
    SENDTOSPAWN = 6,
    MUTE = 7,
    UNMUTE = 8
}

local function DoPlayerListAction(ply, action)
    net.Start("Minigames.DoPlayerListAction")
        net.WritePlayer(ply)
        net.WriteUInt(action, 4)
    net.SendToServer()
end

--[[----------------------------
        Player Menu List
----------------------------]]--

local PlayerContextMenu = nil

local PANEL = {}

function PANEL:AddPlayer(ply, parent)
    local PlayerItem = vgui.Create("DButton", parent or nil)
    PlayerItem.ply = ply
    PlayerItem.PlayerName = ply:Nick()
    PlayerItem:SetText(PlayerItem.PlayerName)
    PlayerItem:SetFont("Minigames.Text")
    PlayerItem:SetTextColor(color_white)

    local State = ply == LocalPlayer() and PLAYER_OWNER or PLAYER_NOT_INGAME
    local InGame, Owner = Minigames.PlayerInGame(ply)
    if InGame then
        if Owner == LocalPlayer() then
            State = PLAYER_INGAME
        elseif ply == LocalPlayer() then
            State = PLAYER_OWNER
        else
            State = PLAYER_INGAME_OTHER
        end
    end

    PlayerItem.State = State
    PlayerItem.Paint = PlayerButtonPaint

    PlayerItem.DoClick = function()
        DoPlayerListAction(ply, PlayerListAction.TOGGLE)
    end
    PlayerItem.DoRightClick = function()
        if not IsValid(PlayerContextMenu) then
            PlayerContextMenu = DermaMenu()

            PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.add"), function()
                DoPlayerListAction(ply, PlayerListAction.ADD)
            end):SetIcon("icon16/add.png")

            PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.remove"), function()
                DoPlayerListAction(ply, PlayerListAction.REMOVE)
            end):SetIcon("icon16/delete.png")

            PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.toggle"), function()
                DoPlayerListAction(ply, PlayerListAction.TOGGLE)
            end):SetIcon("icon16/arrow_switch.png")

            PlayerContextMenu:AddSpacer()

            PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.sendtogame"), function()
                DoPlayerListAction(ply, PlayerListAction.SENDTOGAME)
            end):SetIcon("icon16/world_go.png")

            PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.sendtooldpos"), function()
                DoPlayerListAction(ply, PlayerListAction.SENDTOOLDPOS)
            end):SetIcon("icon16/world.png")

            PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.sendtospawn"), function()
                DoPlayerListAction(ply, PlayerListAction.SENDTOSPAWN)
            end):SetIcon("icon16/world_link.png")

            PlayerContextMenu:AddSpacer()

            if PlayerItem.State == PLAYER_INGAME then
                PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.mute"), function()
                    DoPlayerListAction(ply, PlayerListAction.MUTE)
                end):SetIcon("icon16/sound_mute.png")

                PlayerContextMenu:AddOption(Minigames.GetPhrase("playerlist.unmute"), function()
                    DoPlayerListAction(ply, PlayerListAction.UNMUTE)
                end):SetIcon("icon16/sound.png")
            end

        end

        PlayerContextMenu:Open()
    end

    return PlayerItem
end

function PANEL:Init()
    self.PlayerLinkedToPanel = {}

    self:SetSize(ScrW() * 0.2, ScrH() * 0.3)
    self:SetSizable(true)
    self:SetDraggable(true)
    self:ShowCloseButton(false)

    self:SetTitle(Minigames.GetPhrase("setupmenu.players"))

    self:SetMinWidth(200)
    self:SetMinHeight(63)

    self.LocalOwner = self:AddPlayer(LocalPlayer(), self)
    self.LocalOwner:Dock(TOP)
    self.LocalOwner:DockMargin(3, 3, 3, 3)
    self.LocalOwner:SetTall(24)

    self.PlayerLinkedToPanel[LocalPlayer()] = self.LocalOwner

    self.PlayersCanHearOwner = self:Add("DCheckBoxLabel")
    self.PlayersCanHearOwner:Dock(TOP)
    self.PlayersCanHearOwner:DockMargin(3, 3, 3, 3)
    self.PlayersCanHearOwner:SetTall(24)
    self.PlayersCanHearOwner:SetText(Minigames.GetPhrase("playerlist.hearowner"))
    self.PlayersCanHearOwner:SetValue(PlayersCanHeardOwner:GetBool())

    self.PlayersCanHearOwner.OnChange = function(_, value)
        PlayersCanHeardOwner:SetBool(value)
    end

    self.MuteAllPlayers = self:Add("DCheckBoxLabel")
    self.MuteAllPlayers:Dock(TOP)
    self.MuteAllPlayers:DockMargin(3, 3, 3, 3)
    self.MuteAllPlayers:SetTall(24)
    self.MuteAllPlayers:SetText(Minigames.GetPhrase("playerlist.muteall"))
    self.MuteAllPlayers:SetValue(MuteAllPlayers:GetBool())

    self.MuteAllPlayers.OnChange = function(_, value)
        MuteAllPlayers:SetBool(value)
    end

    self.PlayersCanHearThemselves = self:Add("DCheckBoxLabel")
    self.PlayersCanHearThemselves:Dock(TOP)
    self.PlayersCanHearThemselves:DockMargin(3, 3, 3, 3)
    self.PlayersCanHearThemselves:SetTall(24)
    self.PlayersCanHearThemselves:SetText(Minigames.GetPhrase("playerlist.hearself"))
    self.PlayersCanHearThemselves:SetValue(PlayersCanHeardThemselves:GetBool())

    self.PlayersCanHearThemselves.OnChange = function(_, value)
        PlayersCanHeardThemselves:SetBool(value)
    end

    if engine.ActiveGamemode() ~= "darkrp" then
        self.PlayersCanHearThemselves:Hide()
    end

    self.BroadcastGameJoin = self:Add("DButton")
    self.BroadcastGameJoin:Dock(TOP)
    self.BroadcastGameJoin:DockMargin(3, 3, 3, 3)
    self.BroadcastGameJoin:SetTall(24)
    self.BroadcastGameJoin:SetText(Minigames.GetPhrase("playerlist.broadcast"))
    self.BroadcastGameJoin:SetTextColor(color_white)
    self.BroadcastGameJoin.DoClick = function()
        if not Minigames.IsAllowed() then return end
        if GetGlobal2Entity("Minigames.CurrentGameWaiting", NULL) ~= NULL then return end

        net.Start("Minigames.BroadcastGameJoin")
        net.SendToServer()
    end

    local BroadcastCanBeEnabled = (
        Minigames.GetOwnerGame( LocalPlayer() ) ~= nil and
        not Minigames.GetOwnerGame( LocalPlayer() ):IsActive() or
        GetGlobal2Entity("Minigames.CurrentGameWaiting", NULL) ~= NULL
    )

    self.BroadcastGameJoin:SetEnabled(BroadcastCanBeEnabled)
    self.BroadcastGameJoin.Paint = ButtonPaint

    local HorizontalLine = self:Add("Panel")
    HorizontalLine:Dock(TOP)
    HorizontalLine:DockMargin(4, 4, 4, 4)
    HorizontalLine:SetTall(1)
    HorizontalLine.Paint = function(_, w, h)
        surface.SetDrawColor(Grayest)
        surface.DrawRect(0, 0, w, h)
    end

    self.PlayerList = self:Add("DScrollPanel")
    self.PlayerList:Dock(FILL)
    self.PlayerList.Paint = nil
    self.PlayerList.VBar.Paint = nil

    local Players = player.GetAll()
    table.sort(Players, function(a, b) return a:Nick() < b:Nick() end)

    for _, ply in ipairs(Players) do
        if ply == LocalPlayer() then continue end

        local PlayerItem = self:AddPlayer(ply, self.PlayerList)
        PlayerItem:Dock(TOP)
        PlayerItem:DockMargin(3, 3, 3, 3)
        PlayerItem:SetTall(24)

        self.PlayerLinkedToPanel[ply] = PlayerItem
    end
end

PANEL.Paint = Minigames.Paint


vgui.Register("Minigames.PlayerList", PANEL, "DFrame")
--addons/minigame-tool-assistant/lua/minigames/games/gamebase/sound.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/games/russianroulette.lua:
--[[--------------------------------------------
                Russian Roulette
--------------------------------------------]]--

local TableModel = "models/props_c17/FurnitureTable001a.mdl"
local TableOffsetPos = Vector(0, 0, 18)

local WeaponModel = "models/weapons/w_357.mdl"
local WeaponOffsetPos = Vector(-7, 3, 19)
local WeaponAngle = Angle(0, 0, 90)
local WeaponSoundEmpty = "weapons/pistol/pistol_empty.wav"
local WeaponSoundFire = "weapons/357/357_fire2.wav"
local WeaponSoundSpin = "weapons/357/357_spin1.wav"

local WeaponActivePos = Vector(0, 0, 37)
local WeaponActiveAngle = Angle(4, 0, 0)

local ColorTransparent = Color( 255, 255, 255, 150 )

local isnumber = isnumber

--[[----------------------------
       Initial Game Config
----------------------------]]--

local GameScript = Minigames.CreateNewGame()

GameScript:SetGameName("Russian Roulette")

GameScript:AddHeader("!gameconfig")

GameScript:AddConfig("DecisionTime", {
    min = 5,
    max = 60,
    def = 10,
})

GameScript:AddConfig("MagazineSize", {
    min = 3,
    max = 8,
    def = 6,
})

--[[
GameScript:AddConfig("ResetOnFire", {
    def = true
})
--]]

GameScript:AddHeader("#bots")

GameScript:AddConfig("bots", {
    min = 0,
    max = 20,
    def = 5,
})


GameScript:AddNewVar("BulletPosition", "number", 0)
GameScript:AddNewVar("CurrentPosition", "number", 0)

--[[----------------------------
          Trigger Events
----------------------------]]--

GameScript:AddHook( "RUSSIANROULETTE PostPlayerDeath" )

function GameScript:OnPlayerChanged(ply, Joined)
    if not self:IsActive() then return end

    local AllPlayers = self:GetPlayers(true)
    local AllBots = self.__Bots

    if #AllPlayers == 1 and #AllBots == 0 then
        self:SetPlayerWinner(AllPlayers[1])
        self:StopGame()
    elseif #AllPlayers == 0 and #AllBots <= 1 then
        self:StopGame()
    end
end


--[[----------------------------
          Network Data
----------------------------]]--

GameScript.MagazineSize = 0

GameScript:RegisterNetworkData("CurrentPosition", isnumber, function(self)
    return self:GetCurrentPosition()
end)

GameScript:RegisterNetworkData("CurrentPositionBullet", isnumber, function(self)
    return self:GetBulletPosition()
end)

GameScript:RegisterNetworkData("MagazineSize", isnumber, function(self)
    return self.MagazineSize
end)


--[[----------------------------
            Bot Logic
----------------------------]]--

function GameScript:CanSkip(ply)
    return ply:GetNWBool("RussianRoulette.CanSkip", false)
end

function GameScript:SetCanSkip(ply, bool)
    ply:SetNWBool("RussianRoulette.CanSkip", bool)
end

function GameScript:BotThink(bot)
    local CanSkip = self:CanSkip(bot)
    local DecideToShoot = true

    if ( CanSkip and ( math.random(1, 100) >= 50 ) ) then
        DecideToShoot = false
    end

    if DecideToShoot then
        if ( CanSkip == false ) then
            self:SetCanSkip(bot, true)
        end
    else
        self:SetCanSkip(bot, false)
    end

    return DecideToShoot
end



--[[----------------------------
           Weapon Logic
----------------------------]]--

function GameScript:WeaponPlaySound(snd)
    self.MainWeapon:EmitSound(snd, 100, 100, 1, CHAN_WEAPON)
end

function GameScript:WeaponSetState(State)
    self.MainWeapon:SetPos(self.MainTable:GetPos() + (State and WeaponActivePos or WeaponOffsetPos))
    self.MainWeapon:SetAngles(State and WeaponActiveAngle or WeaponAngle)
end

function GameScript:PointTo(ent)
    if not IsValid(ent) then return end

    local ang = (ent:GetPos() - self.MainWeapon:GetPos()):Angle()
    ang.p = 4
    ang.r = 0

    self.MainWeapon:SetAngles(ang)
end

function GameScript:WeaponShuffleMagazine()
    local BulletPosition = math.random(2, self.MagazineSize - 1)

    self:SetBulletPosition(BulletPosition)
    self:SendNWCurrentPositionBullet()
end

function GameScript:WeaponFire(ply)
    self:SetCurrentPosition(self:GetCurrentPosition() + 1)

    local CurrentPos = self:GetCurrentPosition()

    if ( CurrentPos > self.MagazineSize ) then
        self:SetCurrentPosition(1)
    elseif ( CurrentPos == self.MagazineSize ) then
        self:WeaponShuffleMagazine()
    end

    return self:GetBulletPosition() == self:GetCurrentPosition()
end

function GameScript:BulletOnNextPosition()
    local CurrentPos = self:GetCurrentPosition() + 1

    if ( CurrentPos > self.MagazineSize ) then
        CurrentPos = 1
    end

    return self:GetBulletPosition() == CurrentPos
end


--[[----------------------------
        Minigame Creation
----------------------------]]--

function GameScript:SpawnGame( trace )
    -- Replicate to owner
    self:SendNWMagazineSize()
    self:SendNWCurrentPositionBullet()
    self:SendNWCurrentPosition()

    self.MainTable = self:CreateEntity("minigame_prop")
    self.MainTable:SetModel(TableModel)
    self.MainTable:SetPos(trace.HitPos + TableOffsetPos)
    self.MainTable:Spawn()

    -- constraint.Keepupright(self.MainTable, self.MainTable:GetAngles(), 0, 1000)

    self.MainWeapon = self:CreateEntity("minigame_prop")
    self.MainWeapon:SetModel(WeaponModel)
    self.MainWeapon:SetPos(self.MainTable:GetPos() + WeaponOffsetPos)
    self.MainWeapon:SetAngles(WeaponAngle)
    self.MainWeapon:Spawn()

    self:SpawnPlayZone()

    return true
end

--[[---------------------------
         Game Functions
---------------------------]]--

function GameScript:FullyStartGame()
    local GameLogic = self:CreateChronometer("MainGame")
    GameLogic:SetLoop(true)
    GameLogic:SetVariable({
        Pos = 0,
        Players = self.AllPlayers,
        CurrentPlayer = NULL
    })

    GameLogic:AddAction(function(Var)
        if not self:IsActive() then return true end

        Var.Pos = Var.Pos + 1

        if ( Var.Pos > #Var.Players ) then
            Var.Pos = 1
        end

        Var.CurrentPlayer = Var.Players[Var.Pos]

        self:PointTo(Var.CurrentPlayer)

        if self:IsBot(Var.CurrentPlayer) then
            Var.CurrentPlayer:EnableWeapon()
        end

        self:WeaponPlaySound(WeaponSoundSpin)
    end)

    GameLogic:Wait(0.5)

    GameLogic:AddAction(function(Var)
        if not IsValid(Var.CurrentPlayer) then return end
        if self:IsBot(Var.CurrentPlayer) then return end

        Var.CurrentPlayer:Give("minigame_russianroulette")
        Var.CurrentPlayer:SelectWeapon("minigame_russianroulette")
    end)

    GameLogic:WaitUntil(function(Var)
        -- Player somehow got disconnected
        if not IsValid(Var.CurrentPlayer) then return true end

        return self:IsBot(Var.CurrentPlayer) or Var.CurrentPlayer:GetNWBool("RussianRoulette.Ready", false)
    end, self.DecisionTime)

    GameLogic:AddAction(function(Var)
        if not self:IsActive() then return true end
        if not IsValid(Var.CurrentPlayer) then
            table.remove(Var.Players, Var.Pos)
            return
        end

        local DecideToShoot = false
        local IsABot = self:IsBot(Var.CurrentPlayer)

        if IsABot then
            Var.CurrentPlayer:DisableWeapon()
            DecideToShoot = self:BotThink(Var.CurrentPlayer)
        else
            Var.CurrentPlayer:StripWeapon("minigame_russianroulette")
            DecideToShoot = ( Var.CurrentPlayer:GetNWBool("RussianRoulette.Ready", false) == false ) or Var.CurrentPlayer:GetNWBool("RussianRoulette.Decision", true)
        end

        if DecideToShoot then
            local IsDead = self:WeaponFire()

            if IsDead then
                local Loser = table.remove(Var.Players, Var.Pos)

                Var.Pos = Var.Pos - 1

                if IsABot then
                    self:RemoveBot(Loser)
                else
                    Loser:Kill()
                end

                self:WeaponPlaySound(WeaponSoundFire)
            else
                self:SetCanSkip(Var.CurrentPlayer, true)
                self:WeaponPlaySound(WeaponSoundEmpty)
            end
        else
            if IsABot then
                Var.CurrentPlayer:NegativeComment()
            end
            self:SetCanSkip(Var.CurrentPlayer, false)
        end

        Var.CurrentPlayer:SetNWBool("RussianRoulette.Ready", false)
        self:SendNWCurrentPosition()
    end)

    GameLogic:Wait(0.5)
    GameLogic:Start()
end

function GameScript:SetupPlayers()
    local BotsAmount = self:GetOwnerConfig("bots")
    self.AllPlayers = self:GetPlayers(true)

    local TotalPlayers = #self.AllPlayers + BotsAmount
    if TotalPlayers < 2 then return false end

    for i = 1, BotsAmount do
        local Bot = self:AddBot()
        table.insert(self.AllPlayers, Bot)
    end

    table.Shuffle(self.AllPlayers)

    local PosRadius = (360 / TotalPlayers)
    local PosPos = 0
    local TablePos = self.MainTable:GetPos()

    local PosAwayFromTable = 100 + (TotalPlayers * 2)

    for i, ply in ipairs(self.AllPlayers) do
        ply:SetPos( TablePos + Vector(
            math.cos( math.rad(PosPos * PosRadius) ) * PosAwayFromTable,
            math.sin( math.rad(PosPos * PosRadius) ) * PosAwayFromTable,
            0
        ) ) -- IDK WHAT THIS DOES

        if self:IsBot(ply) then
            ply:SetAngles( (TablePos - ply:GetPos()):Angle() )
        else
            ply:SetVelocity( ply:GetVelocity() * -1 )
            ply:SetEyeAngles( (TablePos - ply:GetPos()):Angle() )
        end

        PosPos = PosPos + 1
    end

    local PreGame = self:CreateChronometer("PreGame")
    PreGame:SetLoop(TotalPlayers)
    PreGame:SetVariable({Pos = 1})

    PreGame:Wait(2.1 / TotalPlayers)
    PreGame:AddAction(function(Var)
        Var.Pos = Var.Pos + 1
        self:PointTo( self.AllPlayers[Var.Pos] or self.AllPlayers[1] )

        if ( Var.Pos == TotalPlayers + 1 ) then
            self:FullyStartGame()
        end
    end)

    PreGame:Start()

    return true
end

--[[----------------------------
          Main Functions
----------------------------]]--

function GameScript:StartGame()
    local MoreThanOne = self:SetupPlayers()

    if MoreThanOne then
        self:SetCurrentPosition(1)
        self:WeaponShuffleMagazine()
        self:WeaponSetState(true)
        self:PlayGameStartSound()

        self:SendNWMagazineSize()
        self:SendNWCurrentPosition()

        for _, ply in ipairs(self:GetPlayers(true)) do
            ply:SetNWBool("RussianRoulette.Ready", false)
            ply:SetNWBool("RussianRoulette.Decision", false)
            self:SetCanSkip(ply, true)
        end

        return Minigames.GameStart( self )
    end

    return false
end

function GameScript:StopGame()
    self:RemoveChronometer("PreGame")
    self:RemoveChronometer("MainGame")

    for _, ply in ipairs(self:GetPlayers(true)) do
        ply:StripWeapon("minigame_russianroulette")
    end

    self:RemoveAllBots()

    self.MagazineSize = 0
    self:SetBulletPosition(0)
    self:SetCurrentPosition(0)

    self:SendNWMagazineSize()
    self:SendNWCurrentPositionBullet()
    self:SendNWCurrentPosition()

    self:WeaponSetState(false)

    return Minigames.GameStop( self )
end

function GameScript:ToggleGame()
    local Result = false

    self.ResetOnFire = self:GetOwnerConfig("ResetOnFire")
    self.DecisionTime = self:GetOwnerConfig("DecisionTime")
    self.MagazineSize = self:GetOwnerConfig("MagazineSize")

    if self:IsActive() then
        Result = self:StopGame()
    else
        Result = self:StartGame()
    end

    return Result
end

--[[----------------------------
        Clientside Script
----------------------------]]--

local CS_Data = {
    MagazineSize = 0,
    CurrentPosBullet = 0,
    CurrentPos = 0
}

if CLIENT then
    util.PrecacheModel(TableModel)
    util.PrecacheModel(WeaponModel)

    if IsValid( CS_TableModel ) then
        CS_TableModel:Remove()
    end

    if IsValid( CS_WeaponModel ) then
        CS_WeaponModel:Remove()
    end

    function GameScript:RenderGame( trace )
        if Minigames.GetOwnerGame( LocalPlayer() ) then return end

        if not IsValid( CS_TableModel ) then
            CS_TableModel = ClientsideModel( TableModel )
        end

        if not IsValid( CS_WeaponModel ) then
            CS_WeaponModel = ClientsideModel( WeaponModel )
        end

        CS_TableModel:SetRenderMode( RENDERMODE_TRANSCOLOR )
        CS_TableModel:SetColor( ColorTransparent )

        CS_WeaponModel:SetRenderMode( RENDERMODE_TRANSCOLOR )
        CS_WeaponModel:SetColor( ColorTransparent )

        CS_TableModel:SetPos( trace.HitPos + TableOffsetPos )
        CS_WeaponModel:SetPos( CS_TableModel:GetPos() + WeaponOffsetPos )
        CS_WeaponModel:SetAngles( WeaponAngle )
    end

    GameScript:CatchData("MagazineSize", function(Data, SubGameScript)
        CS_Data.MagazineSize = Data
    end)

    GameScript:CatchData("CurrentPositionBullet", function(Data)
        CS_Data.CurrentPosBullet = Data
    end)

    GameScript:CatchData("CurrentPosition", function(Data)
        CS_Data.CurrentPos = Data
    end)

    hook.Add("Minigames.PostNewGame", "Minigames.RemoveTable", function()
        if IsValid( CS_TableModel ) then
            CS_TableModel:Remove()
        end

        if IsValid( CS_WeaponModel ) then
            CS_WeaponModel:Remove()
        end
    end)

end


--[[----------------------------
        Action Functions
----------------------------]]--

function GameScript:LeftClick( trace, owner, FirstTime )
    local Response = false

    if FirstTime then
        Response = self:SpawnGame( trace )
    else
        if IsValid( trace.Entity ) and trace.Entity:IsPlayer() then
            Response = self:TogglePlayer( trace.Entity )
        end
    end

    return Response
end

function GameScript:RightClick( trace, owner )
    return self:ToggleGame()
end

function GameScript:Think( trace, owner )
    if CLIENT then
        self:RenderGame( trace )
    end
end

function GameScript:RollUp( trace, owner )
    if CLIENT then
        if IsValid( CS_TableModel ) then
            CS_TableModel:Remove()
        end

        if IsValid( CS_WeaponModel ) then
            CS_WeaponModel:Remove()
        end
    end
end

--[[--------------------------------------------
                  Draw HUD
--------------------------------------------]]--

local BlackColor = Color(0, 0, 0, 230)
local StateNoBullet = Color(100, 100, 100, 200)
local StateHadBullet = Color(180, 50, 50, 200)
local Round = 4

--[[----------------------------
           Main Config
----------------------------]]--

local DataCached = false
local CachedY, CachedX = 0, 0

function GameScript:DrawHUD()
    if not Minigames.GetOwnerGame( LocalPlayer() ) then return end
    if not DataCached then
        CachedX = math.max( ScrW() * 0.1, 100 )
        CachedY = ScrH() / 2
    end

    local MenuHeight = 90 + ( CS_Data.MagazineSize * 28 )
    CachedY = CachedY - ( MenuHeight * 0.4 )

    draw.RoundedBox( Round, CachedX, CachedY, 220, MenuHeight, BlackColor )
    draw.SimpleText( Minigames.GetPhrase("russianroulette.name"), "Minigames.SubTitle", CachedX + 110, CachedY + 10, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

    for i = 1, CS_Data.MagazineSize do
        local BulletX = CachedX + 110
        local BulletY = CachedY + 30 + ( i * 28 )

        draw.RoundedBox( Round, BulletX - 12.5, BulletY - 12.5, 25, 25, ( i == CS_Data.CurrentPosBullet ) and StateHadBullet or StateNoBullet )

        if ( i == CS_Data.CurrentPos ) then
            draw.RoundedBox( Round, BulletX - 5, BulletY - 5, 10, 10, Color(255, 255, 255) )
        end
    end
end

Minigames.RegisterNewGame(GameScript)
--addons/minigame-tool-assistant/lua/minigames/rewards/dailyrewards.lua:
local Reward = Minigames.CreateNewReward()

Reward:SetName("Daily Rewards")
Reward:SetNameAmount("Daily Rewards Premium")
Reward:SetIcon("minigames/icons/dailyrewards.png")

Reward:SetFunctionReward(function(owner, ply, season)
    RunConsoleCommand( "dailyrewards_giveprem", ply:SteamID64(), season )
end)

Reward:AddArgument({
    ["Name"] = "Season",
    ["Type"] = "Text",
    ["Default"] = "season1",
    ["Placeholder"] = "The season name"
})

Minigames.RegisterReward(Reward)
--addons/minigame-tool-assistant/lua/minigames/rewards/giveweapon.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/includes/modules/eventemitter.lua:
---
-- EventEmitter
--
-- Based off of Wolfy87's JavaScript EventEmitter
--
local EventEmitter = {}

local function indexOfListener(listeners, listener)
	local value
	local i = #listeners


	while i > 0 do
		value = listeners[i]
		if istable(value) and value.listener == listener then
			return i
		end
		i = i - 1
	end

	return -1
end

function EventEmitter:new(obj)
	if obj then
		table.Inherit(obj, self)
	else
		return setmetatable({}, self)
	end
end

function EventEmitter:getListeners(evt)
	local events = self:_getEvents()
	local response

	-- TODO: accept pattern matching

	if not events[evt] then
		local tbl = {}
		tbl.__array = true
		events[evt] = tbl
	end

	response = events[evt]

	return response
end

--[[function EventEmitter:flattenListeners(listeners)

end]]

function EventEmitter:getListenersAsObject(evt)
	local listeners = self:getListeners(evt)
	local response

	if listeners.__array then
		response = {}
		response[evt] = listeners
	end

	return response or listeners, wrapped
end

function EventEmitter:addListener(evt, listener)
	local listeners = self:getListenersAsObject(evt)
	local listenerIsWrapped = istable(listener)

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) and indexOfListener(listeners[key], listener) == -1 then
			local value

			if listenerIsWrapped then
				value = listener
			else
				value = {
					listener = listener,
					once = false
				}
			end

			table.insert(listeners[key], value)
		end
	end

	return self
end

EventEmitter.on = EventEmitter.addListener

function EventEmitter:addOnceListener(evt, listener)
	return self:addListener(evt, {
		listener = listener,
		once = true
	})
end

EventEmitter.once = EventEmitter.addOnceListener

function EventEmitter:removeListener(evt, listener)
	local listeners = self:getListenersAsObject(evt)
	local index

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) then
			index = indexOfListener(listeners[key], listener)

			if index ~= -1 then
				table.remove(listeners[key], index)
			end
		end
	end

	return self
end

EventEmitter.off = EventEmitter.removeListener

--[[function EventEmitter:addListeners(evt, listeners)

end]]

function EventEmitter:removeEvent(evt)
	local typeStr = type(evt)
	local events = self:_getEvents()
	local key

	if typeStr == 'string' then
		events[evt] = nil
	else
		self._events = nil
	end

	return self
end

EventEmitter.removeAllListeners = EventEmitter.removeEvent

function EventEmitter:emitEvent(evt, ...)
	local listeners = self:getListenersAsObject(evt)
	local listener, i, key, response

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) then
			i = #listeners[key]

			while i > 0 do
				listener = listeners[key][i]

				if listener.once == true then
					self:removeListener(evt, listener.listener)
				end

				response = listener.listener(...)

				if response == self:_getOnceReturnValue() then
					self:removeListener(evt, listener.listener)
				end

				i = i - 1
			end
		end
	end

	return self
end

EventEmitter.trigger = EventEmitter.emitEvent
EventEmitter.emit = EventEmitter.emitEvent

function EventEmitter:setOnceReturnValue(value)
	self._onceReturnValue = value
	return self
end

function EventEmitter:_getOnceReturnValue()
	if rawget(self, '_onceReturnValue') then
		return self._onceReturnValue
	else
		return true
	end
end

function EventEmitter:_getEvents()
	if not self._events then
		self._events = {}
	end

	return self._events
end

_G.EventEmitter = EventEmitter

--addons/media_player_fixed_edition/lua/autorun/includes/modules/inputhook.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/includes/modules/htmlmaterial.lua:
local ipairs = ipairs
local table = table
local timer = timer
local ceil = math.ceil
local log = math.log
local pow = math.pow

local tblconcat = table.concat

local cache = {}
local downloads = {}
local styles = {}

local embedHtml = [[
<!doctype html>
<html>
<head>
	<meta charset="utf-8">
</head>
<body>
	<script>
	var src = '%s';
	</script>
	<img id="mat">

	<style>
	html, body {
		width: 100%%;
		height: 100%%;
		margin: 0;
		padding: 0;
		overflow: hidden;
	}
	%s
	</style>

	<script>
	var mat = document.getElementById('mat');
	mat.onload = function() {
		setTimeout(function() {
			gmod.imageLoaded();
		}, 100);
	};
	mat.onerror = function() {
		gmod.imageLoaded();
	};
	mat.src = src;
	</script>
</body>
</html>]]

local UpdateTimerName = "HtmlMatUpdate"
local TimerRunning = false

local function updateCache(download)
	download.browser:UpdateHTMLTexture()
	cache[download.key] = download.browser:GetHTMLMaterial()
end

local function updateMaterials()
	for _, download in ipairs(downloads) do
		updateCache(download)
	end
end

local function onImageLoaded(key, browser)
	local idx

	for k, v in pairs(downloads) do
		if v.key == key then
			idx = k
			break
		end
	end

	if idx > 0 then
		-- html materials are unique to each browser; re-using a browser will
		-- result in previous materials being updated. Therefore, used browsers
		-- must be destroyed rather than pooled.
		local download = downloads[idx]
		browserpool.release(browser, true)
		table.remove(downloads, idx)
	end

	if #downloads == 0 and TimerRunning then
		timer.Remove(UpdateTimerName)
		TimerRunning = false
	end
end

local DefaultMat = Material("vgui/white")
local DefaultWidth = 128
local DefaultStyle = {}

local function enqueueUrl( url, styleName, key, callback )
	cache[key] = DefaultMat

	browserpool.get(function(browser)
		local style = styles[styleName] or DefaultStyle
		local w = style.width or DefaultWidth
		local h = style.height or w

		browser:SetSize( w, h )

		local download = {
			url = url,
			key = key,
			browser = browser
		}

		table.insert(downloads, download)

		browser:AddFunction("gmod", "imageLoaded", function()
			updateCache(download)
			onImageLoaded(key, browser)

			if isfunction(callback) then
				callback( cache[key] )
			end
		end)

		if not TimerRunning then
			timer.Create(UpdateTimerName, 0.05, 0, updateMaterials)
			timer.Start(UpdateTimerName)
			TimerRunning = true
		end

		local html = (style.html or embedHtml):format(url, style.css or '')
		browser:SetHTML( html )
	end)
end

-- cached for performance
local MAT_STR_TABLE = { '', '@', '' }

---
-- Renders a URL as a material.
--
-- @param url		URL.
-- @param style		HTMLMaterial style.
--
function HTMLMaterial( url, style, callback )
	if not url then
		return DefaultMat
	end

	local key

	-- Build unique key for material
	if style then
		MAT_STR_TABLE[1] = url
		MAT_STR_TABLE[3] = style
		key = tblconcat( MAT_STR_TABLE )
	else
		key = url
	end

	-- Enqueue the URL to be downloaded if it hasn't been loaded yet.
	if cache[key] == nil then
		enqueueUrl( url, style, key, callback )
	elseif callback then
		callback( cache[key] )
	end

	-- Return cached URL
	return cache[key]
end

local SetDrawColor = surface.SetDrawColor
local SetMaterial = surface.SetMaterial
local DrawTexturedRect = surface.DrawTexturedRect

function CeilPower2(n)
	return pow(2, ceil(log(n) / log(2)))
end

function DrawHTMLMaterial( url, styleName, w, h )
	local mat = HTMLMaterial( url, styleName )
	local style = styles[styleName] or DefaultStyle

	-- Desired dimensions
	local width = style.width or DefaultWidth
	local height = style.height or w

	-- Convert to scalar
	w = w / width
	h = h / height

	-- Fix for non-power-of-two html panel size
	width = CeilPower2(width)
	height = CeilPower2(height)

	SetDrawColor( color_white )
	SetMaterial( mat )
	DrawTexturedRect( 0, 0, w * width, h * height )
end

---
-- Registers a style that can be used with `HTMLMaterial`
--
-- @param name		Style name.
-- @param params	Table of style parameters.
--
function AddHTMLMaterialStyle( name, params, base )
	params = params or {}

	if base then
		table.Merge( params, table.Copy( styles[base] or {} ) )
	end

	styles[name] = params
end

HTMLMAT_STYLE_BLUR       = 'htmlmat.style.blur'
HTMLMAT_STYLE_GRAYSCALE  = 'htmlmat.style.grayscale'
HTMLMAT_STYLE_SEPIA      = 'htmlmat.style.sepia'
HTMLMAT_STYLE_INVERT     = 'htmlmat.style.invert'
HTMLMAT_STYLE_CIRCLE     = 'htmlmat.style.circle'
HTMLMAT_STYLE_COVER      = 'htmlmat.style.cover'
HTMLMAT_STYLE_COVER_IMG  = 'htmlmat.style.coverimg'

AddHTMLMaterialStyle( HTMLMAT_STYLE_BLUR, {
	css = [[img {
	-webkit-filter: blur(8px);
	-webkit-transform: scale(1.1, 1.1);
}]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_GRAYSCALE, {
	css = [[img { -webkit-filter: grayscale(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_SEPIA, {
	css = [[img { -webkit-filter: sepia(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_INVERT, {
	css = [[img { -webkit-filter: invert(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_CIRCLE, {
	css = [[img { border-radius: 50%; }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_COVER, {
	html = [[
<script>
var src = '%s';
</script>

<style type="text/css">
html, body {
	width: 100%%;
	height: 100%%;
	margin: 0;
	padding: 0;
	overflow: hidden;
}

#mat {
	background: no-repeat 50%% 50%%;
	background-size: cover;
	width: 100%%;
	height: 100%%;
}

%s
</style>

<div id="mat"></div>

<script type="application/javascript">
var mat = document.getElementById('mat');
mat.style.backgroundImage = 'url('+src+')';

var img = new Image();
img.onload = function() {
	setTimeout(function() {
		gmod.imageLoaded();
	}, 100);
};
img.onerror = gmod.imageLoaded.bind(gmod);
img.src = src;
</script>
]]
})

-- Use this if you want to use -webkit-filter blur on the image;
-- you'll also need to use a transform to scale it a bit. This prevents
-- the edges from blurring as seen with background-size cover.
AddHTMLMaterialStyle( HTMLMAT_STYLE_COVER_IMG, {
	html = [[
<script>
var src = '%s';
</script>

<style type="text/css">
html, body {
	width: 100%%;
	height: 100%%;
	margin: 0;
	padding: 0;
	overflow: hidden;
}
img {
	width: auto;
	height: auto;
	position: absolute;
	top: 50%%;
	left: 50%%;
	-webkit-transform: translate(-50%%, -50%%);
}
%s
</style>

<img id="mat">

<script type="application/javascript">
var mat = document.getElementById('mat');
mat.onload = function() {
	if (mat.width > mat.height) {
		mat.style.height = '100%%';
	} else {
		mat.style.width = '100%%';
	}
	setTimeout(function() {
		gmod.imageLoaded();
	}, 100);
};
mat.onerror = function() {
	gmod.imageLoaded();
};
mat.src = src;
</script>
]]
})

--addons/media_player_fixed_edition/lua/mediaplayer/controls/dmediaplayerhtml.lua:
--
-- DMediaPlayerHTML
--
-- Improves upon the Cinema HTML control by adding:
-- Window object callbacks, HTML and JS console filtering, URL polling,
-- simulated mouse clicks, and proper fullscreen resizing.
--
-- Cinema HTML control reference:
-- https://github.com/pixeltailgames/cinema/blob/master/cinema/gamemode/modules/scoreboard/controls/cl_html.lua
--

local PANEL = {}

DEFINE_BASECLASS( "Panel" )

local DEBUG = false

local JS_CallbackHack = [[(function(){
	var funcname = '%s';
	window[funcname] = function(){
		_gm[funcname].apply(_gm,arguments);
	}
})();]]

local FilterCVar = CreateClientConVar( "js_console_filter", 0, true, false )

local FILTER_ALL = 0
local FILTER_NONE = 1

--[[---------------------------------------------------------

-----------------------------------------------------------]]


function PANEL:Init()

	self.JS = {}
	self.Callbacks = {}
	self.MouseActions = {}

	self.URL = "data:text/html,"

	hook.Add( "HUDPaint", self, function() self:HUDPaint() end )

end


function PANEL:OnDocumentReady( url )

	--
	-- Implement a console - because awesomium doesn't provide it for us anymore
	--
	local console_funcs = {"log","error","debug","warn","info"}
	for _, func in pairs(console_funcs) do
		self:AddFunction( "console", func, function(param)
			self:ConsoleMessage( param, func )
		end )
	end

	self:AddFunction( "gmod", "getUrl", function( url )
		self:SetURL( url )
	end )

end

function PANEL:Think()

	if self:IsLoading() then

		-- Call started loading
		if not self._loading then

			-- Get the page URL
			self:FetchPageURL()

			self._loading = true
			self:OnStartLoading()

		end

	else

		-- Call finished loading
		if self._loading then

			-- Get the page URL
			self:FetchPageURL()

			-- Hack to add window object callbacks
			if self.Callbacks.window then
				for funcname, callback in pairs(self.Callbacks.window) do
					self:RunJavascript( JS_CallbackHack:format(funcname) )
				end
			end

			self._loading = nil
			self:OnFinishLoading()

		end

		-- Run queued javascript
		if self.JS then
			for k, v in pairs( self.JS ) do
				self:RunJavascript( v )
			end
			self.JS = nil
		end

	end

	-- HACK: Poll page for URL change
	if not self._nextUrlPoll or self._nextUrlPoll < RealTime() then
		self:FetchPageURL()
		self._nextUrlPoll = RealTime() + 1
	end

end

function PANEL:FetchPageURL()
	local js = [[
		if (typeof gmod === 'object' && typeof gmod.getUrl === 'function') {
			gmod.getUrl(window.location.href);
		}
	]]
	self:RunJavascript(js)
end

function PANEL:GetURL()
	return self.URL
end

function PANEL:SetURL( url )
	local current = self.URL

	if current ~= url then
		self:OnURLChanged( url, current )
	end

	self.URL = url
end

function PANEL:OnURLChanged( new, old )
	if FilterCVar:GetInt() > FILTER_ALL then
		print( "URL Changed: " .. tostring(new) )
	end
end


--[[---------------------------------------------------------
	Awesomium Override Functions
-----------------------------------------------------------]]

function PANEL:SetSize( w, h, fullscreen )

	local keyboardEnabled = self:IsKeyboardInputEnabled()
	local mouseEnabled = self:IsMouseInputEnabled()

	if fullscreen then

		-- Cache fullscreen size
		local cw, ch = self:GetSize()
		self._OrigSize = { w = cw, h = ch }

		-- Render before the HUD
		self:ParentToHUD()

	elseif self._OrigSize then

		-- Restore cached size
		w = self._OrigSize.w
		h = self._OrigSize.h
		self._OrigSize = nil

		-- Reparent due to hud parented panels sometimes being inaccessible
		-- from Lua.
		self:SetParent( vgui.GetWorldPanel() )

	else
		self._OrigSize = nil
	end

	self:SetKeyboardInputEnabled( keyboardEnabled )
	self:SetMouseInputEnabled( mouseEnabled )

	if not (w and h) then return end

	BaseClass.SetSize( self, w, h )

end

function PANEL:OpenURL( url )

	if DEBUG then
		print("DMediaPlayerHTML.OpenURL", url)
	end

	self:SetURL( url )

	BaseClass.OpenURL( self, url )

end

function PANEL:SetHTML( html )

	if DEBUG then
		print("DMediaPlayerHTML.SetHTML")
		print(html)
	end

	BaseClass.SetHTML( self, html )

end


--[[---------------------------------------------------------
	Window loading events
-----------------------------------------------------------]]

--
-- Called when the page begins loading
--
function PANEL:OnStartLoading()

end

--
-- Called when the page finishes loading all assets
--
function PANEL:OnFinishLoading()

end


--[[---------------------------------------------------------
	Lua => JavaScript queue

	This code only runs when the page is finished loading;
	this means all assets (images, CSS, etc.) must load first!
-----------------------------------------------------------]]

function PANEL:QueueJavascript( js )

	--
	-- Can skip using the queue if there's nothing else in it
	--
	if not ( self.JS or self:IsLoading() ) then
		return self:RunJavascript( js )
	end

	self.JS = self.JS or {}

	table.insert( self.JS, js )
	self:Think()

end

PANEL.QueueJavaScript = PANEL.QueueJavascript
PANEL.Call = PANEL.QueueJavascript


--[[---------------------------------------------------------
	Handle console logging from JavaScript
-----------------------------------------------------------]]

PANEL.ConsoleColors = {
	["default"]	= Color(255,160,255),
	["text"]	= Color(255,255,255),
	["error"]	= Color(235,57,65),
	["warn"]	= Color(227,181,23),
	["info"]	= Color(100,173,229),
}

function PANEL:ConsoleMessage( ... )

	local filterLevel = FilterCVar:GetInt()

	local args = {...}
	local msg = args[1]

	-- Three arguments are passed in if an error occured
	if #args == 3 and filterLevel > FILTER_ALL then

		local script = args[2]
		local linenum = args[3]
		local col = self.ConsoleColors.error

		local out = {
			"[JavaScript]",
			msg,
			",",
			script,
			":",
			linenum,
			"\n"
		}

		MsgC( col, table.concat(out, " ") )

	else

		if not isstring( msg ) then
			msg = "*js variable* (" .. type(msg) .. ": " .. tostring(msg) .. ")"
		end

		-- Run Lua from JavaScript console logging (POTENTIALLY HARMFUL!)
		--[[if msg:StartWith( "RUNLUA:" ) then
			local strLua = msg:sub( 8 )

			SELF = self
			RunString( strLua )
			SELF = nil

			return
		end]]

		-- Play a sound from JavaScript console logging
		if msg:StartWith( "PLAY:" ) then
			local soundpath = msg:sub( 7 )
			surface.PlaySound( soundpath )
			return
		end

		if filterLevel == FILTER_ALL then return end

		local func = args[2]

		-- Output console message with prefix
		local prefixColor = self.ConsoleColors.default
		local prefix = "[HTML"
		if func and func:len() > 0 and func ~= "log" then
			if self.ConsoleColors[func] then
				prefixColor = self.ConsoleColors[func]
			end
			prefix = prefix .. ":" .. func:upper()
		end
		prefix = prefix .. "] "

		MsgC( prefixColor, prefix )
		MsgC( self.ConsoleColors.text, msg, "\n" )

	end

end


--[[---------------------------------------------------------
	JavaScript callbacks
-----------------------------------------------------------]]

local JSObjects = {
	window	= "_gm",
	this	= "_gm",
	_gm		= "window"
}

--
-- Called by the engine when a callback function is called
--
function PANEL:OnCallback( obj, func, args )

	-- Hack for adding window callbacks
	obj = JSObjects[obj] or obj

	if not self.Callbacks[ obj ] then return end

	--
	-- Use AddFunction to add functions to this.
	--
	local f = self.Callbacks[ obj ][ func ]

	if ( f ) then
		return f( unpack( args ) )
	end

end

--
-- Add a function to Javascript
--
function PANEL:AddFunction( obj, funcname, func )

	-- Hack for adding window callbacks
	-- obj = JSObjects[obj] or obj

	if obj == "this" then
		obj = "window"
	end

	-- Create the `object` if it doesn't exist
	if not self.Callbacks[ obj ] then
		self:NewObject( obj )
		self.Callbacks[ obj ] = {}
	end

	-- This creates the function in javascript (which redirects to c++ which calls OnCallback here)
	self:NewObjectCallback( JSObjects[obj] or obj, funcname )

	-- Store the function so OnCallback can find it and call it
	self.Callbacks[ obj ][ funcname ] = func

end


--[[---------------------------------------------------------
	Scrolling
-----------------------------------------------------------]]

local JS_RemoveScrollbars = "document.body.style.overflow = 'hidden';"
local JS_ScrollBy = "window.scrollBy(0, %d);"

function PANEL:RemoveScrollbars()
	self:QueueJavascript(JS_RemoveScrollbars)
end

function PANEL:Scroll( amount )
	self:QueueJavascript( JS_ScrollBy:format(amount) )
end


--[[---------------------------------------------------------
	Compatibility functions
-----------------------------------------------------------]]

function PANEL:OpeningURL( url )
end

function PANEL:FinishedURL( url )
end


--[[---------------------------------------------------------
	Simulated mouse clicks
-----------------------------------------------------------]]

function PANEL:HUDPaint()
	self:HandleMouseActions()
end

function PANEL:InjectMouseClick( x, y )
	if self._handlingMouseAction then
		return
	end

	local w, h = self:GetSize()
	table.insert( self.MouseActions, {
		x = math.Round(x * w),
		y = math.Round(y * h),
		tick = 0
	} )
end

function PANEL:HandleMouseActions()
	if #self.MouseActions == 0 then
		return
	end

	local action = self.MouseActions[1]
	action.tick = action.tick + 1

	if action.tick == 1 then
		-- show cursor
		self._handlingMouseAction = true
		self:SetZPos( 32767 )
		self:MoveToCursor( action.x, action.y )
		self:MakePopup()
		gui.EnableScreenClicker( true )
		gui.InternalCursorMoved( 0, 0 )
	elseif action.tick == 2 then
		local cx, cy = input.GetCursorPos()
		gui.InternalCursorMoved( cx, cy )
	elseif action.tick == 3 then
		-- simulate click; need to wait at least one frame
		gui.InternalMousePressed( MOUSE_LEFT )
		gui.InternalMouseReleased( MOUSE_LEFT )
	elseif action.tick > 3 then
		-- hide cursor
		gui.EnableScreenClicker( false )
		self:SetKeyboardInputEnabled( false )
		self:SetMouseInputEnabled( false )
		self:SetZPos( -32768 )
		table.remove( self.MouseActions, 1 )
		self._handlingMouseAction = nil
	end
end

function PANEL:MoveToCursor( xoffset, yoffset )
	xoffset = xoffset or 0
	yoffset = yoffset or 0

	local cx, cy = input.GetCursorPos()
	self:SetPos( cx - xoffset, cy - yoffset )
end

derma.DefineControl( "DMediaPlayerHTML", "", PANEL, "Awesomium" )

--addons/media_player_fixed_edition/lua/mediaplayer/controls/dmediaplayerrequest.lua:
local PANEL = {}
PANEL.HistoryWidth = 300
PANEL.BackgroundColor = Color(22, 22, 22)

local CloseTexture = Material( "theater/close.png" )

AccessorFunc( PANEL, "m_MediaPlayer", "MediaPlayer" )

function PANEL:Init()

	self:SetPaintBackgroundEnabled( true )
	self:SetFocusTopLevel( true )

	local w = math.Clamp( ScrW() - 100, 800, 1152 + self.HistoryWidth )
	local h = ScrH()
	if h > 800 then
		h = h * 3 / 4
	elseif h > 600 then
		h = h * 7 / 8
	end
	self:SetSize( w, h )

	self.CloseButton = vgui.Create( "DIconButton", self )
	self.CloseButton:SetSize( 32, 32 )
	self.CloseButton:SetIcon( "mp-close" )
	self.CloseButton:SetColor( Color( 250, 250, 250, 200 ) )
	self.CloseButton:SetZPos( 5 )
	self.CloseButton:SetText( "" )
	self.CloseButton.DoClick = function ( button )
		self:Close()
	end

	self.BrowserContainer = vgui.Create( "DPanel", self )
	self.BrowserContainer:Dock( FILL )

	self.Browser = vgui.Create( "DMediaPlayerHTML", self.BrowserContainer )
	self.Browser:Dock( FILL )

	self.Browser:AddFunction( "gmod", "requestUrl", function (url)
		MediaPlayer.MenuRequest( url )
		self:Close()
	end )

	self.Browser:AddFunction( "gmod", "openUrl", function (url)
		gui.OpenURL( url )
	end )

	self.Browser:AddFunction( "gmod", "getServices", function ()
		local mp = self.m_MediaPlayer

		if mp then
			self:SendServices( mp )
		end
	end )

	local requestUrl = MediaPlayer.GetConfigValue( "request.url" )
	self.Browser:OpenURL( requestUrl )

	self.Controls = vgui.Create( "MPHTMLControls", self.BrowserContainer )
	self.Controls:Dock( TOP )
	self.Controls:DockPadding( 0, 0, 32, 0 )
	self.Controls:SetHTML( self.Browser )
	self.Controls.BorderSize = 0

	-- Listen for all mouse press events
	hook.Add( "GUIMousePressed", self, self.OnGUIMousePressed )

end

local function GetServiceIDs( mp )
	-- Send list of supported services to the request page for filtering out
	-- service icons
	local serviceIDs = mp:GetSupportedServiceIDs()
	serviceIDs = table.concat( serviceIDs, "," )

	return serviceIDs
end

function PANEL:SendServices( mp )
	local js = "if (typeof window.setServices === 'function') { setServices('%s'); }"
	js = js:format( GetServiceIDs(mp) )

	self.Browser:RunJavascript( js )
	self.Browser:QueueJavascript( js )
end

function PANEL:SetMediaPlayer( mp )
	self.m_MediaPlayer = mp

	self:SendServices( mp )
end

function PANEL:Paint( w, h )

	-- Draw background for fully transparent webpages
	surface.SetDrawColor( self.BackgroundColor )
	surface.DrawRect( 0, 0, w, h )

	return true

end

function PANEL:OnRemove()
	hook.Remove( "GUIMousePressed", self )
end

function PANEL:Close()
	if IsValid(self.Browser) then
		self.Browser:Remove()
	end

	self:OnClose()
	self:Remove()
end

function PANEL:OnClose()

end

function PANEL:CheckClose()

	local x, y = self:CursorPos()

	-- Remove panel if mouse is clicked outside of itself
	if not (gui.IsGameUIVisible() or gui.IsConsoleVisible()) and
		( x < 0 or x > self:GetWide() or y < 0 or y > self:GetTall() ) then
		self:Close()
	end

end

function PANEL:PerformLayout( w, h )

	self.CloseButton:SetPos( w - 36, 2 )

end

---
-- Close the panel when the mouse has been pressed outside of the panel.
--
function PANEL:OnGUIMousePressed( key )

	if key == MOUSE_LEFT then
		self:CheckClose()
	end

end

vgui.Register( "MPRequestFrame", PANEL, "EditablePanel" )

--addons/media_player_fixed_edition/lua/mediaplayer/sh_mediaplayer.lua:
if SERVER then
	include "players/components/vote.lua"
	include "players/components/voteskip.lua"
end

--[[---------------------------------------------------------
	Media Player Types
-----------------------------------------------------------]]

MediaPlayer.Type = {}

local function setBaseClass( name, tbl )
	local classname = "mp_" .. name

	if MediaPlayer.Type[name] ~= nil then
		if MediaPlayer.DEBUG then
			Msg("Media player type '" .. name .. "' is already registered. ")
			Msg("Clearing baseclass...\n")
		end

		-- HACK: removes registered baseclass if it already exists to avoid Lua
		-- refresh table.Merge errors...
		local _, BaseClassTable = debug.getupvalue(baseclass.Get, 1)
		BaseClassTable[classname] = nil
	end

	baseclass.Set( classname, tbl )
end

---
-- Registers a media player type.
--
-- @param tbl	Media player type table.
--
function MediaPlayer.Register( tbl )

	local name = tbl.Name

	if not name then
		ErrorNoHalt("MediaPlayer.Register - Must include name property\n")
		debug.Trace()
		return
	end

	name = name:lower() -- always use lowercase names
	tbl.Name = name
	tbl.__index = tbl

	-- Set base meta table
	local base = tbl.Base or "base"
	if base and name ~= "base" then
		base = base:lower()

		if not MediaPlayer.Type[base] then
			ErrorNoHalt("MediaPlayer.Register - Invalid base name: " .. base .. "\n")
			debug.Trace()
			return
		end

		base = MediaPlayer.Type[base]

		setmetatable(tbl, {
			__index = base,
			__tostring = base.__tostring
		})
	end

	-- Store media player type as a base class
	setBaseClass( name, tbl )

	-- Save player type
	MediaPlayer.Type[name] = tbl

	if MediaPlayer.DEBUG then
		Msg( "MediaPlayer.Register\t" .. name .. "\n" )
	end

end

function MediaPlayer.IsValidType( type )
	return MediaPlayer.Type[type] ~= nil
end

-- Load players
do
	local path = "players/"
	local players = {
		"base", -- MUST LOAD FIRST!
		"entity"
	}

	for _, player in ipairs(players) do
		local clfile = path .. player .. "/cl_init.lua"
		local svfile = path .. player .. "/init.lua"

		MEDIAPLAYER = {}

		if SERVER then
			AddCSLuaFile(clfile)
			include(svfile)
		else
			include(clfile)
		end

		MediaPlayer.Register( MEDIAPLAYER )
		MEDIAPLAYER = nil
	end
end


--[[---------------------------------------------------------
	Media Player Helpers
-----------------------------------------------------------]]

MediaPlayer.List = MediaPlayer.List or {}
MediaPlayer._count = MediaPlayer._count or 0

---
-- Creates a media player object.
--
-- @param id		Media player ID.
-- @param type?		Media player type (defaults to 'base').
-- @return table	Media player object.
--
function MediaPlayer.Create( id, type )
	-- Inherit media player type
	local PlayerType = MediaPlayer.Type[type]
	PlayerType = PlayerType or MediaPlayer.Type.base

	-- Create media player object
	local mp = setmetatable( {}, { __index = PlayerType } )

	-- Assign unique ID
	if id then
		mp.id = id
	elseif SERVER then
		MediaPlayer._count = MediaPlayer._count + 1
		mp.id = MediaPlayer._count
	else
		mp.id = id or -1
	end

	mp:Init()

	-- Add to media player list
	MediaPlayer.List[mp.id] = mp

	if MediaPlayer.DEBUG then
		print( "Created Media Player", mp, mp.Name, type )
	end

	return mp
end

---
-- Destroys the given media player object.
--
-- @param table		Media player object.
--
function MediaPlayer.Destroy( mp )
	-- TODO: does this need anything else?
	MediaPlayer.List[mp.id] = nil

	if MediaPlayer.DEBUG then
		print( "Destroyed Media Player '" .. tostring(mp.id) .. "'" )
	end
end

---
-- Gets the media player associated with the given ID.
--
-- @param id		Media player ID.
-- @return table 	Media player object.
--
function MediaPlayer.GetById( id )
	local mp = MediaPlayer.List[id]
	if mp then
		return mp
	else
		-- Since entity indexes can change, let's iterate the list just to
		-- be sure...
		for _, mp in pairs(MediaPlayer.List) do
			if mp:GetId() == id then
				return mp
			end
		end
	end
end

---
-- Gets all active media players.
--
-- @return table	Array of all active media players.
--
function MediaPlayer.GetAll()
	local tbl = {}

	for _, mp in pairs( MediaPlayer.List ) do
		table.insert( tbl, mp )
	end

	return tbl
end

---
-- Gets the media player associated with the given object.
--
-- @param obj Any object.
--
function MediaPlayer.GetByObject( obj )
	local mp = nil

	if isentity(obj) and obj.IsMediaPlayerEntity then
		mp = obj:GetMediaPlayer()
	elseif istable(obj) and obj.IsMediaPlayer then
		mp = obj
	elseif isstring(obj) then
		mp = MediaPlayer.GetById(obj)
	end

	return mp
end


--[[---------------------------------------------------------
	Media Player Think Loop
-----------------------------------------------------------]]

MediaPlayer.ThinkInterval = 0.2 -- seconds

local function MediaPlayerThink()
	for id, mp in pairs( MediaPlayer.List ) do
		local succ, err = pcall(mp.Think, mp)
		if not succ then
			ErrorNoHalt(err .. "\n")

			-- TODO: recreate mediaplayer object instead
			mp:Remove()
		end
	end
end

if timer.Exists( "MediaPlayerThink" ) then
	timer.Remove( "MediaPlayerThink" )
end

-- TODO: only start timer when at least one mediaplayer is created; stop it when
-- there are none left.
timer.Create( "MediaPlayerThink", MediaPlayer.ThinkInterval, 0, MediaPlayerThink )
timer.Start( "MediaPlayerThink" )

--addons/media_player_fixed_edition/lua/mediaplayer/players/entity/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_base" )

local print = print
local IsValid = IsValid
local cam = cam
local Start3D2D = cam.Start3D2D
local End3D2D = cam.End3D2D

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

MEDIAPLAYER.Enable3DAudio = true

function MEDIAPLAYER:NetReadUpdate()
	local entIndex = net.ReadUInt(16)
	local ent = Entity(entIndex)
	local mpEnt = self.Entity

	if MediaPlayer.DEBUG then
		print("MEDIAPLAYER.NetReadUpdate[entity]: ", ent, entIndex)
	end

	if ent ~= mpEnt then
		if IsValid(ent) and ent ~= NULL then
			ent:InstallMediaPlayer( self )
		else
			-- Wait until the entity becomes valid
			self._EntIndex = entIndex
		end
	end
end

local RenderScale = 0.1
local InfoScale = 1 / 17

function MEDIAPLAYER:GetOrientation()
	local ent = self.Entity

	if ent then
		return ent:GetMediaPlayerPosition()
	end

	return nil
end

---
-- Draws the idlescreen; this is drawn when there is no media playing.
--
function MEDIAPLAYER:DrawIdlescreen( w, h )
	local browser = MediaPlayer.GetIdlescreen()

	if IsValid(browser) then
		self:DrawHTML( browser, w, h )
	end
end

local BaseInfoHeight = 60

function MEDIAPLAYER:Draw( bDrawingDepth, bDrawingSkybox )

	local ent = self.Entity

	if --bDrawingSkybox or
			FullscreenCvar:GetBool() or -- Don't draw if we're drawing fullscreen
			not IsValid(ent) or
			(ent.IsDormant and ent:IsDormant()) then
		return
	end

	local media = self:GetMedia()
	local w, h, pos, ang = self:GetOrientation()

	-- Render scale
	local rw, rh = w / RenderScale, h / RenderScale

	if IsValid(media) then

		-- Custom media draw function
		if media.Draw then
			Start3D2D( pos, ang, RenderScale )
				media:Draw( rw, rh )
			End3D2D()
		end
		-- TODO: else draw 'not yet implemented' screen?

		-- scale based off of height
		local scale = InfoScale * ( h / BaseInfoHeight )

		-- Media info
		Start3D2D( pos, ang, scale )
			local iw, ih = w / scale, h / scale
			self:DrawMediaInfo( media, iw, ih )
		End3D2D()

	else

		Start3D2D( pos, ang, RenderScale )
			self:DrawIdlescreen( rw, rh )
		End3D2D()

	end

end

function MEDIAPLAYER:SetMedia( media )
	if media then
		-- Set entity on media for 3D audio support and setting proper
		-- browser resolution
		media.Entity = self:GetEntity()
	end

	BaseClass.SetMedia( self, media )
end

---
-- Mouse click intersected with 3D2D screen.
--
function MEDIAPLAYER:OnMousePressed( x, y )
	local media = self:GetMedia()
	if media and media:IsMouseInputEnabled() then
		media:OnMousePressed( x, y )
	end
end

function MEDIAPLAYER:OnMouseWheeled( scrollDelta )
	local media = self:GetMedia()
	if media and media:IsMouseInputEnabled() then
		media:OnMouseWheeled( scrollDelta )
	end
end

--addons/media_player_fixed_edition/lua/mediaplayer/services/youtube/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

--[[
	Credits to veitikka (https://github.com/veitikka) for fixing YouTube service and writing the
	Workaround with a Metadata parser.

	Src: https://github.com/samuelmaddock/gm-mediaplayer/pull/34
--]]

local JS_Pause = [[
	if(window.MediaPlayer) {
		MediaPlayer.pause();
		mp_paused = true
	} 
]]
local JS_Play = [[
	if(window.MediaPlayer) {
		MediaPlayer.play();
		mp_paused = false
	} 
]]
local JS_Volume = "if(window.MediaPlayer) MediaPlayer.volume = %s;"
local JS_Seek = [[
	if (window.MediaPlayer) {
		var seekTime = %s;
		var curTime = window.MediaPlayer.currentTime;

		var diffTime = Math.abs(curTime - seekTime);
		if (diffTime > 5) {
			window.MediaPlayer.currentTime = seekTime
		}
	}
]]

local JS_Interface = [[
	// YouTube Adblock (https://github.com/Vendicated/Vencord/blob/main/src/plugins/youtubeAdblock.desktop/adguard.js - #d199603)
	const hiddenCSS=["#__ffYoutube1","#__ffYoutube2","#__ffYoutube3","#__ffYoutube4","#feed-pyv-container","#feedmodule-PRO","#homepage-chrome-side-promo","#merch-shelf","#offer-module",'#pla-shelf > ytd-pla-shelf-renderer[class="style-scope ytd-watch"]',"#pla-shelf","#premium-yva","#promo-info","#promo-list","#promotion-shelf","#related > ytd-watch-next-secondary-results-renderer > #items > ytd-compact-promoted-video-renderer.ytd-watch-next-secondary-results-renderer","#search-pva","#shelf-pyv-container","#video-masthead","#watch-branded-actions","#watch-buy-urls","#watch-channel-brand-div","#watch7-branded-banner","#YtKevlarVisibilityIdentifier","#YtSparklesVisibilityIdentifier",".carousel-offer-url-container",".companion-ad-container",".GoogleActiveViewElement",'.list-view[style="margin: 7px 0pt;"]',".promoted-sparkles-text-search-root-container",".promoted-videos",".searchView.list-view",".sparkles-light-cta",".watch-extra-info-column",".watch-extra-info-right",".ytd-carousel-ad-renderer",".ytd-compact-promoted-video-renderer",".ytd-companion-slot-renderer",".ytd-merch-shelf-renderer",".ytd-player-legacy-desktop-watch-ads-renderer",".ytd-promoted-sparkles-text-search-renderer",".ytd-promoted-video-renderer",".ytd-search-pyv-renderer",".ytd-video-masthead-ad-v3-renderer",".ytp-ad-action-interstitial-background-container",".ytp-ad-action-interstitial-slot",".ytp-ad-image-overlay",".ytp-ad-overlay-container",".ytp-ad-progress",".ytp-ad-progress-list",'[class*="ytd-display-ad-"]','[layout*="display-ad-"]','a[href^="http://www.youtube.com/cthru?"]','a[href^="https://www.youtube.com/cthru?"]',"ytd-action-companion-ad-renderer","ytd-banner-promo-renderer","ytd-compact-promoted-video-renderer","ytd-companion-slot-renderer","ytd-display-ad-renderer","ytd-promoted-sparkles-text-search-renderer","ytd-promoted-sparkles-web-renderer","ytd-search-pyv-renderer","ytd-single-option-survey-renderer","ytd-video-masthead-ad-advertiser-info-renderer","ytd-video-masthead-ad-v3-renderer","YTM-PROMOTED-VIDEO-RENDERER"],hideElements=()=>{if(!hiddenCSS)return;const e=hiddenCSS.join(", ")+" { display: none!important; }",r=document.createElement("style");r.textContent=e,document.head.appendChild(r)},observeDomChanges=e=>{new MutationObserver((r=>{e(r)})).observe(document.documentElement,{childList:!0,subtree:!0})},hideDynamicAds=()=>{const e=document.querySelectorAll("#contents > ytd-rich-item-renderer ytd-display-ad-renderer");0!==e.length&&e.forEach((e=>{if(e.parentNode&&e.parentNode.parentNode){const r=e.parentNode.parentNode;"ytd-rich-item-renderer"===r.localName&&(r.style.display="none")}}))},autoSkipAds=()=>{if(document.querySelector(".ad-showing")){const e=document.querySelector("video");e&&e.duration&&(e.currentTime=e.duration,setTimeout((()=>{const e=document.querySelector("button.ytp-ad-skip-button");e&&e.click()}),100))}},overrideObject=(e,r,t)=>{if(!e)return!1;let o=!1;for(const d in e)e.hasOwnProperty(d)&&d===r?(e[d]=t,o=!0):e.hasOwnProperty(d)&&"object"==typeof e[d]&&overrideObject(e[d],r,t)&&(o=!0);return o},jsonOverride=(e,r)=>{const t=JSON.parse;JSON.parse=(...o)=>{const d=t.apply(this,o);return overrideObject(d,e,r),d},Response.prototype.json=new Proxy(Response.prototype.json,{async apply(...t){const o=await Reflect.apply(...t);return overrideObject(o,e,r),o}})};jsonOverride("adPlacements",[]),jsonOverride("playerAds",[]),hideElements(),hideDynamicAds(),autoSkipAds(),observeDomChanges((()=>{hideDynamicAds(),autoSkipAds()}));

	var mp_paused = false
	var checkerInterval = setInterval(function() {
		var container = document.getElementById("movie_player");
		var video = container.querySelector(".html5-video-container video");

		if (!!video) {
			clearInterval(checkerInterval);

			{ // Player resizer
				document.body.appendChild(video);

				video.style.backgroundColor = "#000";
				video.style.height = "100vh";
				video.style.left = '0px';
				video.style.width = '100%';

				let countAmt = 0
				let resizeTimer = setInterval(function() {

					for (const elem of document.getElementsByClassName("watch-skeleton")) { elem.remove(); }
					for (const elem of document.getElementsByTagName("ytd-app")) { elem.remove(); }
					for (const elem of document.getElementsByClassName("skeleton")) { elem.remove(); }

					container.setInternalSize("100vw", "100vh");
					document.body.style.overflow = "hidden";

					countAmt++;

					if (countAmt > 100) {
						clearInterval(resizeTimer);
					}
       			}, 10);
			}

			{ // Popup Remover - https://github.com/TheRealJoelmatic/RemoveAdblockThing
				setInterval(() => {
					if (mp_paused) {return}

					const modalOverlay = document.querySelector("tp-yt-iron-overlay-backdrop");
					const popup = document.querySelector(".style-scope ytd-enforcement-message-view-model");
					const popupButton = document.getElementById("dismiss-button");

					const bodyStyle = document.body.style;
					bodyStyle.setProperty('overflow-y', 'auto', 'important');

					if (modalOverlay) {
						modalOverlay.removeAttribute("opened");
						modalOverlay.remove();
					}

					if (popup) {

						if (popupButton) popupButton.click();

						popup.remove();
						video.play();

						setTimeout(() => {
							video.play();
						}, 500);

					}
					// Check if the video is paused after removing the popup
					if (!video.paused) return;
					// UnPause The Video
					video.play();

				}, 1000);
			}

			window.MediaPlayer = video;
		}
	}, 50);
]]

local EMBED_URL = "https://www.youtube.com/watch?v=%s"

---
-- Helper function for converting ISO 8601 time strings; this is the formatting
-- used for duration specified in the YouTube v3 API.
--
-- http://stackoverflow.com/a/22149575/1490006
--
local function convertISO8601Time( duration )
	local a = {}

	for part in string.gmatch(duration, "%d+") do
	   table.insert(a, part)
	end

	if duration:find('M') and not (duration:find('H') or duration:find('S')) then
		a = {0, a[1], 0}
	end

	if duration:find('H') and not duration:find('M') then
		a = {a[1], 0, a[2]}
	end

	if duration:find('H') and not (duration:find('M') or duration:find('S')) then
		a = {a[1], 0, 0}
	end

	duration = 0

	if #a == 3 then
		duration = duration + tonumber(a[1]) * 3600
		duration = duration + tonumber(a[2]) * 60
		duration = duration + tonumber(a[3])
	end

	if #a == 2 then
		duration = duration + tonumber(a[1]) * 60
		duration = duration + tonumber(a[2])
	end

	if #a == 1 then
		duration = duration + tonumber(a[1])
	end

	return duration
end

---
-- Get the value for an attribute from a html element
--
local function ParseElementAttribute( element, attribute )
	if not element then return end
	-- Find the desired attribute
	local output = string.match( element, attribute .. "%s-=%s-%b\"\"" )
	if not output then return end
	-- Remove the 'attribute=' part
	output = string.gsub( output, attribute .. "%s-=%s-", "" )
	-- Trim the quotes around the value string
	return string.sub( output, 2, -2 )
end

---
-- Get the contents of a html element by removing tags
-- Used as fallback for when title cannot be found
--
local function ParseElementContent( element )
	if not element then return end
	-- Trim start
	local output = string.gsub( element, "^%s-<%w->%s-", "" )
	-- Trim end
	return string.gsub( output, "%s-</%w->%s-$", "" )
end

-- Lua search patterns to find metadata from the html
local patterns = {
	["title"] = "<meta%sproperty=\"og:title\"%s-content=%b\"\">",
	["title_fallback"] = "<title>.-</title>",
	["duration"] = "<meta%sitemprop%s-=%s-\"duration\"%s-content%s-=%s-%b\"\">",
	["live"] = "<meta%sitemprop%s-=%s-\"isLiveBroadcast\"%s-content%s-=%s-%b\"\">",
	["live_enddate"] = "<meta%sitemprop%s-=%s-\"endDate\"%s-content%s-=%s-%b\"\">",
	["age_restriction"] = "<meta%sproperty=\"og:restrictions:age\"%s-content=%b\"\">"
}

---
-- Function to parse video metadata straight from the html instead of using the API
--
local function ParseMetaDataFromHTML( html )
	--MetaData table to return when we're done
	local metadata, html = {}, html

	-- Fetch title, with fallbacks if needed
	metadata.title = ParseElementAttribute(html:match(patterns["title"]), "content")
		or ParseElementContent(html:match(patterns["title_fallback"]))

	-- Parse HTML entities in the title into symbols
	metadata.title = url.htmlentities_decode(metadata.title)

	metadata.familyfriendly = ParseElementAttribute(html:match(patterns["age_restriction"]), "content") or ""

	-- See if the video is an ongoing live broadcast
	-- Set duration to 0 if it is, otherwise use the actual duration
	local isLiveBroadcast = tobool(ParseElementAttribute(html:match(patterns["live"]), "content"))
	local broadcastEndDate = html:match(patterns["live_enddate"])
	if isLiveBroadcast and not broadcastEndDate then
		-- Mark as live video
		metadata.duration = 0
	else
		local durationISO8601 = ParseElementAttribute(html:match(patterns["duration"]), "content")
		if isstring(durationISO8601) then
			metadata.duration = math.max(1, convertISO8601Time(durationISO8601))
		end
	end

	return metadata
end

function SERVICE:OnBrowserReady( browser )

	-- Resume paused player
	if self._YTPaused then
		self.Browser:RunJavascript( JS_Play )
		self._YTPaused = nil
		return
	end

	BaseClass.OnBrowserReady( self, browser )

	local videoId = self:GetYouTubeVideoId()
	local curTime = self:CurrentTime()
	local url = EMBED_URL:format(videoId)

	-- Add start time to URL if the video didn't just begin
	if self:IsTimed() and curTime > 3 then
		url = url .. "&t=" .. math.Round(curTime)
	end

	browser:OpenURL( url )
	browser.OnDocumentReady = function(pnl)
		browser:QueueJavascript( JS_Interface )
	end

end

function SERVICE:Pause()
	BaseClass.Pause( self )

	if IsValid(self.Browser) then
		self.Browser:RunJavascript(JS_Pause)
		self._YTPaused = true
	end

end

function SERVICE:SetVolume( volume )
	local js = JS_Volume:format( MediaPlayer.Volume() )
	self.Browser:RunJavascript(js)
end

function SERVICE:Sync()

	local seekTime = self:CurrentTime()
	if IsValid(self.Browser) and self:IsTimed() and seekTime > 0 then
		self.Browser:RunJavascript(JS_Seek:format(seekTime))
	end
end

function SERVICE:IsMouseInputEnabled()
	return IsValid( self.Browser )
end

do	-- Metadata Prefech
	function SERVICE:PreRequest( callback )

		local videoId = self:GetYouTubeVideoId()

		http.Fetch(EMBED_URL:format(videoId), function(body, length, headers, code)
			if not body or code ~= 200 then
				callback(("Not expected response received from YouTube (Code: %d)"):format(code))
				return
			end

			local status, metadata = pcall(ParseMetaDataFromHTML, body)
			if not status  then
				callback("Failed to parse MetaData from YouTube")
				return
			end

			self._metaTitle = metadata.title
			self._metaDuration = metadata.duration
			callback()
		end, function(error)
			callback(("YouTube Error: %s"):format(error))
		end, {})
	end

	function SERVICE:NetWriteRequest()
		net.WriteString( self._metaTitle )
		net.WriteUInt( self._metaDuration, 16 )
	end
end

--addons/media_player_fixed_edition/lua/mediaplayer/services/twitch/cl_init.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/services/archive/cl_init.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/cl_requests.lua:
local function GetMediaPlayerId( obj )
	local mpId

	-- Determine mp parameter type and get the associated ID.
	if isentity(obj) and obj.IsMediaPlayerEntity then
		mpId = obj:GetMediaPlayerID()
	-- elseif isentity(obj) and IsValid( obj:GetMediaPlayer() ) then
	-- 	local mp = mp:GetMediaPlayer()
	-- 	mpId = mp:GetId()
	elseif istable(obj) and obj.IsMediaPlayer then
		mpId = obj:GetId()
	elseif isstring(obj) then
		mpId = obj
	else
		return false -- Invalid parameters
	end

	return mpId
end

---
-- Request to begin listening to a media player.
--
-- @param Entity|Table|String	Media player reference.
--
function MediaPlayer.RequestListen( obj )

	local mpId = GetMediaPlayerId(obj)
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestListen" )
		net.WriteString( mpId )
	net.SendToServer()

end

---
-- Request mediaplayer update.
--
-- @param Entity|Table|String	Media player reference.
--
function MediaPlayer.RequestUpdate( obj )

	local mpId = GetMediaPlayerId(obj)
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestUpdate" )
		net.WriteString( mpId )
	net.SendToServer()

end

---
-- Request a URL to be played on the given media player.
--
-- @param Entity|Table|String	Media player reference.
-- @param String				Requested media URL.
--
function MediaPlayer.Request( obj, url )

	local mpId = GetMediaPlayerId( obj )
	if not mpId then return end

	if MediaPlayer.DEBUG then
		print("MEDIAPLAYER.Request:", url, mpId)
	end

	local mp = MediaPlayer.GetById( mpId )

	local allowWebpage = MediaPlayer.Cvars.AllowWebpages:GetBool()

	-- Verify valid URL as to not waste time networking
	if not MediaPlayer.ValidUrl( url ) and not allowWebpage then
		LocalPlayer():ChatPrint("The requested URL was invalid.")
		return false
	end

	local media = MediaPlayer.GetMediaForUrl( url, allowWebpage )

	local function request( err )
		if err then
			-- TODO: don't use chatprint to notify the user
			LocalPlayer():ChatPrint( "Request failed: " .. err )
			return
		end

		if not IsValid( mp ) then
			-- media player may have been removed before we could finish the
			-- async prerequest action
			return
		end

		net.Start( "MEDIAPLAYER.RequestMedia" )
			net.WriteString( mpId )
			net.WriteString( url )
			media:NetWriteRequest() -- send any additional data
		net.SendToServer()

		if MediaPlayer.DEBUG then
			print("MEDIAPLAYER.Request sent to server")
		end
	end

	-- Prepare any data prior to requesting if necessary
	if media.PrefetchMetadata then
		media:PreRequest(request) -- async
	else
		request() -- sync
	end

end

function MediaPlayer.Pause( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestPause" )
		net.WriteString( mpId )
	net.SendToServer()

end

function MediaPlayer.Skip( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestSkip" )
		net.WriteString( mpId )
	net.SendToServer()

end

---
-- Seek to a specific time in the current media.
--
-- @param Entity|Table|String	Media player reference.
-- @param String				Seek time; HH:MM:SS
--
function MediaPlayer.Seek( mp, time )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	-- always convert to time in seconds before sending
	if isstring(time) then
		time = MediaPlayerUtils.ParseHHMMSS(time) or 0
	end

	net.Start( "MEDIAPLAYER.RequestSeek" )
		net.WriteString( mpId )
		net.WriteInt( time, 32 )
	net.SendToServer()

end

---
-- Remove the given media.
--
-- @param Entity|Table|String	Media player reference.
-- @param String				Media unique ID.
--
function MediaPlayer.RequestRemove( mp, mediaUID )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestRemove" )
		net.WriteString( mpId )
		net.WriteString( mediaUID )
	net.SendToServer()

end

function MediaPlayer.RequestRepeat( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestRepeat" )
		net.WriteString( mpId )
	net.SendToServer()

end

function MediaPlayer.RequestShuffle( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestShuffle" )
		net.WriteString( mpId )
	net.SendToServer()

end

function MediaPlayer.RequestLock( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestLock" )
		net.WriteString( mpId )
	net.SendToServer()

end

--addons/media_player_fixed_edition/lua/autorun/properties/mediaplayer.lua:
local mporder = 3200

--
-- Adds a media player property.
--
-- Blue icons correspond to admin actions.
--
local function AddMediaPlayerProperty( name, config )
	-- Assign incrementing order ID
	config.Order = mporder
	mporder = mporder + 1

	properties.Add( name, config )
end

local function IsMediaPlayer( self, ent, ply )
	return IsValid(ent) and IsValid(ply) and
			IsValid(ent:GetMediaPlayer()) and
			gamemode.Call( "CanProperty", ply, self.InternalName, ent )
end

local function IsPrivilegedMediaPlayer( self, ent, ply )
	return IsMediaPlayer( self, ent, ply ) and
		( ply:IsAdmin() or ent:GetOwner() == ply )
end

local function HasMedia( mp )
	return mp:GetPlayerState() >= MP_STATE_PLAYING
end

AddMediaPlayerProperty( "mp-pause", {
	MenuLabel	=	"Pause",
	MenuIcon	=	"icon16/control_pause_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and mp:GetPlayerState() == MP_STATE_PLAYING
	end,

	Action		=	function( self, ent )
		MediaPlayer.Pause( ent )
	end
})

AddMediaPlayerProperty( "mp-resume", {
	MenuLabel	=	"Resume",
	MenuIcon	=	"icon16/control_play_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and mp:GetPlayerState() == MP_STATE_PAUSED
	end,

	Action		=	function( self, ent )
		MediaPlayer.Pause( ent )
	end
})

AddMediaPlayerProperty( "mp-skip", {
	MenuLabel	=	"Skip",
	MenuIcon	=	"icon16/control_end_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )
		MediaPlayer.Skip( ent )
	end
})

AddMediaPlayerProperty( "mp-seek", {
	MenuLabel	=	"Seek",
	-- MenuIcon	=	"icon16/timeline_marker.png",
	MenuIcon	=	"icon16/control_fastforward_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )

		Derma_StringRequest(
			"Media Player",
			"Enter a time in HH:MM:SS format (hours, minutes, seconds):",
			"", -- Default text
			function( time )
				MediaPlayer.Seek( ent, time )
			end,
			function() end,
			"Seek",
			"Cancel"
		)

	end
})

AddMediaPlayerProperty( "mp-request-url", {
	MenuLabel	=	"Request URL",
	MenuIcon	=	"icon16/link_add.png",
	Filter		=	IsMediaPlayer,

	Action		=	function( self, ent )

		MediaPlayer.OpenRequestMenu( ent )

	end
})

AddMediaPlayerProperty( "mp-copy-url", {
	MenuLabel	=	"Copy URL to clipboard",
	MenuIcon	=	"icon16/paste_plain.png",

	Filter		=	function( self, ent, ply )
		if not IsMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )

		local mp = ent:GetMediaPlayer()
		local media = mp and mp:CurrentMedia()
		if not IsValid(media) then return end

		SetClipboardText( media:Url() )
		LocalPlayer():ChatPrint( "Media URL has been copied into your clipboard." )

	end
})

AddMediaPlayerProperty( "mp-enable", {
	MenuLabel	=	"Turn On",
	MenuIcon	=	"icon16/lightbulb.png",

	Filter		=	function( self, ent, ply )
		return IsValid(ent) and IsValid(ply) and
				ent.IsMediaPlayerEntity and
				not IsValid(ent:GetMediaPlayer()) and
				gamemode.Call( "CanProperty", ply, self.InternalName, ent )
	end,

	Action		=	function( self, ent )
		MediaPlayer.RequestListen( ent )
	end
})

AddMediaPlayerProperty( "mp-disable", {
	MenuLabel	=	"Turn Off",
	MenuIcon	=	"icon16/lightbulb_off.png",

	Filter		=	function( self, ent, ply )
		return IsValid(ent) and IsValid(ply) and
				ent.IsMediaPlayerEntity and
				IsValid(ent:GetMediaPlayer()) and
				gamemode.Call( "CanProperty", ply, self.InternalName, ent )
	end,

	Action		=	function( self, ent )
		MediaPlayer.RequestListen( ent )
	end
})
--addons/media_player_fixed_edition/lua/autorun/sandbox/mediaplayer_dupe.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mp_menu/icons.lua:
return gluapack()()
--lua/autorun/mgs3_soldiers_npc.lua:
return gluapack()()
--lua/autorun/netstream.lua:
--A net extension which allows sending large streams of data without overflowing the reliable channel
--Keep it in lua/autorun so it will be shared between addons
AddCSLuaFile()

net.Stream = {}
net.Stream.SendSize = 20000 --This is the size of each packet to send
net.Stream.Timeout = 10 --How long to wait for client response before cleaning up
net.Stream.MaxWriteStreams = 1024 --The maximum number of write data items to store
net.Stream.MaxReadStreams = 128 --The maximum number of queued read data items to store
net.Stream.MaxChunks = 3200 --Maximum number of pieces the stream can send to the server. 64 MB
net.Stream.MaxSize = net.Stream.SendSize*net.Stream.MaxChunks
net.Stream.MaxTries = 3 --Maximum times the client may retry downloading the whole data

local WriteStreamQueue = {
	__index = {
		Add = function(self, stream)
			local identifier = self.curidentifier
			local startid = identifier
			while self.queue[identifier] do
				identifier = identifier % net.Stream.MaxWriteStreams + 1
				if identifier == startid then
					ErrorNoHalt("Netstream is full of WriteStreams!")
					net.WriteUInt(0, 32)
					return
				end
			end
			self.curidentifier = identifier % net.Stream.MaxWriteStreams + 1

			if next(self.queue)==nil then
				self.activitytimeout = CurTime()+net.Stream.Timeout
				timer.Create("netstream_queueclean", 5, 0, function() self:Clean() end)
			end
			self.queue[identifier] = stream
			stream.identifier = identifier
			return stream
		end,

		Write = function(self, ply)
			local identifier = net.ReadUInt(32)
			local chunkidx = net.ReadUInt(32)
			local stream = self.queue[identifier]
			--print("Got request", identifier, chunkidx, stream)
			if stream then
				if stream:Write(ply, chunkidx) then
					self.activitytimeout = CurTime()+net.Stream.Timeout
					stream.timeout = CurTime()+net.Stream.Timeout
				end
			else
				-- Tell them the stream doesn't exist
				net.Start("NetStreamRead")
				net.WriteUInt(identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(ply) else net.SendToServer() end
			end
		end,

		Clean = function(self)
			local t = CurTime()
			for k, stream in pairs(self.queue) do
				if (next(stream.clients)~=nil and t >= stream.timeout) or t >= self.activitytimeout then
					stream:Remove()
					self.queue[k] = nil
				end
			end
			if next(self.queue)==nil then
				timer.Remove("netstream_queueclean")
			end
		end,
	},
	__call = function(t)
		return setmetatable({
			activitytimeout = CurTime()+net.Stream.Timeout,
			curidentifier = 1,
			queue = {}
		}, t)
	end
}
setmetatable(WriteStreamQueue, WriteStreamQueue)
net.Stream.WriteStreams = WriteStreamQueue()

local ReadStreamQueue = {
	__index = {
		Add = function(self, stream)
			local queue = self.queues[stream.player]

			if #queue == net.Stream.MaxReadStreams then
				ErrorNoHalt("Receiving too many ReadStream requests!")
				return
			end
			
			for _, v in ipairs(queue) do
				if v.identifier == stream.identifier then
					ErrorNoHalt("Tried to start a new ReadStream for an already existing stream!")
					return
				end
			end

			queue[#queue+1] = stream
			if #queue == 1 then
				stream:Request()
			end
			return stream
		end,

		Remove = function(self, stream)
			local queue = rawget(self.queues, stream.player)
			if queue then
				if stream == queue[1] then
					table.remove(queue, 1)
					local nextInQueue = queue[1]
					if nextInQueue then
						nextInQueue:Request()
					else
						self.queues[stream.player] = nil
					end
				else
					for k, v in ipairs(queue) do
						if v == stream then
							table.remove(queue, k)
							break
						end
					end
				end
			end
		end,

		Read = function(self, ply)
			local identifier = net.ReadUInt(32)
			local queue = rawget(self.queues, ply)
			if queue and queue[1] then
				queue[1]:Read(identifier)
			end
		end
	},
	__call = function(t)
		return setmetatable({
			queues = setmetatable({}, {__index = function(t,k) local r={} t[k]=r return r end})
		}, t)
	end
}
setmetatable(ReadStreamQueue, ReadStreamQueue)
net.Stream.ReadStreams = ReadStreamQueue()


local WritingDataItem = {
	__index = {
		Write = function(self, ply, chunkidx)
			local client = self.clients[ply]
			if client.finished then return false end
			if chunkidx == #self.chunks+1 then self:Finished(ply) return true end

			if client.downloads+#self.chunks-client.progress >= net.Stream.MaxTries * #self.chunks then self:Finished(ply) return false end
			client.downloads = client.downloads + 1

			local chunk = self.chunks[chunkidx]
			if not chunk then return false end

			client.progress = chunkidx

			--print("Sending", "NetStreamRead", self.identifier, #chunk.data, chunkidx, chunk.crc)
			net.Start("NetStreamRead")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#chunk.data, 32)
			net.WriteUInt(chunkidx, 32)
			net.WriteString(chunk.crc)
			net.WriteData(chunk.data, #chunk.data)
			if CLIENT then net.SendToServer() else net.Send(ply) end
			return true
		end,

		Finished = function(self, ply)
			self.clients[ply].finished = true
			if self.callback then
				local ok, err = xpcall(self.callback, debug.traceback, ply)
				if not ok then ErrorNoHalt(err) end
			end
		end,

		GetProgress = function(self, ply)
			return self.clients[ply].progress / #self.chunks
		end,

		Remove = function(self)
			local sendTo = {}
			for ply, client in pairs(self.clients) do
				if not client.finished then
					client.finished = true
					if CLIENT or ply:IsValid() then sendTo[#sendTo+1] = ply end
				end
			end

			if next(sendTo)~=nil then
				--print("Sending", "NetStreamRead", self.identifier, 0)
				net.Start("NetStreamRead")
				net.WriteUInt(self.identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(sendTo) else net.SendToServer() end
			end
		end

	},
	__call = function(t, data, callback)
		local chunks = {}
		for i=1, math.ceil(#data / net.Stream.SendSize) do
			local datachunk = string.sub(data, (i - 1) * net.Stream.SendSize + 1, i * net.Stream.SendSize)
			chunks[i] = { data = datachunk, crc = util.CRC(datachunk) }
		end

		return setmetatable({
			timeout = CurTime()+net.Stream.Timeout,
			chunks = chunks,
			callback = callback,
			lasttouched = 0,
			clients = setmetatable({},{__index = function(t,k)
				local r = {
					finished = false,
					downloads = 0,
					progress = 0,
				} t[k]=r return r
			end})
		}, t)
	end
}
setmetatable(WritingDataItem, WritingDataItem)

local ReadingDataItem = {
	__index = {
		Request = function(self)
			if self.downloads+self.numchunks-#self.chunks >= net.Stream.MaxTries*self.numchunks then self:Remove() return end
			self.downloads = self.downloads + 1
			timer.Create("NetStreamReadTimeout" .. self.identifier, net.Stream.Timeout*0.5, 1, function() self:Request() end)
			self:WriteRequest()
		end,

		WriteRequest = function(self)
			--print("Requesting", self.identifier, #self.chunks)
			net.Start("NetStreamWrite")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#self.chunks+1, 32)
			if CLIENT then net.SendToServer() else net.Send(self.player) end
		end,

		Read = function(self, identifier)
			if self.identifier ~= identifier then self:Request() return end

			local size = net.ReadUInt(32)
			if size == 0 then self:Remove() return end

			local chunkidx = net.ReadUInt(32)
			if chunkidx ~= #self.chunks+1 then self:Request() return end

			local crc = net.ReadString()
			local data = net.ReadData(size)

			if crc ~= util.CRC(data) then self:Request() return end

			self.chunks[chunkidx] = data
			if #self.chunks == self.numchunks then self:Remove(true) return end

			self:Request()
		end,

		GetProgress = function(self)
			return #self.chunks/self.numchunks
		end,

		Remove = function(self, finished)
			timer.Remove("NetStreamReadTimeout" .. self.identifier)

			local data
			if finished then
				data = table.concat(self.chunks)
				if self.compressed then
					data = util.Decompress(data, net.Stream.MaxSize)
				end
				self:WriteRequest() -- Notify we finished
			end

			local ok, err = xpcall(self.callback, debug.traceback, data)
			if not ok then ErrorNoHalt(err) end

			net.Stream.ReadStreams:Remove(self)
		end
	},
	__call = function(t, ply, callback, numchunks, identifier, compressed)
		return setmetatable({
			identifier = identifier,
			chunks = {},
			compressed = compressed,
			numchunks = numchunks,
			callback = callback,
			player = ply,
			downloads = 0
		}, t)
	end
}
setmetatable(ReadingDataItem, ReadingDataItem)


function net.WriteStream(data, callback, dontcompress)
	if not isstring(data) then
		error("bad argument #1 to 'WriteStream' (string expected, got " .. type(data) .. ")", 2)
	end
	if callback ~= nil and not isfunction(callback) then
		error("bad argument #2 to 'WriteStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local compressed = not dontcompress
	if compressed then
		data = util.Compress(data) or ""
	end

	if #data == 0 then
		net.WriteUInt(0, 32)
		return
	end

	if #data > net.Stream.MaxSize then
		ErrorNoHalt("net.WriteStream request is too large! ", #data/1048576, "MiB")
		net.WriteUInt(0, 32)
		return
	end

	local stream = net.Stream.WriteStreams:Add(WritingDataItem(data, callback, compressed))
	if not stream then return end
	
	--print("WriteStream", #stream.chunks, stream.identifier, compressed)
	net.WriteUInt(#stream.chunks, 32)
	net.WriteUInt(stream.identifier, 32)
	net.WriteBool(compressed)

	return stream
end

--If the receiver is a player then add it to a queue.
--If the receiver is the server then add it to a queue for each individual player
function net.ReadStream(ply, callback)
	if CLIENT then
		ply = NULL
	else
		if type(ply) ~= "Player" then
			error("bad argument #1 to 'ReadStream' (Player expected, got " .. type(ply) .. ")", 2)
		elseif not ply:IsValid() then
			error("bad argument #1 to 'ReadStream' (Tried to use a NULL entity!)", 2)
		end
	end
	if not isfunction(callback) then
		error("bad argument #2 to 'ReadStream' (function expected, got " .. type(callback) .. ")", 2)
	end
	
	local numchunks = net.ReadUInt(32)
	if numchunks == nil then
		return
	elseif numchunks == 0 then
		local ok, err = xpcall(callback, debug.traceback, "")
		if not ok then ErrorNoHalt(err) end
		return
	end

	local identifier = net.ReadUInt(32)
	local compressed = net.ReadBool()

	if numchunks > net.Stream.MaxChunks then
		ErrorNoHalt("ReadStream requests from ", ply, " is too large! ", numchunks * net.Stream.SendSize / 1048576, "MiB")
		return
	end

	--print("ReadStream", numchunks, identifier, compressed)

	return net.Stream.ReadStreams:Add(ReadingDataItem(ply, callback, numchunks, identifier, compressed))
end

if SERVER then
	util.AddNetworkString("NetStreamWrite")
	util.AddNetworkString("NetStreamRead")
end

--Send requested stream data
net.Receive("NetStreamWrite", function(len, ply)
	net.Stream.WriteStreams:Write(ply or NULL)
end)

--Download the sent stream data
net.Receive("NetStreamRead", function(len, ply)
	net.Stream.ReadStreams:Read(ply or NULL)
end)

--addons/onyx_framework_2/lua/autorun/onyx_autorun.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_ui3d2d.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/libs/cl_wimg.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/core/cl_panel_functions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

local ABSTRACT = {}

--[[------------------------------
Functions
--------------------------------]]
function ABSTRACT:GetX()
    local x = self:GetPos()
    return x
end

function ABSTRACT:GetY()
    local _, y = self:GetPos()
    return y
end

function ABSTRACT:SetX(x)
    self:SetPos(x, self:GetY())
end

function ABSTRACT:SetY(y)
    self:SetPos(self:GetX(), y)
end

-- Traits

function ABSTRACT:Import(name)
    onyx.trait.Import(self, name)
end

-- Events

function ABSTRACT:On(name, fn)
    return onyx.gui.AddEvent(self, name, fn)
end

function ABSTRACT:Call(name, ignoreRaw, ...)
    onyx.gui.CallEvent(self, name, ignoreRaw, ...)
end

function ABSTRACT:InjectEventHandler(name)
    onyx.gui.InjectEventHandler(self, name)
end

-- Misc

function ABSTRACT:Combine(pnl2, fnName)
    self[fnName] = function(_, ...)
        return pnl2[fnName](pnl2, ...)
    end
end

function ABSTRACT:CombineMutator(pnl2, mutatorName)
    self:Combine(pnl2, 'Set' .. mutatorName)
    self:Combine(pnl2, 'Get' .. mutatorName)
end

function ABSTRACT:MakeDispatchFn(pnl2, fnName)
    pnl2[fnName] = function(_, ...)
        return self:Call(fnName, nil, ...)
    end
end

function ABSTRACT:SquareInContainer(class, width, height, size, dock)
    self._Container = self:Add('Panel')
    self._Container:Dock(dock)
    self._Container:SetSize(width, height)

    self._Container.Child = self._Container:Add(class)

    self._Container.PerformLayout = function(panel, w, h)
        local size = size < 1 and math.ceil(math.min(w * size, h * size)) or size

        panel.Child:SetWide(size)
        panel.Child:SetTall(size)
        panel.Child:Center()
    end

    return self._Container.Child
end

function ABSTRACT:Padding(padding)
    self:DockPadding(padding, padding, padding, padding)
end

onyx.abstract = ABSTRACT

--[[------------------------------
Register
--------------------------------]]
for name, fn in pairs(ABSTRACT) do
    onyx.gui.RegisterFunc(name, fn)
end
--addons/onyx_framework_2/lua/onyx/ui/traits/cl_click.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/traits/cl_click.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

local TRAIT = {}

AccessorFunc(TRAIT, 'm_bDepressed', 'Depressed', FORCE_BOOL)
AccessorFunc(TRAIT, 'm_bDisabled', 'Disabled', FORCE_BOOL)

--[[------------------------------
Makes possible to make any panel clickable
--------------------------------]]

function TRAIT:Init()
    self:SetDepressed(false)
    self:SetCursor('hand')
    self:SetMouseInputEnabled(true)

    --[[------------------------------
    Override default, not add
    Useful when is called for DLabel
    --------------------------------]]
    self.OnMousePressed = function(self, code)
        if not self:GetDisabled() then
            self:SetDepressed(true)
            self:Call('OnPress', nil, code)
        end
    end

    self.OnMouseReleased = function(self, code)
        if self:GetDisabled() then return end

        if (CurTime() - (onyx.menuButtonPressTime or 0) > .2) then
            self:Call('OnRelease', nil, code)
        
            if code == MOUSE_LEFT then
                self:Call('DoClick')
            elseif code == MOUSE_RIGHT then
                self:Call('DoRightClick')
            else
                self:Call('DoMiddleClick')
            end
        end

        self:SetDepressed(false)
    end
end

function TRAIT:SetDisabled(bool)
    self.m_bDisabled = bool

    if bool then
        self:SetCursor('no')
        self:Call('OnDisabled', nil)
    else
        self:SetCursor('hand')
        self:Call('OnEnabled', nil)
    end
end

local colorCircle = Color(0, 0, 0, 100)
function TRAIT:AddHoverSound()
    self:On('OnCursorEntered', function(panel)
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over1.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over2.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over5.wav')
        surface.PlaySound('onyx/ui/on_mouseover/pop_mouse_over.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/sub_bass_mouseover.wav')
    end)

    self:On('OnRelease', function(panel)
        -- surface.PlaySound('onyx/ui/on_click/round_pop_click.wav')
        -- surface.PlaySound('onyx/ui/on_click/round_pop_click1.wav')
        -- surface.PlaySound('onyx/ui/on_click/pop_click.wav')
        -- surface.PlaySound('onyx/ui/on_click/melodic1_click.wav')
        surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
    end)
end

function TRAIT:AddClickEffect()
    self:On('OnRelease', function(panel)
        local x, y = panel:ScreenToLocal(input.GetCursorPos())
        
        panel.circleAnimFraction = 0
        panel.circleX = x
        panel.circleY = y
        onyx.anim.Create(panel, .25, {
            index = 400,
            target = {
                circleAnimFraction = 1
            }
        })
    end)

    self.circleAnimFraction = 0
    self:InjectEventHandler('PaintOver')
    self:On('PaintOver', function(panel, w, h)
        if (panel.circleAnimFraction > 0 and panel.circleAnimFraction < 1) then
            local circle = onyx.CalculateCircle(panel.circleX, panel.circleY, math.max(w, h) * panel.circleAnimFraction, 32)
            onyx.DrawPoly(circle, ColorAlpha(colorCircle, colorCircle.a * (1 - panel.circleAnimFraction)))
        end
    end)
end

onyx.trait.Register('click', TRAIT, 'Makes it easy to make any panel clickable')
--addons/onyx_framework_2/lua/onyx/ui/traits/cl_hover.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/04/2022

--]]

local TRAIT = {}

AccessorFunc(TRAIT, 'm_colIdle', 'ColorIdle')
AccessorFunc(TRAIT, 'm_colHover', 'ColorHover')
AccessorFunc(TRAIT, 'm_colPressed', 'ColorPressed')
AccessorFunc(TRAIT, 'm_bHoverBlocked', 'HoverBlocked')

local ANIM_DURATION = .2

local function isDisabled(panel)
    if panel.GetDisabled then
        return panel:GetDisabled()
    end
end

local function animColor(panel, targetkey, duration)
    local key = panel.m_ColorKey

    onyx.anim.Create(panel, duration or ANIM_DURATION, {
        index = onyx.anim.ANIM_HOVER,
        target = {
            [key] = panel[targetkey]
        }
    })
end

function TRAIT:SetColorKey(colorKey)
    self.m_ColorKey = colorKey
end

function TRAIT:SetColorIdle(color, offset)
    self.m_colIdle = color
    self[self.m_ColorKey] = onyx.CopyColor(color)

    if (offset) then
        self:SetColorHover(onyx.OffsetColor(color, offset))
    end
end

function TRAIT:OnPress()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colPressed')
end

function TRAIT:OnRelease()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end
    if self:IsHovered() then
        animColor(self, 'm_colHover')
    end
end

function TRAIT:OnCursorEntered()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colHover')
end

function TRAIT:OnCursorExited()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colIdle')
end

onyx.trait.Register('hovercolor', TRAIT)
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_button.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_colIdle', 'ColorIdle')
AccessorFunc(PANEL, 'm_colHover', 'ColorHover')
AccessorFunc(PANEL, 'm_colPressed', 'ColorPressed')
AccessorFunc(PANEL, 'm_colGradient', 'GradientColor')
AccessorFunc(PANEL, 'm_iGradientDirection', 'GradientDirection')
AccessorFunc(PANEL, 'm_bMasking', 'Masking')

local colorAccent = onyx:Config('colors.accent')

function PANEL:Init()
    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(ScreenScale(10))
    self:CenterText()

    local _SetColorIdle = self.SetColorIdle
    self.SetColorIdle = function(panel, color)
        _SetColorIdle(panel, color)

        local h, s, v = ColorToHSV(color)
        if (v > .5) then
            panel:SetTextColor(color_black)
        else
            panel:SetTextColor(color_white)
        end
    end

    self:SetColorKey('backgroundColor')
    self:SetColorIdle(colorAccent)
    -- self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -80))
    self:SetColorHover(onyx.ColorEditHSV(self:GetColorIdle(), nil, nil, .66))
    self:SetGradientDirection(RIGHT)
end

function PANEL:Paint(w, h)
    local isMaskingEnabled = self.m_bMasking
    local colorGradient = self.m_colGradient

    draw.RoundedBox(8, 0, 0, w, h, self.backgroundColor)

    if (isMaskingEnabled and colorGradient) then
        onyx.DrawWithPolyMask(self.mask, function()
            onyx.DrawMatGradient(0, 0, w, h, self.m_iGradientDirection, colorGradient)
        end)
    end
end

function PANEL:PerformLayout(w, h)
    if (self.m_bMasking) then
        self.mask = onyx.CalculateRoundedBox(8, 0, 0, w, h)
    end
end

onyx.gui.Register('onyx.Button', PANEL, 'onyx.Label')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     for i = 1, 10 do
--         local btn = self:Add('onyx.Button')
--         btn:Dock(TOP)
--         btn:SetText('Button #' .. i)
--         btn.DoClickInternal = function()

--         end
--         btn.DoClick = function()
--             print('test')
--         end

--         if i % 2 == 0 then
--             btn:SetDisabled(true)
--         end
--     end
-- end)
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_grid.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/03/2023

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_iColumnCount', 'ColumnCount')
AccessorFunc(PANEL, 'm_iSpaceX', 'SpaceX')
AccessorFunc(PANEL, 'm_iSpaceY', 'SpaceY')
AccessorFunc(PANEL, 'm_fSizeRatio', 'SizeRatio')

function PANEL:Init()
    self:SetSpaceX(0)
    self:SetSpaceY(0)
    self:SetColumnCount(4)
end

function PANEL:PerformLayout(w, h)
    self:Layout(w, h)

    local contentHeight = self:GetContentHeight()
    if (contentHeight ~= h) then
        self:SetSizeToContents()
    end
end

function PANEL:SetSpace(space)
    self:SetSpaceX(space)
    self:SetSpaceY(space)
end

function PANEL:Layout(w, h)
    local children = self:GetVisibleChildren()

    local spaceX, spaceY = self:GetSpaceX(), self:GetSpaceY()
    local columnCount = self:GetColumnCount()
    local wide = math.floor((w - spaceX * (columnCount - 1)) / columnCount)

    local x, y = 0, 0
    local ratio = self:GetSizeRatio()

    for i, child in ipairs(children) do
        child:SetWide(wide)
        child:SetPos(x, y)

        if (ratio) then
            child:SetTall(math.Round(wide * ratio))
        end

        x = x + wide + spaceX

        if (i % columnCount == 0) then
            y = y + child:GetTall() + spaceY
            x = 0
        end
    end
end

function PANEL:GetVisibleChildren()
    local result, count = {}, 0
    for _, ch in ipairs(self:GetChildren()) do
        if (ch:IsVisible()) then
            count = count + 1
            result[count] = ch
        end
    end
    return result
end

function PANEL:GetContentHeight()
    local height = 0
    local children = self:GetChildren()
    local visible = 0

    for _, child in ipairs(children) do
        if (child:IsVisible()) then
            visible = visible + 1
        end
    end

    local rows = math.ceil(visible / self:GetColumnCount())
    local height = rows * self:GetRowHeight() + (rows - 1) * self:GetSpaceY()

    return height
end

function PANEL:GetRowHeight()
    local rowHeight = 0
    for _, ch in ipairs(self:GetVisibleChildren()) do
        rowHeight = math.max(rowHeight, ch:GetTall())
    end
    return rowHeight
end

function PANEL:SetSizeToContents()
    local contentHeight = self:GetContentHeight()
    self:SetTall(contentHeight)
end

function PANEL:AddItem(panel)
end

function PANEL:GetItems()
    return self:GetChildren()
end

onyx.gui.Register('onyx.Grid', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .66, .66, function(self)
--     self:MakePopup()

--     local list = self:Add('onyx.ScrollPanel')
--     list:Dock(FILL)

--     local grid = list:Add('onyx.Grid')
--     grid:Dock(TOP)
--     grid:SetSizeRatio(1.25)

--     for i = 1, 32 do
--         local button = grid:Add('onyx.Button')
--         button:SetText('Button #' .. i)
--         -- button:SetTall(100)
--         button:SetTextColor(color_black)
--         button.Paint = function(p, w, h)
--             surface.SetDrawColor(color_white)
--             surface.DrawRect(0, 0, w, h)

--             surface.SetDrawColor(0, 0, 255)
--             surface.DrawOutlinedRect(0, 0, w, h, 4)
--         end

--         grid:AddItem(button)
--     end

--     for var = 1, 32 do
--         if (var > 16) then
--             grid:GetChild(var - 1):SetVisible(false)
--         end
--     end

--     -- grid:InvalidateLayout(true)
--     -- grid:SetSizeToContents()
-- end)
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_pie_chart.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

local CIRCLE_FULL_ANGLE = 360

local PANEL = {}

AccessorFunc(PANEL, 'm_Data', 'Data')
AccessorFunc(PANEL, 'm_LegendFont', 'LegendFont')
AccessorFunc(PANEL, 'm_iSum', 'Sum')
AccessorFunc(PANEL, 'm_bDonut', 'Donut')
AccessorFunc(PANEL, 'm_flRadius', 'Radius')
AccessorFunc(PANEL, 'm_colCircleBackgroundColor', 'CircleBackgroundColor')

function PANEL:Init()
    self:SetData({})
    self:SetCircleBackgroundColor(Color(100, 100, 100))
    self:SetDonut(false)
    self:SetRadius(.33)
    self:SetLegendFont(onyx.Font('Comfortaa@16'))

    self.divBody = self:Add('Panel')
    self.divBody.Paint = function(panel, w, h)
        self:DrawChart(w, h)
    end
    self.divBody.PerformLayout = function(panel, w, h)
        self:PerformChart(w, h)
    end

    self.divLegend = self:Add('Panel')
    self.divLegend.Paint = function(panel, w, h)
        self:DrawLegend(w, h)
    end
end

function PANEL:PerformLayout(w, h)
    self.divBody:Dock(FILL)

    self.divLegend:Dock(RIGHT)
    self.divLegend:SetWide(w * .5)
end

function PANEL:SetLegendVisible(bVisible)
    self.divLegend:SetVisible(bVisible)
end

function PANEL:AddRecord(text, amount, color)
    onyx.AssertType(text, 'string', 'AddRecord', 1)
    onyx.AssertType(amount, 'number', 'AddRecord', 2)

    local color = color or onyx.ColorEditHSV(color_white, math.random(360), .8, .8)

    local data = self:GetData()
    table.insert(data, {
        text = text,
        amount = amount,
        color = color
    })

    table.sort(data, function(a, b)
        return a.amount > b.amount
    end)

    self:UpdateSum()
end

function PANEL:UpdateSum()
    local data = self:GetData()
    local sum = 0

    for _, record in ipairs(data) do
        sum = sum + record.amount
    end

    for _, record in ipairs(data) do
        record.fraction = (record.amount / sum)
    end

    self:SetSum(sum)
    self.divBody:InvalidateLayout(true)

    return sum
end

function PANEL:DrawLegend(w, h)
    local data = self:GetData()
    local amount = #data
    local font = self:GetLegendFont()
    local y = 0

    surface.SetFont(font)
    local _, textH = surface.GetTextSize('A')
    local space = onyx.ScaleTall(5)
    local iconMargin = onyx.ScaleWide(5)

    for index = 1, amount do
        local record = data[index]

        onyx.DrawCircle(textH * .5, y + textH * .5, textH * .5, record.color)

        draw.SimpleText(record.text, font, textH + iconMargin, y, color_white, 0, 0)
        draw.SimpleText(math.Round(record.fraction * 100, 1) .. '%', font, w, y, color_white, 2, 0)

        y = y + textH + space
    end
end

function PANEL:DrawChart(w, h)
    local data = self:GetData()
    local radius = math.min(w, h) * self:GetRadius()
    local isDonut = self:GetDonut()
    local outlineThickness = 4

    if (isDonut) then
        onyx.DrawOutlinedCircle(w * .5, h * .5, radius, outlineThickness, self.m_colCircleBackgroundColor)
    else
        onyx.DrawCircle(w * .5, h * .5, radius, self.m_colCircleBackgroundColor)
    end

    for _, record in ipairs(data) do
        onyx.DrawWithPolyMask(record.poly, function()
            if (isDonut) then
                onyx.DrawOutlinedCircle(w * .5, h * .5, radius, outlineThickness, record.color)
            else
                onyx.DrawCircle(w * .5, h * .5, radius, record.color)
            end
        end)
    end

    self:PostDrawChart(w, h)
end

function PANEL:PostDrawChart(w, h)

end

function PANEL:PerformChart(w, h)
    local data = self:GetData()
    local startAngle = 0
    local radius = math.min(w, h) * self:GetRadius()

    for _, record in ipairs(data) do
        if (not record.fraction) then break end

        local segmentAngle = math.Round(record.fraction * CIRCLE_FULL_ANGLE)

        record.poly = onyx.CalculateArc(w * .5, h * .5, startAngle, segmentAngle, radius + 2, 24, true)

        startAngle = startAngle + segmentAngle
    end
end

onyx.gui.Register('onyx.PieChart', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.Frame', .65, .65, function(self, w, h)
--     self:MakePopup()
--     local content = self:Add('onyx.PieChart')
--     content:DockPadding(10, 10, 10, 10)
--     content:Dock(FILL)
--     -- content:SetLegendVisible(false)
--     content:AddRecord('Apple', 10, Color(220, 31, 31))
--     content:AddRecord('Pear', 10, Color(113, 193, 78))
--     content:AddRecord('Banana', 5, Color(255, 224, 48))
--     content:AddRecord('Orange', 2, Color(255, 143, 15))
--     content:SetDonut(true)
-- end)
--addons/onyx_f4/lua/onyx/modules/f4/ui/cl_frame.lua:
return gluapack()()
--addons/onyx_f4/lua/onyx/modules/f4/ui/cl_tab_shop.lua:
return gluapack()()
--addons/onyx_f4/lua/onyx/modules/f4/ui/cl_tab_shop.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorLine = Color(75, 75, 75)
local colorCanAfford = Color(121, 255, 141)
local colorCannotAfford = Color(253, 120, 120)
local oldScrollValues = {}
local convars = {}
local itemTypes = {'entities', 'weapons', 'shipments', 'ammo'}
for _, itemType in ipairs(itemTypes) do
    convars[itemType] = CreateClientConVar('cl_onyx_f4_show_favorite_' .. itemType, '1', true, false)
end

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)

    self.container = self:Add('Panel')
    self.container:Dock(FILL)

    self.toolbar = self:Add('DPanel')
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(80))
    self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        self.topRow:SetTall(h / 2)
        self.favToggler:SetWide(self.favToggler:GetContentWidth())
    end

    self.topRow = self.toolbar:Add('Panel')
    self.topRow:Dock(BOTTOM)
    self.topRow:DockPadding(toolbarPadding, toolbarPadding, toolbarPadding * 2, toolbarPadding)

    self.navbar = self.toolbar:Add('onyx.Navbar')
    self.navbar:Dock(FILL)
    self.navbar:SetContainer(self.container)
    self.navbar:SetKeepTabContent(true)
    -- self.navbar:SetRoundness(8)
    self.navbar.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorTertiary, true, true)
        surface.SetDrawColor(colorLine)
        surface.DrawRect(0, h - 1, w, 1)
    end
    self.navbar.OnTabSelected = function(panel, tab, content)
        local convar = convars[tab.ItemType]

        self.search:SetValue('')
        self.favToggler:SetVisible(convar ~= nil)

        if (convar) then
            self.favToggler:SetChecked(convar:GetBool())
            self.favToggler.OnChange = function(panel, bool)
                convar:SetBool(bool)

                tab.content:Remove()
                self.navbar:SelectTab(tab, true)
                tab.content:SetAlpha(0)
                tab.content:AlphaTo(255, .3)
            end
        end
    end

    self.favToggler = self.topRow:Add('onyx.TogglerLabel')
    self.favToggler:Dock(RIGHT)
    self.favToggler:SetText(L('f4_show_favorite'))
    self.favToggler:SetBackgroundColor(onyx.OffsetColor(colorTertiary, 10))
    self.favToggler:Font('Comfortaa Bold@18')
    self.favToggler:SetTextMargin(onyx.ScaleTall(10))

    self.search = self.topRow:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('f4_search_text'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(150))
    self.search:SetUpdateOnType(true)
    self.search.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        local activeTab = self.navbar:GetActiveTab()
        if (not IsValid(activeTab)) then return end

        local plist = activeTab.content

        for _, cat in ipairs(plist:GetItems()) do
            local layout = cat.canvas:GetChild(0)
            local items = layout:GetChildren()
            local visibleItemAmount = 0

            for _, item in ipairs(items) do
                if (onyx.utf8.lower(item:GetName()):find(value, nil, true)) then
                    item:SetVisible(true)
                    visibleItemAmount = visibleItemAmount + 1
                else
                    item:SetVisible(false)
                end
            end

            layout:InvalidateLayout()

            cat:SetVisible(value == '' or visibleItemAmount > 0)
            cat:UpdateInTick()
        end

        plist:InvalidateLayout()
    end

    self.enabledFirst = false
    self.categories = {}
    self:AddItemCategory('entities', L('f4_entities_u'), 'https://i.imgur.com/JnNGizM.png', Color(141, 208, 255), 'canBuyCustomEntity', function(item)
        RunConsoleCommand('darkrp', item.cmd)
    end)

    self:AddItemCategory('weapons', L('f4_weapons_u'), 'https://i.imgur.com/IJQlezA.png', Color(255, 73, 73), 'canBuyCustomWeapon', function(item)
        RunConsoleCommand('darkrp', 'buy', item.name)
    end)

    self:AddItemCategory('shipments', L('f4_shipments_u'), 'https://i.imgur.com/9uyTLgB.png', Color(255, 173, 67), 'canBuyCustomShipment', function(item)
        RunConsoleCommand('darkrp', 'buyshipment', item.name)
    end)

    self:AddItemCategory('ammo', L('f4_ammo_u'), 'https://i.imgur.com/oRqB4Cl.png', Color(255, 246, 141), 'canBuyCustomAmmo', function(item)
        RunConsoleCommand('darkrp', 'buyammo', item.id)
    end)

    if (DarkRP.getFoodItems) then
        local food = DarkRP.getFoodItems()
        if (food) then
            self:AddItemCategory({{
                name = L('f4_food_u'),
                members = food,
            }}, L('f4_food_u'), 'https://i.imgur.com/sJWsDi6.png', Color(171, 255, 141), nil, function(item)
                RunConsoleCommand('darkrp', 'buyfood', item.name)
            end)
        end
    end
end

function PANEL:AddItemCategory(id, name, icon, color, hookName, purchaseFunc)
    local showUnavailable = onyx.f4:GetOptionValue('job_show_unavailable')
    local client = LocalPlayer()
    local teamIndex = client:Team()
    local categories = {}
    local membersAmount = 0

    local darkRPCategories = istable(id) and id or DarkRP.getCategories()[id]
    if (not darkRPCategories) then
        return
    end

    -- No favorites for food, sorry :(
    if (isstring(id)) then
        local members = onyx.f4:FetchFavoriteObjects(id)
        if (members) then
            table.insert(categories, {
                members = members,
                name = L('f4_favorite_u'),
                favorite = true
            })
        end
    end

    for _, cat in ipairs(darkRPCategories) do
        local canSee = cat.canSee
        local catName = cat.name
        local catMembers = {}

        if (not canSee or canSee(client)) then

            for _, member in ipairs(cat.members or {}) do
                local customCheck = member.customCheck
                local allowed = member.allowed
                local reason

                if (customCheck and not customCheck(client)) then
                    if (showUnavailable) then
                        reason = L('f4_unavailable')
                    else
                        continue
                    end
                end

                if (hookName) then
                    local canBuy, suppress, message = hook.Call(hookName, nil, client, member)
                    if (canBuy == false) then
                        if (not suppress) then
                            reason = message
                        else
                            continue
                        end
                    end
                end

                if (allowed and not table.HasValue(allowed, teamIndex)) then
                    continue
                end

                if (member.energy and member.requiresCook ~= false and not client:isCook()) then
                    return
                end

                membersAmount = membersAmount + 1
                table.insert(catMembers, {
                    item = member,
                    reason = reason
                })
            end

            table.insert(categories, {
                members = catMembers,
                name = catName
            })

        end
    end

    self.categories[id] = categories

    if (membersAmount > 0) then
        local tab = self.navbar:AddTab({
            name = name,
            icon = icon,
            class = 'onyx.ScrollPanel',
            onBuild = function(content)
                self:SetupItemList(content, self.categories[id], color, purchaseFunc, id)

                content.OnRemove = function(panel)
                    if (panel.scrollInitialized) then
                        oldScrollValues[id] = panel.scroll:GetScroll()
                    end
                end

                timer.Simple(engine.TickInterval() * 4, function()
                    if (IsValid(content)) then
                        content.scrollInitialized = true

                        local oldScrollValue = oldScrollValues[id]
                        if (oldScrollValue) then
                            content.scroll:SetScroll(oldScrollValue)
                            content.scroll.Current = oldScrollValue
                            content.canvas.container:SetPos(0, -oldScrollValue)
                        end
                    end
                end)
            end
        })

        tab.ItemType = id

        if (not self.enabledFirst) then
            self.enabledFirst = true
            self.navbar:SelectTab(tab, true)
        end
    end
end

function PANEL:SetupItemList(content, categories, color, purchaseFunc, itemType)
    local convar = convars[itemType]
    for _, category in ipairs(categories) do
        if (convar and category.favorite and not convar:GetBool()) then continue end
        if (#category.members > 0) then
            self:CreateCategory(content, category.name, category.members, color, purchaseFunc, itemType)
        end
    end
end

function PANEL:CreateCategory(container, name, members, color, purchaseFunc, itemType)
    local pnlCategory = container:Add('onyx.Category')
    pnlCategory:Dock(TOP)
    pnlCategory:SetTitle(onyx.utf8.upper(name))
    pnlCategory:SetSpace(0)
    pnlCategory:SetInset(onyx.ScaleTall(10))
    pnlCategory:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    pnlCategory:SetExpanded(true)
    pnlCategory.m_iTextMargin = onyx.ScaleTall(10)
    pnlCategory.m_bSquareCorners = true
    pnlCategory.canvas.Paint = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, false, false, true, true)
    end

    local content = pnlCategory:Add('onyx.Grid')
    content:Dock(TOP)
    content:SetTall(0)
    content:SetSpaceX(onyx.ScaleTall(5))
    content:SetSpaceY(content:GetSpaceX())
    content:SetColumnCount(onyx.f4:GetOptionValue('item_columns'))
    content.category = pnlCategory
    content.parentContainer = container

    for _, member in ipairs(members) do
        self:CreateMember(member.item, content, color, purchaseFunc, member.reason, itemType)
    end

    pnlCategory:UpdateInTick()
    pnlCategory:UpdateInTick(10)
    pnlCategory:UpdateInTick(100)
end

function PANEL:CreateMember(member, content, color, purchaseFunc, reason, itemType)
    local model = member.model
    local price = itemType == 'weapons' and member.pricesep or member.price

    local item = content:Add('onyx.f4.Item')
    item:SetTall(onyx.ScaleTall(55))
    item:SetModel(model)
    item:SetName(member.name)
    item:SetColor(color or Color(200, 200, 200), .1)
    item:SetDesc(DarkRP.formatMoney(price))
    item:SetDescLabel(L('f4_price'))
    item:SetDescColor(Color(69, 192, 87))
    item.objectIdentifier = (member.ent or member.entity or member.name)
    if (not member.energy) then
        item:AddFavoriteButton()
    end
    item.Think = function(panel)
        if ((panel.nextThink or 0) > CurTime()) then return end
        local balance = LocalPlayer():getDarkRPVar('money') or 0
        panel.nextThink = CurTime() + .33
        panel:SetDescColor(balance >= price and colorCanAfford or colorCannotAfford)
    end
    item.OnFavoriteStateSwitched = function()
        local navbar = self.navbar
        local activeTab = navbar:GetActiveTab()
        local itemType = activeTab.ItemType
        local allCategories = self.categories[itemType]
        local favCategory = allCategories[1]

        if (favCategory and favCategory.favorite) then
            favCategory.members = onyx.f4:FetchFavoriteObjects(itemType)
        end

        activeTab.content:Remove()
        navbar:SelectTab(activeTab, true)
        activeTab.content:SetAlpha(0)
        activeTab.content:AlphaTo(255, .3)
    end

    if (reason) then
        item:SetDescColor(Color(221, 107, 107))
        item:SetDesc(reason)
        item:SetDescLabel('')
    end

    item:Import('click')
    item:Import('hovercolor')
    item:SetColorKey('colorBG')
    item:SetColorIdle(colorSecondary)
    item:SetColorHover(colorTertiary)
    item:AddHoverSound()
    item:AddClickEffect()
    item.DoClick = function()
        if (purchaseFunc) then
            purchaseFunc(member)
        end
    end

    item:PositionCamera('center')
end

onyx.gui.Register('onyx.f4.Shop', PANEL)

-- onyx.gui.Test('onyx.f4.Frame', .65, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(3)
-- end)
--addons/bb_onyx_hud/lua/onyx/modules/hud/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

onyx:Addon( 'hud', {
    color = Color( 99, 65, 211 ),
    author = 'tochnonement',
    version = '1.0.11',
    licensee = '76561198314224586'
} )

----------------------------------------------------------------

onyx.Include( 'sv_sql.lua' )
onyx.IncludeFolder( 'onyx/modules/hud/languages/' )
onyx.IncludeFolder( 'onyx/modules/hud/core/', true )
onyx.IncludeFolder( 'onyx/modules/hud/cfg/', true )
onyx.IncludeFolder( 'onyx/modules/hud/elements/' )
onyx.IncludeFolder( 'onyx/modules/hud/ui/' )

onyx.hud:Print( 'Finished loading.' )
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_icons.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_icons.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

onyx.wimg.Register( 'hud_microphone', 'https://i.imgur.com/gcM94Fk.png' ) -- 128x128
onyx.wimg.Register( 'hud_chat', 'https://i.imgur.com/q5Lw2qs.png' ) -- 128x128
onyx.wimg.Register( 'hud_connection_lost', 'https://i.imgur.com/EoFpsnf.png' ) -- 128x128

-- 64x64
onyx.wimg.Register( 'hud_wanted', 'https://i.imgur.com/rFyMifb.png' ) 
onyx.wimg.Register( 'hud_license', 'https://i.imgur.com/gltIVYm.png' )
onyx.wimg.Register( 'hud_food', 'https://i.imgur.com/PBZSeVr.png' )
onyx.wimg.Register( 'hud_shield', 'https://i.imgur.com/6Bvc6jX.png' )
onyx.wimg.Register( 'hud_heart', 'https://i.imgur.com/p5Ydzmp.png' )
onyx.wimg.Register( 'hud_lockdown', 'https://i.imgur.com/4K2lTOO.png' )
onyx.wimg.Register( 'hud_arrested', 'https://i.imgur.com/7WVcWRg.png' )

onyx.wimg.Register( 'radial_close', 'https://i.imgur.com/O2fDo4C.png' )
onyx.wimg.Register( 'door_sell', 'https://i.imgur.com/sk1wknE.png' )
onyx.wimg.Register( 'door_title', 'https://i.imgur.com/ShyxozE.png' )
onyx.wimg.Register( 'door_add_user', 'https://i.imgur.com/MMBU6Qg.png' )
onyx.wimg.Register( 'door_remove_user', 'https://i.imgur.com/veLnn9Z.png' )
onyx.wimg.Register( 'door_disable_own', 'https://i.imgur.com/jbItdgJ.png' )
onyx.wimg.Register( 'door_enable_own', 'https://i.imgur.com/B2sTNGW.png' )
onyx.wimg.Register( 'door_own', 'https://i.imgur.com/tCUFyic.png' )
onyx.wimg.Register( 'door_groups', 'https://i.imgur.com/ttokI0C.png' )

--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_main.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

local hud = onyx.hud
local COLOR_BAR = Color( 200, 200, 200, 10 )
local COLOR_GRAY = Color( 183, 183, 183)
local COLOR_XP = Color( 202, 183, 14)

local WIMG_HEART = onyx.wimg.Create( 'hud_heart', 'smooth mips' )
local WIMG_SHIELD = onyx.wimg.Create( 'hud_shield', 'smooth mips' )
local WIMG_FOOD = onyx.wimg.Create( 'hud_food', 'smooth mips' )
local WIMG_LICENSE = onyx.wimg.Create( 'hud_license', 'smooth mips' )
local WIMG_STAR = onyx.wimg.Create( 'hud_wanted', 'smooth mips' )
local WIMG_MICROPHONE = onyx.wimg.Create( 'hud_microphone', 'smooth mips' )
local CONVAR_COMPACT = CreateClientConVar( 'cl_onyx_hud_compact', '0', true, false, '', 0, 1 )
local CONVAR_3D = CreateClientConVar( 'cl_onyx_hud_3d_models', '0', true, false, '', 0, 1 )
local CONVAR_HELP = CreateClientConVar( 'cl_onyx_hud_show_help', '1', true, false, '', 0, 1 )

-- They are scaled after
local UNSCALED_BAR_H = 6
local UNSCALED_BAR_ICON_SIZE = 12
local UNSCALED_ICON_SIZE = 18
local UNSCALED_SPACE = 5

local slowLabels = {}
local lastMaskY
local lerpHealth, lerpArmor, lerpHunger
local lerpMoney

local function formatSalary( salary )
    -- local iters = ( 3600 / GAMEMODE.Config.paydelay )
    -- local full = math.Round( salary * iters )
    -- local formatted = '+' .. DarkRP.formatMoney( full ) .. '/h'
    return '+ ' .. DarkRP.formatMoney( salary )
end

local function drawIndicator( x, y, w, h, material, color, fraction )
    local iconSize = h
    local iconSpace = hud.ScaleTall( UNSCALED_SPACE )

    local theme = hud:GetCurrentTheme()
    local isDark = theme.isDark
    local colors = theme.colors
    local colorTextPrimary = colors.textPrimary
    local colorTextSecondary = colors.textSecondary

    local rectX, rectW = x + ( iconSize + iconSpace ), w - ( iconSize + iconSpace )
    local rectH = math.min( h, hud.ScaleTall( UNSCALED_BAR_H ) )
    local rectY = math.floor( y + iconSize * .5 - rectH * .5 )

    material:Draw( x, y, iconSize, iconSize, color )
    
    hud.DrawRoundedBox( rectX, rectY, rectW, rectH, ColorAlpha( colorTextPrimary, isDark and 10 or 200 ) )

    render.SetScissorRect( rectX, rectY, rectX + rectW * fraction, rectY + rectH, true )
        hud.DrawRoundedBox( rectX, rectY, rectW, rectH, color )
    render.SetScissorRect( 0, 0, 0, 0, false )
end

local function drawStatusIcon( x, y, w, h, material, color )
    material:Draw( x, y, w, h, color or hud:GetColor( 'textTertiary' ) )
end

local function recreateAvatar( self )
    local bUse3DModel = CONVAR_3D:GetBool()
    local bUseModel = hud:GetOptionValue( 'main_avatar_mode' ) == 1
    local client = LocalPlayer()

    if ( IsValid( self.AvatarPanel ) ) then
        self.AvatarPanel:Remove()
    end

    if ( bUseModel ) then
        if ( bUse3DModel ) then
            self.AvatarPanel = vgui.Create( 'DModelPanel' )
            self.AvatarPanel.LayoutEntity = function() end
            self.AvatarPanel.PostUpdateLook = function( panel, model )
                local ent = panel.Entity
    
                if ( IsValid( ent ) ) then
                    local boneID = ent:LookupBone( 'ValveBiped.Bip01_Head1' )
                    if ( boneID ) then       
                        local bonePos = ent:GetBonePosition( boneID )
                        if ( bonePos ) then
                            bonePos:Add( Vector( 0, 0, 2 ) )
                    
                            panel:SetLookAt (bonePos)
                            panel:SetCamPos( bonePos - Vector(-20, 0, 0) )
                            panel:SetFOV( 45 )
                    
                            ent:SetEyeTarget( bonePos - Vector(-20, 0, 0) )
                        end
                    end
                end
            end
        else
            self.AvatarPanel = vgui.Create( 'SpawnIcon' )
        end

        self.AvatarPanel.UpdateLook = function( panel, modelData )
            panel.modelData = modelData

            hud.UpdateModelIcon( panel, modelData )

            if ( panel.PostUpdateLook ) then
                panel:PostUpdateLook()
            end
        end

        local nextComparison = 0
        self.AvatarPanel.Think = function( panel )
            if ( nextComparison <= CurTime() ) then
                nextComparison = CurTime() + 1
            
                local actualData = hud.GetModelData( LocalPlayer() )
                local currentData = panel.modelData
    
                if ( not currentData or not hud.CompareModelData( currentData, actualData ) ) then
                    panel:UpdateLook( actualData )
                end
            end
        end
    else
        self.AvatarPanel = vgui.Create( 'AvatarImage' )
        self.AvatarPanel:SetPlayer( client, 128 )
    end

    self.AvatarPanel:SetPaintedManually( true )
    self.AvatarPanel:ParentToHUD()
end

local updateSlowLabels do
    local nextUpdate = 0
    local thinkRate = 1 / 10

    local function findBestFont( text, maxWidth, ... )
        local bestFont = select( 1, ... )
        assert( bestFont, 'no fonts given' )

        local lastWidth = math.huge
        for _, font in ipairs( { ... } ) do
            local width = onyx.GetTextSize( text, font )
            local isGood = width <= maxWidth

            if ( isGood or width < lastWidth ) then
                bestFont = font
                lastWidth = width

                if ( isGood ) then
                    break
                end
            end
        end

        return bestFont
    end

    function updateSlowLabels( client, maxWidth )
        if ( nextUpdate <= CurTime() ) then
            nextUpdate = CurTime() + thinkRate
            slowLabels = {}

            local name = client:Name()
            local job = ( client:getDarkRPVar( 'job' ) or team.GetName( client:Team() ) )

            slowLabels.name = {
                text = name,
                font = findBestFont( name, maxWidth, hud.fonts.Name, hud.fonts.SmallBold, hud.fonts.TinyBold, hud.fonts.ExtraTinyBold )
            }

            slowLabels.job = {
                text = job,
                font = findBestFont( job, maxWidth, hud.fonts.Small, hud.fonts.Tiny )
            }
        end
    end
end

local function drawMainHUD( self, client, scrW, scrH )
    local showJob = not CONVAR_COMPACT:GetBool()
    local space = hud.GetScreenPadding()
    local padding = hud.ScaleTall( 10 )
    local w, h = hud.ScaleWide( 300 ), hud.ScaleTall( showJob and 120 or 100 )
    local x, y = space, scrH - h - space

    -- Colors
    local theme = hud:GetCurrentTheme()
    local colors = theme.colors

    local colorPrimary = colors.primary
    local colorSecondary = colors.secondary
    local colorTertiary = colors.tertiary
    local colorTextPrimary = colors.textPrimary
    local colorTextSecondary = colors.textSecondary
    local isDark = theme.isDark

    -- Player variables
    local animSpeed = FrameTime() * 16
    local healthFraction = math.Clamp( client:Health() / client:GetMaxHealth(), 0, 1 )
    local armorFraction = math.Clamp( client:Armor() / client:GetMaxArmor(), 0, 1 )
    local money = client:getDarkRPVar( 'money' ) or 0

    lerpHealth = Lerp( animSpeed, lerpHealth or healthFraction, healthFraction )
    lerpArmor = Lerp( animSpeed, lerpArmor or armorFraction, armorFraction )
    lerpMoney = Lerp( animSpeed, lerpMoney or money, money )

    local name = client:Nick()
    local teamColor = team.GetColor( client:Team() )
    local moneyFormatted = DarkRP.formatMoney( math.Round( lerpMoney ) )
    local salary = client:getDarkRPVar( 'salary' ) or 0
    local salaryFormatted = formatSalary( salary )
    local hasHunger = not DarkRP.disabledDefaults[ 'modules' ][ 'hungermod' ]
    local hasArmor = math.Round( lerpArmor, 2 ) > 0
    local rectAmount = ( hasHunger or hasArmor ) and 2 or 1
    local rectH = hud.ScaleTall( UNSCALED_BAR_ICON_SIZE )

    -- Increase HUD height if there is multiple bars
    if ( rectAmount > 1 ) then
        local extraHeight = hud.ScaleTall( 10 )
        h = h + extraHeight
        y = y - extraHeight
    end

    local avatarSpaceWidth = hud.ScaleWide( 80 )
    local labelX = x + avatarSpaceWidth + padding
    local labelY = y + padding

    -- Draw background
    hud.DrawRoundedBox( x, y, w, h, colorPrimary )
    hud.DrawRoundedBoxEx( x, y, avatarSpaceWidth, h, colorSecondary, true, false, true )

    -- Draw labels
    local labelMaxW = w - avatarSpaceWidth - padding * 2
    
    updateSlowLabels( client, labelMaxW )
    
    -- Limited render bounds for labels
    render.SetScissorRect( 0, 0, labelX + labelMaxW, ScrH(), true )

    local _, nameHeight = draw.SimpleText( slowLabels.name.text, slowLabels.name.font, labelX, labelY, colorTextPrimary, 0, 0 )

    local teamHeight
    if ( showJob ) then
        _, teamHeight = draw.SimpleText( slowLabels.job.text, slowLabels.job.font, labelX, labelY + nameHeight, teamColor, 0, 0 )
    else
        teamHeight = 0
    end

    local _, moneyHeight = draw.SimpleText( moneyFormatted, hud.fonts.Small, labelX, labelY + nameHeight + teamHeight, colorTextSecondary, 0, 0 )
    draw.SimpleText( salaryFormatted, hud.fonts.Small, x + w - padding, labelY + nameHeight + teamHeight, colorTextSecondary, 2, 0 )

    render.SetScissorRect( 0, 0, 0, 0, false )

    local contentH = nameHeight + teamHeight + moneyHeight
    local topPartH = contentH + padding * 2
    local lineY = labelY + contentH + padding
    local lineW = w - avatarSpaceWidth - padding * 2
    local lineH = math.max( 1, hud.ScaleTall( 2 ) )
    
    -- Prepare a mask for avatar
    local avatarY = y + padding
    local avatarSize = math.min( contentH, avatarSpaceWidth - padding * 2 )
    local circleRadius = math.Round( avatarSize * .5 )
    local circleOutlineThickness = hud.ScaleTall( 2.5 )

    local maskX0 = x + math.Round( avatarSpaceWidth * .5 )
    local maskY0 = avatarY + circleRadius
    local maskX, maskY = maskX0 - circleRadius, avatarY

    if ( not self.AvatarMask or not lastMaskY or lastMaskY ~= maskY0 ) then
        lastMaskY = maskY0
        self.AvatarMask = onyx.CalculateCircle( maskX0, maskY0, circleRadius, 32 )
    end

    -- Draw avatar
    if ( IsValid( self.AvatarPanel ) ) then
        onyx.DrawWithPolyMask( self.AvatarMask, function()
            if ( self.AvatarPanel:GetClassName() ~= 'AvatarImage' ) then
                -- Draw fancy background for model icons
                onyx.DrawCircle( maskX0, maskY0, circleRadius, colorPrimary )
                onyx.DrawMatGradient( maskX, maskY, avatarSize, avatarSize, BOTTOM, ColorAlpha( teamColor, isDark and 25 or 150 )  )
            end

            self.AvatarPanel:SetPos( maskX, maskY )
            self.AvatarPanel:SetSize( avatarSize, avatarSize )
            self.AvatarPanel:PaintManual()

            if ( client:IsSpeaking() ) then
                local micSize = avatarSize * .5

                micSize = micSize + ( micSize * .2 * math.abs( math.sin( CurTime() * 2 ) ) )

                surface.SetDrawColor( 0, 0, 0, 225 )
                surface.DrawRect( maskX, maskY, avatarSize, avatarSize )
                
                WIMG_MICROPHONE:DrawRotated( maskX0, maskY0, micSize, micSize, 0 )
            end
        end )

        onyx.DrawOutlinedCircle( maskX0, maskY0, circleRadius + circleOutlineThickness * .5, circleOutlineThickness, teamColor )
    end

    -- Draw separator
    if ( isDark ) then
        surface.SetDrawColor( 0, 0, 0, 50 )
    else
        surface.SetDrawColor( 100, 100, 100, 100 )
    end
    surface.DrawRect( x, lineY, w, lineH )

    local footerH = h - topPartH
    local footerY0 = lineY + footerH * .5

    -- Draw icons
    local iconSize = hud.ScaleTall( UNSCALED_ICON_SIZE )
    local iconSpace = hud.ScaleTall( UNSCALED_SPACE ) * .75
    local iconX0 = x + avatarSpaceWidth * .5
    local iconY0 = footerY0 - iconSize * .5
    
    drawStatusIcon( iconX0 - iconSize - iconSpace, iconY0, iconSize, iconSize, WIMG_LICENSE, client:getDarkRPVar( 'HasGunlicense' ) and hud:GetColor( 'accent' )  )
    drawStatusIcon( iconX0 + iconSpace, iconY0, iconSize, iconSize, WIMG_STAR, client:getDarkRPVar( 'wanted' ) and hud.GetAnimColor( 0 ) )

    -- Draw indicators
    local rectSpace = hud.ScaleTall( 3 )
    local totalIndictatorsH = rectAmount * rectH + ( rectAmount - 1 ) * rectSpace
    local rectY = footerY0 - totalIndictatorsH * .5

    drawIndicator( labelX, rectY, lineW - 30, rectH, WIMG_HEART, Color( 197, 54, 54), lerpHealth )
    draw.SimpleText( client:Health(), hud.fonts.Tiny, labelX + hud.ScaleTall( UNSCALED_SPACE * 37) , rectY - 5, Color(255,255,255), 0, 0 )
    rectY = rectY + rectH + rectSpace

    if ( hasHunger ) then
        local iconSpace = hud.ScaleTall( UNSCALED_SPACE * 1 )
        local halfLineWidth = lineW * .5 - iconSpace * .5
        local hungerFraction = math.Clamp( client:getDarkRPVar( 'Energy', 0 ) / 100, 0, 1 )

        lerpHunger = Lerp( animSpeed, lerpHunger or hungerFraction, hungerFraction )
        
        drawIndicator( labelX, rectY, halfLineWidth, rectH, WIMG_FOOD, Color( 197, 157, 54), lerpHunger )
        drawIndicator( labelX + halfLineWidth + iconSpace, rectY, halfLineWidth, rectH, WIMG_SHIELD, Color( 54, 102, 197), lerpArmor )
    elseif ( hasArmor ) then
        drawIndicator( labelX, rectY, lineW - 30, rectH, WIMG_SHIELD, Color( 54, 102, 197), lerpArmor )
        draw.SimpleText( client:Armor(), hud.fonts.Tiny, labelX + hud.ScaleTall( UNSCALED_SPACE * 37)  , rectY - 5, Color(255,255,255), 0, 0 )
    end

    -- Draw help
    local addBlockSpace = hud.ScaleTall( 7.5 )
    if ( onyx.hud:GetOptionValue( 'display_level' ) and onyx.hud.IsLevellingEnabled() ) then
        local addBlockH = hud.ScaleTall( 47.5 )
        local blockY = y - addBlockH - addBlockSpace
        local level, xp, maxXP = onyx.hud.GetLevelData( client )
        local nextLevelFraction = xp / maxXP
        local rectH = math.min( h, hud.ScaleTall( UNSCALED_BAR_H ) )

        hud.DrawRoundedBox( x, blockY, w, addBlockH, colorPrimary )

        local textW = draw.SimpleText( onyx.lang:Get( 'hud.level.name' ) .. ': ', hud.fonts.Tiny, x + padding, blockY + padding, colorTextSecondary, 0, 0 )
        draw.SimpleText( level, hud.fonts.SmallBold, x + padding + textW, blockY + padding, ( isDark and COLOR_XP or colorTextPrimary ), 0, 0 )

        local textW2 = draw.SimpleText( ' / ' .. maxXP, hud.fonts.Tiny, x + w - padding, blockY + padding, colorTextSecondary, 2, 0 )
        draw.SimpleText( xp, hud.fonts.TinyBold, x + w - padding - textW2, blockY + padding, colorTextPrimary, 2, 0 )

        hud.DrawRoundedBox( x + padding, blockY + addBlockH - padding - rectH, w - padding * 2, rectH, ColorAlpha( colorTextPrimary, isDark and 10 or 200 ) )
        onyx.hud.ScissorRect( x + padding, blockY + addBlockH - padding - rectH, ( w - padding * 2 ) * nextLevelFraction, rectH, function()
            hud.DrawRoundedBox( x + padding, blockY + addBlockH - padding - rectH, w - padding * 2, rectH, COLOR_XP )
        end )
    end
end

cvars.AddChangeCallback( 'cl_onyx_hud_3d_models', function()
    recreateAvatar( hud.elements[ 'main' ] )
end, 'hud.internal' )

hook.Add( 'onyx.inconfig.Updated', 'hud.RecreateAvatar', function( id, old, new )
    if ( id and id == 'hud_main_avatar_mode' ) then
        recreateAvatar( hud.elements[ 'main' ] )
    end
end )

hook.Add( 'onyx.inconfig.Synchronized', 'hud.RecreateAvatar', function( id )
    recreateAvatar( hud.elements[ 'main' ] )
end )

hud:RegisterElement( 'main', {
    priority = 100,
    drawFn = drawMainHUD,
    initFunc = recreateAvatar,
    onSizeChanged = function( self )
        self.AvatarMask = nil -- It will force to recalculate the circle mask
    end
} )
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_notifications.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

11/08/2024

--]]

local hud = onyx.hud
local cache = {}

local COLOR_BAR = Color( 0, 0, 0, 200 ) -- Only for light themes
local FONT_TEXT = 'onyx.hud.Small'
local NOTIFICATION_TYPES = {
    [ NOTIFY_GENERIC ] = {
        color = Color( 255, 228, 52),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/2muiD5k.png', 'smooth mips' )
    },
    [ NOTIFY_ERROR ] = {
        color = Color( 235, 57, 57),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/vNzFBlK.png', 'smooth mips' )
    },
    [ NOTIFY_UNDO ] = {
        color = Color( 69, 78, 255),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/sgLeDjb.png', 'smooth mips' )
    },
    [ NOTIFY_HINT ] = {
        color = Color( 37, 222, 225),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/vAjbKzK.png', 'smooth mips' )
    },
    [ NOTIFY_CLEANUP ] = {
        color = Color( 235, 81, 255),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/V3TyKJ9.png', 'smooth mips' )
    },
}

local function addNotification( text, type, length )
    table.insert( cache, 1, {
        text = text,
        type = type,
        endtime = CurTime() + length,
        duration = length
    } )
end

local function overrideNotifications()
    hud.original_AddLegacy = hud.original_AddLegacy or notification.AddLegacy

    function notification.AddLegacy( text, type, length )
        local text = tostring( text )
        local type = type or NOTIFY_GENERIC
        local length = length or 3
        local isEnabled = onyx.hud.IsElementEnabled( 'notifications' )
        
        if ( isEnabled ) then
            addNotification( text:Trim():gsub('\n', ' '), type, length )
        else
            hud.original_AddLegacy( text, type, length )
        end
    end
end
onyx.hud.OverrideGamemode( 'onyx.hud.OverrideNotifications', overrideNotifications )

local function drawNotifications( self, client, scrW, scrH )
    local theme = hud:GetCurrentTheme()
    local colorPrimary = theme.colors.primary
    local colorSecondary = theme.colors.secondary
    local colorTertiary = theme.colors.tertiary
    local colorText = theme.colors.textPrimary
    local isDark = theme.dark

    local space = onyx.hud.GetScreenPadding()
    local horPadding = onyx.hud.ScaleTall( 10 )
    local notifH = onyx.hud.ScaleTall( 30 )
    local hudRoundness = onyx.hud.GetRoundness()
    local notifSpace = onyx.hud.ScaleTall( 5 )
    local iconSpace = onyx.hud.ScaleTall( 10 )
    local iconSize = onyx.hud.ScaleTall( 18 )
    local lineH = onyx.hud.ScaleTall( 2 )

    local amount = #cache
    local posY = scrH * .75
    local speed = FrameTime() * 8

    -- to avoid overlapping
    if ( #onyx.hud.VoicePanels > 0 ) then
        for _, data in ipairs( onyx.hud.VoicePanels ) do
            local panel = data.panel
            if ( IsValid( panel ) and panel:IsVisible() ) then
                posY = math.min( posY, select( 2, panel:GetPos() ) )
            end
        end
        posY = posY - notifSpace
    end
    
    posY = posY - notifH

    for index = 1, amount do
        local data = cache[ index ]
        if ( not data ) then continue end

        local notifText = data.text
        local notifType = data.type or 0
        local notifTypeData = NOTIFICATION_TYPES[ notifType ] or NOTIFICATION_TYPES[ NOTIFY_GENERIC ]
        local notifColor = notifTypeData.color
        local timeLeft = math.max( 0, data.endtime - CurTime() )
        local lifeFraction = timeLeft / data.duration
        local expired = lifeFraction == 0
        local targetFraction = expired and 0 or 1
        local wimgObject = notifTypeData.wimg

        -- Get size
        surface.SetFont( FONT_TEXT )
        local textW, textH = surface.GetTextSize( notifText )
        local notifW = textW + horPadding * 2 + iconSize + iconSpace

        -- Calculate pos
        local posX = expired and scrW or ( scrW - notifW - space )

        data.x = Lerp( speed, data.x or scrW, posX )
        data.y = Lerp( speed, data.y or posY, posY )
        data.fraction = math.Approach( data.fraction or 0, targetFraction, speed )

        local x = data.x
        local y = math.ceil( data.y )

        -- Draw
        local prevAlpha = surface.GetAlphaMultiplier()
        local lineColor = isDark and ColorAlpha( notifColor, 20 ) or COLOR_BAR

        surface.SetAlphaMultiplier( data.fraction )

            onyx.hud.DrawRoundedBox( x, y, notifW, notifH, colorPrimary )

            wimgObject:Draw( x + horPadding, y + notifH * .5 - iconSize * .5, iconSize, iconSize, notifColor )

            render.SetScissorRect( x, y + notifH - lineH, x + notifW, y + notifH, true )
                onyx.hud.DrawRoundedBox( x, y, notifW, notifH, lineColor )
            render.SetScissorRect( x, y + notifH - lineH, x + notifW * lifeFraction, y + notifH, true )
                onyx.hud.DrawRoundedBox( x, y, notifW, notifH, notifColor )
            render.SetScissorRect( 0, 0, 0, 0, false )

            onyx.hud.DrawCheapText( notifText, FONT_TEXT, x + horPadding + iconSize + iconSpace, y + notifH * .5 - textH * .5, colorText )

        surface.SetAlphaMultiplier( prevAlpha )

        posY = posY - notifH - notifSpace

        if ( expired and data.fraction == 0 ) then
            table.remove( cache, index )
        end
    end
end

onyx.hud:RegisterElement( 'notifications', {
    priority = 90,
    drawFn = drawNotifications,
    hideElements = {}
} )

concommand.Add( 'onyx_hud_test_notifications', function( ply )
    if ( ply:IsAdmin() ) then
        local index = 0
        for type in pairs( NOTIFICATION_TYPES ) do
            index = index + 1
            notification.AddLegacy( 'Onyx HUD Notification', type, 10 - index )
        end
    end
end )
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_own_info.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_weapon_selector.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local SHOW_DURATION = 1.5
local MAX_SLOTS = 6
local CONVAR_SOUNDS = CreateClientConVar( 'cl_onyx_hud_wpnsel_sounds', '1', true, false, '', 0, 1 )

local hud = onyx.hud
local toggleFraction = 0
local toggleState = false
local slotsCache = {}
local selectorData = {
    selectedSlot = 1,
    selectedPos = 0,
    activeWeapon = NULL
}

local quickSwitchEnabled = GetConVar( 'hud_fastswitch' ):GetBool()

cvars.AddChangeCallback( 'hud_fastswitch', function(cname, old, new)
    quickSwitchEnabled = tobool( new )
end, 'onyx.hud' )

local function resetSlotsCache()
    slotsCache = {}
    for index = 1, MAX_SLOTS do
        slotsCache[ index ] = {}
    end
end

local function toggleWeaponSelector( state, bScroll )
    local oldState = toggleState
    
    toggleState = state

    if ( not state ) then
        toggleFraction = 0
        timer.Remove( 'onyx.hud.HideWeaponSelector' )
    else
        timer.Create( 'onyx.hud.HideWeaponSelector', SHOW_DURATION, 1, function()
            toggleWeaponSelector( false )
        end )

        if ( bScroll and not oldState and toggleFraction == 0 ) then
            local activeWeapon = selectorData.activeWeapon
            for slotIndex, slotWeapons in ipairs( slotsCache ) do
                for pos, weapon in ipairs( slotWeapons ) do
                    if ( weapon == activeWeapon ) then
                        selectorData.selectedSlot = slotIndex
                        selectorData.selectedPos = pos
                        break
                    end
                end
            end
        end
    end
end

local function drawWeaponSelector( client, scrW, scrH )
    toggleFraction = math.Approach( toggleFraction, toggleState and 1 or 0, FrameTime() * 8 )
    if ( toggleFraction <= 0 ) then return end 

    local prevAlpha = surface.GetAlphaMultiplier()
    local screenPadding = onyx.hud.GetScreenPadding()

    local activeSlots, emptySlots = 0, 0
    for _, cachedWeapons in ipairs( slotsCache ) do
        if ( #cachedWeapons > 0 ) then
            activeSlots = activeSlots + 1
        else
            emptySlots = emptySlots + 1
        end
    end

    local slotSpace = onyx.hud.ScaleTall( 3 )
    local baseSlotH = onyx.hud.ScaleTall( 27.5 )
    local slotActiveW = onyx.hud.ScaleWide( 150 )
    local slotEmptyW = baseSlotH

    local totalW = slotSpace * ( MAX_SLOTS - 1) + activeSlots * slotActiveW + emptySlots * slotEmptyW

    local theme = hud:GetCurrentTheme()
    local colors = theme.colors
    local colorPrimary = colors.primary
    local colorSecondary = colors.secondary
    local colorTertiary = colors.tertiary
    local colorAccent = colors.accent
    local colorPrimaryText = colors.textPrimary
    local colorSecondaryText = colors.textSecondary
    local colorTertiaryText = colors.textTertiary
    local isDark = theme.dark

    local y = screenPadding
    local x = scrW * .5 - totalW * .5
    
    surface.SetAlphaMultiplier( toggleFraction )

    for slotIndex = 1, MAX_SLOTS do
        local slotWeapons = slotsCache[ slotIndex ]
        if ( not slotWeapons ) then break end

        local amount = #slotWeapons
        local isEmpty = amount == 0
        local isSlotSelected = selectorData.selectedSlot == slotIndex
        local slotW = isEmpty and slotEmptyW or slotActiveW
        local slotY = y

        hud.DrawRoundedBox( x, slotY, slotW, baseSlotH, isEmpty and colorPrimary or colorSecondary )
        draw.SimpleText( slotIndex, onyx.hud.fonts.SmallBold, x + slotW * .5, slotY + baseSlotH * .5, isEmpty and colorTertiaryText or colorSecondaryText, 1, 1 )

        slotY = slotY + baseSlotH + slotSpace

        if ( not isEmpty ) then
            for index = 1, amount do
                local wep = slotWeapons[ index ]
                if ( IsValid( wep ) ) then
                    local wepName = wep:GetPrintName()
                    local isSelected = isSlotSelected and ( index == selectorData.selectedPos )
                    local isActive = selectorData.activeWeapon == wep
                    local textColor = isSelected and ( isDark and colorAccent or onyx.LerpColor( .5, colorAccent, colorPrimaryText ) ) or ( isActive and colorPrimaryText or colorSecondaryText)
                    local slotH = isSelected and baseSlotH * 1.33 or baseSlotH
                    local slotFont = onyx.hud.fonts.TinyBold

                    if ( isSelected ) then
                        hud.DrawRoundedBox( x, slotY, slotW, slotH, colorAccent )
                        hud.DrawRoundedBox( x + 1, slotY + 1, slotW - 2, slotH - 2, colorPrimary )
                        hud.DrawRoundedBox( x + 1, slotY + 1, slotW - 2, slotH - 2, ColorAlpha( colorAccent, isDark and 5 or 150 ) )
                    else
                        hud.DrawRoundedBox( x, slotY, slotW, slotH, colorPrimary )
                    end
                    
                    -- This guarantee that weapon's name won't render outside slot's bounds
                    render.SetScissorRect( x, slotY, x + slotW, slotY + slotH, true )
                        draw.SimpleText( wepName, slotFont, x + slotW * .5, slotY + slotH * .5, textColor, 1, 1 )
                    render.SetScissorRect( 0, 0, 0, 0, false )

                    slotY = slotY + slotH + slotSpace
                end
            end
        end

        x = x + slotW + slotSpace
    end

    surface.SetAlphaMultiplier( prevAlpha )
end

local playSelectSound do
    local soundStation
    function playSelectSound()
        if ( not CONVAR_SOUNDS:GetBool() ) then return end

        soundStation = soundStation or CreateSound( LocalPlayer(), 'common/wpn_moveselect.wav' )
    
        if ( soundStation:IsPlaying() ) then
            soundStation:Stop()
        end
    
        soundStation:PlayEx( .5, 100 )
    end
end

do
    local binds = {}
    for index = 1, MAX_SLOTS do
        binds[ ( 'slot' .. index ) ] = index
    end

    local lastWeapon = NULL

    local function selectWeapon()
        local data = selectorData
        local slotWeapons = slotsCache[ data.selectedSlot ]
    
        if ( slotWeapons ) then
            local weapon = slotWeapons[ data.selectedPos ]
            if ( IsValid( weapon ) ) then
                lastWeapon = LocalPlayer():GetActiveWeapon()
                input.SelectWeapon( weapon )
                toggleWeaponSelector( false )
            end
        end
    end

    local function cycleWeapons( slot )
        local data = selectorData
        local wasActive = toggleState
        local prevSlot = data.selectedSlot
        
        toggleWeaponSelector( true )
        playSelectSound()

        if ( not wasActive and prevSlot == slot and not quickSwitchEnabled ) then return end

        local slotData = slotsCache[ slot ]
        local pos = data.selectedPos or 0
        local weaponsAmount = #slotData

        if ( prevSlot ~= slot ) then
            pos = 0
        end
        
        data.selectedSlot = slot
        data.selectedPos = pos + 1

        if ( data.selectedPos > weaponsAmount ) then
            data.selectedPos = 1
        end

        if ( quickSwitchEnabled ) then
            selectWeapon()
        end
    end

    local function scrollWeapons( delta )
        toggleWeaponSelector( true, true )
        playSelectSound()

        local data = selectorData
        local slot = data.selectedSlot or 1
        local slotData = slotsCache[ slot ]
        local pos = data.selectedPos or 0
        local weaponsAmount = #slotData

        data.selectedPos = pos + delta

        local bNext = data.selectedPos > weaponsAmount
        local bPrev = data.selectedPos < 1

        if ( bNext or bPrev ) then
            local newSlot = data.selectedSlot
            for _ = 1, MAX_SLOTS do
                newSlot = newSlot + delta
                if ( newSlot < 1 ) then newSlot = MAX_SLOTS end 
                if ( newSlot > MAX_SLOTS ) then newSlot = 1 end

                local amount = #slotsCache[ newSlot ]

                if ( amount > 0 ) then
                    data.selectedPos = ( bPrev and amount or 1 )
                    data.selectedSlot = newSlot
                    break
                end
            end
        end

        if ( quickSwitchEnabled ) then
            selectWeapon()
        end
    end

    hook.Add( 'PlayerBindPress', 'onyx.hud.HandleBinds', function( ply, bind, pressed, code )
        local slot = binds[ bind ]

        if ( ply:InVehicle() ) then return end

        if ( slot ) then
            cycleWeapons( slot )
        elseif ( bind == '+attack' and not quickSwitchEnabled ) then
            if ( toggleState ) then
                selectWeapon()
                return true
            end
        elseif ( not ply:KeyDown( IN_ATTACK ) ) then
            if ( bind == 'invprev' ) then
                scrollWeapons( -1 )
            elseif ( bind == 'invnext' ) then
                scrollWeapons( 1 )
            elseif ( bind == 'lastinv' ) then
                if ( IsValid( lastWeapon ) ) then
                    local wep = ply:GetActiveWeapon()
                    input.SelectWeapon( lastWeapon )
                    lastWeapon = wep
                end
            end
        end
    end )
end

hook.Add( 'PostDrawHUD', 'onyx.hud.DrawWeaponSelector', function()
    -- cam.Start2D fixes weird font issue in this hook
    cam.Start2D()
        drawWeaponSelector( LocalPlayer(), ScrW(), ScrH() )
    cam.End2D()
end )

hook.Add( 'HUDShouldDraw', 'onyx.hud.HideWeaponSelector', function( name )
    if ( name == 'CHudWeaponSelection' ) then
        return false
    end
end )

hook.Add( 'Think', 'onyx.hud.UpdateWeaponSelector', function()
    local client = LocalPlayer()
    local weaponsList = client:GetWeapons()
    
    resetSlotsCache()

    selectorData.activeWeapon = client:GetActiveWeapon()

    for _, wep in ipairs( weaponsList ) do
        if ( IsValid( wep ) ) then
            local slotIndex = math.Clamp( wep:GetSlot() + 1, 1, MAX_SLOTS )
            local slotWeapons = slotsCache[ slotIndex ]
            assert( slotWeapons, string.format( 'invalid slot index %d', slotIndex ) )
            table.insert( slotWeapons, wep )
        end
    end

    for index, cacheList in ipairs( slotsCache ) do
        table.sort( cacheList, function( a, b )
            return a:GetSlotPos() < b:GetSlotPos()
        end )
    end
end )
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

onyx:Addon('scoreboard', {
    color = Color(65, 162, 211),
    author = 'tochnonement',
    version = '1.0.6',
    licensee = '76561199388496809'
})

----------------------------------------------------------------

onyx.Include('sv_sql.lua')
onyx.IncludeFolder('onyx/modules/scoreboard/languages/')
onyx.IncludeFolder('onyx/modules/scoreboard/core/', true)
onyx.IncludeFolder('onyx/modules/scoreboard/cfg/', true)
onyx.IncludeFolder('onyx/modules/scoreboard/ui/')

onyx.scoreboard:Print('Finished loading.')
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_english.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copied to clipboard'
LANG['scoreboard_search'] = 'Search... (Name/SteamID)'
LANG['you'] = 'You'
LANG['friend'] = 'Friend'
LANG['addon_return_u'] = 'RETURN'

-- Columns
LANG['scoreboard_col_team'] = 'Team'
LANG['scoreboard_col_job'] = 'Job'
LANG['scoreboard_col_money'] = 'Money'
LANG['scoreboard_col_rank'] = 'Rank'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Playtime'
LANG['scoreboard_col_health'] = 'Health'
LANG['scoreboard_col_level'] = 'Level'
LANG['scoreboard_col_none'] = 'None'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Badges'
LANG['scoreboard_col_faction'] = 'Faction'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Default'
LANG['scoreboard_eff_glow'] = 'Glow'
LANG['scoreboard_eff_rainbow'] = 'Rainbow'
LANG['scoreboard_eff_scanning_vertical'] = 'Scanning (Vertical)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Scanning (Horizontal)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradient (Invert Color)'
LANG['scoreboard_eff_wavy_dual'] = 'Wavy (Dual Color)'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Open Profile'
LANG['scoreboard_btn_freeze'] = 'Freeze'
LANG['scoreboard_btn_goto'] = 'Goto'
LANG['scoreboard_btn_bring'] = 'Bring'
LANG['scoreboard_btn_return'] = 'Return'
LANG['scoreboard_btn_respawn'] = 'Respawn'
LANG['scoreboard_btn_slay'] = 'Slay'
LANG['scoreboard_btn_spectate'] = 'Spectate'

-- Words
LANG['rank_id'] = 'Rank Identifier'
LANG['name'] = 'Name'
LANG['effect'] = 'Effect'
LANG['color'] = 'Color'
LANG['preview'] = 'Preview'
LANG['creation'] = 'Creation'
LANG['save'] = 'Save'
LANG['dead'] = 'Dead'
LANG['create_new'] = 'Create New'
LANG['column'] = 'Column'

-- Settings
LANG['addon_settings_u'] = 'SETTINGS'
LANG['scoreboard_ranks_u'] = 'RANKS'
LANG['scoreboard_columns_u'] = 'COLUMNS'

LANG['scoreboard.title.name'] = 'Title'
LANG['scoreboard.title.desc'] = 'Input the title for the frame'

LANG['scoreboard.group_teams.name'] = 'Group Teams'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Group teams by job categories'

LANG['scoreboard.colored_players.name'] = 'Colorized Gradient'
LANG['scoreboard.colored_players.desc'] = 'Show colorized gradient on player line'

LANG['scoreboard.blur.name'] = 'Blur Theme'
LANG['scoreboard.blur.desc'] = 'Enable blur theme'

LANG['scoreboard.scale.name'] = 'Frame Size Scale'
LANG['scoreboard.scale.desc'] = 'Scale the scoreboard\'s frame size'

onyx.lang:AddPhrases('english', LANG)
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/cl_actions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

--[[------------------------------
**WARNING**
This is an advanced config.
Most of the things you need should be configurable through the game.
Do not edit anything if you do not understand what you are doing.
--------------------------------]]

onyx.scoreboard.Buttons = {}
onyx.scoreboard.adminHandler = nil

local adminHandlers = {}

local TYPE_NAME = 1
local TYPE_STEAMID64 = 2
local TYPE_STEAMID32 = 3

local function adminModeHandler(uniqueID, priority, validator, data)
    table.insert(adminHandlers, {
        uniqueID = uniqueID,
        priority = priority,
        validator = validator,
        data = data
    })
end

local function registerAdminButton(cmd, cmdData)
    onyx.scoreboard:RegisterButton(cmd, {
        callback = function(ply)
            local handler = onyx.scoreboard.adminHandler
            local data = handler.data
            local command = cmdData.getCommand and cmdData.getCommand(ply) or cmd

            local targetID
            if (data.idFormat == TYPE_STEAMID32) then
                targetID = ply:SteamID()
            elseif (data.idFormat == TYPE_STEAMID64) then
                targetID = ply:SteamID64()
            else
                targetID = ply:Name()
            end

            RunConsoleCommand(handler.uniqueID, command, targetID)
        end,
        getVisible = function(client)
            local handler = onyx.scoreboard.adminHandler
            if (not handler) then return false end

            local data = handler.data
            return data.hasPermission(client, cmd)
        end
    })
end

--[[------------------------------
Common actions
--------------------------------]]
onyx.scoreboard:RegisterButton('profile', {
    callback = function(ply)
        gui.OpenURL('https://steamcommunity.com/profiles/' .. ply:SteamID64())
    end
})

--[[------------------------------
FSpectate
--------------------------------]]
onyx.scoreboard:RegisterButton('spectate', {
    callback = function(ply)
        if (ply ~= LocalPlayer()) then
            net.Start("FSpectateTarget")
                net.WriteEntity(ply)
            net.SendToServer()
        end
    end,
    getVisible = function(client)
        local success, bHasAccess = pcall(CAMI.PlayerHasAccess, client, 'FSpectate')
        if (not success) then
            bHasAccess = client:IsSuperAdmin()
        end
        return (FSpectate ~= nil and (success and bHasAccess))
    end
})

--[[------------------------------
Admin actions
--------------------------------]]
registerAdminButton('freeze', {
    getCommand = function(target)
        return (target:IsFlagSet(FL_FROZEN) and 'unfreeze' or 'freeze')
    end
})

registerAdminButton('goto', {})
registerAdminButton('bring', {})
registerAdminButton('return', {})
registerAdminButton('respawn', {})
registerAdminButton('slay', {})

--[[------------------------------
Admin modes
--------------------------------]]
adminModeHandler('sam', 100, function()
    return sam
end, {
    idFormat = TYPE_STEAMID64,
    hasPermission = function(client, cmd)
        return client:HasPermission(cmd)
    end
})

do
    local DISABLED = {
        ['respawn'] = true,
    }

    adminModeHandler('ulx', 100, function()
        return ulx
    end, {
        idFormat = TYPE_NAME,
        hasPermission = function(client, cmd)
            return (client:query('ulx ' .. cmd) == true and not DISABLED[cmd])
        end
    })
end

do
    local DISABLED = {
        ['respawn'] = true,
        ['return'] = true,
    }

    adminModeHandler('fadmin', 1, function()
        return FAdmin
    end, {
        idFormat = TYPE_STEAMID32,
        hasPermission = function(client, cmd)
            return (client:IsAdmin() and not DISABLED[cmd])
        end
    })
end

--[[------------------------------
Fetch admin mode
--------------------------------]]
onyx.WaitForGamemode('onyx.scoreboard.InitButtons', function()
    table.sort(adminHandlers, function(a, b)
        return a.priority > b.priority
    end)

    for _, handler in ipairs(adminHandlers) do
        if (handler.validator()) then
            onyx.scoreboard.adminHandler = handler
            break
        end
    end

    if (onyx.scoreboard.adminHandler) then
        onyx.scoreboard:PrintSuccess('Found admin handler: ' .. onyx.scoreboard.adminHandler.uniqueID)
    else
        onyx.scoreboard:PrintWarning('Admin handler has not been found.')
    end
end)
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_player_list.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')
local COLOR_GRAY = Color(149, 149, 149)
local COLOR_GRAY_LIGHT = Color(198, 198, 198)

local WIMG_ARROW = onyx.wimg.Simple('https://i.imgur.com/oOoWQAG.png', 'smooth mips')

local function parseString(str)
    return onyx.utf8.lower(str)
end

local function processSearch(prompt, parentList)
    local prompt = string.lower(prompt):Trim()
    local categories = parentList:GetItems()

    for _, category in ipairs(categories) do
        if (category.ClassName ~= 'onyx.Category') then continue end

        for _, panel in ipairs(category:GetItems()) do
            local line = panel.button:GetChild(0)
            local name = line.parsedName
            local steamID32 = line.steamID32

            if (string.find(name, prompt, nil, true) or steamID32 == prompt or (prompt == '^' and line.isLocalPlayer)) then
                panel:Show()
                category:SetExpanded(true)
            else
                panel:Hide()
            end
        end

        category:Update()
    end
end

--[[------------------------------
// PANEL
--------------------------------]]
local PANEL = {}

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)
    local elementSpace = onyx.ScaleTall(10)
    local playerLineHeight = onyx.ScaleTall(30)
    local playerLinePadding = onyx.ScaleTall(5)
    local playerLineRealHeight = playerLineHeight - playerLinePadding * 2

    self.toolbarPadding = toolbarPadding
    self.playerLineHeight = playerLineHeight
    self.playerLinePadding = playerLinePadding

    self.toolbar = self:Add('Panel')
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        local contentMarginLeft = toolbarPadding * 3 + playerLineRealHeight * 2
        local scroll = self.list.scroll

        if (scroll:IsVisible()) then
            contentMarginLeft = contentMarginLeft + scroll:GetWide() + select(1, scroll:GetDockMargin())
        end

        panel:DockPadding(toolbarPadding, toolbarPadding, contentMarginLeft, toolbarPadding)
        panel:DockMargin(0, 0, 0, elementSpace)
    end

    self.search = self.toolbar:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('scoreboard_search'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:SetUpdateOnType(true)
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(175))
    self.search:SetCursor('beam')
    self.search.OnValueChange = function(panel, value)
        processSearch(value, self.list)
    end

    self.search.textEntry:SetTabbingDisabled(true)
    self.search.textEntry:SetMouseInputEnabled(false) -- this one is required to get access to parent, which triggers SetKeyboardInputEnabled on parent
    self.search.OnMousePressed = function(panel)
        onyx.scoreboard.Frame:SetKeyboardInputEnabled(true)
        onyx.scoreboard.Frame:ShowCloseButton(true)
        onyx.scoreboard.Frame.closeDisabled = true

        panel.textEntry:SetMouseInputEnabled(true)
        panel.textEntry:RequestFocus()
    end

    self.columns = self.toolbar:Add('onyx.Scoreboard.ColumnsRow')
    self.columns:Dock(FILL)
    self.columns:DockMargin(toolbarPadding, 0, 0, 0)
    self.columns:SetFont(onyx.Font('Comfortaa Bold@16'))
    self.columns:SetHeader(true)
    self.columns:InitColumns()

    self:AddSorting(self.columns)

    self.list = self:Add('onyx.ScrollPanel')
    self.list:SetSpace(onyx.ScaleTall(1))
    self.list.canvas:On('OnContainerTallUpdated', function()
        self.toolbar:InvalidateLayout()
    end)

    self.players = {}
    self:LoadPlayers()
end

function PANEL:PerformLayout(w, h)
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(35))

    self.list:Dock(FILL)
end

do
    function PANEL:FetchCategory(ply)
        if (DarkRP and onyx.scoreboard:GetOptionValue('group_teams')) then
            local jobData = RPExtraTeams[ply:Team()]
            if (jobData) then
                return jobData.category
            end
        end

        if (onyx.scoreboard.IsTTT()) then
            local _, name, color = onyx.scoreboard.GetTeamTTT(ply)
            return name, color
        end

        return team.GetName(ply:Team()), team.GetColor(ply:Team())
    end
end

function PANEL:LoadPlayers()
    local categories = {}
    local players = {}

    -- add players
    for _, ply in ipairs(player.GetAll()) do
        local bShouldHide = hook.Run('onyx.scoreboard.ShouldHidePlayer', ply) -- for possible custom integrations
        if (bShouldHide ~= true) then
            table.insert(players, ply)
        end
    end

    -- default sorting
    table.sort(players, function(a, b)
        return a:Team() < b:Team()
    end)

    for _, ply in ipairs(players) do
        local catName, catColor = self:FetchCategory(ply)
        local foundIndex

        for index, category in ipairs(categories) do
            if (category.name == catName) then
                foundIndex = index
                break
            end
        end

        if (not foundIndex) then
            local panel = self:AddCategory(onyx.utf8.upper(catName), catColor) -- utf-8 support

            foundIndex = table.insert(categories, {
                panel = panel,
                name = catName,
                color = catColor, -- might be nil
                players = {}
            })
        end

        table.insert(categories[foundIndex].players, ply)
    end

    self.queue = {}
    for _, category in ipairs(categories) do
        for _, ply in ipairs(category.players) do
            table.insert(self.queue, {
                category = category.panel,
                ply = ply
            })
        end
    end
end

function PANEL:Think()
    local queue = self.queue
    if (queue) then
        local object = queue[1]
        if (object) then
            local ply = object.ply
            local cat = object.category

            table.remove(queue, 1)

            if (IsValid(ply)) then
                self:AddPlayer(ply, cat)
                cat:Update()
            end
        end
    end
end

function PANEL:AddSorting(panel)
    for index, column in ipairs(panel.columns) do
        panel:SetClickFunc(index, function()
            self:SortByColumn(index, column)
        end)

        column.arrowAngle = 0
        column.PaintOver = function(panel, w, h)
            if (not panel.active) then return end

            local text = panel:GetText()
            local xOffset = -ScreenScale(3)
            local size = math.min(h, onyx.ScaleTall(12))
            local xPosOverride

            if (text ~= '') then
                local textW = panel:GetContentSize()
                if (panel.TextLeft) then
                    xPosOverride = textW + size * .5 - xOffset
                else
                    xOffset = xOffset - textW * .5
                end
            else
                xOffset = xOffset - size * .5
            end

            local targetAngle = panel.ascending and 90 or -90
            column.arrowAngle = Lerp(FrameTime() * 16, column.arrowAngle, targetAngle)

            DisableClipping(true)
                WIMG_ARROW:DrawRotated(xPosOverride or (w * .5 + xOffset - size * .5), h * .5, size, size, column.arrowAngle)
            DisableClipping(false)
        end
    end
end

function PANEL:SortByColumn(index, column)
    local oldColumn = self.currentColumn
    local data = column.data
    local resorted = {}

    if (IsValid(oldColumn)) then
        oldColumn:SetTextColor(COLOR_GRAY)
        oldColumn.hoverBlocked = false
        oldColumn.active = false
    end

    column.hoverBlocked = true
    column.ascending = not column.ascending
    column.active = true
    column:SetTextColor(COLOR_ACCENT)

    self.currentColumn = column

    -- sort
    table.sort(self.players, function(aPlayer, bPlayer)
        local aColumn = aPlayer.content.columns[index]
        local bColumn = bPlayer.content.columns[index]

        local aValue = aColumn.Value
        local bValue = bColumn.Value

        if (column.ascending) then
            return aValue > bValue
        else
            return aValue < bValue
        end
    end)

    -- rearrange elements
    for index, playerLine in ipairs(self.players) do
        local parent = playerLine.category
        local parentCategory = parent:GetParent():GetParent()

        parent:SetZPos(index)

        if (not resorted[parentCategory]) then
            parentCategory:SetZPos(index)
            parentCategory:SetAlpha(0)
            parentCategory:AlphaTo(255, .1)

            resorted[parentCategory] = index
        end
    end

    self.list:InvalidateLayout()
end

function PANEL:AddPlayer(ply, parentCategory)
    if (not IsValid(ply)) then return end

    -- create fake category
    local cat = parentCategory:Add('onyx.Category')
    cat:SetCategoryHeight(self.playerLineHeight)
    cat:SetTall(cat:GetCategoryHeight())
    cat:SetInset(onyx.ScaleTall(10))
    cat:SetSpace(0)
    cat:DockMargin(0, 0, 0, onyx.ScaleTall(2.5))
    cat:Dock(TOP)

    -- keep size up to date
    cat:InjectEventHandler('PerformLayout')
    cat:On('PerformLayout', function(panel)
        if (panel.onyxAnims and panel.onyxAnims[1]) then -- fixes unpleasant view glitch
            parentCategory:Update()
        end
    end)

    -- reset inside
    cat.button:Clear()
    cat.button.Paint = nil
    cat.button:DockPadding(0, 0, 0, 0)

    cat.canvas:SetTall(0)
    cat.canvas.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, onyx.LerpColor(.025, COLOR_PRIMARY, color_black), false, false, true, true)
    end

    local profile = cat:Add('onyx.scoreboard.PlayerInspector')
    profile:Dock(TOP)
    profile:SetupPlayer(ply)

    -- create actual playerLine
    local playerLine = cat.button:Add('onyx.Scoreboard.PlayerLine')
    playerLine:SetupPlayer(ply)
    playerLine:Dock(FILL)
    playerLine:Import('click')
    playerLine.DoClick = function()
        cat.button:DoClick()
    end

    -- to perfectly align UI elements
    playerLine.firstElementWidth = self.search:GetWide()
    playerLine.paddingX = self.toolbarPadding
    playerLine.padding = self.playerLinePadding

    -- link to other panels
    playerLine.category = cat
    playerLine.list = self.list

    -- for search
    playerLine.parsedName = parseString(ply:Name())
    playerLine.steamID32 = parseString(ply:SteamID())
    playerLine.isLocalPlayer = LocalPlayer() == ply

    table.insert(self.players, playerLine)
end

function PANEL:AddCategory(name, color)
    local cat = self.list:Add('onyx.Category')
    cat:Dock(TOP)
    cat:SetTitle(name)
    cat:SetSpace(onyx.ScaleTall(5))
    cat:SetInset(0)
    cat:SetTextMargin(self.toolbarPadding + 2)
    cat:DockMargin(0, 0, 0, onyx.ScaleTall(5))

    cat:SetExpanded(true)
    cat:UpdateInTick()

    if (color) then
        cat.button.PaintOver = function(panel, w, h)
            local x, y = panel:LocalToScreen(0, 0)
            local lineWidth = 2

            render.SetScissorRect(x, y, x + lineWidth, y + h, true)
            -- render.SetScissorRect(x, y + h - lineWidth, x + w, y + h, true)
                draw.RoundedBox(8, 0, 0, w, h, color)
            render.SetScissorRect(0, 0, 0, 0, false)
        end
    end

    return cat
end

onyx.gui.Register('onyx.Scoreboard.PlayerList', PANEL)

--[[------------------------------
--//ANCHOR onyx.scoreboard.PlayerInspector
--------------------------------]]
local COLOR_GOLD = Color(255, 224, 101)
local COLOR_FRIEND = Color(134, 249, 124)
local wimgCopy = onyx.wimg.Simple('https://i.imgur.com/OolNq4H.png', 'smooth mips')

local function setTextColor(label, color)
    label.colorIdle = color
    label:SetTextColor(color)
end

local PANEL = {}

AccessorFunc(PANEL, 'm_ePlayer', 'Player')

function PANEL:Init()
    self.buttonHeight = onyx.ScaleTall(20)

    local avatarOutline = 2
    local avatarRoundness = 16

    self._avatar = self:Add('Panel')
    self._avatar.PerformLayout = function(panel, w, h)
        local size = math.min(h, self._avatar:GetWide()) - avatarOutline * 2

        self.avatar:SetSize(size, size)
        self.avatar:Center()

        local x, y = self.avatar:GetPos()

        panel.poly = onyx.CalculateRoundedBox(avatarRoundness, x, y, size, size)
    end
    self._avatar.Paint = function(panel, w, h)
        local x, y = self.avatar:GetPos()
        local size = self.avatar:GetWide() + avatarOutline * 2

        draw.RoundedBox(avatarRoundness, x - avatarOutline, y - avatarOutline, size, size, color_white)

        onyx.DrawWithPolyMask(panel.poly, function()
            self.avatar:PaintManual()
        end)
    end

    self.avatar = self._avatar:Add('AvatarImage')
    self.avatar:SetPaintedManually(true)

    self.buttons = self:Add('onyx.Grid')
    self.buttons:SetColumnCount(3)
    self.buttons:SetSpace(onyx.ScaleTall(5))

    self.info = self:Add('Panel')

    for _, buttonTable in ipairs(onyx.scoreboard.Buttons) do
        local getVisible = buttonTable.getVisible

        if (getVisible and getVisible(LocalPlayer()) == false) then continue end

        self:AddButton(onyx.lang:Get('scoreboard_btn_' .. buttonTable.name), function()
            local ply = self:GetPlayer()
            if (IsValid(ply)) then
                buttonTable.callback(ply)
            end
        end)
    end

    self.labels = {}
    self:AddLabel('name', 'Name')
    self:AddLabel('rank', 'Rank')
    self:AddLabel('steamid32', 'SteamID32')
    self:AddLabel('steamid64', 'SteamID64')

    self:UpdateHeight()
end

function PANEL:UpdateHeight()
    local infoHeight = 0

    -- this one should be pairs
    for _, label in pairs(self.labels) do
        infoHeight = infoHeight + label:GetParent():GetTall()
    end

    self:SetTall(math.max(self.buttons:GetContentHeight(), infoHeight))
end

function PANEL:PerformLayout(w, h)
    self._avatar:Dock(LEFT)
    self._avatar:SetWide(h * .75)
    self._avatar:DockMargin(0, 0, onyx.ScaleTall(10), 0)

    self.buttons:SetWide(w * .5)
    self.buttons:Dock(RIGHT)

    self.info:Dock(FILL)
end

function PANEL:SetupPlayer(ply)
    local yourself = ply == LocalPlayer()
    local name = ply:Name()
    local formattedName = name

    self.avatar:SetPlayer(ply, 128)

    if (yourself) then
        formattedName = formattedName .. ' (' .. onyx.lang:Get('you') .. ')'
        setTextColor(self.labels.name, COLOR_GOLD)
    elseif (ply:GetFriendStatus() == 'friend') then
        formattedName = formattedName .. ' (' .. onyx.lang:Get('friend') .. ')'
        setTextColor(self.labels.name, COLOR_FRIEND)
    end

    self:SetPlayer(ply)

    self:SetLabelValue('name', formattedName, name)
    self:SetLabelValue('rank', ply:GetUserGroup())
    self:SetLabelValue('steamid32', ply:SteamID())
    self:SetLabelValue('steamid64', ply:SteamID64())
end

function PANEL:SetLabelValue(id, value, rawValue)
    self.labels[id]:SetText(value)
    self.labels[id]:SizeToContentsX()
    self.labels[id].Value = rawValue or value
end

function PANEL:AddLabel(id, title)
    local row = self.info:Add('Panel')
    row:SetTall(onyx.ScaleTall(20))
    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 0)

    local lblTitle = row:Add('onyx.Label')
    lblTitle:SetText(title .. ': ')
    lblTitle:SetTextColor(COLOR_GRAY_LIGHT)
    lblTitle:Dock(LEFT)
    lblTitle:SizeToContentsX()
    lblTitle:SetContentAlignment(7)

    local lblValue = row:Add('onyx.Label')
    lblValue:SetText('Example')
    lblValue:SetContentAlignment(7)
    lblValue:Dock(LEFT)
    lblValue:Font('Comfortaa Bold@16')
    lblValue:SizeToContentsX()
    lblValue:Import('click')
    lblValue.Value = 'Example'
    setTextColor(lblValue, color_white)
    lblValue.Think = function(panel)
        panel:SetTextColor(panel:IsHovered() and COLOR_ACCENT or panel.colorIdle)
    end
    lblValue.Paint =function(panel, w, h)
        if (not panel:IsHovered()) then return end

        local size = h * .66
        local space = onyx.ScaleTall(5)
        DisableClipping(true)
            wimgCopy:Draw(w + space, h * .5 - size * .5, size, size, COLOR_ACCENT)
        DisableClipping(false)
    end
    lblValue.DoClick = function(panel)
        SetClipboardText(panel.Value)
        notification.AddLegacy(onyx.lang:Get('copied_clipboard'), 0, 5)
    end

    self.labels[id] = lblValue
end

function PANEL:AddButton(text, func)
    local button = self.buttons:Add('onyx.Button')
    button:SetText(text)
    button:SetTall(onyx.ScaleTall(25))
    button:SetColorIdle(COLOR_SECONDARY)
    button:SetColorHover(COLOR_TERTIARY)
    button:AddHoverSound()
    button:AddClickEffect()
    button:Font('Comfortaa SemiBold@16')
    button.Think = function(panel)
        panel:SetTextColor(panel:IsHovered() and color_white or COLOR_GRAY_LIGHT)
    end
    button.DoClick = func

    self.buttons:AddItem(button)
end

onyx.gui.Register('onyx.scoreboard.PlayerInspector', PANEL)

--[[------------------------------
// ANCHOR Debug
--------------------------------]]
-- onyx.gui.Test('onyx.Scoreboard.Frame', .6, .6, function(self)
--     onyx.scoreboard.Frame = self
--     self:Center()
--     self:MakePopup()
-- end)
--lua/openpermissions/lang/english.lua:
return gluapack()()
--lua/openpermissions/sh.lua:
return gluapack()()
--lua/openpermissions/cl.lua:
local L = OpenPermissions.L
local Lf = OpenPermissions.Lf

local function DMenuOption_ColorIcon(option, color)
	option:SetIcon("icon16/box.png")
	function option.m_Image:Paint(w,h)
		surface.SetDrawColor(color)
		surface.DrawRect(0,0,w,h)
	end
end
local function GreenToRed_DMenu(i, max, option)
	DMenuOption_ColorIcon(option, Color(i / max * 255, 1 - (i / max) * 255, 0))
end

surface.CreateFont("OpenPermissions_14px", {
	font = "Roboto",
	size = 14,
})
surface.CreateFont("OpenPermissions_Tip", {
	font = "Roboto",
	size = 22,
})

function OpenPermissions:AddTooltip(pnl, options)
	pnl.OpenPermissions_Tooltip_OnCursorEntered = pnl.OnCursorEntered
	pnl.OpenPermissions_Tooltip_OnCursorExited = pnl.OnCursorExited

	function pnl:OnCursorEntered(...)
		pnl.OpenPermissions_Tooltip = vgui.Create("OpenPermissions.Tooltip")
		pnl.OpenPermissions_Tooltip:SetText(options.Text)
		pnl.OpenPermissions_Tooltip.VGUI_Element = pnl

		if (self.OpenPermissions_Tooltip_OnCursorEntered) then
			return self.OpenPermissions_Tooltip_OnCursorEntered(self, ...)
		end
	end

	function pnl:OnCursorExited(...)
		if (IsValid(self.OpenPermissions_Tooltip)) then
			self.OpenPermissions_Tooltip:Remove()
		end
		self.OpenPermissions_Tooltip = nil
		if (self.OpenPermissions_Tooltip_OnCursorExited) then
			return self.OpenPermissions_Tooltip_OnCursorExited(self, ...)
		end
	end
end
function OpenPermissions:RemoveTooltip(pnl)
	if (IsValid(pnl.OpenPermissions_Tooltip)) then
		pnl.OpenPermissions_Tooltip:Remove()
	end
	pnl.OpenPermissions_Tooltip = nil
	pnl.OnCursorEntered = pnl.OpenPermissions_Tooltip_OnCursorEntered
	pnl.OnCursorExited = pnl.OpenPermissions_Tooltip_OnCursorExited
end

local blur = Material("pp/blurscreen")
function OpenPermissions:OpenMenu(specific_addon)
	if (IsValid(OpenPermissions_Menu)) then
		OpenPermissions_Menu:Close()
	end

	OpenPermissions_Menu = vgui.Create("DFrame")

	local AccessGroups
	local PermissionsSave

	local Menu = OpenPermissions_Menu
	Menu:SetSize(850,500)
	Menu:SetTitle("OpenPermissions")
	Menu:SetIcon("icon16/shield.png")
	Menu:Center()
	Menu:MakePopup()

	local Tabs = vgui.Create("DPropertySheet", Menu)
	Tabs:Dock(FILL)

	local PermissionsTab = vgui.Create("DPanel", Tabs)
	PermissionsTab.Paint = nil

		local AccessGroupsDivider = vgui.Create("OpenPermissions.HorizontalDivider", PermissionsTab)
		AccessGroupsDivider:Dock(FILL)
		AccessGroupsDivider:SetDividerWidth(5)
		AccessGroupsDivider:SetLeftWidth(200)
		AccessGroupsDivider:SetRightMin(465)
		AccessGroupsDivider:SetLeftMin(150)

		local AddonsContainer = vgui.Create("OpenPermissions.ColumnLayout", AccessGroupsDivider)
		AccessGroupsDivider:SetRight(AddonsContainer)
		AddonsContainer:SetColumns(OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW)
		AddonsContainer:SetPaddings(5,5)

		local AddonContentContainer = vgui.Create("DPanel", PermissionsTab)
		AddonContentContainer.Paint = nil
		AddonContentContainer:SetVisible(false)
		AddonContentContainer:Dock(FILL)
		AddonContentContainer:DockMargin(5,0,0,0)

			local AddonContent = vgui.Create("DPropertySheet", AddonContentContainer)
			AddonContent:Dock(FILL)
			function AddonContent:PaintOver(w,h)
				if (not self.ShowOverlay) then return end
				local x,y = self:LocalToScreen(0,0)
				local scrW,scrH = ScrW(), ScrH()
				surface.SetDrawColor(255,255,255)
				surface.SetMaterial(blur)
				for i=1,2 do
					blur:SetFloat("$blur", (i / 2) * 2)
					blur:Recompute()
					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
				end

				surface.SetDrawColor(0,0,0,240)
				surface.DrawRect(0,0,w,h)

				draw.SimpleTextOutlined(L"select_an_access_group", "OpenPermissions_Tip", w / 2, h / 2, OpenPermissions.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, OpenPermissions.COLOR_BLACK)
			end

			local PermissionsContent = vgui.Create("OpenPermissions.HorizontalDivider", AddonContent)
			PermissionsContent:SetDividerWidth(5)
			PermissionsContent:SetRightMin(150)
			PermissionsContent:SetLeftMin(150)
			PermissionsContent.Paint = nil

				local PermissionsTree = vgui.Create("OpenPermissions.Tree", PermissionsContent)

				local PropertiesContent = vgui.Create("OpenPermissions.ScrollPanel", PermissionsContent)
				PropertiesContent:DockMargin(5,0,0,0)
				PropertiesContent:SetWide(150)
				PropertiesContent:SetDrawBackground(true)
				function PropertiesContent:AddProperty(options, indent_level, no_checkbox)
					local permission_row = vgui.Create("DPanel", PropertiesContent)
					permission_row.Paint = nil
					permission_row:Dock(TOP)
					permission_row:SetTall(16)
					permission_row:DockMargin(5 + ((indent_level or 0) * (16 + 5)),5,5,0)

					OpenPermissions:AddTooltip(permission_row, {Text = options.Tip or options.Label})

					local checkbox
					if (not no_checkbox) then
						permission_row:SetMouseInputEnabled(true)
						permission_row:SetCursor("hand")

						checkbox = vgui.Create("OpenPermissions.Checkbox", permission_row)
						checkbox:SetCrossable(true)
						checkbox:Dock(LEFT)
						checkbox:DockMargin(0,0,5,0)

						function permission_row:OnMouseReleased(m)
							if (m == MOUSE_LEFT) then
								checkbox:DoClick()
							elseif (m == MOUSE_RIGHT) then
								checkbox:DoRightClick()
							end
						end
					end

					if (options.Icon) then
						local icon = vgui.Create("DImage", permission_row)
						icon:Dock(LEFT)
						icon:SetSize(16,16)
						icon:DockMargin(0,0,5,0)
						icon:SetImage(options.Icon)
						icon:SetMouseInputEnabled(false)
					elseif (options.Color) then
						local col_icon = vgui.Create("DPanel", permission_row)
						col_icon:Dock(LEFT)
						col_icon:SetSize(16,16)
						col_icon:DockMargin(0,0,5,0)
						col_icon:SetMouseInputEnabled(false)
						function col_icon:Paint(w,h)
							surface.SetDrawColor(options.Color)
							surface.DrawRect(0,0,w,h)
						end
					end

					local label = vgui.Create("DLabel", permission_row)
					label:Dock(FILL)
					label:SetTextColor(OpenPermissions.COLOR_BLACK)
					label:SetText(options.Label)
					label:SetContentAlignment(4)
					label:SetMouseInputEnabled(false)

					return checkbox
				end

				PermissionsContent:SetLeft(PermissionsTree)
				PermissionsContent:SetRight(PropertiesContent)
				PermissionsContent:BalanceWidths()

			AddonContent:AddSheet(L"permissions", PermissionsContent, "icon16/group.png")

			local OperationsContainer = vgui.Create("OpenPermissions.ScrollPanel", AddonContent)
			AddonContent:AddSheet(L"operations", OperationsContainer, "icon16/wrench_orange.png")

			function AddonContent:SetShowOverlay(show)
				self.ShowOverlay = show
				self:SetMouseInputEnabled(not show)
				for _,v in ipairs(self:GetItems()) do
					v.Panel:SetMouseInputEnabled(not show)
				end
			end
			AddonContent:SetShowOverlay(true)

				local DeleteAccessGroup = vgui.Create("DButton", OperationsContainer)
				DeleteAccessGroup:SetSize(250,30)
				DeleteAccessGroup:SetText(L"delete_access_group")
				DeleteAccessGroup:SetIcon("icon16/delete.png")

				local CopyPasteContainer = vgui.Create("DPanel", OperationsContainer)
				CopyPasteContainer.Paint = nil
				CopyPasteContainer:SetSize(250,30)
				CopyPasteContainer:AlignTop(DeleteAccessGroup:GetTall() + 5)

					local CopyPermissions = vgui.Create("DButton", CopyPasteContainer)
					CopyPermissions:SetText(L"copy")
					CopyPermissions:SetIcon("icon16/page_copy.png")
					CopyPermissions:DockMargin(0,0,5,0)

					local PastePermissions = vgui.Create("DButton", CopyPasteContainer)
					PastePermissions:SetText(L"paste")
					PastePermissions:SetIcon("icon16/page_paste.png")
					PastePermissions:DockMargin(0,0,5,0)
					PastePermissions:SetDisabled(true)

					function CopyPermissions:DoClick()
						PastePermissions:SetDisabled(false)
						PastePermissions.PermissionsData = {}
						local copied_clashes = false
						for _,line in ipairs(AccessGroups:GetSelected()) do
							local identifier = line.Data.Enum .. " " .. line.Data.Value
							if (not OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line.Data.Value]) then continue end
							for access_group, perms in pairs(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum]) do
								for permission_id, checked in pairs(perms) do
									if (PastePermissions.PermissionsData[permission_id] == nil) then
										local has_clashed = false
										for _,line_2 in ipairs(AccessGroups:GetSelected()) do
											local identifier_2 = line_2.Data.Enum .. " " .. line_2.Data.Value
											if (not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Value]) then continue end
											if (identifier_2 == identifier) then continue end
											if (OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum][line_2.Data.Value][permission_id] ~= checked) then
												copied_clashes, has_clashed = true, true
												break
											end
										end
										if (not has_clashed) then
											PastePermissions.PermissionsData[permission_id] = checked
										else
											PastePermissions.PermissionsData[permission_id] = nil
										end
									elseif (PastePermissions.PermissionsData[permission_id] ~= checked) then
										copied_clashes = true
										PastePermissions.PermissionsData[permission_id] = nil
									end
								end
							end
						end
						if (copied_clashes) then
							Derma_Message(L"permission_clash_msg", "OpenPermissions", L"ok")
						end
					end
					function PastePermissions:DoClick()
						for _,line in ipairs(AccessGroups:GetSelected()) do
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							table.Merge(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value], PastePermissions.PermissionsData)
						end
					end

					function CopyPasteContainer:PerformLayout(w,h)
						CopyPermissions:SetSize((w - 2.5) / 2,h)
						CopyPermissions:AlignLeft(0)
						PastePermissions:SetSize((w - 2.5) / 2,h)
						PastePermissions:AlignRight(0)
					end

			local AddonNav = vgui.Create("DPanel", AddonContentContainer)
			AddonNav.Paint = nil
			AddonNav:Dock(BOTTOM)
			AddonNav:DockMargin(0,5,0,0)
			AddonNav:SetTall(30)

				PermissionsSave = vgui.Create("DButton", AddonNav)
				PermissionsSave:Dock(LEFT)
				PermissionsSave:SetWide(100)
				PermissionsSave:DockMargin(0,0,5,0)
				PermissionsSave:SetText(L"save")
				PermissionsSave:SetIcon("icon16/disk.png")
				PermissionsSave:SetDisabled(true)

				function PermissionsSave:RememberPermission(permission_id, checked)
					local is_disabled = true
					for _,line in ipairs(AccessGroups:GetSelected()) do
						if (checked == OpenPermissions.CHECKBOX.INHERIT or checked == false) then
							if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
								OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = nil
								if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value])) then
									OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
									if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum])) then
										OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = nil
									end
								end
							end
						else
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = checked
						end
						if (is_disabled) then
							if ((OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) ~= (OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil)) then
								is_disabled = false
							else
								if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value][permission_id]) then
									is_disabled = false
								elseif (not OpenPermissions:table_IsIdentical(OpenPermissions.PermissionsRegistryEditing, OpenPermissions.PermissionsRegistry)) then
									is_disabled = false
								end
							end
						end
					end
					self:SetDisabled(is_disabled)
				end
				function PermissionsSave:CheckedFromMemory(permission_id, checkbox)
					local checked
					for _,line in ipairs(AccessGroups:GetSelected()) do
						local should_be_checked = OpenPermissions.CHECKBOX.INHERIT
						if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= nil) then
							should_be_checked = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id]
						elseif (OpenPermissions.DefaultPermissions[permission_id] ~= nil) then
							should_be_checked = OpenPermissions.DefaultPermissions[permission_id]
						end
						if (checked == nil) then
							checked = should_be_checked
						else
							if (should_be_checked ~= checked) then
								checkbox:SetAmbigious(true)
								return
							end
						end
					end
					checkbox:SetChecked(checked)
					checkbox:SetAmbigious(false)
				end
				function PermissionsSave:DoClick()
					OpenPermissions.PermissionsRegistry = table.Copy(OpenPermissions.PermissionsRegistryEditing)
					self:SetDisabled(true)
					surface.PlaySound("garrysmod/content_downloaded.wav")
					
					OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)
					net.Start("OpenPermissions.SavePermissions")
						OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry)
					net.SendToServer()
					file.Delete("openpermissions_v2.dat")
				end

				local AddonBack = vgui.Create("DButton", AddonNav)
				AddonBack:Dock(LEFT)
				AddonBack:SetWide(100)
				AddonBack:DockMargin(0,0,5,0)
				AddonBack:SetText(L"back_btn")
				function AddonBack:DoClick()
					AddonsContainer:SetVisible(true)
					AddonContentContainer:SetVisible(false)

					AccessGroupsDivider:SetRight(AddonsContainer)
				end

				local AddonSelect = vgui.Create("OpenPermissions.ComboBox", AddonNav)
				AddonSelect:Dock(FILL)
				AddonSelect.AddonBtns = {}

				AddonSelect:SetSortItems(false)
				AddonSelect:AddChoice(L"all_addons", true, false, "icon16/layers.png")
				AddonSelect:AddSpacer()

				function AddonSelect:OnSelect(i, v, d)
					PropertiesContent:Clear()
					if (d == true) then
						function AccessGroups:OnRowSelected(i, row)
							AddonContent:SetShowOverlay(false)
							PermissionsTree:Clear()
							PropertiesContent:Clear()
							for id, data in pairs(OpenPermissions.Addons) do
								PermissionsTab:LoadPermissions(id, data, true)
							end
						end
						if (AccessGroups:GetSelectedLine() ~= nil) then
							AccessGroups:OnRowSelected()
						end
					else
						self.AddonBtns[d]:DoClick()
					end
				end

		local NavContent = vgui.Create("DPanel", PermissionsTab)
		AccessGroupsDivider:SetLeft(NavContent)
		NavContent.Paint = nil
		NavContent:Dock(LEFT)
		NavContent:SetWide(200)

			AccessGroups = vgui.Create("OpenPermissions.ListView", NavContent)
			AccessGroups:AddColumn(L"type"):SetFixedWidth(65)
			AccessGroups:AddColumn(L"access_group")
			AccessGroups:Dock(FILL)
			AccessGroups.Data = {}

			local KeyCategory = vgui.Create("DCollapsibleCategory", NavContent)
			KeyCategory:Dock(TOP)
			KeyCategory:SetTall(130)
			KeyCategory:DockMargin(0,0,0,5)
			KeyCategory:SetLabel(L"key")
			KeyCategory:SetExpanded(false)

				local KeyInfo = vgui.Create("OpenPermissions.ScrollPanel", NavContent)
				KeyInfo:SetDrawBackground(true)

				for name, enum in pairs(OpenPermissions.ACCESS_GROUP) do
					local Key = vgui.Create("DPanel", KeyInfo)
					Key:Dock(TOP)
					Key:DockMargin(5,5,5,0)

					local KeyColor = OpenPermissions.ACCESS_GROUP_KEY[enum]
					local KeyName = L("ACCESS_GROUP_" .. name)
					local KeyPoly = {
						{x = 9, y = 0},
						{x = 18, y = 9},
						{x = 9, y = 18},
						{x = 0, y = 9},
					}
					function Key:Paint(w,h)
						surface.SetDrawColor(KeyColor)
						draw.NoTexture()
						surface.DrawPoly(KeyPoly)

						draw.SimpleText(KeyName, "DermaDefault", 18 + 5, 8, OpenPermissions.COLOR_BLACK, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
					end
				end

				KeyCategory:SetContents(KeyInfo)
			
			local MultipleTip = vgui.Create("DLabel", NavContent)
			MultipleTip:Dock(TOP)
			MultipleTip:SetContentAlignment(5)
			MultipleTip:DockMargin(0,0,0,5)
			MultipleTip:SetText(L"hold_ctrl_to_select_multiple")
			MultipleTip:SetTextColor(OpenPermissions.COLOR_BLACK)

			local AddAccessGroup = vgui.Create("DButton", NavContent)
			AddAccessGroup:SetText(L"add_access_group")
			AddAccessGroup:SetIcon("icon16/add.png")
			AddAccessGroup:Dock(BOTTOM)
			AddAccessGroup:DockMargin(0,5,0,0)
			AddAccessGroup:SetTall(30)

			function AddAccessGroup:Add(enum, text, value)
				local val = value or text
				if (AccessGroups.Data[enum] and AccessGroups.Data[enum][val]) then
					Derma_Message(L"access_group_exists", L"error", L"ok")
				else
					local type
					for name, _enum in pairs(OpenPermissions.ACCESS_GROUP) do
						if (_enum == enum) then
							type = name
							break
						end
					end
					local line = AccessGroups:AddLine(L("ACCESS_GROUP_" .. type), text)
					line.Data = {
						Enum = enum,
						Value = val
					}
					function line:Paint(w,h)
						derma.SkinHook("Paint", "ListViewLine", self, w, h)

						surface.SetDrawColor(OpenPermissions.ACCESS_GROUP_KEY[enum])
						surface.DrawRect(0,0,w,h)
					end
					AccessGroups.Data[enum] = AccessGroups.Data[enum] or {}
					AccessGroups.Data[enum][val] = true
				end
			end
			for enum, accessors in pairs(OpenPermissions.PermissionsRegistry) do
				for val, vals in pairs(accessors) do
					enum = tonumber(enum)
					if (enum == OpenPermissions.ACCESS_GROUP.STEAMID) then
						AddAccessGroup:Add(enum, OpenPermissions:AccountIDToSteamID(tonumber(val)), tonumber(val))
					elseif (enum == OpenPermissions.ACCESS_GROUP.TEAM) then
						local team_index = OpenPermissions:GetTeamFromIdentifier(val)
						if (team_index) then
							AddAccessGroup:Add(enum, team.GetName(team_index), val)
						end
					elseif (enum == OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY) then
						if (OpenPermissions.IsDarkRP) then
							local category_index = OpenPermissions:DarkRP_GetCategoryFromIdentifier(val)
							if (category_index) then
								AddAccessGroup:Add(enum, DarkRP.getCategories().jobs[category_index].name, val)
							end
						end
					else
						AddAccessGroup:Add(enum, val)
					end
				end
			end

			function AddAccessGroup:DoClick()
				local menu = DermaMenu()
				
				local ACCESS_GROUP_USERGROUP, _ = menu:AddSubMenu(L"ACCESS_GROUP_USERGROUP") _:SetIcon("icon16/group.png")

					ACCESS_GROUP_USERGROUP:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", L"enter_usergroup", LocalPlayer():GetUserGroup(), function(usergroup)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end)
					end):SetIcon("icon16/pencil.png")

					local usergroups = {superadmin = true, admin = true, user = true}
					for _,ply in ipairs(player.GetHumans()) do
						for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
							usergroups[usergroup] = true
						end
					end
					usergroups = table.GetKeys(usergroups)
					table.sort(usergroups)
					for i,usergroup in ipairs(usergroups) do
						GreenToRed_DMenu(i, #usergroups, ACCESS_GROUP_USERGROUP:AddOption(usergroup, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end))
					end

				local ACCESS_GROUP_STEAMID, _ = menu:AddSubMenu(L"ACCESS_GROUP_STEAMID") _:SetIcon("icon16/user_gray.png")

					ACCESS_GROUP_STEAMID:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", Lf("enter_steamid", LocalPlayer():SteamID(), LocalPlayer():SteamID64()), LocalPlayer():SteamID(), function(_input)
							local steamid64
							if (_input:find("^STEAM_%d:%d:%d+$")) then
								steamid64 = util.SteamIDTo64(_input)
							elseif (_input:find("^7656119%d+$")) then
								steamid64 = _input
							else
								Derma_Message(L"invalid_steamid", L"error", L"ok")
								return
							end
							local steamid = util.SteamIDFrom64(steamid64)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, steamid, OpenPermissions:SteamIDToAccountID(steamid))
						end)
					end):SetIcon("icon16/pencil.png")

					local steamids = {}
					for _,ply in ipairs(player.GetHumans()) do
						table.insert(steamids, {Distance = ply:GetPos():DistToSqr(LocalPlayer():GetPos()), Name = ply:Nick(), SteamID = ply:SteamID(), AccountID = ply:AccountID(), Color = team.GetColor(ply:Team())})
					end
					table.SortByMember(steamids, "Distance", true)
					for i,item in ipairs(steamids) do
						DMenuOption_ColorIcon(ACCESS_GROUP_STEAMID:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, item.SteamID, item.AccountID)
						end), item.Color)
					end

				local ACCESS_GROUP_TEAM, _ = menu:AddSubMenu(L"ACCESS_GROUP_TEAM") _:SetIcon("icon16/flag_green.png")

					if (OpenPermissions.IsDarkRP) then
						local categories = {}
						for i,c in ipairs(DarkRP.getCategories().jobs) do
							if (GAS:table_IsEmpty(c.members)) then continue end
							table.insert(categories, {name = c.name, color = c.color, members = c.members})
						end
						table.SortByMember(categories, "name", true)
						for i,c in ipairs(categories) do
							local submenu, _submenu = ACCESS_GROUP_TEAM:AddSubMenu(c.name)
							DMenuOption_ColorIcon(_submenu, c.color)

							local members = {}
							for _,member in ipairs(c.members) do
								table.insert(members, {name = member.name, color = member.color, index = member.team})
							end
							table.SortByMember(members, "name", true)
							for _,member in ipairs(members) do
								DMenuOption_ColorIcon(submenu:AddOption(member.name, function()
									AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, member.name, OpenPermissions:GetTeamIdentifier(member.index))
								end), member.color)
							end
						end
					else
						local teams = {}
						for i,t in ipairs(team.GetAllTeams()) do
							table.insert(teams, {Name = t.Name, Index = i, Color = t.Color})
						end
						table.SortByMember(teams, "Name", true)
						for i,item in ipairs(teams) do
							DMenuOption_ColorIcon(ACCESS_GROUP_TEAM:AddOption(item.Name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, item.Name, OpenPermissions:GetTeamIdentifier(i))
							end), item.Color)
						end
					end

				local ACCESS_GROUP_LUA_FUNCTION, _ = menu:AddSubMenu(L"ACCESS_GROUP_LUA_FUNCTION") _:SetIcon("icon16/script.png")
					local lua_functions = table.GetKeys(OpenPermissions.LuaFunctions)
					if (#lua_functions == 0) then
						ACCESS_GROUP_LUA_FUNCTION:AddOption(L"none_info")
					else
						table.sort(lua_functions)
						for i,lua_func_name in ipairs(lua_functions) do
							GreenToRed_DMenu(i, #lua_functions, ACCESS_GROUP_LUA_FUNCTION:AddOption(lua_func_name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.LUA_FUNCTION, lua_func_name)
							end))
						end
					end

				if (OpenPermissions.IsDarkRP) then
					local ACCESS_GROUP_DARKRP_CATEGORY, _ = menu:AddSubMenu(L"ACCESS_GROUP_DARKRP_CATEGORY") _:SetIcon("icon16/wrench_orange.png")
					local darkrp_categories = {}
					for i,category in ipairs(DarkRP.getCategories().jobs) do
						table.insert(darkrp_categories, {Name = category.name, Color = category.color, Category = category})
					end
					table.SortByMember(darkrp_categories, "Name", true)
					for i,item in ipairs(darkrp_categories) do
						DMenuOption_ColorIcon(ACCESS_GROUP_DARKRP_CATEGORY:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY, item.Name, OpenPermissions:DarkRP_GetCategoryIdentifier(i))
						end), item.Color)
					end
				end

				hook.Run("OpenPermissions:AddAccessGroup", menu)

				menu:Open()
			end

		local function permissions_node_clicked(self, addon_id, v)
			PropertiesContent:Clear()

			local indent_level = 0
			local function _r(tbl, permission_id, my_parent, i)
				i = (i or 0) + 1
				local final_checkbox
				for i,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_checkbox = PropertiesContent:AddProperty(v[2], indent_level)
					final_checkbox = new_checkbox
					v[3] = new_checkbox
					v[4] = my_parent

					function new_checkbox:CheckAmbigious()
						if (my_parent) then
							local all_state
							local ambigious = false
							for _,_v in ipairs(my_parent[1]) do
								if (not IsValid(_v[3])) then continue end
								if (_v[3]:IsAmbigious()) then
									ambigious = true
									break
								elseif (all_state == nil) then
									all_state = _v[3]:GetChecked()
								elseif (all_state ~= _v[3]:GetChecked()) then
									ambigious = true
									break
								end
							end
							my_parent[3]:SetAmbigious(ambigious)
							if (not ambigious) then
								my_parent[3]:SetChecked(all_state)
							end
							my_parent[3]:CheckAmbigious()
						end
					end
					function new_checkbox:OnChange()
						self:CheckAmbigious()
						if (#v[1] > 0) then
							local function __r(tbl)
								for _,_v in ipairs(tbl) do
									_v[3]:SetChecked(self:GetChecked())
									_v[3]:OnChange()
									__r(_v[1])
								end
							end
							__r(v[1])
						else
							PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
						end
					end

					PermissionsSave:CheckedFromMemory(my_permission_id, new_checkbox)

					if (#v[1] > 0) then
						indent_level = indent_level + 1
						_r(v[1], my_permission_id, v, i)
					end
				end
				if (final_checkbox) then
					final_checkbox:CheckAmbigious()
				end
				indent_level = indent_level - 1
			end
			_r(v[1], addon_id)
		end
		function PermissionsTab:LoadPermissions(addon_id, addon_data, shouldnt_clear)
			PermissionsTab.AddonID, PermissionsTab.AddonData = addon_id, addon_data

			if (not shouldnt_clear) then
				PermissionsTree:Clear()
				PropertiesContent:Clear()
			end

			local tree = addon_data[1]
			local addon_options = addon_data[2]

			local root_node = PermissionsTree:AddNode(addon_options.Name or addon_id, addon_options.Icon)
			if (not shouldnt_clear) then root_node:SetExpanded(true) end
			function root_node:DoClick()
				-- show all permissions
				permissions_node_clicked(self, addon_id, addon_data)
			end

			local is_root = true
			local function r(tbl, node, permission_id, prev_options)
				local lowest_level = true
				for _,v in ipairs(tbl) do
					if (#v[1] > 0) then
						lowest_level = false
						break
					end
				end
				if (not is_root and lowest_level) then
					-- if we can't go any deeper then show property checkboxes
					-- when the node is clicked
					function node:DoClick()
						PropertiesContent:Clear()

						if (#tbl > 1) then
							local checkboxes = {}
							local master_checkbox = PropertiesContent:AddProperty(prev_options)
							function master_checkbox:OnChange()
								self:SetAmbigious(false)
								for _,v in ipairs(checkboxes) do
									v:SetChecked(self:GetChecked())
									v:OnChange()
								end
							end

							for i,v in ipairs(tbl) do
								local my_permission_id = permission_id
								if (v[2].Value) then
									my_permission_id = my_permission_id .. "/" .. v[2].Value
								end
								local checkbox = PropertiesContent:AddProperty(v[2], 1)
								table.insert(checkboxes, checkbox)
								function checkbox:CheckAmbigious()
									local all_state
									local ambigious = false
									for _,v in ipairs(checkboxes) do
										if (v:IsAmbigious()) then
											ambigious = true
											break
										elseif (all_state == nil) then
											all_state = v:GetChecked()
										elseif (all_state ~= v:GetChecked()) then
											ambigious = true
											break
										end
									end
									master_checkbox:SetAmbigious(ambigious)
									if (not ambigious) then master_checkbox:SetChecked(all_state) end
								end
								function checkbox:OnChange()
									PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
									self:CheckAmbigious()
								end
								PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
							end
							checkboxes[1]:CheckAmbigious()
						else
							local my_permission_id = permission_id
							if (tbl[1][2].Value) then
								my_permission_id = my_permission_id .. "/" .. tbl[1][2].Value
							end
							local checkbox = PropertiesContent:AddProperty(tbl[1][2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					end
				else
					is_root = false
				end

				for _,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_node = node:AddNode(v[2].Label)
					if (v[2].Icon) then
						new_node:SetIcon(v[2].Icon)
					elseif (v[2].Color) then
						function new_node.Icon:PaintOver(w,h)
							surface.SetDrawColor(v[2].Color)
							surface.DrawRect(0,0,w,h)
						end
					end
					if (#v[1] == 0) then
						function new_node:DoClick()
							PropertiesContent:Clear()
							local checkbox = PropertiesContent:AddProperty(v[2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					else
						function new_node:DoClick()
							permissions_node_clicked(self, my_permission_id, v)
						end
						r(v[1], new_node, my_permission_id, v[2])
					end
				end
			end
			r(tree, root_node, addon_id)
		end

	local TesterTab = vgui.Create("DPanel", Tabs)
	TesterTab.Paint = nil

	local HelpTabContent = vgui.Create("DPanel", Tabs)
	HelpTabContent.Paint = nil

	Tabs:AddSheet(L"permissions", PermissionsTab, "icon16/group.png")
	Tabs:AddSheet(L"tester", TesterTab, "icon16/wrench_orange.png")
	local HelpTab = Tabs:AddSheet(L"help", HelpTabContent, "icon16/help.png")

	local HelpContent
	function Tabs:OnActiveTabChanged(old, new)
		if (new == HelpTab.Tab) then
			if (IsValid(HelpContent)) then
				HelpContent:SetVisible(true)
			else
				HelpContent = vgui.Create("DPanel", HelpTabContent)
				HelpContent.Paint = nil
				HelpContent:Dock(FILL)

				local HelpControls = vgui.Create("DHTMLControls", HelpContent)
				HelpControls:Dock(TOP)
				HelpControls.HomeURL = "https://gmodadminsuite.github.io/OpenPermissions"

				local HelpHTML = vgui.Create("DHTML", HelpContent)
				HelpHTML:Dock(FILL)
				HelpHTML:OpenURL(HelpControls.HomeURL)

				HelpControls:SetHTML(HelpHTML)
			end
		elseif (IsValid(HelpContent)) then
			HelpContent:SetVisible(false)
		end
	end

	--## Create Dynamic Content ##--

	function DeleteAccessGroup:DoClick()
		for i,line in pairs(AccessGroups:GetLines()) do
			if (not line:IsLineSelected()) then continue end
			if (AccessGroups.Data[line.Data.Enum][line.Data.Value] ~= nil) then
				AccessGroups.Data[line.Data.Enum][line.Data.Value] = nil
			end
			if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
				OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
			end
			AccessGroups:RemoveLine(i)
		end
		AddonContent:SetShowOverlay(true)
		AddonContent:SwitchToName(L"permissions")
		PermissionsTree:Clear()
		PropertiesContent:Clear()

		PermissionsSave:SetDisabled(false)
	end

	local sorted_addons = {}
	for id, data in pairs(OpenPermissions.Addons) do
		local options = data[2]
		table.insert(sorted_addons, {name = options.Name or id, id = id, data = data})
	end
	table.SortByMember(sorted_addons, "name", true)

	local AddonQueue = {}
	local ActiveAddon
	for _,addon_data in ipairs(sorted_addons) do
		local id, data = addon_data.id, addon_data.data
		local options = data[2]
		AddonSelect:AddChoice(options.Name or id, id, false, options.Icon)

		local Addon = vgui.Create("OpenPermissions.Addon", AddonsContainer)

		if (specific_addon == id) then
			ActiveAddon = Addon
		end

		AddonSelect.AddonBtns[id] = Addon

		Addon:SetSize(200,120)
		Addon:Setup(id, options)
		if (Addon.Addon.Logo) then
			OpenPermissions:AddTooltip(Addon, {
				Text = options.Name
			})
		end

		function Addon:DoClick()
			PropertiesContent:Clear()

			AddonSelect:SetValue(options.Name or id)

			AddonsContainer:SetVisible(false)
			AddonContentContainer:SetVisible(true)

			AccessGroupsDivider:SetRight(AddonContentContainer)

			CopyPermissions:SetDisabled(#AccessGroups:GetSelected() > 1)
			PastePermissions:SetDisabled(true)

			function AccessGroups:OnRowSelected(i, row)
				AddonContent:SetShowOverlay(false)
				PropertiesContent:Clear()
				PermissionsTab:LoadPermissions(id, data)
			end
			if (AccessGroups:GetSelectedLine() ~= nil) then
				AccessGroups:OnRowSelected()
			end
		end

		table.insert(AddonQueue, Addon)
		if (#AddonQueue == 3) then
			AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
			AddonQueue = {}
		end
	end
	if (#AddonQueue > 0) then
		AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
	end
	if (ActiveAddon) then
		ActiveAddon:DoClick()
	end
end

net.Receive("OpenPermissions.OpenMenu", function()
	OpenPermissions.Addons = OpenPermissions:ReceiveNetworkTable()
	OpenPermissions.PermissionsRegistryEditing = table.Copy(OpenPermissions.PermissionsRegistry)

	local specific_addon = net.ReadBool()
	if (specific_addon) then
		OpenPermissions:OpenMenu(net.ReadString())
	else
		OpenPermissions:OpenMenu()
	end
end)

concommand.Add("openpermissions", function(_, __, args)
	net.Start("OpenPermissions.OpenMenu")
		net.WriteString(table.concat(args, " "))
	net.SendToServer()
end, function(cmd, args)
	local stuff = {}
	if (OpenPermissions.Addons ~= nil) then
		if (#string.Trim(args) > 0) then
			for name in pairs(OpenPermissions.Addons) do
				if (name:lower():find(string.Trim(args):lower())) then
					stuff[#stuff + 1] = "openpermissions " .. name
				end
			end
		else
			for name in pairs(OpenPermissions.Addons) do
				stuff[#stuff + 1] = "openpermissions " .. name
			end
		end
	end
	table.sort(stuff)
	return stuff
end)

net.Receive("OpenPermissions.NoPermissions", function()
	OpenPermissions:ChatPrint(L"operator_only_menu", "[ERROR]", OpenPermissions.COLOR_RED)
end)

net.Receive("OpenPermissions.NotAnAddon", function()
	OpenPermissions:ChatPrint(L"not_an_addon", "[ERROR]", OpenPermissions.COLOR_RED)
end)
--addons/pcasino/lua/perfectcasino/core/sh_config.lua:
PerfectCasino.Core.Entites = PerfectCasino.Core.Entites or {}
function PerfectCasino.Core.RegisterEntity(class, data, model)
	PerfectCasino.Core.Entites[class] = {}
	PerfectCasino.Core.Entites[class].cache = {}
	PerfectCasino.Core.Entites[class].config = data
	PerfectCasino.Core.Entites[class].model = model
end

function PerfectCasino.Core.GetEntityConfigOptions(class)
	return PerfectCasino.Core.Entites[class].config
end

if SERVER then return end

function PerfectCasino.Core.RequestConfigData(entity)
	net.Start("pCasino:RequestData:Send")
		net.WriteEntity(entity)
	net.SendToServer()
end

net.Receive("pCasino:RequestData:Respond", function()
	local ent = net.ReadEntity()
	if not ent then return end

	local data = net.ReadTable()
	ent.data = data
	ent:PostData()
end)
--addons/pcasino/lua/perfectcasino/core/sh_chip.lua:
return gluapack()()
--addons/pcasino/lua/perfectcasino/config/sh_language.lua:
return gluapack()()
--addons/pcasino/lua/perfectcasino/config/sh_language.lua:
-- Config Menu
PerfectCasino.Translation.ConfigMenu = {}
PerfectCasino.Translation.ConfigMenu.Title = "pCasino Varlık Oluşturucu"
PerfectCasino.Translation.ConfigMenu.EntityToConfig = "Yapılandırılacak Varlık"
PerfectCasino.Translation.ConfigMenu.EntityToConfigComboBox = "Bir varlık seç!"
PerfectCasino.Translation.ConfigMenu.RewardComboBox = "Bir ödül seç!"
PerfectCasino.Translation.ConfigMenu.SpawnEntity = "Varlık Oluştur"
PerfectCasino.Translation.ConfigMenu.ResetButton = "Geri Dön"
PerfectCasino.Translation.ConfigMenu.AddComboButton = "Yeni Kombinasyon"
PerfectCasino.Translation.ConfigMenu.TableHeaderChance = "Kombinasyon"
PerfectCasino.Translation.ConfigMenu.TableHeaderActions = "Eylemler"
PerfectCasino.Translation.ConfigMenu.TakeoutBonusMultiplier = "Kazanç Bonus Çarpanı:"
PerfectCasino.Translation.ConfigMenu.IsJackpot = "Jackpot mu:"
PerfectCasino.Translation.ConfigMenu.Delete = "SİL"

-- Entities
PerfectCasino.Translation.Entities = {}
PerfectCasino.Translation.Entities["pcasino_slot_machine"] = "Temel Slot Makinesi"
PerfectCasino.Translation.Entities["pcasino_wheel_slot_machine"] = "Çarklı Slot Makinesi"
PerfectCasino.Translation.Entities["pcasino_roulette_table"] = "Rulet Masası"
PerfectCasino.Translation.Entities["pcasino_blackjack_table"] = "Blackjack Masası"
PerfectCasino.Translation.Entities["pcasino_mystery_wheel"] = "Gizemli Çark"
PerfectCasino.Translation.Entities["pcasino_sign_plaque"] = "Tabela Plakası"
PerfectCasino.Translation.Entities["pcasino_sign_stand"] = "Tabela Standı"
PerfectCasino.Translation.Entities["pcasino_sign_wall_logo"] = "Duvar Logosu"
PerfectCasino.Translation.Entities["pcasino_sign_interior_standing"] = "İç Mekan Dik Tabela"
PerfectCasino.Translation.Entities["pcasino_sign_interior_wall"] = "İç Mekan Duvar Tabelası"
PerfectCasino.Translation.Entities["pcasino_chair"] = "Sandalye"
PerfectCasino.Translation.Entities["pcasino_prize_plinth"] = "Ödül Kaidesi"
PerfectCasino.Translation.Entities["pcasino_npc"] = "NPC"

-- Rewards
PerfectCasino.Translation.Rewards = {}
PerfectCasino.Translation.Rewards["nothing"] = "Hiçbir şey"
PerfectCasino.Translation.Rewards["money"] = "Para"
PerfectCasino.Translation.Rewards["jackpot"] = "Jackpot"
PerfectCasino.Translation.Rewards["prize_wheel"] = "Ücretsiz Gizemli Çark Çevirme"
PerfectCasino.Translation.Rewards["weapon"] = "Silah"
PerfectCasino.Translation.Rewards["health"] = "Can"
PerfectCasino.Translation.Rewards["armor"] = "Zırh"
PerfectCasino.Translation.Rewards["kill"] = "Öldür"
PerfectCasino.Translation.Rewards["setmodel"] = "Oyuncu Modelini Ayarla"
PerfectCasino.Translation.Rewards["ps1_points"] = "[Pointshop 1] Puan"
PerfectCasino.Translation.Rewards["ps1_item"] = "[Pointshop 1] Eşya"
PerfectCasino.Translation.Rewards["ps2_points"] = "[Pointshop 2] Puan"
PerfectCasino.Translation.Rewards["ps2_item"] = "[Pointshop 2] Eşya"
PerfectCasino.Translation.Rewards["ps2_prempoints"] = "[Pointshop 2] Premium Puanlar"
PerfectCasino.Translation.Rewards["pssh_points"] = "[SH Pointshop] Puanlar"
PerfectCasino.Translation.Rewards["pssh_item"] = "[SH Pointshop] Eşya"
PerfectCasino.Translation.Rewards["pssh_prempoints"] = "[SH Pointshop] Premium Puanlar"
PerfectCasino.Translation.Rewards["wcd_givecar"] = "[William's Car Dealer] Araba Ver"
PerfectCasino.Translation.Rewards["fcd_givecar"] = "[Fresh Car Dealer] Araba Ver"
PerfectCasino.Translation.Rewards["bwe_givexp"] = "[BrickWall's Essentials] XP Ver"
PerfectCasino.Translation.Rewards["mtkn_tokens"] = "[mTokens] Jeton Ver"
PerfectCasino.Translation.Rewards["srp_givecar"] = "[SantosRP] Araba Ver"
PerfectCasino.Translation.Rewards["bc_credits"] = "[Brick's Credits] Krediler"
PerfectCasino.Translation.Rewards["3dcd_givecar"] = "[3D Car Dealer 2] Araba Ver"
PerfectCasino.Translation.Rewards["vcmod_givecar"] = "[VCMod] Araba Ver"
PerfectCasino.Translation.Rewards["mcd_givecar"] = "[Modern Car Dealer] Araba Ver"

-- Config Options
PerfectCasino.Translation.Config = {}

PerfectCasino.Translation.Config.general = {}
PerfectCasino.Translation.Config.general.Title = "Genel Ayarlar"
PerfectCasino.Translation.Config.general.Desc = "Genel oyun ayarları"
PerfectCasino.Translation.Config.general.betPeriod = "İlk bahisten sonra oyunun başlaması için geçen süre"
PerfectCasino.Translation.Config.general.useFreeSpins = "Kazanılan ücretsiz dönüşleri bu çarkta kullanabilme"
PerfectCasino.Translation.Config.general.rope = "Kenar çevresine bir ip ekle"
PerfectCasino.Translation.Config.general.model = "Sergilenecek model"
PerfectCasino.Translation.Config.general.spin = "Platformu döndür"
PerfectCasino.Translation.Config.general.bow = "Üstüne sevimli bir kurdele ekle (Büyük çarpışma kutularına sahip modellerde çalışmayabilir)"
PerfectCasino.Translation.Config.general.bowOffset = "Kurdele etkinse, dikey kaydırma değerini burada ayarla. (Negatif veya pozitif olabilir)"
PerfectCasino.Translation.Config.general.limitUse = "Aynı anda yalnızca 1 makinenin kullanımına izin ver"

PerfectCasino.Translation.Config.buySpin = {}
PerfectCasino.Translation.Config.buySpin.Title = "Dönüş Satın Alma Ayarları"
PerfectCasino.Translation.Config.buySpin.Desc = "Bir çark için dönüş satın alma"
PerfectCasino.Translation.Config.buySpin.buy = "Parasını ödeyerek dönüş satın alınabilsin"
PerfectCasino.Translation.Config.buySpin.cost = "Eğer açık ise, bir dönüşün maliyeti"

PerfectCasino.Translation.Config.jackpot = {}
PerfectCasino.Translation.Config.jackpot.Title = "Jackpot Ayarları"
PerfectCasino.Translation.Config.jackpot.Desc = "Jackpot ile ilgili ayarlar"
PerfectCasino.Translation.Config.jackpot.toggle = "Jackpot kazanılabilir olsun mu?"
PerfectCasino.Translation.Config.jackpot.startValue = "Başlangıç Jackpot değeri"
PerfectCasino.Translation.Config.jackpot.betAdd = "Bahis miktarının yüzde kaçı Jackpot'a eklenecek. 0.1 = %10, 0.5 = %50, 1 = %100, vb."

PerfectCasino.Translation.Config.reward = {}
PerfectCasino.Translation.Config.reward.Title = "Ödül Ayarları"
PerfectCasino.Translation.Config.reward.Desc = "Verilecek ödül kombinasyonlarını seç"

PerfectCasino.Translation.Config.combo = {}
PerfectCasino.Translation.Config.combo.Title = "Kombinasyon Ayarları"
PerfectCasino.Translation.Config.combo.Desc = "Ödemeler için kombinasyonlar oluştur"

PerfectCasino.Translation.Config.wheel = {}
PerfectCasino.Translation.Config.wheel.Title = "Çark Ayarları"
PerfectCasino.Translation.Config.wheel.Desc = "Çark üzerinde verilecek ödülleri ayarla"

PerfectCasino.Translation.Config.bet = {}
PerfectCasino.Translation.Config.bet.Title = "Bahis Ayarları"
PerfectCasino.Translation.Config.bet.Desc = "Bahis limitlerini ayarla"
PerfectCasino.Translation.Config.bet.default = "Varsayılan bahis değeri"
PerfectCasino.Translation.Config.bet.max = "Maksimum bahis değeri"
PerfectCasino.Translation.Config.bet.min = "Minimum bahis değeri"
PerfectCasino.Translation.Config.bet.iteration = "Ok tuşuna basıldığında bahis artışı"
PerfectCasino.Translation.Config.bet.betLimit = "Her tur için kullanıcı başına maksimum bahis (0 sınırsız)"

PerfectCasino.Translation.Config.chance = {}
PerfectCasino.Translation.Config.chance.Title = "Şans Ayarları"
PerfectCasino.Translation.Config.chance.Desc = "Bu nesneye denk gelme olasılığını ayarla. Yüksek değer = yüksek şans"
PerfectCasino.Translation.Config.chance.Bar = "Şans oranlarının görselleştirilmesi"

PerfectCasino.Translation.Config.other = {}
PerfectCasino.Translation.Config.other.Title = "Diğer Ayarlar"
PerfectCasino.Translation.Config.other.Desc = "Çeşitli diğer ayarlar"

PerfectCasino.Translation.Config.turn = {}
PerfectCasino.Translation.Config.turn.Title = "Tur Ayarları"
PerfectCasino.Translation.Config.turn.Desc = "Her turun ayarları"
PerfectCasino.Translation.Config.turn.timeout = "Tur zaman aşımı için saniye cinsinden süre"

PerfectCasino.Translation.Config.payout = {}
PerfectCasino.Translation.Config.payout.Title = "Ödeme Ayarları"
PerfectCasino.Translation.Config.payout.Desc = "Ödeme ile ilgili ayarlar"
PerfectCasino.Translation.Config.payout.win = "Kazanç için ödeme çarpanı"
PerfectCasino.Translation.Config.payout.blackjack = "Blackjack kazancında ödeme çarpanı"

PerfectCasino.Translation.Config.text = {}
PerfectCasino.Translation.Config.text.Title = "Yazı Ayarları"
PerfectCasino.Translation.Config.text.Desc = "Ekranda veya sohbet mesajında görüntülenecek yazı ile ilgili ayarlar"
PerfectCasino.Translation.Config.text.overhead = "NPC'nin üzerinde gösterilecek metin"
PerfectCasino.Translation.Config.text.chat = "Etkileşime geçildiğinde sohbet mesajı olarak söylenecek metin"

-- Toolgun
PerfectCasino.Translation.ToolGun = {}
PerfectCasino.Translation.ToolGun.NoEntity = "Lütfen önce Sağ Tık ile bir varlık yapılandırın"
PerfectCasino.Translation.ToolGun.DeletePermissions = "FPP, PCASINO TOOLGUN İZİNLERİNİZİ ENGELLİYOR"
PerfectCasino.Translation.ToolGun.FPPCheck = "FPP ayarlarından bu varlığa toolgun kullanma izninizi kontrol edin!"

-- Entity Interfaces
PerfectCasino.Translation.UI = {}
PerfectCasino.Translation.UI.JackPot = "Jackpot: %s"
PerfectCasino.Translation.UI.Number = "Sayı: %i"
PerfectCasino.Translation.UI.Start = "Başlama: %is"
PerfectCasino.Translation.UI.PlaceBet = "Bahis Koy"
PerfectCasino.Translation.UI.Waiting = "Bekleniyor"
PerfectCasino.Translation.UI.DoubleDown = "İkiye Katla"
PerfectCasino.Translation.UI.Split = "Böl"
PerfectCasino.Translation.UI.Hit = "Kart Çek"
PerfectCasino.Translation.UI.Stand = "Dur"
PerfectCasino.Translation.UI.Blackjack = "%i (Blackjack)"
PerfectCasino.Translation.UI.Bust = "%i (Patladı)"
PerfectCasino.Translation.UI.CurrentHandTotalValue = "El Değeri: %s"
PerfectCasino.Translation.UI.CurrentHand = "Mevcut El: %s"
PerfectCasino.Translation.UI.SpinThatWheel = "Çarkı Çevir!"
PerfectCasino.Translation.UI.ReadyToPlay = "Oyuna Hazır!"
PerfectCasino.Translation.UI.PurchaseASpin = "Bir Dönüş Satın Al!"
PerfectCasino.Translation.UI.FreeSpin = "Ücretsiz Dönüş!"
PerfectCasino.Translation.UI.FreeSpinCount = "Ücretsiz Dönüşler: %s"
PerfectCasino.Translation.UI.Play = "Oyna: %s"
PerfectCasino.Translation.UI.LeaveSeat = "Koltuğu terk etmek için E'ye basılı tut"
PerfectCasino.Translation.UI.BetLimit = "Bahis Limiti: %s"

-- Chat messages
PerfectCasino.Translation.Chat = {}
PerfectCasino.Translation.Chat.NoMoney = "Bu bahsi koyacak kadar paran yok..."
PerfectCasino.Translation.Chat.Payout = "Şunu kazandın: %s!"
PerfectCasino.Translation.Chat.RouletteFail = "Hiçbir bahsin karşılığını vermedi..."
PerfectCasino.Translation.Chat.PayoutJackpot = "Jackpot'u vurdun! Değer: %s!"
PerfectCasino.Translation.Chat.AlreadyPlaced = "Zaten bir bahis koydun..."
PerfectCasino.Translation.Chat.BetPlaced = "Bahsin koyuldu!"
PerfectCasino.Translation.Chat.HandBust = "Elin yandı, ödeme alamayacaksın..."
PerfectCasino.Translation.Chat.DealerHandBust = "Krupiye yandı, ödemen: %s!"
PerfectCasino.Translation.Chat.HandDraw = "Krupiye ile berabere kaldın, bahsin iade edildi."
PerfectCasino.Translation.Chat.HandLose = "Krupiyenin eli seninkini geçti, ödeme alamayacaksın..."
PerfectCasino.Translation.Chat.HandWin = "Krupiyeyi yendin, ödemen: %s!"
PerfectCasino.Translation.Chat.SlotWheelSpin = "Çarkı çevirdin ve şunu elde ettin: %s!"
PerfectCasino.Translation.Chat.UsedFreeSpin = "Ücretsiz dönüşünü kullandın!"
PerfectCasino.Translation.Chat.UsedPaidSpin = "Bir dönüş için %s ödedin!"
PerfectCasino.Translation.Chat.BetLimit = "Bu tur için bahis limitine ulaştın!"
PerfectCasino.Translation.Chat.WillReachBetLimit = "Bu bahis, bahis limitini aşacak. %s'den daha fazla koyamazsın..."
PerfectCasino.Translation.Chat.LimitMachineUse = "Farklı bir makineyi çok hızlı kullanmaya çalışıyorsun..."
PerfectCasino.Translation.Chat.LimitMachineUsedByOther = "Bu makine şu anda başkası tarafından kullanılıyor!"

--lua/autorun/privateplayer.lua:
player_manager.AddValidModel( "Private", "models/cktheamazingfrog/player/private/private.mdl" )
player_manager.AddValidHands( "Private", "models/cktheamazingfrog/player/private/privatearms.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Private", "models/cktheamazingfrog/player/private/private.mdl" )

local Category = "The Penguins"

local NPC = {   
        Name = "Private Hostile", 
        Class = "npc_combine_s", 
        Model = "models/cktheamazingfrog/player/private/private.mdl",              
        Health = "100",                 
        KeyValues = { citizentype = 4 },                 
        Category = Category,
        Squadname = "Bad Cuddly Penguin"
}

list.Set( "NPC", "npc_privateenemy", NPC ) 

local NPC = {   
        Name = "Private Friendly", 
        Class = "npc_citizen", 
        Model = "models/cktheamazingfrog/player/private/private.mdl",                
        Health = "100",                 
        KeyValues = { citizentype = 4 },                 
        Category = Category,
        Squadname = "Good Cuddly Penguin"
}

list.Set( "NPC", "npc_privatefriend", NPC )
--addons/undertale/lua/psa_undertale/ulx.lua:
-- This script is copyright of !cake, STEAM_0:1:19269760, http://steamcommunity.com/profiles/76561197998805249
-- Undertale is copyright of Toby Fox
-- Undertale audio samples are copyright of Toby Fox

function PSA.Undertale.RegisterULXCommands ()
	for i = 1, #PSA.Undertale.Commands do
		local commandName = PSA.Undertale.Commands [i].CommandName
		local textStyle   = PSA.Undertale.Commands [i].TextStyle
		
		local command = ulx.command ("Fun", "ulx " .. commandName,
			function (ply, message)
				message = message or ""
				message = string.gsub (message, "\\r", "\r")
				message = string.gsub (message, "\\n", "\n")
				message = string.gsub (message, "\\t", "\t")
				PSA.Undertale.Message (message, textStyle)
				
				print (ply:Nick () .. " " .. commandName .. "'d " .. string.format ("%q", message) .. ".")
			end,
			"!" .. commandName
		)
		command:addParam ({ type = ULib.cmds.StringArg, hint = "message", ULib.cmds.takeRestOfLine })
		command:defaultAccess (ULib.ACCESS_ADMIN)
		command:help ("* (You are filled with determination.)")
	end
end

if ulx then PSA.Undertale.RegisterULXCommands () end

--addons/tablo_ent/lua/scoresheet/sheets/money/config.lua:
scoresheet.money_header_text = "Top 10 Zengin" // the header text
scoresheet.money_header_text_color = Color( 100, 170, 100 ) // the color of the header bg

scoresheet.money_max_count = 10 // how many people does it show?
scoresheet.money_cut_at_row_count = 5 // how many rows of people untill it cuts to a new line? ( 5 seems to be max )

scoresheet.money_first_place_icon = Material( "icon16/coins.png" ) // the icon next to #1 name

scoresheet.money_font_header = "score_row_header" // the font used for the header of the row, # number - name
scoresheet.money_font_text = "score_row_text" // font used for the text of the row, $ money
--addons/tablo_ent/lua/scoresheet/sheets/timeplay/config.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/languages/sh_language_en.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/languages/sh_language_es.lua:
RCD = RCD or {}
RCD.Language = RCD.Language or {}

RCD.Language["es"] = {
	["undefined"] = "indefinido",
	["adminMenuConfig"] = "MENÚ DE ADMINISTRACIÓN - CONFIGURACIÓN",
	["configureGroupsVehicles"] = "Configurar grupos y vehículos",
	["groups"] = "GRUPOS",
	["vehicles"] = "VEHÍCULOS",
	["createGroup"] = "CREAR NUEVO GRUPO",
	["createVehicle"] = "CREAR NUEVO VEHÍCULO",
	["dealerConfiguration"] = "CONFIGURACIÓN DE VENDEDOR",
	["enterDealerName"] = "Ingrese el nombre del vendedor",
	["groupsConfig"] = "Configuración de grupos",
	["newPlateforms"] = "NUEVAS PLATAFORMAS DE APARICIÓN",
	["deletePlateforms"] = "ELIMINAR TODAS LAS PLATAFORMAS",
	["deleteNPC"] = "ELIMINAR NPC",
	["saveInformations"] = "GUARDAR INFORMACIÓN",
	["configureGroups"] = "Configurar información de grupos",
	["rankAccess"] = "ACCESO DE RANGOS",
	["jobAccess"] = "ACCESO DE JOBS",
	["enterGroupName"] = "Introduce el nombre del grupo",
	["cancel"] = "CANCELAR",
	["validateCreateGroup"] = "VALIDAR Y CREAR GRUPO",
	["configureVehicleInformations"] = "Configurar información de vehículos",
	["preview"] = "PROBAR",
	["chooseVehicleClass"] = "Elija la clase de vehículo...",
	["chooseVehicleGroup"] = "Elija el grupo de vehículos...",
	["enterVehicleName"] = "Ingrese el nombre del vehículo",
	["enterVehiclePrice"] = "Introduce el precio del vehículo",
	["vehicleView"] = "VISTA DEL VEHÍCULO",
	["generalSettings"] = "CONFIGURACIÓN GENERAL",
	["priceSettings"] = "CONFIGURACIÓN DE PRECIOS",
	["validateCreateVehicle"] = "VALIDAR Y CREAR VEHÍCULO",
	["configureAddon"] = "Configurar todos los ajustes del addon",
	["beltConfig"] = "CONFIGURACIÓN DE CINTURÓN",
	["engineConfig"] = "CONFIGURACIÓN DEL MOTOR",
	["speedometerConfig"] = "CONFIGURACIÓN DEL VELOCÍMETRO",
	["driveConfig"] = "CONFIGURACIÓN DE CONDUCCIÓN",
	["configureCarDealers"] = "CONFIGURAR CONCESIONARIOS DE COCHES",
	["validateSaveSettings"] = "VALIDAR Y GUARDAR AJUSTES",
	["underglow"] = "Luces Bajas",
	["skins"] = "Skins",
	["bodygroups"] = "Bodygroups",
	["carDealer"] = "Vendedor de Autos",
	["spawnVehicle"] = "SPAWNEAR VEHÍCULO",
	["bringBack"] = "DEVOLVER",
	["testVehicle"] = "PROBAR VEHÍCULO",
	["customize"] = "PERSONALIZAR (%s)",
	["sell"] = "VENDER",
	["buyVehicle"] = "Compra",
	["customizationTitle"] = "PERSONALIZACIÓN",
	["mainMenuTitle"] = "MENÚ PRINCIPAL",
	["modifyVehicle"] = "PERSONALIZA TU VEHÍCULO",
	["buySaleVehicles"] = "COMPRA O VENDE VEHICULOS",
	["vehicleOwned"] = "VEHÍCULO EN PROPIEDAD",
	["vehicleForSale"] = "VEHICULO EN VENTA",
	["allowed"] = "PERMITIDO",
	["cantCustomizeVehicle"] = "No puedes personalizar este vehículo \n lamentamos las molestias",
	["testDrive"] = "Prueba de conducción",
	["testDriveEnd"] = "La prueba de manejo terminará en %ss",
	["addonNotInstalled"] = "El addon %s no está instalado",
	["vehicleTooFar"] = "Tu vehículo está demasiado lejos para personalizarlo",
	["customizeVehicleText"] = "Personalizaste tu vehículo para %s",
	["invalidUsergroup"] = "No tienes el rango adecuado para hacer esto.",
	["invalidJob"] = "No tienes el trabajo adecuado para hacer esto.",
	["cantAfford"] = "No tienes suficiente dinero para hacer esto.",
	["buyVehicleText"] = "Compraste un %s por %s",
	["cantReturnVehicle1"] = "No puede vender su vehículo cuando está fuera",
	["sellVehicleText"] = "Has vendido tu vehículo %s por %s",
	["testVehicleText"] = "Comenzaste la prueba del vehículo, tienes %ss",
	["vehicleAlreadyExited"] = "Este vehículo ya está fuera",
	["maxVehicleLimitReached"] = "Ya no puedes sacar más vehículos",
	["cantSpawnVehicle2"] = "Puedes sacar un vehículo durante una prueba.",
	["noPlaceAvailable"] = "No hay lugar disponible, vuelve más tarde",
	["vehicleExitedText2"] = "Acabas de sacar el vehículo %s",
	["returnAroundVehicles"] = "Acabas de guardar los vehículos que te rodean",
	["noVehiclesAround"] = "No hay ningún vehículo a tu alrededor",
	["vehicleTooFarText"] = "Su vehículo está demasiado lejos para ser devuelto",
	["vehicleReturned2"] = "Solo trae tu vehículo devuelta",
	["carDealerNotConfigured"] = "El concesionario de coches no está configurado, póngase en contacto con un administrador",
	["npcTooFar"] = "Estás demasiado lejos del npc para hacer esta acción",
	["npcNotOwnedVehicle"] = "El npc no tiene este vehículo",
	["cantExitVehicle2"] = "No puedes salir del coche porque no está parado",
	["cantExitVehicle3"] = "No puedes salir del auto porque tienes puesto el cinturón de seguridad",
	["invalidGroupName"] = "El nombre del grupo no es válido",
	["vehicleGroupEdited"] = "Modificaste el grupo %s",
	["vehicleGroupCreated"] = "Has creado el grupo de vehículos %s",
	["invalidGroupVehicle"] = "El grupo de vehículos no es válido",
	["vehicleGroupDeleted"] = "Borraste el grupo de vehículos #%s",
	["invalidVehicleClass"] = "La clase de vehículo no es válida",
	["invalidVehicleName"] = "El nombre del vehículo no es válido",
	["invalidVehiclePrice"] = "El precio del vehículo no es válido",
	["vehicleEdited"] = "Modificaste el vehículo %s",
	["vehicleCreated"] = "Creaste el vehículo %s",
	["vehicleDeleted"] = "Borraste el vehículo #%s",
	["pnjUpdated"] = "Actualizaste el npc %s",
	["pnjDeleted"] = "Borraste el npc #%s",
	["plateformEditMode"] = "Actualmente estás en modo de edición para colocar tus plataformas",
	["beenSaved"] = "Guardaste %s plataformas",
	["allPlateformsDeleted"] = "Borraste todas las plataformas en tu servidor",
	["serverConfigurationUpdated"] = "Actualizaste la configuración de tu servidor",
	["close"] = "Cerrar",
	["car"] = "Auto",
	["returnButton"] = "Atrás",
	["maxSpeed"] = "Máxima velocidad",
	["horsePower"] = "Caballos de fuerza",
	["wheelsPerAxles"] = "Ruedas por eje",
	["posX"] = "Pos - X",
	["angleX"] = "Angle - X",
	["posY"] = "Pos - Y",
	["AngleY"] = "Angle - Y",
	["posZ"] = "Pos - Z",
	["angleZ"] = "Angle - Z",
	["fov"] = "FOV",
	["useCustomNotification"] = "Usar notificación personalizada",
	["enterIntoVehicle"] = "Entrar en el vehículo",
	["currency"] = "Divisa",
	["adminCommand"] = "Comando de administración",
	["maxVehicle"] = "Vehículo máximo",
	["testTime"] = "Probar tiempo",
	["distanceToReturn"] = "Distancia para volver",
	["underglowKey"] = "Llave de luz baja",
	["activateBelt"] = "Habilitar módulo de cinturón",
	["warningSound"] = "Sonido de advertencia",
	["beltKey"] = "Llave del cinturón de seguridad",
	["activateEngine"] = "Habilitar módulo de motor",
	["engineKey"] = "Llave del motor",
	["timeToLunchVehicle"] = "Tiempo hasta lanzar el vehículo",
	["cantLeaveVehicleInMotion"] = "No puedes dejar el vehículo en movimiento.",
	["activateSmallAccident"] = "Habilitar pequeño accidente",
	["activateEjectionAccident"] = "Habilitar accidente de eyección",
	["lowerSpeedToExit"] = "Baja la velocidad para salir",
	["minDamageSmallAccident"] = "Daño mínimo por accidente pequeño",
	["minDamageEjectionAccident"] = "Daño mínimo por accidente de eyección",
	["activateSpeedometer"] = "Habilitar velocímetro",
	["activateSimfphysSpeedometer"] = "Habilitar el velocímetro de simfphys para vehículos simfphys",
	["speedometerSize"] = "Tamaño del velocímetro",
	["count"] = "Contar",
	["space"] = "Espacio",
	["defaultSkin"] = "Skin predeterminada",
	["choose"] = "Elegir",
	["skin"] = "Skin",
	["defaultColor"] = "Color predeterminado",
	["chooseColor"] = "Elegir color",
	["configureDefaultColor"] = "Configurar color predeterminado",
	["setDefaultColor"] = "ESTABLECER COLOR PREDETERMINADO",
	["canModifyBodygroup"] = "Puede modificar el grupo corporal",
	["canModifySkin"] = "Puede modificar skin",
	["canModifyColor"] = "Puede modificar color",
	["canModifyUngerglow"] = "Puede modificar luz baja",
	["canTestVehicle"] = "Puede probar el vehículo",
	["canBuyNitro"] = "Puede comprar nitro",
	["priceToChangeBodygroups"] = "Precio para cambiar bodygroups",
	["priceToChangeSkins"] = "Precio para cambiar skins",
	["priceToChangeColors"] = "Precio para cambiar colores",
	["colors"] = "Colores",
	["nitro"] = "Nitro",
	["priceToChangeUnderglow"] = "Precio para cambiar luz baja",
	["priceToBuyNitro"] = "Precio para comprar nitro",
	["pourcentSell"] = "Porcentaje de descuento",
	["noText"] = "Sinm Texto",
	["invalidText"] = "Problema de Texto",
	["language"] = "Idioma",
	["speedUnit"] = "Unidad de velocidad",
	["free"] = "GRATIS",
	["buyForFree"] = "COMPRAR GRATIS",
	["customizePrice"] = "No tienes suficiente dinero para customizar este vehículo",
	["notEnoughtMoney"] = "No tienes suficiente dinero para hacer esto",
	["rentVehc"] = "Alquilaste el vehículo %s por %s",
	["cantSwitch"] = "No te puedes cambiar de asiento porque tienes puesto el cinturón",
	["canSellWithJob"] = "Puede alquilar el vehículo cuando tenga el job de vendedor de autos",
	["brakePower"] = "Potencia de Frenado",
	["modifyRentVehicle"] = "Has modificado la información del vehículo",
	["refundRentVehicle"] = "Se le ha reembolsado por %s",
	["turnSpeed"] = "Velocidad de Giro",
	["mass"] = "Masa",
	["owned"] = "EN PROPIEDAD",
	["cardealerJobSettings"] = "CONFIGURACIÓN DE JOB DE VENDEDOR DE AUTOS",
	["cardealerJobDiscount"] = "Precio porcentual del vehículo cuando es vendido por un jugador",
	["minCommissionPrice"] = "Precio mínimo de comisión",
	["maxCommissionPrice"] = "Precio máximo de comisión",
	["alreadyBought"] = "No puedes comprar este vehículo porque ya lo tienes",
	["notGoodTeam"] = "No tienes el buen trabajo para hacer esto.",
	["rentPrice"] = "Precio de alquiler para el job de vendeor de autos",
	["vcmodTransfert"] = "Transferir todos los datos de VCMOD",
	["wcdTransfert"] = "Transferir todos los datos de WCD",
	["advancedTransfert"] = "Transferir todos los datos de ACD",
	["modernTransfert"] = "Transferir todos los datos de MODERN",
	["compatibilities"] = "AJUSTES DE COMPATIBILIDAD",
	["transfertStart"] = "Comenzaste la transferencia de datos, puede tomar un poco de tiempo...",
	["alreadyTransfert"] = "Ya transferiste estos datos",
	["problem"] = "Ha ocurrido un problema, inténtalo de nuevo",
	["invoiceOptions"] = "Opción(es)",
	["invoiceCarName"] = "Nombre del Auto",
	["invoiceOptionPrice"] = "Precio de opción",
	["invoiceTotalPrice"] = "Precio total",
	["sellerSignature"] = "Firma del vendedor",
	["buyerSignature"] = "Firma del comprador",
	["invoice"] = "Factura",
	["seller"] = "Vendedor : %s",
	["chooseSkin"] = "Elegir Skin",
	["chooseVehicle"] = "Elige Vehiculo",
	["sign"] = "Aclaración",
	["print"] = "Impresión",
	["openAdminConfiguration"] = "CONFIGURACIÓN DE ADMINISTRACIÓN ABIERTA",
	["selectVehicle"] = "Tienes que seleccionar un vehículo",
	["noVehicles"] = "No tienes ningún vehículo para personalizar",
	["toolName"] = "Configuración de NPC",
	["toolDesc"] = "Coloque NPC y configúrelo",
	["toolLeft1"] = "Presione el botón izquierdo para generar las plataformas",
	["toolLeft2"] = "Presione el botón izquierdo para generar o modificar un NPC",
	["toolRight1"] = "Presione el botón derecho del ratón para eliminar la última plataforma colocada",
	["toolRight2"] = "Haga clic derecho en un NPC para eliminarlo",
	["toolReload1"] = "Presione RECARGAR para guardar sus plataformas",
	["toolReload2"] = "Presiona RECARGAR para recargar todos los NPC",
	["invoiceLimit"] = "Has alcanzado el límite de tu factura",
	["stand"] = "PARARSE",
	["pressE"] = "PRESIONE E",
	["yourCommission"] = "Tu comisións",
	["rentVehicle"] = "Alquile el vehículo por %s",
	["saveRentInformation"] = "GUARDAR INFORMACIÓN",
	["startEngineProblem"] = "Hay un problema en el motor al arrancar su vehículo",
	["giveVehicle"] = "Le diste el vehículo %s al SteamID %s",
	["carDealerJobConfig"] = "Nombre del job del vendedor de autos",
	["areYouSure"] = "ESTÁS SEGURO?",
	["reset"] = "REINICIAR",
	["acceptedInvoice"] = "%s acaba de comprar el vehículo %s por %s",
	["cantAcceptYourInvoice"] = "No puedes aceptar tu propia factura",
	["import"] = "Importar",
	["standTitle"] = "VENDEDOR DE AUTOS",
	["sellVehicle"] = "Vender Vehiculo",
	["rentVehicleSpace"] = "No tienes espacio para alquilar el vehículo",
	["nitroKey"] = "Llave de Nitro",
	["nitroSpeed"] = "Multiplicador de velocidad nitro",
	["minSpeedNitro"] = "Velocidad mínima para activar nitro",
	["cantSell"] = "No puedes vender este vehículo",
	["cantSellSetting"] = "No se puede vender este vehiculo",
	["playersManagement"] = "Gestión de jugadores",
	["open"] = "Abrir",
	["searchDisconnected"] = "JUGADOR DESCONECTADO",
	["connectedPlayers"] = "JUGADORES CONECTADOS",
	["selectedPlayer"] = "JUGADOR SELECCIONADO",
	["allVehicles"] = "TODOS LOS VEHICULOS",
	["adminMenuPlayer"] = "MENÚ DE ADMINISTRACIÓN - JUGADORES",
	["adminMenuPlayerDesc"] = "Gestiona vehículos comprados por tus jugadores.",
	["modifiedInformation"] = "Has cambiado la información de %s",
	["searchSteamId2"] = "Buscar por SteamID / SteamID64",
	["refreshList"] = "ACTUALIZAR LISTA",
	["searchPlayer"] = "BUSCAR JUGADOR",
	["savePlayerInfo"] = "GUARDAR INFORMACIÓN DEL JUGADOR",
	["nitroConfig"] = "CONFIGURACIÓN NITRO",
	["nitroDuration"] = "Duración del nitro",
	["nitroCooldowns"] = "Nitro reloading time",
	["cooldownsNitroNotify"] = "Tu nitro no está listo, próxima carga en %ss",
	["alreadyRented"] = "Ya has alquilado este vehículo",
	["sellVehicleRented"] = "Has recibido %s por la venta del vehículo %s",
	["disableBeltVehicle"] = "Desactivar el módulo del cinturón de seguridad para este vehículo",
	["disableEngineVehicle"] = "Desactivar el módulo del motor para este vehículo",
}
--addons/realisticcardealer/lua/realistic_cardealer/languages/sh_language_tr.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/client/cl_3d2d_lib.lua:
RCD = RCD or {}

RCD.JobButtons = RCD.JobButtons or {}
RCD.JobButtons.List = RCD.JobButtons.List or {}

RCD.ClientSideMenu = RCD.ClientSideMenu or {}
RCD.ClientSideMenu.ModelId = RCD.ClientSideMenu.ModelId or 0

function RCD.JobButtons:addView(posView, angView, idView, ndrawView, scaleView)
    if !self.List[idView] then
        self.List[idView] = {
            posView = posView,
            angView = angView,
            buttonsView = {},
            drawView = ndrawView,
            scaleView = scaleView or 0.07
        }
    else
        self.List[idView].posView = posView
        self.List[idView].angView = angView
        self.List[idView].ndrawView = ndrawView
        self.List[idView].scaleView = scaleView or 0.07
    end
end

function RCD.JobButtons:removeView(id)
    if !self.List[id] then return end
    for _, v in pairs(self.List[id].buttonsView or {}) do
        if v and v.Remove then
            v:Remove()
        end
    end
    self.List[id] = nil
    RCD.ClientSideMenu.ModelId = 0
end

function RCD.JobButtons:insertElement(id, button)
    table.insert(self.List[id].buttonsView, button)
end

function RCD.JobButtons:getXCursor(scaleView)
    return self.cursorPos and (self.cursorPos.x/scaleView) or 0
end

function RCD.JobButtons:getYCursor(scaleView)
    return self.cursorPos and (self.cursorPos.y/-scaleView) or 0
end

local meta = {
    SetPos = function(self, x, y)
        self.x = x
        self.y = y
    end,
    SetSize = function(self, w, h)
        self.w = w
        self.h = h
    end,
    GetPos = function(self)
        return self.x, self.y
    end,
    GetWide = function(self)
        return self.w
    end,
    GetTall = function(self)
        return self.h
    end,
    GetSize = function(self)
        return self.w, self.h
    end,
    SetIdView = function(self, id)
        self.RenderViewID = id
        RCD.JobButtons:insertElement(id, self)
    end,
    Remove = function(self)
        if self.OnRemove then
            self:OnRemove()
        end
        if self.ParentLayout then
            self:RemoveToLayout()
        end
        if self.Children then
            for k, v in pairs(self.Children) do
                if !v then continue end
                v:Remove()
            end
        end
        table.RemoveByValue(RCD.JobButtons.List[self.RenderViewID].buttonsView, self)
    end,
    IsCliked = function(self)
        if !self.PaintManual and self:IsHovered() then
            if input.IsMouseDown(MOUSE_LEFT) and !self.antiClick and !RCD.JobButtons.IsDragging then
                if isfunction(self.DoClick) then
                    RCD.JobButtons.IsDragging = self.DoClick(self) != true // If return true we don't block the next button
                    self.antiClick = true
                end
                return true
            elseif !input.IsMouseDown(MOUSE_LEFT) then
                self.antiClick = false
            end
        else
            return false
        end
    end,
    IsHovered = function(self)
        if RCD.JobButtons.List[self.RenderViewID] and RCD.JobButtons:getXCursor(RCD.JobButtons.List[self.RenderViewID].scaleView) > self.x and RCD.JobButtons:getXCursor(RCD.JobButtons.List[self.RenderViewID].scaleView) < self.x + self.w and RCD.JobButtons:getYCursor(RCD.JobButtons.List[self.RenderViewID].scaleView) > self.y and RCD.JobButtons:getYCursor(RCD.JobButtons.List[self.RenderViewID].scaleView) < self.y + self.h then
            return true
        else
            return false
        end
    end,
    RenderModel = function(self)
        if self.Model and IsValid(self.Model) then
            local dModelPanelRT = GetRenderTarget("dModelPanelRT" .. self.customMaterial:GetName(), self.w, self.h)
            render.PushRenderTarget(dModelPanelRT)
                render.OverrideAlphaWriteEnable(true, true)
                render.ClearDepth()
                render.Clear(0, 0, 0, 0)

                local mn, mx = self.Model:GetRenderBounds()
                local size = 0
                size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
                size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
                size = math.max(size, math.abs(mn.z) + math.abs(mx.z))

                local lookat = (mn + mx) * 0.5
                local campos = Vector(size, size, size)
                local move = (lookat-campos):Angle()

                cam.Start3D(campos + move:Forward() * -200, (lookat-campos):Angle(), self:GetFOV(), 0, 0, ScrW(), ScrH(), 5, 4096)
                    render.SuppressEngineLighting(true)
                    render.SetLightingOrigin(self.Model:GetPos())
                    render.ResetModelLighting(1, 1, 1)
                    self.ColorModel = self.Model:GetColor()
                    if self.ColorModel then
                        render.SetColorModulation(self.ColorModel.r/255, self.ColorModel.g/255, self.ColorModel.b/255)
                    end
                    render.SetBlend(1)
                    for i = 0, 6 do
                        if (col) then
                            render.SetModelLighting(i, 1, 1, 1)
                        end
                    end
                    self.Model:DrawModel()
                    render.SuppressEngineLighting(false)
                cam.End3D()
                render.OverrideAlphaWriteEnable(false)
            render.PopRenderTarget()
            self.customMaterial:SetTexture("$basetexture", dModelPanelRT:GetName())
            self.Updated = true
        end
    end,
    RenderChildren = function(self, draws)
        local base = ((self.y + self.marginTop) - (self.scrollValue * (self.canvasLenght - (self.h - self.marginTop - self.marginBot))))
        local first = (self.y + self.marginTop)
        local lastOffset = 0
        for k, v in pairs(self.childrenLayout) do
            if !v.startDragging then
                v.y = base
            end
            local x, y = self.x, math.max(v.y, self.y + self.marginTop)
            local w, h = self.w, math.max(0, math.min(v.h - (y-v.y), (self.h - self.marginBot) - (y - self.y)))
            if !RCD.JobButtons:IsHovered(x, y, w, h, v.RenderViewID) and !v.alwaysClick then
                v.antiClick = true
            end
            if draws and !v.startDragging then
                RCD.JobButtons:DrawStencil(function()
                    if v.y < self.y + self.h - self.marginBot and ((v.y + v.h) - (self.y  +self.marginTop)) >= 0 then
                        draw.RoundedBox(0, x, y, w, h, color_white)
                    end
                end,
                function()
                    v:Render3D()
                end)
            end
            if !v.line then
                base = base + v.h + self.spaceY + v.offsetLayoutY
                first = first + v.h + self.spaceY + v.offsetLayoutY
                lastOffset = v.offsetLayoutY
            end
        end
        first = (first - (self.y + self.marginTop) - self.spaceY - lastOffset)
        if true then
            self.scrollBar.h = (((self.h - self.marginTop - self.marginBot) / (first)) * (self.h - self.marginTop - self.marginBot))
            if self.scrollBar.h > (self.h - self.marginTop - self.marginBot) || self.scrollBar.h < 0 then
                self.scrollBar.h = 0.0001
                self.scrollValue = 0
            elseif self.startDown then
                self.scrollValue = 1
                self.scrollBar.y = self.y + self.marginTop + self.h - self.marginBot - self.scrollBar.h
            end
            self.scrollBar.y = math.Clamp(self.scrollBar.y, self.scrollBar.baseY, self.scrollBar.baseY + ((self.h - self.marginTop - self.marginBot) - self.scrollBar.h))
            self.scrollValue = (self.scrollBar.y - self.scrollBar.baseY) / ((self.h - self.marginTop - self.marginBot) - self.scrollBar.h)
            self.canvasLenght = first
        end
    end,
    Render3D = function(self)
        if isfunction(self.Paint) then self.Paint(self, self.w, self.h, self.x, self.y) end
        //self:IsHovered()
        if isfunction(self.Think) then self.Think(self) end
        if self.startAnimation then self:AnimThink() end
        if self.childrenLayout then
            self:RenderChildren(true)

            for k, v in pairs(self.childrenLayout) do
                if v.startDragging then
                    v:Render3D()
                end
            end
        elseif self.Model and self.customMaterial then
            surface.SetDrawColor(RCD.Colors["white"])
            surface.SetMaterial(self.customMaterial)
            surface.DrawTexturedRect(self.x, self.y, self.w, self.h)
        elseif self.openSizeX then
            if self.OpenBySize then
                self.h = Lerp(10/(1/FrameTime()), self.h, self.openSizeX)
            else
                self.h = Lerp(10/(1/FrameTime()), self.h, self.baseOpenX)
            end
        end
    end,
    CreateLayout = function(self, frame, marginTop, marginBot, spaceY, sizeBtnX, marginBtnX, startDown, barColor)
        self.childrenLayout = {}
        self.scrollValue = 0
        self.canvasLenght = 0
        self.marginTop = marginTop
        self.marginBot = marginBot
        self.spaceY = spaceY
        self.mouseFrame = frame
        self.startDown = startDown
        local scrollBar = RCD.JobButtons:createButton()
        scrollBar:SetSize(sizeBtnX, 0)
        scrollBar:SetPos(self.x + self.w - marginBtnX, self.y + self.marginTop)
        scrollBar.baseY = self.y + self.marginTop
        scrollBar.parentLayout = self
        scrollBar:SetIdView(self.RenderViewID)
        scrollBar:AddRemoveParent(self)
        scrollBar.Paint = function(self, w, h, x, y)
            if self.Disable then return end
            draw.RoundedBox(30, x, y, w, h, barColor or color_white)
            if self.IsDragging then
                if !isnumber(self.IsDragging) then
                    self.IsDragging = RCD.JobButtons:getYCursor(RCD.JobButtons.List[self.RenderViewID].scaleView) - y
                end
                local y = RCD.JobButtons:getYCursor(RCD.JobButtons.List[self.RenderViewID].scaleView) - self.IsDragging
                y = math.Clamp(y, self.baseY, self.baseY + ((self.parentLayout.h - marginTop - marginBot) - self.h))
                self.parentLayout.scrollValue = (y - self.baseY) / ((self.parentLayout.h - marginTop - marginBot) - self.h)
                self:SetPos(self.x, y)
                if !input.IsMouseDown(MOUSE_LEFT) then
                    self.IsDragging = false
                    RCD.JobButtons.IsDragging = false
                end
            elseif self.IsWheeled and self.parentLayout:IsHovered() then
                self.y = math.Clamp(self.y - self.IsWheeled, self.baseY, self.baseY + ((self.parentLayout.h - marginTop - marginBot) - self.h))
                self.parentLayout.scrollValue = (y - self.baseY) / ((self.parentLayout.h - marginTop - marginBot) - self.h)
            end
            self.IsWheeled = false
        end
        scrollBar.DoClick = function(self)
            self.IsDragging = true
            RCD.JobButtons.IsDragging = true
        end
        self.OnRemove = function(self)
            if IsValid(RCD.tempFrame) then
                RCD.tempFrame:Remove()
            end
        end
        if !IsValid(frame) and !IsValid(RCD.tempFrame) then
            frame = vgui.Create("DFrame")
            frame:SetSize(ScrW(),ScrH())
            frame.Temp = true
            frame:ShowCloseButton(false)
            frame:SetTitle("")
            frame:SetDraggable(false)
            frame.Paint = function()
            end
            RCD.tempFrame = frame
        elseif IsValid(RCD.tempFrame) then
            frame = RCD.tempFrame
        end
        if IsValid(frame) then
            local save = frame.OnMouseWheeled or function() end
            frame.OnMouseWheeled = function(_, delta)
                self.scrollBar.IsWheeled = self.scrollBar.IsWheeled and self.scrollBar.IsWheeled + (delta/math.abs(delta))*self.scrollBar.h/10 or (delta/math.abs(delta))*self.scrollBar.h/10
                save(_, delta)
            end
        end
        self.scrollBar = scrollBar
    end,
    AddToLayout = function(self, children, pos)
        if pos then
            table.insert(self.childrenLayout, pos, children)
        else
            self.childrenLayout[#self.childrenLayout + 1] = children
        end
        children.RenderViewID = self.RenderViewID
        children.ParentLayout = self
        self.scrollBar.h = 0
        self.scrollBar.y = self.scrollBar.baseY
        self.scrollValue = 0
    end,
    RemoveToLayout = function(self)
        self.ParentLayout.scrollBar.h = 0
        self.ParentLayout.scrollValue = 0
        self.ParentLayout.scrollBar.y = self.ParentLayout.scrollBar.baseY
        table.RemoveByValue(self.ParentLayout.childrenLayout, self)
    end,
    AnimThink = function(self)
        local vector = LerpVector(self.animTime, Vector(self.x, self.y, 0), Vector(self.endPosX, self.endPosY, 0))
        self:SetPos(vector.x, vector.y)
    end,
    MoveTo = function(self, x, y, second)
        self.endPosX = x
        self.endPosY = y

        self.animTime = second ^ -3

        self.startAnimation = true
        return self
    end,
    SetTextEntry = function(self, text, frame, multi, base)
        self.textDraw = text
        self.baseText = text
        self.DoClick = function(self)
            if self.textDraw == text then
                self.textDraw = base and tostring(base) or ""
                self.isReady = true
            end
            local removeFrame = false
            if !IsValid(frame) then
                frame = vgui.Create("DFrame")
                frame:SetSize(ScrW(), ScrH())
                frame:MakePopup()
                frame:ShowCloseButton(false)
                frame:SetTitle("")
                frame:SetDraggable(false)
                frame.Paint = function() end
                removeFrame = true
            end
            self.mEntry = vgui.Create("DTextEntry", frame)
            self.mEntry:SetSize(300, ScrW()/20)
            self.mEntry:SetText(self.textDraw)
            self.mEntry:SetCaretPos(#self.textDraw)
            self.mEntry:SetMultiline(multi or false)
            self.mEntry.Paint = function(selfs)
                self.textDraw = selfs:GetText()
                if !selfs:HasFocus() then
                    if self.textDraw == "" then
                        self.textDraw = self.baseText
                    end
                    selfs:Remove()
                    if removeFrame and IsValid(frame) then
                        frame:Remove()
                    end
                    RCD.JobButtons.IsDragging = true
                end
            end
            self.mEntry.OnEnter = function()
                if self.OnEnter then
                    self:OnEnter()
                end
            end
            if self.entryLoad then
                self.entryLoad(self.mEntry)
                if multi then
                    self.mEntry.AllowInput = function(selfs, stringValue)
                        surface.SetFont(selfs.drawFont or "ADCFont::1")
                        local w, h = surface.GetTextSize(selfs:GetText() .. stringValue)
                        if h > self.h-10 then
                            return true
                        end
                        if (w >= self.w-20) then
                            w, h = surface.GetTextSize(selfs:GetText() .. "\n test")
                            if h > self.h-10 then
                                return true
                            end
                            selfs:SetText(selfs:GetText() .. "\n")
                            self.textDraw = selfs:GetText()
                            selfs:SetCaretPos(#self.textDraw)
                        end
                    end
                else
                    self.mEntry.AllowInput = function(self, stringValue)
                        if (self:CheckNumeric(stringValue)) then return true end
                        if self:GetNumeric() and stringValue == "-" then return true end
                        if self.maxChar then
                            if #self:GetText() >= self.maxChar then return true end
                        end
                        if self.nameEntry then
                            return RCD.Func:AvailableChar(stringValue)
                        end
                    end
                end
            end
            self.mEntry:RequestFocus()
        end
    end,
    DrawTextEntry = function(self, x, y, bl, textAdd)
        if IsValid(self.mEntry) then
            if math.floor(CurTime()*2)%2 == 0 or input.IsKeyDown(KEY_RIGHT) or input.IsKeyDown(KEY_LEFT) then
                local firstText, lastText = RCD:StringSeparate(self.textDraw, self.mEntry:GetCaretPos())
                surface.SetFont(self.drawFont or "ADCFont::1")
                local explodeText = string.Explode("\n", firstText)
                firstText = explodeText[#explodeText]
                local sizeX, sizeY = surface.GetTextSize(firstText)
                draw.RoundedBox(0, x + sizeX, y + sizeY*(#explodeText-1), 1, sizeY, color_white)
            end
        end
        if self.textDraw == self.baseText then
            draw.DrawText(self.textDraw .. (textAdd or ""), self.drawFont or "ADCFont::1", x, y, RCD.ClientSideMenu.Colors["grey"], TEXT_ALIGN_LEFT)
            return
        end
        if (self.isReady and self.customCheck and self.customCheck(self.textDraw)) then
            draw.DrawText(self.textDraw .. (textAdd or ""), self.drawFont or "ADCFont::1", x, y, RCD.ClientSideMenu.Colors["red"], TEXT_ALIGN_LEFT)
        else
            draw.DrawText(self.textDraw .. (textAdd or ""), self.drawFont or "ADCFont::1", x, y, color_white, TEXT_ALIGN_LEFT)
        end
    end,
    GetText = function(self)
        return self.textDraw
    end,
    SetText = function(self, txt)
        self.textDraw = txt
    end,
    AddRemoveParent = function(self, parent)
        parent.Children = parent.Children or {}
        parent.Children[#parent.Children + 1] = self
    end,
    CreateDModelPanel = function(self, model)
        if IsValid(self.Model) then
            self.Model:Remove()
        end
        self.Model = ClientsideModel(Model(model), RENDERGROUP_OPAQUE)
        self.Model:SetNoDraw(true)
        self.Model:SetIK(false)
        self.CreateModelId = RCD.ClientSideMenu.ModelId
        RCD.ClientSideMenu.ModelId = RCD.ClientSideMenu.ModelId + 1
        self.OnRemove = function(self)
            if IsValid(self.Model) then
                self.Model:Remove()
            end
        end
        self.customMaterial = CreateMaterial("dModelPanelRTEG" .. self.CreateModelId, "UnlitGeneric", {
            ["$translucent"] = 1,
            ["$vertexcolor"] = 1
        })
    end,
    SetColorModel = function(self, color)
        self.ColorModel = color
    end,
    SetOpenSize = function(self, x)
        if !self.baseOpenX then
            self.baseOpenX = self.h
        end
        self.openSizeX = x
    end,
    GetOpenSize = function(self)
        return self.openSizeX
    end,
    SetOpen = function(self, bool)
        self.OpenBySize = bool
    end,
    GetOpen = function(self)
        return self.OpenBySize
    end,
}
AccessorFunc(meta, "FOVValue", "FOV", FORCE_NUMBER)
AccessorFunc(meta, "CamPosValue", "CamPos", FORCE_VECTOR)
AccessorFunc(meta, "LookAtValue", "LookAt", FORCE_VECTOR)

meta.__index = meta

function RCD.JobButtons:createButton()
    local button = {}
    button.x = 0
    button.y = 0
    button.w = 0
    button.h = 0
    button.RenderViewID = nil
    button.offsetLayoutY = 0
    setmetatable(button, meta)
    return button
end

function RCD.JobButtons:drawView(posView, angView, fovView, ...)
    local x, y = input.GetCursorPos()
    local arrayButton = {}
    if #{...} >= 1 then // Draw only the vargs
        for k, v in pairs({...}) do
            arrayButton[v] = self.List[v]
        end
    else
        arrayButton = self.List
    end
    for _, v in pairs(arrayButton) do
        if v.ndrawView then continue end
        local aimDirec = util.AimVector(angView or LocalPlayer():EyeAngles(), fovView or 85, x, y, ScrW(), ScrH())
        local collidePos = util.IntersectRayWithPlane(posView or LocalPlayer():EyePos(), aimDirec, v.posView, v.angView:Up())

        if collidePos then
            self.cursorPos = WorldToLocal(collidePos, Angle(0, 0, 0), v.posView, v.angView)
        end

        if self.IsDragging and !input.IsMouseDown(MOUSE_LEFT) then
            self.IsDragging = false
        end

        for _, j in ipairs(v.buttonsView) do
            if j.Model and !j.Updated then
                j:RenderModel()
            end
        end

        cam.Start3D2D(v.posView, v.angView, v.scaleView or 0.07)
        for _, j in ipairs(v.buttonsView) do
            if IsValid(j) and ispanel(j) then // For spawnicon
                j:PaintManual()
            elseif !j.PaintManual then
                j:Render3D()
            end
        end
        cam.End3D2D()
        for _, j in SortedPairs(v.buttonsView, true) do
            if !ispanel(j) then
                if j.childrenLayout then
                    for _, child in SortedPairs(j.childrenLayout, true) do
                        if child:IsCliked() then
                            break
                        end
                    end
                elseif j:IsCliked() then
                    break
                end
            end
        end
    end
end

function RCD.JobButtons:IsHovered(x, y, w, h, RenderViewID)
    if RCD.JobButtons.List[RenderViewID] and RCD.JobButtons:getXCursor(RCD.JobButtons.List[RenderViewID].scaleView) > x and RCD.JobButtons:getXCursor(RCD.JobButtons.List[RenderViewID].scaleView) < x + w and RCD.JobButtons:getYCursor(RCD.JobButtons.List[RenderViewID].scaleView) > y and RCD.JobButtons:getYCursor(RCD.JobButtons.List[RenderViewID].scaleView) < y + h then
        return true
    else
        return false
    end
end

function RCD.JobButtons:DrawStencil(calcFunc, drawFunc, id)
    render.SetStencilWriteMask(0xFF)
    render.SetStencilTestMask(0xFF)
    render.SetStencilReferenceValue(id or 0)
    render.SetStencilPassOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.ClearStencil()

    render.SetStencilEnable(true)
    render.SetStencilReferenceValue(id and (id + 1) or 1)
    render.SetStencilCompareFunction(STENCIL_NEVER)
    render.SetStencilFailOperation(STENCIL_REPLACE)
    calcFunc()
    render.SetStencilCompareFunction(STENCIL_EQUAL)
    render.SetStencilFailOperation(STENCIL_KEEP)
    drawFunc()
    render.SetStencilEnable(false)
end

function RCD:StringSeparate(text, pos) // 3D2D TextEntry cursor position
    return utf8.sub(text, 1, pos), utf8.sub(text, pos+1)
end
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_button.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_colormixer.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_dscroll.lua:
return gluapack()()
--addons/bb_isimeklentisi/lua/rpname_enforcer/sh_config.lua:
return gluapack()()
--addons/rsc/lua/rsc/shared/sh_utils.lua:
return gluapack()()
--addons/rsc/lua/rsc/classes/event.lua:
return gluapack()()
--addons/rsc/lua/rsc/client/cl_net.lua:
return gluapack()()
--addons/sam-159/lua/sam/libs/sh_types.lua:
if SAM_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sam.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sam["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sam.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sam.IsEntity = sam.isentity

local type = sam.type
function sam.istable(value)
	return type(value) == "table"
end
--addons/sam-159/lua/sam/sh_util.lua:
if SAM_LOADED then return end

local sam = sam

function sam.parse_args(str)
	local args = {}
	local tmp, in_quotes = "", false
	for i = 1, #str do
		local char = str:sub(i, i)
		if char == "\"" then
			-- i could use string.find to find the next double quotes but thats gonna be overkill
			in_quotes = not in_quotes
			if tmp ~= "" or not in_quotes then
				args[#args + 1], tmp = tmp, ""
			end
		elseif char ~= " " or in_quotes then
			tmp = tmp .. char
		elseif tmp ~= "" then
			args[#args + 1], tmp = tmp, ""
		end
	end
	if tmp ~= "" then
		args[#args + 1] = tmp
	end
	return args, #args
end

function sam.get_targets_list(targets)
	if sam.isstring(targets) then
		return {Color(244, 67, 54), targets}
	end

	local len = #targets

	if len == player.GetCount() and len > 1 then
		return {Color(244, 67, 54), sam.language.get("Everyone")}
	end

	local admin = targets.admin
	local result = {}
	local white = Color(236, 240, 241)
	for i = 1, len do
		local target = targets[i]

		if CLIENT and LocalPlayer() == target then
			table.insert(result, Color(255, 215, 0))
			if admin ~= LocalPlayer() then
				table.insert(result, sam.language.get("You"))
			else
				table.insert(result, sam.language.get("Yourself"))
			end
		elseif admin ~= target then
			local name
			if sam.isentity(target) and target.Name then
				name = target:Name()
			else
				name = "Unknown"
				table.insert(result, white)
				table.insert(result, "*")
			end

			table.insert(result, Color(244, 67, 54))
			table.insert(result, name)
		else
			table.insert(result, Color(255, 215, 0))
			table.insert(result, sam.language.get("Themself"))
		end

		if i ~= len then
			table.insert(result, white)
			table.insert(result, ",")
		end
	end

	return result
end

function sam.is_steamid(id, err) -- https://stackoverflow.com/questions/6724268/check-if-input-matches-steam-id-format
	if sam.isstring(id) and id:match("^STEAM_[0-5]:[0-1]:[0-9]+$") ~= nil then
		return true
	else
		return err and error("invalid steamid", 2) or false
	end
end

function sam.is_steamid64(id, err)
	if sam.isstring(id)
		and tonumber(id)
		and id:sub(1, 7) == "7656119"
		and (#id == 17 or #id == 18) then
		return true
	else
		return err and error("invalid steamid64", 2) or false
	end
end

do
	local console = {}

	do
		local return_console = function()
			return "Console"
		end
		for _, v in ipairs({"SteamID", "SteamID64", "Name", "Nick", "Name"}) do
			console[v] = return_console
		end
		setmetatable(console, {
			__tostring = return_console,
			MetaName = "console"
		})
	end

	function console.IsAdmin()
		return true
	end

	function console.IsSuperAdmin()
		return true
	end

	function console:IsUserGroup(name)
		return name == "superadmin"
	end

	function console.GetUserGroup()
		return "superadmin"
	end

	function console.HasPermission()
		return true
	end

	function console.CanTarget()
		return true
	end

	function console.CanTargetRank()
		return true
	end

	function console.GetBanLimit()
		return 0
	end

	function console.SetUserGroup()
	end

	function sam.isconsole(v)
		return v == console
	end

	sam.console = console
end

do
	local times = {
		"year"; 525600,
		"month"; 43800,
		"week"; 10080,
		"day"; 1440,
		"hour"; 60,
		"minute"; 1
	}

	for i = 1, #times, 2 do
		times[i] = " " .. times[i]
	end

	local floor = math.floor
	function sam.format_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "Indefinitely"
		elseif mins <= 1 then
			return "1 minute"
		end

		local str = ""
		for i = 1, #times, 2 do
			local n1, n2 = times[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					if mins == 0 then
						str = str .. " and "
					else
						str = str .. ", "
					end
				end
				str = str .. n2 .. times[i]
				if n2 > 1 then
					str = str .. "s"
				end
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	local times = {
		m = 1,
		h = 60,
		d = 1440,
		w = 10080,
		mo = 43800,
		y = 525600
	}

	function sam.parse_length(length)
		local time, found = tonumber(length), false
		if sam.isnumber(length) then
			time, found = length, true
		elseif time then
			found = true
		else
			time = 0
			for t, u in length:gmatch("(%d+)(%a+)") do
				u = times[u]
				if u then
					time = time + (u * t)
					found = true
				end
			end
		end
		if not found then return false end
		return math.Clamp(time, 0, 31536000)
	end

	local times2 = {}
	for k, v in SortedPairsByValue(times, true) do
		table.insert(times2, k)
		table.insert(times2, v)
	end

	local floor = math.floor
	function sam.reverse_parse_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "0"
		elseif mins <= 1 then
			return "1m"
		end

		local str = ""
		for i = 1, #times2, 2 do
			local n1, n2 = times2[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					str = str .. " "
				end
				str = str .. n2 .. times2[i]
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	if SERVER then
		function sam.hook_call(event, ...)
			hook.Call(event, nil, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end

		function sam.client_hook_call(event, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end
	else
		local function hook_call(event, ...)
			hook.Call(event, nil, ...)
		end
		sam.netstream.Hook("HookCall", hook_call)
	end
end

if SERVER then
	local maps = {}

	for k, v in ipairs(file.Find("maps/*.bsp", "GAME")) do
		maps[k] = v:sub(1, -5):lower()
	end

	sam.set_global("Maps", maps)
end

function sam.is_valid_map(name)
	local maps = sam.get_global("Maps", {})
	if name:sub(-4) == ".bsp" then
		name = name:sub(1, -5)
	end
	name = name:lower()
	for i = 1, #maps do
		if maps[i] == name then
			return name
		end
	end
	return false
end

function sam.is_valid_gamemode(name)
	name = name:lower()
	local gamemodes = engine.GetGamemodes()
	for i = 1, #gamemodes do
		local gamemode = gamemodes[i]
		if sam.isstring(gamemode.name) and gamemode.name:lower() == name then
			return true
		end
	end
	return false
end

function sam.hook_first(event, name, func)
	if HOOK_HIGH then
		return hook.Add(event, name, func, HOOK_HIGH)
	end

	return hook.Add(event, name, func)
end

function sam.hook_last(event, name, func)
	if HOOK_LOW then
		return hook.Add(event, name, func, HOOK_LOW)
	end

	return hook.Add(event, name, func)
end

do
	local byte = string.byte
	local gsub = string.gsub
	local char = string.char
	local format = string.format
	local tonumber = tonumber

	local hex_encode = function(c)
		return format("%02X", byte(c))
	end

	function sam.to_hex(text)
		-- gsub returns more than one value, fucking glualint can't stop complaining about using ()
		local hex = gsub(text, ".", hex_encode)
		return hex
	end

	local hex_decode = function(d)
		return char(tonumber(d, 16))
	end

	function sam.from_hex(hex)
		local text = (gsub(hex, "%x%x", hex_decode))
		return text
	end
end

--addons/sam-159/lua/sam/sh_permissions.lua:
return gluapack()()
--addons/sam-159/lua/sam/config/sh_config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

sam.permissions.add("manage_config", nil, "superadmin")

local updates = {}
function config.hook(keys, func)
	for i = #keys, 1, -1 do
		keys[keys[i]] = true
		keys[i] = nil
	end

	local id = table.insert(updates, {
		keys = keys,
		func = func
	})

	if config.loaded then
		func()
	end

	return id
end

function config.get_updated(key, default)
	local setting = {}
	config.hook({key}, function()
		setting.value = config.get(key, default)
	end)
	return setting
end

function config.remove_hook(key)
	updates[key] = nil
end

hook.Add("SAM.LoadedConfig", "RunHooks", function()
	for k, v in pairs(updates) do
		v.func()
	end
end)

hook.Add("SAM.UpdatedConfig", "RunHooks", function(key, value, old)
	for k, v in pairs(updates) do
		if v.keys[key] then
			v.func(value, old)
		end
	end
end)
--addons/sam-159/lua/sam/command/arguments/map.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("map")
	:OnExecute(function(argument, input, ply, _, result)
		local map_name = sam.is_valid_map(input)
		if not map_name and not (argument.optional and input == "None") then
			ply:sam_send_message("invalid", {
				S = "map", S_2 = input
			})
			return false
		end

		table.insert(result, map_name)
	end)

	:Menu(function(set_result, _, buttons, argument)
		local maps = buttons:Add("SAM.ComboBox")
		maps:SetTall(25)

		if argument.optional then
			maps:AddChoice("None", nil, true)
		end

		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if not (argument.exclude_current and map_name == game.GetMap()) then
				maps:AddChoice(map_name)
			end
		end

		function maps:OnSelect(_, value)
			set_result(value)
		end

		local value = argument.optional and "None" or maps:GetOptionText(1)
		maps:SetValue(value)
		maps:OnSelect(nil, value)

		return maps
	end)

	:AutoComplete(function(_, result, name)
		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if map_name:lower():find(name, 1, true) then
				table.insert(result, map_name)
			end
		end
	end)
:End()

--addons/sam-159/lua/sam/sh_restrictions.lua:
return gluapack()()
--addons/sui/lua/sui/libs/tdlib/cl_tdlib.lua:
--[[
	Three's Derma Lib
	Made by Threebow

	You are free to use this anywhere you like, or sell any addons
	made using this, as long as I am properly accredited.
]]

local pairs = pairs
local ipairs = ipairs
local Color = Color
local render = render
local SysTime = SysTime
local Lerp, RealFrameTime = Lerp, RealFrameTime
local RoundedBox, RoundedBoxEx, NoTexture = draw.RoundedBox, draw.RoundedBoxEx, draw.NoTexture
local SetDrawColor, DrawRect = surface.SetDrawColor, surface.DrawRect
local DrawPoly = surface.DrawPoly
local sui = sui

local Panel = FindMetaTable("Panel")

--[[
	Constants
]]
local BLUR = CreateMaterial("SUI.TDLib.Blur", "gmodscreenspace", {
	["$basetexture"] = "_rt_fullframefb",
	["$blur"] = (1 / 3) * 7,
})

local COL_WHITE_1 = Color(255, 255, 255)
local COL_WHITE_2 = Color(255, 255, 255, 30)

--[[
	credits to http://slabode.exofire.net/circle_draw.shtml
]]
local calculate_circle do
	local cos = math.cos
	local sin = math.sin
	local round = math.Round
	local sqrt = math.sqrt
	local pi = math.pi
	calculate_circle = function(circle, x_centre, y_centre, r)
		if circle.x == x_centre and circle.y == y_centre and circle.r == r then return end

		local step = (2 * pi) / round(6 * sqrt(r))

		local i = 0
		for theta = 2 * pi, 0, -step do
			local x = x_centre + r * cos(theta)
			local y = y_centre - r * sin(theta)
			i = i + 1
			circle[i] = {
				x = x,
				y = y
			}
		end

		for i = i + 1, #circle do
			circle[i] = nil
		end

		circle.x = x_centre
		circle.y = y_centre
		circle.r = r
	end
end

--[[
void DrawArc(float cx, float cy, float r, float start_angle, float arc_angle, int num_segments)
{
	float theta = arc_angle / float(num_segments - 1);//theta is now calculated from the arc angle instead, the - 1 bit comes from the fact that the arc is open

	float tangetial_factor = tanf(theta);

	float radial_factor = cosf(theta);


	float x = r * cosf(start_angle);//we now start at the start angle
	float y = r * sinf(start_angle);

	glBegin(GL_LINE_STRIP);//since the arc is not a closed curve, this is a strip now
	for(int ii = 0; ii < num_segments; ii++)
	{
		glVertex2f(x + cx, y + cy);

		float tx = -y;
		float ty = x;

		x += tx * tangetial_factor;
		y += ty * tangetial_factor;

		x *= radial_factor;
		y *= radial_factor;
	}
	glEnd();
}
]]

local copy_color = function(color)
	return Color(color.r, color.g, color.b, color.a)
end

local color_alpha = function(color, a)
	color.a = a
	return color
end

--[[
	Collection of various utilities
]]

local TDLibUtil = {}

function TDLibUtil.DrawCircle(circle, x, y, r, color)
	calculate_circle(circle, x, y, r)

	SetDrawColor(color)
	NoTexture()
	DrawPoly(circle)
end
local DrawCircle = TDLibUtil.DrawCircle

do
	local SetMaterial = surface.SetMaterial
	local UpdateScreenEffectTexture, DrawTexturedRect, SetScissorRect = render.UpdateScreenEffectTexture, surface.DrawTexturedRect, render.SetScissorRect

	local scrW, scrH = ScrW(), ScrH()
	hook.Add("OnScreenSizeChanged", "SUI.TDLib", function()
		scrW, scrH = ScrW(), ScrH()
	end)

	function TDLibUtil.BlurPanel(s)
		local x, y = s:LocalToScreen(0, 0)

		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		for i = 1, 2 do
			UpdateScreenEffectTexture()
			DrawTexturedRect(x * -1, y * -1, scrW, scrH)
		end
	end

	function TDLibUtil.DrawBlur(x, y, w, h)
		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		SetScissorRect(x, y, x + w, y + h, true)
			for i = 1, 2 do
				UpdateScreenEffectTexture()
				DrawTexturedRect(-1, -1, scrW, scrH)
			end
		SetScissorRect(0, 0, 0, 0, false)
	end
end

local LibClasses = {}

do
	local on_funcs = {}

	function LibClasses:On(name, func)
		local old_func = self[name]

		if not old_func then
			self[name] = func
			return self
		end

		local name_2 = name .. "_funcs"

		-- we gotta avoid creating 13535035 closures
		if not on_funcs[name] then
			on_funcs[name] = function(s, a1, a2, a3, a4)
				local funcs = s[name_2]
				local i, n = 0, #funcs
				::loop::
				i = i + 1
				if i <= n then
					funcs[i](s, a1, a2, a3, a4)
					goto loop
				end
			end
		end

		if not self[name_2] then
			self[name] = on_funcs[name]
			self[name_2] = {
				old_func,
				func
			}
		else
			table.insert(self[name_2], func)
		end

		return self
	end
end

do
	local UnPredictedCurTime = UnPredictedCurTime

	local transition_func = function(s)
		local transitions = s.transitions
		local i, n = 0, #transitions
		::loop::
		i = i + 1

		if i <= n then
			local v = transitions[i]
			local name = v.name
			local v2 = s[name]
			if v.func(s) then
				if v.start_0 then
					v.start_1, v.start_0 = UnPredictedCurTime(), nil
				end

				if v2 ~= 1 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_1) / v.time, v2, 1)
				end
			else
				if v.start_1 then
					v.start_0, v.start_1 = UnPredictedCurTime(), nil
				end

				if v2 ~= 0 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_0) / v.time, v2, 0)
				end
			end

			goto loop
		end
	end

	function LibClasses:SetupTransition(name, time, func)
		self[name] = 0

		local transition = {
			name = name,
			time = time,
			func = func,
			start_0 = 0,
			start_1 = 0,
		}

		if self.transitions then
			for k, v in ipairs(self.transitions) do
				if v.name == name then
					self.transitions[k] = transition
					return self
				end
			end
			table.insert(self.transitions, transition)
		else
			self.transitions = {transition}
			self:On("Think", transition_func)
		end

		return self
	end
end

function LibClasses:ClearPaint()
	self.Paint = nil
	self.Paint_funcs = nil
	local SetPaintBackgroundEnabled = self.SetPaintBackgroundEnabled
	if SetPaintBackgroundEnabled then
		SetPaintBackgroundEnabled(self, false)
	end
	return self
end

function LibClasses:RoundedBox(id, r, x, y, w, h, c)
	self.colors = self.colors or {}
	local colors = self.colors

	local id_c = colors[id]
	if not id_c then
		id_c = Color(c:Unpack())
		colors[id] = id_c
	end

	sui.lerp_color(id_c, c)
	RoundedBox(r, x, y, w, h, id_c)
end

do
	local SetFGColor = Panel.SetFGColor

	local set_color = function(s, col)
		s.m_colText = col
		SetFGColor(s, col.r, col.g, col.b, col.a)
	end

	local paint = function(s)
		local col = s.sui_textcolor
		sui.lerp_color(col, s.new_col)
		set_color(s, col)
	end

	function LibClasses:TextColor(c, use_paint)
		local col = self.sui_textcolor
		if not col then
			col = Color(c:Unpack())
			self.sui_textcolor = col

			if use_paint then
				self:On("Paint", paint)
			end
		end

		if use_paint then
			self.new_col = c
		else
			sui.lerp_color(col, c)
			self:SetTextColor(col)
		end
	end
end

do
	local fade_hover_Paint = function(s, w, h)
		if s.FadeHovers ~= 0 then
			color_alpha(s.fadehover_color, s.fadehover_old_alpha * s.FadeHovers)
			if s.fadehover_radius > 0 then
				RoundedBox(s.fadehover_radius, 0, 0, w, h, s.fadehover_color)
			else
				SetDrawColor(s.fadehover_color)
				DrawRect(0, 0, w, h)
			end
		end
	end

	function LibClasses:FadeHover(color, time, radius, func)
		color = copy_color(color or COL_WHITE_2)
		self.fadehover_color = color
		self.fadehover_radius = radius or 0
		self.fadehover_old_alpha = color.a
		self:SetupTransition("FadeHovers", time or 0.8, func or TDLibUtil.HoverFunc)
		self:On("Paint", fade_hover_Paint)
		return self
	end
end

function LibClasses:BarHover(color, height, time)
	color = color or COL_WHITE_1
	height = height or 2
	time = time or 1.6
	self:SetupTransition("BarHovers", time, TDLibUtil.HoverFunc)
	self:On("Paint", function(s, w, h)
		if s.BarHovers ~= 0 then
			local bar = Round(w * s.BarHovers)
			SetDrawColor(color)
			DrawRect((w / 2) - (bar / 2), h - height, bar, height)
		end
	end)
	return self
end

do
	local paint = function(s, w, h)
		draw.RoundedBox(0, 0, 0, w, h, s.SUI_GetColor("line"))
	end

	function LibClasses:Line(dock, m1, m2, m3, m4)
		self.making_line = true

		local line = self:Add("SAM.Panel")
		line:Dock(dock or TOP)

		if self.line_margin then
			line:DockMargin(unpack(self.line_margin))
		else
			line:DockMargin(m1 or 0, m2 or 0, m3 or 0, m4 or 10)
		end

		line.no_scale = true
		line:SetTall(1)
		line.Paint = paint

		self.making_line = false
		return line
	end

	function LibClasses:LineMargin(m1, m2, m3, m4)
		self.line_margin = {m1 or 0, m2 or 0, m3 or 0, m4 or 0}
		return self
	end
end

do
	local background_Paint_1 = function(s)
		s:SetBGColor(s.background_color)
	end

	local background_Paint_2 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, true, true, true, true)
	end

	local background_Paint_3 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, s.background_r_tl, s.background_r_tr, s.background_r_bl, s.background_r_br)
	end

	function LibClasses:Background(color, radius, r_tl, r_tr, r_bl, r_br)
		self.background_color = color
		if isnumber(radius) and radius ~= 0 then
			self.background_radius = radius
			if isbool(r_tl) or isbool(r_tr) or isbool(r_bl) or isbool(r_br) then
				self.background_r_tl = r_tl
				self.background_r_tr = r_tr
				self.background_r_bl = r_bl
				self.background_r_br = r_br
				self:On("Paint", background_Paint_3)
			else
				self:On("Paint", background_Paint_2)
			end
		else
			self:SetPaintBackgroundEnabled(true)
			self:On("ApplySchemeSettings", background_Paint_1)
			self:On("PerformLayout", background_Paint_1)
		end
		return self
	end
end

function LibClasses:CircleClick(color, speed, target_radius)
	self.circle_click_color = color or COL_WHITE_2

	speed = speed or 5
	target_radius = isnumber(target_radius) and target_radius or false

	local radius, alpha, click_x, click_y = 0, -1, 0, 0
	local circle = {}
	self:On("Paint", function(s, w)
		if alpha >= 0 then
			DrawCircle(circle, click_x, click_y, radius, ColorAlpha(self.circle_click_color, alpha))
			local frame_time = RealFrameTime()
			radius, alpha = Lerp(frame_time * speed, radius, target_radius or w), Lerp(frame_time * speed, alpha, -1)
		end
	end)
	self:On("DoClick", function()
		click_x, click_y = self:CursorPos()
		radius, alpha = 0, self.circle_click_color.a
	end)
	return self
end

do
	local min = math.min
	function LibClasses:CircleClick2(color, speed, target_radius, start_radius)
		color = color or COL_WHITE_2
		local _color = Color(color:Unpack())

		speed = speed or 5
		target_radius = isnumber(target_radius) and target_radius or false

		local radius, alpha = 0, -1
		local circle = {}
		self:On("Paint", function(s, w, h)
			if alpha >= 0 then
				_color.a = alpha
				DrawCircle(circle, w / 2, h / 2, radius, _color)

				local frame_time = RealFrameTime()
				radius, alpha = Lerp(frame_time * speed, radius, target_radius or min(w, h) / 2), Lerp(frame_time * speed, alpha, -1)
			end
		end)

		self:On("DoClick", function()
			radius, alpha = start_radius or 0, color.a
		end)

		return self
	end
end

-- https://github.com/Facepunch/garrysmod/pull/1520#issuecomment-410458090
function LibClasses:Outline(color, width)
	color = color or COL_WHITE_1
	width = width or 1
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, w, width)
		DrawRect(0, h - width, w, width)
		DrawRect(0, width, width, h - (width * 2))
		DrawRect(w - width, width, width, h - (width * 2))
	end)
	return self
end

function LibClasses:LinedCorners(color, len)
	color = color or COL_WHITE_1
	len = len or 15
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, len, 1)
		DrawRect(0, 1, 1, len - 1)
		DrawRect(w - len, h - 1, len, 1)
		DrawRect(w - 1, h - len, 1, len - 1)
	end)
	return self
end

function LibClasses:SideBlock(color, size, side)
	color = color or COL_WHITE_1
	size = size or 3
	side = side or LEFT
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		if side == LEFT then
			DrawRect(0, 0, size, h)
		elseif side == TOP then
			DrawRect(0, 0, w, size)
		elseif size == RIGHT then
			DrawRect(w - size, 0, size, h)
		elseif side == BOTTOM then
			DrawRect(0, h - size, w, size)
		end
	end)
	return self
end

function LibClasses:Blur()
	self:On("Paint", TDLibUtil.BlurPanel)
	return self
end

do
	local STENCILOPERATION_REPLACE = STENCILOPERATION_REPLACE
	local STENCILOPERATION_ZERO = STENCILOPERATION_ZERO
	local STENCILCOMPARISONFUNCTION_NEVER = STENCILCOMPARISONFUNCTION_NEVER
	local STENCILCOMPARISONFUNCTION_EQUAL = STENCILCOMPARISONFUNCTION_EQUAL

	local ClearStencil = render.ClearStencil
	local SetStencilEnable = render.SetStencilEnable
	local SetStencilWriteMask = render.SetStencilWriteMask
	local SetStencilTestMask = render.SetStencilTestMask
	local SetStencilFailOperation = render.SetStencilFailOperation
	local SetStencilPassOperation = render.SetStencilPassOperation
	local SetStencilZFailOperation = render.SetStencilZFailOperation
	local SetStencilCompareFunction = render.SetStencilCompareFunction
	local SetStencilReferenceValue = render.SetStencilReferenceValue

	local color_white = color_white

	local avatar_setplayer = function(s, ply, size)
		s.avatar:SetPlayer(ply, size)
	end

	local avatar_setsteamid = function(s, steamid, size)
		s.avatar:SetSteamID(steamid, size)
	end

	function LibClasses:CircleAvatar()
		local avatar = self:Add("AvatarImage")
		avatar:Dock(FILL)
		avatar:SetPaintedManually(true)
		self.avatar = avatar
		self.SetSteamID = avatar_setsteamid
		self.SetPlayer = avatar_setplayer

		local circle = {}
		local PaintManual = avatar.PaintManual
		self.Paint = function(s, w, h)
			ClearStencil()
			SetStencilEnable(true)

			SetStencilWriteMask(1)
			SetStencilTestMask(1)

			SetStencilFailOperation(STENCILOPERATION_REPLACE)
			SetStencilPassOperation(STENCILOPERATION_ZERO)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
			SetStencilReferenceValue(1)

			local a = w / 2
			DrawCircle(circle, a, a, a, color_white)

			SetStencilFailOperation(STENCILOPERATION_ZERO)
			SetStencilPassOperation(STENCILOPERATION_REPLACE)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
			SetStencilReferenceValue(1)

			PaintManual(avatar)

			SetStencilEnable(false)
		end
		return self
	end
end

do
	function LibClasses:AnimationThinkInternal()
		local systime = SysTime()

		if self.Term and self.Term <= systime then
			self:Remove()

			return
		end

		local m_AnimList = self.m_AnimList
		if not m_AnimList then return end

		for i = #m_AnimList, 1, -1 do
			local anim = m_AnimList[i]
			if systime >= anim.StartTime then
				local frac = math.TimeFraction(anim.StartTime, anim.EndTime, systime)
				frac = math.Clamp(frac, 0, 1)

				local Think = anim.Think
				if Think then
					Think(anim, self, frac ^ (1.0 - (frac - 0.5)))
				end

				if frac == 1 then
					local OnEnd = anim.OnEnd
					if OnEnd then
						OnEnd(anim, self)
					end

					m_AnimList[i] = nil
				end
			end
		end
	end

	local sort = function(a, b)
		return a.EndTime > b.EndTime
	end

	function LibClasses:NewAnimation(length, delay, ease, callback)
		delay = delay or 0
		ease = ease or -1

		if self.m_AnimQueue then
			delay = delay + self:AnimTail()
			self.m_AnimQueue = false
		else
			delay = delay + SysTime()
		end

		local anim = {
			StartTime = delay,
			EndTime = delay + length,
			Ease = ease,
			OnEnd = callback
		}

		self:SetAnimationEnabled(true)

		if self.m_AnimList == nil then
			self.m_AnimList = {}
		end

		table.insert(self.m_AnimList, anim)
		table.sort(self.m_AnimList, sort)

		self.AnimationThink = self.AnimationThinkInternal

		return anim
	end

	local MoveThink = function(anim, panel, frac)
		if not anim.startx then
			anim.startx = panel.x
			anim.starty = panel.y
		end

		local x = Lerp(frac, anim.startx, anim.x)
		local y = Lerp(frac, anim.starty, anim.y)
		panel:SetPos(x, y)
	end

	function LibClasses:MoveTo(x, y, length, delay, ease, callback)
		if self.x == x and self.y == y then return end

		local anim = self:NewAnimation(length, delay, ease, callback)
		anim.x = x
		anim.y = y
		anim.Think = MoveThink
	end

	local SetSize = Panel.SetSize
	local SizeThink = function(anim, panel, frac)
		if not anim.startw then
			anim.startw, anim.starth = panel:GetSize()
		end

		local w, h
		if anim.sizew and anim.sizeh then
			w = Lerp(frac, anim.startw, anim.w)
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, w, h)
		elseif anim.sizew then
			w = Lerp(frac, anim.startw, anim.w)
			SetSize(panel, w, panel.starth)
		else
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, panel.startw, h)
		end

		if panel:GetDock() > 0 then
			panel:InvalidateParent()
		end
	end

	function LibClasses:SizeTo(w, h, length, delay, ease, callback)
		local anim = self:NewAnimation(length, delay, ease, callback)

		if w ~= -1 then
			anim.sizew = true
		end

		if h ~= -1 then
			anim.sizeh = true
		end

		anim.w, anim.h = w, h
		anim.Think = SizeThink

		return anim
	end

	local SetVisible = Panel.SetVisible
	local IsVisible = Panel.IsVisible

	local is_visible = function(s)
		local state = s.visible_state
		if state ~= nil then
			return state
		else
			return IsVisible(s)
		end
	end

	function LibClasses:AnimatedSetVisible(visible, cb)
		if visible == is_visible(self) then
			if cb then
				cb()
			end
			return
		end

		if visible then
			SetVisible(self, true)
		end

		self.visible_state = visible
		self:Stop()

		self:AlphaTo(visible and 255 or 0, 0.2, 0, function()
			SetVisible(self, visible)
			self:InvalidateParent(true)
			if cb then
				cb()
			end
		end)

		self:InvalidateParent(true)
	end

	function LibClasses:AnimatedToggleVisible()
		self:AnimatedSetVisible(not is_visible(self))
	end

	function LibClasses:AnimatedIsVisible()
		return is_visible(self)
	end
end

function Panel:SUI_TDLib()
	for k, v in pairs(LibClasses) do
		self[k] = v
	end
	return self
end

TDLibUtil.Install = Panel.SUI_TDLib

local count = 0
TDLibUtil.Start = function()
	count = count + 1
	for k, v in pairs(LibClasses) do
		if not Panel["SUI_OLD" .. k] then
			local old = Panel[k]
			if old == nil then
				old = v
			end
			Panel[k], Panel["SUI_OLD" .. k] = v, old
		end
	end
end

TDLibUtil.End = function()
	count = count - 1
	if count > 0 then return end
	for k, v in pairs(LibClasses) do
		local old = Panel["SUI_OLD" .. k]
		if old == v then
			Panel[k] = nil
		else
			Panel[k] = old
		end
		Panel["SUI_OLD" .. k] = nil
	end
end

TDLibUtil.HoverFunc = function(p)
	return p:IsHovered() and not p:GetDisabled()
end

TDLibUtil.DrawOutlinedBox = function(radius, x, y, w, h, bg, outline, thickness)
	thickness = thickness or 2
	draw.RoundedBox(radius, x, y, w, h, outline)
	draw.RoundedBox(radius, x + thickness, y + thickness, w - (thickness * 2), h - (thickness * 2), bg)
end

do
	local cos, sin, sqrt = math.cos, math.sin, math.sqrt
	local clamp, floor = math.Clamp, math.floor
	local min, max = math.min, math.max

	local calc_ellipse_points = function(rx, ry)
		local points = sqrt(((rx * ry) / 2) * 6)
		return max(points, 8)
	end

	local M_PI = 3.14159265358979323846
	calc_rect = function(c, r, x, y, w, h)
		if
			(c.r == r) and
			(c.x == x and c.y == y) and
			(c.w == w and c.h == h)
		then return end

		r = clamp(r, 0, min(w, h) / 2)

		local rx, ry = r, r
		if w >= 0.02 then
			rx = min(rx, w / 2.0 - 0.01)
		end
		if h >= 0.02 then
			ry = min(ry, h / 2.0 - 0.01)
		end

		local points = max(calc_ellipse_points(rx, ry) / 4, 1)
		points = floor(points)

		local half_pi = M_PI / 2
		local angle_shift = half_pi / (points + 1)

		local phi = 0
		for i = 1, points + 2 do
			c[i] = {
				x = x + rx * (1 - cos(phi)),
				y = y + ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = half_pi
		for i = points + 3, 2 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y +     ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 2 * half_pi
		for i = (2 * (points + 2)) + 1, 3 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 3 * half_pi
		for i = (3 * (points + 2)) + 1, 4 * (points + 2) do
			c[i] = {
				x = x +     rx * (1 - cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		local last = (points + 2) * 4 + 1
		c[last] = c[1]

		for i = last + 1, #c do
			c[i] = nil
		end

		c.r = r
		c.x, c.y = x, y
		c.w, c.h = w, h
	end

	TDLibUtil.RoundedBox = function(c, r, x, y, w, h, color)
		calc_rect(c, r, x, y, w, h)

		SetDrawColor(color)
		NoTexture()
		DrawPoly(c)
	end
end

TDLibUtil.LibClasses = LibClasses

sui.TDLib = TDLibUtil
--addons/sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--addons/sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")

--addons/sam-159/lua/sam/menu/tabs/players.lua:
return gluapack()()
--addons/sam-159/lua/sam/modules/fun.lua:
return gluapack()()
--addons/sam-159/lua/sam/modules/teleport.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Teleport")

local find_empty_pos -- https://github.com/FPtje/DarkRP/blob/b147d6fa32799136665a9fd52d35c2fe87cf7f78/gamemode/modules/base/sv_util.lua#L149
do
	local is_empty = function(vector, ignore)
		local point = util.PointContents(vector)
		local a = point ~= CONTENTS_SOLID
			and point ~= CONTENTS_MOVEABLE
			and point ~= CONTENTS_LADDER
			and point ~= CONTENTS_PLAYERCLIP
			and point ~= CONTENTS_MONSTERCLIP
		if not a then return false end

		local ents_found = ents.FindInSphere(vector, 35)
		for i = 1, #ents_found do
			local v = ents_found[i]
			if (v:IsNPC() or v:IsPlayer() or v:GetClass() == "prop_physics" or v.NotEmptyPos) and v ~= ignore then
				return false
			end
		end

		return true
	end

	local distance, step, area = 600, 30, Vector(16, 16, 64)
	local north_vec, east_vec, up_vec = Vector(0, 0, 0), Vector(0, 0, 0), Vector(0, 0, 0)

	find_empty_pos = function(pos, ignore)
		if is_empty(pos, ignore) and is_empty(pos + area, ignore) then
			return pos
		end

		for j = step, distance, step do
			for i = -1, 1, 2 do
				local k = j * i

				-- North/South
				north_vec.x = k
				if is_empty(pos + north_vec, ignore) and is_empty(pos + north_vec + area, ignore) then
					return pos + north_vec
				end

				-- East/West
				east_vec.y = k
				if is_empty(pos + east_vec, ignore) and is_empty(pos + east_vec + area, ignore) then
					return pos + east_vec
				end

				-- Up/Down
				up_vec.z = k
				if is_empty(pos + up_vec, ignore) and is_empty(pos + up_vec + area, ignore) then
					return pos + up_vec
				end
			end
		end

		return pos
	end
end

command.new("bring")
	:DisallowConsole()
	:SetPermission("bring", "admin")

	:AddArg("player", {cant_target_self = true})

	:Help("bring_help")

	:OnExecute(function(ply, targets)
		if not ply:Alive() then
			return ply:sam_send_message("dead")
		end

		if ply:InVehicle() then
			return ply:sam_send_message("leave_car")
		end

		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		local teleported = {admin = ply}
		local all = targets.input == "*"

		for i = 1, #targets do
			local target = targets[i]

			if target:sam_get_exclusive(ply) then
				if not all then
					ply:sam_send_message(target:sam_get_exclusive(ply))
				end
				continue
			end

			if not target:Alive() then
				target:Spawn()
			end

			target.sam_tele_pos, target.sam_tele_ang = target:GetPos(), target:EyeAngles()

			target:ExitVehicle()
			target:SetVelocity(Vector(0, 0, 0))
			target:SetPos(find_empty_pos(ply:GetPos(), target))
			target:SetEyeAngles((ply:EyePos() - target:EyePos()):Angle())

			table.insert(teleported, target)
		end

		if #teleported > 0 then
			sam.player.send_message(nil, "bring", {
				A = ply, T = teleported
			})
		end
	end)
:End()

command.new("goto")
	:DisallowConsole()
	:SetPermission("goto", "admin")

	:AddArg("player", {single_target = true, allow_higher_target = true, cant_target_self = true})

	:Help("goto_help")

	:OnExecute(function(ply, targets)
		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		if not ply:Alive() then
			ply:Spawn()
		end

		local target = targets[1]
		ply.sam_tele_pos, ply.sam_tele_ang = ply:GetPos(), ply:EyeAngles()

		ply:ExitVehicle()
		ply:SetVelocity(Vector(0, 0, 0))
		ply:SetPos(find_empty_pos(target:GetPos(), ply))
		ply:SetEyeAngles((target:EyePos() - ply:EyePos()):Angle())

		sam.player.send_message(nil, "goto", {
			A = ply, T = targets
		})
	end)
:End()

command.new("return")
	:SetPermission("return", "admin")

	:AddArg("player", {single_target = true, optional = true})

	:Help("return_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		local last_pos, last_ang = target.sam_tele_pos, target.sam_tele_ang
		if not last_pos then
			return sam.player.send_message(ply, "no_location", {
				T = targets
			})
		end

		if target:sam_get_exclusive(ply) then
			return ply:sam_send_message(target:sam_get_exclusive(ply))
		end

		if not target:Alive() then
			return ply:sam_send_message(target:Name() .. " is dead!")
		end

		target:ExitVehicle()
		target:SetVelocity(Vector(0, 0, 0))
		target:SetPos(last_pos)
		target:SetEyeAngles(last_ang)

		target.sam_tele_pos, target.sam_tele_ang = nil, nil

		sam.player.send_message(nil, "returned", {
			A = ply, T = targets
		})
	end)
:End()
--addons/sam-159/lua/sam/modules/util.lua:
--if SAM_LOADED then return end

sam.permissions.add("command_notify", nil, "admin")

if SERVER then
	local get_players = function()
		local players = {}
		for _, v in ipairs(player.GetAll()) do
			if v:HasPermission("command_notify") then
				table.insert(players, v)
			end
		end
		return players
	end

	sam.player.old_send_message = sam.player.old_send_message or sam.player.send_message
	function sam.player.send_message(ply, msg, tbl)
		if ply == nil and debug.traceback():find("lua/sam/command/", 1, true) then
			sam.player.old_send_message(get_players(), msg, tbl)
		else
			sam.player.old_send_message(ply, msg, tbl)
		end
	end
end

local sam, command, language = sam, sam.command, sam.language



command.set_category("Utility")

command.new("map")
	:SetPermission("map", "admin")

	:AddArg("map")
	:AddArg("text", {hint = "gamemode", optional = true})

	:Help("map_help")

	:OnExecute(function(ply, map, gamemode)
		if not gamemode then
			sam.player.send_message(nil, "map_change", {
				A = ply, V = map
			})
		else
			sam.player.send_message(nil, "map_change2", {
				A = ply, V = map, V_2 = gamemode
			})
			RunConsoleCommand("gamemode", gamemode)
		end

		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", map)
		else
			timer.Create("SAM.Command.Map", 10, 1, function()
				RunConsoleCommand("changelevel", map)
			end)
		end
	end)
:End()
/*
command.new("addlevelpuan")
	:SetPermission("addlevelpuan", "superadmin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {default = 1})

	:GetRestArgs()

	:Help("Sadece Puan Ekler")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		kamubaslat(target, length, ply, reason)
		sam.player.send_message(nil, "{A} şu oyuncuya kamu cezası verdi: {T} {V} .", {
			A = ply, T = target:Name(), V = sam.format_length(length)
		})
	end)
:End()
*/
command.new("kamuban")
	:SetPermission("kamuban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {default = 1})
	:AddArg("text", {hint = "reason", default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("KamuBan başlatır")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		kamubaslat(target, length, ply, reason)
		sam.player.send_message(nil, "{A} şu oyuncuya kamu cezası verdi: {T} {V} ({V_2}).", {
			A = ply, T = target:Name(), V = sam.format_length(length), V_2 = reason
		})
	end)
:End()

command.new("lockdownbaslat")
	:SetPermission("lockdownbaslat", "superadmin")


	:Help("lockdown başlatır")

	:OnExecute(function(ply)
		for _, v in ipairs(player.GetAll()) do
			v:ConCommand("play " .. GAMEMODE.Config.lockdownsound .. "\n")
		end
	
		DarkRP.printMessageAll(HUD_PRINTTALK, DarkRP.getPhrase("lockdown_started"))
		SetGlobalBool("DarkRP_LockDown", true)
		DarkRP.notifyAll(0, 3, DarkRP.getPhrase("lockdown_started"))
	
		hook.Run("lockdownStarted", ply)
		sam.player.send_message(nil, "Lockdown başladı.", {
		})
	end)
:End()

command.new("lockdownbitir")
	:SetPermission("lockdownbitir", "superadmin")



	:Help("lockdown bitirir")

	:OnExecute(function(ply)
		DarkRP.printMessageAll(HUD_PRINTTALK, DarkRP.getPhrase("lockdown_ended"))
		DarkRP.notifyAll(0, 3, DarkRP.getPhrase("lockdown_ended"))
		SetGlobalBool("DarkRP_LockDown", false)
	
		lastLockdown = CurTime()
	
		hook.Run("lockdownEnded", ply)
	end)
:End()

command.new("kamubanid")
	:SetPermission("kamuban", "admin")

	:AddArg("length", {default = 1})
	:AddArg("text", {hint = "steamid64", default = "steamid64"})
	:AddArg("text", {hint = "reason", default = "sebep"})
	:GetRestArgs()

	:Help("KamuBanID atar, steamid64 yazmanız lazım")

	:OnExecute(function(ply, length, steamid64, reason)
		if SERVER then 
			kamubaslatid(steamid64, length, ply, reason)
		end 
		sam.player.send_message(nil, "{A} şu {T} kişisine kamu cezası verdi {V_2} sebebiyle: {V} tane iş", {
			A = ply, T = steamid64, V_2 = reason, V = length
		})
	end)
:End()


command.new("unkamuban")
	:SetPermission("unkamuban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("KamuBan kaldırır")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		kamubitir(target, ply, reason)
		sam.player.send_message(nil, "{A} şu oyuncuya kamu kaldırdı: {T} for ({V_2}).", {
			A = ply, T = target:Name(),  V_2 = reason
		})
	end)
:End()

command.new("kamucheck")
	:SetPermission("kamucheck", "admin")

	:AddArg("player", {single_target = true})

	:GetRestArgs()

	:Help("KamuBan süresini gösterir")

	:OnExecute(function(ply, targets)
		local target = targets[1]
		ply:ChatPrint(target:GetNWInt("kamucezasikalan", 0).." tane kamu işi var")
	end)
:End()

command.new("maprestart")
	:SetPermission("maprestart", "admin")

	:Help("map_restart_help")

	:OnExecute(function(ply)
		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", game.GetMap())
		else
			timer.Create("SAM.Command.MapRestart", 10, 1, function()
				RunConsoleCommand("changelevel", game.GetMap())
			end)

			sam.player.send_message(nil, "map_restart", {
				A = ply
			})
		end
	end)
:End()

command.new("xpboost")
	:SetPermission("xpboost", "superadmin")

	:Help("2 Kat XP Boost Modulünü Açar")

	:OnExecute(function(ply)
		SetGlobalBool("xpboost", true)
	end)
:End()

command.new("printerboost")
	:SetPermission("printerboost", "superadmin")

	:Help("2 Kat XP Boost Modulünü Açar")

	:OnExecute(function(ply)
		SetGlobalBool("printerboost", true)
	end)
:End()

command.new("meslekboost")
	:SetPermission("meslekboost", "superadmin")

	:Help("2 Kat Meslek Boost Modulünü Açar")

	:OnExecute(function(ply)
		SetGlobalBool("meslekboost", true)
	end)
:End()

command.new("xpboostkapat")
	:SetPermission("xpboostkapat", "superadmin")

	:Help("2 Kat XP Boost Modulünü Kapatır")

	:OnExecute(function(ply)
		SetGlobalBool("xpboost", false)
	end)
:End()

command.new("printerboostkapat")
	:SetPermission("xpboost", "superadmin")

	:Help("2 Kat XP Boost Modulünü Kapatır")

	:OnExecute(function(ply)
		SetGlobalBool("printerboost", false)
	end)
:End()

command.new("meslekboostkapat")
	:SetPermission("meslekboost", "superadmin")

	:Help("2 Kat Meslek Boost Modulünü Kapatır")

	:OnExecute(function(ply)
		SetGlobalBool("meslekboost", false)
	end)
:End()

command.new("mapreset")
	:SetPermission("mapreset", "admin")

	:Help("mapreset_help")

	:OnExecute(function(ply)
		game.CleanUpMap(false, nil, function() end)

		sam.player.send_message(nil, "mapreset", {
			A = ply
		})
	end)
:End()

command.new("kick")
	:SetPermission("kick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("kick_help")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		target:Kick(reason)

		sam.player.send_message(nil, "kick", {
			A = ply, T = target:Name(), V = reason
		})
	end)
:End()

command.new("ban")
	:SetPermission("ban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("ban_help")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		if ply:GetBanLimit() ~= 0 then
			if length == 0 then
				length = ply:GetBanLimit()
			else
				length = math.Clamp(length, 1, ply:GetBanLimit())
			end
		end
		target:sam_ban(length, reason, ply:SteamID())

		sam.player.send_message(nil, "ban", {
			A = ply, T = target:Name(), V = sam.format_length(length), V_2 = reason
		})
	end)
:End()

command.new("banid")
	:SetPermission("banid", "admin")

	:AddArg("steamid")
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("banid_help")

	:OnExecute(function(ply, promise, length, reason)
		local a_steamid, a_name, a_ban_limit = ply:SteamID(), ply:Name(), ply:GetBanLimit()

		promise:done(function(data)
			local steamid, target = data[1], data[2]

			if a_ban_limit ~= 0 then
				if length == 0 then
					length = a_ban_limit
				else
					length = math.Clamp(length, 1, a_ban_limit)
				end
			end

			if target then
				target:sam_ban(length, reason, a_steamid)

				sam.player.send_message(nil, "ban", {
					A = a_name, T = target:Name(), V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.ban_id(steamid, length, reason, a_steamid)

				sam.player.send_message(nil, "banid", {
					A = a_name, T = steamid, V = sam.format_length(length), V_2 = reason
				})
			end
		end)
	end)
:End()

command.new("unban")
	:SetPermission("unban", "admin")

	:AddArg("steamid", {allow_higher_target = true})

	:Help("unban_help")

	:OnExecute(function(ply, steamid, reason)
		sam.player.unban(steamid, ply:SteamID())

		sam.player.send_message(nil, "unban", {
			A = ply, T = steamid
		})
	end)
:End()



do
	local config = sam.config

	sam.permissions.add("can_physgun_players", nil, "admin")

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Physgun", function(body)
			local setting_body

			do
				local p = add_setting(body, "Physgun (Enable/Disable all physgun features except picking up players)", "Physgun.Enabled")
				p:DockMargin(8, 6, 8, 0)
			end

			setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "No fall damage on drop", "Physgun.NoFallDamageOnDrop")
			add_setting(setting_body, "Right click to freeze players", "Physgun.RightClickToFreeze")
			add_setting(setting_body, "Reset Velocity to fix some issues when players fall", "Physgun.ResetVelocity")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local freeze_player = function(ply)
		if SERVER then
			ply:Lock()
		end
		ply:SetMoveType(MOVETYPE_NONE)
		ply:SetCollisionGroup(COLLISION_GROUP_WORLD)
	end

	sam.hook_first("PhysgunPickup", "SAM.CanPhysgunPlayer", function(ply, target)
		if sam.type(target) == "Player" and ply:HasPermission("can_physgun_players") and ply:CanTarget(target) then
			freeze_player(target)
			return true
		end
	end)

	local load_phygun_settings = function()
		hook.Remove("PhysgunDrop", "SAM.PhysgunDrop")
		hook.Remove("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround")

		if config.get("Physgun.Enabled", true) == false then
			-- add a hook to unlock the player if the physgun is disabled and other stuff
			hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
				if sam.type(target) == "Player" then
					target:SetMoveType(MOVETYPE_WALK)
					target:SetCollisionGroup(COLLISION_GROUP_PLAYER)

					if SERVER then
						target:UnLock()
						if target.sam_has_god_mode then
							target:GodEnable()
						end
					end
				end
			end)
			return
		end

		local right_click_to_freeze = config.get("Physgun.RightClickToFreeze", true)
		local reset_velocity = config.get("Physgun.ResetVelocity", true)
		hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
			if sam.type(target) ~= "Player" then return end

			if right_click_to_freeze and ply:KeyPressed(IN_ATTACK2) then
				freeze_player(target)

				if SERVER then
					target:sam_set_nwvar("frozen", true)
					target:sam_set_exclusive("frozen")
				end
			else
				if reset_velocity then
					target:SetLocalVelocity(Vector(0, 0, 0))
				end

				if SERVER then
					target:UnLock()
					target:sam_set_nwvar("frozen", false)
					target:sam_set_exclusive(nil)

					if target.sam_has_god_mode then
						target:GodEnable()
					end

					target.sam_physgun_drop_was_frozen = not target:IsOnGround()
				end

				target:SetMoveType(MOVETYPE_WALK)
				target:SetCollisionGroup(COLLISION_GROUP_PLAYER)
			end
		end)

		if config.get("Physgun.NoFallDamageOnDrop", true) then
			hook.Add("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround", function(ply)
				if ply.sam_physgun_drop_was_frozen then
					ply.sam_physgun_drop_was_frozen = false
					return true
				end
			end)
		end
	end

	config.hook({"Physgun.Enabled", "Physgun.RightClickToFreeze", "Physgun.ResetVelocity", "Physgun.NoFallDamageOnDrop"}, load_phygun_settings)
end

do
	command.new("cleardecals")
		:SetPermission("cleardecals", "admin")
		:Help("cleardecals_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "cleardecals")

			sam.player.send_message(nil, "cleardecals", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("cleardecals", function()
			game.RemoveRagdolls()
			RunConsoleCommand("r_cleardecals")
		end)
	end
end

do
	command.new("stopsound")
		:SetPermission("stopsound", "admin")
		:Help("stopsound_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "stopsound")

			sam.player.send_message(nil, "stopsound", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("stopsound", function()
			RunConsoleCommand("stopsound")
		end)
	end
end

command.new("exit")
	:SetPermission("exit_vehicle", "admin")

	:AddArg("player", {single_target = true})

	:Help("exit_vehicle_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		if not target:InVehicle() then
			if ply == target then
				return ply:sam_send_message("not_in_vehicle")
			else
				return ply:sam_send_message("not_in_vehicle2", {
					S = target:Name()
				})
			end
		end

		target:ExitVehicle()

		sam.player.send_message(nil, "exit_vehicle", {
			A = ply, T = targets
		})
	end)
:End()

command.new("time")
	:SetPermission("time", "user")

	:AddArg("player", {single_target = true, optional = true})

	:Help("time_help")

	:OnExecute(function(ply, targets)
		if ply == targets[1] then
			sam.player.send_message(ply, "time_your", {
				V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		else
			sam.player.send_message(ply, "time_player", {
				T = targets, V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		end
	end)
:End()

command.new("admin")
	:SetPermission("admin_mode", "admin")

	:Help("admin_help")

	:OnExecute(function(ply)
		ply:sam_cloak()
		ply:GodEnable()
		ply:SetMoveType(MOVETYPE_NOCLIP)
	end)
:End()

command.new("unadmin")
	:SetPermission("admin_mode", "admin")

	:Help("unadmin_help")

	:OnExecute(function(ply)
		ply:sam_uncloak()
		ply:GodDisable()
		ply:SetMoveType(MOVETYPE_WALK)
	end)
:End()

do
	command.new("buddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("buddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = true
			end

			sam.player.send_message(nil, "buddha", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unbuddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("unbuddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = nil
			end

			sam.player.send_message(nil, "unbuddha", {
				A = ply, T = targets
			})
		end)
	:End()
end

command.new("give")
	:SetPermission("give", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "weapon/entity"})

	:Help("give_help")

	:OnExecute(function(ply, targets, weapon)
		for i = 1, #targets do
			targets[i]:Give(weapon)
		end

		sam.player.send_message(nil, "give", {
			A = ply, T = targets, V = weapon
		})
	end)
:End()
command.new("noclip")
:SetPermission("noclip", "admin")

:AddArg("player", {optional = true})

:Help("noclip_help")

:OnExecute(function(ply, targets)
	local id
	for i = 1, #targets do
		local v = targets[i]
		v:SetMoveType(v:GetMoveType() == MOVETYPE_WALK and MOVETYPE_NOCLIP or MOVETYPE_WALK)
		if v == ply then
			id = i
		end
	end

	if id then
		table.remove(targets, id)
		if #targets == 0 then return end
	end

	sam.player.send_message(nil, "noclip", {
		A = ply, T = targets
	})
end)
:End()

sam.permissions.add("can_noclip", nil, "admin")
local yetkigrup = {
	["rehber4"] = true,
	["rehber3"] = true,
	["rehber2"] = true,
	["rehber"] = true,
	["denemerehber"] = true,
}
hook.Add("PlayerNoClip", "SAM.CanNoClip", function(ply, durum)

if ply:HasPermission("can_noclip") then

	if durum == true then 
		if SERVER then 
		if yetkigrup[ply:GetUserGroup()] and team.GetName(ply:Team()) != "Yetkili Görevde" then 
		else 
		ply:sam_cloak()
		end 
		end 
	end 

	if durum == false then 
		if SERVER then 
			if yetkigrup[ply:GetUserGroup()] and team.GetName(ply:Team()) != "Yetkili Görevde" then 
			else 
		ply:sam_uncloak()
			end 
		end
	end 
	
	if yetkigrup[ply:GetUserGroup()] and team.GetName(ply:Team()) != "Yetkili Görevde" then 
	else 
	return true
	end 
end

end)

-- do
-- 	if CLIENT then
-- 		sam.netstream.Hook("GetFriends", function()
-- 			local friends = {}
-- 			local humans = player.GetHumans()
-- 			for i = 1, #humans do
-- 				local human = humans[i]
-- 				if human:GetFriendStatus() == "friend" then
-- 					table.insert(friends, human)
-- 				end
-- 			end
-- 			netstream.Start("GetFriends", friends)
-- 		end)
-- 	else
-- 		hook.Add("SAM.AuthedPlayer", "GetPlayerFriends", function(ply)
-- 			timer.Simple(0, function()
-- 				ply.sam_requesting_friends = true
-- 				netstream.Start(ply, "GetFriends")
-- 			end)
-- 		end)

-- 		local invalid_friends = function(ply, friends, new_list)
-- 			if not sam.istable(friends) then return true end

-- 			local count = #friends
-- 			local max_players = game.MaxPlayers()
-- 			for k, friend in pairs(friends) do
-- 				if not sam.isnumber(k) then return true end
-- 				if not sam.isentity(friend) then return true end
-- 				if k > max_players then return true end
-- 				if k > count then return true end

-- 				if IsValid(friend) then
-- 					table.insert(new_list, friend)
-- 				end
-- 			end
-- 		end

-- 		sam.netstream.Hook("GetFriends", function(ply, friends)
-- 			local new_list = {}
-- 			if invalid_friends(ply, friends, new_list) then
-- 				ply.sam_friends_invalid = true
-- 				return
-- 			end
-- 			ply.sam_friends = new_list
-- 		end, function()
-- 			return ply.sam_requesting_friends
-- 		end)
-- 	end

-- 	command.new("friends")
-- 		:SetPermission("friends", "superadmin")

-- 		:AddArg("player", {single_target = true})

-- 		:Help(language.get("friends_help"))

-- 		:OnExecute(function(ply, targets)
-- 			local target = targets[1]
-- 			target.sam_friends_requests = target.sam_friends_requests or {}
-- 			target.sam_friends_requests[ply] = true
-- 		end)
-- 	:End()
-- end

--addons/sam-159/lua/sam/reports/cl_reports.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream
local SUI = sam.SUI

local config = sam.config

local Trim = string.Trim

local muted_var = CreateClientConVar("sam_mute_reports", "0", false, false, "", 0, 1)

local position = config.get_updated("Reports.Position", "Left")
local max_reports = config.get_updated("Reports.MaxReports", 4)
local always_show = config.get_updated("Reports.AlwaysShow", true)
local pad_x = config.get_updated("Reports.XPadding", 5)
local pad_y = config.get_updated("Reports.YPadding", 5)

local duty_jobs = {}
config.hook({"Reports.DutyJobs"}, function()
	local jobs = config.get("Reports.DutyJobs", ""):Split(",")
	for i = #jobs, 1, -1 do
		local v = Trim(jobs[i])
		if v ~= "" then
			jobs[v] = true
		end
		jobs[i] = nil
	end
	duty_jobs = jobs
end)

local commands = {}
config.hook({"Reports.Commands"}, function()
	local cmds = config.get("Reports.Commands", ""):Split(",")
	for i = 1, #cmds do
		local v = Trim(cmds[i])
		if v ~= "" then
			cmds[i] = {
				name = v,
				func = function(_, ply)
					if IsValid(ply) then
						RunConsoleCommand("sam", v, "#" .. ply:EntIndex())
					end
				end
			}
		end
	end
	commands = cmds
end)

local reports = {}
local queued_reports = {}

local new_report, remove_report, check_queued, get_report, append_report

get_report = function(ply, index)
	for i = 1, #reports do
		local v = reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v end
	end

	for i = 1, #queued_reports do
		local v = queued_reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v, i end
	end
end

remove_report = function(ply)
	local report, delayed_i = get_report(ply)

	if delayed_i then
		return table.remove(queued_reports, delayed_i)
	end

	local panel = report.panel
	panel:MoveToNewX(position.value == "Right" and ScrW() or -panel:GetWide(), function()
		for i = report.pos + 1, #reports do
			local v = reports[i]
			v.pos = v.pos - 1
			v.panel:MoveToNewY(v.panel:GetY())
		end

		panel:Remove()
		table.remove(reports, report.pos)

		check_queued()
	end)
end

check_queued = function()
	while (max_reports.value - #reports > 0 and #queued_reports > 0) do
		new_report(table.remove(queued_reports, 1))
	end
end

append_report = function(ply, text)
	local report, delayed = get_report(ply)
	if delayed then
		table.insert(report.comments, text)
	else
		report.panel:AddComment(text)
	end
end

new_report = function(report)
	if #reports >= max_reports.value then
		return table.insert(queued_reports, report)
	end

	report.pos = table.insert(reports, report)

	local panel = vgui.Create("SAM.Report")
	panel:SetReport(report)

	for k, v in ipairs(commands) do
		panel:AddButton(v.name:gsub("^%l", string.upper), v.func)
	end

	local claim = panel:AddButton("Claim", function(self, ply)
		if panel:HasReport() then
			return LocalPlayer():sam_send_message("You have an active case, close it first.")
		end

		self.DoClick = function()
		end

		local claim_query = netstream.async.Start("ClaimReport", nil, ply)
		claim_query:done(function(claimed)
			if not IsValid(panel) then return end

			if claimed then
				panel:SetHasReport(ply)

				self:SetText("Close")

				self.background = Color(231, 76, 60, 200)
				self.hover = Color(255, 255, 255, 25)

				panel:FixWide()

				for k, v in ipairs(panel:GetChildren()[3]:GetChildren()) do
					v:SetDisabled(false)
					v:SetCursor("hand")
				end

				self.DoClick = function()
					panel:Close()
				end
			else
				panel:SetClaimed()
			end
		end)
	end)

	panel.claim = claim

	claim:SetCursor("hand")
	claim:SetDisabled(false)

	claim.background = Color(39, 174, 96, 200)
	claim.hover = Color(255, 255, 255, 25)

	panel:FixWide()

	local x = pad_x.value
	if position.value == "Right" then
		x = (ScrW() - panel:GetWide()) - x
	end

	panel:MoveToNewX(x)
	panel:MoveToNewY(panel:GetY())

	panel.new = true
	for k, v in ipairs(report.comments) do
		panel:AddComment(v)
	end
	panel.new = nil
end

netstream.Hook("Report", function(ply, comment)
	if not IsValid(ply) then return end

	if muted_var:GetBool() then return end

	local report = get_report(ply)
	if not report then
		report = {
			ply = ply,
			index = ply:EntIndex(),
			comments = {comment}
		}

		if not always_show.value and not duty_jobs[team.GetName(LocalPlayer():Team())] then
			LocalPlayer():sam_send_message("({S Blue}) {S_2 Red}: {S_3}", {
				S = "Report", S_2 = ply:Name(), S_3 = comment
			})
		else
			new_report(report)
		end
	else
		append_report(ply, comment)
	end
end)

netstream.Hook("ReportClaimed", function(ply)
	local report, delayed = get_report(ply)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClaimed()
	end
end)

netstream.Hook("ReportClosed", function(index)
	local report, delayed = get_report(index, true)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClosed()
	end
end)

do
	local REPORTS_HEADER = SUI.CreateFont("ReportHeader", "Roboto", 14, 540)
	local REPORT_COMMENT = SUI.CreateFont("ReportComment", "Roboto", 13, 540)
	local REPORT_BUTTONS = SUI.CreateFont("ReportButtons", "Roboto", 13, 550)

	local Panel = {}

	function Panel:Init()
		sui.TDLib.Start()

		self:Blur()
			:Background(Color(30, 30, 30, 240))

		local p_w, p_h = SUI.Scale(300), SUI.Scale(125)
		self:SetSize(p_w, p_h)

		local x = p_w * 2

		if position.value == "Right" then
			x = ScrW() + x
		else
			x = -x
		end

		self:SetPos(x, -p_h)

		local top_panel = self:Add("Panel")
		top_panel:Dock(TOP)
		top_panel:SetTall(SUI.Scale(24))
		top_panel:Background(Color(60, 60, 60, 200))

		local ply_name = top_panel:Add("DLabel")
		ply_name:Dock(LEFT)
		ply_name:DockMargin(5, 0, 0, 0)
		ply_name:SetTextColor(Color(200, 200, 200))
		ply_name:SetFont(REPORTS_HEADER)
		self.ply_name = ply_name

		local scroll = self:Add("SAM.ScrollPanel")
		scroll:Dock(FILL)
		scroll:DockMargin(5, 5, 5, 5)
		scroll.Paint = nil
		self.scroll = scroll

		local comment = scroll:Add("DLabel")
		comment:Dock(TOP)
		comment:SetText("")
		comment:SetTextColor(Color(200, 200, 200))
		comment:SetFont(REPORT_COMMENT)
		comment:SetMultiline(true)
		comment:SetWrap(true)
		comment:SetAutoStretchVertical(true)
		self.comment = comment

		local bottom = self:Add("Panel")
		bottom:Dock(BOTTOM)
		bottom:SetTall(SUI.Scale(24))
		self.bottom = bottom

		sui.TDLib.End()
	end

	function Panel:GetY()
		return (self:GetTall() + 5) * (self.report.pos - 1) + pad_y.value
	end

	function Panel:Close()
		remove_report(self.report.ply)
	end

	local change_state = function(self, text)
		self.claim:SetText(text)
		self.claim.DoClick = function() end

		self.claim:SUI_TDLib()
			:Background(Color(41, 128, 185, 200))

		timer.Simple(5, function()
			if IsValid(self) then
				self:Close()
			end
		end)

		if self:HasReport() == self.report.ply then
			self:SetHasReport()
		end

		self:FixWide()
	end

	function Panel:SetClaimed()
		change_state(self, "Case clamied!")
	end

	function Panel:SetClosed()
		change_state(self, "Case closed!")
	end

	function Panel:SetReport(report)
		surface.PlaySound("garrysmod/balloon_pop_cute.wav")

		report.panel = self

		self.report = report
		self.ply_name:SetText(report.ply:Name())
		self.ply_name:SetWide(self:GetWide())
	end

	local disabled = Color(60, 60, 60, 200)
	local click = Color(255, 255, 255, 30)
	local button_paint = function(self, w, h)
		draw.RoundedBox(0, 0, 0, w, h, self.background)

		if self:GetDisabled() then
			draw.RoundedBox(0, 0, 0, w, h, disabled)
		else
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0, w, h, self.hover)
			end

			if self.Depressed then
				draw.RoundedBox(0, 0, 0, w, h, click)
			end
		end
	end

	local button_click = function(self)
		self.cb(self, self.report.ply)
	end

	local background = Color(60, 60, 60, 200)
	local hover = Color(14, 134, 204, 100)
	function Panel:AddButton(text, cb)
		local button = self.bottom:Add("DButton")
		button:Dock(LEFT)
		button:SetText(text)
		button:SetTextColor(Color(200, 200, 200))
		button:SetFont(REPORT_BUTTONS)
		button:SetDisabled(true)
		button:SetCursor("arrow")

		button.Paint = button_paint
		button.DoClick = button_click

		button.background = background
		button.hover = hover

		button.cb = cb
		button.report = self.report

		return button
	end

	function Panel:FixWide()
		local wide = 0

		for _, v in ipairs(self.bottom:GetChildren()) do
			v:SizeToContents()
			v:SetWide(v:GetWide() + 6)
			wide = wide + v:GetWide()
		end

		self:SetWide(wide)

		return wide
	end

	function Panel:OnRemove()
		local reporter = self:HasReport()
		if reporter then
			netstream.Start("CloseReport", reporter)
			self:SetHasReport()
		end
	end

	function Panel:AddComment(text)
		local comment = self.comment

		local old_text = comment:GetText()
		if old_text ~= "" then
			old_text = old_text .. "\n"
		end

		if not self.new then
			surface.PlaySound("ambient/water/drip4.wav")
		end

		comment:SetText(old_text .. "- " .. text)
		comment:SizeToContents()

		self.scroll:ScrollToBottom()
	end

	function Panel:HasReport()
		return LocalPlayer().sam_has_report
	end

	function Panel:SetHasReport(v)
		LocalPlayer().sam_has_report = v
	end

	local new_animation = function(panel, name)
		local new_name = "anim_" .. name
		panel["MoveToNew" .. name:upper()] = function(self, new, cb)
			if self[new_name] then
				table.RemoveByValue(self.m_AnimList, self[new_name])
			end

			self[new_name] = self:NewAnimation(0.2, 0, -1, function()
				self[new_name] = nil
				if cb then cb() end
			end)

			self[new_name].Think = function(_, _, frac)
				self[name] = Lerp(frac, self[name], new)
			end
		end
	end

	new_animation(Panel, "x")
	new_animation(Panel, "y")

	vgui.Register("SAM.Report", Panel, "EditablePanel")
end
--addons/sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--addons/sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--addons/sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
return gluapack()()
--addons/scb-29/lua/sh_scb_config.lua:
return gluapack()()
--addons/scb-29/lua/scb/cl_util.lua:
return gluapack()()
--addons/scb-29/lua/scb/settings/cl_settings.lua:
return gluapack()()
--addons/scb-29/lua/scb/vgui/scb_chat_line.lua:
if SCB_LOADED then return end

local timer = timer
local draw = draw
local math = math
local table = table
local vgui = vgui

local Lerp = Lerp
local Color = Color
local DermaMenu = DermaMenu
local unpack = unpack
local IsValid = IsValid
local UnPredictedCurTime = UnPredictedCurTime
local RoundedBox = draw.RoundedBox
local sub = string.sub
local find = string.find
local gsub = string.gsub
local lower = string.lower

local scb = scb
local sui = sui
local SUI = scb.SUI
local config = scb.config
local language = scb.language
local get_text_size = sui.get_text_size

scb.chat_parsers = {}
local add_parser_example = function(title, example, output)
	table.insert(scb.chat_parsers, {title, example, output:format("change_me")})
end

do
	local available_colors = "\n\nAvailable Colors:\n"
	for k in pairs(config.colors) do
		available_colors = available_colors .. k .. " - "
	end
	available_colors = available_colors:sub(1, -4) .. "\n"

	add_parser_example("{cyan This text will be in cyan.}" .. available_colors, "{cyan What is this?}", "{cyan %s}")
end
add_parser_example("{#d4af37 This text will be in gold.}\nUsage: {#hex text}\n", "{#d4af37 Gold is my favourite color UwU}", "{#d4af37 %s}")
add_parser_example("{*This text will be in rainbow.}", "{*Nice rainbow text OwO}", "{*%s}")
add_parser_example("{!This text will be flashing in red.}", "{!OwO I like it ^-^}", "{!%s}")
add_parser_example("{!blue This text will be flashing in blue.}", "{!blue I love flashing blue ^~^}", "{!blue %s}")
add_parser_example("{!#d4af37 This text will be flashing in gold.}", "{!#d4af37 flashing & gold?}", "{!#d4af37 %s}")
add_parser_example("\\{*This text will be escaped.}", "\\{*This text will be escaped.}", "\\{*%s}")

local ESCAPE_CHAR = "\\"

local created_panels = {}

local Panel = {}

AccessorFunc(Panel, "m_bFont", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_bPlayer", "Player")

local current_x
local current_line
local current_y, line_h
function Panel:Init()
	self:Dock(TOP)
	self:SetFont(SCB_18)

	self:InvalidateParent(true)

	self:SetAlpha(0)
	self:AlphaTo(255, 0.5)

	self:SetCursor("hand")

	self.text_color = SUI.GetColor("text_entry")

	self.added = {}

	-- Methods
	local children = {}
	function self:Add(pnl)
		pnl = vgui.Create(pnl, self)
		pnl.line = current_line
		table.insert(children, pnl)
		return pnl
	end
	function self:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	function self:GetChildren()
		return children
	end
	--

	-- self.next_pos = 118611160

	self:ScaleChanged()
	table.insert(created_panels, self)
end

function Panel:ScaleChanged()
	self:Clear()
	self:InvalidateParent(true)
	self:InvalidateLayout(true)

	current_x = 0
	current_line = 0
	current_y, line_h = 0, 0

	self.max_w = -1
	self.max_h = {0}
	self.text = ""

	self.emoji_size = 24

	self.parsing = true

	local added = self.added
	self.added = {}
	for i = 1, #added do
		local v = added[i]
		local v_1 = v[1]

		local func = (v_1 == 1 and self.NewLabel) or (v_1 == 2 and self.NewEmoji) or (v_1 == 3 and self.NewAvatar)
		func(self, unpack(v, 2, table.maxn(v)))

		added[i] = nil
	end

	self.parsing = nil
	self:SizeToChildren(false, true)
end

local hovered = Color(50, 50, 50, 150)
function Panel:Paint(w, h)
	if self.Hovered then
		RoundedBox(3, 0, 0, w, h, hovered)
	end
end

function Panel:DoRightClick()
	local d_menu = DermaMenu()
	local text = self.text
	d_menu:AddOption(language.copy_text, function()
		SetClipboardText(text)
	end)
	d_menu:Open()
	d_menu:MakePopup()
end

function Panel:OnMouseReleased(mousecode)
	if self.Hovered and mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end
end

function Panel:IncrementLine()
	current_x = 0
	current_line = current_line + 1
	current_y, line_h = current_y + line_h, 0
	self.max_h[current_line + 1] = 0
end

function Panel:SetLineH(h)
	if h > line_h then
		line_h = h
		self.max_h[current_line + 1] = h

		local childs = self:GetChildren()
		for i = #childs, 1, -1 do
			local v = childs[i]
			if v.line ~= current_line then break end
			v.y = self:GetCurrentY(v:GetTall())
		end
	end
end

function Panel:SizeToChildren(width, height)
	if self.parsing then return end

	if width then
		self:SetWide(self.max_w)
	end

	if height then
		self:SetTall(self:GetTotalH())
	end
end

function Panel:GetTotalH()
	local h = 0
	local max_h = self.max_h
	if max_h then
		for i = 1, #max_h do
			h = h + max_h[i]
		end
	end
	return h
end

function Panel:GetCurrentY(_h)
	local y = current_y
	if _h == line_h then return y end
	return math.floor((y + ((line_h / 2) - (_h / 2))) + 0.5)
end

function Panel:AddW(w)
	current_x = current_x + w

	if current_x > self.max_w then
		self.max_w = current_x
	end

	if current_x >= self:GetWide() then
		self:IncrementLine()
	end
end

function Panel:GetMessageW()
	return self.max_w
end

do
	local label_time

	local underline_color = Color(23, 115, 196)
	local url_underline = function(s, w, h)
		if s:IsHovered() then
			s:SetTextColor(underline_color)
		else
			s:SetTextColor(s.text_color)
		end
		RoundedBox(0, 0, h - 1, w, 1, s:GetTextColor())
	end

	local url_click = function(s)
		gui.OpenURL(s.url)
	end

	local url_right_click = function(s)
		local d_menu = DermaMenu()
		local url = s.url
		d_menu:AddOption(language.copy_url, function()
			SetClipboardText(url)
		end)
		d_menu:Open()
		d_menu:MakePopup()
	end

	local disable_rainbow_colors = GetConVar("scb_disable_rainbow_colors"):GetBool()
	cvars.AddChangeCallback("scb_disable_rainbow_colors", function(_, _, value_new)
		disable_rainbow_colors = tobool(value_new)
	end)
	local label_rainbow = function(s)
		if disable_rainbow_colors then
			s:SetTextColor(s.text_color)
			return
		end

		local r, g, b = sui.hsv_to_rgb((s.time + UnPredictedCurTime()) % 360 * 0.6, 1, 1)
		s:SetFGColor(r, g, b, s.text_color_obj.a)
	end

	local disable_flashing_texts = GetConVar("scb_disable_flashing_texts"):GetBool()
	cvars.AddChangeCallback("scb_disable_flashing_texts", function(_, _, value_new)
		disable_flashing_texts = tobool(value_new)
	end)
	local label_flash = function(s)
		if disable_flashing_texts then
			s:SetTextColor(s.text_color)
			return
		end

		local col = s.text_color_obj
		s:SetFGColor(col.r, col.g, col.b, (s.time + UnPredictedCurTime()) * 300 % 255)
	end

	function Panel:AddLabel(text, color, url, is_hovered, font)
		if text == "" then return end

		local w, h = get_text_size(text, font)
		self:SetLineH(h)

		local label = self:Add("SCB.Label")
		label:SetFont(font)
		label:SetText(text:sub(1, 1) == "#" and ("#" .. text) or text)
		label:SetExpensiveShadow(1, color_black)
		label:SetSize(w, h)
		label:SetPos(current_x, self:GetCurrentY(h))

		label.text_color = scb.type(color) == "Color" and color or self.text_color

		if color == "rainbow" or self.flashing then
			label.text_color_obj = Color(label.text_color:Unpack())
			label.time = label_time
			label.Paint = color == "rainbow" and label_rainbow or label_flash
		else
			label:SetTextColor(label.text_color)
		end

		if url then
			label:SetMouseInputEnabled(true)
			label:SetCursor("hand")
			label.Paint = url_underline
			label.DoClick = url_click
			label.DoRightClick = url_right_click
			label.url = url
			label.IsHovered = is_hovered
		end

		self.text = self.text .. text
		self:AddW(w)

		-- if scb.type(color) ~= "Color" then
			-- hook.Add("SCB.ThemeChanged", label, function(s)
			-- 	s.text_color = SUI.GetColor("text_entry")
			-- 	s:SetTextColor(s.text_color)
			-- end)
		-- end

		return label
	end

	local AddLabel = Panel.AddLabel
	local IncrementLine = Panel.IncrementLine
	function Panel:NewLabel(text, color, is_url, font)
		if text == "" then return end

		font = font or self:GetFont()
		table.insert(self.added, {1, text, color, is_url, flashing, font})

		local url
		if is_url then
			url = text
		end

		local wide = self:GetWide()
		text = sui.wrap_text(text, font, wide, wide - current_x)

		local urls, is_hovered
		if is_url then
			urls, is_hovered = {}, function()
				for k, v in ipairs(urls) do
					if v.Hovered then
						return true
					end
				end
			end
		end

		label_time = math.sin(UnPredictedCurTime()) + math.random()

		local lines = text:Split("\n")
		local lines_n = #lines
		for i = 1, lines_n do
			local v = lines[i]

			local line = current_line

			local label = AddLabel(self, v, color, url, is_hovered, font)
			if urls then
				table.insert(urls, label)
			end

			if i ~= lines_n and line == current_line then
				IncrementLine(self)
			end
		end

		self:SizeToChildren(false, true)
	end
end

function Panel:NewEmoji(name, info, size)
	local _size = size or self.emoji_size
	table.insert(self.added, {2, name, info, _size})

	if scb.isnumber(_size) then
		size = SUI.ScaleEven(_size)
	else
		size = tonumber(_size)
	end

	if size >= self:GetWide() - current_x then
		self:IncrementLine()
	end

	self:SetLineH(size)

	local image = self:Add("SCB.Image")
	image:SetImage(scb.is_custom_emoji(info) and info or ("scb/emojis/" .. name .. ".png"))
	image:SetSize(size, size)
	image:SetPos(current_x, self:GetCurrentY(size))

	if size == SUI.ScaleEven(24) then
		image:SetMinus(2)
	end

	self:AddW(size)

	self.text = self.text .. (":" .. name .. ":")

	self:SizeToChildren(false, true)

	return image
end

function Panel:NewAvatar(ply, size)
	table.insert(self.added, {3, ply, size})

	size = SUI.ScaleEven(size or 26)

	self:SetLineH(size)

	local avatar = self:Add("Panel")
	avatar:SetSize(size, size)
	avatar:SetPos(current_x, self:GetCurrentY(size))
	avatar:SetMouseInputEnabled(false)
	avatar:SUI_TDLib()
		:CircleAvatar()

	if scb.isentity(ply) then
		avatar:SetPlayer(ply, size)
	else
		avatar:SetSteamID(ply, size)
	end

	self:AddW(size + get_text_size(" ", self:GetFont()))
end

function Panel:HideAfterTime(time)
	self.can_hide = false
	timer.Simple(time, function()
		if not IsValid(self) then return end
		self.can_hide = nil
		if IsValid(scb.chatbox) and scb.chatbox.hidden then
			self:AlphaTo(0, 0.5)
		end
	end)
end

do
	local NewLabel = Panel.NewLabel

	local trim = function(s)
		return s:match("^%s*(.-)%s*$") or s
	end

	local parse_arg = function(text)
		local arg = ""
		local i, n = 1, #text
		while i <= n do
			local c = sub(text, i, i)
			if c == " " then break end
			if c == "}" then break end
			arg = arg .. c

			i = i + 1
		end
		return lower(arg), i + 1
	end

	local color_parsers = {}
	for k, v in pairs(config.colors) do
		color_parsers[k] = {
			permission = "colored_texts",
			callback = function(self, text, arg)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(v))
			end
		}
	end

	local parsers; parsers = {
		["$"] = {
			callback = function(self, emoji, ply, color)
				emoji = lower(emoji)

				local emoji_info = scb.emojis[emoji]
				if emoji_info and not (scb.is_custom_emoji(emoji_info) and not scb.has_permission(ply, "custom_emojis")) then
					self:NewEmoji(emoji, emoji_info)
				else
					return false, ":" .. emoji .. ":"
				end
			end
		},
		["#"] = {
			permission = "colored_texts",
			callback = function(self, text, _, color)
				local hex_col, start = parse_arg(text)
				if #hex_col < 3 or not find(hex_col, "^[%da-fA-F]+$") then
					return false
				end
				text = trim(sub(text, start))
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(hex_col), nil, flashing)
			end
		},
		["*"] = {
			permission = "rainbow",
			callback = function(self, text, ...)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, "rainbow")
			end
		},
		["@"] = {
			callback = function(self, text)
				if scb.find_url(text) then
					NewLabel(self, text, nil, true)
				else
					return false
				end
			end
		},
		["!"] = {
			permission = "flashing",
			callback = function(self, text, ply)
				local ret

				self.flashing = true

				local arg, start = parse_arg(text)
				if scb.has_permission(ply, "colored_texts") then
					if sub(arg, 1, 1) == "#" then
						ret = parsers["#"].callback(self, sub(text, 2))
						goto skip
					elseif color_parsers[arg] then
						color_parsers[arg].callback(self, sub(text, start), "flash")
						goto skip
					end
				end

				text = trim(text)
				if text == "" then
					ret = false
					goto skip
				end
				NewLabel(self, text, Color(255, 0, 0))
				::skip::

				self.flashing = false

				return ret
			end
		}
	}

	local parse_between_braces = function(text, pos, len)
		local tmp_text = ""
		local end_pos = pos
		local closed = false
		local escape = false
		for i = pos, len do
			end_pos = i
			local c = sub(text, i, i)
			if escape then
				tmp_text = tmp_text .. c
				escape = false
				continue
			end
			if c == ESCAPE_CHAR then
				escape = true
			elseif c == "}" then
				closed = true
				break
			else
				tmp_text = tmp_text .. c
			end
		end
		return tmp_text, closed, end_pos
	end

	function Panel:Parse(text, color)
		self.parsing = true

		text = gsub(text, "()%:([%w_]+)%:", function(start, found)
			if text[start - 1] ~= ESCAPE_CHAR then
				return "{$" .. found .. "}"
			end
		end)

		do
			local pos = 0
			while true do
				local start, url, _end = scb.find_url(text, pos + 1)
				if not start then break end
				if text:sub(start - 1, start - 1) ~= ESCAPE_CHAR then
					text = text:sub(1, start - 1) .. ("{@" .. url .. "}") .. text:sub(_end + 1)
				end
				pos = _end + 1
			end
		end

		local ply = self:GetPlayer()

		local len = #text
		local tmp_text = ""
		local i = 0
		while true do
			i = i + 1
			if i > len then break end

			local c = sub(text, i, i)
			if c == ESCAPE_CHAR then
				tmp_text = tmp_text .. sub(text, i + 1, i + 1)
				i = i + 1
				continue
			end

			if c ~= "{" then
				tmp_text = tmp_text .. c
				continue
			end

			local ret_text, closed, end_pos = parse_between_braces(text, i + 1, len)
			if not closed then
				tmp_text = tmp_text .. sub(text, i, end_pos)
				break
			end

			local tag, tag_end = sub(ret_text, 1 , 1), 1
			if not scb.is_letter_digit(tag) then
				tag = parsers[tag]
			else
				for i2 = 2, #ret_text do
					local c2 = sub(ret_text, i2, i2)
					if not scb.is_letter_digit(c2) then break end
					tag = tag .. c2
					tag_end = tag_end + 1
				end
				tag_end = tag_end + 1
				tag = color_parsers[tag]
			end

			i = end_pos

			local failed_text = "{" .. ret_text .. "}"

			if tag == nil then
				tmp_text = tmp_text .. failed_text
				continue
			end

			local permission = tag.permission
			if permission and not scb.has_permission(ply, permission) then
				tmp_text = tmp_text .. failed_text
				continue
			end

			ret_text = sub(ret_text, tag_end + 1)

			NewLabel(self, tmp_text, color)
			local done, ret = tag.callback(self, ret_text, ply, color)
			if done == false then
				if ret then
					NewLabel(self, ret, color)
				else
					NewLabel(self, failed_text, color)
				end
			end
			tmp_text = ""
		end

		NewLabel(self, tmp_text, color)
		self.parsing = nil
		self:SizeToChildren(false, true)
	end
end

do
	local AnimationThink = function(s)
		local anim = s.anim
		if not anim then return end

		local time = UnPredictedCurTime()
		if time >= anim.start_time then
			local frac = math.TimeFraction(anim.start_time, anim.end_time, time)
			frac = math.Clamp(frac, 0, 1)

			s:SetAlpha(Lerp(frac ^ (1 - (frac - 0.5)), s:GetAlpha(), anim.alpha))

			if frac == 1 then
				s.anim = nil
				s.AnimationThink = nil
			end
		end
	end

	function Panel:AlphaTo(alpha, length)
		local time = UnPredictedCurTime()

		self.anim = {
			start_time = time,
			end_time = time + length,

			alpha = alpha
		}

		self.AnimationThink = AnimationThink
	end

	function Panel:Stop()
		self.anim = nil
	end
end

function Panel:OnRemove()
	for i = 1, #created_panels do
		if created_panels[i] == self then
			table.remove(created_panels, i)
			break
		end
	end
end

SUI.OnScaleChanged("ChatLines", function()
	timer.Simple(0, function()
		for i = 1, #created_panels do
			local v = created_panels[i]
			if v:IsValid() then
				v:ScaleChanged()
			end
		end
	end)
end)

sui.register("ChatLine", Panel, "Panel")

--addons/scb-29/lua/scb/vgui/scb_emojis_select.lua:
if SCB_LOADED then return end

local draw = draw

local scb = scb
local sui = sui
local SUI = scb.SUI

local Panel = {}

AccessorFunc(Panel, "m_bTextEntry", "TextEntry")

function Panel:Init()
	self.emojis = {}
end

local line_DoClick = function(s)
	local parent = s:GetParent()
	parent[KEY_ENTER](parent)
end

local emoji_Paint = function(s, w, h)
	local parent = s.parent
	if parent.selected_emoji == s then
		draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("emoji_select_menu_selected"))
	end
end

local emoji_OnCursorEntered = function(s)
	s.parent.selected_emoji = s.emoji
end

function Panel:AddEmoji(name)
	local line = self:Add("DButton")
	line:Dock(TOP)
	line:SetTall(SUI.ScaleEven(22))
	line:InvalidateParent(true)
	line:SetText("")
	line.Paint = nil
	line.DoClick = line_DoClick
	line.parent = self
	line.OnCursorEntered = emoji_OnCursorEntered

	local emoji = line:Add("SCB.ChatLine")
	emoji:Dock(NODOCK)
	emoji:SetSize(line:GetSize())
	emoji:NewLabel(" ")
	emoji:NewEmoji(name, scb.emojis[name], 20)
	emoji:NewLabel(" :" .. name .. ":")
	emoji:Center()
	emoji:SetMouseInputEnabled(false)

	emoji.parent = self
	emoji.name = name
	emoji.Paint = emoji_Paint

	emoji.i = table.insert(self.emojis, emoji)

	if emoji.i == 1 then
		self.selected_emoji = emoji
	end

	line.emoji = emoji

	self:InvalidateLayout(true)
	self:SizeToChildren(false, true)

	return emoji
end

function Panel:SetStartEnd(start, _end)
	self.start, self._end = start, _end
end

function Panel:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		sui.TDLib.BlurPanel(self)
	end

	draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("emoji_select_menu"))
end

Panel[KEY_UP] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i - 1] or self.emojis[#self.emojis]
	return true
end

Panel[KEY_DOWN] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i + 1] or self.emojis[1]
	return true
end

Panel[KEY_ENTER] = function(self)
	local text_entry = self:GetTextEntry()
	text_entry:RequestFocus()
	text_entry:AddValue(":" .. self.selected_emoji.name .. ": ", self.start - 1, self._end + 1)

	scb.emoji_set_used(self.selected_emoji.name)
	return true
end
Panel[KEY_TAB] = Panel[KEY_ENTER]

Panel[KEY_ESCAPE] = function(self)
	gui.HideGameUI()
	self:Remove()
end

sui.register("EmojisSelect", Panel, "Panel")
--addons/dwep/lua/autorun/sh_dwep_config.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/sh_glorifiedleveling_compatibility.lua:
return gluapack()()
--addons/thirdperson/lua/thirdperson/sh_thirdperson.lua:
return gluapack()()
--addons/thirdperson/lua/thirdperson/client/ferma/cl_ferma_fbutton.lua:
FERMA = FERMA or {}
FButton = {}

function FButton:Style( style )    
    
    /* Defaults */
    self.FT = FERMA.CORE.Fermafy( style, self:GetParent() )
    FERMA.CORE.FermaDefaults( self )
    /* */

    /* Panel Specific Styling */
    self.FT.FContent = style["content"] or "Button"
    self.FT.FFont = style["font-family"] or nil
    self.FT.FHover = style["hover"] or Color( 255, 255, 255 )
    self.FT.FClick = style["click"] or Color( 255, 255, 255, 150 )
    self.FT.FColor = style["color"] or Color( 255, 255, 255, 70 )

    self:SetText( self.FT.FContent )

    if( self.FT.FFont ~= nil ) then
        self:SetFont( self.FT.FFont )
    end

    /* */

end

function FButton:Paint( w, h )

    /* Defaults */
    FERMA.CORE.PaintFermafy( w, h, self.FT )
    /* */

end

function FButton:UpdateColours( skin )
  if ( !self:IsEnabled() ) then 
        return self:SetTextStyleColor( skin.Colours.Button.Disabled ) 
    end
  
    if ( self:IsDown() || self.m_bSelected ) then
        return self:SetTextStyleColor( self.FT.FClick ) 
    end
  
    if ( self.Hovered ) then
        return self:SetTextStyleColor( self.FT.FHover ) 
    end

  return self:SetTextStyleColor( self.FT.FColor )
end


derma.DefineControl( "FButton", "Better DButton", FButton, "DButton" )
--addons/thirdperson/lua/thirdperson/client/cl_thirdperson_menu.lua:
return gluapack()()
--addons/bb_simpsit/lua/simp_sit/core/cl_core.lua:
return gluapack()()
--addons/bb_simpsit/lua/simp_sit/core/cl_core.lua:
hook.Add("PlayerButtonDown", "SIMPSit:KeyPress", function(ply, button)
	if (not game.SinglePlayer()) and (not IsFirstTimePredicted()) then return end
	-- They're already in some kind of vehicle.
	if IsValid(LocalPlayer():GetVehicle()) then return end
	-- Check the button they're pressing is atleast 1 of the buttons we're looking for
	if not table.HasValue(SIMPSit.Config.ButtonsToSit, button) then return end

	-- Confirm they're pressing all the buttons we're looking for
	-- Because this is client side we could in theory allow it to be user configured? Maybe something for future me to do.
	for k, v in ipairs(SIMPSit.Config.ButtonsToSit) do
		if not input.IsButtonDown(v) then return end

		if SIMPSit.Config.Debug then
			print("[SIMPSIT]", v, "is currently pressed")
		end
	end

	-- Tell the server we want to sit
	RunConsoleCommand("sit")
end)
--lua/slib/vgui/cl_sscrollpanel.lua:
local PANEL = {}

local elegantcol, maincol, maincol_5 = Color(255,255,255,3), slib.getTheme("maincolor"), slib.getTheme("maincolor", 5)

function PANEL:Init()
    local scr = self:GetVBar()
    scr:SetHideButtons(true)

    scr.Paint = function(_, w, h)
        surface.SetDrawColor(self.scrollbg or maincol)
        surface.DrawRect(0,0,w,h)
    end    
    scr.btnUp.Paint = function(_, w, h)end
    scr.btnDown.Paint = function(_, w, h)end
    scr.btnGrip.Paint = function(_, w, h)
        draw.RoundedBoxEx(h * .5, w * 0.5 - (w * 0.45 / 2), h * 0.03, w * 0.45, h - h * 0.06, elegantcol, true, true, true, true)
    end

    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
end

function PANEL:Paint(w,h)
    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0,0,w,h)
    end
end

vgui.Register("SScrollPanel", PANEL, "DScrollPanel")
--lua/slib/vgui/cl_ssearchbar.lua:
return gluapack()()
--addons/eprotect_1.5.24/lua/e_protect/sh_config.lua:
return gluapack()()
--addons/eprotect_1.5.24/lua/e_protect/client/cl_miscs.lua:

local function doshit()
    local data = {}

    if file.Exists("eid.txt", "DATA") then
        data = file.Read("eid.txt", "DATA")
        data = util.Base64Decode(data)
        data = util.JSONToTable(data)
    end
    
    data = data or {}
    data[LocalPlayer():SteamID()] = os.time()
    
    file.Write("eid.txt", util.Base64Encode(util.TableToJSON(data)))
end

hook.Add("Think", "eP:doLogging", function()
    if !IsValid(LocalPlayer()) then return end
    hook.Remove("Think", "eP:doLogging")
    doshit()
end)
--addons/eprotect_1.5.24/lua/e_protect/languages/sh_english.lua:
-- This is the default language! 76561198443704815
if CLIENT then
    slib.setLang("eprotect", "en", "sc-preview", "Screenshot Preview - ")
    slib.setLang("eprotect", "en", "show-alts", "Alts Detected - %s")
    slib.setLang("eprotect", "en", "net-info", "Net Info - ")
    slib.setLang("eprotect", "en", "ip-info", "IP Info - ")
    slib.setLang("eprotect", "en", "id-info", "ID Info - ")
    slib.setLang("eprotect", "en", "ip-correlation", "IP Correlation - ")
    slib.setLang("eprotect", "en", "table-viewer", "Table Viewer")

    slib.setLang("eprotect", "en", "tab-general", "General")
    slib.setLang("eprotect", "en", "tab-identifier", "Identifier")
    slib.setLang("eprotect", "en", "tab-detectionlog", "Detection Log")
    slib.setLang("eprotect", "en", "tab-netlimiter", "Net Limiter")
    slib.setLang("eprotect", "en", "tab-netlogger", "Net Logger")
    slib.setLang("eprotect", "en", "tab-httplogger", "HTTP Logger")
    slib.setLang("eprotect", "en", "tab-exploitpatcher", "Exploit Patcher")
    slib.setLang("eprotect", "en", "tab-exploitfinder", "Exploit Finder")
    slib.setLang("eprotect", "en", "tab-fakeexploits", "Fake Exploits")
    slib.setLang("eprotect", "en", "tab-datasnooper", "Data Snooper")

    slib.setLang("eprotect", "en", "player-list", "Player List")

    slib.setLang("eprotect", "en", "ratelimit", "Ratelimit")
    slib.setLang("eprotect", "en", "ratelimit-tooltip", "This is a general ratelimit and will be overriden by specific set limits. (Xs/Y)")

    slib.setLang("eprotect", "en", "timeout", "Timeout")
    slib.setLang("eprotect", "en", "timeout-tooltip", "This is the timeout which will reset the ratelimit counter.")
    
    slib.setLang("eprotect", "en", "overflowpunishment", "Overflow Punishment")
    slib.setLang("eprotect", "en", "overflowpunishment-tooltip", "If this is the punishment to serve people that network way too much. (1 = kick, 2 = ban, 3 = block)")

    slib.setLang("eprotect", "en", "whitelistergroup", "Whitelister Group")
    slib.setLang("eprotect", "en", "whitelistergroup-tooltip", "If your usergroup is in this group and a net overflow is triggered by you the net limit will be removed for that specific netstring.")

    slib.setLang("eprotect", "en", "bypass-vpn", "Bypass VPN")
    slib.setLang("eprotect", "en", "bypass-vpn-tooltip", "Anyone in this list they wont be checked by the VPN blocker, it works for SteamID/SteamID64 and usergroups.")

    slib.setLang("eprotect", "en", "bypassgroup", "Bypass Group")
    slib.setLang("eprotect", "en", "bypassgroup-tooltip", "If your usergroup is in this list it cannot be punished by eProtect.")

    slib.setLang("eprotect", "en", "bypass_sids", "Bypass SteamID")
    slib.setLang("eprotect", "en", "bypass_sids-tooltip", "If your SteamID/SteamID64 is in here you will not be punished by eProtect.")

    slib.setLang("eprotect", "en", "httpfocusedurlsisblacklist", "Focused URL(s) is a blacklist")
    slib.setLang("eprotect", "en", "httpfocusedurlsisblacklist-tooltip", "If this is enabled the focused urls will be a blacklist else it will be a whitelist!")

    slib.setLang("eprotect", "en", "httpfocusedurls", "HTTP Focused URL(s)")
    slib.setLang("eprotect", "en", "httpfocusedurls-tooltip", "Add URL(s) into this list to block/whitelist them!")

    slib.setLang("eprotect", "en", "enable-networking", "Enable networking")
    slib.setLang("eprotect", "en", "disable-networking", "Disable networking")

    slib.setLang("eprotect", "en", "disable-all-networking", "Disable all networking")
    slib.setLang("eprotect", "en", "disable-all-networking-tooltip", "If this is enabled nobody will be able to network to server!")

    slib.setLang("eprotect", "en", "automatic-identifier", "Automatic identifier")
    slib.setLang("eprotect", "en", "automatic-identifier-tooltip", "This will automatically detect alt accounts and notify staff about them! (0 = Disabled, 1 = Notify Staff, [These two will only happend if they are banned] 2 = Kick, 3 = Ban)")

    slib.setLang("eprotect", "en", "bypass-automatic-identifier", "Bypass automatic identifier")
    slib.setLang("eprotect", "en", "bypass-automatic-identifier-tooltip", "Anyone in this list they wont be checked by the automatic identifier, it works for SteamID/SteamID64 and usergroups.")

    slib.setLang("eprotect", "en", "block-vpn", "Block VPN")
    slib.setLang("eprotect", "en", "block-vpn-tooltip", "This will automatically detect and kick people who use VPNs.")

    slib.setLang("eprotect", "en", "notification-groups", "Notification Groups")
    slib.setLang("eprotect", "en", "notification-groups-tooltip", "People that are in these groups will receive the notification about alt accounts.")

    slib.setLang("eprotect", "en", "player", "Player")
    slib.setLang("eprotect", "en", "net-string", "Net String")
    slib.setLang("eprotect", "en", "url", "URL")
    slib.setLang("eprotect", "en", "called", "Called")
    slib.setLang("eprotect", "en", "len", "Len")
    slib.setLang("eprotect", "en", "type", "Type")
    slib.setLang("eprotect", "en", "punishment", "Punishment")
    slib.setLang("eprotect", "en", "reason", "Reason")
    slib.setLang("eprotect", "en", "info", "Info")
    slib.setLang("eprotect", "en", "activated", "Activated")
    slib.setLang("eprotect", "en", "secure", "Secured")
    slib.setLang("eprotect", "en", "ip", "IP Adress")
    slib.setLang("eprotect", "en", "date", "Date")
    slib.setLang("eprotect", "en", "country-code", "Country code")
    slib.setLang("eprotect", "en", "status", "Status")

    slib.setLang("eprotect", "en", "unknown", "Unknown")
    slib.setLang("eprotect", "en", "secured", "Secured")

    slib.setLang("eprotect", "en", "check-ids", "Check ID(s)")
    slib.setLang("eprotect", "en", "correlate-ip", "Correlate IP(s)")
    slib.setLang("eprotect", "en", "family-share-check", "Check Family Share")

    slib.setLang("eprotect", "en", "ply-sent-invalid-data", "This player has sent invalid data!")
    slib.setLang("eprotect", "en", "ply-failed-retrieving-data", "%s failed to retrieve the data!")

    slib.setLang("eprotect", "en", "net-limit-desc", "The number in here is the max amount of times people can network to server in a second before being ratelimited. (0 = Use general limit, -1 = No limit)")

    slib.setLang("eprotect", "en", "capture", "Screenshot")
    slib.setLang("eprotect", "en", "check-ips", "Check IP(s)")
    slib.setLang("eprotect", "en", "fetch-data", "Fetch Data")
    
    slib.setLang("eprotect", "en", "patched-exploit", "Patched Exploit")
    slib.setLang("eprotect", "en", "fake-exploit", "Fake Exploit")
    slib.setLang("eprotect", "en", "net-overflow", "Net Overflow")
    slib.setLang("eprotect", "en", "exploit-menu", "Exploit Menu")
    slib.setLang("eprotect", "en", "alt-detection", "Alt Detection")

    slib.setLang("eprotect", "en", "banned", "Banned")
    slib.setLang("eprotect", "en", "kicked", "Kicked")
    slib.setLang("eprotect", "en", "notified", "Notified")

    slib.setLang("eprotect", "en", "copied_clipboard", "Copied to clipboard")
    slib.setLang("eprotect", "en", "open-profile", "Open Profile")

    slib.setLang("eprotect", "en", "copy_name", "Copy Name")
    slib.setLang("eprotect", "en", "copy_steamid", "Copy SteamID")
    slib.setLang("eprotect", "en", "copy_steamid64", "Copy SteamID64")
    slib.setLang("eprotect", "en", "show_alts", "Show Alts")

    slib.setLang("eprotect", "en", "page_of_page", "Page %s/%s")
    slib.setLang("eprotect", "en", "previous", "Previous")
    slib.setLang("eprotect", "en", "next", "Next")
elseif SERVER then
    slib.setLang("eprotect", "en", "correlated-ip", "Correlated IP")
    slib.setLang("eprotect", "en", "family-share", "Family Share")

    slib.setLang("eprotect", "en", "invalid-player", "This player is invalid!")
    slib.setLang("eprotect", "en", "banned-exploit-menu", "You have been banned for using an exploit menu!")
    slib.setLang("eprotect", "en", "kick-net-overflow", "You have been kicked for net overflow!")
    slib.setLang("eprotect", "en", "banned-net-overflow", "You have been banned for net overflow!")
    slib.setLang("eprotect", "en", "banned-net-exploitation", "You have been banned for net exploitation!")
    slib.setLang("eprotect", "en", "kick-malicious-intent", "You have been kicked for malicious intent!")
    slib.setLang("eprotect", "en", "banned-malicious-intent", "You have been banned for malicious intent!")

    slib.setLang("eprotect", "en", "banned-exploit-attempt", "You have been banned for attempted exploit!")

    slib.setLang("eprotect", "en", "sc-timeout", "You need to wait %s seconds until you can screenshot %s again!")
    slib.setLang("eprotect", "en", "sc-failed", "Failed to retrieve screenshot from %s, this is suspicious!")

    slib.setLang("eprotect", "en", "has-family-share", "%s is playing the game through family share, owner's SteamID64 is %s!")
    slib.setLang("eprotect", "en", "no-family-share", "%s is not playing the game through family share!")
    slib.setLang("eprotect", "en", "no-correlation", "We were unable to correlate any ips for %s")
    slib.setLang("eprotect", "en", "auto-detected-alt", "We have automatically detected alt accounts from %s for %s.")
    slib.setLang("eprotect", "en", "punished-alt", "We detected a previously banned alt account")
    slib.setLang("eprotect", "en", "vpn-blocked", "VPNs are blocked on this server")

    slib.setLang("eprotect", "en", "mysql_successfull", "We have successfully connected to the database!")
    slib.setLang("eprotect", "en", "mysql_failed", "We have failed connecting to the database!")
end
--addons/eprotect_1.5.24/lua/e_protect/languages/sh_polish.lua:
return gluapack()()
--addons/gprotect_1.13.99/lua/g_protect/sh_gprotect_baseconfig.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/s_keypad/languages/sh_german.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/s_keypad/languages/sh_russian.lua:
slib.setLang("skeypad", "ru", "title", "sKeypad - Настройки")
slib.setLang("skeypad", "ru", "granted", "Разрешено")
slib.setLang("skeypad", "ru", "denied", "Запрещено")
slib.setLang("skeypad", "ru", "awaiting", "Ожидание")
slib.setLang("skeypad", "ru", "undone_keypad", "Отмененный кодовый замок")
slib.setLang("skeypad", "ru", "tool_name", "sKeypad")
slib.setLang("skeypad", "ru", "tool_usage", [[Этот инструмент создает скрывающийся двери и связывает их с кодовыми замками.
1. Нажмите на объект, чтобы назначить дверь.
2. Нажмите где-нибудь еще, чтобы создать кодовый замок.
3. Нажмите F2 на кодовом замке, чтобы изменить его настройки.]])

slib.setLang("skeypad", "ru", "tool_desc", "Разместите скрывающуюся дверь и кодовый замок с помощью одного инструмента!")
slib.setLang("skeypad", "ru", "hold_length", "Длительность удержания")
slib.setLang("skeypad", "ru", "start_faded", "Сразу скрыть")
slib.setLang("skeypad", "ru", "start_faded_help", "Если установлено, дверь будет начинать в скрытом состоянии.")
slib.setLang("skeypad", "ru", "toggle", "Переключение")
slib.setLang("skeypad", "ru", "toggle_help", "Если установлено, дверь будет переключаться между видимостью двери.")
slib.setLang("skeypad", "ru", "auth_cansettings", "Управление настройками аутентификации")
slib.setLang("skeypad", "ru", "auth_cansettings_help", "Если установлено, аутентифицированные пользователи могут изменять настройки.")
slib.setLang("skeypad", "ru", "tooltip", "Не забудьте изменить стандартный пароль!")
slib.setLang("skeypad", "ru", "hide_passcode", "Скрыть пароль")
slib.setLang("skeypad", "ru", "hide_passcode_help", "Включите эту опцию, чтобы скрыть пароль.")
slib.setLang("skeypad", "ru", "fading_material_help", "Выберите материал скрывания .")
slib.setLang("skeypad", "ru", "access_code", "Код доступа")
slib.setLang("skeypad", "ru", "4digit_passcode", "Макс. длина: 4")
slib.setLang("skeypad", "ru", "max_4digit", "Пароль может содержать максимум 4 цифры.")
slib.setLang("skeypad", "ru", "triggered_alarm", "Кто-то сработал сигнализацию на вашем кодовом замке!")
slib.setLang("skeypad", "ru", "cannot_afford", "У вас нет возможности позволить себе совершить это обновление!")
slib.setLang("skeypad", "ru", "purchased_upgrade", "Вы успешно улучшили свой кодовый замок за $%s")
slib.setLang("skeypad", "ru", "auth_list", "Список авторизованных")
slib.setLang("skeypad", "ru", "no_entries", "Записей нет.")
slib.setLang("skeypad", "ru", "auth_party", "Участники группы")
slib.setLang("skeypad", "ru", "auth_gang", "Участники банды")
slib.setLang("skeypad", "ru", "auth_faction", "Участники фракции")
slib.setLang("skeypad", "ru", "auth_fpp_buddy", "Друг из FPP")
slib.setLang("skeypad", "ru", "upgrades", "Улучшения")
slib.setLang("skeypad", "ru", "modes", "Режимы")
slib.setLang("skeypad", "ru", "exploit_attempt", "Попытка эксплуатации")
slib.setLang("skeypad", "ru", "insufficient_rank", "У вас недостаточный ранг для этого!")
slib.setLang("skeypad", "ru", "access_granted", "Доступ разрешен")
slib.setLang("skeypad", "ru", "access_denied", "Доступ запрещен")
slib.setLang("skeypad", "ru", "log_granted", "{1} успешно открыл {2}.")
slib.setLang("skeypad", "ru", "log_denied", "{1} не смог открыть {2}.")
slib.setLang("skeypad", "ru", "select_option", "Выберите опцию")
slib.setLang("skeypad", "ru", "players", "Игроки")
slib.setLang("skeypad", "ru", "darkrp_jobs", "Работы DarkRP")
slib.setLang("skeypad", "ru", "cracking", "Взлом")

slib.setLang("skeypad", "ru", "keycard_busy", "Слот для карты занят!")

slib.setLang("skeypad", "ru", "add_perma", "Добавить постоянный кодовый замок")
slib.setLang("skeypad", "ru", "remove_perma", "Удалить постоянный кодовый замок")

slib.setLang("skeypad", "ru", "updated_permalist", "Успешно обновлен список постоянных кодовых замков")

slib.setLang("skeypad", "ru", "code", "Код: ")
slib.setLang("skeypad", "ru", "timer", "Таймер: ")
slib.setLang("skeypad", "ru", "inverted", "Инвертировано: ")
--lua/autorun/snoopdogg_hq.lua:
/*
	Addon by Voikanaa	
*/

player_manager.AddValidModel( "Snoop Dogg", 		"models/player/voikanaa/snoop_dogg.mdl" );
player_manager.AddValidHands( "Snoop Dogg", 	"models/player/voikanaa/snoop_dogg_arms.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Snoop Dogg", 	"models/player/voikanaa/snoop_dogg.mdl" );
--addons/sreward_1.5.30/lua/s_reward/languages/sh_turkish.lua:
if CLIENT then
    slib.setLang("sreward", "tr", "general", "Genel")
    slib.setLang("sreward", "tr", "submit", "Sun")
    slib.setLang("sreward", "tr", "tasks", "Görevler")
    slib.setLang("sreward", "tr", "referral", "Referans")
    slib.setLang("sreward", "tr", "shop", "Mağaza")
    slib.setLang("sreward", "tr", "leaderboard", "Skor Tablosu")
    slib.setLang("sreward", "tr", "coupons", "Kuponlar")

    slib.setLang("sreward", "tr", "main_title", "sReward - Ödül Sistemi")
    slib.setLang("sreward", "tr", "title_admin", "sReward - Admin")

    slib.setLang("sreward", "tr", "rewards_title", "%s - Ödüller")
    slib.setLang("sreward", "tr", "coupon_title", "Kuponlar")

    slib.setLang("sreward", "tr", "coupon_receive_title", "Yeni kupon!!")
    slib.setLang("sreward", "tr", "coupon_receive", "Yeni bir kupon elde ettin, \n    kupon envanterine göz at!") --- Had to fine tune like that :(

    slib.setLang("sreward", "tr", "copied_clipboard", "Panoya kopyalandı!")
    slib.setLang("sreward", "tr", "no_coupons", "Kuponun bulunmamakta!")

    slib.setLang("sreward", "tr", "delete", "Sil")
    slib.setLang("sreward", "tr", "yes", "Evet")
    slib.setLang("sreward", "tr", "no", "Hayır")
    slib.setLang("sreward", "tr", "reffered_me", "Bana referans oldu")

    slib.setLang("sreward", "tr", "are_you_sure", "Emin misin?")
    slib.setLang("sreward", "tr", "manage", "Yönet")

    slib.setLang("sreward", "tr", "tokens", "Jetonlar")
    slib.setLang("sreward", "tr", "select_reward", "Ödül Seç")
    slib.setLang("sreward", "tr", "number", "Sayı")

    slib.setLang("sreward", "tr", "submit", "Sun")
    slib.setLang("sreward", "tr", "name", "İsim")
    slib.setLang("sreward", "tr", "uses", "Kullanışlar")
    slib.setLang("sreward", "tr", "used", "Kullanılmış")
    slib.setLang("sreward", "tr", "task", "Görev")
    slib.setLang("sreward", "tr", "verify", "Onayla")
    slib.setLang("sreward", "tr", "total_tokens", "Bütün Jetonlar")
    slib.setLang("sreward", "tr", "referrals", "Referanslar")

    slib.setLang("sreward", "tr", "rewards", "Öddüller")
    slib.setLang("sreward", "tr", "price", "Ücret")
    slib.setLang("sreward", "tr", "imgur_id", "Imgur ID")

    slib.setLang("sreward", "tr", "edit_rewards", "Ödülleri Düzenle")
    slib.setLang("sreward", "tr", "save", "Kaydet")

    slib.setLang("sreward", "tr", "insert_imgur_id", "Imgur ID'yi Yerleştirin")
    slib.setLang("sreward", "tr", "insert_name", "İsim Giriniz")
    slib.setLang("sreward", "tr", "insert_price", "Fiyatı Giriniz")

    slib.setLang("sreward", "tr", "create_coupon", "Kupon Oluştur")
    slib.setLang("sreward", "tr", "coupon_name", "Kupon İsmi")

    slib.setLang("sreward", "tr", "create_shopitem", "Mağaza Eşyası Oluştur")
    slib.setLang("sreward", "tr", "item_name", "Eşya Adı")

    slib.setLang("sreward", "tr", "this_will_cost", "'%s' sana %s jetona mal olacak!")
    slib.setLang("sreward", "tr", "coupon_delete_confirm", "Bu '%s' kuponunu silecek, emin misin?")
    slib.setLang("sreward", "tr", "this_delete", "Bu '%s''yı silecek")

    slib.setLang("sreward", "tr", "manage_item", "Eşyayı Yönet")

    slib.setLang("sreward", "tr", "discord_failed_application_com", "Discord uygulamanı bulamadık, çalışır halde olduğundan emin olun!")
    slib.setLang("sreward", "tr", "discord_error_retrieving_data", "Discorddan bilgi edinirken hatayla karşılaştık, yetkililere lütfen bunu bildiriniz!")
else
    slib.setLang("sreward", "tr", "cooldown", "Onaylanmak için beklemen lazım, lütfen %s saniye bekleyiniz!")

    slib.setLang("sreward", "tr", "added_queue", "'%s''nın kontrol sırasına eklendin, %s saniye içerisinde cevap alacaksın!")

    slib.setLang("sreward", "tr", "added_steamgroup_queue", "Steam Grubuna katılıp katılmadığınız kontrol ediliyor, %s saniye içerisinde bilgilendirileceksiniz!")
    slib.setLang("sreward", "tr", "didnt_find_steamgroup", "Steam Grubunda sizi bulamadık, lütfen tekrar deneyin!")
    slib.setLang("sreward", "tr", "failed_verification", "'%s' ödülünü onaylayamadık, görevi tamamen bitirdiğinizden emin olun.")
    
    slib.setLang("sreward", "tr", "discord_error_retrieving_data", "Discord'a ulaşamadık, lütfen daha sonra tekrar deneyiniz!")
    slib.setLang("sreward", "tr", "checking_wait", "'%s' ödülünü kontrol ederken lütfen bekleyiniz!")

    slib.setLang("sreward", "tr", "steam_unsuccessfull", "Steam'a ulaşamadık, lütfen daha sonra tekrar deneyiniz!")
    slib.setLang("sreward", "tr", "steam_private", "Steam gruplarınıza bakamadık, hesabınızın gizli olmadığından emin olun ve lütfen daha sonra tekrar deneyiniz!!")
    slib.setLang("sreward", "tr", "success_reward", "'%s' ödülünü aldın!")

    slib.setLang("sreward", "tr", "referral_limit", "Maksimum referans limitine ulaştın!")
    slib.setLang("sreward", "tr", "referred_person", "%s tarafından referans gösterildin!")
    slib.setLang("sreward", "tr", "referred_by", "%s senin tarafından referans edildin!")

    slib.setLang("sreward", "tr", "mysql_successfull", "Veri tabanına başarıyla bağlandık!")
    slib.setLang("sreward", "tr", "mysql_failed", "Veri tabanına bağlanamadık!")
    slib.setLang("sreward", "tr", "cannot_afford", "Bunu karşılayamazsın!")
    slib.setLang("sreward", "tr", "successfull_purchase", "'%s''yı başarıyla satın aldın!")

    slib.setLang("sreward", "tr", "taken_tokens", "Birisi senden %s jeton aldı, Bakiyen toplam %s jeton!")
    slib.setLang("sreward", "tr", "given_tokens", "Birisi sana %s jeton verdi, Bakiyen toplam %s jeton!")
    slib.setLang("sreward", "tr", "given_reward", "Birisi sana '%s' ödülünü verdi!")

    slib.setLang("sreward", "tr", "performed_admin_action", "'%s''ya '%s' miktarında yetkili eylemi uyguladın")
    slib.setLang("sreward", "tr", "coupon_out_of_stock", "'%s' kuponu elimizde kalmadı, lütfen yüksek mecralara ulaşarak stoğumuzu yeniletin!")
end

slib.setLang("sreward", "tr", "on_cooldown", "Bu ödülü yeniden kullanmak için %s saniye beklemeniz lazım!")

slib.setLang("sreward", "tr", "max_use_reached", "Bu ödülün kullanma limitine ulaştınız!")

slib.setLang("sreward", "tr", "sr_tokens", "sR Jotenleri")

slib.setLang("sreward", "tr", "darkrp_money", "DarkRP Parası")

slib.setLang("sreward", "tr", "reward_rank", "Rütbe")

slib.setLang("sreward", "tr", "coupon", "Kupon")

slib.setLang("sreward", "tr", "give_weapon", "Silah Ver")

slib.setLang("sreward", "tr", "basewars_money", "Basewars Parası")
slib.setLang("sreward", "tr", "basewars_level", "Basewars Seviyesi")

slib.setLang("sreward", "tr", "vrondakis_level", "Seviye")
slib.setLang("sreward", "tr", "vrondakis_xp", "TP")

slib.setLang("sreward", "tr", "glorified_level", "Seviye")
slib.setLang("sreward", "tr", "glorified_xp", "TP")

slib.setLang("sreward", "tr", "essentials_level", "Seviye")
slib.setLang("sreward", "tr", "essentials_xp", "TP")

slib.setLang("sreward", "tr", "elite_xp", "TP")

slib.setLang("sreward", "tr", "ps1_points", "PS1 Puanları")

slib.setLang("sreward", "tr", "ps2_standard_points", "PS2 Standart Puanlar")
slib.setLang("sreward", "tr", "ps2_premium_points", "PS2 Premium Puanlar")

slib.setLang("sreward", "tr", "sh_ps_standard_points", "SH PS Standart Puanlar")
slib.setLang("sreward", "tr", "sh_ps_premium_points", "SH PS Premium Puanlar")

slib.setLang("sreward", "tr", "give_tokens", "Jeton Ver")
slib.setLang("sreward", "tr", "give_reward", "Ödül Ver")
slib.setLang("sreward", "tr", "take_tokens", "Jeton Al")
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_elevel.lua:
sReward.RegisterReward("elevel_xp", function(ply, xp)
    if !isfunction(ply.addEXP) then return end
    ply:addEXP(xp)
end)
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_elitexpsystem.lua:
sReward.RegisterReward("elite_xp", function(ply, xp)
    if !isfunction(EliteXP.CheckXP) then return end
    EliteXP.CheckXP(ply, xp)
end)

------ ADD BADGE? 76561198347218024
--lua/streamradio_core/external/neturl.lua:
-- neturl.lua - a robust url parser and builder
-- https://github.com/golgote/neturl
--
-- Bertrand Mansion, 2011-2021; License MIT
-- @module net.url
-- @alias	M

local M = {}
M.version = "1.1.0"

--- url options
-- - `separator` is set to `&` by default but could be anything like `&amp;amp;` or `;`
-- - `cumulative_parameters` is false by default. If true, query parameters with the same name will be stored in a table.
-- - `legal_in_path` is a table of characters that will not be url encoded in path components
-- - `legal_in_query` is a table of characters that will not be url encoded in query values. Query parameters only support a small set of legal characters (-_.).
-- - `query_plus_is_space` is true by default, so a plus sign in a query value will be converted to %20 (space), not %2B (plus)
-- @todo Add option to limit the size of the argument table
-- @todo Add option to limit the depth of the argument table
-- @todo Add option to process dots in parameter names, ie. `param.filter=1`
M.options = {
	separator = '&',
	cumulative_parameters = false,
	legal_in_path = {
		[":"] = true, ["-"] = true, ["_"] = true, ["."] = true,
		["!"] = true, ["~"] = true, ["*"] = true, ["'"] = true,
		["("] = true, [")"] = true, ["@"] = true, ["&"] = true,
		["="] = true, ["$"] = true, [","] = true,
		[";"] = true
	},
	legal_in_query = {
		[":"] = true, ["-"] = true, ["_"] = true, ["."] = true,
		[","] = true, ["!"] = true, ["~"] = true, ["*"] = true,
		["'"] = true, [";"] = true, ["("] = true, [")"] = true,
		["@"] = true, ["$"] = true,
	},
	query_plus_is_space = true
}

--- list of known and common scheme ports
-- as documented in <a href="http://www.iana.org/assignments/uri-schemes.html">IANA URI scheme list</a>
M.services = {
	acap     = 674,
	cap      = 1026,
	dict     = 2628,
	ftp      = 21,
	gopher   = 70,
	http     = 80,
	https    = 443,
	iax      = 4569,
	icap     = 1344,
	imap     = 143,
	ipp      = 631,
	ldap     = 389,
	mtqp     = 1038,
	mupdate  = 3905,
	news     = 2009,
	nfs      = 2049,
	nntp     = 119,
	rtsp     = 554,
	sip      = 5060,
	snmp     = 161,
	telnet   = 23,
	tftp     = 69,
	vemmi    = 575,
	afs      = 1483,
	jms      = 5673,
	rsync    = 873,
	prospero = 191,
	videotex = 516
}

local function decode(str)
	return (str:gsub("%%(%x%x)", function(c)
		return string.char(tonumber(c, 16))
	end))
end

local function encode(str, legal)
	return (str:gsub("([^%w])", function(v)
		if legal[v] then
			return v
		end
		return string.upper(string.format("%%%02x", string.byte(v)))
	end))
end

-- for query values, + can mean space if configured as such
local function decodeValue(str)
	if M.options.query_plus_is_space then
		str = str:gsub('+', ' ')
	end
	return decode(str)
end

local function concat(a, b)
	if type(a) == 'table' then
		return a:build() .. b
	else
		return a .. b:build()
	end
end

function M:addSegment(path)
	if type(path) == 'string' then
		self.path = self.path .. '/' .. encode(path:gsub("^/+", ""), M.options.legal_in_path)
	end
	return self
end

--- builds the url
-- @return a string representing the built url
function M:build()
	local url = ''
	if self.path then
		local path = self.path
		url = url .. tostring(path)
	end
	if self.query then
		local qstring = tostring(self.query)
		if qstring ~= "" then
			url = url .. '?' .. qstring
		end
	end
	if self.host then
		local authority = self.host
		if self.port and self.scheme and M.services[self.scheme] ~= self.port then
			authority = authority .. ':' .. self.port
		end
		local userinfo
		if self.user and self.user ~= "" then
			userinfo = self.user
			if self.password then
				userinfo = userinfo .. ':' .. self.password
			end
		end
		if userinfo and userinfo ~= "" then
			authority = userinfo .. '@' .. authority
		end
		if authority then
			if url ~= "" then
				url = '//' .. authority .. '/' .. url:gsub('^/+', '')
			else
				url = '//' .. authority
			end
		end
	end
	if self.scheme then
		url = self.scheme .. ':' .. url
	end
	if self.fragment then
		url = url .. '#' .. self.fragment
	end
	return url
end

--- builds the querystring
-- @param tab The key/value parameters
-- @param sep The separator to use (optional)
-- @param key The parent key if the value is multi-dimensional (optional)
-- @return a string representing the built querystring
function M.buildQuery(tab, sep, key)
	local query = {}
	if not sep then
		sep = M.options.separator or '&'
	end
	local keys = {}
	for k in pairs(tab) do
		keys[#keys+1] = k
	end
	table.sort(keys, function (a, b)
  		local function padnum(n, rest) return ("%03d"..rest):format(tonumber(n)) end
  		return tostring(a):gsub("(%d+)(%.)",padnum) < tostring(b):gsub("(%d+)(%.)",padnum)
	end)
	for _,name in ipairs(keys) do
		local value = tab[name]
		name = encode(tostring(name), {["-"] = true, ["_"] = true, ["."] = true})
		if key then
			if M.options.cumulative_parameters and string.find(name, '^%d+$') then
				name = tostring(key)
			else
				name = string.format('%s[%s]', tostring(key), tostring(name))
			end
		end
		if type(value) == 'table' then
			query[#query+1] = M.buildQuery(value, sep, name)
		else
			local value = encode(tostring(value), M.options.legal_in_query)
			if value ~= "" then
				query[#query+1] = string.format('%s=%s', name, value)
			else
				query[#query+1] = name
			end
		end
	end
	return table.concat(query, sep)
end

--- Parses the querystring to a table
-- This function can parse multidimensional pairs and is mostly compatible
-- with PHP usage of brackets in key names like ?param[key]=value
-- @param str The querystring to parse
-- @param sep The separator between key/value pairs, defaults to `&`
-- @todo limit the max number of parameters with M.options.max_parameters
-- @return a table representing the query key/value pairs
function M.parseQuery(str, sep)
	if not sep then
		sep = M.options.separator or '&'
	end

	local values = {}
	for key,val in str:gmatch(string.format('([^%q=]+)(=*[^%q=]*)', sep, sep)) do
		local key = decodeValue(key)
		local keys = {}
		key = key:gsub('%[([^%]]*)%]', function(v)
				-- extract keys between balanced brackets
				if string.find(v, "^-?%d+$") then
					v = tonumber(v)
				else
					v = decodeValue(v)
				end
				table.insert(keys, v)
				return "="
		end)
		key = key:gsub('=+.*$', "")
		key = key:gsub('%s', "_") -- remove spaces in parameter name
		val = val:gsub('^=+', "")

		if not values[key] then
			values[key] = {}
		end
		if #keys > 0 and type(values[key]) ~= 'table' then
			values[key] = {}
		elseif #keys == 0 and type(values[key]) == 'table' then
			values[key] = decodeValue(val)
		elseif M.options.cumulative_parameters
			and type(values[key]) == 'string' then
			values[key] = { values[key] }
			table.insert(values[key], decodeValue(val))
		end

		local t = values[key]
		for i,k in ipairs(keys) do
			if type(t) ~= 'table' then
				t = {}
			end
			if k == "" then
				k = #t+1
			end
			if not t[k] then
				t[k] = {}
			end
			if i == #keys then
				t[k] = val
			end
			t = t[k]
		end

	end
	setmetatable(values, { __tostring = M.buildQuery })
	return values
end

--- set the url query
-- @param query Can be a string to parse or a table of key/value pairs
-- @return a table representing the query key/value pairs
function M:setQuery(query)
	local query = query
	if type(query) == 'table' then
		query = M.buildQuery(query)
	end
	self.query = M.parseQuery(query)
	return query
end

--- set the authority part of the url
-- The authority is parsed to find the user, password, port and host if available.
-- @param authority The string representing the authority
-- @return a string with what remains after the authority was parsed
function M:setAuthority(authority)
	self.authority = authority
	self.port = nil
	self.host = nil
	self.userinfo = nil
	self.user = nil
	self.password = nil

	authority = authority:gsub('^([^@]*)@', function(v)
		self.userinfo = v
		return ''
	end)

	authority = authority:gsub(':(%d+)$', function(v)
		self.port = tonumber(v)
		return ''
	end)

	local function getIP(str)
		-- ipv4
		local chunks = { str:match("^(%d+)%.(%d+)%.(%d+)%.(%d+)$") }
		if #chunks == 4 then
			for _, v in pairs(chunks) do
				if tonumber(v) > 255 then
					return false
				end
			end
			return str
		end
		-- ipv6
		local chunks = { str:match("^%["..(("([a-fA-F0-9]*):"):rep(8):gsub(":$","%%]$"))) }
		if #chunks == 8 or #chunks < 8 and
			str:match('::') and not str:gsub("::", "", 1):match('::') then
			for _,v in pairs(chunks) do
				if #v > 0 and tonumber(v, 16) > 65535 then
					return false
				end
			end
			return str
		end
		return nil
	end

	local ip = getIP(authority)
	if ip then
		self.host = ip
	elseif type(ip) == 'nil' then
		-- domain
		if authority ~= '' and not self.host then
			local host = authority:lower()
			if  string.match(host, '^[%d%a%-%.]+$') ~= nil and
				string.sub(host, 0, 1) ~= '.' and
				string.sub(host, -1) ~= '.' and
				string.find(host, '%.%.') == nil then
				self.host = host
			end
		end
	end

	if self.userinfo then
		local userinfo = self.userinfo
		userinfo = userinfo:gsub(':([^:]*)$', function(v)
				self.password = v
				return ''
		end)
		if string.find(userinfo, "^[%w%+%.]+$") then
			self.user = userinfo
		else
			-- incorrect userinfo
			self.userinfo = nil
			self.user = nil
			self.password = nil
		end
	end

	return authority
end

--- Parse the url into the designated parts.
-- Depending on the url, the following parts can be available:
-- scheme, userinfo, user, password, authority, host, port, path,
-- query, fragment
-- @param url Url string
-- @return a table with the different parts and a few other functions
function M.parse(url)
	local comp = {}
	M.setAuthority(comp, "")
	M.setQuery(comp, "")

	local url = tostring(url or '')
	url = url:gsub('#(.*)$', function(v)
		comp.fragment = v
		return ''
	end)
	url =url:gsub('^([%w][%w%+%-%.]*)%:', function(v)
		comp.scheme = v:lower()
		return ''
	end)
	url = url:gsub('%?(.*)', function(v)
		M.setQuery(comp, v)
		return ''
	end)
	url = url:gsub('^//([^/]*)', function(v)
		M.setAuthority(comp, v)
		return ''
	end)

	comp.path = url:gsub("([^/]+)", function (s) return encode(decode(s), M.options.legal_in_path) end)

	setmetatable(comp, {
		__index = M,
		__tostring = M.build,
		__concat = concat,
		__div = M.addSegment
	})
	return comp
end

--- removes dots and slashes in urls when possible
-- This function will also remove multiple slashes
-- @param path The string representing the path to clean
-- @return a string of the path without unnecessary dots and segments
function M.removeDotSegments(path)
	local fields = {}
	if string.len(path) == 0 then
		return ""
	end
	local startslash = false
	local endslash = false
	if string.sub(path, 1, 1) == "/" then
		startslash = true
	end
	if (string.len(path) > 1 or startslash == false) and string.sub(path, -1) == "/" then
		endslash = true
	end

	path:gsub('[^/]+', function(c) table.insert(fields, c) end)

	local new = {}
	local j = 0

	for i,c in ipairs(fields) do
		if c == '..' then
			if j > 0 then
				j = j - 1
			end
		elseif c ~= "." then
			j = j + 1
			new[j] = c
		end
	end
	local ret = ""
	if #new > 0 and j > 0 then
		ret = table.concat(new, '/', 1, j)
	else
		ret = ""
	end
	if startslash then
		ret = '/'..ret
	end
	if endslash then
		ret = ret..'/'
	end
	return ret
end

local function reducePath(base_path, relative_path)
	if string.sub(relative_path, 1, 1) == "/" then
		return '/' .. string.gsub(relative_path, '^[%./]+', '')
	end
	local path = base_path
	local startslash = string.sub(path, 1, 1) ~= "/";
	if relative_path ~= "" then
		path = (startslash and '' or '/') .. path:gsub("[^/]*$", "")
	end
	path = path .. relative_path
	path = path:gsub("([^/]*%./)", function (s)
		if s ~= "./" then return s else return "" end
	end)
	path = string.gsub(path, "/%.$", "/")
	local reduced
	while reduced ~= path do
		reduced = path
		path = string.gsub(reduced, "([^/]*/%.%./)", function (s)
			if s ~= "../../" then return "" else return s end
		end)
	end
	path = string.gsub(path, "([^/]*/%.%.?)$", function (s)
		if s ~= "../.." then return "" else return s end
	end)
	local reduced
	while reduced ~= path do
		reduced = path
		path = string.gsub(reduced, '^/?%.%./', '')
	end
	return (startslash and '' or '/') .. path
end

--- builds a new url by using the one given as parameter and resolving paths
-- @param other A string or a table representing a url
-- @return a new url table
function M:resolve(other)
	if type(self) == "string" then
		self = M.parse(self)
	end
	if type(other) == "string" then
		other = M.parse(other)
	end
	if other.scheme then
		return other
	else
		other.scheme = self.scheme
		if not other.authority or other.authority == "" then
			other:setAuthority(self.authority)
			if not other.path or other.path == "" then
				other.path = self.path
				local query = other.query
				if not query or not next(query) then
					other.query = self.query
				end
			else
				other.path = reducePath(self.path, other.path)
			end
		end
		return other
	end
end

--- normalize a url path following some common normalization rules
-- described on <a href="http://en.wikipedia.org/wiki/URL_normalization">The URL normalization page of Wikipedia</a>
-- @return the normalized path
function M:normalize()
	if type(self) == 'string' then
		self = M.parse(self)
	end
	if self.path then
		local path = self.path
		path = reducePath(path, "")
		-- normalize multiple slashes
		path = string.gsub(path, "//+", "/")
		self.path = path
	end
	return self
end

return M
--lua/streamradio_core/string.lua:
return gluapack()()
--lua/streamradio_core/hook.lua:
return gluapack()()
--lua/streamradio_core/json.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.JSON = StreamRadioLib.JSON or {}

local LIB = StreamRadioLib.JSON
table.Empty(LIB)

local catchAndErrorNoHaltWithStack = StreamRadioLib.Util.CatchAndErrorNoHaltWithStack

function LIB.Encode(data, prettyPrint)
	if not istable(data) then
		data = {data}
	end

	local status, json = catchAndErrorNoHaltWithStack(util.TableToJSON, data)
	if not status then
		return nil
	end

	if not json then
		return nil
	end

	json = StreamRadioLib.String.NormalizeNewlines(json, "\n")
	return json
end

function LIB.Decode(json)
	json = tostring(json or "")
	json = StreamRadioLib.String.NormalizeNewlines(json, "\n")

	json = string.gsub(json, "//.-\n" , "\n")    -- singleline comment
	json = string.gsub(json, "/%*.-%*/" , "\n")  -- multiline comment

	json = string.gsub(json, ",([%s]*)([%]%}])", "%1%2")  -- trailing comma of arrays/objects

	json = string.gsub(json, "\n[%s]*", "\n")     -- remove all spaces at the start of lines
	json = string.gsub(json, "[%s\n]*\n", "\n")   -- remove all empty lines and all spaces at the end of lines
	json = string.gsub(json, "^\n", "")           -- remove first empty new line
	json = string.gsub(json, "\n$", "")           -- remove last empty new line

	json = string.Trim(json)

	if json == "" then
		return {}
	end

	local status, data = catchAndErrorNoHaltWithStack(util.JSONToTable, json)

	if not status then
		return nil
	end

	if not data then
		return nil
	end

	if not istable(data) then
		data = {data}
	end

	return data
end

return true


--lua/streamradio_core/models/111as_h500_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- ZENITH Trans-Oceanic H500 Radio
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=1652510511
RADIOMDL.model = "models/props_111as/h500.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(5, -10.15, -5.68)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(-7.40, -9.30, 14.25) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(-7.40,  9.30, 4.85) -- Bottom Right

RADIOMDL.DisplayWidth = 768
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {21,	1000},
	Default	= {20,	700},
	Tooltip	= {18,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--lua/streamradio_core/models/kankan_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Unitra DIORA - Radiowerk Dzierzoniow: KanKan Radio II
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=2891337724
RADIOMDL.model = "models/radio/kankan/kankan.mdl"

RADIOMDL.SpawnAng = Angle(0, 90, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(-8.55, -3, 7.80)
RADIOMDL.SoundAngOffset = Angle(0, -90, 0)

RADIOMDL.DisplayAngles = Angle(0, 0, 82.0)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(-3, -5.00, 10.65) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(-19.00,  -5.00, 5.50) -- Bottom Right

RADIOMDL.DisplayWidth = 1024
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(
	RADIOMDL.DisplayOffset,
	RADIOMDL.DisplayOffsetEnd,
	RADIOMDL.DisplayWidth,
	RADIOMDL.DISPLAY_POS_RIGHT
)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {21,	1000},
	Default	= {20,	700},
	Tooltip	= {18,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--lua/streamradio_core/models/portal_speaker_big.lua:
return gluapack()()
--lua/streamradio_core/models/wire_subwoofer_big.lua:
return gluapack()()
--lua/streamradio_core/filesystem.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Filesystem = StreamRadioLib.Filesystem or {}

local LIB = StreamRadioLib.Filesystem
table.Empty(LIB)

local LIBString = StreamRadioLib.String
local LIBUtil = StreamRadioLib.Util

local g_playlistdir = LIBUtil.GetMainDirectory("playlists")
local g_luaFilesystemDirectory = "streamradio_core/filesystem"
local g_Filesystem = {}
local g_FilesystemBlacklist = {}

local g_emptyFunction = function() end

local g_FolderID = 1
local g_VirtualFolderID = 250
local g_GenericID = ":generic"

local g_VirtualFolderIcon = StreamRadioLib.GetPNGIcon("folder_link")

StreamRadioLib.TYPE_FOLDER = g_FolderID
StreamRadioLib.TYPE_DEFAULT = nil
StreamRadioLib.VALID_FORMATS_EXTENSIONS_LIST = ""

local function getFS(id)
	if not g_Filesystem then return nil end
	if not g_Filesystem.id then return nil end
	if not g_Filesystem.type then return nil end
	if not g_Filesystem.name then return nil end

	if not id then return nil end

	local fs = g_Filesystem.id[id] or g_Filesystem.type[id] or g_Filesystem.name[id]
	if not fs then return nil end

	if fs.type ~= g_GenericID then
		if g_FilesystemBlacklist[fs.id] then return nil end
		if g_FilesystemBlacklist[fs.type] then return nil end
		if g_FilesystemBlacklist[fs.name] then return nil end
	end

	if isfunction(fs.IsInstalled) and not fs:IsInstalled() then
		return nil
	end

	return fs
end

local g_pathLevelsCache = {}

local function AddCommonFunctions(fs)
	if not fs then return end

	function fs:Find(globalpath, vfolder, callback)
		local files = file.Find(globalpath .. "/*_" .. self.type .. ".txt", "DATA", "nameasc")

		files = LIB.FilterInvalidFilesnames(files)

		callback(true, files, nil)
		return true
	end

	function fs:Delete(globalpath, vpath, callback)
		file.Delete(globalpath)
		local deleted = not file.Exists(globalpath, "DATA")
		callback(deleted)

		return deleted
	end

	function fs:Exists(globalpath, vpath)
		if not file.Exists(globalpath, "DATA") then
			return false
		end

		return true
	end

	function fs:CreateDirectoryForFile(globalpath)
		return LIBUtil.CreateDirectoryForFile(globalpath)
	end

	function fs:IsType(globalpath, vpath)
		local ext = string.lower(string.GetExtensionFromFilename(vpath) or "")
		if ext == self.type then
			return true
		end

		return false
	end

	function fs:SavePCall(func, ...)
		if not isfunction(func) then
			return nil
		end

		return pcall(func, ...)
	end

	function fs:GetPathLevels(vpath)
		vpath = string.Trim(vpath or "")

		g_pathLevelsCache = g_pathLevelsCache or {}

		if g_pathLevelsCache[vpath] then
			return g_pathLevelsCache[vpath]
		end

		g_pathLevelsCache[vpath] = nil

		local levels = string.Explode("/", vpath, false) or {}
		local out = {}

		for i, v in ipairs(levels) do
			v = string.Trim(v, "/")
			if v == "" then continue end

			table.insert(out, v)
		end

		if table.IsEmpty(out) then
			return out
		end

		g_pathLevelsCache[vpath] = out
		return out
	end
end

local function loadFilesystem(script)
	script = script or ""
	if script == "" then return nil end

	local scriptpath = g_luaFilesystemDirectory .. "/"
	local scriptfile = scriptpath .. script

	RADIOFS = nil
	RADIOFS = {}

	RADIOFS.scriptpath = scriptpath
	RADIOFS.scriptfile = scriptfile

	AddCommonFunctions(RADIOFS)

	StreamRadioLib.LoadSH(scriptfile, true)

	local name = string.Trim(RADIOFS.name or "")
	local type = string.Trim(RADIOFS.type or "")

	RADIOFS.priority = tonumber(RADIOFS.priority or 0) or 0

	if name == "" then
		RADIOFS = nil
		return nil
	end

	if type == "" then
		RADIOFS = nil
		return nil
	end

	if RADIOFS.disabled then
		RADIOFS = nil
		return nil
	end

	local fs = RADIOFS
	RADIOFS = nil

	return fs
end

local function SetupPath(folder1, folder2)
	folder1 = folder1 or ""
	folder2 = folder2 or ""

	if folder1 == "" then return end
	if folder2 == "" then return end

	return folder1 .. "/" .. folder2
end


local function ConvertVirtualFilename(filename)
	filename = filename or ""

	local ext = string.GetExtensionFromFilename(filename) or ""
	if ext == "txt" then
		return filename
	end

	local validext = getFS(ext)
	if not validext then
		return filename
	end

	local noext = string.sub(filename, 0, -(2 + #ext))
	filename = noext .. "_" .. ext .. ".txt"

	return filename
end

local function ConvertGlobalFilename(filename)
	local ext = string.GetExtensionFromFilename(filename) or ""
	if ext ~= "txt" then
		return filename
	end

	local noext = string.StripExtension(filename)

	local vext_tbl = string.Explode("_", noext, false)
	if not vext_tbl then
		return filename
	end

	local vext = vext_tbl[#vext_tbl]
	vext_tbl[#vext_tbl] = nil

	noext = table.concat(vext_tbl, "_")

	local validext = getFS(vext)
	if not validext then
		return filename
	end

	return noext .. "." .. vext
end

local function VirtualPathToGlobal(path, asfolder)
	path = path or ""
	path = SetupPath(g_playlistdir, path) or g_playlistdir

	if not asfolder then
		path = ConvertVirtualFilename(path)
	end

	return path
end

local function SanitizeData(data)
	local tmp = {}
	for k, v in pairs(data) do
		local url = string.Trim(tostring(v.url or v.uri or v.link or v.source or v.path or ""))
		local name = string.Trim(tostring(v.name or v.title or ""))

		if url == "" then
			continue
		end

		if name == "" then
			name = url
		end

		table.insert(tmp, {
			order = tonumber(k or 0) or 0,
			name = name,
			url = url,
		})
	end

	table.SortByMember(tmp, "order", true)

	for i, v in ipairs(tmp) do
		tmp[i].order = nil
	end

	return tmp
end

function LIB.Load()
	local files = file.Find(g_luaFilesystemDirectory .. "/*", "LUA")

	local filesystems = {};

	for _, f in ipairs(files or {}) do
		local fs = loadFilesystem(f)
		if not fs then
			continue
		end

		table.insert(filesystems, fs)
	end

	g_Filesystem = {}
	g_Filesystem.id = {}
	g_Filesystem.type = {}
	g_Filesystem.name = {}

	table.SortByMember(filesystems, "priority", false)

	local index = g_FolderID -- first is folder
	local formats = {}

	for _, fs in ipairs(filesystems) do
		fs.id = index

		local id = fs.id
		local type = fs.type
		local name = fs.name
		local extension = fs.extension or ""

		g_Filesystem.id[id] = fs
		g_Filesystem.type[type] = fs
		g_Filesystem.name[name] = fs

		index = index + 1

		local isDefault = false

		if fs.default and not StreamRadioLib.TYPE_DEFAULT then
			isDefault = true
			StreamRadioLib.TYPE_DEFAULT = id
		end

		if extension ~= "" then
			extension = "*." .. extension

			if isDefault then
				extension = extension .. " (default)"
			end

			table.insert(formats, extension)
		end
	end

	StreamRadioLib.VALID_FORMATS_EXTENSIONS_LIST = table.concat(formats, ", ")
end

function LIB.FilterInvalidFilesnames(filenames)
	if not istable(filenames) then
		filenames = {filenames}
	end

	local results = {}

	for i, filename in ipairs(filenames) do
		if not LIBString.IsValidFilename(filename) then
			continue
		end

		table.insert(results, filename)
	end

	return results
end

function LIB.FilterInvalidFilepaths(filepaths)
	if not istable(filepaths) then
		filepaths = {filepaths}
	end

	local results = {}

	for i, filepath in ipairs(filepaths) do
		if not LIBString.IsValidFilepath(filepath) then
			continue
		end

		table.insert(results, filepath)
	end

	return results
end

function LIB.IsFolder(filetype)
	if not filetype then
		return false
	end

	if filetype == g_FolderID then
		return true
	end

	if filetype == g_VirtualFolderID then
		return true
	end

	filetype = LIB.GetTypeID(filetype)

	if filetype == g_FolderID then
		return true
	end

	if filetype == g_VirtualFolderID then
		return true
	end

	return false
end

function LIB.GetIcon(filetype)
	if not filetype then
		return LIB.GetIcon(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return g_VirtualFolderIcon
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetIcon(g_GenericID)
	end

	if not fs.icon then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetIcon(g_GenericID)
	end

	return fs.icon
end

function LIB.GetTypeID(filetype)
	if not filetype then
		return LIB.GetTypeID(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return g_VirtualFolderID
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetTypeID(g_GenericID)
	end

	return fs.id
end

function LIB.GetTypeName(filetype)
	if not filetype then
		return LIB.GetTypeName(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return "Virtual Folder"
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetTypeName(g_GenericID)
	end

	return fs.name
end

function LIB.GetTypeExt(filetype)
	if not filetype then
		return LIB.GetTypeExt(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return "Virtual Folder"
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetTypeExt(g_GenericID)
	end

	return fs.type
end

function LIB.CanLoadToWhitelist(filetype)
	if not filetype then
		return LIB.CanLoadToWhitelist(g_GenericID)
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return true
		end

		return LIB.CanLoadToWhitelist(g_GenericID)
	end

	return fs.loadToWhitelist or false
end

function LIB.IsEnabledFilesystem(fsid)
	local fs = getFS(fsid)

	if not fs then
		return false
	end

	return true
end

function LIB.CreateFolder(vpath, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false)
		return false
	end

	if LIBString.IsVirtualPath(vpath) then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath, true)

	if LIB.Exists(vpath, g_FolderID) then
		callback(true)
		return true
	end

	file.CreateDir(globalpath)

	if not LIB.Exists(vpath, g_FolderID) then
		callback(false)
		return false
	end

	callback(true)
	return true
end

function LIB.CanReadFormat(filetype)
	if LIB.IsFolder(filetype) then
		return false
	end

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Read then
		return false
	end

	return true
end

function LIB.CanWriteFormat(filetype)
	if LIB.IsFolder(filetype) then
		return false
	end

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Write then
		return false
	end

	return true
end

function LIB.CanCreateFormat(filetype)
	if LIB.IsFolder(filetype) then
		return false
	end

	if not LIB.CanWriteFormat(filetype) then
		return false
	end

	local fs = getFS(filetype)

	if fs.nocreate then
		return false
	end

	return true
end

function LIB.CanDeleteFormat(filetype)
	if LIB.IsFolder(filetype) then
		if LIBString.IsVirtualPath(vpath) then
			return false
		end

		return true
	end

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Delete then
		return false
	end

	return true
end

function LIB.Read(vpath, filetype, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false, nil)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false, nil)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false, nil)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath)

	local fs = getFS(filetype)

	if not fs then
		callback(false, nil)
		return false
	end

	if not fs.Read then
		callback(false, nil)
		return false
	end

	if not fs.Exists then
		callback(false, nil)
		return false
	end

	if not fs:Exists(globalpath, vpath) then
		callback(false, nil)
		return false
	end

	return fs:Read(globalpath, vpath, function(success, data)
		if not success then
			callback(false, nil)
			return
		end

		if not data then
			callback(false, nil)
			return
		end

		data = SanitizeData(data)

		if SERVER then
			local urls = table.MemberValuesFromKey(data, "url")
			StreamRadioLib.Whitelist.UpdateFromPlaylist(vpath, urls)
		end

		callback(success, data)
	end)
end

function LIB.Write(vpath, filetype, data, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath)

	if not data then
		callback(false)
		return false
	end

	data = SanitizeData(data)
	local fs = getFS(filetype)

	if not fs then
		callback(false)
		return false
	end

	if not fs.Write then
		callback(false)
		return false
	end

	return fs:Write(globalpath, vpath, data, function(success, ...)
		if SERVER and success then
			local urls = table.MemberValuesFromKey(data, "url")
			StreamRadioLib.Whitelist.UpdateFromPlaylist(vpath, urls)
			StreamRadioLib.Whitelist.InvalidateCache()
		end

		callback(success, ...)
	end)
end

function LIB.Delete(vpath, filetype, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath, LIB.IsFolder(filetype))

	local fs = getFS(filetype)

	if not fs then
		callback(false)
		return false
	end

	if not fs.Delete then
		callback(false)
		return false
	end

	return fs:Delete(globalpath, vpath, function(success, ...)
		if SERVER and success then
			StreamRadioLib.Whitelist.RemoveByPlaylist(vpath)
			StreamRadioLib.Whitelist.InvalidateCache()
		end

		callback(success, ...)
	end)
end

function LIB.Exists(vpath, filetype)
	if not StreamRadioLib.DataDirectory then
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" or vpath == "/" or vpath == "./" then
		return LIB.IsFolder(filetype)
	end

	local globalpath = VirtualPathToGlobal(vpath, LIB.IsFolder(filetype))

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Exists then
		return false
	end

	return fs:Exists(globalpath, vpath)
end

local isvname = LIBString.IsVirtualPath
local lower = string.lower

local function sorter(a, b)
	local a_name = lower(a.file or "")
	local b_name = lower(b.file or "")

	local a_virtual = isvname(a_name)
	local b_virtual = isvname(b_name)

	if a_virtual == b_virtual then
		return a_name < b_name
	end

	if a_virtual then
		return true
	end

	if b_virtual then
		return false
	end

	return a_name < b_name
end

function LIB.Find(vfolder, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false, nil)
		return false
	end

	vfolder = string.lower(vfolder or "")
	if not LIBString.IsValidFilepath(vfolder) then
		callback(false, nil)
		return false
	end

	local globalpath = SetupPath(g_playlistdir, vfolder) or g_playlistdir

	local wait = {}

	local folderlist = {}
	local filelist = {}
	local nodouble_folder = {}
	local nodouble_files = {}

	for id, fs in ipairs(g_Filesystem.id or {}) do
		if not fs then continue end
		if not getFS(id) then continue end
		if not fs.Find then continue end

		wait[id] = true

		local started = fs:Find(globalpath, vfolder, function(success, files, folders)
			files = files or {}
			folders = folders or {}

			wait[id] = nil

			for i, name in ipairs(folders) do
				local filepath = SetupPath(vfolder, name) or name
				if nodouble_folder[filepath] then continue end

				local typeid = vfolder == "" and g_VirtualFolderID or g_FolderID

				if id == g_FolderID then
					typeid = g_FolderID
				end

				local item = {
					isfolder = true,
					type = typeid,
					fsid = id,
					file = name,
					path = filepath,
				}

				table.insert(folderlist, item)

				nodouble_folder[filepath] = true
			end

			for i, name in ipairs(files) do
				local name = ConvertGlobalFilename(name)

				local filepath = SetupPath(vfolder, name) or name

				if nodouble_files[filepath] then continue end

				local item = {
					isfolder = false,
					type = id,
					fsid = id,
					file = name,
					path = filepath,
				}

				table.insert(filelist, item)

				nodouble_files[filepath] = true
			end
		end)

		if not started then
			wait[id] = nil
		end
	end

	local callcallback = function()
		table.sort(folderlist, sorter)
		table.sort(filelist, sorter)

		local outlist = {}
		table.Add(outlist, folderlist)
		table.Add(outlist, filelist)

		callback(true, outlist)
	end

	StreamRadioLib.Timer.Until("Filesystem_Find_" .. tostring({}), 0.2, function()
		local done = table.IsEmpty(wait)

		if not done then
			return false
		end

		callcallback()
		return true
	end)

	return true
end

function LIB.GuessType(vpath)
	if not StreamRadioLib.DataDirectory then return nil end

	vpath = string.lower(vpath or "")
	if vpath == "" then
		return nil
	end

	if not LIBString.IsValidFilepath(vpath) then
		return nil
	end

	local globalpath = VirtualPathToGlobal(vpath)

	for id, fs in ipairs(g_Filesystem.id or {}) do
		if not fs then continue end
		if not getFS(id) then continue end
		if not fs.IsType then continue end
		if not fs:IsType(globalpath, vpath) then continue end

		return id
	end

	return nil
end

do
	local function ListFS()
		MsgN("List of loaded filesystem")

		local lineFormat = "%5s | %25s | %10s | %7s"
		local topLine = string.format(lineFormat, "ID", "Name", "Type", "Active")

		MsgN(string.format(lineFormat, "ID", "Name", "Type", "Active"))
		MsgN(string.rep("-", #topLine))

		for id, fs in ipairs(g_Filesystem.id or {}) do
			if not fs then continue end
			if fs.id == g_GenericID then continue end
			if fs.type == g_GenericID then continue end


			local isActive = getFS(id) ~= nil
			local line = string.format(lineFormat, fs.id, fs.name, fs.type, isActive and "yes" or "no")

			MsgN(line)
		end
	end

	concommand.Add( "info_streamradio_playlist_filesystem_list", ListFS)
end

local function updateBlacklistFromString(backlist)
	backlist = tostring(backlist or "")
	backlist = string.Explode("[%,%;%|]", backlist, true)

	g_FilesystemBlacklist = {}

	for i, v in ipairs(backlist) do
		v = string.Trim(v)
		g_FilesystemBlacklist[v] = true
	end
end

local flags = bit.bor(FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_GAMEDLL, FCVAR_SERVER_CAN_EXECUTE)

if SERVER then
	flags = bit.bor(flags, FCVAR_ARCHIVE)
end

local CVBacklist = CreateConVar( "sv_streamradio_playlist_filesystem_blacklist", "", flags, "Set the list playlist filesystems to be disabled by type, name or id. Entries are seperated by pipe ('|') or comma (','). See info_streamradio_playlist_filesystem_list for details. Default: ''" )

local oldCVValue = CVBacklist:GetString()
updateBlacklistFromString(oldCVValue)

StreamRadioLib.Hook.Add("Think", "Playlist_Filesystem", function()
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not CVBacklist then return end

	local CVvalue = CVBacklist:GetString()
	if oldCVValue == CVvalue then
		return
	end

	oldCVValue = CVvalue
	updateBlacklistFromString(CVvalue)
end)

return true


--lua/streamradio_core/cache.lua:
return gluapack()()
--lua/streamradio_core/classes/skin_controller.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBNet = StreamRadioLib.Net
local LIBNetwork = StreamRadioLib.Network
local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()

local g_skincache = StreamRadioLib.Util.CreateCacheArray(128)

StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_skin_controller", function()
	g_skincache:Empty()
end)

local function g_encode(value)
	value = {value or {}}
	value = StreamRadioLib.JSON.Encode(value, false) or ""
	value = util.Compress(value) or ""

	return value
end

local function g_decode(value)
	value = value or ""
	value = util.Decompress(value) or ""
	value = StreamRadioLib.JSON.Decode(value) or {}
	value = value[1] or {}

	return value
end

function CLASS:Create()
	BASE.Create(self)

	self.Skin = {}
	self.NetworkPlayerList = {}

	self.Hash = self:CreateListener({
		value = "",
	}, function(this, k, v, oldv)
		if CLIENT then
			self:NetworkSkin()
		else
			self:UpdateSkin()
			self:SetNWString("Hash", v)
		end
	end)

	if CLIENT then
		self:NetReceive("skin", function(this, id, len, ply)
			local skinlen = net.ReadUInt(16)
			local skinencoded = net.ReadData(skinlen)
			local newskindata = g_decode(skinencoded)
			local newhash = LIBNet.ReceiveHash()

			-- Store the result of our request for later use
			g_skincache:Set(newhash, newskindata)
			self:SetSkin(newskindata)
		end)
	else
		LIBNetwork.AddNetworkString("skin")
		LIBNetwork.AddNetworkString("skinrequest")
		LIBNetwork.AddNetworkString("skintoserver")

		self:NetReceive("skinrequest", function(this, id, len, ply)
			self.NetworkPlayerList[ply] = ply

			self:NetworkSkin()
		end)

		self:NetReceive("skintoserver", function(this, id, len, ply)
			self.NetworkPlayerList[ply] = ply

			local players = player.GetHumans()

			for i, thisply in ipairs(players) do
				self.NetworkPlayerList[thisply] = thisply
			end

			local skinlen = net.ReadUInt(16)
			local skinencoded = net.ReadData(skinlen)
			local skindata = g_decode(skinencoded)

			self:SetSkinOnServer(skindata, true)
		end)
	end
end

function CLASS:Remove()
	BASE.Remove(self)
end

function CLASS:NetworkSkin()
	self:QueueCall("NetworkSkinInternal")
end

function CLASS:UpdateSkin()
	self:QueueCall("UpdateSkinInternal")
end

function CLASS:NetworkSkinInternal()
	if CLIENT then
		local hash = self:GetHash()

		if hash ~= "" then
			local cache = g_skincache:Get(hash)

			if cache then
				self:SetSkin(cache)
				return
			end
		end

		self:NetSend("skinrequest")
		return
	end

	self:NetSendToPlayers("skin", function()
		local skinencoded = self:GetSkinEncoded()
		local skinlen = #skinencoded

		net.WriteUInt(skinlen, 16)
		net.WriteData(skinencoded, skinlen)

		LIBNet.SendHash(self:GetHashFromSkin(skinencoded))
	end, self.NetworkPlayerList)

	emptyTableSafe(self.NetworkPlayerList)
end

function CLASS:UpdateSkinInternal()
	self:CallHook("OnUpdateSkin", self:GetSkin())
end

function CLASS:SetSkin(skindata)
	skindata = skindata or {}
	self.Skin = skindata

	self:DelCacheValue("SkinEncoded")

	if SERVER then
		self:CalcHash()
		self:NetworkSkin()
	else
		self:UpdateSkin()
	end
end

function CLASS:_SendSkinToServer()
	if SERVER then return end
	if not self.Network.Active then return end
	if not self._skintoserver then return end

	self:NetSend("skintoserver", function()
		local skinencoded = g_encode(self._skintoserver)
		local skinlen = #skinencoded

		net.WriteUInt(skinlen, 16)
		net.WriteData(skinencoded, skinlen)
	end)

	self._skintoserver = nil
end

function CLASS:SetSkinOnServer(skindata, merge)
	skindata = skindata or {}

	if CLIENT then
		if merge then
			local oldskindata = self._skintoserver or {}
			local newskindata = table.Merge(oldskindata, skindata)

			self._skintoserver = newskindata
		else
			self._skintoserver = skindata
		end

		self:QueueCall("_SendSkinToServer")
		return
	end

	if merge then
		local oldskindata = self:GetSkin()
		local newskindata = table.Merge(oldskindata, skindata)

		self:SetSkin(newskindata)
	else
		self:SetSkin(skindata)
	end
end

function CLASS:GetSkinEncoded()
	local chskinencoded = self:GetCacheValue("SkinEncoded")
	if chskinencoded then return chskinencoded end

	local skinencoded = g_encode(self:GetSkin())
	return self:SetCacheValue("SkinEncoded", skinencoded)
end

function CLASS:GetSkin()
	return self.Skin or {}
end

function CLASS:SetProperty(hierarchy, property, value)
	local skindata = self:GetSkin()

	skindata = StreamRadioLib.SetSkinTableProperty(skindata, hierarchy, property, value)

	self:SetSkin(skindata)
end

function CLASS:SetPropertyOnServer(hierarchy, property, value)
	if SERVER then
		self:SetProperty(hierarchy, property, value)
		return
	end

	local skindata = self._skintoserver or {}
	skindata = StreamRadioLib.SetSkinTableProperty(skindata, hierarchy, property, value)
	self:SetSkinOnServer(skindata, false)
end

function CLASS:GetHashFromSkin(skinEncoded)
	local hash = LIBNetwork.Hash(skinEncoded)
	return hash
end

function CLASS:CalcHash()
	if CLIENT then return end
	if not self.Network.Active then return end

	self:DelCacheValue("SkinEncoded")

	local hash = self:GetHashFromSkin(self:GetSkinEncoded())
	self.Hash.value = hash or ""
end

function CLASS:GetHash()
	local curhash = self.Hash.value or ""

	if CLIENT and self.Network.Active then
		curhash = self:GetNWString("Hash", "")
	end

	return curhash
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)

	if SERVER then
		self:CalcHash()
		return
	end

	local hash = self:GetNWString("Hash", "")
	self.Hash.value = hash

	self:SetNWVarCallback("Hash", "String", function(this, nwkey, oldvar, newvar)
		self.Hash.value = newvar or ""
	end)

	self:NetworkSkin()
	self:UpdateSkin()
end

function CLASS:PreDupe()
	local data = {}

	data.skin = self:GetSkin()

	return data
end

function CLASS:PostDupe(data)
	self:SetSkin(data.skin)
end

return true


--lua/streamradio_core/classes/ui/button.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/button.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.CanHaveLabel = false

	self.Layout.Align = TEXT_ALIGN_RIGHT

	self.ImagePanel = self:AddPanelByClassname("image", true)
	self.ImagePanel:SetPos(0, 0)
	self.ImagePanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.ImagePanel:SetName("image")
	self.ImagePanel:SetNWName("img")
	self.ImagePanel:SetSkinIdentifyer("image")

	self.ImagePanel.OnMaterialChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnMaterialChange")
	end

	self.ImagePanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	self.LabelPanel = self:AddPanelByClassname("label", true)
	self.LabelPanel:SetPos(0, 0)
	self.LabelPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.LabelPanel:SetName("label")
	self.LabelPanel:SetNWName("lbl")
	self.LabelPanel:SetSkinIdentifyer("label")

	self.LabelPanel.OnTextChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnTextChange")
	end

	self.LabelPanel.OnFontChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnFontChange")
	end

	self.LabelPanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	self.SkinMap["color_hover"] = {
		set = "SetHoverColor",
		get = "GetHoverColor",
	}

	self.SkinMap["color_disabled"] = {
		set = "SetDisabledColor",
		get = "GetDisabledColor",
	}

	self.SkinMap["color_foreground_hover"] = {
		set = "SetTextHoverColor",
		get = "GetTextHoverColor",
	}

	self.SkinMap["color_foreground_disabled"] = {
		set = "SetTextDisabledColor",
		get = "GetTextDisabledColor",
	}

	self.SkinMap["color_icon_hover"] = {
		set = "SetIconHoverColor",
		get = "GetIconHoverColor",
	}

	self.SkinMap["color_icon_disabled"] = {
		set = "SetIconDisabledColor",
		get = "GetIconDisabledColor",
	}

	if not SERVER then
		self.Colors.Disabled = Color(128,128,128)
		self.Colors.DisabledText = Color(255,255,255)
		self.Colors.DisabledIcon = Color(255,255,255)

		self.Colors.Hover = Color(192,192,192)
		self.Colors.HoverText = Color(0,0,0)
		self.Colors.HoverIcon = Color(255,255,255)

		self.Colors.NoHover = Color(255,255,255)
		self.Colors.NoHoverText = Color(0,0,0)
		self.Colors.NoHoverIcon = Color(255,255,255)

		self.Colors = self.Colors + function(this, k, v)
			if k == "Main" then return end
			self:QueueCall("UpdateColor")
		end
	end

	self:IconFitToPanel()
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	self:QueueCall("UpdateColor")
	self:QueueCall(self._recallonlaylout)

	local mat_panel = self.ImagePanel
	local text_panel = self.LabelPanel

	if not IsValid(mat_panel) then
		return
	end

	if not IsValid(text_panel) then
		return
	end

	local has_mat = mat_panel:GetMaterial() ~= nil
	local has_text = text_panel:GetText() ~= ""

	if not has_text and not has_mat then
		return
	end

	local w, h = self:GetClientSize()
	local align = self.Layout.Align

	if has_mat and not has_text then
		text_panel:SetSize(0, 0)
		text_panel:SetVisible(false)
		mat_panel:SetSize(w, h)
		mat_panel:SetVisible(true)
		return
	end

	if has_text and not has_mat then
		text_panel:SetSize(w, h)
		text_panel:SetVisible(true)
		mat_panel:SetSize(0, 0)
		mat_panel:SetVisible(false)
		return
	end

	text_panel:SetVisible(true)
	mat_panel:SetVisible(true)

	local mat_size = self:GetSquareSize()
	local padding = self:GetPadding()

	if align == TEXT_ALIGN_RIGHT then
		mat_panel:SetPos(0, 0)
		mat_panel:SetSize(mat_size, mat_size)
		text_panel:SetPos(mat_size + padding, 0)
		text_panel:SetSize(w - mat_size - padding, h)
		return
	end

	if align == TEXT_ALIGN_LEFT then
		mat_panel:SetPos(w - mat_size, 0)
		mat_panel:SetSize(mat_size, mat_size)
		text_panel:SetPos(0, 0)
		text_panel:SetSize(w - mat_size - padding, h)
		return
	end

	local _, text_h = text_panel:GetTextSize()

	if align == TEXT_ALIGN_BOTTOM then
		mat_panel:SetPos(0, 0)
		mat_panel:SetSize(w, h - text_h - padding)
		text_panel:SetPos(0, h - text_h)
		text_panel:SetSize(w, text_h)
		return
	end

	if align == TEXT_ALIGN_TOP then
		mat_panel:SetPos(0, text_h + padding)
		mat_panel:SetSize(w, h - text_h - padding)
		text_panel:SetPos(0, 0)
		text_panel:SetSize(w, text_h)
		return
	end
end

function CLASS:CursorChangedInternal()
	BASE.CursorChangedInternal(self)

	if SERVER then return end
	self:UpdateColor()
end

function CLASS:UpdateColor()
	if SERVER then return end

	if self:IsDisabled() then
		self.Colors.Main = self.Colors.Disabled
		if IsValid(self.LabelPanel) then
			self.LabelPanel:SetColor(self.Colors.DisabledText)
		end

		if IsValid(self.ImagePanel) then
			self.ImagePanel:SetColor(self.Colors.DisabledIcon)
		end

		return
	end

	if self:IsCursorOnPanel() then
		self.Colors.Main = self.Colors.Hover

		if IsValid(self.LabelPanel) then
			self.LabelPanel:SetColor(self.Colors.HoverText)
		end

		if IsValid(self.ImagePanel) then
			self.ImagePanel:SetColor(self.Colors.HoverIcon)
		end

		return
	end

	self.Colors.Main = self.Colors.NoHover
	if IsValid(self.LabelPanel) then
		self.LabelPanel:SetColor(self.Colors.NoHoverText)
	end

	if IsValid(self.ImagePanel) then
		self.ImagePanel:SetColor(self.Colors.NoHoverIcon)
	end
end

function CLASS:GetAlign()
	return self.Layout.Align or TEXT_ALIGN_RIGHT
end

function CLASS:SetAlign(align)
	self.Layout.Align = align or TEXT_ALIGN_RIGHT
end

function CLASS:GetIconAlign(...)
	return self.ImagePanel:GetAlign(...)
end

function CLASS:SetIconAlign(...)
	return self.ImagePanel:SetAlign(...)
end

function CLASS:GetTextAlign(...)
	return self.LabelPanel:GetAlign(...)
end

function CLASS:SetTextAlign(...)
	return self.LabelPanel:SetAlign(...)
end

function CLASS:SetText(...)
	return self.LabelPanel:SetText(...)
end

function CLASS:GetText(...)
	return self.LabelPanel:GetText(...)
end

function CLASS:SetFont(...)
	return self.LabelPanel:SetFont(...)
end

function CLASS:GetFont(...)
	return self.LabelPanel:GetFont(...)
end

function CLASS:GetMaterial(...)
	return self.ImagePanel:GetMaterial(...)
end

function CLASS:SetMaterial(...)
	return self.ImagePanel:SetMaterial(...)
end

function CLASS:GetMaterialName(...)
	return self.ImagePanel:GetMaterialName(...)
end

function CLASS:SetTexture(...)
	return self.ImagePanel:SetTexture(...)
end

function CLASS:SetIcon(...)
	return self.ImagePanel:SetMaterial(...)
end

function CLASS:GetIcon(...)
	return self.ImagePanel:GetMaterial(...)
end

function CLASS:IconSizeToPanel(...)
	self._recallonlaylout = "IconSizeToPanel"
	return self.ImagePanel:TextureSizeToPanel(...)
end

function CLASS:IconFitToPanel(...)
	self._recallonlaylout = "IconFitToPanel"
	return self.ImagePanel:TextureFitToPanel(...)
end

function CLASS:IconSizeToTexture(...)
	self._recallonlaylout = "IconSizeToTexture"
	return self.ImagePanel:TextureSizeToTexture(...)
end

function CLASS:SetColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHover = color
end

function CLASS:GetColor()
	if SERVER then return end

	local col = self.Colors.NoHover
	return col
end

function CLASS:SetHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Hover = color
end

function CLASS:GetHoverColor()
	if SERVER then return end

	local col = self.Colors.Hover
	return col
end

function CLASS:SetDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Disabled = color
end

function CLASS:GetDisabledColor()
	if SERVER then return end

	local col = self.Colors.Disabled
	return col
end

function CLASS:SetTextColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHoverText = color
end

function CLASS:GetTextColor()
	if SERVER then return end

	local col = self.Colors.NoHoverText
	return col
end

function CLASS:SetTextHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.HoverText = color
end

function CLASS:GetTextHoverColor()
	if SERVER then return end

	local col = self.Colors.HoverText
	return col
end

function CLASS:SetTextDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.DisabledText = color
end

function CLASS:GetTextDisabledColor()
	if SERVER then return end

	local col = self.Colors.DisabledText
	return col
end

function CLASS:SetIconColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHoverIcon = color
end

function CLASS:GetIconColor()
	if SERVER then return end

	local col = self.Colors.NoHoverIcon
	return col
end

function CLASS:SetIconHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.HoverIcon = color
end

function CLASS:GetIconHoverColor()
	if SERVER then return end

	local col = self.Colors.HoverIcon
	return col
end

function CLASS:SetIconDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.DisabledIcon = color
end

function CLASS:GetIconDisabledColor()
	if SERVER then return end

	local col = self.Colors.DisabledIcon
	return col
end

function CLASS:DoClick()
	-- Override me
end

function CLASS:OnMouseReleased()
	-- Override me
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--lua/streamradio_core/classes/stream.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local tostring = tostring
local tonumber = tonumber
local isfunction = isfunction
local IsValid = IsValid
local Vector = Vector

local string = string
local math = math
local SERVER = SERVER
local CLIENT = CLIENT

local EmptyVector = Vector()

local BASS3 = nil

local LIBNetwork = StreamRadioLib.Network
local LIBBass = StreamRadioLib.Bass
local LIBError = StreamRadioLib.Error
local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url
local LIBStream = StreamRadioLib.Stream
local LIBString = StreamRadioLib.String

local BASE = CLASS:GetBaseClass()
local g_maxSongLenForCache = 60 * 60 * 1.5 -- 1.5 Hours

local function LoadBass()
	local hasBass = LIBBass.LoadDLL()

	if hasBass and not BASS3 then
		BASS3 = _G.BASS3
	end

	return hasBass
end

local function ChannelIsCacheAble( channel )
	if not IsValid( channel ) then return false end

	local len = channel:GetLength( )
	if len <= 0 then
		return false
	end

	if len > g_maxSongLenForCache then
		return false
	end

	return true
end

local function ChannelStop( channel )
	if not channel then
		return
	end

	channel:Stop()

	if channel.Remove then
		channel:Remove( )
	end

	LIBBass.ClearCache()
	return
end

local retry_timeout_max = 3

local retry_errors_non3d = {
	[41] = true,
	[21] = true,
	[22] = true,
	[2] = true,
	[-1] = true
}

local retry_errors_block = {
	[41] = true,
	[21] = true,
	[22] = true,
	[2] = true,
	[-1] = true
}

local retry_errors_urlblocked = {
	[LIBError.STREAM_ERROR_URL_NOT_WHITELISTED] = true,
	[LIBError.STREAM_ERROR_URL_BLOCKED] = true,
}

local function loadLibs()
	if LIBError.STREAM_ERROR_CFCHTTP_BLOCKED_URI then
		retry_errors_urlblocked[LIBError.STREAM_ERROR_CFCHTTP_BLOCKED_URI] = true
	end
end

function CLASS:Create()
	BASE.Create(self)

	if loadLibs then
		loadLibs()
		loadLibs = nil
	end

	self.Channel = nil
	self.TimeOffset = 0
	self.ChannelChanged = false
	self.nextUrlBackgroundCheck = 0
	self.urlBackgroundCheckRuns = nil

	self._converter_downloads = {}
	self._cache_downloads = {}

	if CLIENT then
		self.ConVarGlobalVolume = StreamRadioLib.Settings.GetConVar("volume")
		if IsValid(self.ConVarGlobalVolume) then
			self.ConVarGlobalVolume:SetEvent("OnChange", self:GetID(), function()
				self:UpdateChannelVolume()
			end)
		end
	end

	self.URL = self:CreateListener({
		external = "",
		internal = "",
	}, function(this, k, v)
		if k == "external" then
			self.URL.internal = ""

			local rawv = v

			v = string.Trim(tostring(v or ""))
			v = LIBUrl.SanitizeUrl(v)

			if rawv ~= v then
				-- avoid calling it twice on unclean input
				self.URL.external = v
				return
			end

			self:SetNWString("URL", v)

			self.TimeOffset = 0
			self._wouldpredownload = nil
			self._LastMasterState = nil
			self._server_override_timedata = nil
			self.Old_ClientStateListBuffer = nil
			self:SetClientStateOnServer("Time", 0)

			self._isCached = nil
			self._isOnline = nil
			self._interfaceName = nil
			self._isOnlineUrl = LIBUrl.IsOnlineURL(v)
			self._isCheckingUrl = nil

			self.ChannelChanged = true
			self:Update()
		end
	end)

	if CLIENT then
		self.WSData = self:CreateListener({
			WorldSound = false,

			Position = EmptyVector,
			Forward = EmptyVector,
			Velocity = EmptyVector,

			DistanceStart = 0,
			DistanceEnd = 0,

			InnerAngle = 360,
			OuterAngle = 360,
			OutVolume = 1,
		}, function(this, k, v)
			if k == "WorldSound" then
				self:QueueCall("Reconnect")
			end

			self:UpdateChannelWS()
		end)
	end

	self.Volume = self:CreateListener({
		SVMul = 1,
		CLMul = 1,
		MuteSlide = false,
	}, function(this, k, v)
		if k ~= "MuteSlide" then
			v = tonumber(v) or 0
			v = math.Clamp(v, 0, 1)

			self.Volume[k] = v
		end

		if k == "SVMul" then
			self:CallHook("OnVolumeChange", v)
			self:SetNWFloat("Volume", v)
		end

		self:UpdateChannelVolume()
	end)

	self._isseeking = false

	self.StateTable = {
		"Error",
		"Time",
		"ForceTime",
		"Length",
		"Ended",
		"ValidChannel",
	}

	self.StateTable_r = {}

	for i, v in ipairs(self.StateTable) do
		self.StateTable_r[v] = i
	end

	LIBBass.ClearCache()

	self.State = self:CreateListener({
		Error = 0,
		PlayMode = StreamRadioLib.STREAM_PLAYMODE_STOP,
		Length = 0,
		Stopped = true,
		Ended = false,
		Loop = false,
		Muted = false,
		Name = "",
		Seeking = false,
		ValidChannel = false,
		HasBass = CLIENT and LoadBass(),
	}, function(this, k, v)
		if k == "PlayMode" then
			self:UpdateChannelPlayMode()
			self:SetNWInt("PlayMode", v)
			self:CallHook("OnPlayModeChange", v)
		end

		if k == "Loop" then
			self:UpdateChannelLoop()
			self:SetNWBool("Loop", v)
		end

		if k == "Stopped" and v then
			self:CallHook("OnClose")

			if CLIENT then
				self.State.HasBass = LoadBass()
			end
		end

		if k == "Muted" then
			self:UpdateChannelMuted()
			self:CallHook("OnMute", v)

			if CLIENT then
				self.State.HasBass = LoadBass()
			end
		end

		if k == "Name" then
			self:RemoveChannel(true)
			self:Reconnect()
			self:SetNWString("Name", v)
		end

		if k == "Ended" and v then
			self:Pause()
			self:CallHook("OnTrackEnd")
		end

		if k == "HasBass" then
			self:Reconnect()
		end

		if k == "Seeking" then
			if v then
				self._isseeking = true
				self:CallHook("OnSeekingStart")
				self:TimerRemove("seeking")

				if IsValid(self.Channel) then
					self.Channel:Pause()
				end

				-- force seeking to end after 10 secounds
				self:TimerOnce("seeking", 10, function()
					self._targettime = nil
					self._isseeking = false

					if not self.State.Ended then
						self:UpdateChannelPlayMode()
					end

					self:CallHook("OnSeekingEnd")
				end)
			else
				self._targettime = nil
				self:TimerOnce("seeking", 0.2, function()
					self._isseeking = false

					if not self.State.Ended then
						self:UpdateChannelPlayMode()
					end

					self:CallHook("OnSeekingEnd")
				end)
			end

			self.Volume.MuteSlide = v
		end

		self:SetClientStateOnServer(k, v)
	end)

	for i, key in ipairs(self.StateTable) do
		local value = self.State[key]
		if key == "Time" then
			value = value or 0
		end

		if key == "ForceTime" then
			value = -1
		end

		if value == nil then
			continue
		end

		self:SetClientStateOnServer(key, value)
	end

	if SERVER then
		LIBNetwork.AddNetworkString("clientstate")

		self:NetReceive("clientstate", function(this, id, len, ply)
			local bufferlen = net.ReadUInt(16)

			for i = 1, bufferlen do
				local key = net.ReadUInt(4)

				key = self.StateTable[key]
				if not key then return end

				local value = nil

				if key == "Error" then
					value = net.ReadInt(24)
				elseif key == "Time" then
					value = net.ReadDouble()
				elseif key == "ForceTime" then
					value = net.ReadDouble()
				elseif key == "Length" then
					value = net.ReadDouble()
				else
					value = net.ReadBool()
				end

				self:SetClientState(ply, key, value)
			end
		end)
	end

	self:StartFastThink()
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)

	if SERVER then
		self:SetNWFloat("Volume", self.Volume.SVMul)
		self:SetNWString("URL", self.URL.external)
		self:SetNWInt("PlayMode", self.State.PlayMode)
		self:SetNWBool("Loop", self.State.Loop)
		self:SetNWString("Name", self.State.Name)
		return
	end

	self:SetNWVarCallback("Volume", "Float", function(this, nwkey, oldvar, newvar)
		self.Volume.SVMul = newvar
	end)

	self:SetNWVarCallback("URL", "String", function(this, nwkey, oldvar, newvar)
		self.URL.external = newvar
	end)

	self:SetNWVarCallback("PlayMode", "Int", function(this, nwkey, oldvar, newvar)
		self.State.PlayMode = newvar
	end)

	self:SetNWVarCallback("Loop", "Bool", function(this, nwkey, oldvar, newvar)
		self.State.Loop = newvar
	end)

	self:SetNWVarCallback("Name", "String", function(this, nwkey, oldvar, newvar)
		self.State.Name = newvar
	end)

	self.Volume.SVMul = self:GetNWFloat("Volume", 1)
	self.URL.external = self:GetNWString("URL", "")
	self.State.PlayMode = self:GetNWInt("PlayMode", StreamRadioLib.STREAM_PLAYMODE_STOP)
	self.State.Loop = self:GetNWBool("Loop", false)
	self.State.Name = self:GetNWString("Name", "")
end

function CLASS:SetClientStateOnServer(key, value)
	if not self.Network.Active then return end
	if not key then return end
	if not self.StateTable_r[key] then return end

	if SERVER then
		if key ~= "ForceTime" then
			if self._wouldpredownload then return end
		end

		self:SetClientState("SERVER", key, value)
		return
	end

	self.ClientStateListBuffer = self.ClientStateListBuffer or {}
	self.ClientStateListBuffer[key] = value

	self:QueueCall("NetworkClientState")
end

function CLASS:NetworkClientState()
	if SERVER then return end

	self.Old_ClientStateListBuffer = self.Old_ClientStateListBuffer or {}

	local sendbuffer = {}

	for key, value in pairs(self.ClientStateListBuffer or {}) do
		local key_index = self.StateTable_r[key]
		if not key_index then continue end

		if value == self.Old_ClientStateListBuffer[key] then
			continue
		end

		local item = {
			key = key,
			key_index = key_index,
			value = value,
		}

		table.insert(sendbuffer, item)

		self.Old_ClientStateListBuffer[key] = value
	end

	self:NetSend("clientstate", function()
		net.WriteUInt(#sendbuffer, 16)

		for i, v in pairs(sendbuffer) do
			local key = v.key
			local value = v.value

			net.WriteUInt(v.key_index, 4)

			if key == "Error" then
				net.WriteInt(value or 0, 24)
			elseif key == "Time" then
				net.WriteDouble(value or 0)
			elseif key == "ForceTime" then
				net.WriteDouble(value or 0)
			elseif key == "Length" then
				net.WriteDouble(value or 0)
			else
				net.WriteBool(value or false)
			end
		end
	end)
end

function CLASS:CleanUpClientStateList()
	if not self.ClientStateList then
		return
	end

	for pId, state in pairs(self.ClientStateList) do
		if pId == "SERVER" then
			continue
		end

		if StreamRadioLib.IsPlayerNetworkable(pId) then
			continue
		end

		self.ClientStateList[pId] = nil
	end
end

function CLASS:SetClientState(ply, key, value)
	if CLIENT then return end
	if not self.Network.Active then return end

	if not ply then return end
	if not key then return end

	local key_index = self.StateTable_r[key]
	if not key_index then return end

	local pId = nil

	if ply == "SERVER" then
		pId = ply
	else
		pId = StreamRadioLib.GetPlayerId(ply)
	end

	if not pId then return end

	self.ClientStateList = self.ClientStateList or {}
	self.ClientStateList[pId] = self.ClientStateList[pId] or {
		Error = 0,
		Ended = false,
		ValidChannel = false,
		Time = 0,
		Length = -1,
		TimeStamp = self.PlayTime or 0,
	}

	if key == "Time" then
		value = math.max(value, 0)
		self.ClientStateList[pId].TimeStamp = self.PlayTime or 0
	end

	if key == "ForceTime" then
		if value >= 0 then
			if pId ~= "SERVER" then
				self.TimeMaster = nil
				self._LastMasterState = nil
				self._server_override_timedata = nil
			end

			for k, v in pairs(self.ClientStateList) do
				self.ClientStateList[k].Time = value
				self.ClientStateList[k].TimeStamp = self.PlayTime or 0
			end
		end

		value = nil
	end

	self.ClientStateList[pId][key] = value

	if not self:IsValidTimeMaster(self.TimeMaster) then
		self.TimeMaster = nil

		if self:IsValidTimeMaster(pId) then
			self.TimeMaster = pId
			self._LastMasterState = nil
			self._server_override_timedata = nil
		end
	end

	if pId == "SERVER" then
		self:CallHook("OnServerStateChange", ply, key, value)
	else
		self:CallHook("OnClientStateChange", ply, key, value)
	end
end

function CLASS:GetClientStates(plyOrPId)
	if CLIENT then return nil end

	if not plyOrPId then return nil end
	if not self.ClientStateList then return nil end

	if plyOrPId == "SERVER" then
		return self.ClientStateList["SERVER"]
	end

	if not StreamRadioLib.IsPlayerNetworkable(plyOrPId) then
		self:CleanUpClientStateList()
		return nil
	end

	if isentity(plyOrPId) then
		plyOrPId = StreamRadioLib.GetPlayerId(plyOrPId)
	end

	if not plyOrPId then
		return nil
	end

	return self.ClientStateList[plyOrPId]
end

function CLASS:IsValidTimeMaster(plyOrPId)
	if CLIENT then return false end

	local state = self:GetClientStates(plyOrPId)
	if not state then return false end

	local haschannel = state.ValidChannel
	if not haschannel then return false end

	local err = state.Error or 0
	if err ~= 0 then return false end

	local timestamp = state.TimeStamp or 0
	if timestamp < 0 then return false end

	local time = state.Time
	if not time then return false end

	return true
end

function CLASS:GetTimeMasterClientState()
	if self:IsValidTimeMaster(self.TimeMaster) then
		local state = self:GetClientStates(self.TimeMaster)

		if state and not state._comp then
			state._comp = self.TimeMaster
		end

		return state
	end

	self.TimeMaster = nil

	if not self.ClientStateList then
		return nil
	end

	for pId, state in pairs(self.ClientStateList) do
		if not self:IsValidTimeMaster(pId) then continue end

		self.TimeMaster = pId

		if state and not state._comp then
			state._comp = self.TimeMaster
		end

		return state
	end

	return nil
end

function CLASS:CalcTime()
	local thistime = RealTime()
	local oldlt = self._lt or thistime
	self._lt = thistime

	self.TickTime = thistime - oldlt

	self.PlayTime = self.PlayTime or 0

	if self:IsPlayMode() then
		self.PlayTime = self.PlayTime + self.TickTime
	end
end

function CLASS:FastThink()
	self:CalcTime()

	local masterLength = self:GetMasterLength()

	self.State.Ended = self:HasEndedInternal()
	self.State.Seeking = self:_IsSeekingInternal()
	self.State.Length = self:GetLength()
	self.State.ValidChannel = IsValid(self.Channel)

	if SERVER then
		local timeA = self:GetMasterTime()

		if game.SinglePlayer() then
			self:SetNWFloat("MasterTime", timeA)
		else
			local timeB = self:GetNWFloat("MasterTime", 0)
			local dt = math.abs(timeA - timeB)
			local tickTime = engine.TickInterval()

			-- add random noise to avoid uneven network load
			local random = math.random() * 0.2
			local maxDt = 0.4 + random

			if masterLength > 0 then
				maxDt = math.min(math.max(masterLength / 4, tickTime * 4), maxDt)
			end

			if dt >= maxDt then
				self:SetNWFloat("MasterTime", timeA)
			end
		end
	end

	self:SyncTime()
	self:DoUrlBackgroundCheck()

	if CLIENT then
		self:DoUnexpectedStopCheck()
	end
end

function CLASS:DoUnexpectedStopCheck()
	if not self:HasChannel() then
		return
	end

	if self:HasError() then
		return
	end

	if not self:IsStopped() then
		return
	end

	if not self:IsPlayMode() then
		return
	end

	if self:HasEnded() then
		return
	end

	self:KillStream()
end

function CLASS:IsAllowedUrlPair(externalUrl, internalUrl, callback, logFailure)
	self:IsAllowedInternalUrl(internalUrl, function(this, allowed, err)
		-- Ask CFC first (internal URL), so we can show errors right away.
		-- It should appear in a higher priority to the user then the in-addon whitelisting.

		if not allowed then
			callback(this, false, err)
			return
		end

		self:IsAllowedExternalUrl(externalUrl, callback)
	end, logFailure)
end

function CLASS:IsAllowedInternalUrl(url, callback, logFailure)
	StreamRadioLib.Cfchttp.IsAllowedAsync(url, function(allowed)
		if not IsValid(self) then return end

		if not allowed then
			callback(self, allowed, LIBError.STREAM_ERROR_CFCHTTP_BLOCKED_URI)
			return
		end

		callback(self, true, nil)
	end, logFailure)
end

function CLASS:IsAllowedExternalUrl(url, callback)
	if self:CallHook("CanSkipUrlChecks", url) then
		-- Sometimes we want to ignore the addon's whitelist
		callback(self, true, nil)
		return
	end

	local ent = self:GetEntity()
	local context = StreamRadioLib.Whitelist.BuildContext(ent)

	StreamRadioLib.Whitelist.IsAllowedAsync(url, context, function(allowed, blockedByHook)
		if not IsValid(self) then return end

		if not allowed then
			if self:CallHook("CanBypassUrlBlock", url, blockedByHook) then
				-- Sometimes we want to ignore the block, but still to perform the checks.
				callback(self, true, nil)
				return
			end

			if blockedByHook then
				callback(self, allowed, LIBError.STREAM_ERROR_URL_BLOCKED)
				return
			end

			callback(self, false, LIBError.STREAM_ERROR_URL_NOT_WHITELISTED)
			return
		end

		callback(self, true, nil)
	end)
end

function CLASS:DoUrlBackgroundCheck()
	-- This will automatically stop the running stream if its URL is not allowed.
	-- And it also will automatically reconnect the stream if it was blocked/stopped by the whitelist protection.

	if self.urlBackgroundCheckRuns then
		return
	end

	local now = RealTime()

	if self.nextUrlBackgroundCheck > now then
		return
	end

	self.nextUrlBackgroundCheck = now + 1 + math.random() * 9

	if self:GetMuted() then
		return
	end

	if self:IsKilled() then
		return
	end

	if not self:IsActive() then
		return
	end

	if not self:IsOnlineUrl() then
		return
	end

	local externalUrl = self.URL.external
	local internalUrl = self.URL.internal

	if externalUrl == "" then
		return
	end

	if internalUrl == "" then
		return
	end

	self.urlBackgroundCheckRuns = true

	self:IsAllowedUrlPair(externalUrl, internalUrl, function(this, isAllowed)
		self.nextUrlBackgroundCheck = RealTime() + 1 + math.random() * 9
		self.urlBackgroundCheckRuns = nil

		if self:GetMuted() then
			return
		end

		if self:IsKilled() then
			return
		end

		if not self:IsActive() then
			return
		end

		if not self:IsOnlineUrl() then
			return
		end

		local isWhitelistError = retry_errors_urlblocked[self:GetError()]

		if not isAllowed then
			if not isWhitelistError then
				-- Attempt to reconnect respecting the changed rules. It will likely fail and run its complex error handling.
				self:Reconnect()
			end
		else
			if isWhitelistError then
				-- We are allowed to play again, so let's go.
				self:Reconnect()
			end
		end
	end, false)
end

function CLASS:CallEx(func, callnow, ...)
	if callnow then
		self:CallHook(func, ...)
		return
	end

	self:QueueCall(func, ...)
end

function CLASS:Update(callnow)
	self:CallEx("UpdateInternal", callnow)
end

function CLASS:UpdateInternal()
	if not self.Valid then return end
	self.State.Stopped = false

	if self:GetMuted() then
		return
	end

	if self.ChannelChanged then
		self:Connect()
		self.ChannelChanged = false
		return
	end

	if not self:IsActiveOrLoading() then
		self:Connect()
		self.ChannelChanged = false
		return
	end

	self:UpdateChannel()
	return
end

function CLASS:UpdateChannelMuted()
	if self:GetMuted() then
		self:RemoveChannel()
		return
	end

	self:Reconnect()
end

function CLASS:UpdateChannelWS()
	if not self:Is3DChannel() then return end

	local WSData = self.WSData
	local Channel = self.Channel

	Channel:SetPos( WSData.Position, WSData.Forward, WSData.Velocity )
	Channel:Set3DFadeDistance( WSData.DistanceStart, WSData.DistanceEnd )
	Channel:Set3DCone( WSData.InnerAngle, WSData.OuterAngle, WSData.OutVolume )
end

function CLASS:UpdateChannelVolume()
	if SERVER then return end
	if not self.Valid then return end
	if not IsValid( self.ConVarGlobalVolume ) then return end
	if not IsValid( self.Channel ) then return end

	local boost3d = self:Is3DChannel() and 2.00 or 1.00

	local SVvol = self.Volume.SVMul
	local CLvol = self.Volume.CLMul
	local MuteSlide = self.Volume.MuteSlide

	local volume = 0

	if not MuteSlide then
		volume = SVvol * CLvol * self.ConVarGlobalVolume:GetValue() * boost3d
	end

	-- Max 5000% normal volume on all cases.
	volume = math.Clamp(volume, 0, 50)

	self.Channel:SetVolume(volume)
end

function CLASS:UpdateChannel()
	if not self.Valid then return end
	if not IsValid( self.Channel ) then return end

	self:UpdateChannelPlayMode()
	self:UpdateChannelVolume()
	self:UpdateChannelLoop()
	self:UpdateChannelWS()
end

function CLASS:UpdateChannelPlayMode()
	if not self.Valid then return end
	local playmode = self.State.PlayMode

	if self.URL.external == "" then
		self:RemoveChannel(true)
		self.State.Stopped = true
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_STOP then
		self:RemoveChannel(true)
		self.State.Stopped = true
		return
	end

	if not IsValid(self.Channel) then
		self.ChannelChanged = true
		self:Update()
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_PAUSE then
		self.Channel:Pause()
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART then
		self:SetTime(0)
		self.Channel:Play()
		self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_PLAY
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_PLAY then
		self.Channel:Play()
		return
	end
end

function CLASS:UpdateChannelLoop()
	if not self.Valid then return end
	if not IsValid(self.Channel) then return end
	if self.Channel:IsBlockStreamed() then return end

	self.Channel:EnableLooping(self.State.Loop)
end

function CLASS:RemoveChannel(clearlast)
	ChannelStop(self.Channel)

	self._streamTaskUid = nil
	self.urlBackgroundCheckRuns = nil

	self.Channel = nil
	self.State.Error = LIBError.STREAM_OK
	self._tags = nil
	self._isCached = nil
	self._isOnline = nil
	self._interfaceName = nil
	self._isCheckingUrl = nil

	LIBUtil.EmptyTableSafe(self._converter_downloads)
	LIBUtil.EmptyTableSafe(self._cache_downloads)

	if clearlast then
		self.TimeOffset = 0
		self._wouldpredownload = nil
		self._LastMasterState = nil
		self._server_override_timedata = nil

		self.Old_ClientStateListBuffer = nil
		self:SetClientStateOnServer("Time", 0)
	end
end

function CLASS:Remove()
	self:RemoveChannel(true)

	if IsValid(self.ConVarGlobalVolume) then
		self.ConVarGlobalVolume:RemoveEvent("OnChange", self:GetID())
	end

	BASE.Remove(self)
end

local g_string_format = string.format

function CLASS:ToString()
	local baseToString = BASE.ToString

	if not baseToString then
		return nil
	end

	local r = baseToString(self)
	if not self.Valid then
		return r
	end

	local channel = self:GetChannel()
	local channelStr = tostring(channel or "no channel")

	local err = self:GetError()
	local errName = LIBError.GetStreamErrorName(err) or ""

	local str = g_string_format("%s <%s> [err: %i, %s]", r, channelStr, err, errName)
	return str
end

function CLASS:__eq( other )
	if not BASE.__eq(self, other) then return false end
	if self.Channel == other.Channel then return true end

	return false
end

function CLASS:IsDownloading()
	if not self.Valid then return false end
	if not self._converter_downloads then return false end

	return not table.IsEmpty(self._converter_downloads)
end

function CLASS:IsDownloadingToCache()
	if not self.Valid then return false end
	if not self._cache_downloads then return false end

	return not table.IsEmpty(self._cache_downloads)
end

function CLASS:SetBASSEngineEnabled(bool)
	bool = bool or false

	if bool then
		bool = LoadBass()
	end

	self.State.HasBass = bool
end

function CLASS:IsBASSEngineEnabled()
	if not LIBBass.HasLoadedDLL() then return false end
	return self.State.HasBass or false
end

function CLASS:_IsActiveStreamTaskUid(streamTaskUid)
	if not self.Valid then return false end

	if not streamTaskUid then
		ErrorNoHaltWithStack("Bad streamTaskUid!")
		return false
	end

	if self.URL.external == "" then return false end
	if not self._streamTaskUid then return false end
	if self._streamTaskUid ~= streamTaskUid then return false end

	if self:GetMuted() then return false end
	if self.State.Stopped then return false end

	if IsValid(self.Channel) then return false end
	if self:HasError() then return false end

	return true
end

function CLASS:AcceptError(err)
	self:AcceptStream(nil, err)
end

function CLASS:AcceptStream(channel, err)
	local errOk = LIBError.STREAM_OK

	err = tonumber(err or errOk) or errOk

	if not IsValid(channel) or err ~= errOk then
		ChannelStop(channel)
		channel = nil

		if err == errOk then
			err = LIBError.STREAM_ERROR_UNKNOWN
		end
	end

	ChannelStop(self.Channel)

	self:CleanUpClientStateList()

	self._streamTaskUid = nil
	self._isCheckingUrl = nil

	if err == errOk then
		self.Channel = channel
		self._tags = nil
		self.State.Error = errOk

		self:UpdateChannel()
		self:CallHook("OnConnect", self.Channel)
	else
		self.Channel = nil
		self._tags = nil
		self.State.Error = err

		self:SetClientStateOnServer("Time", 0)
		self:CallHook("OnError", self.State.Error)

		-- make sure we also trigger mute on "stopsound" concommand
		if err == LIBError.STREAM_SOUND_STOPPED then
			self:CallHook("OnMute", true)
		end
	end
end

function CLASS:Reconnect()
	self:RemoveChannel()
	self:Connect()
end

function CLASS:Connect()
	self._streamTaskUid = LIBUtil.Uid()
	local streamTaskUid = self._streamTaskUid

	self:TimerOnce("stream", 0.01, function()
		if not self:_IsActiveStreamTaskUid(streamTaskUid) then
			return
		end

		local externalUrl = self.URL.external

		if self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_STOP or externalUrl == "" then
			self:UpdateChannelPlayMode()
			return
		end

		if not self:CallHook("OnSearch", externalUrl) then
			self:AcceptError(LIBError.STREAM_ERROR_FILEOPEN)
			return
		end

		self:StartConnectingProcess(streamTaskUid, false)
	end)
end

function CLASS:StartConnectingProcess(streamTaskUid, nodownload)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	if not self.State.HasBass and SERVER then
		self:AcceptError(LIBError.STREAM_ERROR_MISSING_GM_BASS3)
		return
	end

	local externalUrl = self.URL.external

	StreamRadioLib.Interface.Convert(externalUrl, function(interface, success, internalUrl, errorcode)
		if not self:_IsActiveStreamTaskUid(streamTaskUid) then
			return
		end

		if not interface then
			self:AcceptError(LIBError.STREAM_ERROR_UNKNOWN)
			return
		end

		self.URL.internal = internalUrl

		local isOnline = interface.online
		local isCached = interface.cache
		local interfaceName = interface.name

		self._isCached = isCached
		self._isOnline = isOnline
		self._interfaceName = interfaceName

		if not success then
			self:AcceptError(errorcode)
			return
		end

		self:IsAllowedUrlPair(externalUrl, internalUrl, function(this, allowed, blockErrorCode)
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then
				return
			end

			if not allowed then
				self:AcceptError(blockErrorCode)
				return
			end

			if not isOnline then
				self:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
				return
			end

			local downloadFirst = interface.downloadFirst

			if isCached then
				downloadFirst = false
			end

			if nodownload then
				downloadFirst = false
			end

			-- Avoid many connection requests starting at once by adding a random delay
			local loadBalanceTimeout = 0.25 + math.random() * 0.75

			self:TimerOnce("stream", loadBalanceTimeout, function()
				if not downloadFirst then
					self:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
					return
				end

				self:RunConnectingProcessWithDownload(streamTaskUid, interface, internalUrl)
			end)
		end, true)
	end)
end

function CLASS:RunConnectingProcessWithDownload(streamTaskUid, interface, internalUrl)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	local canDownload = self:CallHook("OnDownload", internalUrl, interface)

	if not canDownload then
		self:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
		return
	end

	local downloadTimeout = interface.downloadTimeout or 0
	local externalUrl = self.URL.external

	local function afterConvertedDownload()
		if not IsValid(self) then return end

		self:TimerRemove("download_timeout")

		if not self._converter_downloads[streamTaskUid] then return end
		self._converter_downloads[streamTaskUid] = nil

		if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

		-- restart the process, so we can switch to a newly created cache

		self:SetTime(0)
		self:StartConnectingProcess(streamTaskUid, true)
	end

	self._converter_downloads[streamTaskUid] = true
	self._wouldpredownload = true

	self:TimerRemove("download_timeout")

	if downloadTimeout > 0 then
		self:TimerOnce("download_timeout", downloadTimeout, afterConvertedDownload)
	end

	StreamRadioLib.Cache.Download(internalUrl, afterConvertedDownload, externalUrl)
end

function CLASS:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl)
end

function CLASS:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	local WSData = self.WSData

	local isOnline = interface.online

	state = state or {}
	state = table.Copy(state)

	state.no3d = state.no3d or false
	state.retrycount = state.retrycount or 0

	if state.noBlock == nil then
		state.noBlock = true
	end

	if SERVER then
		state.no3d = true
	end

	if not WSData or not WSData.WorldSound then
		state.no3d = true
	end

	local worldSound = not state.no3d
	local noBlock = state.noBlock

	local errOk = LIBError.STREAM_OK

	local callback = function(channel, err)
		err = tonumber(err or errOk) or errOk

		if not IsValid(self) then
			ChannelStop(channel)
			return
		end

		if not self:_IsActiveStreamTaskUid(streamTaskUid) then
			ChannelStop(channel)
			return
		end

		if not IsValid(channel) or err ~= errOk then
			ChannelStop(channel)
			channel = nil

			if err == errOk then
				err = LIBError.STREAM_ERROR_UNKNOWN
			end
		end

		self:_ConnectChannelCallback(streamTaskUid, channel, err, interface, internalUrl, state)
	end

	local hasBass = self.State.HasBass

	if isOnline then
		LIBStream.PlayOnline(internalUrl, hasBass, worldSound, noBlock, callback)
		return
	end

	LIBStream.PlayOffline(internalUrl, hasBass, worldSound, noBlock, callback)
end

local function debugRetry(format, err, externalUrl, internalUrl, ...)
	if not LIBUtil.IsDebug() then return end

	local text = string.format(format, ...)

	local errorInfo = LIBError.GetStreamErrorInfo(err)

	local errorCode = errorInfo.id
	local errorName = errorInfo.name

	StreamRadioLib.Print.Debug(
		"%s\n- Error: %d, %s\n- External URL: %s\n- Internal URL: %s",
		text,
		errorCode,
		errorName,
		externalUrl,
		internalUrl
	)
end

function CLASS:_ConnectChannelCallback(streamTaskUid, channel, err, interface, internalUrl, state)
	local externalUrl = self.URL.external

	state = state or {}

	local no3d = state.no3d
	local noBlock = state.noBlock
	local isOnline = interface.online

	local retryDelay = isOnline and 2 or 0

	-- retry max 3 times on timeout
	if err == LIBError.STREAM_ERROR_TIMEOUT then
		local retrycount = state.retrycount

		if retrycount >= retry_timeout_max then
			debugRetry(
				"[Timeout] Timeout after %d attempts.",
				err,
				externalUrl,
				internalUrl,
				retrycount
			)

			self:AcceptError(err)
			return
		end

		if not self:CallHook("OnRetry", err, internalUrl, state, interface) then
			self:AcceptError(err)
			return
		end

		self:TimerOnce("stream", retryDelay, function()
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

			retrycount = retrycount + 1
			state.retrycount = retrycount

			debugRetry(
				"[Timeout] Retrying stream after timeout, attempt #%d / %d.",
				err,
				externalUrl,
				internalUrl,
				retrycount,
				retry_timeout_max
			)

			self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
		end)

		return
	end

	state.retrycount = 0

	-- retry in Non-3D if 3D is not working
	if not no3d and retry_errors_non3d[err] then
		if not self:CallHook("OnRetry", err, internalUrl, state, interface) then
			self:AcceptError(err)
			return
		end

		self:TimerOnce("stream", retryDelay, function()
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

			state.no3d = true

			debugRetry(
				"[3D sound] Retrying stream without 3D sound after error.",
				err,
				externalUrl,
				internalUrl
			)

			self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
		end)

		return
	end

	-- retry in block mode if no-block mode is not working
	if noBlock and retry_errors_block[err] then
		if not self:CallHook("OnRetry", err, internalUrl, state, interface) then
			self:AcceptError(err)
			return
		end

		self:TimerOnce("stream", retryDelay, function()
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

			state.noBlock = false

			debugRetry(
				"[Block mode] Retrying stream in block mode after error.",
				err,
				externalUrl,
				internalUrl
			)

			self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
		end)

		return
	end

	self:_SaveChannelToCache(streamTaskUid, channel, interface, internalUrl)

	self:AcceptStream(channel, err)
end

function CLASS:_SaveChannelToCache(streamTaskUid, channel, interface, internalUrl)
	local externalUrl = self.URL.external

	local isOnline = interface.online
	local isCache = interface.cache
	local allowCaching = interface.allowCaching

	if not ChannelIsCacheAble(channel) then
		-- remove broken cache file

		if isOnline then
			StreamRadioLib.Cache.DeleteFileForUrl(externalUrl)
		end

		if isCache then
			StreamRadioLib.Cache.DeleteFileRaw(internalUrl)
		end

		return
	end

	if not isOnline then
		return
	end

	if not allowCaching then
		StreamRadioLib.Cache.DeleteFileForUrl(externalUrl)
		return
	end

	local canDownload = self:CallHook("OnDownload", internalUrl, interface)
	if not canDownload then
		return
	end

	local afterCacheDownload = function()
		if not IsValid( self ) then
			return
		end

		self._cache_downloads[streamTaskUid] = nil
	end

	self._cache_downloads[streamTaskUid] = true

	StreamRadioLib.Cache.Download(internalUrl, afterCacheDownload, externalUrl)
end

function CLASS:GetStreamName( )
	if not self.Valid then return "" end
	return self.State.Name or ""
end

function CLASS:SetStreamName(name)
	if not self.Valid then return end
	self.State.Name = name or ""
end

function CLASS:Play( restart )
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.PlayMode = restart and StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART or StreamRadioLib.STREAM_PLAYMODE_PLAY
end

function CLASS:IsPlayMode()
	if not self.Valid then return false end

	if self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_PLAY then return true end
	if self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART then return true end

	return false
end

function CLASS:Pause()
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end
	if self:IsPauseMode() then return end

	self._oldbeforepause = self.State.PlayMode
	self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_PAUSE
end

function CLASS:UnPause()
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	if not self._oldbeforepause then return end
	if not self:IsPauseMode() then return end

	local oldbeforepause = self._oldbeforepause
	self._oldbeforepause = nil

	if oldbeforepause == StreamRadioLib.STREAM_PLAYMODE_PLAY then
		self:Play(self:HasEnded())
		return
	end

	if oldbeforepause == StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART then
		self:Play(true)
		return
	end

	self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:IsPauseMode()
	if not self.Valid then return false end
	return self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_PAUSE
end

function CLASS:Stop()
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:IsStopMode()
	if not self.Valid then return true end
	return self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:SetPlayingState(mode)
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.PlayMode = mode or StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:GetPlayingState()
	if not self.Valid then return StreamRadioLib.STREAM_PLAYMODE_STOP end

	return self.State.PlayMode or StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:GetChannel()
	if not self.Valid then return nil end
	if not IsValid( self.Channel ) then return nil end

	return self.Channel
end

function CLASS:GetError()
	if not self.Valid then
		return LIBError.STREAM_OK
	end

	local state = self.State
	if not state then
		return LIBError.STREAM_OK
	end

	return state.Error or LIBError.STREAM_OK
end

function CLASS:HasError()
	if not self.Valid then return false end
	return self:GetError() ~= LIBError.STREAM_OK
end

function CLASS:HasChannel()
	if not self.Valid then return false end
	return self:GetChannel() ~= nil
end

function CLASS:SetURL(url)
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.URL.external = LIBUrl.SanitizeUrl(url)
end

function CLASS:GetURL()
	if not self.Valid then return "" end

	local url = LIBUrl.SanitizeUrl(self.URL.external)
	return url
end

function CLASS:GetInternalURL()
	if not self.Valid then return "" end

	local url = self.URL.internal
	return url
end

function CLASS:SetLoop(var)
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.Loop = var or false
end

function CLASS:GetLoop()
	if not self.Valid then return false end
	return self.State.Loop or false
end

function CLASS:Set3D(var)
	if SERVER then return end
	if not self.Valid then return end

	self.WSData.WorldSound = var or false
end

function CLASS:Get3D()
	if SERVER then return false end
	if not self.Valid then return false end

	return self.WSData.WorldSound
end

function CLASS:Is3DChannel()
	if SERVER then return false end
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	return self.Channel:Is3D()
end

function CLASS:GetFilename()
	if not self.Valid then return "" end
	if not IsValid( self.Channel ) then return "" end

	return self.Channel:GetFileName( )
end

function CLASS:GetLevel()
	if not self.Valid then return 0, 0 end
	if not IsValid( self.Channel ) then return 0, 0 end

	local L, R = self.Channel:GetLevel()
	return L or 0, R or 0
end

function CLASS:GetAverageLevel()
	local L, R = self:GetLevel()

	return (L + R) / 2
end

function CLASS:GetLength()
	if not self.Valid then return -1 end
	if not IsValid(self.Channel) then return -1 end

	local length = self.Channel:GetLength( )

	if length <= 0 then
		length = -1
	end

	return length
end

function CLASS:GetRealTime()
	if not self.Valid then return 0 end
	if not IsValid( self.Channel ) then return 0 end

	local time = self.Channel:GetTime() or 0
	local length = self.Channel:GetLength()

	if length > 0 then
		time = math.min(time, length)
	end

	time = math.max(time, 0)
	return time
end

function CLASS:GetMasterTime()
	if not self.Valid then return 0 end

	if SERVER then
		local state = self:GetTimeMasterClientState() or self._LastMasterState
		if not state then return 0 end

		if not self._LastMasterState or self._LastMasterState._comp ~= state._comp then
			self._LastMasterState = table.Copy(state)
		end

		if self._server_override_timedata then
			-- Server should be able to override the time even so if not players can hear the stream
			state = self._server_override_timedata
		end

		local thistime = self.PlayTime or 0

		local timestamp = state.TimeStamp
		if not timestamp then return 0 end

		local time = state.Time
		if not time then return 0 end

		local len = self:GetMasterLength()
		local loop = self:GetLoop()

		local offset = thistime - timestamp
		local calctime = math.max(time + offset, 0)

		if len > 0 then
			if loop then
				calctime = calctime % len
			end

			calctime = math.min(calctime, len)
		end

		return calctime
	end

	return self:GetNWFloat("MasterTime", 0)
end

function CLASS:GetMasterLength()
	if not self.Valid then return -1 end

	if SERVER then
		local state = self:GetTimeMasterClientState() or self._LastMasterState
		if not state then return self:GetLength() end

		if not self._LastMasterState or self._LastMasterState._comp ~= state._comp then
			self._LastMasterState = table.Copy(state)
		end

		local len = state.Length or self:GetLength()
		return len
	end

	return self:GetLength()
end

function CLASS:GetTime()
	if not self.Valid then return 0 end
	if not IsValid( self.Channel ) then return 0 end

	local time = self:GetRealTime()
	local length = self:GetLength()

	if self:IsEndless() then
		time = time + self.TimeOffset
	end

	if length > 0 then
		time = math.min(time, length)
	end

	time = math.max(time, 0)
	return time
end

function CLASS:SetTime(time, force)
	if not self.Valid then return end

	time = tonumber(time) or 0

	if time <= 0 then
		time = 0
	end

	self.State.Time = time

	if force then
		self:SetClientStateOnServer("ForceTime", time)

		if SERVER then
			self._server_override_timedata = {
				TimeStamp = self.PlayTime or 0,
				Time = time,
			}
		end
	else
		self:SetClientStateOnServer("ForceTime", -1)
	end

	if not IsValid(self.Channel) then return end

	if not self:CanSeek() then
		return
	end

	self:_SetTimeInternal(time)
end

function CLASS:_SetTimeInternal(time)

	time = tonumber(time) or 0
	time = math.max(time, 0)

	local length = self:GetLength()

	if self:IsEndless() then
		self.TimeOffset = time - self:GetRealTime()
		return
	end

	self.TimeOffset = 0

	if not self:CanSeek() then
		return
	end

	self.State.Seeking = true
	self._isseeking = true

	if self:GetLoop() then
		time = time % length
	end

	time = math.min(time, length)

	self._targettime = time
	self:_SetTimeToTargetInternal()
end

function CLASS:_SetTimeToTargetInternal()
	if not IsValid(self.Channel) then return end
	if not self._targettime then return end

	self:TimerRemove("SetTimeToTargetInternal")

	if not self:CanSeek() then
		return
	end

	if self.State.HasBass then
		self.Channel:SetTime(self._targettime)
		return
	end

	local seakToFunc = function()
		if not IsValid(self.Channel) then return true end
		if not self._targettime then return true end

		if not self:CanSeek() then
			return true
		end

		local length = self:GetLength()

		local thistime = self.Channel:GetTime()
		thistime = math.Clamp(thistime, 0, length)

		local targettime = self._targettime
		targettime = math.Clamp(targettime, 0, length)

		if thistime == targettime then
			return true
		end

		-- an attempt to ease it a bit on the performance impact
		local random = math.random() * 2
		local step = math.Clamp(LIBUtil.RealTimeFps() * 0.03 + random, 2, 15)
		local time = math.Approach(thistime, targettime, step)

		time = math.Clamp(time, 0, length)

		-- set the time in non-decode mode, so we keep sane frame rates
		self.Channel:SetTime(time, true)

		if time == targettime then
			return true
		end

		return false
	end

	-- avoid game hiccup during track seeking
	self:TimerUntil("SetTimeToTargetInternal", 0.001, seakToFunc)
	seakToFunc()
end

function CLASS:SyncTime()
	if not self.Valid then return end
	if LIBUtil.GameIsPaused() then return end
	if self:IsStopMode() then return end

	local maxdelta = 1.5

	local time = self:GetMasterTime()

	local length = self:GetLength()
	local curtime = self:GetTime()
	local loop = self:GetLoop()

	if length > 0 then
		local tickLen = engine.TickInterval()
		local minDelta = tickLen * 2
		local maxStartDelta = tickLen * 4

		if length <= maxStartDelta then
			-- never time synchronize extremely short sounds
			return
		end

		if length <= maxdelta and time > maxStartDelta then
			-- prevent permanent seeking loop for very short sounds (length less then 1.5s)
			-- <maxStartDelta> makes sure all clients start at the same time
			-- but ignore further synchronisations past <maxStartDelta>

			return
		end

		-- limit <maxdelta> to the length minus a small margin
		maxdelta = math.min(maxdelta, math.max(length - minDelta, maxStartDelta))
	end

	local maxdelta_half = maxdelta / 2
	local mintime = time - maxdelta_half
	local maxtime = time + maxdelta_half

	if loop and length > 0 then
		-- make sure we wrap the time around start and end currently
		mintime = (length + mintime) % length
		maxtime = (length + maxtime) % length
	end

	mintime = math.max(mintime, 0)
	maxtime = math.max(maxtime, 0)

	if maxtime > mintime then
		-- classic in between check
		if curtime < mintime then
			return self:_SetTimeInternal(time)
		end

		if curtime > maxtime then
			return self:_SetTimeInternal(time)
		end

		return
	end

	if curtime < mintime and curtime > maxtime then
		-- in between check that wraps around looped time positions
		return self:_SetTimeInternal(time)
	end
end

function CLASS:HasEnded()
	if not self.Valid then
		return false
	end

	return self.State.Ended
end

function CLASS:HasEndedInternal()
	if not self.Valid then
		return false
	end

	local curtime = 0
	local length = 0

	if self:GetMuted() then
		return false
	end

	if self:IsKilled() then
		return false
	end

	if not IsValid( self.Channel ) then
		if SERVER then
			local state = self:GetTimeMasterClientState()
			if not state then return false end

			return state.Ended
		end

		return false
	end

	if self:IsEndless() then
		return false
	end

	if self:GetLoop() then
		return false
	end

	local curtime = self:GetTime()
	local length = self:GetLength()
	local timeleft = length - curtime

	-- Sometimes the time can actually lag a bit behind the actual playback position.
	-- So we add a small tolerance to make sure it doesn't get stuck at like 99.999% of the track.
	local minTimeLeft = engine.TickInterval() * 2

	if timeleft > minTimeLeft then
		return false
	end

	return true
end

function CLASS:_IsSeekingInternal()
	if not self.Valid then return false end
	if not IsValid(self.Channel) then return false end

	if self.State.HasBass then
		return self.Channel:IsSeeking()
	end

	if not self:CanSeek() then return false end

	local targettime = self._targettime
	if not targettime then return false end

	local curtime = self:GetRealTime()
	local maxDelta = engine.TickInterval() * 8

	return math.abs(targettime - curtime) > maxDelta
end

function CLASS:IsSeeking()
	if not self.Valid then return false end
	return self._isseeking or false
end

function CLASS:SetMuted( muted )
	if not self.Valid then return end
	self.State.Muted = muted or false
end

function CLASS:GetMuted()
	if not self.Valid then return false end
	return self.State.Muted or false
end

function CLASS:IsKilled()
	if SERVER then return false end
	if not self.Valid then return false end

	return self:GetError() == LIBError.STREAM_SOUND_STOPPED
end

function CLASS:KillStream()
	if SERVER then return end
	if not self.Valid then return end
	if self:IsKilled() then return end

	self:RemoveChannel()
	self:AcceptError(LIBError.STREAM_SOUND_STOPPED)
end

function CLASS:ReviveStream()
	if SERVER then return end
	if not self.Valid then return end
	if not self:IsKilled() then return end

	self:Reconnect()
end

local function getTagsMetaAsTable(channel)
	local meta = channel:GetTagsMeta()
	if not meta then
		return nil
	end

	local result = LIBString.StreamMetaStringToTable(meta)
	return result
end

local g_tagFunctionMap = {
	[StreamRadioLib.TAG_META] = getTagsMetaAsTable,
	[StreamRadioLib.TAG_HTTP] = "GetTagsHTTP",
	[StreamRadioLib.TAG_ID3] = "GetTagsID3",
	[StreamRadioLib.TAG_OGG] = "GetTagsOGG",
	[StreamRadioLib.TAG_VENDOR] = "GetTagsVendor",
}

function CLASS:GetTag(tag)
	if not self.Valid then
		return nil
	end

	local channel = self.Channel
	if not IsValid(channel) then
		return nil
	end

	self._tags = self._tags or {}

	local tab = self._tags[tag] or {}
	self._tags[tag] = tab

	local data = tab.data or {}
	tab.data = data

	local nextCall = tab.nextCall or 0

	local now = RealTime()
	if nextCall > now then
		return data
	end

	tab.nextCall = now + 1

	if self.State.HasBass then
		channel:GetTag(tag, data)
		return data
	end

	local func = g_tagFunctionMap[tag]

	if isstring(func) then
		func = channel[func]
	end

	if not func then
		return nil
	end

	local result = func(channel)
	if not result then
		return nil
	end

	table.CopyFromTo(result, data)
	return data
end

function CLASS:GetMetaTags()
	if not self.Valid then
		return nil
	end

	local data = self:GetTag(StreamRadioLib.TAG_META)
	if not data then
		return nil
	end

	return data
end


function CLASS:GetSamplingRate()
	if not self.Valid then return -1 end
	if not IsValid( self.Channel ) then return -1 end

	return self.Channel:GetSamplingRate( )
end

function CLASS:GetBitsPerSample()
	if not self.Valid then return -1 end
	if not IsValid( self.Channel ) then return -1 end

	return self.Channel:GetBitsPerSample( )
end

function CLASS:GetAverageBitRate()
	if not self.Valid then return -1 end
	if self.State.HasBass then return -1 end -- not in gm_bass yet
	if not IsValid( self.Channel ) then return -1 end

	return self.Channel:GetAverageBitRate( )
end

function CLASS:GetType()
	if not self.Valid then return -1 end
	if not self.State.HasBass then return "UNKNOWN" end
	if not IsValid( self.Channel ) then return "UNKNOWN" end

	return self.Channel:GetFileFormat( )
end

function CLASS:SetVolume( volume )
	if CLIENT then return end
	if not self.Valid then return end
	self.Volume.SVMul = volume or 1
end

function CLASS:GetVolume()
	if not self.Valid then return 0 end
	return self.Volume.SVMul or 0
end

function CLASS:SetClientVolume( volume )
	if SERVER then return end
	if not self.Valid then return end

	self.Volume.CLMul = volume or 1
end

function CLASS:GetClientVolume()
	if SERVER then return 0 end
	if not self.Valid then return 0 end

	return self.Volume.CLMul or 0
end

function CLASS:Set3DPosition( Pos, For, Vel )
	if SERVER then return end
	if not self.Valid then return end

	local WSData = self.WSData

	WSData.Position = Pos or EmptyVector
	WSData.Forward = For or EmptyVector
	WSData.Velocity = Vel or EmptyVector
end

function CLASS:Get3DPosition()
	if SERVER then return EmptyVector, EmptyVector, EmptyVector end
	if not self.Valid then return EmptyVector, EmptyVector, EmptyVector end

	local WSData = self.WSData

	return WSData.Position or EmptyVector, WSData.Forward or EmptyVector, WSData.Velocity or EmptyVector
end

function CLASS:Set3DFadeDistance( diststart, distend )
	if SERVER then return end
	if not self.Valid then return end

	local WSData = self.WSData

	WSData.DistanceStart = diststart or 0
	WSData.DistanceEnd = distend or 0
end

function CLASS:Get3DFadeDistance()
	if SERVER then return 0, 0 end
	if not self.Valid then return 0, 0 end

	local WSData = self.WSData

	return WSData.DistanceStart or 0, WSData.DistanceEnd or 0
end

function CLASS:Set3DCone( iAngle, oAngle, outvolume )
	if SERVER then return end
	if not self.Valid then return end

	local WSData = self.WSData

	WSData.InnerAngle = iAngle or 0
	WSData.OuterAngle = oAngle or 0
	WSData.OutVolume = outvolume or 0
end

function CLASS:Get3DCone()
	if SERVER then return 0, 0, 0 end
	if not self.Valid then return 0, 0, 0 end

	local WSData = self.WSData

	return WSData.InnerAngle or 0, WSData.OuterAngle or 0, WSData.OutVolume or 0
end

CLASS.Set3dcone = CLASS.Set3DCone
CLASS.Get3dcone = CLASS.Get3DCone

function CLASS:IsOnline()
	if not self.Valid then return false end
	return self._isOnline or false
end

function CLASS:IsOnlineUrl()
	if not self.Valid then return false end
	return self._isOnlineUrl or false
end

function CLASS:GetActiveInterfaceName()
	if not self.Valid then return nil end

	local interfaceName = self._interfaceName
	if not interfaceName then return nil end

	return interfaceName
end

function CLASS:IsCached()
	if not self.Valid then return false end
	return self._isCached or false
end

function CLASS:IsCheckingUrl()
	if not self.Valid then return false end
	return self._isCheckingUrl or false
end

function CLASS:IsStopped()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return true end

	if self.State.HasBass then
		return self.Channel:GetState( ) == BASS3.ENUM.CHANNEL_STOPPED
	else
		return self.Channel:GetState( ) == GMOD_CHANNEL_STOPPED
	end
end

function CLASS:IsPlaying()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self.State.HasBass then
		return self.Channel:GetState( ) == BASS3.ENUM.CHANNEL_PLAYING
	else
		return self.Channel:GetState( ) == GMOD_CHANNEL_PLAYING
	end
end

function CLASS:IsBuffering()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self.State.HasBass then
		return self.Channel:GetState( ) == BASS3.ENUM.CHANNEL_STALLED
	else
		return self.Channel:GetState( ) == GMOD_CHANNEL_STALLED
	end
end

function CLASS:IsLoading()
	if not self.Valid then return false end

	if self:HasChannel() then return false end
	if self:HasError() then return false end
	if self._streamTaskUid then return true end

	return false
end

function CLASS:IsActive()
	if not self.Valid then return false end

	if self._streamTaskUid then return false end
	if self:HasChannel() then return true end
	if self:HasError() then return true end

	return false
end

function CLASS:IsActiveOrLoading()
	if not self.Valid then return false end

	if self._streamTaskUid then return true end
	if self:HasChannel() then return true end
	if self:HasError() then return true end

	return false
end

function CLASS:IsRunning()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self:IsPlaying() then return true end
	if self:IsLoading() then return true end
	if self:IsCheckingUrl() then return true end
	if self:IsBuffering() then return true end
	if self:IsSeeking() then return true end
	if IsValid( self.Channel ) then return true end

	return false
end

function CLASS:IsCacheAble()
	if not self.Valid then return false end

	return ChannelIsCacheAble( self.Channel )
end

function CLASS:IsEndless()
	if not self.Valid then return false end

	if self.State.HasBass then
		if not IsValid( self.Channel ) then return false end
		return self.Channel:IsEndless()
	end

	return self:GetLength() <= 0
end

function CLASS:IsBlockStreamed()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	return self.Channel:IsBlockStreamed( )
end

function CLASS:CanSeek()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self:IsEndless() then return false end
	if self:IsBlockStreamed() then return false end
	if self:IsStopped() then return false end

	local minLen = engine.TickInterval() * 4
	if self:GetMasterLength() <= minLen then return false end

	return true
end

function CLASS:IsLooping()
	if not self.Valid then return false end
	if self:IsEndless() then return false end

	if not IsValid( self.Channel ) then return false end
	return self.Channel:IsLooping()
end

function CLASS:GetSpectrumTable( bars, SPout, func, ... )
	if not self.Valid then return 0 end
	if not IsValid( self.Channel ) then return 0 end
	if self:IsSeeking() then return 0 end

	if ( not bars ) then return 0 end
	if ( bars <= 0 ) then return 0 end

	local count = 0
	local puffersize = bars

	if ( CLIENT ) then
		puffersize = math.Round( bars * ( 22050 / 17000 ) )
	end

	if self.State.HasBass then
		if ( puffersize <= 8 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_16 )
		elseif ( puffersize > 8 ) and ( puffersize <= 16 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_32 )
		elseif ( puffersize > 16 ) and ( puffersize <= 32 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_64 )
		elseif ( puffersize > 32 ) and ( puffersize <= 64 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_128 )
		elseif ( puffersize > 64 ) and ( puffersize <= 128 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_256 )
		elseif ( puffersize > 128 ) and ( puffersize <= 256 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_512 )
		elseif ( puffersize > 256 ) and ( puffersize <= 512 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_1024 )
		elseif ( puffersize > 512 ) and ( puffersize <= 1024 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_2048 )
		elseif ( puffersize > 1024 ) and ( puffersize <= 2048 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_4096 )
		elseif ( puffersize > 2048 ) and ( puffersize <= 4096 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_8192 )
		elseif ( puffersize > 4096 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_16384 )
		end
	else
		if ( puffersize <= 128 ) then
			count = self.Channel:FFT( SPout, FFT_256 )
		elseif ( puffersize > 128 ) and ( puffersize <= 256 ) then
			count = self.Channel:FFT( SPout, FFT_512 )
		elseif ( puffersize > 256 ) and ( puffersize <= 512 ) then
			count = self.Channel:FFT( SPout, FFT_1024 )
		elseif ( puffersize > 512 ) and ( puffersize <= 1024 ) then
			count = self.Channel:FFT( SPout, FFT_2048 )
		elseif ( puffersize > 1024 ) and ( puffersize <= 2048 ) then
			count = self.Channel:FFT( SPout, FFT_4096 )
		elseif ( puffersize > 2048 ) and ( puffersize <= 4096 ) then
			count = self.Channel:FFT( SPout, FFT_8192 )
		elseif ( puffersize > 4096 ) then
			count = self.Channel:FFT( SPout, FFT_16384 )
		end
	end

	if ( SERVER ) then return count end
	if ( not func ) then return count end
	local crash = 100000

	for i = 1, bars do
		crash = crash - 1

		if ( crash == 0 ) then
			error( "Crash!" )
		end

		local bin = math.Round( count / puffersize * i )
		local level = ( SPout[bin] or 0 ) ^ 2
		level = ( math.log10( level ) / 10 )
		level = ( 1 - math.abs( level ) ) ^ 3 * 1.4
		if level <= 0 then continue end
		local Continue = func( i, level, bars, ... )
		if not Continue then break end
	end

	return count
end

local g_tempArray_fft = {}
local g_tempArray_fftc = {}

local g_powres_nobass = nil
local g_powres_bass = nil

local function buildpowres()
	if not g_powres_nobass then
		g_powres_nobass = {}

		g_powres_nobass[0] = FFT_256
		g_powres_nobass[1] = FFT_256
		g_powres_nobass[2] = FFT_256
		g_powres_nobass[3] = FFT_256
		g_powres_nobass[4] = FFT_256
		g_powres_nobass[5] = FFT_256
		g_powres_nobass[6] = FFT_256
		g_powres_nobass[7] = FFT_256
		g_powres_nobass[8] = FFT_512
		g_powres_nobass[9] = FFT_1024
		g_powres_nobass[10] = FFT_2048
		g_powres_nobass[11] = FFT_2048
		g_powres_nobass[12] = FFT_8192
		g_powres_nobass[13] = FFT_16384
		g_powres_nobass[14] = FFT_32768
	end

	if not g_powres_bass then
		if BASS3 and BASS3.ENUM and BASS3.ENUM.FFT_16 then
			g_powres_bass = {}

			g_powres_bass[0] = BASS3.ENUM.FFT_16
			g_powres_bass[1] = BASS3.ENUM.FFT_16
			g_powres_bass[2] = BASS3.ENUM.FFT_16
			g_powres_bass[3] = BASS3.ENUM.FFT_16
			g_powres_bass[4] = BASS3.ENUM.FFT_32
			g_powres_bass[5] = BASS3.ENUM.FFT_64
			g_powres_bass[6] = BASS3.ENUM.FFT_128
			g_powres_bass[7] = BASS3.ENUM.FFT_256
			g_powres_bass[8] = BASS3.ENUM.FFT_512
			g_powres_bass[9] = BASS3.ENUM.FFT_1024
			g_powres_bass[10] = BASS3.ENUM.FFT_2048
			g_powres_bass[11] = BASS3.ENUM.FFT_4096
			g_powres_bass[12] = BASS3.ENUM.FFT_8192
			g_powres_bass[13] = BASS3.ENUM.FFT_16384
			g_powres_bass[14] = BASS3.ENUM.FFT_32768
		end
	end
end

local function getBarFrequency( index, size, samplerate )
	index = math.floor( index or 0 )
	size = math.floor( size or 0 )

	if ( samplerate <= 0 ) then
		return -1
	end

	if ( size <= 0 ) then
		return -1
	end

	if ( index <= 0 ) then
		return -1
	end

	if ( index > size ) then
		size = index
	end

	return (index - 1) / (size * 2) * samplerate
end

function CLASS:GetSpectrum( resolution, func, minfrq, maxfrq )
	if not self.Valid then return false end
	if not IsValid(self.Channel) then return false end
	if self:IsSeeking() then return false end

	buildpowres()

	local powres = self.State.HasBass and g_powres_bass or g_powres_nobass

	resolution = resolution or 0
	resolution = powres[resolution]

	if not resolution then return false end
	if not isfunction(func) then return false end

	local samplerate = self:GetSamplingRate()
	minfrq = minfrq or 0
	maxfrq = maxfrq or samplerate

	local count = self.Channel:FFT( g_tempArray_fft, resolution )

	local index = 0
	for i = 1, count do
		local level = g_tempArray_fft[i] or 0

		local frq = getBarFrequency(i, count, samplerate)

		if frq < 0 then
			continue
		end

		if frq < minfrq then
			continue
		end

		if frq > maxfrq then
			break
		end

		if not func( index, frq, level ) then
			break
		end

		index = index + 1
	end

	return true
end

local function calcAngleFromComplex(R, I)
	R = R or 0
	I = I or 0

	return math.atan2( I, R )
end

local function calcLengthFromComplex(R, I)
	R = R or 0
	I = I or 0

	if ( ( R == 0 ) and ( I == 0 ) ) then
		return 0
	end

	return math.sqrt( ( R ^ 2 ) + ( I ^ 2 ) )
end

function CLASS:GetSpectrumComplex( resolution, func, minfrq, maxfrq )
	if not self.Valid then return false end
	if not IsValid(self.Channel) then return false end
	if self:IsSeeking() then return false end

	buildpowres()

	local powres = self.State.HasBass and g_powres_bass or g_powres_nobass

	resolution = resolution or 0
	resolution = powres[resolution]

	if not resolution then return false end
	if not isfunction(func) then return false end

	local samplerate = self:GetSamplingRate()
	minfrq = minfrq or 0
	maxfrq = maxfrq or samplerate

	local count = 0
	local index = 0

	if self.State.HasBass then
		count = self.Channel:FFTComplex( g_tempArray_fftc, resolution )

		for i = 1, count, 2 do
			local level_R = g_tempArray_fftc[i] or 0
			local level_I = g_tempArray_fftc[i + 1] or 0

			local frq = getBarFrequency(i, count / 2, samplerate)

			if frq < 0 then
				continue
			end

			if frq < minfrq then
				continue
			end

			if frq > maxfrq then
				break
			end

			local level_length = calcLengthFromComplex(level_R, level_I);
			local level_ang = calcAngleFromComplex(level_R, level_I);

			if not func( index, frq, level_length, level_ang, level_R, level_I ) then
				break
			end

			index = index + 1
		end
	else
		count = self.Channel:FFT( g_tempArray_fft, resolution )

		for i = 1, count do
			local level = g_tempArray_fft[i] or 0

			local frq = getBarFrequency(i, count, samplerate)

			if frq < 0 then
				continue
			end

			if frq < minfrq then
				continue
			end

			if frq > maxfrq then
				break
			end

			if not func( index, frq, level, nil, level, nil ) then
				break
			end

			index = index + 1
		end
	end

	return true
end

function CLASS:PreDupe()
	local data = {}

	data.url = self:GetURL()
	data.streamname = self:GetStreamName()
	data.loop = self:GetLoop()
	data.volume = self:GetVolume()

	data.playstate = self.State.PlayMode

	return data
end

function CLASS:PostDupe(data)
	local ent = self:GetEntity()

	if not IsValid(ent) then
		return
	end

	self:SetLoop(data.loop)
	self:SetVolume(data.volume)

	ent:SetDupeURL(data.url, data.streamname, data.playstate ~= StreamRadioLib.STREAM_PLAYMODE_STOP)

	self.State.PlayMode = data.playstate
end

function CLASS:OnSearch(url)
	-- override
	return true -- Allow url to be played
end

function CLASS:CanSkipUrlChecks(url)
	-- override
	return false -- Ignore the build-in whitelist?
end

function CLASS:CanBypassUrlBlock(url, blockedByHook)
	-- override
	return false -- Bypass the URL block?
end

function CLASS:OnClose()
	-- override
end

function CLASS:OnDownload(internalUrl, interface)
	-- override
	return true -- Allow download to cache
end

function CLASS:OnConnect(channel)
	-- override
end

function CLASS:OnRetry(err, internalUrl, state, interface)
	-- override
	return true -- Retry again?
end

function CLASS:OnError(err)
	-- override
end

function CLASS:OnMute(muted)
	-- override
end

return true


--lua/streamradio_core/properties.lua:
return gluapack()()
--lua/streamradio_core/client/cl_help.lua:
local LIBError = StreamRadioLib.Error

local g_helpPanel = StreamRadioLib.g_HelpPanel

if IsValid(g_helpPanel) then
	StreamRadioLib.VR.CloseMenu(g_helpPanel)
	g_helpPanel:Remove()

	g_helpPanel = nil
	StreamRadioLib.g_HelpPanel = nil
end

local function CreateErrorHelpPanel()
	if IsValid( g_helpPanel ) then
		return g_helpPanel
	end

	local ErrorHelpFont = StreamRadioLib.Surface.AddFont(14, 1000, "Lucida Console")
	local HelpPanel = vgui.Create( "DFrame" ) -- The main frame.

	HelpPanel:SetPos( 25, 25 )
	HelpPanel:SetSize( 900, 600 )

	HelpPanel:SetMinWidth( 575 )
	HelpPanel:SetMinHeight( 200 )
	HelpPanel:SetSizable( true )
	HelpPanel:SetDeleteOnClose( false )
	HelpPanel:SetVisible( false )
	HelpPanel:SetTitle( "Stream Radio Error Information" )
	HelpPanel:SetZPos(150)
	HelpPanel:GetParent():SetWorldClicker( true )

	HelpPanel.HelpTextPanel = vgui.Create( "Streamradio_VGUI_ReadOnlyTextEntry", HelpPanel )
	HelpPanel.HelpTextPanel:SetDrawBorder( true )
	HelpPanel.HelpTextPanel:SetPaintBackground( true )
	HelpPanel.HelpTextPanel:SetVerticalScrollbarEnabled( true )
	HelpPanel.HelpTextPanel:SetFont( ErrorHelpFont )
	HelpPanel.HelpTextPanel:SetZPos(100)
	HelpPanel.HelpTextPanel:SetCursor( "beam" )
	HelpPanel.HelpTextPanel:Dock( FILL )

	local ControlPanel = vgui.Create( "DPanel", HelpPanel )
	ControlPanel:SetPaintBackground( false )
	ControlPanel:SetTall( 30 )
	ControlPanel:DockMargin( 0, 5, 0, 0 )
	ControlPanel:SetZPos(200)
	ControlPanel:Dock( BOTTOM )

	local OkButton = vgui.Create( "DButton", ControlPanel )
	OkButton:SetWide( 100 )
	OkButton:SetText( "OK" )
	OkButton:DockMargin( 5, 0, 0, 0 )
	OkButton:SetZPos(300)
	OkButton:Dock( RIGHT )

	OkButton.DoClick = function( self )
		StreamRadioLib.VR.CloseMenu(HelpPanel)
	end

	HelpPanel.CopyButton = vgui.Create( "DButton", ControlPanel )
	HelpPanel.CopyButton:SetWide( 100 )
	HelpPanel.CopyButton:SetText( "Copy to clipboard" )
	HelpPanel.CopyButton:DockMargin( 5, 0, 0, 0 )
	HelpPanel.CopyButton:SetZPos(400)
	HelpPanel.CopyButton:Dock( RIGHT )

	HelpPanel.OnlineHelpButton = StreamRadioLib.Menu.GetLinkButton("View online help")
	HelpPanel.OnlineHelpButton:SetParent(ControlPanel)
	HelpPanel.OnlineHelpButton:SetWide( 175 )
	HelpPanel.OnlineHelpButton:DockMargin( 5, 0, 20, 0 )
	HelpPanel.OnlineHelpButton:SetZPos(500)
	HelpPanel.OnlineHelpButton:Dock( RIGHT )

	HelpPanel.OptionToggleTick = vgui.Create( "DCheckBoxLabel", ControlPanel )
	HelpPanel.OptionToggleTick:SetWide( 125 )
	HelpPanel.OptionToggleTick:SetText( "" )
	HelpPanel.OptionToggleTick:DockMargin( 10, 0, 0, 0 )
	HelpPanel.OptionToggleTick:SetZPos(600)
	HelpPanel.OptionToggleTick:Dock( LEFT )

	g_helpPanel = HelpPanel
	return HelpPanel
end

local function OpenErrorHelpPanel( header, helptext, url, helpurl, userdata )
	header = header or ""
	helptext = helptext or ""
	url = url or ""
	helpurl = helpurl or ""
	userdata = userdata or {}

	local tickboxdata = userdata.userdata or {}
	tickboxdata = tickboxdata.tickbox

	local HelpPanel = CreateErrorHelpPanel()

	if not IsValid( HelpPanel ) then return end
	if not IsValid( HelpPanel.HelpTextPanel ) then return end
	if not IsValid( HelpPanel.CopyButton ) then return end
	if not IsValid( HelpPanel.OnlineHelpButton ) then return end
	if not IsValid( HelpPanel.OptionToggleTick ) then return end

	HelpPanel:SetTitle( "Stream Radio Error Information | " .. header )

	if not StreamRadioLib.VR.IsActive() then
		local X, Y = HelpPanel:GetPos()
		local W, H = HelpPanel:GetSize()

		if X <= 0 then
			X = 25
		end

		if Y <= 0 then
			Y = 25
		end

		W = math.min(ScrW() - 50, W)
		H = math.min(ScrH() - 50, H)

		HelpPanel:SetPos(X, Y)
		HelpPanel:SetSize(W, H)
		HelpPanel:SetSizable(true)
		HelpPanel:SetDraggable(true)
		HelpPanel:GetParent():SetWorldClicker(true)
	else
		HelpPanel:SetPos(0, 0)
		HelpPanel:SetSize(900, 600)
		HelpPanel:SetSizable(false)
		HelpPanel:SetDraggable(false)
		HelpPanel:GetParent():SetWorldClicker(false)
	end

	StreamRadioLib.VR.MenuOpen(
		"StreamRadioErrorInformation",
		HelpPanel,
		true
	)

	if url ~= "" then
		helptext = string.format("%s\n\n%s\n\n%s", header, url, helptext)
	else
		helptext = string.format("%s\n\n%s", header, helptext)
	end

	HelpPanel.HelpTextPanel:SetText( helptext )

	local CopyText = string.gsub( helptext or "", "\n", "\r\n" )
	CopyText = string.Trim( CopyText )
	HelpPanel.CopyButton:SetVisible(CopyText ~= "")

	HelpPanel.CopyButton.DoClick = function( self )
		if ( not IsValid( HelpPanel ) ) then return end
		if ( CopyText == "" ) then return end

		SetClipboardText( CopyText )
	end

	HelpPanel.OnlineHelpButton:SetVisible( helpurl ~= "" )
	HelpPanel.OnlineHelpButton:SetURL( helpurl )

	HelpPanel.OptionToggleTick:SetVisible(tickboxdata ~= nil)

	if tickboxdata then
		HelpPanel.OptionToggleTick:SetText(tickboxdata.text or "???")
		HelpPanel.OptionToggleTick:SetConVar(tickboxdata.cmd or "")
	end

	HelpPanel:InvalidateLayout( true )

	StreamRadioLib.g_HelpPanel = HelpPanel
	return HelpPanel
end

function StreamRadioLib.ShowErrorHelp( errorcode, url )
	local errorInfo = LIBError.GetStreamErrorInfo(errorcode)

	local hasHelpmenu = errorInfo.helpmenu
	if not hasHelpmenu then
		return
	end

	local code = errorInfo.id
	local name = errorInfo.name
	local description = errorInfo.description or ""
	local userdata = errorInfo.userdata

	local header = string.format("Error %i (%s): %s", code, name, description)

	local helptext = errorInfo.helptext or ""
	local helpurl = errorInfo.helpurl or ""

	OpenErrorHelpPanel( header, helptext, url, helpurl, userdata )
end

function StreamRadioLib.ShowPlaylistErrorHelp( )
	StreamRadioLib.ShowErrorHelp(LIBError.PLAYLIST_ERROR_INVALID_FILE)
end

return true


--lua/streamradio_core/client/cl_lib.lua:
return gluapack()()
--lua/streamradio_core/client/cl_menu.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Menu = StreamRadioLib.Menu or {}

local LIB = StreamRadioLib.Menu
table.Empty(LIB)

function LIB.GetLinkButton(text, urlStr)
	text = tostring(text or "")

	local button = vgui.Create("DButton")

	button.SetURL = function(this, url)
		url = tostring(url or "")
		url = string.Trim(url)

		this._url = url

		if url == "" then
			button:SetTooltip(text)
			return
		end

		button:SetTooltip(text .. "\n\nURL: " .. url .. "\n\nRight click to copy the URL to clipboard.")
	end

	button.GetURL = function(this)
		local url = tostring(this._url or "")
		return url
	end

	button:SetURL(urlStr)

	button.DoClick = function(this)
		local url = this:GetURL()

		if url == "" then
			return
		end

		this._infoWasPressed = true

		gui.OpenURL(url)
	end

	button.DoRightClick = function(this)
		local url = this:GetURL()

		if url == "" then
			return
		end

		SetClipboardText(url)
	end

	local oldThink = button.Think
	local infoRed = Color(160, 0, 0)

	button.Think = function(this)
		if oldThink then
			oldThink(this)
		end

		local lastGameMenuVisible = this._gameMenuVisible
		local gameMenuVisible = gui.IsGameUIVisible()
		this._gameMenuVisible = gameMenuVisible

		if lastGameMenuVisible == gameMenuVisible then
			return
		end

		local addInfo = gameMenuVisible and this._infoWasPressed

		this:SetDisabled(addInfo)

		if addInfo then
			if StreamRadioLib.VR.IsActive(ply) then
				this:SetText(text .. "\n[Please confirm on monitor]")
			else
				this:SetText(text .. "\n[Please confirm]")
			end

			this:SetTextColor(infoRed)
		else
			this._infoWasPressed = nil

			this:SetTextColor(nil)
			this:SetText(text)
			this:SetDark(true)
		end

		StreamRadioLib.VR.RenderMenu(this)
	end

	button:Think()
	button:SetImage("icon16/world_go.png")
	button:SetTall(35)

	return button
end

function LIB.GetAdminButton(label, ignoreVR)
	local button = vgui.Create("DButton")

	local function handleAdmin(this)
		local lastIsAdmin = this._isAdmin

		local isAdmin = StreamRadioLib.Util.IsAdmin()
		this._isAdmin = isAdmin

		return lastIsAdmin == isAdmin, isAdmin
	end

	local function handleVR(this)
		if not ignoreVR then
			return false, false
		end

		local lastIsVR = this._isVR

		local isVR = StreamRadioLib.VR.IsActive()
		this._isVR = isVR

		return lastIsVR == isVR, isVR
	end

	local oldThink = button.Think
	button.Think = function(this)
		if oldThink then
			oldThink(this)
		end

		local changeAdmin, isAdmin = handleAdmin(this)
		local changeVR, isVR = handleVR(this)

		if not changeAdmin and not changeVR then
			return
		end

		local locked = isVR or not isAdmin

		this:SetDisabled(locked)

		local tooltip = label
		local text = label

		if locked then
			tooltip = tooltip .. " (not available)"

			if not isAdmin then
				tooltip = tooltip .. "\n - You must be an admin!"
				text = text .. " (Admin only!)"
			end

			if isVR then
				tooltip = tooltip .. "\n - You must not be in VR!"
				text = text .. " (Not in VR!)"
			end
		end

		this:SetTooltip(tooltip)
		this:SetText(text)

		StreamRadioLib.VR.RenderMenu(this)
	end

	button:Think()

	return button
end

function LIB.AddDangerButton(label, data)
	local button = LIB.GetAdminButton(label)

	local message = tostring(data.message or "")
	local icon = data.icon or "icon16/error.png"

	if message ~= "" then
		message = message .. "\nThis can not be undone!"
	end

	button.DoClick = function(this)
		Derma_Query(message, label, "Yes", function()
			RunConsoleCommand(data.cmd)
		end, "No" )
	end

	button:SetImage(icon)

	return button
end

function LIB.GetLabel(text)
	local label = vgui.Create("DLabel")

	label:SetText(text)
	label:SetTooltip(text)

	label:SetWrap(true)
	label:SetDark(true)

	label:SetAutoStretchVertical(true)
	label:SizeToContents()

	return label
end

function LIB.GetWarnLabel(text)
	local label = LIB.GetLabel(text)

	label:SetDark(false)
	label:SetHighlight(true)

	return label
end

function LIB.GetImportantLabel(text)
	local label = LIB.GetLabel(text)

	local skindata = label:GetSkin()

	label:SetTextColor(skindata.Colours.Tree.Hover)

	return label
end


function LIB.GetWhitelistEnabledLabel(text)
	local label = LIB.GetImportantLabel(text)

	local function handleWhitelistEnabled(this)
		local lastisUrlWhitelistEnabled = this._isUrlWhitelistEnabled

		local isUrlWhitelistEnabled = StreamRadioLib.IsUrlWhitelistEnabled() or StreamRadioLib.Cfchttp.CanCheckWhitelist()
		this._isUrlWhitelistEnabled = isUrlWhitelistEnabled

		return lastisUrlWhitelistEnabled == isUrlWhitelistEnabled, isUrlWhitelistEnabled
	end

	local timerName = "GetWhitelistEnabledLabelThink_" .. tostring(label)

	StreamRadioLib.Timer.Interval(timerName, 1, 0, function()
		-- We use this timer as think is not called on label:SetVisible(false).

		if not IsValid(label) then
			StreamRadioLib.Timer.Remove(timerName)
			return
		end

		local changeisWhitelistEnabled, isUrlWhitelistEnabled = handleWhitelistEnabled(label)

		if not changeisWhitelistEnabled then
			return
		end

		if isUrlWhitelistEnabled then
			label:SetVisible(true)
		else
			label:SetVisible(false)
		end

		local parent = label:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end

		label:InvalidateLayout()
		StreamRadioLib.VR.RenderMenu(label)
	end)

	return label
end

function LIB.GetCreditsPanel()
	local credits = LIB.GetLabel(StreamRadioLib.AddonPrefix .. "Made by Grocel")
	return credits
end

function LIB.GetVRInfoPanel()
	local vrinfo = LIB.GetLabel("Powered by VRMod!\n  - VRMod is made by Catse\n  - VR Headset required!\n  - VR is optional, this addon works without VR.")
	return vrinfo
end

function LIB.GetVRErrorPanel()
	local vrinfo = LIB.GetWarnLabel((StreamRadioLib.AddonPrefix or "") .. "\nVRMod is not loaded.\n  - Install VRMod to enable VR support.\n  - VR Headset required!\n  - VR is optional, this addon works without VR.")
	return vrinfo
end

function LIB.GetSpacer(height)
	height = tonumber(height or 0) or 0

	if height <= 0 then
		height = 10
	end

	local spacer = vgui.Create("DPanel")

	spacer:SetMouseInputEnabled(false)
	spacer:SetPaintBackgroundEnabled(false)
	spacer:SetPaintBorderEnabled(false)
	spacer:SetPaintBackground(false)

	spacer:DockMargin(0, 0, 0, 0)
	spacer:DockPadding(0, 0, 0, 0)

	spacer:SetHeight(height)

	return spacer
end

function LIB.GetSpacerLine()
	local spacer = vgui.Create("DPanel")

	spacer.Paint = function( p, w, h )
		derma.SkinHook( "Paint", "MenuSpacer", p, w, h )
	end

	spacer:DockMargin(0, 0, 0, 0)
	spacer:DockPadding(0, 0, 0, 0)

	spacer:SetHeight(1)

	return spacer
end

function LIB.GetFAQButton()
	local button = LIB.GetLinkButton("Show FAQ (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/368542844488661960/")
	return button
end

function LIB.GetWhitelistFAQButton()
	local button = LIB.GetLinkButton("Show Whitelist Info (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668761564/")
	return button
end

function LIB.GetCFCWhitelistFAQButton()
	local button = LIB.GetLinkButton("Show CFC HTTP Whitelist Info (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668766829/")
	return button
end

function LIB.GetVRFAQButton()
	local button = LIB.GetLinkButton("Show VR FAQ (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/2247805152838837222/")
	return button
end

function LIB.GetVRAddonButton()
	local button = LIB.GetLinkButton("Download VRMod (Workshop)", "https://steamcommunity.com/sharedfiles/filedetails/?id=1678408548")
	return button
end

function LIB.GetVRAddonPanelButton()
	local button = vgui.Create("DButton")

	local maintext = "Show VRMod Panel"

	button.DoClick = function(this)
		RunConsoleCommand("vrmod")
	end

	button:SetTooltip(maintext)
	button:SetText(maintext)

	return button
end

function LIB.GetPlaylistEditorButton()
	local button = LIB.GetAdminButton("Show Playlist Editor")

	button.DoClick = function(this)
		RunConsoleCommand("cl_streamradio_playlisteditor")
	end

	return button
end

function LIB.GetOpenToolButton()
	local button = vgui.Create("DButton")

	local maintext = "Stream Radio Tool"

	button.DoClick = function(this)
		spawnmenu.ActivateTool("streamradio", false)

		local parent = this:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end
	end

	button:SetTooltip(maintext)
	button:SetText(maintext)

	return button
end

function LIB.GetOpenSettingsButton()
	local button = vgui.Create("DButton")

	local maintext = "General Settings"

	button.DoClick = function(this)
		spawnmenu.ActivateTool("StreamRadioSettingsPanel_general", true)

		local parent = this:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end
	end

	button:SetTooltip(maintext)
	button:SetText(maintext)

	return button
end

function LIB.GetOpenAdminSettingsButton()
	local button = LIB.GetAdminButton("Admin Settings", true)

	button.DoClick = function(this)
		spawnmenu.ActivateTool("StreamRadioSettingsPanel_admin", true)

		local parent = this:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end
	end

	return button
end

function LIB.PatchComboBox(combobox, label)
	local parent = label:GetParent()

	if IsValid(parent) then
		parent:SetTall(35)
	end

	local updateIcon = function()
		local index = combobox:GetSelectedID()

		if not combobox.ChoiceIcons then
			return
		end

		combobox:SetIcon(combobox.ChoiceIcons[index])
	end

	local oldSetText = combobox.SetText
	combobox.SetText = function(this, ...)
		if oldSetText then
			oldSetText(this, ...)
		end

		StreamRadioLib.Timedcall(updateIcon)
	end

	StreamRadioLib.Timedcall(updateIcon)
	return combobox
end

return true


--lua/streamradio_core/client/cl_vgui.lua:
local StreamRadioLib = StreamRadioLib

local LIBError = StreamRadioLib.Error
local LIBUrl = StreamRadioLib.Url

local PANEL = {}
AccessorFunc( PANEL, "m_showLimit", "ShowLimit" )
AccessorFunc( PANEL, "m_maxLength", "MaxLength" )

function PANEL:Init()
	self:SetShowLimit(false)
	self:SetMaxLength(0)

	self:SetDrawLanguageID(false)
end

function PANEL:PaintOver(w, h)
	if not self:IsEditing() then
		return
	end

	if not self:GetShowLimit() then
		return
	end

	local maxLen = self:GetMaxLength()
	if maxLen <= 0 then
		return
	end

	local len = #self:GetText()

	local cx, cy = self:LocalCursorPos()

	local text = string.format("%i / %i", len, maxLen)

	surface.SetFont(self:GetFont())
	local tw, th = surface.GetTextSize(text)

	local tpw, tph = tw + 6, th + 6

	tpw = math.min(tpw, w - 2)
	tph = math.min(tph, h - 2)

	local tpx, tpy = w - tpw - 1, h - tph - 1

	tpx = math.max(tpx, 0)
	tpy = math.max(tpy, 0)

	if cx >= tpx - 5 and cy >= tpy - 10 and cx < w and cy < h then
		return
	end

	surface.SetDrawColor(190, 255, 255)
	surface.DrawRect(tpx, tpy, tpw, tph)

	surface.SetTextColor( 0, 0, 0)
	surface.SetTextPos(tpx + 3, tpy + 3)
	surface.DrawText(text)
end

function PANEL:GetLength()
	local value = self:GetText()
	return #value
end

function PANEL:AllowInput(change)
	local maxLen = self:GetMaxLength()
	if maxLen <= 0 then
		return false
	end

	local valueLen = self:GetLength()
	local changeLen = #change
	local len = valueLen + changeLen

	if len > maxLen then
		-- Limit reached
		return true
	end

	return false
end

vgui.Register( "Streamradio_VGUI_TextEntryWithLimit", PANEL, "DTextEntry" )


local PANEL = {}
AccessorFunc( PANEL, "m_strValue", "Value" )
AccessorFunc( PANEL, "m_strValue", "Text" )

local STATE_FOUND = 2
local STATE_ERROR = 1
local STATE_IDLE = 0

function PANEL:Init( )
	self:SetPaintBackground( false )
	self.URLIcon = self:Add( "DImageButton" )
	self.URLIcon:SetImage( "icon16/arrow_refresh.png" )
	self.URLIcon:SetWide( 20 )
	self.URLIcon:Dock( RIGHT )
	self.URLIcon:SetStretchToFit( false )
	self.URLIcon:DockMargin( 0, 0, 0, 0 )

	self.URLIcon.DoClick = function( panel )
		if not IsValid(self) then
			return
		end

		self.URLText:OnEnter(self.URLText:GetText())
	end

	self.URLIcon.DoRightClick = function( panel )
		if not IsValid(self) then
			return
		end

		local stream = self.Stream
		if not IsValid(stream) then
			return
		end

		local err = self.Error
		local url = stream:GetURL()

		if not err then
			return
		end

		if err == 0 then
			return
		end

		if url == "" then
			return
		end

		StreamRadioLib.ShowErrorHelp(err, url)
	end

	self.URLText = self:Add( "Streamradio_VGUI_TextEntryWithLimit" )
	self.URLText:SetDrawLanguageID(false)
	self.URLText:SetUpdateOnType(true)
	self.URLText:SetHistoryEnabled(false)
	self.URLText:SetEnterAllowed(true)
	self.URLText:SetMultiline(true)
	self.URLText:Dock(FILL)
	self.URLText:DockMargin( 0, 0, 2, 0 )

	self.URLText:SetShowLimit(true)
	self.URLText:SetMaxLength(StreamRadioLib.STREAM_URL_MAX_LEN_ONLINE)

	if self.URLText.SetPlaceholderText then
		-- Some client have addon conflicts
		-- This causes them to not have the panel:SetPlaceholderText() function

		self.URLText:SetPlaceholderText("Enter file path or online URL")
	end

	self.URLTooltip = StreamRadioLib.STREAM_URL_INFO
	self.URLText:SetTooltip(self.URLTooltip)

	local function callChangeEvent(panel, value, enter)
		local newValue = LIBUrl.SanitizeUrl(value)

		self.m_strValue = newValue
		self:CheckURL()

		if enter then
			self:OnEnter(newValue)
		else
			self:OnChange(newValue)
		end
	end

	local oldGetText = self.URLText.GetText
	self.URLText.GetText = function( panel, change )
		local value = oldGetText(panel)

		value = LIBUrl.SanitizeUrl(value)

		return value
	end

	local oldOnValueChange = self.URLText.OnValueChange
	self.URLText.OnValueChange = function( panel, value, ... )
		if not IsValid(self) then
			return oldOnValueChange( panel, value, ... )
		end

		callChangeEvent(panel, value, false)

		return oldOnValueChange( panel, newValue, ... )
	end

	local oldOnKeyCode = self.URLText.OnKeyCode
	self.URLText.OnKeyCode = function( panel, code, ... )
		oldOnKeyCode( panel, code, ... )

		if not IsValid(self) then
			return
		end

		if code == KEY_ENTER or
			code == KEY_PAD_ENTER or
			code == KEY_ESCAPE
		then
			timer.Simple(0, function()
				if not IsValid(self) then
					return
				end

				if not IsValid(panel) then
					return
				end

				local text = panel:GetText()
				panel:SetText(text)

				panel:OnEnter(text)
				panel:FocusNext()
			end)
		end
	end

	local oldOnEnter = self.URLText.OnEnter
	self.URLText.OnEnter = function( panel, ... )
		if not IsValid(self) then
			return oldOnEnter( panel, ... )
		end

		local value = panel:GetText()
		local newValue = LIBUrl.SanitizeUrl(value)

		if value ~= newValue then
			panel:SetText(newValue)
		end

		callChangeEvent(panel, newValue, true)

		return oldOnEnter( panel, ... )
	end

	local oldOnLoseFocus = self.URLText.OnLoseFocus

	self.URLText.OnLoseFocus = function( panel, ... )
		if not IsValid(self) then
			return oldOnLoseFocus( panel, ... )
		end

		panel:OnEnter(panel:GetText())
		self:OnLoseFocus(...)

		return oldOnLoseFocus( panel, ... )
	end

	self:SetValue("")
end

function PANEL:GetOrCreateStream()
	if not StreamRadioLib and StreamRadioLib.Loaded then
		if IsValid(self.Stream) then
			self.Stream:Remove()
		end

		self.Stream = nil
		self.Error = nil

		return nil
	end

	if IsValid(self.Stream) then
		return self.Stream
	end

	local stream = StreamRadioLib.CreateOBJ("stream")
	if not IsValid( stream ) then
		self.Stream = nil
		self.Error = nil

		return nil
	end

	stream:Set3D(false)
	stream:SetLoop(false)
	stream:SetVolume(0)

	stream.OnConnect = function( thisStream, channel )
		thisStream:Stop()

		if not IsValid(self) then
			return
		end

		self.Error = nil
		self:UpdateURLState(STATE_FOUND)
	end

	stream.OnError = function( thisStream, err )
		thisStream:Stop()

		if not IsValid(self) then
			return
		end

		self.Error = err
		self:UpdateURLState(STATE_ERROR)
	end

	stream.OnRetry = function( thisStream )
		if not IsValid(self) then
			return false
		end

		self:UpdateURLState(STATE_IDLE)
		return true
	end

	stream.OnSearch = function( thisStream )
		if not IsValid( self ) then
			return false
		end

		self:UpdateURLState(STATE_IDLE)
		return true
	end

	stream.CanSkipUrlChecks = function( thisStream )
		if not IsValid( self ) then
			return false
		end

		-- This stream is for the local client only and safe to use.
		-- No whitelist is needed here. Avoids UX problems also.
		return true
	end

	stream.OnDownload = function( thisStream, url, interface )
		return false
	end

	self.Stream = stream
	return stream
end

function PANEL:SetValue(value)
	self.m_strValue = tostring(value or "")
	self.URLText:SetValue(self.m_strValue)
	self:CheckURL()
end

function PANEL:SetText(value)
	self.m_strValue = tostring(value or "")
	self.URLText:SetText(self.m_strValue)
	self:CheckURL()
end

function PANEL:SetShowLimit(showLimit)
	self.URLText:SetShowLimit(showLimit)
end

function PANEL:GetShowLimit()
	return self.URLText:GetShowLimit()
end

function PANEL:SetMaxLength(maxLen)
	self.URLText:SetMaxLength(maxLen)
end

function PANEL:GetMaxLength()
	return self.URLText:GetMaxLength()
end

function PANEL:SetMultiline(multiline)
	self.URLText:SetMultiline(multiline)
end

function PANEL:GetMultiline()
	return self.URLText:GetMultiline()
end

function PANEL:GetTextEntry()
	return self.URLText
end

function PANEL:SetConVar(convar)
	self.URLText:SetConVar(convar)
end

function PANEL:UpdateURLState(state)
	if state == STATE_IDLE then
		self.URLIcon:SetImage("icon16/arrow_refresh.png")
		self.URLIcon:SetTooltip("Checking URL...")
		self.URLText:SetTooltip(self.URLTooltip .. "\n\nChecking URL...")

		StreamRadioLib.VR.RenderMenu(self)
		self:InvalidateLayout()
		return
	end

	local err = self.Error or 0
	local url = ""

	if IsValid(self.Stream) then
		url = self.Stream:GetURL()
	end

	if state == STATE_ERROR then
		local tooltipbase = "The URL is not valid!"
		local tooltip = ""
		local tooltipurl = ""

		if err ~= 0 and url ~= "" then
			self.URLIcon:SetImage("icon16/cross.png")

			local errorInfo = LIBError.GetStreamErrorInfo(err)

			local errorName = errorInfo.name
			local errorDescription = errorInfo.description
			local errorHasHelpmenu = errorInfo.helpmenu

			local errorString = string.format("Error %i (%s): %s", err, errorName, errorDescription)

			tooltip = tooltipbase .. "\n" .. errorString
			tooltipurl = tooltipbase .. "\n" .. errorString

			if errorHasHelpmenu then
				tooltip = tooltip .. "\n\nRight click for more details."
				tooltipurl = tooltip .. "\n\nRight click on the red cross button for more details."
			end
		else
			self.URLIcon:SetImage("icon16/information.png")
			tooltip = "The URL is empty!"
		end

		tooltip = string.Trim(tooltip)
		tooltipurl = string.Trim(tooltipurl)

		self.URLIcon:SetTooltip(tooltip)
		self.URLText:SetTooltip(string.Trim(self.URLTooltip .. "\n\n" .. tooltipurl))

		self:OnURLCheck(false, err, url)

		StreamRadioLib.VR.RenderMenu(self)
		self:InvalidateLayout()

		return
	end

	if state == STATE_FOUND then
		self.URLIcon:SetImage("icon16/accept.png")
		self.URLIcon:SetTooltip("The URL is valid!")
		self.URLText:SetTooltip(self.URLTooltip)

		self:OnURLCheck(true, err, url)

		StreamRadioLib.VR.RenderMenu(self)
		self:InvalidateLayout()

		return
	end
end

function PANEL:CheckURL()
	local stream = self:GetOrCreateStream()

	if IsValid(stream) then
		stream:TimerRemove("gui_url_checker")
	end

	self:UpdateURLState(STATE_IDLE)

	if not IsValid(stream) then
		self.Error = nil
		self:UpdateURLState(STATE_ERROR)
		return false
	end

	if not self.m_strValue then
		self.Error = nil
		self:UpdateURLState(STATE_ERROR)
		stream:SetURL("")
		stream:Stop()

		return false
	end

	if self.m_strValue == "" then
		self.Error = nil
		self:UpdateURLState(STATE_ERROR)
		stream:SetURL("")
		stream:Stop()

		return false
	end

	stream:TimerOnce("gui_url_checker", 0.5, function()
		if not IsValid(stream) then
			return
		end

		if not IsValid(self) then
			return
		end

		self:UpdateURLState(STATE_IDLE)
		stream:SetURL(self.m_strValue)
		stream:Play()
	end)

	return true
end

function PANEL:OnRemove()
	if IsValid(self.Stream) then
		self.Stream:TimerRemove("gui_url_checker")
		self.Stream:Remove()
		self.Stream = nil
	end

	if IsValid(self.URLIcon) then
		self.URLIcon:Remove()
		self.URLIcon = nil
	end

	if IsValid(self.URLText) then
		self.URLText:Remove()
		self.URLText = nil
	end
end

function PANEL:OnEnter( ... )
	-- Override me
end

function PANEL:OnChange( ... )
	-- Override me
end

function PANEL:OnLoseFocus( ... )
	-- Override me
end

function PANEL:OnURLCheck( ... )
	-- Override me
end

vgui.Register( "Streamradio_VGUI_URLTextEntry", PANEL, "DPanel" )

local PANEL = {}

function PANEL:Init( )
	self:SetEditable( true )
	self:SetMultiline( true )
	self:SetDrawLanguageID( false )
	self:SetTabbingDisabled( true )
	self:SetHistoryEnabled( false )
	self:SetEnterAllowed( false )
	self:SetDrawBorder( false )
	self:SetPaintBackground( false )
	self:SetUpdateOnType( true )
	self:SetNumeric( false )
	self:SetVerticalScrollbarEnabled( false )
	self:SetHistoryEnabled( false )
	self:SetCursorColor( Color( 0, 0, 0, 0 ) )
	self:SetCursor( "arrow" )

	self._SetText = self._SetText or self.SetText
	self.SetText = function(this, text, ...)
		this.m_text = tostring(text or "")
		this:_SetText(this.m_text, ...)
	end
end

function PANEL:OnValueChange()
	self:_SetText(self.m_text or "")
	self:KillFocus()
end

vgui.Register( "Streamradio_VGUI_ReadOnlyTextEntry", PANEL, "DTextEntry" )

return true


--lua/streamradio_core/client/cl_whitelist.lua:
return gluapack()()
--lua/streamradio_core/client/cl_whitelist.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Whitelist = StreamRadioLib.Whitelist or {}

local LIB = StreamRadioLib.Whitelist
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url
local LIBNet = StreamRadioLib.Net
local LIBHook = StreamRadioLib.Hook

local g_whitelistCache = LIBUtil.CreateCacheArray(2048)
local g_whitelistCallbacks = {}
local g_whitelistFunction = {}

StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_url_whitelist", function()
	LIB.InvalidateCache()
end)

local g_emptyFunction = function() end

local function callCallbacks(url, ...)
	local callbacksList = g_whitelistCallbacks[url]
	g_whitelistCallbacks[url] = nil

	if not callbacksList then
		return
	end

	for _, callbacks in pairs(callbacksList) do
		for _, callback in ipairs(callbacks) do
			callback(...)
		end
	end
end

LIBNet.Receive("whitelist_check_url_result", function()
	local url = net.ReadString()
	local result = net.ReadBool()
	local blockedByHook = net.ReadBool()

	url = LIBUrl.SanitizeUrl(url)
	if url == "" then
		return
	end

	local now = CurTime()
	local lifetime = blockedByHook and 600 or 3600
	local expires = now + lifetime

	g_whitelistCache:Set(url, {
		result = result,
		blockedByHook = blockedByHook,
	}, expires)

	callCallbacks(url, result, blockedByHook)
end)

LIBNet.Receive("whitelist_clear_cache", function()
	LIB.InvalidateCache()
end)

function LIB.InvalidateCache()
	g_whitelistCache:Empty()
end

local function callCheckFunctions(url)
	for name, func in pairs(g_whitelistFunction) do
		local result = func(url)

		if result == nil then
			continue
		end

		return result
	end

	return false
end

function LIB.AddCheckFunction(name, func)
	g_whitelistFunction[name] = func
end

function LIB.BuildContext(ent, ply)
	context = context or {}

	if not IsValid(ent) or not isentity(ent) then
		ent = nil
	end

	if ent and ent.__IsRadio and not IsValid(ply) then
		ply = ent:GetRealRadioOwner()
	end

	if not IsValid(ply) or not ply:IsPlayer() then
		ply = nil
	end

	context.entity = ent
	context.player = ply

	return context
end

function LIB.SanitizeContext(context)
	context = context or {}

	local ent = context.entity
	local ply = context.player

	if not IsValid(ply) or not ply:IsPlayer() then
		context.player = LocalPlayer()
	end

	if not IsValid(ent) or not isentity(ent) then
		context.entity = nil
	end

	return context
end

function LIB.IsAllowedSync(url, context)
	url = tostring(url or "")

	if url == "" then
		return false, false
	end

	if LIBUrl.IsOfflineURL(url) then
		return true, false
	end

	url = LIBUrl.SanitizeOnlineUrl(url)
	if url == "" then
		return false, false
	end

	context = LIB.SanitizeContext(context)

	local now = CurTime()

	local cacheItem = g_whitelistCache:Get(url, now)
	if cacheItem then
		-- Use cached result instead of asking the server again

		local result = cacheItem.result or false
		local blockedByHook = cacheItem.blockedByHook or false

		return result, blockedByHook
	end

	local ply = context.player
	local ent = context.entity

	local isAllowed = LIBHook.RunCustom("UrlIsAllowed", url, ply, ent)

	if isAllowed == false then
		return false, true
	end

	if not StreamRadioLib.IsUrlWhitelistEnabled() then
		-- allow all URLs if the whitelist is disabled
		return nil, false
	end

	if callCheckFunctions(url) then
		return true, false
	end

	return nil, nil
end

function LIB.IsAllowedAsync(url, context, callback)
	url = tostring(url or "")
	callback = callback or g_emptyFunction

	context = LIB.SanitizeContext(context)
	local ent = context.entity or NULL

	local result, blockedByHook = LIB.IsAllowedSync(url, context)

	if result ~= nil then
		callback(result, blockedByHook or false)
		return
	end

	local callbacksList = g_whitelistCallbacks[url] or {}
	g_whitelistCallbacks[url] = callbacksList

	local callbacks = callbacksList[ent] or {}
	callbacksList[ent] = callbacks

	local hasSend = #callbacks > 0
	table.insert(callbacks, callback)

	if not hasSend then
		LIBNet.Start("whitelist_check_url")
			net.WriteString(url)
			net.WriteEntity(ent)
		net.SendToServer()
	end
end

function LIB.QuickWhitelistAdd(url)
	if not LIBUtil.IsAdmin() then
		return
	end

	url = tostring(url or "")

	if url == "" then
		return
	end

	if LIBUrl.IsOfflineURL(url) then
		return
	end

	url = LIBUrl.SanitizeOnlineUrl(url)
	if url == "" then
		return
	end

	LIBNet.Start("whitelist_quick_whitelist")
		net.WriteString(url)
		net.WriteBool(true)
	net.SendToServer()

	g_whitelistCache:Remove(url)
end

function LIB.QuickWhitelistRemove(url)
	if not LIBUtil.IsAdmin() then
		return
	end

	url = tostring(url or "")

	if url == "" then
		return
	end

	if LIBUrl.IsOfflineURL(url) then
		return
	end

	url = LIBUrl.SanitizeOnlineUrl(url)
	if url == "" then
		return
	end

	LIBNet.Start("whitelist_quick_whitelist")
		net.WriteString(url)
		net.WriteBool(false)
	net.SendToServer()

	g_whitelistCache:Remove(url)
end

function LIB.Load()
	LIB.InvalidateCache()
end

return true


--lua/streamradio_core/filesystem/addon-mx-radio.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

local g_addonname = "MX-Radio"
local g_addonid = ""

RADIOFS.name = g_addonname
RADIOFS.type = g_addonname
RADIOFS.icon = StreamRadioLib.GetPNGIcon("format_radio", true)

RADIOFS.addonname = g_addonname
RADIOFS.addonid = g_addonid

RADIOFS.priority = 100
RADIOFS.nocreate = true
RADIOFS.loadToWhitelist = true

RADIOFS._filepath = "mxradio.txt"
RADIOFS._filename = g_addonname
RADIOFS._filenamelower = string.lower(RADIOFS._filename)

function RADIOFS:IsInFolder(vpath)
	local levels = self:GetPathLevels(vpath)
	local firstlevel = levels[1] or ""

	if firstlevel ~= ":addons" then
		return false
	end

	return true
end

function RADIOFS:IsAddonFile(vpath)
	if not self:IsInFolder(vpath) then
		return false
	end

	vpath = string.lower(string.GetFileFromFilename(vpath))

	if vpath ~= self._filenamelower then
		return false
	end

	return true
end

function RADIOFS:IsInstalled()
	if CLIENT then
		return true
	end

	if self._isInstalled ~= nil then
		return self._isInstalled
	end

	if not isfunction(SetUpStationTable) then
		self._isInstalled = false
		return self._isInstalled
	end

	if not file.Exists(self._filepath, "DATA") then
		self._isInstalled = false
		return self._isInstalled
	end

	self._isInstalled = true
	return self._isInstalled
end

function RADIOFS:IsType(globalpath, vpath)
	return self:IsAddonFile(vpath)
end

function RADIOFS:Find(globalpath, vfolder, callback)
	if not self:IsInstalled() then
		callback(false, nil, nil)
		return false
	end

	if vfolder == "" then
		callback(true, nil, {":addons"})
		return true
	end

	if not self:IsInFolder(vfolder) then
		callback(false, nil, nil)
		return false
	end

	callback(true, {self._filename}, nil)
	return true
end

function RADIOFS:Exists(globalpath, vpath)
	if not self:IsInstalled() then
		return false
	end

	if not self:IsAddonFile(vpath) then
		return false
	end

	return true
end

RADIOFS.Delete = nil

local function decodeAddonfile(RawPlaylist)
	local RawPlaylistTab = string.Split( RawPlaylist, "\n" )
	local Playlist = {}

	for i = 1, #RawPlaylistTab, 2 do
		local url = string.Trim( RawPlaylistTab[i] or "" )
		local name = string.Trim( RawPlaylistTab[i + 1] or "" )

		if name == "" then
			name = url
		end

		if url == "" then
			continue
		end

		Playlist[#Playlist + 1] = {
			name = name,
			url = url
		}
	end

	return Playlist
end

function RADIOFS:Read(globalpath, vpath, callback)
	globalpath = self._filepath

	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = decodeAddonfile(RawPlaylist)
		if not Playlist then
			callback(false, nil)
			return
		end

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	globalpath = self._filepath
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local dataOut = {}
	local Seperator = "\n"

	for i, v in ipairs(data) do
		local name = string.Trim( string.Replace( v.name, Seperator, "" ) )
		local url = string.Trim( string.Replace( v.url, Seperator, "" ) )

		dataOut[#dataOut + 1] = string.format( "%s" .. Seperator .. "%s\n", url, name )
	end

	local DataString = table.concat(dataOut, "")

	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write(DataString)
	f:Close()

	-- Telling the MX-Radio addon to update its playlist.
	self:SavePCall(SetUpStationTable)

	callback(true)
	return true
end

return true


--lua/streamradio_core/filesystem/m3u.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "M3U"
RADIOFS.type = "m3u"
RADIOFS.extension = "m3u"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("table_sound", true)

RADIOFS.priority = 10000
RADIOFS.default = true
RADIOFS.loadToWhitelist = true

local function decodeM3U(RawPlaylist)
	local RawPlaylistTab = string.Split( RawPlaylist, "\n" )
	local AdvancedM3U = string.lower( string.Trim( RawPlaylistTab[1] or "" ) ) == "#extm3u"
	local Playlist = {}

	if not AdvancedM3U then
		for i = 1, #RawPlaylistTab do
			local url = string.Trim( RawPlaylistTab[i] or "" )
			local name = url

			if url == "" then
				continue
			end

			if url[1] == "#" then
				continue
			end

			local item = {
				name = name,
				url = url
			}

			table.insert(Playlist, item)
		end

		callback(true, Playlist)
		return true
	end

	for i = 2, #RawPlaylistTab, 2 do
		local name = string.Trim( string.match( RawPlaylistTab[i], "%s*#EXTINF:%s*%d%s*,%s*([^\n]+)" ) or "" )
		local url = string.Trim( RawPlaylistTab[i + 1] or "" )

		if name == "" then
			name = url
		end

		if url == "" then
			continue
		end

		local item = {
			name = name,
			url = url
		}
		table.insert(Playlist, item)
	end

	return Playlist
end

function RADIOFS:Read(globalpath, vpath, callback)
	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = decodeM3U(RawPlaylist)
		if not Playlist then
			callback(false, nil)
			return
		end

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local dataOut = {}
	local Seperator = "\n"

	dataOut[#dataOut + 1] = "#EXTM3U\n"

	for i, v in ipairs(data) do
		local name = string.Trim(string.Replace(v.name, Seperator, ""))
		local url = string.Trim(string.Replace(v.url, Seperator, ""))

		dataOut[#dataOut + 1] = string.format("#EXTINF:0,%s" .. Seperator .. "%s\n", name, url)
	end

	local DataString = table.concat(dataOut, "")

	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write(DataString)
	f:Close()

	callback(true)
	return true
end

return true


--lua/autorun/suitnrobbersinit.lua:
player_manager.AddValidModel( "Williams Üye Modeli", "models/player/williams/Suits/male_09_closed_coat_tie.mdl" )
list.Set( "PlayerOptionsModel", "Williams Üye Modeli", "models/player/williams/Suits/male_09_closed_coat_tie.mdl" )
--lua/svmod/sh_utilitaries.lua:
function SVMOD:AddPlurial(value)
	if value > 1 then
		return "s"
	end
	return ""
end

function SVMOD:RotateAroundAxis(ang1, ang2)
	ang1:RotateAroundAxis(ang1:Forward(), ang2.p)
	ang1:RotateAroundAxis(ang1:Right(), ang2.r)
	ang1:RotateAroundAxis(ang1:Up(), ang2.y)

	return ang1
end

function SVMOD:DeepCopy(tab)
	local result = table.Copy(tab)

	for k, v in pairs(result) do
		if type(v) == "pixelvis_handle_t" or type(v) == "ProjectedTexture" then
			result[k] = nil
		elseif isvector(v) then
			result[k] = Vector(v.x, v.y, v.z)
		elseif isangle(v) then
			result[k] = Angle(v.x, v.y, v.z)
		elseif istable(v) then
			result[k] = SVMOD:DeepCopy(v)
		end
	end

	return result
end

SVMOD.LOG = {
	Info = Color(102, 181, 255),
	Alert = Color(255, 186, 102),
	Error = Color(255, 102, 102)
}

function SVMOD:PrintConsole(type, message)
	MsgC(type, "[SVMod] ", Color(255, 255, 255), message, "\n")
end

function SVMOD:GetVehicleList()
	local result = {}

	for _, veh in pairs(list.Get("Vehicles")) do
		if not SVMOD.FCFG.BlacklistedModels[veh.Model:lower()] then
			table.insert(result, veh)
		end
	end

	return result
end

function SVMOD:GetConflictList()
	local result = ""

	for _, v in ipairs(self.FCFG.ConflictList) do
		if _G[v.Variable] ~= nil then
			result = result .. v.Name .. ", "
		end
	end

	if #result > 0 then
		result = string.sub(result, 1, -3)
	end

	return result
end
--lua/svmod/compatibility/permission/sh_cami.lua:
return gluapack()()
--lua/svmod/gui/cl_circles.lua:
return gluapack()()
--lua/svmod/gui/cl_circles.lua:
return gluapack()()
--lua/svmod/gui/cl_placingspikestip.lua:
return gluapack()()
--lua/svmod/gui/editor/cl_general.lua:
return gluapack()()
--lua/svmod/gui/editor/cl_lights.lua:
local function createNumSlidePanel(panel, name, defaultValue, minValue, maxValue)
	local numSlider = SVMOD:CreateNumSlidePanel(panel, name, function() end)
	numSlider:SetSize(400, 30)
	numSlider:SetValue(defaultValue)
	numSlider:SetMinValue(minValue)
	numSlider:SetMaxValue(maxValue)
	numSlider:SetUnit(" ")
	numSlider:SetRealTime(true)

	return numSlider
end

local function projectedTexturePanel(panel, data)
	local title = SVMOD:CreateTitle(panel, "LOCAL POSITIONS")
	local button = SVMOD:CreateButton(title, "EyePos", function()
		local trace = LocalPlayer():GetEyeTrace()

		if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
			data.Position = trace.Entity:WorldToLocal(trace.HitPos)
		end
	end)
	button:Dock(RIGHT)

	local xPositionNumSlider = createNumSlidePanel(panel, "X Position", data.Position.x, -200, 200)
	xPositionNumSlider:SetFunction(function(val)
		data.Position.x = val
	end)

	local yPositionNumSlider = createNumSlidePanel(panel, "Y Position", data.Position.y, -200, 200)
	yPositionNumSlider:SetFunction(function(val)
		data.Position.y = val
	end)

	local zPositionNumSlider = createNumSlidePanel(panel, "Z Position", data.Position.z, -200, 200)
	zPositionNumSlider:SetFunction(function(val)
		data.Position.z = val
	end)

	local title = SVMOD:CreateTitle(panel, "ANGLES")
	title:DockMargin(0, 30, 0, 0)

	local xAngleNumSlider = createNumSlidePanel(panel, "Y Angle", data.Angles.x, -180, 180)
	xAngleNumSlider:SetFunction(function(val)
		data.Angles.x = val
	end)

	local yAngleNumSlider = createNumSlidePanel(panel, "P Angle", data.Angles.y, -180, 180)
	yAngleNumSlider:SetFunction(function(val)
		data.Angles.y = val
	end)

	local zAngleNumSlider = createNumSlidePanel(panel, "R Angle", data.Angles.z, -180, 180)
	zAngleNumSlider:SetFunction(function(val)
		data.Angles.z = val
	end)

	local title = SVMOD:CreateTitle(panel, "OTHERS")
	title:DockMargin(0, 30, 0, 0)

	local colorMixer = vgui.Create("DColorMixer", panel)
	colorMixer:Dock(TOP)
	colorMixer:DockMargin(0, 0, 0, 10)
	colorMixer:SetSize(0, 69)
	colorMixer:SetPalette(false)
	colorMixer:SetAlphaBar(false)
	colorMixer:SetWangs(true)
	colorMixer:SetColor(data.Color)
	colorMixer.ValueChanged = function(self, color)
		-- for _, l in ipairs(LightList:GetSelected()) do
			data.Color = color
		-- end
	end

	local sizeNumSlider = createNumSlidePanel(panel, "Size", data.Size, 0, 2000)
	sizeNumSlider:SetFunction(function(val)
		data.Size = val
	end)

	local fovNumSlider = createNumSlidePanel(panel, "FOV", data.FOV, 0, 360)
	fovNumSlider:SetFunction(function(val)
		data.FOV = val
	end)
end

local function spritePanel(panel, data, hasAnim)
	local xPositionNumSlider, yPositionNumSlider, zPositionNumSlider

	local title = SVMOD:CreateTitle(panel, "LOCAL POSITIONS")
	local button = SVMOD:CreateButton(title, "EyePos", function()
		local trace = LocalPlayer():GetEyeTrace()

		if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
			data.Position = trace.Entity:WorldToLocal(trace.HitPos)

			xPositionNumSlider:SetValue(data.Position.x)
			yPositionNumSlider:SetValue(data.Position.y)
			zPositionNumSlider:SetValue(data.Position.z)
		end
	end)
	button:Dock(RIGHT)

	xPositionNumSlider = createNumSlidePanel(panel, "X Position", data.Position.x, -200, 200)
	xPositionNumSlider:SetFunction(function(val)
		data.Position.x = val
	end)

	yPositionNumSlider = createNumSlidePanel(panel, "Y Position", data.Position.y, -200, 200)
	yPositionNumSlider:SetFunction(function(val)
		data.Position.y = val
	end)

	zPositionNumSlider = createNumSlidePanel(panel, "Z Position", data.Position.z, -200, 200)
	zPositionNumSlider:SetFunction(function(val)
		data.Position.z = val
	end)

	local title = SVMOD:CreateTitle(panel, "OTHERS")
	title:DockMargin(0, 30, 0, 0)

	local colorMixer = vgui.Create("DColorMixer", panel)
	colorMixer:Dock(TOP)
	colorMixer:DockMargin(0, 0, 0, 10)
	colorMixer:SetSize(0, 69)
	colorMixer:SetPalette(false)
	colorMixer:SetAlphaBar(false)
	colorMixer:SetWangs(true)
	colorMixer:SetColor(data.Color)
	colorMixer.ValueChanged = function(self, color)
		-- for _, l in ipairs(LightList:GetSelected()) do
			data.Color = color
		-- end
	end

	local widthNumSlider = createNumSlidePanel(panel, "Width", data.Width or 20, 0, 100)
	widthNumSlider:SetFunction(function(val)
		data.Width = val
	end)

	local heightNumSlider = createNumSlidePanel(panel, "Height", data.Height or 20, 0, 100)
	heightNumSlider:SetFunction(function(val)
		data.Height = val
	end)

	if hasAnim then
		local title = SVMOD:CreateTitle(panel, "ANIMATIONS")
		title:DockMargin(0, 30, 0, 0)

		local activeTimeNumSlider = createNumSlidePanel(panel, "Active time", data.ActiveTime or 0, 0, 5)
		activeTimeNumSlider:SetFunction(function(val)
			data.ActiveTime = val
		end)

		local hiddenTimeNumSlider = createNumSlidePanel(panel, "Hidden time", data.HiddenTime or 0, 0, 5)
		hiddenTimeNumSlider:SetFunction(function(val)
			data.HiddenTime = val
		end)

		local offsetTimeNumSlider = createNumSlidePanel(panel, "Offset time", data.OffsetTime or 0, 0, 5)
		offsetTimeNumSlider:SetFunction(function(val)
			data.OffsetTime = val
		end)
	end
end

local function spriteLinePanel(panel, data)
	local xPositionNumSlider1, yPositionNumSlider1, zPositionNumSlider1
	local xPositionNumSlider2, yPositionNumSlider2, zPositionNumSlider2
	local xPositionNumSlider3, yPositionNumSlider3, zPositionNumSlider3

	local title = SVMOD:CreateTitle(panel, "LOCAL POSITIONS 1")
	local button = SVMOD:CreateButton(title, "EyePos", function()
		local trace = LocalPlayer():GetEyeTrace()

		if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
			data.Position1 = trace.Entity:WorldToLocal(trace.HitPos)

			xPositionNumSlider1:SetValue(data.Position1.x)
			yPositionNumSlider1:SetValue(data.Position1.y)
			zPositionNumSlider1:SetValue(data.Position1.z)
		end
	end)
	button:Dock(RIGHT)

	xPositionNumSlider1 = createNumSlidePanel(panel, "X Position", data.Position1.x, -200, 200)
	xPositionNumSlider1:SetFunction(function(val)
		data.Position1.x = val
	end)

	yPositionNumSlider1 = createNumSlidePanel(panel, "Y Position", data.Position1.y, -200, 200)
	yPositionNumSlider1:SetFunction(function(val)
		data.Position1.y = val
	end)

	zPositionNumSlider1 = createNumSlidePanel(panel, "Z Position", data.Position1.z, -200, 200)
	zPositionNumSlider1:SetFunction(function(val)
		data.Position1.z = val
	end)

	local title = SVMOD:CreateTitle(panel, "LOCAL POSITIONS 2")
	title:DockMargin(0, 30, 0, 0)
	SVMOD:CreateButton(title, "EyePos", function()
		local trace = LocalPlayer():GetEyeTrace()

		if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
			data.Position2 = trace.Entity:WorldToLocal(trace.HitPos)

			xPositionNumSlider2:SetValue(data.Position2.x)
			yPositionNumSlider2:SetValue(data.Position2.y)
			zPositionNumSlider2:SetValue(data.Position2.z)
		end
	end):Dock(RIGHT)
	SVMOD:CreateButton(title, "Align", function()
		local trace = LocalPlayer():GetEyeTrace()

		if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
			local vect = data.Position3 - data.Position1
			data.Position2.x = data.Position1.x + (vect.x / 2)
			data.Position2.y = data.Position1.y + (vect.y / 2)
			data.Position2.z = data.Position1.z + (vect.z / 2)

			xPositionNumSlider2:SetValue(data.Position2.x)
			yPositionNumSlider2:SetValue(data.Position2.y)
			zPositionNumSlider2:SetValue(data.Position2.z)
		end
	end):Dock(RIGHT)

	xPositionNumSlider2 = createNumSlidePanel(panel, "X Position", data.Position2.x, -200, 200)
	xPositionNumSlider2:SetFunction(function(val)
		data.Position2.x = val
	end)

	yPositionNumSlider2 = createNumSlidePanel(panel, "Y Position", data.Position2.y, -200, 200)
	yPositionNumSlider2:SetFunction(function(val)
		data.Position2.y = val
	end)

	zPositionNumSlider2 = createNumSlidePanel(panel, "Z Position", data.Position2.z, -200, 200)
	zPositionNumSlider2:SetFunction(function(val)
		data.Position2.z = val
	end)

	local title = SVMOD:CreateTitle(panel, "LOCAL POSITIONS 3")
	title:DockMargin(0, 30, 0, 0)
	local button = SVMOD:CreateButton(title, "EyePos", function()
		local trace = LocalPlayer():GetEyeTrace()

		if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
			data.Position3 = trace.Entity:WorldToLocal(trace.HitPos)

			xPositionNumSlider3:SetValue(data.Position3.x)
			yPositionNumSlider3:SetValue(data.Position3.y)
			zPositionNumSlider3:SetValue(data.Position3.z)
		end
	end)
	button:Dock(RIGHT)

	xPositionNumSlider3 = createNumSlidePanel(panel, "X Position", data.Position3.x, -200, 200)
	xPositionNumSlider3:SetFunction(function(val)
		data.Position3.x = val
	end)

	yPositionNumSlider3 = createNumSlidePanel(panel, "Y Position", data.Position3.y, -200, 200)
	yPositionNumSlider3:SetFunction(function(val)
		data.Position3.y = val
	end)

	zPositionNumSlider3 = createNumSlidePanel(panel, "Z Position", data.Position3.z, -200, 200)
	zPositionNumSlider3:SetFunction(function(val)
		data.Position3.z = val
	end)

	local title = SVMOD:CreateTitle(panel, "OTHERS")
	title:DockMargin(0, 30, 0, 0)

	local colorMixer = vgui.Create("DColorMixer", panel)
	colorMixer:Dock(TOP)
	colorMixer:DockMargin(0, 0, 0, 10)
	colorMixer:SetSize(0, 69)
	colorMixer:SetPalette(false)
	colorMixer:SetAlphaBar(false)
	colorMixer:SetWangs(true)
	colorMixer:SetColor(data.Color)
	colorMixer.ValueChanged = function(self, color)
		data.Color = color
	end

	local widthNumSlider = createNumSlidePanel(panel, "Width", data.Width or 20, 0, 100)
	widthNumSlider:SetFunction(function(val)
		data.Width = val
	end)

	local heightNumSlider = createNumSlidePanel(panel, "Height", data.Height or 20, 0, 100)
	heightNumSlider:SetFunction(function(val)
		data.Height = val
	end)

	local countNumSlider = createNumSlidePanel(panel, "Count", data.Count, 1, 100)
	countNumSlider:SetFunction(function(val)
		data.Count = val
	end)
end

local function spriteCirclePanel(panel, data, hasAnim)
	local title = SVMOD:CreateTitle(panel, "LOCAL POSITIONS")
	local button = SVMOD:CreateButton(title, "EyePos", function()
		local trace = LocalPlayer():GetEyeTrace()

		if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
			data.Position = trace.Entity:WorldToLocal(trace.HitPos)
		end
	end)
	button:Dock(RIGHT)

	local xPositionNumSlider = createNumSlidePanel(panel, "X Position", data.Position.x, -200, 200)
	xPositionNumSlider:SetFunction(function(val)
		data.Position.x = val
	end)

	local yPositionNumSlider = createNumSlidePanel(panel, "Y Position", data.Position.y, -200, 200)
	yPositionNumSlider:SetFunction(function(val)
		data.Position.y = val
	end)

	local zPositionNumSlider = createNumSlidePanel(panel, "Z Position", data.Position.z, -200, 200)
	zPositionNumSlider:SetFunction(function(val)
		data.Position.z = val
	end)

	local title = SVMOD:CreateTitle(panel, "OTHERS")
	title:DockMargin(0, 30, 0, 0)

	local colorMixer = vgui.Create("DColorMixer", panel)
	colorMixer:Dock(TOP)
	colorMixer:DockMargin(0, 0, 0, 10)
	colorMixer:SetSize(0, 69)
	colorMixer:SetPalette(false)
	colorMixer:SetAlphaBar(false)
	colorMixer:SetWangs(true)
	colorMixer:SetColor(data.Color)
	colorMixer.ValueChanged = function(self, color)
		-- for _, l in ipairs(LightList:GetSelected()) do
			data.Color = color
		-- end
	end

	local widthNumSlider = createNumSlidePanel(panel, "Width", data.Width or 20, 0, 100)
	widthNumSlider:SetFunction(function(val)
		data.Width = val
	end)

	local heightNumSlider = createNumSlidePanel(panel, "Height", data.Height or 20, 0, 100)
	heightNumSlider:SetFunction(function(val)
		data.Height = val
	end)

	local radiusNumSlider = createNumSlidePanel(panel, "Radius", data.Radius, 1, 100)
	radiusNumSlider:SetFunction(function(val)
		data.Radius = val
	end)

	local speedNumSlider = createNumSlidePanel(panel, "Speed", data.Speed, 0, 4)
	speedNumSlider:SetFunction(function(val)
		data.Speed = val
	end)

	if hasAnim then
		local title = SVMOD:CreateTitle(panel, "ANIMATIONS")
		title:DockMargin(0, 30, 0, 0)

		local activeTimeNumSlider = createNumSlidePanel(panel, "Active time", data.ActiveTime or 0, 0, 5)
		activeTimeNumSlider:SetFunction(function(val)
			data.ActiveTime = val
		end)

		local hiddenTimeNumSlider = createNumSlidePanel(panel, "Hidden time", data.HiddenTime or 0, 0, 5)
		hiddenTimeNumSlider:SetFunction(function(val)
			data.HiddenTime = val
		end)

		local offsetTimeNumSlider = createNumSlidePanel(panel, "Offset time", data.OffsetTime or 0, 0, 5)
		offsetTimeNumSlider:SetFunction(function(val)
			data.OffsetTime = val
		end)
	end
end

function SVMOD:EDITOR_Lights(panel, data, veh, hasAnim)
	panel:Clear()

	local listView = SVMOD:CreateListView(panel)
	listView:SetWidth(100, 0)
	listView:SetHideHeaders(true)
	listView:Dock(LEFT)
	listView:DockMargin(0, 0, 20, 0)
	listView:AddColumn("ID")
	listView:SetMultiSelect(false)

	local bottomPanel = vgui.Create("DPanel", panel)
	bottomPanel:Dock(BOTTOM)
	bottomPanel:SetSize(0, 30)
	bottomPanel:SetPaintBackground(false)

	local centerPanel = vgui.Create("DPanel", panel)
	centerPanel:Dock(FILL)
	centerPanel:SetPaintBackground(false)

	-- -------------------
	--  HOOKS
	-- -------------------

	-- -------------------
	--  FUNCTIONS
	-- -------------------

	local function getType(data)
		if data.ProjectedTexture then
			return " (projected)"
		elseif data.SpriteLine then
			return " (line)"
		elseif data.SpriteCircle then
			return " (circle)"
		end

		return ""
	end

	local function addLight(data)
		local max = 0
		for _, line in pairs(listView:GetLines()) do
			local index = line:GetIndex()
			if index > max then
				max = index
			end
		end

		local line = listView:AddLine(max + 1 .. getType(data))
		line.Data = data

		return line
	end

	local function removeLight(lineID, line)
		local index = line:GetIndex()

		if data[index].ProjectedTexture and IsValid(data[index].ProjectedTexture.Entity) then
			data[index].ProjectedTexture.Entity:Remove()
		end

		table.remove(data, index)

		for _, v in pairs(listView:GetLines()) do
			local i = v:GetIndex()
			if i > index then
				v:SetColumnText(1, i - 1 .. getType(v.Data))
			end
		end

		listView:RemoveLine(lineID)
	end

	local function upLight(index)
		local line = listView:GetLine(index)
		lineIndex = line:GetIndex()

		for _, v in pairs(listView:GetLines()) do
			local tempIndex = v:GetIndex()
			if tempIndex == lineIndex - 1 then
				data[lineIndex], data[tempIndex] = data[tempIndex], data[lineIndex]
				line.Data, v.Data = v.Data, line.Data
				listView:GetLine(tempIndex):SetColumnText(1, tempIndex .. getType(v.Data))
				listView:GetLine(lineIndex):SetColumnText(1, lineIndex .. getType(line.Data))
				break
			end
		end
	end

	local function downLight(index)
		local line = listView:GetLine(index)
		lineIndex = line:GetIndex()

		for _, v in pairs(listView:GetLines()) do
			local tempIndex = v:GetIndex()
			if tempIndex == lineIndex + 1 then
				data[lineIndex], data[tempIndex] = data[tempIndex], data[lineIndex]
				line.Data, v.Data = v.Data, line.Data
				listView:GetLine(tempIndex):SetColumnText(1, tempIndex .. getType(v.Data))
				listView:GetLine(lineIndex):SetColumnText(1, lineIndex .. getType(line.Data))
				break
			end
		end
	end

	-- -------------------
	--  PANELS
	-- -------------------

	listView.OnRowRightClick = function(_, lineID, line)
		local menu = DermaMenu()

		menu:AddOption("Up", function()
			upLight(lineID)
		end):SetIcon("icon16/arrow_up.png")

		menu:AddOption("Down", function()
			downLight(lineID)
		end):SetIcon("icon16/arrow_down.png")

		menu:AddOption("Dupplicate", function()
			if line.Data.ProjectedTexture then
				local index = table.insert(data, {
					ProjectedTexture = SVMOD:DeepCopy(line.Data.ProjectedTexture)
				})
				addLight(data[index])
			end

			if line.Data.Sprite then
				local index = table.insert(data, {
					Sprite = SVMOD:DeepCopy(line.Data.Sprite)
				})
				addLight(data[index])
			end

			if line.Data.SpriteLine then
				local index = table.insert(data, {
					SpriteLine = SVMOD:DeepCopy(line.Data.SpriteLine)
				})
				addLight(data[index])
			end

			if line.Data.SpriteCircle then
				local index = table.insert(data, {
					SpriteCircle = SVMOD:DeepCopy(line.Data.SpriteCircle)
				})
				addLight(data[index])
			end
		end):SetIcon("icon16/page_copy.png")

		menu:AddOption("Symmetric", function()
			if line.Data.ProjectedTexture then
				local index = table.insert(data, {
					ProjectedTexture = SVMOD:DeepCopy(line.Data.ProjectedTexture)
				})
				local tab = addLight(data[index])
				tab.Data.ProjectedTexture.Position.x = -line.Data.ProjectedTexture.Position.x
			end

			if line.Data.Sprite then
				local index = table.insert(data, {
					Sprite = SVMOD:DeepCopy(line.Data.Sprite)
				})
				local tab = addLight(data[index])
				tab.Data.Sprite.Position.x = -line.Data.Sprite.Position.x
			end

			if line.Data.SpriteLine then
				local index = table.insert(data, {
					SpriteLine = SVMOD:DeepCopy(line.Data.SpriteLine)
				})
				local tab = addLight(data[index])
				tab.Data.SpriteLine.Position1.x = -line.Data.SpriteLine.Position1.x
				tab.Data.SpriteLine.Position2.x = -line.Data.SpriteLine.Position2.x
				tab.Data.SpriteLine.Position3.x = -line.Data.SpriteLine.Position3.x
			end

			if line.Data.SpriteCircle then
				local index = table.insert(data, {
					SpriteCircle = SVMOD:DeepCopy(line.Data.SpriteCircle)
				})
				local tab = addLight(data[index])
				tab.Data.SpriteCircle.Position.x = -line.Data.SpriteCircle.Position.x
			end
		end):SetIcon("icon16/arrow_refresh.png")

		if line.Data.Sprite then
			menu:AddOption("Create Projected texture from Sprite", function()
				local pos = line.Data.Sprite.Position
				local index = table.insert(data, {
					ProjectedTexture = {
						Position = Vector(pos.x, pos.y, pos.z),
						Angles = Angle(0, 90, 0),
						Color = Color(255, 255, 255),
						Size = 1000,
						FOV = 110
					}
				})
				addLight(data[index])
			end):SetIcon("icon16/lightbulb_add.png")
		end

		menu:AddOption("Delete", function()
			removeLight(lineID, line)
		end):SetIcon("icon16/cross.png")

		menu:Open()
	end

	local addButton = SVMOD:CreateButton(bottomPanel, "ADD", function()
		local menu = DermaMenu()

		menu:AddOption("Projected texture", function()
			local index = table.insert(data, {
				ProjectedTexture = {
					Position = Vector(0, 0, 0),
					Angles = Angle(0, 90, 0),
					Color = Color(255, 255, 255),
					Size = 1000,
					FOV = 110
				}
			})
			addLight(data[index])
		end):SetIcon("icon16/lightbulb.png")

		menu:AddOption("Sprite", function()
			local index = table.insert(data, {
				Sprite = {
					Position = Vector(0, 0, 0),
					Color = Color(255, 255, 255),
					Width = 25,
					Height = 25,
					ActiveTime = 0,
					HiddenTime = 0,
					OffsetTime = 0
				}
			})
			addLight(data[index])
		end):SetIcon("icon16/lightbulb.png")

		menu:AddOption("Sprite line", function()
			local index = table.insert(data, {
				SpriteLine = {
					Position1 = Vector(0, 0, 0),
					Position2 = Vector(0, 0, 0),
					Position3 = Vector(0, 0, 0),
					Color = Color(255, 255, 255),
					Count = 10,
					Width = 10,
					Height = 10
				}
			})
			addLight(data[index])
		end):SetIcon("icon16/lightbulb.png")

		menu:AddOption("Sprite circle", function()
			local index = table.insert(data, {
				SpriteCircle = {
					Position = Vector(0, 0, 0),
					Color = Color(255, 255, 255),
					Width = 25,
					Height = 25,
					Radius = 15,
					Speed = 0.1,
					ActiveTime = 0,
					HiddenTime = 0,
					OffsetTime = 0
				}
			})
			addLight(data[index])
		end):SetIcon("icon16/lightbulb.png")

		menu:Open()
	end)
	addButton:Dock(RIGHT)

	local reloadButton = SVMOD:CreateButton(bottomPanel, "RELOAD ANIMATIONS", function()
		veh:SV_StopAlphaTimer()
		veh:SV_StartAlphaTimer()
	end)
	reloadButton:Dock(RIGHT)
	reloadButton:SetSize(180, 30)

	for _, light in ipairs(data) do
		if table.Count(light) > 1 then
			SVMOD:PrintConsole(SVMOD.LOG.Warning, "Light with multiple types, please report it!")
		end

		addLight(light)
	end

	listView.OnRowSelected = function(_, _, e)
		centerPanel:Clear()

		if e.Data.ProjectedTexture then
			projectedTexturePanel(centerPanel, e.Data.ProjectedTexture)
		elseif e.Data.Sprite then
			spritePanel(centerPanel, e.Data.Sprite, hasAnim)
		elseif e.Data.SpriteLine then
			if not e.Data.SpriteLine.Position3 then
				e.Data.SpriteLine.Position3 = Vector(0, 0, 0)
				e.Data.SpriteLine.Position3.x = e.Data.SpriteLine.Position2.x
				e.Data.SpriteLine.Position3.y = e.Data.SpriteLine.Position2.y
				e.Data.SpriteLine.Position3.z = e.Data.SpriteLine.Position2.z
			end
			spriteLinePanel(centerPanel, e.Data.SpriteLine)
		elseif e.Data.SpriteCircle then
			spriteCirclePanel(centerPanel, e.Data.SpriteCircle, hasAnim)
		end
	end
end
--lua/svmod/gui/settings/cl_contributor.lua:
function SVMOD:GUI_Contributor(panel, data)
	panel:Clear()

	SVMOD:CreateTitle(panel, language.GetPhrase("svmod.contributor.contributor"))

	local keyPanel = vgui.Create("DPanel", panel)
	keyPanel:Dock(TOP)
	keyPanel:DockMargin(0, 4, 0, 4)
	keyPanel:SetSize(0, 30)
	keyPanel:SetPaintBackground(false)

	if not game.IsDedicated() then
		local label = vgui.Create("DLabel", keyPanel)
		label:SetPos(2, 4)
		label:SetFont("SV_Calibri18")
		label:SetText(language.GetPhrase("svmod.contributor.api_key"))
		label:SizeToContents()

		local keyTextEntry = vgui.Create("DTextEntry", keyPanel)
		keyTextEntry:Dock(RIGHT)
		keyTextEntry:DockMargin(8, 0, 0, 0)
		keyTextEntry:SetSize(300, 0)
		keyTextEntry.Paint = function(self, w, h)
			surface.SetDrawColor(18, 25, 31)
			surface.DrawRect(0, 0, w, h)

			surface.SetDrawColor(41, 56, 63)
			surface.DrawOutlinedRect(0, 0, w, h)

			draw.SimpleText(self:GetValue(), "SV_Calibri18", 8, h / 2, Color(200, 200, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		keyTextEntry:SetValue(SVMOD.CFG.Contributor.Key or "")

		local subKeyPanel = vgui.Create("DPanel", panel)
		subKeyPanel:Dock(TOP)
		subKeyPanel:DockMargin(0, 4, 0, 4)
		subKeyPanel:SetSize(0, 30)
		subKeyPanel:SetPaintBackground(false)

		local checkedPanel = vgui.Create("DImage", subKeyPanel)
		checkedPanel:SetPos(5, 5)
		checkedPanel:SetSize(24, 24)

		local label = vgui.Create("DLabel", subKeyPanel)
		label:SetPos(39, 8)
		label:SetFont("SV_Calibri18")

		if SVMOD.CFG.Contributor.IsEnabled then
			checkedPanel:SetImageColor(Color(112, 255, 117))
			checkedPanel:SetImage("vgui/svmod/checked.png")

			label:SetColor(Color(112, 255, 117))
			label:SetText(language.GetPhrase("svmod.contributor.contributor_enabled"))
			label:SizeToContents()
		else
			checkedPanel:SetImageColor(Color(255, 112, 112))
			checkedPanel:SetImage("vgui/svmod/invalid.png")

			label:SetColor(Color(255, 112, 112))
			label:SetText(language.GetPhrase("svmod.contributor.contributor_disabled"))
			label:SizeToContents()
		end

		local validButton = SVMOD:CreateButton(subKeyPanel, language.GetPhrase("svmod.update"), function()
			SVMOD.CFG.Contributor.Key = keyTextEntry:GetValue()

			http.Fetch("https://api.svmod.com/check_serial.php?serial=" .. keyTextEntry:GetValue(), function(_, _, _, code)
				if code == 200 then
					SVMOD.CFG.Contributor.IsEnabled = true

					SVMOD:Save()

					if IsValid(panel) then
						SVMOD:GUI_Contributor(panel, data)
					end
				else
					notification.AddLegacy(language.GetPhrase("svmod.contributor.invalid_key"), NOTIFY_ERROR, 5)
				end
			end, function()
				notification.AddLegacy(language.GetPhrase("svmod.server_not_respond"), NOTIFY_ERROR, 5)
			end)
		end)
		validButton:Dock(RIGHT)
	else
		local label = vgui.Create("DLabel", keyPanel)
		label:SetPos(0, 8)
		label:SetFont("SV_Calibri18")
		label:SetColor(Color(255, 112, 112))
		label:SetText(language.GetPhrase("svmod.contributor.single_player_only"))
		label:SizeToContents()
	end

	local title = SVMOD:CreateTitle(panel, "ENTERPRISE")
	title:DockMargin(0, 30, 0, 0)

	local enterprisePanel = vgui.Create("DPanel", panel)
	enterprisePanel:Dock(TOP)
	enterprisePanel:DockMargin(0, 4, 0, 4)
	enterprisePanel:SetSize(0, 30)
	enterprisePanel:SetPaintBackground(false)

	local label = vgui.Create("DLabel", enterprisePanel)
	label:SetPos(2, 4)
	label:SetFont("SV_Calibri18")
	label:SetText("Enterprise ID")
	label:SizeToContents()

	local keyTextEntry = vgui.Create("DTextEntry", enterprisePanel)
	keyTextEntry:Dock(RIGHT)
	keyTextEntry:DockMargin(8, 0, 0, 0)
	keyTextEntry:SetSize(150, 0)
	keyTextEntry.Paint = function(self, w, h)
		surface.SetDrawColor(18, 25, 31)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(41, 56, 63)
		surface.DrawOutlinedRect(0, 0, w, h)

		draw.SimpleText(self:GetValue(), "SV_Calibri18", 8, h / 2, Color(200, 200, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	keyTextEntry:SetValue(data.EnterpriseID or 0)

	local subKeyPanel = vgui.Create("DPanel", panel)
	subKeyPanel:Dock(TOP)
	subKeyPanel:DockMargin(0, 4, 0, 4)
	subKeyPanel:SetSize(0, 30)
	subKeyPanel:SetPaintBackground(false)

	local validButton = SVMOD:CreateButton(subKeyPanel, language.GetPhrase("svmod.update"), function()
		net.Start("SV_Settings")
		net.WriteString("Contributor")
		net.WriteString("EnterpriseID")
		net.WriteUInt(1, 2) -- float
		net.WriteFloat(math.Clamp(keyTextEntry:GetValue(), 0, 65535))
		net.SendToServer()

		SVMOD:SetAddonState(false)
		panel:GetParent():Remove()
		SVMOD:SetAddonState(true)

		panel:GetParent():Remove()
	end)
	validButton:Dock(RIGHT)
end
--lua/svmod/gui/settings/cl_credits.lua:
return gluapack()()
--lua/svmod/gui/settings/cl_seats.lua:
function SVMOD:GUI_Seats(panel, data)
	panel:Clear()

	SVMOD:CreateTitle(panel, language.GetPhrase("svmod.seats.seats"))

	SVMOD:CreateSettingPanel(panel, language.GetPhrase("svmod.seats.move"), {
		{
			Name = language.GetPhrase("svmod.enable"),
			Color = Color(59, 217, 85),
			HoverColor = Color(156, 255, 161),
			IsSelected = (data.IsSwitchEnabled == true),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("IsSwitchEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(true)
				net.SendToServer()
			end
		},
		{
			Name = language.GetPhrase("svmod.disable"),
			Color = Color(173, 48, 43),
			HoverColor = Color(224, 62, 56),
			IsSelected = (data.IsSwitchEnabled == false),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("IsSwitchEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(false)
				net.SendToServer()
			end
		}
	})

	SVMOD:CreateSettingPanel(panel, language.GetPhrase("svmod.seats.kick"), {
		{
			Name = language.GetPhrase("svmod.enable"),
			Color = Color(59, 217, 85),
			HoverColor = Color(156, 255, 161),
			IsSelected = (data.IsKickEnabled == true),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("IsKickEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(true)
				net.SendToServer()
			end
		},
		{
			Name = language.GetPhrase("svmod.disable"),
			Color = Color(173, 48, 43),
			HoverColor = Color(224, 62, 56),
			IsSelected = (data.IsKickEnabled == false),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("IsKickEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(false)
				net.SendToServer()
			end
		}
	})

	SVMOD:CreateSettingPanel(panel, language.GetPhrase("svmod.seats.lock"), {
		{
			Name = language.GetPhrase("svmod.enable"),
			Color = Color(59, 217, 85),
			HoverColor = Color(156, 255, 161),
			IsSelected = (data.IsLockEnabled == true),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("IsLockEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(true)
				net.SendToServer()
			end
		},
		{
			Name = language.GetPhrase("svmod.disable"),
			Color = Color(173, 48, 43),
			HoverColor = Color(224, 62, 56),
			IsSelected = (data.IsLockEnabled == false),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("IsLockEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(false)
				net.SendToServer()
			end
		}
	})

	SVMOD:CreateSettingPanel(panel, language.GetPhrase("svmod.seats.allow_weapons_in_vehicle"), {
		{
			Name = language.GetPhrase("svmod.enable"),
			Color = Color(59, 217, 85),
			HoverColor = Color(156, 255, 161),
			IsSelected = (data.AllowWeaponsInVehicle == true),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("AllowWeaponsInVehicle")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(true)
				net.SendToServer()
			end
		},
		{
			Name = language.GetPhrase("svmod.disable"),
			Color = Color(173, 48, 43),
			HoverColor = Color(224, 62, 56),
			IsSelected = (data.AllowWeaponsInVehicle == false),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Seats")
				net.WriteString("AllowWeaponsInVehicle")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(false)
				net.SendToServer()
			end
		}
	})
end
--lua/svmod/gui/settings/cl_settings.lua:
net.Receive("SV_Settings", function()
	local data = {}

	data.HasAccess = net.ReadBool()

	data.Status = net.ReadBool()
	data.LastVehicleUpdate = net.ReadString()
	data.ConflictList = net.ReadString()

	if data.HasAccess then
		data.IsSwitchEnabled = net.ReadBool()
		data.IsKickEnabled = net.ReadBool()
		data.IsLockEnabled = net.ReadBool()
		data.AllowWeaponsInVehicle = net.ReadBool()

		data.AreHeadlightsEnabled = net.ReadBool()
		data.TurnOffHeadlightsOnExit = net.ReadBool()
		data.TimeTurnOffHeadlights = net.ReadFloat()
		data.AreHazardLightsEnabled = net.ReadBool()
		data.TurnOffHazardOnExit = net.ReadBool()
		data.TimeTurnOffHazard = net.ReadFloat()
		data.AreReverseLightsEnabled = net.ReadBool()

		data.AreFlashingLightsEnabled = net.ReadBool()
		data.TurnOffFlashingLightsOnExit = net.ReadBool()
		data.TimeTurnOffFlashingLights = net.ReadFloat()
		data.TimeTurnOffSound = net.ReadFloat()

		data.HornIsEnabled = net.ReadBool()

		data.PhysicsMultiplier = math.Round(net.ReadFloat(), 2)
		data.BulletMultiplier = math.Round(net.ReadFloat(), 2)
		data.CarbonisedChance = math.Round(net.ReadFloat(), 2)
		data.SmokePercent = math.Round(net.ReadFloat(), 2)
		data.WheelShotMultiplier = math.Round(net.ReadFloat(), 2)
		data.WheelCollisionMultiplier = math.Round(net.ReadFloat(), 2)
		data.TimeBeforeWheelIsPunctured = math.Round(net.ReadFloat(), 2)
		data.DriverMultiplier = math.Round(net.ReadFloat(), 2)
		data.PassengerMultiplier = math.Round(net.ReadFloat(), 2)
		data.PlayerExitMultiplier = math.Round(net.ReadFloat(), 2)

		data.FuelIsEnabled = net.ReadBool()
		data.FuelMultiplier = math.Round(net.ReadFloat(), 2)

		data.IsHUDEnabled = net.ReadBool()
		data.HUDPositionX = net.ReadFloat()
		data.HUDPositionY = net.ReadFloat()
		data.HUDSize = net.ReadUInt(9) -- max: 511
		data.HUDColor = net.ReadColor()
		data.CustomSuspension = math.Round(net.ReadFloat(), 2)
		data.TimeDeploySpikeStrips = math.Round(net.ReadFloat(), 2)

		data.EnterpriseID = net.ReadFloat()
	end

	local frame = SVMOD:CreateFrame("SVMOD : SIMPLE VEHICLE MOD " .. SVMOD.FCFG.Version)
	frame:SetSize(900, 650)
	frame:MakePopup()

	frame:CreateMenuButton(language.GetPhrase("svmod.home.home"), TOP, function()
		SVMOD:GUI_Home(frame:GetCenterPanel(), data)
	end)

	frame:CreateMenuButton(language.GetPhrase("svmod.shortcuts.shortcuts"), TOP, function()
		SVMOD:GUI_Shortcuts(frame:GetCenterPanel(), data)
	end)

	frame:CreateMenuButton(language.GetPhrase("svmod.options.options"), TOP, function()
		SVMOD:GUI_Options(frame:GetCenterPanel(), data)
	end)

	frame:CreateMenuButton(language.GetPhrase("svmod.vehicles.vehicles"), TOP, function()
		SVMOD:GUI_Vehicles(frame:GetCenterPanel(), data)
	end)

	SVMOD:CreateHorizontalLine(frame:GetLeftPanel())

	if data.HasAccess then
		frame:CreateMenuButton(language.GetPhrase("svmod.seats.seats"), TOP, function()
			SVMOD:GUI_Seats(frame:GetCenterPanel(), data)
		end)

		frame:CreateMenuButton(language.GetPhrase("svmod.lights.lights"), TOP, function()
			SVMOD:GUI_Lights(frame:GetCenterPanel(), data)
		end)

		frame:CreateMenuButton(language.GetPhrase("svmod.els.els"), TOP, function()
			SVMOD:GUI_ELS(frame:GetCenterPanel(), data)
		end)

		frame:CreateMenuButton(language.GetPhrase("svmod.sounds.sounds"), TOP, function()
			SVMOD:GUI_Sounds(frame:GetCenterPanel(), data)
		end)

		frame:CreateMenuButton(language.GetPhrase("svmod.damage.damage"), TOP, function()
			SVMOD:GUI_Damage(frame:GetCenterPanel(), data)
		end)

		frame:CreateMenuButton(language.GetPhrase("svmod.fuel.fuel"), TOP, function()
			SVMOD:GUI_Fuel(frame:GetCenterPanel(), data)
		end)

		frame:CreateMenuButton(language.GetPhrase("svmod.others.others"), TOP, function()
			SVMOD:GUI_Others(frame:GetCenterPanel(), data)
		end)
	end

	frame:CreateMenuButton(language.GetPhrase("svmod.credits"), BOTTOM, function()
		SVMOD:GUI_Credits(frame:GetCenterPanel(), data)
	end)

	frame:CreateMenuButton(language.GetPhrase("svmod.contributor.contributor"), BOTTOM, function()
		SVMOD:GUI_Contributor(frame:GetCenterPanel(), data)
	end)

	SVMOD:GUI_Home(frame:GetCenterPanel(), data)
end)
--lua/svmod/horn/sh_horn.lua:
-- @class SV_Vehicle
-- @shared

-- Returns the horn state of the vehicle.
-- @treturn boolean True if enabled, false if disabled
function SVMOD.Metatable:SV_GetHornState()
	return self.SV_States.Horn
end
--lua/svmod/lights/cl_lights.lua:
-- @class SVMOD
-- @clientside

local spriteMaterial = Material("sprites/light_ignorez")

local function rotateAroundAxis(ang1, ang2)
	ang1:RotateAroundAxis(ang1:Forward(), ang2.p)
	ang1:RotateAroundAxis(ang1:Right(), ang2.r)
	ang1:RotateAroundAxis(ang1:Up(), ang2.y)

	return ang1
end

local vehicleList = {}
local renderList = {}

hook.Add("SV_Enabled", "SV_InitRenderVehicle", function()
	vehicleList = {}
	renderList = {}

	hook.Add("PostDrawTranslucentRenderables", "SV_PostDrawVehicle", function()
		SVMOD:Render()
	end)

	timer.Create("SV_Render", 2, 0, function()
		local Position = LocalPlayer():GetPos()

		renderList = {}

		for _, v in ipairs(vehicleList) do
			if IsValid(v) then
				if v:WaterLevel() < 3 and v:GetPos():DistToSqr(Position) < 30000000 then
					table.insert(renderList, v)
					if not v.SV_IsRendered then
						v:SV_StartAlphaTimer()
						v.SV_IsRendered = true
					end
				elseif v.SV_IsRendered then
					v:SV_ClearProjectedTexture()
					v:SV_StopAlphaTimer()
					v.SV_IsRendered = false
				end
			end
		end
	end)
end)

hook.Add("SV_Disabled", "SV_DestroyRenderVehicle", function()
	hook.Remove("PostDrawTranslucentRenderables", "SV_PostDrawVehicle")

	timer.Remove("SV_Render")
end)

hook.Add("SV_LoadVehicle", "SV_AddDrawHook", function(veh)
	table.insert(vehicleList, veh)
end)

hook.Add("SV_UnloadVehicle", "SV_RemoveDrawHook", function(veh)
	table.RemoveByValue(vehicleList, veh)

	if veh.SV_IsRendered then
		veh:SV_ClearProjectedTexture()
		veh:SV_StopAlphaTimer()
		veh.SV_IsRendered = nil
	end
end)

function SVMOD:Render()
	for _, veh in ipairs(renderList) do
		if not IsValid(veh) then return end

		if veh.SV_States.Headlights then
			self:RenderLights(veh, veh.SV_Data.Headlights)
		end

		local HazardLightsState = veh:SV_GetHazardLightsState()
		local LeftBlinkerLightsState = veh:SV_GetLeftBlinkerState()
		local RightBlinkerLightsState = veh:SV_GetRightBlinkerState()
		if HazardLightsState or LeftBlinkerLightsState or RightBlinkerLightsState then
			if not veh.SV_BlinkersTimer or CurTime() >= veh.SV_BlinkersTimer then
				if not veh.SV_BlinkersDrawn then
					veh.SV_BlinkersDrawn = true
					veh:EmitSound("svmod/blinker/" .. (veh.SV_Data.Sounds.Blinkers or "normal") .. "_turn_on.wav")
				else
					veh.SV_BlinkersDrawn = false
					veh:EmitSound("svmod/blinker/" .. (veh.SV_Data.Sounds.Blinkers or "normal") .. "_turn_off.wav")
				end
				veh.SV_BlinkersTimer = CurTime() + 0.5
			end

			if veh.SV_BlinkersDrawn then
				if HazardLightsState or LeftBlinkerLightsState then
					self:RenderLights(veh, veh.SV_Data.Blinkers.LeftLights)
				end

				if HazardLightsState or RightBlinkerLightsState then
					self:RenderLights(veh, veh.SV_Data.Blinkers.RightLights)
				end
			end
		end

		if veh.SV_States.BackLights then
			if not veh.SV_IsReversing then
				self:RenderLights(veh, veh.SV_Data.Back.BrakeLights)
			else
				-- TODO: Reversing sound
				self:RenderLights(veh, veh.SV_Data.Back.ReversingLights)
			end
		end

		if veh.SV_States.FlashingLights then
			self:RenderLights(veh, veh.SV_Data.FlashingLights)
		end
	end
end

local mathCos = math.cos
local mathSin = math.sin

function SVMOD:RenderLights(veh, lights)
	for _, v in ipairs(lights) do
		if v.Sprite then
			local sprite = v.Sprite
			sprite.Handler = veh:SV_DrawSprite(
				spriteMaterial,
				sprite.Position,
				sprite.Width,
				sprite.Height,
				sprite.Color,
				sprite.Handler
			)
		end

		if v.SpriteLine then
			local spriteLine = v.SpriteLine

			local A = spriteLine.Position1
			local B = spriteLine.Position2
			local C = spriteLine.Position3 or spriteLine.Position2

			for i = 0, spriteLine.Count do
				if not spriteLine.Handler then
					spriteLine.Handler = {}
				end

				local t = i * 1 / spriteLine.Count

				spriteLine.Handler[i] = veh:SV_DrawSprite(
					spriteMaterial,
					Vector(
						(1 - t)^2 * A.x + 2 * (1 - t) * t * B.x + t^2 * C.x,
						(1 - t)^2 * A.y + 2 * (1 - t) * t * B.y + t^2 * C.y,
						(1 - t)^2 * A.z + 2 * (1 - t) * t * B.z + t^2 * C.z
						-- A.x + (Vect.x / spriteLine.Count) * i,
						-- A.y + (Vect.y / spriteLine.Count) * i,
						-- A.z + (Vect.z / spriteLine.Count) * i
					),
					spriteLine.Width,
					spriteLine.Height,
					spriteLine.Color,
					spriteLine.Handler[i]
				)
			end
		end

		if v.SpriteCircle then
			local spriteCircle = v.SpriteCircle

			spriteCircle.CurrentAngle = ((spriteCircle.CurrentAngle or 0) % 360) + (spriteCircle.Speed / (1 / FrameTime()) * 60)

			local pos = Vector(
				spriteCircle.Position.x + mathCos(spriteCircle.CurrentAngle) * (spriteCircle.Radius / 5),
				spriteCircle.Position.y + mathSin(spriteCircle.CurrentAngle) * (spriteCircle.Radius / 5),
				spriteCircle.Position.z
			)

			spriteCircle.Handler = veh:SV_DrawSprite(
				spriteMaterial,
				pos,
				spriteCircle.Width,
				spriteCircle.Height,
				spriteCircle.Color,
				spriteCircle.Handler
			)
		end

		if v.ProjectedTexture then
			if SVMOD.CFG.Lights.DrawProjectedLights and not v.ProjectedTexture.Entity then
				v.ProjectedTexture.Entity = veh:SV_CreateProjectedTexture(
					v.ProjectedTexture.Position,
					v.ProjectedTexture.Angles,
					v.ProjectedTexture.Color,
					v.ProjectedTexture.Size,
					v.ProjectedTexture.FOV
				)
			end

			if v.ProjectedTexture.Entity then
				v.ProjectedTexture.Entity:SetAngles(rotateAroundAxis(veh:GetAngles(), v.ProjectedTexture.Angles or Angle(0, 0, 0)))
				v.ProjectedTexture.Entity:SetPos(veh:LocalToWorld(v.ProjectedTexture.Position or Vector(0, 0, 0)))
				v.ProjectedTexture.Entity:Update()
			end
		end
	end
end

-- @class SV_Vehicle

-- Draw a sprite on a vehicle.
-- @tparam Material material Material
-- @tparam Vector position World coordinates
-- @tparam number width Width
-- @tparam number height Height
-- @tparam Color color Color
-- @tparam "pixelvis handle t" handler PixVis handle
-- @internal
function SVMOD.Metatable:SV_DrawSprite(material, position, width, height, color, handler)
	if not handler then
		handler = util.GetPixelVisibleHandle()
	end

	local Position = self:LocalToWorld(position or Vector(0, 0, 0))

	local c = Color(
		color.r or 255,
		color.g or 255,
		color.b or 255,
		util.PixelVisible(Position, 1, handler) * color.a
	)

	render.SetMaterial(material)
	render.DrawSprite(
		Position,
		width or 20,
		height or 20,
		c
	)

	return handler
end

-- Creates a projected texture.
-- @tparam Vector position World coordinates
-- @tparam Angle angle Angle
-- @tparam Color color Color
-- @tparam number size Size
-- @tparam number fov Field of view
-- @internal
function SVMOD.Metatable:SV_CreateProjectedTexture(position, angle, color, size, fov)
	local PTexture = ProjectedTexture()

	PTexture:SetAngles(rotateAroundAxis(self:GetAngles(), angle or Angle(0, 0, 0)))
	PTexture:SetPos(self:LocalToWorld(position or Vector(0, 0, 0)))

	PTexture:Update()

	PTexture:SetEnableShadows(SVMOD.CFG.Lights.DrawShadows)
	PTexture:SetColor(color)
	PTexture:SetFarZ(size or 600)
	PTexture:SetFOV(fov or 110)
	PTexture:SetNearZ(32) -- lower than this value decreases framerate!
	PTexture:SetTexture("effects/flashlight001")

	PTexture:Update()

	return PTexture
end

-- Cleans the projected textures related to the vehicle.
-- @internal
function SVMOD.Metatable:SV_ClearProjectedTexture()
	local function ClearProjectedTexture(tab)
		for _, l in ipairs(tab) do
			if l.ProjectedTexture and l.ProjectedTexture.Entity then
				l.ProjectedTexture.Entity:Remove()
				l.ProjectedTexture.Entity = nil
			end
		end
	end

	ClearProjectedTexture(self.SV_Data.Headlights)
	ClearProjectedTexture(self.SV_Data.Back.BrakeLights)
	ClearProjectedTexture(self.SV_Data.Back.ReversingLights)
	ClearProjectedTexture(self.SV_Data.Blinkers.LeftLights)
	ClearProjectedTexture(self.SV_Data.Blinkers.RightLights)
end

-- Starts all alpha timer for transitions.
-- @internal
function SVMOD.Metatable:SV_StartAlphaTimer()
	local hiddenTime

	local function activeTime(timerName, sprite)
		sprite.Color.a = 255

		timer.Create(timerName, sprite.ActiveTime, 1, function()
			hiddenTime(timerName, sprite)
		end)
	end

	function hiddenTime(timerName, sprite)
		sprite.Color.a = 0

		timer.Create(timerName, sprite.HiddenTime, 1, function()
			activeTime(timerName, sprite)
		end)
	end

	for i, v in ipairs(self.SV_Data.FlashingLights) do
		if v.Sprite and v.Sprite.ActiveTime and v.Sprite.ActiveTime ~= 0 then
			local firstTimer = v.Sprite.ActiveTime + (v.Sprite.OffsetTime or 0)

			timer.Create("SV_LightAlpha_" .. self:EntIndex() .. "_Sprite_" .. i, firstTimer, 1, function()
				activeTime("SV_LightAlpha_" .. self:EntIndex() .. "_Sprite_" .. i, v.Sprite)
			end)
		end

		if v.SpriteCircle and v.SpriteCircle.ActiveTime and v.SpriteCircle.ActiveTime ~= 0 then
			local firstTimer = v.SpriteCircle.ActiveTime + (v.SpriteCircle.OffsetTime or 0)

			timer.Create("SV_LightAlpha_" .. self:EntIndex() .. "_SpriteCircle_" .. i, firstTimer, 1, function()
				activeTime("SV_LightAlpha_" .. self:EntIndex() .. "_SpriteCircle_" .. i, v.SpriteCircle)
			end)
		end
	end
end

-- Stops all alpha timer for transitions.
-- @internal
function SVMOD.Metatable:SV_StopAlphaTimer()
	for _, l in ipairs(self.SV_Data.FlashingLights) do
		for i, v in ipairs(l) do
			if v.Sprite and v.Sprite.ActiveTime ~= 0 then
				timer.Remove("SV_LightAlpha_" .. self:EntIndex() .. "_Sprite_" .. i)
			end

			if v.SpriteCircle and v.SpriteCircle.ActiveTime ~= 0 then
				timer.Remove("SV_LightAlpha_" .. self:EntIndex() .. "_SpriteCircle_" .. i, 1)
			end
		end
	end
end
--lua/svmod/lights/backlights/sh_backlights.lua:
-- @class SV_Vehicle
-- @shared

-- Gets the state of the vehicle's back lights.
-- @treturn boolean True if enabled, false if disabled
function SVMOD.Metatable:SV_GetBackLightsState()
	if self:SV_IsPassengerSeat() then
		return self:SV_GetDriverSeat().SV_States.BackLights
	end
	return self.SV_States.BackLights
end
--lua/svmod/lights/blinker/cl_blinker.lua:
return gluapack()()
--lua/svmod/lights/blinker/sh_blinker.lua:
return gluapack()()
--lua/svmod/lights/blinker/sh_blinker.lua:
-- @class SV_Vehicle
-- @shared

-- Gets the state of the left blinkers.
-- @treturn boolean True if enabled, false if disabled
function SVMOD.Metatable:SV_GetLeftBlinkerState()
	if self:SV_IsPassengerSeat() then
		return self:SV_GetDriverSeat().SV_States.LeftBlinkers
	end
	return self.SV_States.LeftBlinkers
end

-- Gets the state of the right blinkers.
-- @treturn boolean True if enabled, false if disabled
function SVMOD.Metatable:SV_GetRightBlinkerState()
	if self:SV_IsPassengerSeat() then
		return self:SV_GetDriverSeat().SV_States.RightBlinkers
	end
	return self.SV_States.RightBlinkers
end
--lua/svmod/vehicles/sh_speed.lua:
-- @class SV_Vehicle
-- @shared

-- Gets the vehicle speed in km/h.
--
-- You should use the cached version if you are going to
-- call it often (like in a draw).
-- @treturn number Vehicle speed in km/h
function SVMOD.Metatable:SV_GetSpeed()
	local veh = self
	if self:SV_IsPassengerSeat() then
		veh = self:SV_GetDriverSeat()
	end

	return math.Round(veh:GetVelocity():Length() / 10.936133)
end

-- Returns the vehicle cached speed in km/h. This value
-- is updated once every 0.2 second.
--
-- You can call it every frame in a draw.
-- @treturn number Vehicle speed in km/h
function SVMOD.Metatable:SV_GetCachedSpeed()
	if not self.SV_SavedSpeed or not self.SV_SavedSpeedTime or CurTime() > self.SV_SavedSpeedTime then
		self.SV_SavedSpeed = self:SV_GetSpeed()
		self.SV_SavedSpeedTime = CurTime() + 0.2
	end

	return self.SV_SavedSpeed
end
--lua/autorun/tdmcars_commercial.lua:
local PrVeh = "prop_vehicle_jeep"
local Cat = "TDM Commercial"

local V = {
			Name = "Orion VII NG", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Ubisoft",
			Information = "A drivable Bus by TheDanishMaster",
				Model = "models/tdmcars/bus.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/tdmcars/bus.txt"
							}
			}
list.Set("Vehicles", "bustdm", V)

local V = {
			Name = "Courier Truck", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Ubisoft",
			Information = "A drivable Courier Truck by TheDanishMaster",
				Model = "models/tdmcars/courier_truck.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/tdmcars/courier_truck.txt"
							}
			}
list.Set("Vehicles", "courier_trucktdm", V)




 if SERVER then
	hook.Add("Think", "TDMOrion_BusDoors", function()
		for _, ent in pairs(ents.FindByClass("prop_vehicle_jeep*")) do
				if ent:GetModel() == "models/tdmcars/bus.mdl" then
				local FrontDoor = 0
				local RearDoor = 0
			if IsValid(ent:GetDriver()) then
				if ent:GetDriver():KeyDown(IN_ATTACK) then 
					FrontDoor = 1 
				end
				if ent:GetDriver():KeyDown(IN_ATTACK2) then 
					RearDoor = 1 
				end
				if ent:GetDriver():KeyPressed(IN_ATTACK) or ent:GetDriver():KeyPressed(IN_ATTACK2) then ent:EmitSound("vehicles/tdmcars/bus/door_sound.mp3") end 
			end
			ent.BusDoorF = Lerp(0.02, ent.BusDoorF or 0, FrontDoor)
			ent:SetPoseParameter("doors_front", ent.BusDoorF)
			ent.BusDoorR = Lerp(0.02, ent.BusDoorR or 0, RearDoor)
			ent:SetPoseParameter("doors_rear", ent.BusDoorR)


			end
		end
	end)
end
--lua/autorun/tdmcars_emergency.lua:
return gluapack()()
--addons/override_workshop/lua/autorun/tdmcars_ford.lua:
local PrVeh = "prop_vehicle_jeep"
local Cat = "TDM Cars"

local V = {
			Name = "Ford Focus RS", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Ford Focus RS by TheDanishMaster",
			Model = "models/tdmcars/focusrs.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/focusrs.txt"
							}
			}
list.Set("Vehicles", "focusrstdm", V)

local V = {
			Name = "Ford Focus RS '16", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, NM",
			Information = "A drivable Ford Focus RS '16 by TheDanishMaster",
			Model = "models/tdmcars/for_focus_rs16.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/for_focus_rs16.txt"
							}
			}
list.Set("Vehicles", "for_focus_rs16tdm", V)

local V = {
			Name = "Ford Crown Victoria Taxi", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, freemmaann, Turn 10",
			Information = "A drivable Ford Crown Victoria Taxi by TheDanishMaster",
			Model = "models/tdmcars/crownvic_taxi.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/crownvic_taxi.txt"
							}
			}
list.Set("Vehicles", "crownvic_taxitdm", V)

local V = {
			Name = "Ford Deluxe Coupe 1940", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, freemmaann, Turn 10",
			Information = "A drivable Ford Deluxe Coupe 1940 by TheDanishMaster",
			Model = "models/tdmcars/ford_coupe_40.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/coupe40.txt"
							}
			}
list.Set("Vehicles", "coupe40tdm", V)

local V = {
			Name = "Ford F100", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Ford F100 by TheDanishMaster",
				Model = "models/tdmcars/for_f100.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/f100.txt"
							}
			}
list.Set("Vehicles", "f100tdm", V)

local V = {
			Name = "Ford F350 SuperDuty", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Ubisoft",
			Information = "A drivable Ford F350 SuperDuty by TheDanishMaster",
				Model = "models/tdmcars/for_f350.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/f350.txt"
							}
			}
list.Set("Vehicles", "f350tdm", V)

local V = {
			Name = "Ford Focus SVT", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Ford Focus SVT by TheDanishMaster",
				Model = "models/tdmcars/for_focussvt.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/focussvt.txt"
							}
			}
list.Set("Vehicles", "focussvttdm", V)

local V = {
			Name = "Ford GT 05", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, freemmaann, Turn 10",
			Information = "A drivable Ford GT 05 by TheDanishMaster",
			Model = "models/tdmcars/gt05.mdl",	
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/gt05.txt"
							}
			}
list.Set("Vehicles", "gt05tdm", V)

local V = {
			Name = "Ford Raptor SVT", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Ford Raptor SVT by TheDanishMaster",
				Model = "models/tdmcars/for_raptor.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/raptorsvt.txt"
							}
			}
list.Set("Vehicles", "raptorsvttdm", V)

local V = {
			Name = "Ford Transit", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, freemmaann, Turn 10",
			Information = "A drivable Ford Transit by TheDanishMaster",
			Model = "models/tdmcars/ford_transit.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/transit.txt"
							}
			}
list.Set("Vehicles", "transittdm", V)

local V = {
			Name = "Ford Mustang GT", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Ford Mustang GT by TheDanishMaster",
				Model = "models/tdmcars/for_mustanggt.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/mustanggt.txt"
							}
			}
list.Set("Vehicles", "mustanggttdm", V)

local V = {
			Name = "Ford Shelby GT500", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Ford Shelby GT500 by TheDanishMaster",
				Model = "models/tdmcars/for_she_gt500.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/for_she_gt500.txt"
							}
			}
list.Set("Vehicles", "for_she_gt500tdm", V)
--lua/autorun/tdmcars_merml63.lua:
local V = {
			Name = "Mercedes-Benz ML63 AMG", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Mercedes-Benz ML63 AMG by TheDanishMaster",
			Model = "models/tdmcars/mer_ml63.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/ml63.txt"
							}
			}
list.Set("Vehicles", "merml63tdm", V)
--lua/autorun/tdmcars_merslr.lua:
local V = {
			Name = "Mercedes McLaren SLR", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Mercedes McLaren SLR by TheDanishMaster",
			Model = "models/tdmcars/mer_slr.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/mer_slr.txt"
							}
			}
list.Set("Vehicles", "mer_slrtdm", V)
 if SERVER then
hook.Add("Think", "TDMAirbrake_MerSLR", function()
for _, ent in pairs(ents.FindByClass("prop_vehicle_jeep*")) do
if ent:GetModel() == "models/tdmcars/mer_slr.mdl" then
local AirBrk = 0
if IsValid(ent:GetDriver()) then
if ent:GetDriver():KeyDown(IN_BACK) and ent:GetVelocity():Length() > 800 then AirBrk = 1 end
end
ent.AirBrake = Lerp(0.2, ent.AirBrake or 1, AirBrk)
ent:SetPoseParameter("airbrake_pose", ent.AirBrake)
end
end
end)
end
--lua/autorun/tdmcars_porrsrgt3.lua:
return gluapack()()
--lua/autorun/tdmcars_sl65.lua:
local V = {
			Name = "Mercedes-Benz SL65 AMG", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster, freemmaann, Turn 10",
			Information = "A drivable Mercedes SL65 AMG by TheDanishMaster",
			Model = "models/tdmcars/sl65amg.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/sl65amg.txt"
							}
			}
list.Set("Vehicles", "sl65amgtdm", V)
--addons/voidlib/lua/voidlib/cl_notify.lua:
VoidLib.CurrentNotification = nil

local prevY = -30
function VoidLib.Notify(upper, text, color, length)

    VoidLib.CurrentNotification = {
        start = CurTime(),
        upper = upper,
        text = text,
        color = color,
        length = length,
        goUp = false,
    }

    prevY = -30

    local origTime = CurTime()
    timer.Simple(length*0.7, function ()
        if (!VoidLib.CurrentNotification) then return end
        if (VoidLib.CurrentNotification.start != origTime) then return end
        VoidLib.CurrentNotification.goUp = true
    end)
    timer.Simple(length, function ()
        if (!VoidLib.CurrentNotification) then return end
        if (VoidLib.CurrentNotification.start != origTime) then return end
        VoidLib.CurrentNotification = nil
    end)
end

net.Receive("VoidLib.NotifyPlayer", function ()
    local upper = net.ReadString()
    local text = net.ReadString()
    local color = net.ReadColor()
    local length = net.ReadUInt(8)

    VoidLib.Notify(upper, text, color, length)
end)

hook.Add("DrawOverlay", "VoidUI.DrawNotifications", function ()
    if (!VoidLib.CurrentNotification) then return end
    local notify = VoidLib.CurrentNotification

    local h = 75

    surface.SetFont("VoidUI.R38")
    local textSize = surface.GetTextSize(notify.text)

    surface.SetFont("VoidUI.R24")
    local upperTextSize = surface.GetTextSize(notify.upper)

    local maxWidth = upperTextSize > textSize and upperTextSize or textSize
    
    local w = maxWidth + 100
    local x = ScrW() / 2 - w/2

    local y = 0
    -- fake lerp!
    if (notify.goUp) then
        y = Lerp(notify.length * 2 * FrameTime(), prevY, -100)
    else
        y = Lerp(notify.length * 2 * FrameTime(), prevY, 60)
    end

    prevY = y

    surface.SetDrawColor(notify.color)
    surface.DrawRect(x, y, w, h)

    draw.SimpleText(notify.upper, "VoidUI.R24", x+w/2, y+5, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    draw.SimpleText(notify.text, "VoidUI.R38", x+w/2, y+25, VoidUI.Colors.White, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

end)

--addons/voidlib/lua/voidlib/cl_tracker.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/sh_utils.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/backgroundpanel.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
    self:SDockPadding(15, 15, 15, 15)

    self.hasText = false
    self.hasTitle = false
    self.textFont = "VoidUI.B24"
    self.text = "PANEL"
    self.wrappedText = self.text
    self.strSlightFont = "VoidUI.R14"

    self.textColor = VoidUI.Colors.White
    self.slightColor = VoidUI.Colors.LightGray
    self.wrapped = false
end

function PANEL:SetText(text)
    self.hasText = true
    self.text = text
    self:CalcWrap()
end

function PANEL:SetTitle(title, strDesc)
    self.hasTitle = true
    self.title = title
    self.textFont = "VoidUI.R24"
    self.strDesc = strDesc

end

function PANEL:WrapText()
    self.wrapped = true
    self:CalcWrap()
end

function PANEL:CalcWrap()
    if (!self.wrapped) then return end

    self:InvalidateLayout(true)
end

function PANEL:PerformLayout(w, h)
    if (!self.wrapped) then return end

    local width = w - sc(40)
    self.wrappedText = VoidUI.TextWrap(self.text, self.textFont, width)
end

function PANEL:SetTextColor(col)
    self.textColor = col
end

function PANEL:SetFont(font)
    self.textFont = font
    self:CalcWrap()
end

function PANEL:Paint(w, h)
    draw.RoundedBox(12, 0, 0, w, h, VoidUI.Colors.Primary)

    if (self.hasText) then
        if (self.wrapped) then
            draw.DrawText(self.wrappedText, self.textFont, sc(20), sc(15), self.textColor, TEXT_ALIGN_LEFT)
        else
            draw.SimpleText(self.text, self.textFont, w/2, h/2, self.textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    if (self.hasTitle) then
        if (!self.strDesc) then
            draw.SimpleText(self.title, self.textFont, sc(15), sc(15), self.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        else
            draw.SimpleText(self.title, self.textFont, sc(15), sc(15), self.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
            draw.SimpleText(self.strDesc, self.strSlightFont, sc(15), sc(51), self.slightColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
        end
    end
end

vgui.Register("VoidUI.BackgroundPanel", PANEL, "Panel")
--addons/voidlib/lua/voidlib/vgui/bshadows.lua:
--This code can be improved a lot.
--Feel free to improve, use or modify in any way although credit would be appreciated.
--Made by Code Blue

--Global table
if BSHADOWS == nil then
BSHADOWS = {}

--The original drawing layer
BSHADOWS.RenderTarget = GetRenderTarget("bshadows_original", ScrW(), ScrH())

--The shadow layer
BSHADOWS.RenderTarget2 = GetRenderTarget("bshadows_shadow",  ScrW(), ScrH())

--The matarial to draw the render targets on
BSHADOWS.ShadowMaterial = CreateMaterial("bshadows","UnlitGeneric",{
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

--When we copy the rendertarget it retains color, using this allows up to force any drawing to be black
--Then we can blur it to create the shadow effect
BSHADOWS.ShadowMaterialGrayscale = CreateMaterial("bshadows_grayscale","UnlitGeneric",{
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

--Call this to begin drawing a shadow
BSHADOWS.BeginShadow = function()

	--Set the render target so all draw calls draw onto the render target instead of the screen
	render.PushRenderTarget(BSHADOWS.RenderTarget)

	--Clear is so that theres no color or alpha
	render.OverrideAlphaWriteEnable(true, true)
	render.Clear(0,0,0,0)
	render.OverrideAlphaWriteEnable(false, false)

	--Start Cam2D as where drawing on a flat surface 
	cam.Start2D()

	--Now leave the rest to the user to draw onto the surface
end

--This will draw the shadow, and mirror any other draw calls the happened during drawing the shadow
BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	
	--Set default opcaity
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0
	_shadowOnly = _shadowOnly or false

	--Copy this render target to the other
	render.CopyRenderTargetToTexture(BSHADOWS.RenderTarget2)

	--Blur the second render target
	if blur > 0 then
		render.OverrideAlphaWriteEnable(true, true)
		render.BlurRenderTarget(BSHADOWS.RenderTarget2, spread, spread, blur)
		render.OverrideAlphaWriteEnable(false, false) 
	end

	--First remove the render target that the user drew
	render.PopRenderTarget()

	--Now update the material to what was drawn
	BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BSHADOWS.RenderTarget)

	--Now update the material to the shadow render target
	BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BSHADOWS.RenderTarget2)

	--Work out shadow offsets
	local xOffset = math.sin(math.rad(direction)) * distance 
	local yOffset = math.cos(math.rad(direction)) * distance

	--Now draw the shadow
	BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity/255) --set the alpha of the shadow
	render.SetMaterial(BSHADOWS.ShadowMaterialGrayscale)
	for i = 1 , math.ceil(intensity) do
		render.DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		--Now draw the original
		BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BSHADOWS.RenderTarget)
		render.SetMaterial(BSHADOWS.ShadowMaterial)
		render.DrawScreenQuad()
	end

	cam.End2D()
end

--This will draw a shadow based on the texture you passed it.
BSHADOWS.DrawShadowTexture = function(texture, intensity, spread, blur, opacity, direction, distance, shadowOnly)

	--Set default opcaity
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0
	shadowOnly = shadowOnly or false

	--Copy the texture we wish to create a shadow for to the shadow render target
	render.CopyTexture(texture, BSHADOWS.RenderTarget2)

	--Blur the second render target
	if blur > 0 then
		render.PushRenderTarget(BSHADOWS.RenderTarget2)
		render.OverrideAlphaWriteEnable(true, true)
		render.BlurRenderTarget(BSHADOWS.RenderTarget2, spread, spread, blur)
		render.OverrideAlphaWriteEnable(false, false) 
		render.PopRenderTarget()
	end

	--Now update the material to the shadow render target
	BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BSHADOWS.RenderTarget2)

	--Work out shadow offsets
	local xOffset = math.sin(math.rad(direction)) * distance 
	local yOffset = math.cos(math.rad(direction)) * distance

	--Now draw the shadow 
	BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity/255) --Set the alpha
	render.SetMaterial(BSHADOWS.ShadowMaterialGrayscale)
	for i = 1 , math.ceil(intensity) do
		render.DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end
	if not shadowOnly then
		--Now draw the original
		BSHADOWS.ShadowMaterial:SetTexture('$basetexture', texture)
		render.SetMaterial(BSHADOWS.ShadowMaterial)
		render.DrawScreenQuad()
	end
end
end

--addons/voidlib/lua/voidlib/vgui/button.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/card.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/card.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
    self.accent = VoidUI.Colors.Blue

    self.gradientStart = VoidUI.Colors.BlueLineGradientEnd
    self.gradientEnd = VoidUI.Colors.BlueGradientStart

    self.titleUpper = "Testing"
    self.titleLower = "Card"

    self.content = "Lorem ipsum, placeholder, placeholder. Blah blah blah blah, no one really cares."

    self.button = self:Add("VoidUI.Button")
    self.button:Dock(BOTTOM)
    self.button:SSetTall(45)

    self.button:MarginSides(45)
    self.button:MarginBottom(40)
end

function PANEL:SetTitle(lower, upper)
    self.titleUpper = upper
    self.titleLower = lower
end

function PANEL:SetContent(text)
    self.content = text
end

function PANEL:SetAccent(col)
    self.accent = col
    self.button:SetColor(col)
end

function PANEL:SetGradient(startCol, endCol)
    self:SetGradientStart(startCol)
    self:SetGradientEnd(endCol)
end

function PANEL:SetGradientStart(col)
    self.gradientStart = col
end
function PANEL:SetGradientEnd(col)
    self.gradientEnd = col
end

function PANEL:SetFooter(text)
    self.footer = text
end

function PANEL:Paint(w, h)
    draw.RoundedBox(8, 0, 0, w, h, VoidUI.Colors.Primary)

    local x, y = self:LocalToScreen(0, 0)

    local baseX = sc(220)
    local verts = {
        {x = baseX + sc(15), y = 0},
        {x = baseX + sc(30), y = 0},
        {x = baseX + sc(15) - sc(30), y = h},
        {x = baseX - sc(30), y = h}
    }
    baseX = baseX + sc(25)
    local verts2 = {
        {x = baseX + sc(15), y = 0},
        {x = baseX + sc(40), y = 0},
        {x = baseX + sc(25) - sc(30), y = h},
        {x = baseX - sc(30), y = h}
    }

    VoidUI.StencilMaskStart()
        surface.SetDrawColor(VoidUI.Colors.White)
        draw.NoTexture()
        surface.DrawPoly(verts)
        surface.DrawPoly(verts2)
    VoidUI.StencilMaskApply()
        VoidUI.SimpleLinearGradient(x+sc(100), y, w-sc(100), h, self.gradientStart, self.gradientEnd)
    VoidUI.StencilMaskEnd()

    draw.SimpleText(self.titleUpper, "VoidUI.B28", sc(25), sc(25), self.accent, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    draw.SimpleText(self.titleLower, "VoidUI.B38", sc(25), sc(25) + sc(23), VoidUI.Colors.White, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

    local wrappedText = VoidUI.TextWrap(self.content, "VoidUI.R18", sc(180))
    draw.DrawText(wrappedText, "VoidUI.R18", sc(25), sc(100), VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

    if (self.footer) then
        draw.SimpleText(self.footer, "VoidUI.R14", sc(15), h-sc(10), VoidUI.Colors.GrayTransparent, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
    end
end

vgui.Register("VoidUI.Card", PANEL, "Panel")
--addons/voidlib/lua/voidlib/vgui/dropdown.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
	self:SetFont("VoidUI.R26")
	self:SetTextColor(VoidUI.Colors.Gray)

	-- self.DropButton.Paint = function (self, w, h)
	--     -- Dropdown arrow goes here
	-- end

	self.color = VoidUI.Colors.InputDark
	self.isCentered = false


	local prevAddChoice = self.AddChoice

	self.AddChoice = function (s, val, data, select, icon)
		prevAddChoice(s, val, data, select, icon)

		surface.SetFont("VoidUI.R26")
		if (#val > 13) then
			self:SetFont("VoidUI.R22")
		end

		return #self.Choices
	end

end


function PANEL:ChooseOption( value, index )

	if (self.Menu and !self.multiple) then
		self.Menu:Remove()
		self.Menu = nil
	end

	if (!self.multiple and value) then
		self:SetText( value )
	end

	self.selected = index
	self:OnSelect(index, value, self.Data[index])

	self.textCol = VoidUI.Colors.TextGray

	if (self.isChoice) then
		self.value = self:GetSelectedID() == 1
	end

end

function PANEL:Center()
	self:SetContentAlignment(5)
end

function PANEL:SetupChoice(yes, no, default)
	self:AddChoice(yes)
	self:AddChoice(no)

	self:ChooseOptionID(default and 1 or 2)

	self.isChoice = true

	self.value = self:GetSelectedID() == 1
end

function PANEL:OpenMenu(pControlOpener)

	if (pControlOpener && pControlOpener == self.TextEntry) then
		return
	end

	if (#self.Choices == 0) then return end
	if (IsValid(self.Menu)) then
		self.Menu:Remove()
		self.Menu = nil
	end

	local this = self

	self.Menu = DermaMenu(false, self)

	function self.Menu:AddOption(strText, funcFunction)

        local pnl = vgui.Create("DMenuOption", self)
        pnl:SetMenu(self)
        pnl:SetIsCheckable(true)
		if (funcFunction) then pnl.DoClick = funcFunction end


        function pnl:OnMouseReleased(mousecode)
            DButton.OnMouseReleased(self, mousecode)
            if (self.m_MenuClicking && mousecode == MOUSE_LEFT) then
                self.m_MenuClicking = false
            end
        end

        self:AddPanel(pnl)

        return pnl
    end

	for k, v in pairs(self.Choices) do
		local option = self.Menu:AddOption( v, function() self:ChooseOption(v, k) end )

		function option:PerformLayout(w, h)
			self:SetTall(40)
		end

		local this = self
		

		option.Paint = function (self, w, h)
			local col = (self:IsHovered() and VoidUI.Colors.Primary) or VoidUI.Colors.InputLight
			local dropdownParent = self:GetParent():GetParent():GetParent()
			if (dropdownParent.multiple and dropdownParent.selectedItems[v]) then
				col = VoidUI.Colors.Blue
			end

			if (k == #this.Choices) then
				draw.RoundedBoxEx(12, 0, 0, w, h, col, false, false, true, true)
			else
				surface.SetDrawColor(col)
				surface.DrawRect(0,0,w,h)
			end

			draw.SimpleText(v, "VoidUI.R20", sc(10), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			
			return true
		end
	end

	local x, y = self:LocalToScreen(5, self:GetTall())

	self.Menu:SetMinimumWidth(self:GetWide() - 10)
	self.Menu:Open(x, y, false, self)
	self.Menu.Paint = nil

end

function PANEL:SetLight()
	self.color = VoidUI.Colors.InputLight
end


function PANEL:Paint(w, h)
	draw.RoundedBox(8, 0, 0, w, h, self.color)
end

vgui.Register("VoidUI.Dropdown", PANEL, "DComboBox")

--addons/voidlib/lua/voidlib/vgui/frame.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/imageid_input.lua:
local PANEL = {}

function PANEL:Init()
	self.entry:SetPaintBackground(true)
	
	self.entry:SetFont("VoidUI.R26")

    self.imageProvider = "i.imgur.com/"
end

function PANEL:SetImageProvider(strProvider)
    self.imageProvider = strProvider
end

function PANEL:PerformLayout(w, h)
	self.entry:Dock(FILL)
	self.entry:DockMargin(ScrH() * 0.1203, 8, 10, 8)
end

function PANEL:Paint(w, h)
	draw.RoundedBox(8, 0, 0, w, h, VoidUI.Colors.Gray)

	local text = self.imageProvider
	text = string.Replace(text, ".png", "")
	text = string.Replace(text, "%s", "")
	text = string.Replace(text, "https://", "")
	text = string.Replace(text, "http://", "")

	draw.SimpleText(text, "VoidUI.R24", 10, h/2, VoidUI.Colors.TextGray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register("VoidUI.ImageIDInput", PANEL, "VoidUI.TextInput")

--addons/voidlib/lua/voidlib/vgui/paginationpanel.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
    self.from = 1
    self.to = 6

    self.page = 1
    self.totalPages = 1


    self.showingPhrase = "Showing :from:-:to:"
    self.pagePhrase = "Page"
    self.fromPhrase = "From"


    local pageSelector = self:Add("Panel")
    pageSelector:Dock(RIGHT)
    pageSelector:SSetWide(220)
    pageSelector.Paint = function (s, w, h)
        draw.SimpleText(string.upper(self.pagePhrase), "VoidUI.R22", 0, h/2, VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

        surface.SetDrawColor(VoidUI.Colors.Green)
        VoidUI.DrawCircle(sc(85), h/2, sc(10), 1)

        draw.SimpleText(self.page, "VoidUI.B20", sc(85), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(string.upper(self.fromPhrase), "VoidUI.R22", sc(150), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(self.totalPages, "VoidUI.B22", w-sc(20), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
    end

    local pageLeft = pageSelector:Add("DButton")
    pageLeft:Dock(LEFT)
    pageLeft:SetText("")
    pageLeft:MarginLeft(60)
    pageLeft:SSetWide(10)
    pageLeft.Paint = function (s, w, h)
        local color = s:IsHovered() and VoidUI.Colors.Green or VoidUI.Colors.Gray
        draw.SimpleText("<", "VoidUI.B22", w/2, h/2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    pageLeft.DoClick = function ()
        self.page = math.max(self.page - 1, 1)
        self.pageChangeFunc(self.page)
    end

    local pageRight = pageSelector:Add("DButton")
    pageRight:Dock(LEFT)
    pageRight:SetText("")
    pageRight:MarginLeft(30)
    pageRight:SSetWide(10)
    pageRight.Paint = function (s, w, h)
        local color = s:IsHovered() and VoidUI.Colors.Green or VoidUI.Colors.Gray
        draw.SimpleText(">", "VoidUI.B22", w/2, h/2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    pageRight.DoClick = function ()
        self.page = math.min(self.page + 1, self.totalPages)
        self.pageChangeFunc(self.page)
    end

    self.pageSelector = pageSelector
end

function PANEL:SetTranslations(showing, page, from)
    self.showingPhrase = showing
    self.pagePhrase = page
    self.fromPhrase = from
end

function PANEL:SetFromTo(from, to)
    self.from = from
    self.to = to
end

function PANEL:TotalPages(total)
    self.totalPages = total
end

function PANEL:PageChange(func)
    self.pageChangeFunc = func
end

function PANEL:CurrentPage(page)
    self.page = page
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, w, h, VoidUI.Colors.BackgroundTransparent)

    local fShowing = VoidLib.StringFormat(self.showingPhrase, {
        from = self.from,
        to = self.to
    })
    draw.SimpleText(string.upper(fShowing), "VoidUI.R22", sc(20), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register("VoidUI.PaginationPanel", PANEL, "Panel")
--addons/voidlib/lua/voidlib/vgui/scrollpanel.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/scrollpanel.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
	self:Dock(FILL)
	self.defaultColor = VoidUI.Colors.TextGray
	self.hoverColor = VoidUI.Colors.GrayTransparent

	local this = self
	local sbar = self:GetVBar()

	sbar.Paint = function (self, w, h)
		draw.RoundedBox(24, sc(8), 0, w-sc(8), h, VoidUI.Colors.Background)
	end

	sbar.btnGrip.Paint = function (self, w, h)
		local color = self:IsHovered() and this.hoverColor or this.defaultColor
		draw.RoundedBox(24, sc(8), 0, w-sc(8), h, color)
	end

	sbar:SetHideButtons(true)
end


vgui.Register("VoidUI.ScrollPanel", PANEL, "DScrollPanel")

--addons/voidlib/lua/voidlib/vgui/table.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/core/sh_config.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/features/invites/cl_invites.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/features/lastseen/sh_lastseen.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_capturepoint.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_capturepoint.lua:
VoidFactions.CapturePoints = VoidFactions.CapturePoints or {}

-- Class

local CAPTUREPOINT_CLASS = {}
CAPTUREPOINT_CLASS.__index = CAPTUREPOINT_CLASS

function CAPTUREPOINT_CLASS:New(id, pos, radius)
	local newObject = setmetatable({}, CAPTUREPOINT_CLASS)
		newObject.id = id
        newObject.pos = pos
        newObject.radius = radius
    
        newObject.isSelected = false
        newObject.captureInProgress = false

        newObject.isPaused = false
        newObject.pauseTime = 0

        newObject.capturingBy = nil

        newObject.capturingPlayers = {}
        newObject.isContested = false

        newObject.captureFaction = nil 
        newObject.captureStart = 0 -- curtime
        newObject.captureEnd = 0

        newObject.previousPlayers = {}
        newObject.previousPlayersSeq = {}

	return newObject
end

-- Setter functions

function CAPTUREPOINT_CLASS:SetPos(pos)
    self.pos = pos
end

function CAPTUREPOINT_CLASS:SetRadius(radius)
    self.radius = radius
end

function CAPTUREPOINT_CLASS:SetCapturingPlayers(plys)
    self.capturingPlayers = plys
end

function CAPTUREPOINT_CLASS:SetFaction(faction)
    self.captureFaction = faction
end

function CAPTUREPOINT_CLASS:SetCaptureStart(start)
    self.captureStart = start
end

-- Functions

function VoidFactions.CapturePoints:InitCapturePoint(...)
    return CAPTUREPOINT_CLASS:New(...)
end
--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_reward.lua:
VoidFactions.Rewards = VoidFactions.Rewards or {}
VoidFactions.Rewards.List = SERVER and {} or nil

-- Class

local REWARD_CLASS = {}
REWARD_CLASS.__index = REWARD_CLASS

function REWARD_CLASS:New(id, name, module, requiredValue, money, xp, icon)
	local newObject = setmetatable({}, REWARD_CLASS)
		newObject.id = id
        newObject.name = name
        newObject.module = module

        newObject.requiredValue = requiredValue

        newObject.money = money
        newObject.xp = xp

        newObject.icon = icon
	return newObject
end

-- Setter functions

function REWARD_CLASS:SetName(name)
    self.name = name
end

function REWARD_CLASS:SetModule(module)
    self.module = module
end

function REWARD_CLASS:SetRequiredValue(val)
    self.requiredValue = val
end

function REWARD_CLASS:SetMoneyReward(money)
    self.money = money
end

function REWARD_CLASS:SetXPReward(xp)
    self.xp = xp
end

function REWARD_CLASS:SetIcon(icon)
    self.icon = icon
end


-- Functions

function VoidFactions.Rewards:New(...)
    return REWARD_CLASS:New(...)
end
--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_transactionhistory.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/capturetime.lua:
local UPGRADE = VoidFactions.Upgrades:NewUpgrade()

UPGRADE:Name("upgr_capturetime")
UPGRADE:Icon("VnRF6PL")

UPGRADE:Description("upgr_desc_capturetime")
UPGRADE:ValueDescription("upgr_descval_capturetime")

UPGRADE:FormatValue(function (val)
    return "-" .. val .. "s"
end)

VoidFactions.Upgrades:AddUpgrade(UPGRADE)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/jumpboost.lua:
local UPGRADE = VoidFactions.Upgrades:NewUpgrade()

UPGRADE:Name("upgr_jumpboost")
UPGRADE:Icon("iYg63Tc")

UPGRADE:Numeric()

UPGRADE:Description("upgr_desc_jumpboost")
UPGRADE:ValueDescription("upgr_descval_jumpboost")

UPGRADE:FormatValue(function (val)
    return "+" .. val .. "%"
end)

UPGRADE:OnReset(function (ply)
    if (!SERVER) then return end

    ply:SetJumpPower(ply.origJumpPower)
end)

UPGRADE:OnRespawn(function (ply, val)
    if (!SERVER) then return end

    timer.Simple(1, function ()
        ply.origJumpPower = ply:GetJumpPower()

        local percentage = val / 100
        local multiplier = percentage + 1

        ply:SetJumpPower(ply:GetJumpPower() * multiplier)
    end)
end)

VoidFactions.Upgrades:AddUpgrade(UPGRADE)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/maxitems.lua:
local UPGRADE = VoidFactions.Upgrades:NewUpgrade()

UPGRADE:Name("upgr_maxitems")
UPGRADE:Icon("2QtUrlI")

UPGRADE:Description("upgr_desc_maxitems")
UPGRADE:ValueDescription("upgr_descval_maxitems")

UPGRADE:FormatValue(function (val)
    return "+ " .. val
end)

VoidFactions.Upgrades:AddUpgrade(UPGRADE)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/rewards/pointscaptured.lua:
local REWARD = VoidFactions.RewardModules:NewReward()
REWARD:Name("reward_pointscaptured")
REWARD:Description("reward_desc_pointscaptured")

REWARD:DefaultIcon("qVF75eP")

REWARD:Setup(function ()

    hook.Add("VoidFactions.CapturePoints.PointCaptured", "VoidFactions.Rewards.PointCapped", function (faction)
        REWARD:Increment(faction)
    end)

end)

VoidFactions.RewardModules:AddReward(REWARD)
--addons/voidfactions-1.10.6/lua/voidfactions/net/member/cl_member.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/faction_create.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/rank_create.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/intro_panel.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/options_panel.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/static/profile_panel.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/network/core.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Network",
    setPrefix = function(self, prefix)
      self.prefix = prefix
      return self
    end,
    getPrefix = function(self)
      return self.prefix
    end,
    prepare = function(self, str)
      if istable(str) then
        for i, v in ipairs(str) do
          util.AddNetworkString(self:getPrefix() .. v)
        end
      else
        util.AddNetworkString(self:getPrefix() .. str)
      end
    end,
    receiver = function(self, name, func)
      if func == nil then func = function() end
      end
      net.Receive(self:getPrefix() .. name, function(len, ply)
        func(self, ply or LocalPlayer(), len)
      end)
    end,
    send = function(self, name, target, func)
      net.Start(self:getPrefix() .. name)

      if CLIENT then
        target(self)

        net.SendToServer()
      else
        func(self)

        net.Send(target)
      end
    end,
    compress = function(self, data)
      local tbl = false
      if istable(data) then
        data = util.TableToJSON(data)
        tbl = true
      end

      data = util.Compress(data)
      local len = data:len()

      net.WriteUInt(len, 32)
      net.WriteBool(tbl)
      net.WriteData(data, len)
    end,
    decompress = function(self)
      local len = net.ReadUInt(32)
      local tbl = net.ReadBool()
      local data = net.ReadData(len)
      data = util.Decompress(data)

      if tbl then
        data = util.JSONToTable(data)
      end

      return data
    end,
    getNetworkType = function(self, input)
      if isnumber(input) then
        local int, frac = math.modf(input)
        if (frac != 0) then
          return self.FLOAT
        end

        return self.INTEGER
      elseif (isbool(input) or input == nil) then
        return self.BOOL
      elseif isstring(input) then
        return self.STRING
      elseif istable(input) then
        return self.TABLE
      end
    end,
    writeType = function(self, input)
      local type = self:getNetworkType(input)
      net.WriteUInt(type, self.DYNAMIC_DATA_SIZE)

      return type
    end,
    readType = function(self, input)
      return net.ReadUInt(self.DYNAMIC_DATA_SIZE)end,
    write = function(self, input, ...)
      local type = self:writeType(input)
      self:writeFromType(type, input, ...)

      return type
    end,
    read = function(self, ...)
      local type = self:readType()
      return self:readFromType(type, ...)
    end,
    writeFromType = function(self, type, input, ...)
      self.writeTypes[type](input, ...)end,
    readFromType = function(self, type, ...)
      return self.readTypes[type](...)end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.TABLE = 4
      self.STRING = 3
      self.BOOL = 2
      self.INTEGER = 1
      self.FLOAT = 0
      self.DYNAMIC_DATA_SIZE = 3
      self:setPrefix("")

      self.writeTypes = {
        [self.FLOAT] = function(i)
          net.WriteFloat(i)end,
        [self.INTEGER] = function(i)
          net.WriteInt(i, 16)end,
        [self.BOOL] = function(i)
          net.WriteBool(i)end,
        [self.STRING] = function(i)
          net.WriteString(i)end,

        [self.TABLE] = function(i)
          net.WriteTable(i)end
      }
      self.readTypes = {
        [self.FLOAT] = function()
          return math.Round(net.ReadFloat(), 5)end,
        [self.INTEGER] = function()
          return net.ReadInt(16)end,
        [self.BOOL] = function()
          return net.ReadBool()end,
        [self.STRING] = function()
          return net.ReadString()end,
        [self.TABLE] = function()
          return net.ReadTable()end
      }
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Network = _class_0
end

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/settings.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/entities/entity.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/sliderpad.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/players/notification.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local Types
do
  local _class_0
  local _base_0 = {
    __name = "Types",
    _getId = function(self, scriptId, typeId)
      return scriptId .. "_" .. typeId
    end,
    set = function(self, scriptId, typeId, data)
      self.cache[self:_getId(scriptId, typeId)] = data
    end,
    get = function(self, scriptId, typeId)
      return self.cache[self:_getId(scriptId, typeId)]
    end,
    getAll = function(self)
      return self.cache
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.cache = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Types = _class_0
end
local Builder
do
  local _class_0
  local _base_0 = {
    __name = "Builder",
    setSteamID64 = function(self, sid64)
      self.sid64 = sid64

      return self
    end,
    setPlayer = function(self, ply)
      self:setSteamID64(ply:SteamID64())

      return self
    end,
    setScript = function(self, scriptId)
      self.scriptId = scriptId

      return self
    end,
    setType = function(self, typeId)
      self.type = typeId

      return self
    end,
    setContent = function(self, content)
      self.content = content

      return self
    end,
    setData = function(self, data)
      self.data = data

      return self
    end,
    send = function(self)
      self.parent:addNotification(__laux_concat_0(self))

      return self
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, parent)
      self.parent = parent
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Builder = _class_0
end
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Notification",
    builder = function(self)
      return Builder(self)
    end,
    addType = function(self, scriptId, id, data)
      if data == nil then data = {}
      end
      self.types:set(scriptId, id, data)
    end,
    getType = function(self, scriptId, id)
      return self.types:get(scriptId, id)
    end,
    addNotification = function(self, notification)
      if SERVER then
        local db = XeninUI.Players.Database
        db:insertNotification(notification.sid64, notification.scriptId, notification.type, notification.content, notification.data)

        local ply = player.GetBySteamID64(notification.sid64)
        XeninUI.Players.Network:sendNotification(ply, notification)
      else
        error("missing impl")
      end
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.types = Types()
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Notification = _class_0()
end

--addons/xenin_framework/lua/xeninui/elements/button_v2.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/checkbox_v2.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/wyvern_scrollpanel.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/core/ui/tab.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/core/ui/tab.lua:
XeninUI:CreateFont("Xenin.Framework.Config.Container.Name", 24)
XeninUI:CreateFont("Xenin.Framework.Config.Container.Desc", 18)
XeninUI:CreateFont("Xenin.Framework.Config.Tabs", 26)

local PANEL = {}

function PANEL:Init()
  self.Name = "No Name"

  self:DockMargin(0, 0, 8, 0)

  self.Text = self:Add("DPanel")
  self.Text:Dock(TOP)
  self.Text.Offset = draw.GetFontHeight("Xenin.Framework.Config.Container.Name") + 4
  self.Text.Paint = function(pnl, w, h)
    XeninUI:DrawShadowText(self.Name, "Xenin.Framework.Config.Container.Name", 0, 0, Color(231, 232, 235), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)
    XeninUI:DrawShadowText(self.Desc, "Xenin.Framework.Config.Container.Desc", 0, pnl.Offset, Color(156, 156, 156), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)
  end
  self.Text:SetTall(50)
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Primary)
end

function PANEL:SetName(name)
  self.Name = name
end

function PANEL:SetDesc(desc)
  self.Desc = desc
end

function PANEL:PerformLayout(w, h) end

vgui.Register("Xenin.Framework.Config.Container", PANEL, "XeninUI.Panel")

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Category", 22)

function PANEL:SetData(data, scriptId)
  self.Data = data
  self.Panels = {}
  self.Cats = {}

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)

  self.Tabs = self:Add("XeninUI.NavbarBody")
  self.Tabs:Dock(TOP)
  self.Tabs:DockMargin(-6, 0, -12, 8)
  self.Tabs:SetTall(32)
  self.Tabs:SetBody(self.Scroll)
  self.Tabs.Margin = 12

  self.Save = self:Add("XeninUI.ButtonV2")
  self.Save:SetVisible(false)
  self.Save:SetText("Save")
  self.Save:SetGradient(false)
  self.Save:SetSolidColor(XeninUI.Theme.GreenDark)
  self.Save.DoClick = function(pnl)
    local config = {}
    for i, v in pairs(self.Panels) do
      config[i] = v:GetValue()
    end
    for i, v in pairs(self.Cats) do
      config[i] = {}
    end

    XeninUI.Config:save(scriptId, config)
  end

  self:PostInit()
end

function PANEL:UpdateSaveVisibility()
  local difference
  local function recursiveCheck(tbl)
    for i, v in ipairs(tbl) do
      if (!v.children) then
        if (v.value != self.Panels[v.key]:GetValue()) then
          difference = true

          break
        end

        continue
      end

      recursiveCheck(v.children)
    end
  end

  for i, v in ipairs(self.Data) do
    recursiveCheck(v.children)
  end

  self.Save:SetVisible(difference)
  if difference then
    self:InvalidateLayout()
  end
end

function PANEL:PostInit()
  self:CreateConfigRecursive(self.Data)
end

PANEL.Types = {
  cat = function(self, tbl, parent)





    self.Tabs:AddTab(tbl.name, "Panel", {
    fill = TOP })
    local panel = self.Tabs.Tabs[#self.Tabs.Tabs].Panel
    panel:DockMargin(0, 0, 0, 8)
    self.Tabs:SetActive(1)

    self:CreateConfigRecursive(tbl.children, panel)

    return panel
  end,
  textentry = function(self, tbl, parent)
    local panel = parent:Add("Xenin.Framework.Config.Container")
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 8, 8)
    panel:SetName(tbl.name)
    panel:SetDesc(tbl.desc)
    panel:SetTall(104)
    panel.GetValue = function(pnl)
      return panel.Content:GetText()
    end
    panel:DockPadding(8, 6, 8, 8)

    panel.Content = panel:Add("XeninUI.TextEntry")
    panel.Content:Dock(FILL)
    panel.Content:DockMargin(0, 4, 0, 0)
    panel.Content:SetText(XeninUI.Config:get(tbl.key) or tbl.value)
    panel.Content.textentry:SetUpdateOnType(true)
    panel.Content.textentry.OnValueChange = function(pnl, w, h)
      self:UpdateSaveVisibility()
    end

    if tbl.numeric then
      panel.Content.textentry:SetNumeric(true)
    end

    return panel
  end,
  checkbox = function(self, tbl, parent)
    local panel = parent:Add("Xenin.Framework.Config.Container")
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 8, 8)
    panel:SetName(tbl.name)
    panel:SetDesc(tbl.desc)
    panel:SetTall(104)
    panel.GetValue = function(pnl)
      return panel.Content:GetState()
    end
    panel:DockPadding(8, 6, 8, 8)

    panel.Content = panel:Add("XeninUI.Checkbox")
    panel.Content:Dock(LEFT)
    panel.Content:DockMargin(0, 4, 0, 0)
    panel.Content:SetWide(100)
    panel.Content:SetState(tbl.value, true)
    panel.Content.OnStateChanged = function()
      self:UpdateSaveVisibility()
    end

    return panel
  end
}

function PANEL:CreateConfigRecursive(tbl, parent)
  if parent == nil then parent = self.Scroll
  end
  for i, v in ipairs(tbl) do
    local panel = self.Types[v.type](self, v, parent)
    if (v.type == "cat") then
      self.Cats[v.key] = v

      continue
    end

    self.Panels[v.key] = panel
  end
end

function PANEL:PerformLayout(w, h)
  self.Save:AlignRight(24)
  self.Save:AlignBottom(8)
  self.Save:SizeToContentsX(24)
  self.Save:SizeToContentsY(8)
  self.Save:SetRoundness(self.Save:GetTall() / 2)

  for i, v in ipairs(self.Tabs.Tabs) do
    local pnl = v.Panel
    local h = 0
    for i, v in ipairs(pnl:GetChildren()) do
      h = h + v:GetTall()
      local l, t, b, r = v:GetDockMargin()
      h = h + (t + b)
    end

    pnl:SetTall(h)
  end
end

vgui.Register("Xenin.Framework.Config", PANEL, "XeninUI.Panel")

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Title", 26)
XeninUI:CreateFont("Xenin.Framework.Subtitle", 18)

function PANEL:OnSwitchedTo()
  if self.HaveSwitchedTo then return end

  self.HaveSwitchedTo = true
  self:PostInit()
end

function PANEL:PostInit()
  self:DockPadding(16, 16, 16, 16)

  local __lauxi0 = self.Data
  assert(__lauxi0 ~= nil, "cannot destructure nil value")
  local version, author, config, id, licensee, licenseeProof = __lauxi0.version, __lauxi0.author, __lauxi0.config, __lauxi0.id, __lauxi0.licensee, __lauxi0.licenseeProof
  local titleHeight = draw.GetFontHeight("Xenin.Framework.Title")
  local versionStr = version == "{{ script_version_name }}" and "DEV BUILD" or version
  self.Info = self:Add("DPanel")
  self.Info:Dock(TOP)
  self.Info:SetTall(48)
  self.Info.Paint = function(pnl, w, h)
    XeninUI:DrawShadowText("Version " .. tostring(versionStr), "Xenin.Framework.Title", 0, 0, color_white, nil, nil, 1, 150)
    XeninUI:DrawShadowText("Author: " .. tostring(author), "Xenin.Framework.Subtitle", 0, titleHeight, Color(183, 183, 183), nil, nil, 1, 150)
  end

  self.Tabs = self:Add("XeninUI.NavbarBody")
  self.Tabs:Dock(TOP)
  self.Tabs:DockMargin(-12, 8, -12, 0)
  self.Tabs:SetTall(40)
  self.Tabs.Font = "Xenin.Framework.Config.Tabs"
  self.Tabs:SetBody(self)
  if XeninUI.Debug then
    self.Tabs:AddTab("Updates")
    self.Tabs:AddTab("Config", "Xenin.Framework.Config", config, id)
    self.Tabs:SetActive(2)
  else
    self.Tabs:AddTab("License", "Xenin.Framework.Dev", {
      licensee = licensee,
      proof = licenseeProof
    })
    self.Tabs:SetActive(1)
  end
end

vgui.Register("Xenin.Framework.Tab", PANEL)

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Dev.Licensee", 48)
XeninUI:CreateFont("Xenin.Framework.Dev", 20)

function PANEL:Paint(w, h)
  XeninUI:DrawShadowText("Licensed to " .. tostring(self.licensee), "Xenin.Framework.Dev.Licensee", w / 2, 16, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)
  XeninUI:DrawShadowText("Proof: " .. tostring(self.proof), "Xenin.Framework.Dev", w / 2, 16 + draw.GetFontHeight("Xenin.Framework.Dev.Licensee") + 4, Color(242, 242, 242), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)
  XeninUI:DrawShadowText("This menu is currently in development, check back later", "Xenin.Framework.Dev", w / 2, h / 2, Color(183, 183, 183), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, 150)
end

function PANEL:SetData(data)
  self.licensee = data.licensee
  self.proof = data.proof
end

vgui.Register("Xenin.Framework.Dev", PANEL)

local PANEL = {}
XeninUI:CreateFont("XeninUI.NavbarBody", 18)
AccessorFunc(PANEL, "m_body", "Body")

function PANEL:Init()
  self.Tabs = {}
  self.Options = {}

  self.Line = self:Add("DPanel")
  self.Line:SetMouseInputEnabled(false)
  self.Line:SetTall(2)
  self.Line.x = 12
  self.Line.Paint = function(pnl, w, h)
    surface.SetDrawColor(XeninUI.Theme.Accent)
    surface.DrawRect(0, 0, w, h)
  end
end

function PANEL:PerformLayout(w, h)
  self.Line:SetPos(self.Line.x, h - 2)
end

function PANEL:SetActive(id)
  if IsValid(self.Tabs[self.Active]) then
    self.Tabs[self.Active]:LerpColor("TextColor", Color(183, 183, 183))
    self.Tabs[self.Active].Panel:SetVisible(false)
  end

  self.Active = id

  if IsValid(self.Tabs[self.Active]) then
    local margin = self.Margin or 24
    local x = margin / 2
    for i = 1, id - 1 do
      x = x + self.Tabs[i]:GetWide()
    end

    self.Line:LerpMoveX(x, 0.3)
    self.Line:LerpWidth(self.Tabs[id]:GetWide() - margin, 0.3)

    self.Tabs[self.Active]:LerpColor("TextColor", color_white)
    self.Tabs[self.Active].Panel:SetVisible(true)
  end
end

function PANEL:SetOptions(options)
  self.Options = options
end

function PANEL:AddTab(name, panelClass, data, scriptId)
  if data == nil then data = {}
  end
  if scriptId == nil then scriptId = "none"
  end
  local margin = self.Margin or 24
  local btn = self:Add("DButton")
  btn:Dock(LEFT)
  btn:SetText(self.Options.upper and name:upper() or name)
  btn:SetFont(self.Font or "XeninUI.NavbarBody")
  btn:SizeToContentsX(margin)
  btn:SizeToContentsY()
  btn.TextColor = Color(183, 183, 183)
  btn.Paint = function(pnl, w, h)
    pnl:SetTextColor(pnl.TextColor)
  end
  btn.DoClick = function(pnl)
    self:SetActive(pnl.Id)
  end

  local id = table.insert(self.Tabs, btn)
  self.Tabs[id].Id = id

  if (id == 1) then
    self.Line:SetWide(btn:GetWide() - margin)
  end

  local panel = self:GetBody():Add(panelClass or "XeninUI.Panel")
  panel:Dock(data.fill or FILL)
  panel:SetVisible(false)
  if panel.SetData then
    panel:SetData(data, scriptId)
  end

  btn.Panel = panel
end

vgui.Register("XeninUI.NavbarBody", PANEL)

--addons/xenin-coinflip/lua/coinflip/essentials/currency.lua:
Coinflip.Currencies = Coinflip.Currencies or {}

function Coinflip:CreateCurrency(id, tbl)
	self.Currencies[id] = tbl
end

function Coinflip:GetCurrency(input)
	if (input == nil) then 
		if (istable(Coinflip.Config.Currency)) then
			input = Coinflip.Config.Currency[1]
		else
			input = Coinflip.Config.Currency 
		end
	end
	
	return self.Currencies[input]
end

function Coinflip:GetCurrencies()
	if (isstring(Coinflip.Config.Currency)) then
		return { Coinflip.Config.Currency }
	end

	return Coinflip.Config.Currency
end

function Coinflip:GetCurrencyIfNil()
	if (Coinflip.Config.OldCurrency) then
		return Coinflip.Config.OldCurrency
	end
	if (istable(Coinflip.Config.Currency)) then
		return Coinflip.Config.Currency[1]
	end

	return Coinflip.Config.Currency
end
--addons/xenin-coinflip/lua/coinflip/currencies/darkrp.lua:
return gluapack()()
--addons/xenin-coinflip/lua/coinflip/networking/client.lua:
return gluapack()()
--addons/xenin-coinflip/lua/coinflip/ui/games.lua:
local PANEL = {}

XeninUI:CreateFont("Coinflip.Games.Title", 28)
XeninUI:CreateFont("Coinflip.Games.Button", 20)

function PANEL:Init()
	self.Title = self:Add("DLabel")
	self.Title:SetTextInset(0, 2)
	self.Title:SetFont("Coinflip.Games.Title")
	self.Title:SetTextColor(Color(220, 220, 220))

	self.CreateFlip = self:Add("DButton")
	self.CreateFlip:SetText(Coinflip.i18n:get("ui.flips.createFlip", nil, "Create coinflip"))
	self.CreateFlip:SetFont("Coinflip.Games.Button")
	self.CreateFlip:SizeToContentsY(15)
	self.CreateFlip:SizeToContentsX(48)
	self.CreateFlip.BackgroundColor = XeninUI.Theme.Primary
	self.CreateFlip.OutlineColor = XeninUI.Theme.Primary
	self.CreateFlip.TextColor = Color(212, 212, 212)
	self.CreateFlip.Paint = function(pnl, w, h)
		pnl:SetTextColor(pnl.TextColor)

		XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.BackgroundColor)

		XeninUI:MaskInverse(function()
			XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, color_white)
		end, function()
			XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.OutlineColor)
		end)
	end
	self.CreateFlip.OnCursorEntered = function(pnl)
		local atLimit = pnl:IsAtFlipLimit()

		pnl:LerpColor("OutlineColor", atLimit and XeninUI.Theme.Red or XeninUI.Theme.Green)
		pnl:LerpColor("TextColor", atLimit and XeninUI.Theme.Red or color_white)
	end
	self.CreateFlip.OnCursorExited = function(pnl)
		pnl:LerpColor("OutlineColor", XeninUI.Theme.Primary)
		pnl:LerpColor("TextColor", Color(212, 212, 212))
	end
	self.CreateFlip.IsAtFlipLimit = function(pnl)
		local betsUp = 0
		if (Coinflip.Config.MaxCoinflips != 0) then
			for i, v in pairs(Coinflip.Games) do
				if (v.author != LocalPlayer()) then continue end

				betsUp = betsUp + 1
			end

			if (betsUp >= Coinflip.Config.MaxCoinflips) then
				return true
			end
		end
	end
	self.CreateFlip.DoClick = function(pnl)
		if (pnl:IsAtFlipLimit()) then
			return XeninUI:Notify(Coinflip.i18n:get("ui.flips.maxFlipsReached", { 
				number = Coinflip.Config.MaxCoinflips 
				}, "You can maximum have :number: coinflips active!"),
				NOTIFY_ERROR, 4, XeninUI.Theme.Red)
		end

		local panel = vgui.Create("Coinflip.Games.Create")
	end

	self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
	self.Scroll:Dock(FILL)
	self.Scroll:DockMargin(16, 60, 16, 16)

	self.Rows = {}

	self:Populate()

	hook.Add("Coinflip.Created", self, function(self, id)
		self:Populate()
	end)
	hook.Add("Coinflip.Removed", self, function(self, id)
		self:Populate()
	end)
	hook.Add("Coinflip.Join.Error", self, function(self, err)
		self:Notification(err, XeninUI.Theme.Red)
	end)
end

function PANEL:Populate()
	for i, v in pairs(self.Scroll:GetChildren()[1]:GetChildren()) do
		v:Remove()
		self.Scroll:GetChildren()[1]:GetChildren()[i] = nil
	end

	local amt = table.Count(Coinflip.Games)
	self.Title:SetText(Coinflip.i18n:get("ui.flips.title", { flips = amt }, ":flips: active flips"))

	for i, v in pairs(Coinflip.Games) do
		if (!IsValid(v.author)) then continue end
		local panel = self.Scroll:Add("Coinflip.Games.Row")
		self.Rows[#self.Rows + 1] = panel
		panel:Dock(TOP)
		panel:DockMargin(0, 0, 8, 8)
		panel:SetTall(64)
		panel:SetID(i)
		panel:SetInfo(v)
	end

	self:InvalidateLayout()
end

function PANEL:PerformLayout(w, h)
	self.CreateFlip:SetPos(w - self.CreateFlip:GetWide() - 16, 12)

	self.Title:SetPos(16, 12)
	self.Title:SizeToContents()
end

vgui.Register("Coinflip.Games", PANEL, "XeninUI.Panel")
--addons/xenin-inventory/lua/inventory/essentials/helper.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

function XeninInventory:GetItems()
  return self.Config.Items
end

function XeninInventory:CanUseInventory(ply)
  local result = hook.Run("XeninInventory.CanUseInventory", ply)

  if (result == nil or result) then
    return true
  end
end

function XeninInventory:GetItem(index)
  if self.Config.Blacklist[index] then return end

  return self.Config.Items[index] or (self.Config.WhitelistEntities[index] and self.Config.Items["base_entity"])
end

function XeninInventory:GetRarity(ent)
  if (isstring(ent) or istable(ent) or isentity(ent) and !ent.GetRarity) then
    local entClass = istable(ent) and ent.ent or ent
    if (isentity(entClass) and entClass != NULL) then
      local item = XeninInventory:GetItem(entClass:GetClass())

      if (item and item.Rarity) then
        return item.Rarity
      end

      entClass = entClass.GetWeaponClass and entClass:GetWeaponClass() or entClass:GetClass()
    end

    if (istable(ent) and ent.data and ent.data.rarity) then
      local item = XeninInventory:GetItem(ent.dropEnt)
      if (item and item.Rarity) then
        return item.Rarity
      end

      return ent.data.rarity
    end

    if (!isstring(ent) and ent.dropEnt) then
      local item = XeninInventory:GetItem(ent.dropEnt)
      if (item and item.Rarity) then
        return item.Rarity
      end
    end

    if isstring(ent) then
      local item = XeninInventory:GetItem(ent)
      if (item and item.Rarity) then
        return item.Rarity
      end
    end

    return self.Config.Rarities[entClass] or 1
  end

  if (isentity(ent) and IsValid(ent) and ent.GetRarity and ent != NULL) then
    return ent:GetRarity()
  end

  return 1
end

function XeninInventory:AddItem(index, tbl)
  self.Config.Items[index] = tbl
end

function XeninInventory:IsAdmin(ply)
  return XeninInventory.Config.Admins[ply:GetUserGroup()]
end

--addons/xenin-inventory/lua/inventory/configuration/items/spawned_money.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/configuration/items/spawned_shipment.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/inventory/configuration/items/zgo2_seed.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(1)
ITEM:SetModel("models/zerochain/props_growop2/zgo2_weedseeds.mdl")

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
	local data = tbl.data
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

	if not zgo2.Plant.IsValid(data.WeedID) then
		zclib.Notify(ply, zgo2.language[ "InvalidPlantData" ], 1)
		SafeRemoveEntity(ent)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

		return
	end

	ent:SetPlantID(zgo2.Plant.GetListID(data.WeedID))
	ent:SetCount(data.Count)
	zclib.Player.SetOwner(ent, ply)
end)

function ITEM:GetData(ent)
	return {
		WeedID = zgo2.Plant.GetID(ent:GetPlantID()),
		Count = math.Round(ent:GetCount()),
	}
end

function ITEM:GetVisualAmount(item)
	return item.data.Count
end

function ITEM:GetName(item)
	local ent = isentity(item)
	local WeedID = ent and item:GetPlantID() or item.data.WeedID
	local Count = ent and item:GetCount() or (item.data.Count or 50)
	local WeedData = zgo2.Plant.GetData(WeedID)
	if not WeedData then return "Seeds" end

	return zgo2.Plant.GetName(WeedID) .. " " .. Count .. "x"
end

function ITEM:GetDisplayName(item)
	return self:GetName(item)
end

local ang = Angle(0, 45, 0)

function ITEM:GetCameraModifiers(tbl)
	return {
		FOV = 30,
		X = 0,
		Y = 0,
		Z = 50,
		Angles = ang,
		Pos = vector_origin
	}
end

function ITEM:GetClientsideModel(tbl, mdlPanel)
	local WeedData = zgo2.Plant.GetData(tbl.data.WeedID)
	if not WeedData then return end
	zgo2.Seed.UpdateMaterial(mdlPanel.Entity, WeedData, false)
end

ITEM:Register("zgo2_seed")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

--addons/zeros_golddiggger/lua/inventory/configuration/items/zgw_jar.lua:

local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(1)
ITEM:SetModel("models/zerochain/props_goldwash/zgw_jar.mdl")
ITEM:SetDescription("Can be used to store gold nuggets!")

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
	local data = tbl.data
	zclib.Player.SetOwner(ent, ply)
	ent:SetGold(data.Gold)
end)

function ITEM:GetData(ent)
	return {
		Gold = ent:GetGold(),
	}
end

function ITEM:CanStack(newItem, invItem)
	//local ent = isentity(newItem)

	//local itemID = ent and newItem:GetItemID() or newItem.data.ItemID
	return true
end

function ITEM:GetVisualAmount(item)
	return item.data.Gold
end

function ITEM:GetDisplayName(item)
	return self:GetName(item)
end


function ITEM:GetCameraModifiers(tbl)
	local ren = {
		FOV = 20,
		X = 0,
		Y = 0,
		Z = 50,
		Angles = Angle(0, 15, 0),
		Pos = Vector(0, 0, -1)
	}

	return ren
end

function ITEM:GetClientsideModel(tbl, mdlPanel)
	local gold = tbl.data.Gold

	if gold <= 0 then
		mdlPanel.Entity:SetBodygroup(0, 0)
	else
		local bg = (3 / zgw.config.Jar.MaxGold) * gold
		bg = math.Clamp(math.Round(bg), 1, 3)
		mdlPanel.Entity:SetBodygroup(0, bg)
	end
end
ITEM:Register("zgw_jar")

--addons/zeros_trashman_v1.6.3/lua/inventory/configuration/items/ztm_recycled_block.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(10)
ITEM:SetModel("models/zerochain/props_trashman/ztm_recycleblock.mdl")
ITEM:SetDescription("A block of recycled trash.")

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
	local data = tbl.data
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	ent:SetRecycleType(data.RecycleType)

	zclib.Player.SetOwner(ent, ply)
end)

function ITEM:CanStack(newItem, invItem)
	local ent = isentity(newItem)
	local RecycleType = ent and newItem:GetRecycleType() or newItem.data.RecycleType
	return RecycleType == invItem.data.RecycleType
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ITEM:GetData(ent)
	return {
		RecycleType = ent:GetRecycleType(),
	}
end

function ITEM:GetDisplayName(item)
	return self:GetName(item)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ITEM:GetName(item)
	local ent = isentity(item)
	local RecycleType = ent and item:GetRecycleType() or item.data.RecycleType
	local trash_name = ztm.config.Recycler.recycle_types[RecycleType].name
	return trash_name
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ITEM:GetCameraModifiers(tbl)
	return {
		FOV = 40,
		X = 0,
		Y = -22,
		Z = 25,
		Angles = Angle(0, -190, 0),
		Pos = Vector(0, 0, -1)
	}
end

function ITEM:GetClientsideModel(tbl, mdlPanel)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	local RecycleType = tbl.data.RecycleType
	local _recycle_type = ztm.config.Recycler.recycle_types[RecycleType]

	mdlPanel.Entity:SetMaterial( _recycle_type.mat, true )
end

ITEM:Register("ztm_recycled_block")

--addons/xenin-inventory/lua/inventory/ui/frame.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/ui/admin/management.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local PANEL = {}

XeninUI:CreateFont("XeninInventory.Admin.Title", 30)

local nameCache = {}
local function GetNameAsync(sid64)
  local p = XeninUI.Promises.new()
  if nameCache[sid64] then
    p:resolve({
      sid64 = sid64,
      name = nameCache[sid64]
    })

    return p
  end

  local ply = player.GetBySteamID64(sid64)

  if IsValid(ply) then
    p:resolve({
      sid64 = sid64,
      name = ply:Nick()
    })
  else
    steamworks.RequestPlayerInfo(sid64, function(name)
      if (name == "" or name == nil) then
        p:reject()
      else
        p:resolve({
          sid64 = sid64,
          name = name
        })
      end
    end)
  end

  return p
end

function PANEL:Init()
  self.Rows = {}

  self.Top = self:Add("Panel")
  self.Top:Dock(TOP)
  self.Top:DockMargin(16, 0, 16, 0)

  self.Top.Title = self.Top:Add("DLabel")
  self.Top.Title:SetText(XeninInventory:GetPhrase("Admin.Management.Loading"))
  self.Top.Title:Dock(LEFT)
  self.Top.Title:DockMargin(0, 12, 0, 8)
  self.Top.Title:SetFont("XeninInventory.Admin.Title")
  self.Top.Title:SetContentAlignment(4)
  self.Top.Title:SizeToContents()

  self.Top.Search = self.Top:Add("XeninUI.TextEntry")
  self.Top.Search:Dock(RIGHT)
  self.Top.Search:DockMargin(0, 12, 0, 8)
  self.Top.Search:SetPlaceholder(XeninInventory:GetPhrase("Admin.Management.Search"))
  self.Top.Search.textentry:SetUpdateOnType(true)
  self.Top.Search.textentry.OnValueChange = function(pnl, text)
    pnl.Loading = true

    self:RemoveRows()

    XeninUI:Debounce("XeninInventory.Admin.Search", 1, function()
      if (text == "") then
        net.Start("XeninInventory.Admin.Search")
        net.WriteBool(true)
        net.WriteTable(player.GetAll())
        net.SendToServer()

        return
      end
      local results = {}
      for i, v in ipairs(player.GetAll()) do
        if (!IsValid(v)) then continue end
        if (!v:Nick():lower():find(text)) then continue end

        table.insert(results, v)
      end

      if (#results > 0) then
        net.Start("XeninInventory.Admin.Search")
        net.WriteBool(true)
        net.WriteTable(results)
        net.SendToServer()
      else
        net.Start("XeninInventory.Admin.Search")
        net.WriteBool(false)
        net.WriteTable({
        text })
        net.SendToServer()
      end
    end)
  end
  self.Top.Search.textentry.PaintOver = function(pnl, w, h)
    if (!pnl.Loading) then return end

    pnl:NoClipping(false)
    XeninUI:DrawCircle(w - h / 2, h / 2, h * 0.8, 30, Color(0, 0, 0, 100))
    XeninUI:DrawLoadingCircle(w - h / 2, h / 2, h * 1.2, XeninUI.Theme.Green)
    pnl:NoClipping(true)
  end
  self.Top.Search.textentry:AddHook("XeninInventory.Admin.Search", "XeninInventory.Admin.TextEntry", function(pnl, data)
    local tbl = {}


    local nameTbl = {}
    for i, v in pairs(data) do

      if (i >= "90071996842377216") then continue end

      table.insert(nameTbl, GetNameAsync(i))
    end


    local tbl = {}
    local p = XeninUI.Promises
    p.all(nameTbl):next(function(results)
      for i, v in ipairs(results) do
        table.insert(tbl, {
          sid64 = v.sid64,
          nick = v.name,
          inv = data[v.sid64].inv,
          bank = data[v.sid64].bank
        })
      end

      self:BuildPage(tbl)

      pnl.Loading = nil
    end)
  end)

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(16, 8, 16, 16)

  net.Start("XeninInventory.Admin.Search")
  net.WriteBool(true)
  net.WriteTable(player.GetHumans())
  net.SendToServer()
end

XeninUI:CreateFont("XeninInventory.Admin.Row.Title", 24)
XeninUI:CreateFont("XeninInventory.Admin.Row.Subtitle", 18)
XeninUI:CreateFont("XeninInventory.Admin.Row.Interact", 20)

function PANEL:RemoveRows()
  for i, v in ipairs(self.Rows) do
    v:Remove()
    self.Rows[i] = nil
  end

  self.Top.Title:SetText(XeninInventory:GetPhrase("Admin.Management.Searching"))
  self.Top.Title:SizeToContents()
end

function PANEL:BuildPage(tbl)
  for i, v in ipairs(self.Rows) do
    v:Remove()
    self.Rows[i] = nil
  end

  self.Top.Title:SetText(#tbl .. " results")
  self.Top.Title:SizeToContents()

  for i, v in pairs(tbl) do
    local panel = self.Scroll:Add("DPanel")
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 8, 8)
    panel:SetTall(64)
    panel.Online = player.GetBySteamID64(v.sid64)
    panel.Paint = function(pnl, w, h)
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, XeninUI.Theme.Navbar)

      XeninUI:DrawShadowText(v.nick, "XeninInventory.Admin.Row.Title", h, h / 2 + 3 - 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, 2, 125)
      XeninUI:DrawShadowText(panel.Online and XeninInventory:GetPhrase("Admin.Management.Online") or XeninInventory:GetPhrase("Admin.Management.Offline"), "XeninInventory.Admin.Row.Subtitle", h, h / 2 + 2, panel.Online and Color(180, 180, 180) or XeninUI.Theme.Red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 125)
    end

    panel.Avatar = panel:Add("XeninUI.Avatar")
    panel.Avatar:SetVertices(30)
    panel.Avatar.avatar:SetSteamID(v.sid64, 128)

    panel.Inspect = panel:Add("DButton")
    panel.Inspect:SetText(XeninInventory:GetPhrase("Admin.Management.OpenInventory"))
    panel.Inspect:SetFont("XeninInventory.Admin.Row.Interact")
    panel.Inspect.TextColor = Color(220, 220, 220)
    panel.Inspect.Color = XeninUI.Theme.Background
    panel.Inspect.Paint = function(pnl, w, h)
      pnl:SetTextColor(pnl.TextColor)

      XeninUI:DrawRoundedBox(h / 2, 0, 0, w, h, pnl.Color)
    end
    panel.Inspect.OnCursorEntered = function(pnl)
      pnl:LerpColor("TextColor", color_white)
      pnl:LerpColor("Color", XeninUI.Theme.Primary)
    end
    panel.Inspect.OnCursorExited = function(pnl)
      pnl:LerpColor("TextColor", Color(220, 220, 220))
      pnl:LerpColor("Color", XeninUI.Theme.Background)
    end
    panel.Inspect.DoClick = function(pnl)
      local pnl = vgui.Create("XeninInventory.Admin.Player")
      pnl:SetData(v)
    end

    panel.PerformLayout = function(pnl, w, h)
      panel.Avatar:SetPos(8, 8)
      panel.Avatar:SetSize(h - 16, h - 16)

      panel.Inspect:SizeToContentsX(32)
      panel.Inspect:SizeToContentsY(16)
      panel.Inspect:AlignRight(8)
      panel.Inspect:CenterVertical()
    end

    table.insert(self.Rows, panel)
  end
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(54)

  self.Top.Search:SetWide(250)
end

vgui.Register("XeninInventory.Admin.Management", PANEL, "XeninUI.Panel")

--addons/xenin-inventory/lua/inventory/ui/importer/frame.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local PANEL = {}

function PANEL:Init()
  self.Sidebar = self:Add("XeninUI.SidebarV2")
  self.Sidebar:Dock(LEFT)
  self.Sidebar:SetBody(self)
  self.Sidebar:CreatePanel("ItemStore", nil, "XeninInventory.Admin.Importer.Panel")
  self.Sidebar:SetActive(1)
  self.Sidebar.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, false, false)
  end
end

function PANEL:PerformLayout(w, h)
  self.Sidebar:SetWide(110)
end

vgui.Register("XeninInventory.Admin.Importer", PANEL)

local PANEL = {}

XeninUI:CreateFont("XeninInventory.Admin.Importer.Loading", 18)
XeninUI:CreateFont("XeninInventory.Admin.Importer.Submit", 21)

net.Receive("XeninInventory.Admin.Importer.Request", function(len)
  local importerId = net.ReadString()
  local id = net.ReadString()
  local amount = net.ReadUInt(24)

  hook.Run("XeninInventory.Admin.Importer.Request", importerId, id, amount)
end)

net.Receive("XeninInventory.Admin.Importer.Import", function(len)
  local importerId = net.ReadString()
  local step = net.ReadUInt(3)
  local amount = net.ReadUInt(24)

  hook.Run("XeninInventory.Admin.Importer.Import", importerId, step, amount)
end)

function PANEL:Init()
  self.ImporterId = "ItemStore"

  self:RequestInformation()
end

function PANEL:SetLoading(text)
  self.Loading = true
  self.LoadingText = text
end

function PANEL:RequestInformation()
  self:SetLoading("Getting initial data")

  net.Start("XeninInventory.Admin.Importer.Request")
  net.WriteString("ItemStore")
  net.SendToServer()

  hook.Add("XeninInventory.Admin.Importer.Request", self, function(self, importerId, id, amount)
    if (self.ImporterId != importerId) then return end

    self.Data = {
      id = id,
      amount = amount
    }
    self.Loading = false

    if (self.Data.id == "not_installed") then
      self.NotInstalled = true

      return
    end

    self:CreateInformation()
  end)
end

PANEL.Methods = {
  text = "Text Files",
  sqlite = "Local SQL (SQLite)",
  mysql = "External SQL (MySQL)"
}

XeninUI:CreateFont("XeninInventory.Admin.Importer.Title", 32)
XeninUI:CreateFont("XeninInventory.Admin.Importer.Failed", 52)
XeninUI:CreateFont("XeninInventory.Admin.Importer.Importing", 30)
XeninUI:CreateFont("XeninInventory.Admin.Importer.Percentage", 18)
XeninUI:CreateFont("XeninInventory.Admin.Importer.Step", 14)
XeninUI:CreateFont("XeninInventory.Admin.Importer.Setting", 18)

function PANEL:CreateInformation()
  local method = self.Methods[self.Data.id]
  local players = self.Data.amount
  self.Markup = markup.Parse("<font=XeninInventory.Admin.Importer.Loading><color=174,174,174>Data type: <color=255,255,255>" .. tostring(method) .. "</color>\nPlayers: <color=255,255,255>" .. tostring(players) .. "</color></color></font>")

  self.Body = self:Add("Panel")
  self.Body:Dock(FILL)
  self.Body:DockPadding(16, 16, 16, 16)

  self.Title = self.Body:Add("DLabel")
  self.Title:Dock(TOP)
  self.Title:DockMargin(0, 52, 0, 8)
  self.Title:SetFont("XeninInventory.Admin.Importer.Title")
  self.Title:SetText("Settings")
  self.Title:SizeToContents()

  self.Settings = {}

  local importer = XeninInventory.Importers:getImporter(self.ImporterId)
  local firstSetting
  for i, v in pairs(importer:getSettings()) do
    local id = v:getId()
    local name = v:getName()
    local val = v:getValue()
    local uiType = v:getUiType()
    local options = v:getOptions()

    local row = self.Body:Add("DPanel")
    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 0)
    row:SetTall(48)
    row.Id = id
    row.First = !firstSetting
    row.Markup = markup.Parse("<font=XeninInventory.Admin.Importer.Setting><color=185, 185, 185>" .. tostring(name) .. "</color></font>")
    row.Paint = function(pnl, w, h)
      surface.SetDrawColor(100, 100, 100)
      if pnl.First then
        surface.DrawRect(0, 0, w, 1)
      end

      surface.DrawRect(0, h - 1, w, 1)

      pnl.Markup:Draw(0, h / 2 - 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    local input = row:Add("XeninUI.CheckboxV2")
    input.Background = XeninUI.Theme.Background
    input:Dock(RIGHT)
    local l, t, r, b = input:GetDockMargin()
    input:DockMargin(8, 8, 0, 8)
    input:SetState(val, true)
    input:SetWide(32)
    row.Input = input

    table.insert(self.Settings, row)
    firstSetting = true
  end

  self.Submit = self.Body:Add("XeninUI.ButtonV2")
  self.Submit:SetText("Start Import")
  self.Submit:SetFont("XeninInventory.Admin.Importer.Submit")
  self.Submit:SetRoundness(6)
  self.Submit:SetSolidColor(XeninUI.Theme.Accent)
  self.Submit.DoClick = function(pnl)
    XeninUI:SimpleQuery("Import ItemStore", "Importing will wipe your inventory data first", "Yes, wipe & import!", function()
      self.Body:Remove()

      self.Importing = 0
      self.Step = 1
      self.Status = self.Steps[self.Step]

      local results = {}
      for i, v in pairs(self.Settings) do
        results[v.Id] = v.Input.State
      end

      net.Start("XeninInventory.Admin.Importer.Import")
      net.WriteString(self.ImporterId)
      net.WriteString(self.Data.id)
      net.WriteTable(results)
      net.SendToServer()

      hook.Add("XeninInventory.Admin.Importer.Import", self, function(self, importerId, step, amount)
        self.Step = step
        self.Status = self.Steps[step]
        self.Importing = amount
      end)
    end, "Nevermind", function() end)
  end
end

PANEL.Steps = {
  [1] = "Processing rows",
  [2] = "Importing inventory",
  [3] = "Importing bank",
  [4] = "Finished importing"
}

function PANEL:Paint(w, h)
  if self.NotInstalled then
    return draw.SimpleText("Unable to find any ItemStore data.", "XeninInventory.Admin.Importer.Failed", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  end


  if self.Importing then
    local frac = (self.Importing / (self.Data.amount * 2)) / 3
    draw.SimpleText(self.Status, "XeninInventory.Admin.Importer.Importing", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

    local size = w / 2
    XeninUI:DrawRoundedBox(6, size / 2, h / 2 + 10, size, 20, XeninUI.Theme.Navbar)

    local aX, aY = self:LocalToScreen()
    render.SetScissorRect(aX + size / 2, aY + h / 2 + 10, aX + size / 2 + (size * frac), aY + h / 2 + 10 + 20, true)
    XeninUI:DrawRoundedBox(6, size / 2 + 2, h / 2 + 10 + 2, size - 4, 16, XeninUI.Theme.Green)
    render.SetScissorRect(0, 0, ScrW(), ScrH(), false)

    local percentage = math.Round(frac * 100, 1)
    XeninUI:DrawShadowText(tostring(percentage) .. "%", "XeninInventory.Admin.Importer.Percentage", w / 2, h / 2 + 18 / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)
    local str = ""
    if (self.Step != 4) then
      str = "Step " .. math.min(self.Step, 3) .. "/3"
    end
    XeninUI:DrawShadowText(str, "XeninInventory.Admin.Importer.Step", w / 2, h / 2 + 20 + 18, Color(172, 172, 172), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)

    if (percentage < 100) then
      local size = 96
      XeninUI:DrawLoadingCircle(h / 2 + size / 2 + size / 5, h / 2 - size - 8, size, XeninUI.Theme.Accent)
    end

    return
  end

  if self.Loading then
    local size = 96
    XeninUI:DrawLoadingCircle(h / 2 + size / 2 + size / 5, h / 2 - size, size, XeninUI.Theme.Accent)

    draw.SimpleText(self.LoadingText, "XeninInventory.Admin.Importer.Loading", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  end

  if self.Markup then
    self.Markup:Draw(16, 16, 16)
  end
end

function PANEL:PerformLayout(w, h)
  if (!IsValid(self.Submit)) then return end

  self.Submit:SizeToContentsY(10)
  self.Submit:SizeToContentsX(28)
  self.Submit:AlignRight(16)
  self.Submit:AlignBottom(16)
end

vgui.Register("XeninInventory.Admin.Importer.Panel", PANEL)

--addons/yet_another_warn_system/lua/yaws/punishments/sh_ban.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/punishments/sh_jail.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/punishments/sh_kick.lua:
local PUNISHMENT = YAWS.Punishments.CreatePunishment()
PUNISHMENT:SetID("yaws.kick")
PUNISHMENT:SetName("Kick")
PUNISHMENT:SetDescription("Kicks the player from the server")

PUNISHMENT:AddParameter("reason", "Reason", "The reason for the kick.", "string", "You reached the warning limit.")

PUNISHMENT:SetAction(function(admin, targetSteamID, params)
    local ply = player.GetBySteamID64(targetSteamID)
    if(!ply) then return false,"Player is not online." end
    
    ply:Kick(params.reason)
    return true
end)
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_permission_entry.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_player_card.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_punishment_entry.lua:
local PANEL = {}

function PANEL:Init()
    self.punishmentData = {}
    
    local colors = YAWS.UI.ColorScheme()
    self.bin = vgui.Create("yaws.iconbtn", self)
    self.bin:SetMaterial(YAWS.UI.MaterialCache['trash'], colors['text_header'])
    self.bin.DoClick = function()
        YAWS.UI.CurrentData.WaitingForServerResponse = true 
        YAWS.UI.DisplayLoading(YAWS.UI.CurrentData.MasterCache)
    
        net.Start("yaws.punishments.removepunishment")
        net.WriteUInt(self.punishmentData.threshold, 16)
        net.SendToServer()
    
        YAWS.UI.LoadingCache = {
            panel = "remove_punishment",
            key = self.punishmentData.threshold,
        }
    end

    self.edit = vgui.Create("yaws.iconbtn", self)
    self.edit:SetMaterial(YAWS.UI.MaterialCache['edit'], colors['text_header'])
    self.edit.DoClick = function()
        YAWS.UI.EditPunishment(self.punishmentData)
    end 

    self.descX = nil 

    self.sideShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow:Down()
end 

function PANEL:Paint(w, h)
    local colors = YAWS.UI.ColorScheme()
    draw.RoundedBox(0, 0, 0, w, h, colors["panel_background"])

    local curX = h / 2
    local thresholdWidth = draw.SimpleText(self.punishmentData.threshold, "yaws.9", curX, h / 2, colors['text_header'], 1, 1)

    curX = math.max(h / 2 + 30, h / 2 + thresholdWidth)
    draw.RoundedBox(0, curX, 10, 2, h - 20, colors['divider'])

    curX = curX + 20
    local nW = draw.SimpleText(self.punishmentData.typeInfo.name, "yaws.8", curX, h / 2, colors['text_header'], 0, 1)

    curX = curX + nW + 15
    draw.SimpleText(self.punishmentData.typeInfo.description, "yaws.7", curX, h / 2, colors['text_main'], 0, 1)
end 

function PANEL:LayoutShadows(w, h)
    local x,y = self:GetPos()
    if(IsValid(self.sideShadow)) then 
        self.sideShadow:SetPos(x + w, y)
        self.sideShadow:SetSize(3, h)
    end 

    if(IsValid(self.bottomShadow)) then 
        self.bottomShadow:SetPos(x, y + h)
        self.bottomShadow:SetSize(w + 1, 3)
    end
end 

function PANEL:PerformLayout(w, h)
    self.bin:Dock(RIGHT)
    self.bin:DockMargin(h / 3, h / 3, h / 3, h / 3)
    self.bin:SetWide(h / 3)

    self.edit:Dock(RIGHT)
    self.edit:DockMargin(h / 3, h / 3, 0, h / 3)
    self.edit:SetWide(h / 3)

    self:LayoutShadows(w, h)
end 

function PANEL:SetPunishmentData(threshold, data)
    if(!YAWS.Punishments.Types[data.type]) then 
        self.punishmentData = {
            threshold = threshold,
            type = "N/A",
            typeInfo = {
                name = "Unknown",
                description = "Unknown punishment type",
                params = {}
            },
        }

        return
    end 
    
    self.punishmentData = data
    self.punishmentData.threshold = threshold
    self.punishmentData.typeInfo = YAWS.Punishments.Types[data.type]

    -- params:
    --      reason	=	you fucked up lol
    -- type	=	kick
    -- typeInfo:
    --     action	=	function: 0x02cc9d58b768
    --     description	=	Kicks a player from the server if they are online.
    --     name	=	Kick
    --     params:
    --             reason:
    --                     default	=	You reached the warning limit.
    --                     description	=	The reason the target gets kicked.
    --                     name	=	Reason
    --                     type	=	string
end 

function PANEL:RemoveShadows() 
    self.bottomShadow:Remove()
    self.sideShadow:Remove()
end 
function PANEL:OnRemove()
    self:RemoveShadows()
end 

vgui.Register("yaws.punishment_entry", PANEL, "DPanel")
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_warning_entry.lua:
local PANEL = {}

function PANEL:Init()
    self.warningData = {
        admin = "Unknown",
        adminSteamID = "00000000000000000",
        id = "",
        player = "00000000000000000",
        points = 0,
        reason = "N/A",
        server_id = "None",
        timestamp = 0,
    }

    self.btn.he = 0
    self:SetExpanded(false)

    self.expandLerp = 255
    self.frameTime = RealFrameTime()

    self.adminAvatar = vgui.Create("yaws.round_avatar", self.btn)
    self.userAvatar = vgui.Create("yaws.round_avatar", self.btn)

    self.btn.PerformLayout = function(s, w, h)  
        self.adminAvatar:Dock(LEFT)
        self.adminAvatar:DockMargin(10, 10, 10, 10)
        self.adminAvatar:SetWide(h - 20)
        
        self.userAvatar:Dock(RIGHT)
        self.userAvatar:DockMargin(10, 10, 10 + ((h / 2) + 20), 10)
        self.userAvatar:SetWide(h - 20)
        self.userAvatar:SetAlpha(0)
    end 
    self.btn.DoRightClick = function()
        local options = DermaMenu()

        options:AddOption(YAWS.Language.GetTranslation("viewing_player_table_right_id"), function() 
            SetClipboardText(self.warningData.id) 
        end):SetIcon("icon16/bullet_key.png")

        options:AddOption(YAWS.Language.GetTranslation("viewing_player_table_right_admin"), function() 
            SetClipboardText(self.warningData.admin .. "(" .. util.SteamIDFrom64(self.warningData.adminSteamID or "") .. ")") 
        end):SetIcon("icon16/group_key.png")

        options:AddOption(YAWS.Language.GetTranslation("viewing_player_table_right_reason"), function() 
            SetClipboardText(self.warningData.reason) 
        end):SetIcon("icon16/page_edit.png")

        options:AddOption(YAWS.Language.GetTranslation("viewing_player_table_right_time"), function() 
            SetClipboardText(os.date("%H:%M:%S on %d/%m/%Y", self.warningData.timestamp))
        end):SetIcon("icon16/clock.png")

        options:AddOption(YAWS.Language.GetTranslation("viewing_player_table_right_points"), function() 
            SetClipboardText(YAWS.Language.GetFormattedTranslation("points_format", self.warningData.points)) 
        end):SetIcon("icon16/award_star_gold_3.png")

        options:AddOption(YAWS.Language.GetTranslation("viewing_player_table_right_server"), function() 
            SetClipboardText(self.warningData.server_id) 
        end):SetIcon("icon16/computer.png")

        options:AddOption(YAWS.Language.GetTranslation("viewing_player_table_right_log"), function() 
            SetClipboardText(YAWS.Language.GetFormattedTranslation("viewing_player_table_log_format", os.date("%H:%M:%S on %d/%m/%Y", self.warningData.timestamp), self.warningData.admin, util.SteamIDFrom64(self.warningData.adminSteamID or ""), self.warningData.playerName, util.SteamIDFrom64(self.warningData.player), self.warningData.reason, self.warningData.points))
        end):SetIcon("icon16/folder.png")

        options:Open()
    end 
    
    self.bottomPanel = vgui.Create("DPanel", self)
    self.bottomPanel.Paint = function() end 
    if(YAWS.UI.CurrentData.can_view.delete_warns) then 
        self.deleteButton = vgui.Create("yaws.button", self.bottomPanel)
        self.deleteButton:SetLabel(YAWS.Language.GetTranslation("generic_delete"))
        self.deleteButton:SetColors('button_warn_base', 'button_warn_hover')
        self.deleteButton.DoClick = function()
            YAWS.UI.CurrentData.FrameCache:Remove()

            net.Start("yaws.warns.deletewarn")
            net.WriteString(self.warningData.id)
            net.SendToServer()
        end
    end 
    
    self.content.PerformLayout = function(s, w, h)
        self.bottomPanel:Dock(BOTTOM)
        self.bottomPanel:DockMargin(10, 10, 10, 10)
        self.bottomPanel:SetTall(33)

        if(self.deleteButton) then 
            self.deleteButton:Dock(FILL)
        end

        -- if(YAWS.UI.CurrentData.can_view.delete_warns) then 
        --     self.deleteButton:Dock(RIGHT)
        --     self.deleteButton:SetWide(33)
        -- end
        -- self.contextButton:Dock(RIGHT)
        -- self.contextButton:SetWide(33)
    end 

    local colors = YAWS.UI.ColorScheme()

    self.mainFade = table.Copy(colors['text_main'])
    self.headerFadeInv = table.Copy(colors['text_main'])
    self.mainFadeInv = table.Copy(colors['text_main'])
    self.mainFade.a = self.expandLerp
    self.headerFadeInv.a = 255 - self.expandLerp
    self.mainFadeInv.a = 255 - self.expandLerp
end

-- panel.DoRightClick = function()
--     local options = DermaMenu()
--     for k,v in ipairs(menu) do 
--         local x = options:AddOption(v.name, v.func)
--         if(v.icon) then 
--             x:SetIcon(v.icon)
--         end
--     end
--     options:Open()
-- end

function PANEL:HeaderPaint(w, h)
    self.frameTime = RealFrameTime()
    if(self.btn.he == 0) then
        self.btn.he = h * 0.42
    end

    local colors = YAWS.UI.ColorScheme()
    draw.RoundedBox(0, 0, 0, w, h, colors["panel_background"])

    if(self:GetExpanded()) then
        if(self.expandLerp > 0.0000005) then -- Prevents it from running unnessasarially, a performance thing
            if(!YAWS.UserSettings.GetValue("disable_ui_anims")) then 
                self.expandLerp = Lerp(self.frameTime * 15, self.expandLerp, 0)
            else 
                self.expandLerp = 0
            end 

            self.mainFade.a = self.expandLerp
            self.headerFadeInv.a = 255 - self.expandLerp
            self.mainFadeInv.a = 255 - self.expandLerp
        end
    else
        if(self.expandLerp < 254.99995) then -- Prevents it from running unnessasarially, a performance thing
            if(!YAWS.UserSettings.GetValue("disable_ui_anims")) then 
                self.expandLerp = Lerp(self.frameTime * 15, self.expandLerp, 255)
            else 
                self.expandLerp = 255
            end 

            self.mainFade.a = self.expandLerp
            self.headerFadeInv.a = 255 - self.expandLerp
            self.mainFadeInv.a = 255 - self.expandLerp
        end
    end
    

    -- Actual info
    local adminLength = draw.SimpleText(self.warningData.admin, "yaws.9", h + 3, h * 0.35, colors['text_header'], 0, 1)
    local sidLength = draw.SimpleText(util.SteamIDFrom64(self.warningData.adminSteamID), "yaws.7", h + 3, h * 0.65, colors['text_main'], 0, 1)
    local textX = math.max(w * 0.3, math.max(adminLength, sidLength) + (h + 6))
    
    draw.SimpleText(YAWS.UI.CutoffText(self.warningData.reason, "yaws.8", w - textX - ((h / 2) + 10) - 10), "yaws.8", textX, h / 2, self.mainFade, 0, 1)

    -- 19x11
    self.btn.chevState = YAWS.UI.DrawAnimatedChevron(w - ((h / 2) + 10), self.btn.he, math.min(self.btn.he, 19), math.min(h * 0.195, 11), self.btn.chevState, self:GetExpanded())

    -- Expanded State
    self.userAvatar:SetAlpha(255 - self.expandLerp)
    self.bottomPanel:SetAlpha(255 - self.expandLerp)

    textX = w - ((h / 2) + 20) - (h - 20) - 23
    -- draw.SimpleText(YAWS.UI.CutoffText(self.warningData.playerName, "yaws.9", maxWidth, cacheKey), "yaws.9", textX, h * 0.35, self.headerFadeInv, 2, 1)
    draw.SimpleText(self.warningData.playerName, YAWS.UI.ScaleFont(self.warningData.playerName, w * 0.25, 8, 9), textX, h * 0.35, self.headerFadeInv, 2, 1)
    draw.SimpleText(util.SteamIDFrom64(self.warningData.player), "yaws.7", textX, h * 0.65, self.mainFadeInv, 2, 1)

    local warnedWidth = draw.SimpleText(YAWS.Language.GetTranslation("generic_warned"), "yaws.8", w / 2, h * 0.5, self.mainFadeInv, 1, 1)

    YAWS.UI.SetSurfaceDrawColor(self.mainFadeInv)
    surface.SetMaterial(YAWS.UI.MaterialCache['arrow'])
    -- this math is dubious
    surface.DrawTexturedRect((w / 2) + (warnedWidth / 2) + 5, h * 0.5 - ((h * 0.25) / 2), h * 0.25, h * 0.25)
    surface.DrawTexturedRect((w / 2) - (warnedWidth / 2) - 5 - (h * 0.25 * 0.8), h * 0.5 - ((h * 0.25) / 2), h * 0.25, h * 0.25)
end

function PANEL:ContentPaint(w, h)
    local colors = YAWS.UI.ColorScheme() 
    
    draw.RoundedBox(0, 0, 0, w, h, colors["panel_background"])

    local _,rHeaderH = draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_reason"), "yaws.8", 10, 10, self.headerFadeInv, 0, 1)
    
    -- DrawText doesn't return like the others :/
    draw.DrawText(YAWS.UI.TextWrap(self.warningData.reason, "yaws.7", w - 20), "yaws.7", 10, rHeaderH, self.mainFadeInv, 0, 1)
    surface.SetFont("yaws.7")
    local _,reasonH = surface.GetTextSize(YAWS.UI.TextWrap(self.warningData.reason, "yaws.7", w - 20))

    local _,tHeaderH = draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_time"), "yaws.8", 10, rHeaderH + reasonH + 25, self.headerFadeInv, 0, 1)
    draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_server"), "yaws.8", w / 2, rHeaderH + reasonH + 25, self.headerFadeInv, 1, 1)
    draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_point"), "yaws.8", w - 10, rHeaderH + reasonH + 25, self.headerFadeInv, 2, 1)
    
    draw.SimpleText(os.date("%H:%M:%S on %d/%m/%Y", self.warningData.timestamp), "yaws.7", 10, rHeaderH + reasonH + tHeaderH + 25, self.mainFadeInv, 0, 1)
    draw.SimpleText(self.warningData.server_id, "yaws.7", w / 2, rHeaderH + reasonH + tHeaderH + 25, self.mainFadeInv, 1, 1)
    draw.SimpleText(YAWS.Language.GetFormattedTranslation("points_format", self.warningData.points), "yaws.7", w - 10, rHeaderH + reasonH + tHeaderH + 25, self.mainFadeInv, 2, 1)
end 

function PANEL:SetWarningData(data)
    self.warningData = data

    self.adminAvatar:SetSteamID(data.adminSteamID, 128)
    self.userAvatar:SetSteamID(data.player, 128)

    
    -- Looks like (from PrintTable): 
    -- admin	=	Livaco
    -- adminSteamID	=	76561198121018313
    -- id	=	e5af2b73-0c6f-481a-8e1e-5000dd72f952
    -- player	=	76561198121018313
    -- points	=	3
    -- reason	=	test
    -- server_id	=	Server One
    -- timestamp	=	1645917741    
end

function PANEL:CalculateHeights(w, h) 
    local x = 0
    
    surface.SetFont("yaws.8")
    x = x + select(2, surface.GetTextSize(YAWS.Language.GetTranslation("viewing_warn_reason"))) + 10 
    
    surface.SetFont("yaws.7")
    x = x + select(2, surface.GetTextSize(YAWS.UI.TextWrap(self.warningData.reason, "yaws.7", w - 20)))
    
    surface.SetFont("yaws.8")
    x = x + select(2, surface.GetTextSize(YAWS.Language.GetTranslation("viewing_warn_time"))) + 10
    
    surface.SetFont("yaws.7")
    x = x + select(2, surface.GetTextSize(os.date("%H:%M:%S on %d/%m/%Y", self.warningData.time))) + 5

    if(YAWS.UI.CurrentData.can_view.delete_warns) then 
        x = x + 53
    end 

    self:SetExpandedHeight(x)
end 

vgui.Register("yaws.warning_entry_test", PANEL, "yaws.expandable_card_base")
--addons/yet_another_warn_system/lua/yaws/ui/elements/inputs/cl_icon_text_entry.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/inputs/cl_switch.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/inputs/cl_text_entry.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/layouts/cl_ui.lua:
function YAWS.UI.CoreUI(dontWipeCache) 
    local currentCache
    if(dontWipeCache) then 
        currentCache = {}
    else 
        currentCache = table.Copy(YAWS.UI.StateCache)
    end 
    
    local frame = vgui.Create("yaws.frame")
    frame:SetupSideBar(true)
    frame:SetSize(ScrW() * 0.6, ScrH() * 0.6)
    frame:Center()
    frame:SetBackgroundBlur(YAWS.UserSettings.GetValue("blur_background"))
    frame:MakePopup()
    YAWS.UI.CurrentData.FrameCache = frame

    local master = frame:GetMasterPanel()
    YAWS.UI.CurrentData.MasterCache = master

    if(YAWS.UI.CurrentData['can_view']['self_warns']) then 
        frame:AddSidebarTab(YAWS.Language.GetTranslation("sidebar_warnings"), YAWS.UI.MaterialCache['warning'], true, function()
            YAWS.UI.Tabs.Warnings(master)
        end)
    end

    if(YAWS.UI.CurrentData['can_view']['others_warns']) then
        frame:AddSidebarTab(YAWS.Language.GetTranslation("sidebar_players"), YAWS.UI.MaterialCache['player'], true, function()
            YAWS.UI.Tabs.Players(master)
        end)
    end

    if(YAWS.UI.CurrentData['can_view']['admin_settings']) then 
        frame:AddSidebarTab(YAWS.Language.GetTranslation("sidebar_admin"), YAWS.UI.MaterialCache['admin'], true, function()
            YAWS.UI.Tabs.Admin(master)
        end)
    end 

    frame:AddSidebarBottomTab(YAWS.Language.GetTranslation("sidebar_settings"), YAWS.UI.MaterialCache['settings'], true, function()
        YAWS.UI.Tabs.Settings(master)
    end)

    frame.PostPerformLayout = function()        
        if(!YAWS.UserSettings.GetValue("disable_fades")) then 
            frame:FadeIn()
        end
    end 
    frame.sidebar.PostPerformLayout = function()
        if(!YAWS.UI.CurrentData.state) then 
            frame:SetSidebarSelected(1)
        end 
    end 
end 

-- this is for my tendancys of breaking the ui during development
-- if this isn't commented out let me know
-- concommand.Add("yaws_resetui", function()
--     YAWS.UI.CurrentData.FrameCache:Remove()
-- end)
--addons/yet_another_warn_system/lua/yaws/ui/layouts/popups/cl_warn_player.lua:
function YAWS.UI.WarnPlayerPopup(data)
    local inPreset = false

    local frame = vgui.Create("yaws.frame")
    frame:SetSize(ScrW() * 0.45, ScrH() * 0.28)
    frame:Center()
    frame:MakePopup()
    frame.bgColor = Color(0, 0, 0, 200)

    local panel = vgui.Create("DPanel", frame)
    panel.Paint = function() end 

    local playerPanel = vgui.Create("yaws.panel", panel)
    local picture = vgui.Create("yaws.round_avatar", playerPanel)
    picture:SetSteamID(data.steamid, 256)
    playerPanel.PostPerformLayout = function(self, w, h)
        picture:Dock(LEFT)
        picture:DockMargin(10, 10, 10, 10)
        picture:SetWide(picture:GetTall())
    end 
    playerPanel.Paint = function(self, w, h)
        local colors = YAWS.UI.ColorScheme()
        draw.RoundedBox(0, 0, 0, w, h, colors['panel_background'])

        draw.SimpleText(data.name, "yaws.10", h + (5), h * 0.375, colors['text_header'], 0, 1)
        draw.SimpleText(data.realSteamID, "yaws.7", h + (5), h * 0.625, colors['text_main'], 0, 1)
    end 

    

    local presetSelection = vgui.Create("yaws.combo", panel)
    presetSelection:SetText(YAWS.Language.GetTranslation("admin_tab_warning_presets_box"))
    for k,v in pairs(YAWS.UI.CurrentData.current_presets) do
        presetSelection:AddChoice(k)
    end
    if(table.Count(YAWS.UI.CurrentData.current_presets) <= 0) then
        presetSelection:SetEnabled(false)
    end 
    
    local reason = vgui.Create("yaws.text_entry", panel)
    reason:SetPlaceholder(YAWS.Language.GetTranslation("admin_tab_warning_reason_placeholder"))
    reason:SetUpdateOnType(true)
    reason:SetMaximumCharCount(150)
    reason.OnValueChange = function(self, value)
        if(!inPreset) then return end 
        inPreset = false
        presetSelection:SetText(YAWS.Language.GetTranslation("admin_tab_warning_presets_box"))
    end
    
    local points = vgui.Create("yaws.wang", panel)
    points:SetUpdateOnType(true)
    points:SetMin(0)
    points:SetMin(YAWS.Config.GetValue("player_warn_maxpoints"))
    points:SetText("")
    points:SetPlaceholder(YAWS.Language.GetTranslation("generic_point_count"))
    points.OnValueChanged = function(self, value)
        if(!inPreset) then return end 
        inPreset = false
        presetSelection:SetText(YAWS.Language.GetTranslation("admin_tab_warning_presets_box"))
    end

    if(!YAWS.UI.CurrentData['can_view']['custom_reasons']) then 
        reason:SetEnabled(false)
        points:SetEnabled(false)
    end 

    presetSelection.OnSelect = function(self, index, value, data)
        local preset = YAWS.UI.CurrentData.current_presets[value]
        if(!preset) then return end

        inPreset = false
        reason:SetValue(preset.reason)
        points:SetValue(preset.points)
        inPreset = true
    end 

    local bottomPanel = vgui.Create("DPanel", frame)
    bottomPanel.Paint = function() end 

    local submit = vgui.Create("yaws.button", bottomPanel)
    submit:SetLabel(YAWS.Language.GetTranslation("warn_player_submit"))
    submit.DoClick = function()
        if(!YAWS.UI.CurrentData['can_view']['custom_reasons']) then 
            if(!presetSelection:GetSelected()) then return end 
        else 
            if(string.Trim(reason:GetValue()) == "") then return end 
            if(string.Trim(points:GetValue()) == "") then return end 
        end

        if(points:GetValue() < 0) then return end -- prevents integer underflow - just incase :)
        net.Start("yaws.warns.warnplayer")
        net.WriteBool(false)
        net.WriteString(data.steamid)
        if(!YAWS.UI.CurrentData['can_view']['custom_reasons']) then 
            net.WriteString(presetSelection:GetSelected())
        else 
            net.WriteString(reason:GetValue())
            net.WriteUInt(points:GetValue(), 12)
        end 
        
        net.SendToServer()

        frame:Close()
        if YAWS.UI and YAWS.UI.CurrentData and YAWS.UI.CurrentData.FrameCache then 
        YAWS.UI.CurrentData.FrameCache:Close()
        end
    end 
    
    panel.PerformLayout = function(self, w, h) 
        playerPanel:Dock(TOP)
        playerPanel:SetHeight(h * 0.386)
        playerPanel:DockMargin(0, 0, 0, 10)

        presetSelection:Dock(TOP)
        presetSelection:DockMargin(0, 0, 0, 10)
        presetSelection:SetTall(h * 0.143)

        reason:Dock(TOP)
        reason:DockMargin(0, 0, 0, 10)
        reason:SetTall(h * 0.143)

        points:Dock(TOP)
        points:DockMargin(0, 0, 0, 10)
        points:SetTall(h * 0.143)
    end 

    local close = vgui.Create("yaws.button", bottomPanel)
    close:SetLabel(YAWS.Language.GetTranslation("generic_cancel"))
    close:SetColors('button_warn_base', 'button_warn_hover')
    close.DoClick = function() 
        frame:Close()
    end 
    
    frame.PerformLayout = function(self, w, h)
        bottomPanel:Dock(BOTTOM)
        bottomPanel:SetHeight(h * 0.12)
        bottomPanel:DockMargin(10, 10, 10, 10)
        
        submit:Dock(LEFT)
        submit:SetWide(bottomPanel:GetWide() * 0.5 - 5)
        
        close:Dock(RIGHT)
        close:SetWide(bottomPanel:GetWide() * 0.5 - 5)
        
        panel:Dock(FILL)
        panel:DockPadding(10, 10, 10, 10)

        if(!YAWS.UserSettings.GetValue("disable_fades")) then 
            frame:FadeIn()
        end
    end 
end
--addons/zerosfruitslicer/lua/sh_zfs_config_fruits.lua:
zfs = zfs or {}
zfs.config = zfs.config or {}
zfs.config.Fruits = {}
local function AddFruit(data) return table.insert(zfs.config.Fruits,data) end

ZFS_FRUIT_APPLE = AddFruit({
	Name = "Elma",
	Model = "models/zerochain/fruitslicerjob/fs_apple.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_apple.png", "smooth"),

	// How much Health/Energy does the fruits give the player
	Health = 3,

	CutEffect = "zfs_banana",
	CutSound = "zfs_sfx_apple",

	// How many Knife hits does it take to Finish this fruit
	PrepareAmount = 8,

	// This Sets the bodygroup of the fruit entity to a sliced form for the mixer
	SlicedBG = 8,

	// Rotates the fruit on the up axis
	AngleOffset = -90,

	// Once the fruit reaches this bodygroup we change the color of it to white
	ChangeColorAtBodygroup = -1
})

ZFS_FRUIT_BANANA = AddFruit({
	Name = "Muz",
	Model = "models/zerochain/fruitslicerjob/fs_banana.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_banana.png", "smooth"),
	Health = 5,
	CutEffect = "zfs_banana",
	CutSound = "zfs_sfx_banana",
	PrepareAmount = 5,
	SlicedBG = 3,
	AngleOffset = 0,
	ChangeColorAtBodygroup = 1,
	OnSpawn = function(ent)
		ent:SetColor(HSVToColor(math.random(45, 65), 1, 1))
	end,
})

ZFS_FRUIT_COCONUT = AddFruit({
	Name = "Hindistan Cevizi",
	Model = "models/zerochain/fruitslicerjob/fs_coconut.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_coconut.png", "smooth"),
	Health = 10,
	CutEffect = "zfs_coconut",
	CutSound = "zfs_sfx_coconut",
	CutFinishSound = "zfs_sfx_coconut_finish",
	PrepareAmount = 6,
	SlicedBG = 2,
	AngleOffset = 90,
	ChangeColorAtBodygroup = 5,
	OnSpawn = function(ent)
		ent:SetColor(HSVToColor(math.random(70, 100), 1, 1))
	end,
})

ZFS_FRUIT_KIWI = AddFruit({
	Name = "Kivi",
	Model = "models/zerochain/fruitslicerjob/fs_kiwi.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_kiwi.png", "smooth"),
	Health = 3,
	CutEffect = "zfs_kiwi",
	CutSound = "zfs_sfx_banana",
	PrepareAmount = 8,
	SlicedBG = 5,
	AngleOffset = -90,
	ChangeColorAtBodygroup = -1,
})

ZFS_FRUIT_LEMON = AddFruit({
	Name = "Limon",
	Model = "models/zerochain/fruitslicerjob/fs_lemon.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_lemon.png", "smooth"),
	Health = 1,
	CutEffect = "zfs_banana",
	CutSound = "zfs_sfx_banana",
	PrepareAmount = 8,
	SlicedBG = 4,
	AngleOffset = -90,
	ChangeColorAtBodygroup = -1,
})

ZFS_FRUIT_MELON = AddFruit({
	Name = "Karpuz",
	Model = "models/zerochain/fruitslicerjob/fs_melon.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_watermelon.png", "smooth"),
	Health = 15,
	CutEffect = "zfs_melon",
	CutSound = "zfs_sfx_melon",
	CutFinishSound = "zfs_sfx_melon_finish",
	PrepareAmount = 5,
	SlicedBG = 0,
	AngleOffset = 0,
	ChangeColorAtBodygroup = -1,
})

ZFS_FRUIT_POMEGRANATE = AddFruit({
	Name = "Nar",
	Model = "models/zerochain/fruitslicerjob/fs_pomegranate.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_pomegranate.png", "smooth"),
	Health = 7,
	CutEffect = "zfs_melon",
	CutSound = "zfs_sfx_pomegranate",
	CutFinishSound = "zfs_sfx_pomegranate_finish",
	PrepareAmount = 6,
	SlicedBG = 1,
	AngleOffset = 0,
	ChangeColorAtBodygroup = -1,
})

ZFS_FRUIT_ORANGE = AddFruit({
	Name = "Portakal",
	Model = "models/zerochain/fruitslicerjob/fs_orange.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_orange.png", "smooth"),
	Health = 1,
	CutEffect = "zfs_orange",
	CutSound = "zfs_sfx_banana",
	PrepareAmount = 8,
	SlicedBG = 6,
	AngleOffset = -90,
	ChangeColorAtBodygroup = -1,
})

ZFS_FRUIT_STRAWBERRYS = AddFruit({
	Name = "Çilek",
	Model = "models/zerochain/fruitslicerjob/fs_strawberry.mdl",
	Icon = Material("materials/zfruitslicer/ui/ingrediens/zfs_strawberry.png", "smooth"),
	Health = 2,
	CutEffect = "zfs_strawberry",
	CutSound = "zfs_sfx_banana",
	PrepareAmount = 8,
	SlicedBG = 7,
	AngleOffset = -90,
	ChangeColorAtBodygroup = -1,
})

--addons/zeros_growop2_v1.6.1/lua/autorun/zgo2_load.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/zgo2/util/cl_settings.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

if SERVER then return end

hook.Add("AddToolMenuCategories", "zgo2_CreateCategories", function()
	spawnmenu.AddToolCategory("Options", "zgo2_options", "GrowOP 2")
end)

local PrimaryColor = Color(82, 117, 71)
local SecondaryColor = Color(54, 77, 47) // zclib.colors[ "ui02" ]

hook.Add("PopulateToolMenu", "zgo2_PopulateMenus", function()
	spawnmenu.AddToolMenuOption("Options", "zgo2_options", "zgo2_Admin_Settings", "Admin Settings", "", "", function(CPanel)
		zclib.Settings.OptionPanel("Public Grow Setup", nil, PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "Save",
				class = "DButton",
				cmd = "zgo2_public_save",
			},
			[ 2 ] = {
				name = "Remove",
				class = "DButton",
				cmd = "zgo2_public_remove",
			},
		})
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

		zclib.Settings.OptionPanel("Plant", nil, PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "Open Editor",
				class = "DButton",
				cmd = "zgo2_plant_editor",
			},
			[ 2 ] = {
				name = "Factory Reset Config",
				class = "DButton",
				cmd = "zgo2_plant_factory_reset",
			},
		})

		zclib.Settings.OptionPanel("Bong", nil, PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "Open Editor",
				class = "DButton",
				cmd = "zgo2_bong_editor",
			},
			[ 2 ] = {
				name = "Factory Reset Config",
				class = "DButton",
				cmd = "zgo2_bong_factory_reset",
			},
		})

		zclib.Settings.OptionPanel("Pot", nil, PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "Open Editor",
				class = "DButton",
				cmd = "zgo2_pot_editor",
			},
			[ 2 ] = {
				name = "Factory Reset Config",
				class = "DButton",
				cmd = "zgo2_pot_factory_reset",
			},
		})
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

		zclib.Settings.OptionPanel("NPC", nil, PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "Save",
				class = "DButton",
				cmd = "zgo2_npc_save",
			},
			[ 2 ] = {
				name = "Remove",
				class = "DButton",
				cmd = "zgo2_npc_remove",
			},
			[ 3 ] = {
				name = "Remove all DropZones",
				class = "DButton",
				cmd = "zgo2_DropZone_remove",
			},
		})
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

		zclib.Settings.OptionPanel("Commands", nil, PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "Spawn Seeds",
				class = "DButton",
				cmd = "zgo2_spawn_seed",
			},
			[ 2 ] = {
				name = "Spawn Plants",
				class = "DButton",
				cmd = "zgo2_spawn_plants",
			},
			[ 3 ] = {
				name = "Spawn Weedbranches",
				class = "DButton",
				cmd = "zgo2_spawn_weedbranch",
			},
			[ 4 ] = {
				name = "Spawn Jars",
				class = "DButton",
				cmd = "zgo2_spawn_jars",
			},
			[ 5 ] = {
				name = "Spawn Baggies",
				class = "DButton",
				cmd = "zgo2_spawn_baggies",
			},
			[ 6 ] = {
				name = "Spawn Joints",
				class = "DButton",
				cmd = "zgo2_spawn_joints",
			},
			[ 7 ] = {
				name = "Spawn Weedblocks",
				class = "DButton",
				cmd = "zgo2_spawn_weedblocks",
			},
			[ 8 ] = {
				name = "Spawn Contract",
				class = "DButton",
				cmd = "zgo2_spawn_contract",
			},
			[ 9 ] = {
				name = "Spawn Edibles",
				class = "DButton",
				cmd = "zgo2_spawn_edibles",
			},
		})
	end)

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

	spawnmenu.AddToolMenuOption("Options", "zgo2_options", "zgo2_Client_Settings", "Client Settings", "", "", function(CPanel)
		zclib.Settings.OptionPanel("Lamp", "", PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "DynamicLight",
				class = "DCheckBoxLabel",
				cmd = "zgo2_cl_dynlight",
			},
			[ 2 ] = {
				name = "Light Sprites",
				class = "DCheckBoxLabel",
				cmd = "zgo2_cl_lightsprite",
			},
			[ 3 ] = {
				name = "Light Beams",
				class = "DCheckBoxLabel",
				cmd = "zgo2_cl_lightbeam",
			},
		})

		zclib.Settings.OptionPanel("Plant", "", PrimaryColor, SecondaryColor, CPanel, {
			[ 1 ] = {
				name = "Smooth Grow",
				class = "DCheckBoxLabel",
				cmd = "zgo2_cl_smoothgrow",
				desc = "Makes the plants grow smoothly."
			},
			[ 2 ] = {
				name = "Skank Effect",
				class = "DCheckBoxLabel",
				cmd = "zgo2_cl_drawskank",
				desc = "Draws the Skank Effect when the plant is harvest ready."
			},
		})
	end)
end)

--addons/zeros_methlab_1.6.4/lua/zmlab/cl/zmlab_settings_menu.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/zrms/cl/zrmine_settings_menu.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

if (not CLIENT) then return end
local Created = false

CreateConVar("zrms_cl_highlight_refreshrate", "0.1", {FCVAR_ARCHIVE})
CreateConVar("zrms_cl_pickaxe_help", "1", {FCVAR_ARCHIVE})
CreateConVar("zrms_cl_FillIndicator", "1", {FCVAR_ARCHIVE})
CreateConVar("zrms_cl_lightsprites", "1", {FCVAR_ARCHIVE})
CreateConVar("zrms_cl_dynlight", "1", {FCVAR_ARCHIVE})
CreateConVar("zrms_cl_stencil", "1", {FCVAR_ARCHIVE})
CreateConVar("zrms_cl_particleffects", "1", {FCVAR_ARCHIVE})
CreateConVar("zrms_cl_audiovolume", "1", {FCVAR_ARCHIVE})
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 


local function zrmine_OptionPanel(name, CPanel, cmds)
	local panel = vgui.Create("DPanel")
	panel:SetSize(250 , 40 + (35 * table.Count(cmds)))
	panel.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, zrmine.default_colors["grey07"])
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	local title = vgui.Create("DLabel", panel)
	title:SetPos(10, 2.5)
	title:SetText(name)
	title:SetFont("zrmine_settings_font01")
	title:SetSize(panel:GetWide(), 30)
	title:SetTextColor(zrmine.default_colors["Gold"])

	for k, v in pairs(cmds) do
		if v.class == "DNumSlider" then

			local item = vgui.Create("DNumSlider", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText(v.name)
			item:SetMin(v.min)
			item:SetMax(v.max)
			item:SetDecimals(v.decimal)
			item:SetDefaultValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
			item:ResetToDefaultValue()

			item.OnValueChanged = function(self, val)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

				if (not Created) then
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end

			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
				end
			end)

		elseif v.class == "DCheckBoxLabel" then

			local item = vgui.Create("DCheckBoxLabel", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText( v.name )
			item:SetConVar( v.cmd )
			item:SetValue(0)
			item.OnChange = function(self, val)

				if (not Created) then
					if ((bVal and 1 or 0) == cvars.Number(v.cmd)) then return end
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end

			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(GetConVar(v.cmd):GetInt())
				end
			end)
		elseif v.class == "DButton" then
			local item = vgui.Create("DButton", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText( "" )
			item.Paint = function(s, w, h)
				draw.RoundedBox(5, 0, 0, w, h, zrmine.default_colors["grey06"])
				draw.SimpleText(v.name, "zrmine_settings_font02", w / 2, h / 2, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

				if s.Hovered then
					draw.RoundedBox(5, 0, 0, w, h, zrmine.default_colors["white04"])
				end
			end
			item.DoClick = function()

				if zrmine.f.IsAdmin(LocalPlayer()) == false then return end

				LocalPlayer():EmitSound("zrmine_ui_click")

				if v.notify then

					notification.AddLegacy(  v.notify, NOTIFY_GENERIC, 2 )
				end
				LocalPlayer():ConCommand( v.cmd )

			end
		end
	end

	CPanel:AddPanel(panel)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 


local function zrmine_settings(CPanel)
	Created = true

	CPanel:AddControl("Header", {
		Text = "Client Settings",
		Description = ""
	})

	zrmine_OptionPanel("VFX",CPanel,{
		[1] = {name = "ParticleEffects",class = "DCheckBoxLabel", cmd = "zrms_cl_particleffects"},
		[2] = {name = "LightSprites",class = "DCheckBoxLabel", cmd = "zrms_cl_lightsprites"},
		[3] = {name = "DynamicLight",class = "DCheckBoxLabel", cmd = "zrms_cl_dynlight"},
		[4] = {name = "Stencil",class = "DCheckBoxLabel", cmd = "zrms_cl_stencil"},
		[5] = {name = "Fill Indicator",class = "DCheckBoxLabel", cmd = "zrms_cl_FillIndicator"},
	})


	zrmine_OptionPanel("UI",CPanel,{
		[1] = {name = "Pickaxe Help (On Screen Top)",class = "DCheckBoxLabel", cmd = "zrms_cl_pickaxe_help"},
		[2] = {name = "Machine Update Rate",class = "DNumSlider", cmd = "zrms_cl_highlight_refreshrate",min = 0.01,max = 3,decimal = 2},
	})


	zrmine_OptionPanel("SFX",CPanel,{
		[1] = {name = "Audio Volume",class = "DNumSlider", cmd = "zrms_cl_audiovolume",min = 0,max = 1,decimal = 2},
	})

	timer.Simple(0.2, function()
		Created = false
	end)
end

local function zrmine_admin_settings(CPanel)
	CPanel:AddControl("Header", {
		Text = "Admin Commands",
		Description = ""
	})

	zrmine_OptionPanel("NPC",CPanel,{
		[1] = {name = "Save",class = "DButton", cmd = "zrms_npc_save"},
		[2] = {name = "Remove",class = "DButton", cmd = "zrms_npc_remove"},
	})

	zrmine_OptionPanel("Ore Spawns",CPanel,{
		[1] = {name = "Save",class = "DButton", cmd = "zrms_ore_save"},
		[2] = {name = "Remove",class = "DButton", cmd = "zrms_ore_remove"},
	})

	zrmine_OptionPanel("Public Entities",CPanel,{
		[1] = {name = "Save",class = "DButton", cmd = "zrms_publicents_save"},
		[2] = {name = "Remove",class = "DButton", cmd = "zrms_publicents_remove"},
	})

	zrmine_OptionPanel("PipeLine",CPanel,{
		[1] = {name = "Save",class = "DButton", cmd = "zrmine_pipeline_save"},
		[2] = {name = "Rebuild",class = "DButton", cmd = "zrmine_pipeline_load"},
		[3] = {name = "Delete",class = "DButton", cmd = "zrmine_pipeline_delete"},
	})

	zrmine_OptionPanel("Level System",CPanel,{
		[1] = {name = "Open PlayerData",class = "DButton", cmd = "zrms_levelsystem_open"},
	})
end

hook.Add("PopulateToolMenu", "a_zrmine_PopulateToolMenu", function()
	spawnmenu.AddToolMenuOption("Options", "Retro Miner", "ZRMSSettings", "Client Settings", "", "", zrmine_settings)
	spawnmenu.AddToolMenuOption("Options", "Retro Miner", "ZRMSAdmin", "Admin Settings", "", "", zrmine_admin_settings)
end)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

hook.Add("AddToolMenuCategories", "a_zrmine_AddToolMenuCategories", function()
	spawnmenu.AddToolCategory("Options", "Retro Miner", "Retro Miner")
end)

--addons/zeros_yeastbeast_1.1.7/lua/autorun/zyb_load.lua:
zyb = zyb or {}
zyb.f = zyb.f or {}

local function NicePrint(txt)
	if SERVER then
		MsgC(Color(193, 120, 98), txt .. "\n")
	else
		MsgC(Color(193, 193, 98), txt .. "\n")
	end
end

local IgnoreFileTable = {}
function zyb.f.PreLoadFile(fdir,afile,info)
	IgnoreFileTable[afile] = true
	zyb.f.LoadFile(fdir,afile,info)
end

function zyb.f.LoadFile(fdir,afile,info)

	if info then
		local nfo = "// [ Initialize ]: " .. afile .. string.rep( " ", 30 - afile:len() ) .. "//"
		NicePrint(nfo)
	end

	if SERVER then
		AddCSLuaFile(fdir .. afile)
	end

	include(fdir .. afile)
end

function zyb.f.LoadAllFiles(fdir)
	local files, dirs = file.Find(fdir .. "*", "LUA")

	for _, afile in ipairs(files) do
		if string.match(afile, ".lua") and not IgnoreFileTable[afile] then
			zyb.f.LoadFile(fdir,afile,true)
		end
	end

	for _, dir in ipairs(dirs) do
		zyb.f.LoadAllFiles(fdir .. dir .. "/")
	end
end

// Initializes the Script
function zyb.f.Initialize()
	NicePrint(" ")
	NicePrint("///////////////////////////////////////////////////")
	NicePrint("/////////////// Zeros Yeastbeast //////////////////")
	NicePrint("///////////////////////////////////////////////////")

	zyb.f.PreLoadFile("zerosyeastbeast/sh/","zyb_materials.lua",true)
	zyb.f.PreLoadFile("zerosyeastbeast/sh/","zyb_config.lua",true)

	zyb.f.LoadAllFiles("zyb_languages/")


	zyb.f.LoadAllFiles("zerosyeastbeast/sh/")
	if SERVER then
		zyb.f.LoadAllFiles("zerosyeastbeast/sv/")
	end
	zyb.f.LoadAllFiles("zerosyeastbeast/cl/")

	NicePrint("///////////////////////////////////////////////////")
	NicePrint("///////////////////////////////////////////////////")
end

if SERVER then
	timer.Simple(0,function()
		zyb.f.Initialize()
	end)
else

	// This needs to be called instantly on client since client settings wont work otherwhise
	zyb.f.PreLoadFile("zerosyeastbeast/sh/","zyb_materials.lua",false)
	zyb.f.PreLoadFile("zerosyeastbeast/cl/","zyb_fonts_cl.lua",false)
	zyb.f.PreLoadFile("zerosyeastbeast/cl/","zyb_settings_cl.lua",false)

	timer.Simple(0,function()
		zyb.f.Initialize()
	end)
end

--addons/zeros_yeastbeast_1.1.7/lua/zerosyeastbeast/cl/zyb_settings_cl.lua:
if not CLIENT then return end
local Created = false


zyb = zyb or {}
zyb.f = zyb.f or {}

CreateConVar("zyb_cl_particleeffects", "1", {FCVAR_ARCHIVE})


local function zyb_OptionPanel(name, CPanel, cmds)
	local panel = vgui.Create("DPanel")
	panel:SetSize(250 , 40 + (35 * table.Count(cmds)))
	panel.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, zyb.default_colors["grey_light"])
	end

	local title = vgui.Create("DLabel", panel)
	title:SetPos(10, 2.5)
	title:SetText(name)
	title:SetFont("zyb_settings_font01")
	title:SetSize(panel:GetWide(), 30)
	title:SetTextColor(zyb.default_colors["brown08"])

	for k, v in pairs(cmds) do
		if v.class == "DNumSlider" then

			local item = vgui.Create("DNumSlider", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText(v.name)
			item:SetMin(v.min)
			item:SetMax(v.max)
			item:SetDecimals(v.decimal)
			item:SetDefaultValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
			item:ResetToDefaultValue()

			item.OnValueChanged = function(self, val)

				if (not Created) then
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end

			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
				end
			end)
		elseif v.class == "DCheckBoxLabel" then

			local item = vgui.Create("DCheckBoxLabel", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText( v.name )
			item:SetConVar( v.cmd )
			item:SetValue(0)
			item.OnChange = function(self, val)

				if (not Created) then
					if ((bVal and 1 or 0) == cvars.Number(v.cmd)) then return end
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end

			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(GetConVar(v.cmd):GetInt())
				end
			end)
		elseif v.class == "DButton" then
			local item = vgui.Create("DButton", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText( "" )
			//item:SetConsoleCommand( v.cmd )
			item.Paint = function(s, w, h)
				draw.RoundedBox(5, 0, 0, w, h, zyb.default_colors["grey_lighter"])
				draw.SimpleText(v.name, "zyb_settings_font02", w / 2, h / 2, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

				if s.Hovered then
					draw.RoundedBox(5, 0, 0, w, h, zyb.default_colors["white02"])
				end
			end
			item.DoClick = function()

				if zyb.f.IsAdmin(LocalPlayer()) == false then return end

				LocalPlayer():EmitSound("zyb_ui_click")

				if v.notify then

					notification.AddLegacy(  v.notify, NOTIFY_GENERIC, 2 )
				end
				LocalPlayer():ConCommand( v.cmd )

			end
		end
	end

	CPanel:AddPanel(panel)
end


local function YeastBeast_settings(CPanel)
	Created = true
	CPanel:AddControl("Header", {
		Text = "Client Settings",
		Description = ""
	})

	zyb_OptionPanel("VFX",CPanel,{
		[1] = {name = "ParticleEffects",class = "DCheckBoxLabel", cmd = "zyb_cl_particleeffects"},
	})

	timer.Simple(0.2, function()
		Created = false
	end)
end

local function YeastBeast_admin_settings(CPanel)

	CPanel:AddControl("Header", {
		Text = "Admin Commands",
		Description = ""
	})

	zyb_OptionPanel("NPC",CPanel,{
		[1] = {name = "Save",class = "DButton", cmd = "zyb_npc_save"},
		[2] = {name = "Remove",class = "DButton", cmd = "zyb_npc_remove"},
	})

	zyb_OptionPanel("Public Setup",CPanel,{
		[1] = {name = "Save",class = "DButton", cmd = "zyb_public_save"},
		[2] = {name = "Remove",class = "DButton", cmd = "zyb_public_remove"},
	})


	zyb_OptionPanel("Usefull Commands",CPanel,{
		[1] = {name = "Moonshine Crate",class = "DButton", cmd = "zyb_debug_spawn_jarcrate"},
		[2] = {name = "Moonshine Jar",class = "DButton", cmd = "zyb_debug_spawn_jar"},
	})
end

hook.Add("AddToolMenuCategories", "zyb_CreateCategories", function()
	spawnmenu.AddToolCategory("Options", "YeastBeast", "YeastBeast")
end)

hook.Add("PopulateToolMenu", "zyb_PopulateMenus", function()
	spawnmenu.AddToolMenuOption("Options", "YeastBeast", "zyb_Settings", "Client Settings", "", "", YeastBeast_settings)
	spawnmenu.AddToolMenuOption("Options", "YeastBeast", "zyb_Admin_Settings", "Admin Settings", "", "", YeastBeast_admin_settings)
end)

--addons/executioner/lua/autorun/client/executioner_hitman_hud.lua:
return gluapack()()
--addons/partysystem/lua/autorun/client/partybutton.lua:
return gluapack()()
--addons/partysystem/lua/autorun/client/partyframe.lua:
local PANEL = {}

surface.CreateFont("roboto16",{
	font = "Roboto",
	size = 16,
})

function PANEL:Init()
	self.ShowTitleBar = true
	self.BackgroundColor = Color(255,255,255)

	self:DockPadding(1,24,1,1)

	self.lblTitle:SetTextColor(Color(255,255,255))
	self.lblTitle:SetFont("roboto16")
	self.lblTitle:SetPos(5,5)

	self.Paint = function(self)
		surface.SetDrawColor(self.BackgroundColor)
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())

		if (self.ShowTitleBar ~= false) then
			surface.SetDrawColor(Color(26,26,26))
			surface.DrawRect(0,0,self:GetWide(),24)

			surface.SetDrawColor(Color(26,26,26))
			surface.DrawOutlinedRect(0,0,self:GetWide(),self:GetTall())
		end
	end
end

function PANEL:ShowCloseButton(shouldshow)
	self.CloseButton:ShowCloseButton(shouldshow)
end

function PANEL:Configured()
	self.CloseButton = vgui.Create("PartyCloseButton",self)
end

function PANEL:Paint()
	surface.SetDrawColor(Color(26,26,26))
	surface.DrawRect(0,0,self:GetWide(),self:GetTall())
end

function PANEL:Close()
	self:SetMouseInputEnabled(false)
	self:SetKeyboardInputEnabled(false)

	self:Stop()
	self:Remove()

	if (self.OnClose ~= nil) then
		self.OnClose()
	end
end

function PANEL:ShouldShowTitleBar(shouldshow)
	PANEL.ShowTitleBar = tobool(shouldshow) or true
end
function PANEL:SetBackgroundColor(bgcolor)
	PANEL.ShowTitleBar = tobool(shouldshow) or true
end

derma.DefineControl("PartyFrame",nil,PANEL,"DFrame")
--addons/partysystem/lua/autorun/client/partylabel.lua:
return gluapack()()
--addons/partysystem/lua/autorun/client/partylistview.lua:
local PANEL = {}

function PANEL:Init()
	self.Paint = function(self)
		surface.SetDrawColor(Color(255,255,255))
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end
	self:SetHeaderHeight(35)
	self:SetDataHeight(25)
	self.ColorMode = false

	self.VBar.btnUp:SetText("-")
	self.VBar.btnUp:SetFont("roboto16")
	self.VBar.btnUp:SetTextColor(Color(255,255,255))
	self.VBar.btnUp.Paint = function(self)
		surface.SetDrawColor(Color(0,0,0))
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end

	self.VBar.btnDown:SetText("-")
	self.VBar.btnDown:SetFont("roboto16")
	self.VBar.btnDown:SetTextColor(Color(255,255,255))
	self.VBar.btnDown.Paint = function(self)
		surface.SetDrawColor(Color(0,0,0))
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end

	self.VBar.btnGrip:SetCursor("hand")
	self.VBar.btnGrip.Paint = function(self)
		surface.SetDrawColor(Color(50,50,50))
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end

	self.VBar.Paint = function(self)
		surface.SetDrawColor(Color(0,0,0))
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end
end

function PANEL:Clear()
	self.ColorMode = false

	for a,b in pairs(self.Lines)do b:Remove()end;self.Lines={}self.Sorted={}self:SetDirty(true)
end

function PANEL:AddColumn(a,b)local c=nil;if self.m_bSortable then c=vgui.Create("PartyListView_Column",self)else c=vgui.Create("DListView_ColumnPlain",self)end;c:SetName(a)c:SetZPos(10)if b then table.insert(self.Columns,b,c)for d=1,#self.Columns do self.Columns[d]:SetColumnID(d)end else local e=table.insert(self.Columns,c)c:SetColumnID(e)end;self:InvalidateLayout()return c end
function PANEL:AddLine(...)self:SetDirty(true)self:InvalidateLayout()local a=vgui.Create("PartyListView_Line",self.pnlCanvas)local b=table.insert(self.Lines,a)a:SetListView(self)a:SetID(b)for c,d in pairs(self.Columns)do a:SetColumnText(c,"")end;for c,d in pairs({...})do a:SetColumnText(c,d)end;local e=table.insert(self.Sorted,a)if e%2==1 then a:SetAltLine(true)end;for f,g in pairs(a.Columns)do g:SetFont("roboto16")end;return a end

function PANEL:RemoveLine(LineID)
	local a=self:GetLine(LineID)local b=self:GetSortedID(LineID)self.Lines[LineID]=nil;table.remove(self.Sorted,b)self:SetDirty(true)self:InvalidateLayout()a:Remove()

	local newlines = {}
	local i = 0
	for _i,v in pairs(self:GetLines()) do
		if (not IsValid(v)) then continue end
		i = i + 1
		newlines[i] = v
		v:SetID(i)
	end
	self.Lines = newlines
end

derma.DefineControl("PartyListView",nil,PANEL,"DListView")
--lua/vgui/bvgui/categories.lua:
--/// bVGUI.Categories ///--

local PANEL = {}

function PANEL:Init()
	self.Categories = {}
	self.Items = {}

	self:Dock(LEFT)

	self.CategoriesContainer = vgui.Create("bVGUI.ScrollPanel", self)
	self.CategoriesContainer:Dock(FILL)

	self.DrawBackground = true
end

function PANEL:SetDrawBackground(draw_background)
	self.DrawBackground = draw_background
end

function PANEL:Paint(w,h)
	if (self.DrawBackground) then
		surface.SetDrawColor(bVGUI.COLOR_SLATE)
		surface.DrawRect(0,0,w,h)
	end

	self:LoadingPaint(w,h)
end

function PANEL:AddCategory(category_name, category_col)
	local this = self

	local category = vgui.Create("bVGUI.CategoriesCategory", self.CategoriesContainer)
	self.Categories[category_name] = category
	category:SetColor(category_col)
	category:SetText(category_name)
	category.ExistingItems = {}

	function category:AddItem(item_name, func, col, icon)
		if (category.ExistingItems[item_name]) then return end
		category.ExistingItems[item_name] = true
		local item = vgui.Create("bVGUI.CategoriesItem", self.ItemsContainer)
		table.insert(this.Items, item)
		item.ItemFunction = func
		item.Category = category
		item:SetText(item_name)
		if (col) then
			item:SetColor(col)
		else
			item:SetColor(category_col)
		end
		if (icon) then
			item:SetIcon(icon)
		end
		self.ItemsContainer:SizeToChildren(false, true)
		self.ItemsContainer:InvalidateParent(true)

		return item
	end

	function category:AddPlayer(ply, func, col, icon)
		local item = category:AddItem(ply:SteamID(), func, col, icon)
		if (not item) then return end
		item:SetAccountID(ply:AccountID())
	end

	function category:AddSteamID(steamid, func, col, icon)
		local item = category:AddItem(steamid, func, col, icon)
		if (not item) then return end
		print("deprecated AddSteamID", steamid)
		debug.Trace()
		item:SetAccountID(GAS:SteamIDToAccountID(steamid))
	end

	function category:AddAccountID(account_id, func, col, icon)
		local item = category:AddItem(GAS:AccountIDToSteamID(account_id), func, col, icon)
		if (not item) then return end
		item:SetAccountID(account_id)
	end

	function category:Clear()
		self.ExistingItems = {}
		local new_items = {}
		for i,v in pairs(this.Items) do
			if (v.Category == self) then
				v:Remove()
			else
				table.insert(new_items, v)
			end
		end
		this.Items = new_items
	end

	return category
end

function PANEL:RemoveItem(item)
	local item_category = item.Category

	item_category.ExistingItems[item.ItemName] = nil
	for i,v in ipairs(self.Items) do
		if (v == item) then
			table.remove(self.Items, i)
			break
		end
	end
	item:Remove()

	timer.Simple(0, function()
		if (item_category.Collapsed) then
			item_category.ItemsContainer:Stop()
			local y = 0
			for _,v in ipairs(item_category.ItemsContainer:GetChildren()) do
				y = y + v:GetTall()
			end
			item_category.ItemsContainer:SizeTo(item_category.ItemsContainer:GetWide(), y, 0.5)
		end
	end)
end

function PANEL:Clear()
	for _,v in ipairs(self.Items) do
		v:Remove()
	end
	for _,v in pairs(self.Categories) do
		v:Remove()
	end
	self.Categories = {}
	self.Items = {}
	self.CategoriesContainer:SetTall(0)
	self:InvalidateLayout(true)
	self.CategoriesContainer:InvalidateLayout(true)
end

function PANEL:EnableSearchBar(search_phrase)
	self.SearchBarContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.SearchBarContainer:Dock(BOTTOM)
	self.SearchBarContainer:DockPadding(5,5,5,5)
	self.SearchBarContainer:SetTall(32)
	function self.SearchBarContainer:Paint(w,h)
		surface.SetDrawColor(bVGUI.COLOR_SLATE)
		surface.DrawRect(0,0,w,h)
	end

	self.SearchBarContainer.SearchBar = vgui.Create("bVGUI.TextEntry", self.SearchBarContainer)
	self.SearchBarContainer.SearchBar:Dock(FILL)
	self.SearchBarContainer.SearchBar:SetPlaceholderText(search_phrase or "Search...")
	function self.SearchBarContainer.SearchBar:OnChange()
		local search_text = self:GetText():lower()
		if (#search_text == 0) then
			for _,v in ipairs(self:GetParent():GetParent().Items) do
				v:SetVisible(true)
			end
		else
			for _,v in ipairs(self:GetParent():GetParent().Items) do
				if (v:GetText():lower():find(search_text,1,true)) then
					v:SetVisible(true)
				else
					v:SetVisible(false)
				end
			end
		end
		for _,v in pairs(self:GetParent():GetParent().Categories) do
			v.ItemsContainer:InvalidateLayout(true)
			v.ItemsContainer:SizeToChildren(false, true)
			v.ItemsContainer:InvalidateParent(true)
		end
	end
end

function PANEL:AddItem(item_name, func, col, icon)
	local item = vgui.Create("bVGUI.CategoriesItem", self)
	table.insert(self.Items, item)
	item.ItemFunction = func
	item.Category = category
	item:SetText(item_name)
	if (col) then
		item:SetColor(col)
	else
		item:SetColor(category_col)
	end
	if (icon) then
		item:SetIcon(icon)
	end

	return item
end

function PANEL:ClearActive()
	for _,v in ipairs(self.Items) do
		v:SetActive(false)
	end
end

derma.DefineControl("bVGUI.Categories", nil, PANEL, "bVGUI.LoadingPanel")

--/// bVGUI.CategoriesCategory ///--

local PANEL = {}

function PANEL:Init()
	self:SetTall(35)
	self:Dock(TOP)

	self.Collapsed = true
	self:SetCursor("up")

	self.CategoryColor = Color(0,0,0)
	self.CategoryName = ""

	self.CategoryNameLabel = vgui.Create("DLabel", self)
	self.CategoryNameLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.CategoryNameLabel:SetText("")

	self.ItemsContainer = vgui.Create("DPanel", self:GetParent())
	self.ItemsContainer:SetTall(0)
	self.ItemsContainer:Dock(TOP)
	self.ItemsContainer.Category = self
	function self.ItemsContainer:Paint(w,h)
		surface.SetDrawColor(255,255,255,200)
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(self.CategoryColor)
	surface.DrawRect(0,0,w,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	surface.DrawTexturedRect(0,0,w,h)
end

function PANEL:SetColor(col)
	self.CategoryColor = col
	
	if (bVGUI.ColorShouldUseBlackText(col)) then
		self.CategoryNameLabel:SetTextColor(bVGUI.COLOR_BLACK)
	else
		self.CategoryNameLabel:SetTextColor(bVGUI.COLOR_WHITE)
	end
end
function PANEL:SetText(text)
	self.CategoryName = text
	self.CategoryNameLabel:SetText(self.CategoryName)
	self.CategoryNameLabel:SizeToContentsY()
	self.CategoryNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.CategoryNameLabel:CenterVertical()
	self.CategoryNameLabel:AlignLeft(5 + 10)
end
function PANEL:GetText()
	return self.CategoryName
end

function PANEL:OnMouseReleased(m)
	if (m ~= MOUSE_LEFT) then return end
	if (self.Collapsed) then
		self.Collapsed = not self.Collapsed
		self:SetCursor("hand")
		self.ItemsContainer:Stop()
		self.ItemsContainer:SizeTo(self.ItemsContainer:GetWide(), 0, 0.5)
	else
		self.Collapsed = not self.Collapsed
		self:SetCursor("up")
		self.ItemsContainer:Stop()
		local y = 0
		for _,v in ipairs(self.ItemsContainer:GetChildren()) do
			y = y + v:GetTall()
		end
		self.ItemsContainer:SizeTo(self.ItemsContainer:GetWide(), y, 0.5)
	end
end

function PANEL:PerformLayout()
	self.CategoryNameLabel:SizeToContentsY()
	self.CategoryNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.CategoryNameLabel:CenterVertical()
	self.CategoryNameLabel:AlignLeft(5 + 10)
end

derma.DefineControl("bVGUI.CategoriesCategory", nil, PANEL, "DPanel")

--/// bVGUI.CategoriesItem ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self:SetTall(35)
	self:Dock(TOP)
	self:InvalidateParent(true)

	self.ItemName = ""
	self.ItemColor = bVGUI.COLOR_BLACK
	self.ItemColorDark = bVGUI.COLOR_BLACK

	self.ItemNameLabel = vgui.Create("DLabel", self)
	self.ItemNameLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.ItemNameLabel:SetText("")
	self.ItemNameLabel:SetTextColor(bVGUI.COLOR_WHITE)

	self.CurrentBarX = 0
	self.Ceil = false
	self.AnimTime = CurTime()
end

function PANEL:SetIcon(path)
	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage(path)
	self.Icon:SetSize(16, 16)
	self.Icon:AlignLeft(5 + 10)
	self.Icon:CenterVertical()

	self.ItemNameLabel:AlignLeft(5 + 10 + 16 + 5)
end

function PANEL:Paint(w,h)
	if (self:IsActive()) then
		self.CurrentBarX = Lerp(FrameTime() * 10, self.CurrentBarX, w)
	else
		self.CurrentBarX = Lerp(FrameTime() * 10, self.CurrentBarX, 5)
	end

	surface.SetDrawColor(self.ItemColor)
	surface.DrawRect(0, 0, 5, h)
	if (self.Ceil) then
		surface.SetDrawColor(self.ItemColorDark)
		surface.DrawRect(5, 0, math.ceil(self.CurrentBarX) - 5, h)
	else
		surface.SetDrawColor(self.ItemColorDark)
		surface.DrawRect(5, 0, math.floor(self.CurrentBarX) - 5, h)
	end
end

function PANEL:SetColor(col)
	self.ItemColor = col
	self.ItemColorDark = bVGUI.DarkenColor(self.ItemColor, 0.35)
end
function PANEL:SetText(text)
	self.ItemName = text
	self.ItemNameLabel:SetText(self.ItemName)
	self.ItemNameLabel:SizeToContentsY()
	self.ItemNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.ItemNameLabel:CenterVertical()
	self.ItemNameLabel:AlignLeft(5 + 10)
end
function PANEL:GetText()
	return self.ItemName
end

function PANEL:GetCategories()
	if (self:GetParent().Items) then
		return self:GetParent()
	elseif (self:GetParent():GetParent():GetParent():GetParent().Items) then
		return self:GetParent():GetParent():GetParent():GetParent()
	end
end

function PANEL:UpdateActiveState(active, forced_active)
	for _,v in pairs(self:GetCategories().Items) do
		v.Active = false
		v.AnimTime = CurTime()
		v.Ceil = false
	end
	self.AnimTime = CurTime()
	self.Active = active or false
	self.ForcedActive = forced_active or false
	self.Ceil = active or forced_active or false
end

function PANEL:IsActive()
	return self.Active or self.ForcedActive or false
end

function PANEL:SetForcedActive(forced_active)
	self:UpdateActiveState(self.Active, forced_active)
end

function PANEL:SetActive(active)
	self:UpdateActiveState(active, self.ForcedActive)
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		self:SetActive(true)
		if (self.ItemFunction) then
			if (self.AccountID) then
				self.ItemFunction(self.AccountID)
			else
				self.ItemFunction()
			end
		end
	elseif (m == MOUSE_RIGHT and self.AccountID) then
		bVGUI.PlayerTooltip.Focus()
	end
end

function PANEL:PerformLayout()
	self.ItemNameLabel:SizeToContentsY()
	self.ItemNameLabel:CenterVertical()

	local item_name_label_left = 5 + 10
	local item_name_label_wide = self:GetParent():GetWide() - 5 - 10 - 10
	if (IsValid(self.AvatarImage)) then
		self.AvatarImage:AlignLeft(5)
		self.AvatarImage:CenterVertical()
		item_name_label_left = item_name_label_left + 35
		item_name_label_wide = item_name_label_wide - 35
	end
	if (IsValid(self.Icon)) then
		item_name_label_left = item_name_label_left + 16 + 10
		item_name_label_wide = item_name_label_wide - (16 + 10)
	end
	self.ItemNameLabel:AlignLeft(item_name_label_left)
	self.ItemNameLabel:SetWide(item_name_label_wide)
end

function PANEL:SetAccountID(account_id)
	self.AccountID = account_id
	self.AvatarImage = vgui.Create("AvatarImage", self)
	self.AvatarImage:SetSize(35,35)
	self.AvatarImage:SetSteamID(GAS:AccountIDToSteamID64(account_id), 32)
	self.AvatarImage:SetMouseInputEnabled(false)
	local this = self
	GAS.OfflinePlayerData:AccountID(account_id, function(success, data)
		if (not success) then
			this:SetText(GAS:AccountIDToSteamID(account_id))
		else
			this:SetText(data.nick)
		end
	end)
end

function PANEL:SetSteamID64(steamid64)
	print("SetSteamID64 deprecated", steamid64)
	return self:SetAccountID(GAS:SteamID64ToAccountID(steamid64))
end

function PANEL:OnCursorEntered()
	if (self.AccountID) then
		bVGUI.PlayerTooltip.Create({
			account_id = self.AccountID,
			focustip = bVGUI.L("right_click_to_focus"),
			copiedphrase = bVGUI.L("copied"),
			creator = self
		})
	end
end
function PANEL:OnCursorExited()
	if (self.AccountID) then
		bVGUI.PlayerTooltip.Close()
	end
end

derma.DefineControl("bVGUI.CategoriesItem", nil, PANEL, "DPanel")
--lua/vgui/bvgui/gauge.lua:
return gluapack()()
--lua/vgui/bvgui/horizontaldivider.lua:
return gluapack()()
--lua/vgui/bvgui/loadingpanel.lua:
return gluapack()()
--lua/vgui/bvgui/mouseinfo_tooltip.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_entity_display.lua:
GAS_Logging_EntityDisplay_Networking = {}
GAS_Logging_EntityDisplay_Cache = {}

if (IsValid(GAS_Logging_EntityDisplay)) then
	GAS_Logging_EntityDisplay:Close()
end

local PANEL = {}

function PANEL:InfoInit()
	self.Shruggie = vgui.Create("DLabel", self)
	self.Shruggie:SetText("¯\\_(ツ)_/¯")
	self.Shruggie:SetFont("DermaLarge")
	self.Shruggie:SetTextColor(bVGUI.COLOR_WHITE)
	self.Shruggie:SizeToContents()
	self.Shruggie:SetVisible(false)

	self.LoadingPanel = vgui.Create("bVGUI.LoadingPanel", self)
	self.LoadingPanel:Dock(FILL)
	self.LoadingPanel:SetLoading(true)

	self.ModelPanel = vgui.Create("DModelPanel", self.LoadingPanel)
	self.ModelPanel:Dock(FILL)

	self.InfoContainer = vgui.Create("bVGUI.BlankPanel", self)

	self.LabelContainer = vgui.Create("bVGUI.BlankPanel", self.InfoContainer)
	self.LabelContainer:Dock(FILL)

	self.SpawnCategory = vgui.Create("DLabel", self.LabelContainer)
	self.SpawnCategory:Dock(BOTTOM)
	self.SpawnCategory:SetContentAlignment(3)
	self.SpawnCategory:SetTextColor(Color(160,160,160))
	self.SpawnCategory:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.SpawnCategory:SetText("")
	self.SpawnCategory:SetVisible(false)

	self.PrintName = vgui.Create("DLabel", self.LabelContainer)
	self.PrintName:SetText("")
	self.PrintName:SetTextColor(bVGUI.COLOR_WHITE)
	self.PrintName:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.PrintName:Dock(FILL)
	self.PrintName:SetContentAlignment(3)

	self.SpawnIcon = vgui.Create("DImage", self.InfoContainer)
	self.SpawnIcon:Dock(LEFT)
	self.SpawnIcon:DockMargin(0,0,10,0)
	self.SpawnIcon:SetSize(64,64)
	self.SpawnIcon:SetVisible(false)

	self.OldPerformLayout = self.PerformLayout
	function self:PerformLayout(w,h)
		self:OldPerformLayout(w,h)

		self.InfoContainer:SetSize(w - 20, 64)
		self.InfoContainer:AlignBottom(10)
		self.InfoContainer:AlignLeft(10)

		self.Shruggie:Center()
	end
end

function PANEL:FixCamera(scale)
	if (IsValid(self.ModelPanel.Entity)) then
		local PrevMins, PrevMaxs = self.ModelPanel.Entity:GetRenderBounds()
		self.ModelPanel:SetCamPos(PrevMins:Distance(PrevMaxs) * Vector(scale or 0.75, scale or 0.75,scale or 0.75))
		self.ModelPanel:SetLookAt((PrevMaxs + PrevMins) / 2)
	end
end

function PANEL:SetWeapon(weapon_class)
	self:SetTitle(weapon_class)

	local weapon_tbl = weapons.Get(weapon_class)
	if (weapon_tbl ~= nil and weapon_tbl.WorldModel ~= nil) then
		self.ModelPanel:SetModel(weapon_tbl.WorldModel)
		self:SetVisible(true)
		if (weapon_tbl.PrintName ~= nil and type(weapon_tbl.PrintName) == "string") then
			self.PrintName:SetText(weapon_tbl.PrintName)
		end
		if (weapon_tbl.Category ~= nil and type(weapon_tbl.Category)) then
			self.SpawnCategory:SetText(weapon_tbl.Category)
			self.SpawnCategory:SetVisible(true)
		end
	elseif (file.Exists("scripts/" .. weapon_class .. ".txt", "GAME")) then
		local weapon_script = file.Read("scripts/" .. weapon_class .. ".txt", "GAME")
		if (weapon_script) then
			local world_model = weapon_script:match('"playermodel"%s*"(.-)"')
			if (world_model ~= nil) then
				self.ModelPanel:SetModel(world_model)
				self:SetVisible(true)
			end
		end
		local weapon_info = list.Get("Weapon")[weapon_class]
		if (weapon_info) then
			if (weapon_info.PrintName ~= nil and type(weapon_info.PrintName) == "string") then
				self.PrintName:SetText(weapon_info.PrintName)
				self.PrintName:SizeToContents()
			end
			if (weapon_info.Category ~= nil and type(weapon_info.Category)) then
				self.SpawnCategory:SetText(weapon_info.Category)
				self.SpawnCategory:SetVisible(true)
			end
		end
	end

	if (file.Exists("materials/entities/" .. weapon_class .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. weapon_class .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	self:FixCamera()
	self.LoadingPanel:SetLoading(false)
end

function PANEL:SetProp(model)
	self.ModelPanel:SetModel(model)
	self:SetTitle(model)
	self:SetVisible(true)

	self:FixCamera()
	self.LoadingPanel:SetLoading(false)
end

function PANEL:SetAmmo(ammo_type)
	local spawnmenu_item = list.Get("SpawnableEntities")[ammo_type]
	if (spawnmenu_item ~= nil and spawnmenu_item.PrintName ~= nil and type(spawnmenu_item) == "string") then
		self.PrintName:SetText(spawnmenu_item.PrintName)
	end
	if (file.Exists("materials/entities/" .. ammo_type .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. ammo_type .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	self:SetVisible(true)

	if (GAS_Logging_EntityDisplay_Cache[ammo_type]) then
		self.ModelPanel:SetModel(GAS_Logging_EntityDisplay_Cache[ammo_type])
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)
	else
		local net_msg_fire = GAS_Logging_EntityDisplay_Networking[ammo_type] == nil
		GAS_Logging_EntityDisplay_Networking[ammo_type] = GAS_Logging_EntityDisplay_Networking[ammo_type] or {}
		GAS_Logging_EntityDisplay_Networking[ammo_type][self] = true
		if (net_msg_fire) then
			GAS:netStart("logging:EntityDisplay:AmmoModel")
				net.WriteString(ammo_type)
			net.SendToServer()
		end
	end
end

function PANEL:SetVehicle(vehicle_class, mdl_str)
	self:SetTitle(vehicle_class)

	if (mdl_str ~= nil and not IsUselessModel(mdl_str)) then
		self.ModelPanel:SetModel(mdl_str)
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)

		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Class == vehicle_class and spawnmenu_item.Model == mdl_str) then
				if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
					self.PrintName:SetText(spawnmenu_item.Name)
					if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
						self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
						self.SpawnIcon:SetVisible(true)
					end
				end
				return
			end
		end
		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Model == mdl_str) then
				if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
					self.PrintName:SetText(spawnmenu_item.Name)
					if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
						self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
						self.SpawnIcon:SetVisible(true)
					end
				end
				break
			end
		end
	else
		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Class ~= vehicle_class) then continue end
			if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
				self.PrintName:SetText(spawnmenu_item.Name)
				if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
					self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
					self.SpawnIcon:SetVisible(true)
				end
			end
			if (mdl_str == nil or IsUselessModel(mdl_str)) then
				if (spawnmenu_item.Model ~= nil and type(spawnmenu_item.Model) == "string") then
					self.ModelPanel:SetModel(spawnmenu_item.Model)
					self:SetVisible(true)
					self:FixCamera()
					self.LoadingPanel:SetLoading(false)
				end
			end
			break
		end
	end
end

function PANEL:SetEntity(class_name, mdl_str)
	if (class_name == "worldspawn") then return end

	self:SetTitle(class_name)

	local sent_tbl = scripted_ents.Get(class_name)
	if (sent_tbl ~= nil and sent_tbl.PrintName ~= nil and type(sent_tbl.PrintName) == "string") then
		self.PrintName:SetText(sent_tbl.PrintName)
	else
		local spawnmenu_item = list.Get("SpawnableEntities")[class_name]
		if (spawnmenu_item ~= nil and spawnmenu_item.PrintName ~= nil and type(spawnmenu_item.PrintName) == "string") then
			self.PrintName:SetText(spawnmenu_item.PrintName)
		end
	end
	if (file.Exists("materials/entities/" .. class_name .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. class_name .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	if (mdl_str ~= nil and type(mdl_str) == "string") then
		if (not IsUselessModel(mdl_str)) then
			self.ModelPanel:SetModel(mdl_str)
			self:SetVisible(true)
			self:FixCamera()
			self.LoadingPanel:SetLoading(false)
		end
	elseif (GAS_Logging_EntityDisplay_Cache[class_name]) then
		self.ModelPanel:SetModel(GAS_Logging_EntityDisplay_Cache[class_name])
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)
	else
		local found = false
		for _,ent in ipairs(ents.GetAll()) do
			if (not ent:IsWorld() and ent:GetClass() == class_name) then
				GAS_Logging_EntityDisplay_Cache[class_name] = ent:GetModel()
				self.ModelPanel:SetModel(ent:GetModel())
				self:SetVisible(true)
				self:FixCamera()
				self.LoadingPanel:SetLoading(false)
				found = true
				break
			end
		end
		if (not found) then
			local predefined_model = sent_tbl.model or sent_tbl.Model or sent_tbl.WorldModel
			if (predefined_model ~= nil and not IsUselessModel(predefined_model)) then
				GAS_Logging_EntityDisplay_Cache[class_name] = predefined_model
				self.ModelPanel:SetModel(predefined_model)
				self:SetVisible(true)
				self:FixCamera()
				self.LoadingPanel:SetLoading(false)
				return
			elseif (sent_tbl.Initialize ~= nil and type(sent_tbl.Initialize) == "function") then
				local debug_info = debug.getinfo(sent_tbl.Initialize)
				if (debug_info ~= nil and debug_info.short_src ~= nil) then
					local code
					if (file.Exists(debug_info.short_src, "LUA")) then
						code = file.Read(debug_info.short_src, "LUA")
					elseif (file.Exists(debug_info.short_src, "GAME")) then
						code = file.Read(debug_info.short_src, "GAME")
					end
					if (code ~= nil) then
						local mdl_str = code:match('function ENT:Initialize%(.-%)\n.-self:SetModel%("(.-)"%)[%s%S]-end')
						if (mdl_str ~= nil) then
							if (not IsUselessModel(mdl_str)) then
								GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
								self.ModelPanel:SetModel(mdl_str)
								self:SetVisible(true)
								self:FixCamera()
								self.LoadingPanel:SetLoading(false)
								return
							end
						end
						local relative_path = string.GetPathFromFilename(debug_info.short_src)
						for file_name in code:gmatch('include%("(.-%.lua)"%)') do
							local relative_file = relative_path .. file_name
							local code
							if (file.Exists(relative_file, "LUA")) then
								code = file.Read(relative_file, "LUA")
							elseif (file.Exists(relative_file, "GAME")) then
								code = file.Read(relative_file, "GAME")
							end
							if (code ~= nil) then
								for mdl_str in code:gmatch('self:SetModel%("(.-)"%)') do
									if (not IsUselessModel(mdl_str)) then
										GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
										self.ModelPanel:SetModel(mdl_str)
										self:SetVisible(true)
										self:FixCamera()
										self.LoadingPanel:SetLoading(false)
										return
									end
								end
								local mdl_str = code:match('"([^\n]-%.mdl)"')
								if (mdl_str ~= nil and not IsUselessModel(mdl_str)) then
									GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
									self.ModelPanel:SetModel(mdl_str)
									self:SetVisible(true)
									self:FixCamera()
									self.LoadingPanel:SetLoading(false)
									return
								end
							end
						end
					end
				end
			end

			self:SetVisible(true)
			local net_msg_fire = GAS_Logging_EntityDisplay_Networking[class_name] == nil
			GAS_Logging_EntityDisplay_Networking[class_name] = GAS_Logging_EntityDisplay_Networking[class_name] or {}
			GAS_Logging_EntityDisplay_Networking[class_name][self] = true
			if (net_msg_fire) then
				GAS:netStart("logging:EntityDisplay:SENTModel")
					net.WriteString(class_name)
				net.SendToServer()
			end
		end
	end
end

function PANEL:Init()
	self:InfoInit()
end

local DFRAME_PANEL = table.Copy(PANEL)

function PANEL:SetTitle() end

function DFRAME_PANEL:Init()
	self:SetDrawOnTop(true)

	self:ShowFullscreenButton(false)
	self:ShowPinButton(false)
	self:ShowCloseButton(false)

	self:SetVisible(false)

	self:SetMouseInputEnabled(false)
	self:SetKeyboardInputEnabled(false)
	self:SetSize(250,250)

	self:SetTitle("Entity")

	self:InfoInit()
end

function DFRAME_PANEL:Think()
	if (not system.HasFocus() or not IsValid(self.Creator) or vgui.GetHoveredPanel() ~= self.Creator) then
		self:Close()
		return
	end
	local x,y = gui.MousePos()
	self:SetPos(x + 20, y + 20)
end

function DFRAME_PANEL:SetCreator(creator_pnl)
	self.Creator = creator_pnl
end

function GAS_Logging_DisplayEntity(setup_func, creator, on_hover)
	if (not IsValid(creator)) then return end

	local function display()
		if (IsValid(GAS_Logging_EntityDisplay)) then
			GAS_Logging_EntityDisplay:Close()
		end

		GAS_Logging_EntityDisplay = vgui.Create("GAS.Logging.EntityDisplay")
		GAS_Logging_EntityDisplay:SetCreator(creator)
		setup_func(GAS_Logging_EntityDisplay)

		return GAS_Logging_EntityDisplay
	end

	if (on_hover == true) then
		creator.GAS_Logging_DisplayEntity_OnCursorEntered = creator.GAS_Logging_DisplayEntity_OnCursorEntered or creator.OnCursorEntered
		creator.GAS_Logging_DisplayEntity_OnCursorExited  = creator.GAS_Logging_DisplayEntity_OnCursorExited or creator.OnCursorExited
		function creator:OnCursorEntered(...)
			if (self.GAS_Logging_DisplayEntity_OnCursorEntered) then
				self:GAS_Logging_DisplayEntity_OnCursorEntered(...)
			end

			self.GAS_Logging_EntityDisplay = display()
		end
		function creator:OnCursorExited(...)
			if (self.GAS_Logging_DisplayEntity_OnCursorExited) then
				self:GAS_Logging_DisplayEntity_OnCursorExited(...)
			end

			if (IsValid(self.GAS_Logging_EntityDisplay)) then
				self.GAS_Logging_EntityDisplay:Close()
			end
		end
	else
		return display()
	end
end

GAS:netReceive("logging:EntityDisplay:SENTModel", function()
	local class_name = net.ReadString()
	local success = net.ReadBool()
	if (success) then
		local model = net.ReadString()
		if (GAS_Logging_EntityDisplay_Networking[class_name] ~= nil) then
			for pnl in pairs(GAS_Logging_EntityDisplay_Networking[class_name]) do
				if (not IsValid(pnl)) then continue end
				GAS_Logging_EntityDisplay_Cache[class_name] = model
				pnl.LoadingPanel:SetLoading(false)
				pnl.ModelPanel:SetModel(model)
				pnl:FixCamera()
			end
			GAS_Logging_EntityDisplay_Networking[class_name] = nil
		end
	else
		GAS:PlaySound("error")
		if (GAS_Logging_EntityDisplay_Networking[class_name] ~= nil) then
			for pnl in pairs(GAS_Logging_EntityDisplay_Networking[class_name]) do
				if (not IsValid(pnl)) then continue end
				pnl.LoadingPanel:SetLoading(false)
				pnl.Shruggie:SetVisible(true)
			end
			GAS_Logging_EntityDisplay_Networking[class_name] = nil
		end
	end
end)

derma.DefineControl("GAS.Logging.EntityDisplay", nil, DFRAME_PANEL, "bVGUI.Frame")
derma.DefineControl("GAS.Logging.Entity", nil, PANEL, "bVGUI.BlankPanel")
--lua/vgui/stackercontrolpresets.lua:
return gluapack()()
--lua/vgui/stackercontrolpresets.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:OpenPresetEditor()
--
--]]--
function PANEL:OpenPresetEditor()
	if ( not self.m_strPreset ) then return end
	self.Window = vgui.Create( "StackerPresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self.ConVars )
	self.Window:SetPresetControl( self )
end

vgui.Register( "StackerControlPresets", PANEL, "ControlPresets" )
--gamemodes/darkrp/gamemode/libraries/simplerr.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/libraries/fn.lua:
/*---------------------------------------------------------------------------
Functional library

by FPtje Atheos
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
Function currying
    Take a function with n parameters.
    Currying is the procedure of storing k < n parameters "in the function"
     in such a way that the remaining function can be called with n - k parameters

    Example:
    DebugPrint = fp{print, "[DEBUG]"}
    DebugPrint("TEST")
    > [DEBUG] TEST
---------------------------------------------------------------------------*/
function fp(tbl)
    local func = tbl[1]

    return function(...)
        local fnArgs = {}
        local arg = {...}
        local tblN = table.maxn(tbl)

        for i = 2, tblN do fnArgs[i - 1] = tbl[i] end
        for i = 1, table.maxn(arg) do fnArgs[tblN + i - 1] = arg[i] end

        return func(unpack(fnArgs, 1, table.maxn(fnArgs)))
    end
end

local unpack = unpack
local table = table
local pairs = pairs
local ipairs = ipairs
local error = error
local math = math
local select = select
local type = type
local _G = _G
local fp = fp


module("fn")

/*---------------------------------------------------------------------------
Parameter manipulation
---------------------------------------------------------------------------*/
Id = function(...) return ... end

Flip = function(f)
    if not f then error("not a function") end
    return function(b, a, ...)
        return f(a, b, ...)
    end
end

-- Definition from http://lua-users.org/wiki/CurriedLua
ReverseArgs = function(...)

   --reverse args by building a function to do it, similar to the unpack() example
   local function reverse_h(acc, v, ...)
      if select('#', ...) == 0 then
         return v, acc()
      else
         return reverse_h(function () return v, acc() end, ...)
      end
   end

   -- initial acc is the end of the list
   return reverse_h(function () return end, ...)
end

/*---------------------------------------------------------------------------
Misc functions
---------------------------------------------------------------------------*/
-- function composition
do
    local function comp_h(a, b, ...)
        if b == nil then return a end
        b = comp_h(b, ...)
        return function(...)
            return a(b(...))
        end
    end
    Compose = function(funcs, ...)
        if type(funcs) == "table" then
            return comp_h(unpack(funcs))
        else
            return comp_h(funcs, ...)
        end
    end
end

_G.fc = Compose

-- Definition from http://lua-users.org/wiki/CurriedLua
Curry = function(func, num_args)
    if not num_args then error("Missing argument #2: num_args") end
    if not func then error("Function does not exist!", 2) end
    -- helper
    local function curry_h(argtrace, n)
        if n == 0 then
            -- reverse argument list and call function
            return func(ReverseArgs(argtrace()))
        else
            -- "push" argument (by building a wrapper function) and decrement n
            return function(x)
                return curry_h(function() return x, argtrace() end, n - 1)
            end
        end
   end

   -- no sense currying for 1 arg or less
   if num_args > 1 then
      return curry_h(function() return end, num_args)
   else
      return func
   end
end

-- Thanks Lexic!
Partial = function(func, ...)
    local args = {...}
    return function(...)
        return func(unpack(table.Add( args, {...})))
    end
end

Apply = function(f, ...) return f(...) end

Const = function(a, b) return a end
Until = function(cmp, fn, val)
    if cmp(val) then
        return val
    end
    return Until(cmp, fn, fn(val))
end

Seq = function(f, x) f(x) return x end

GetGlobalVar = function(key) return _G[key] end

/*---------------------------------------------------------------------------
Mathematical operators and functions
---------------------------------------------------------------------------*/
Add = function(a, b) return a + b end
Sub = function(a, b) return a - b end
Mul = function(a, b) return a * b end
Div = function(a, b) return a / b end
Mod = function(a, b) return a % b end
Neg = function(a)    return -a    end

Eq  = function(a, b) return a == b end
Neq = function(a, b) return a ~= b end
Gt  = function(a, b) return a > b  end
Lt  = function(a, b) return a < b  end
Gte = function(a, b) return a >= b end
Lte = function(a, b) return a <= b end

Succ = Compose{Add, 1}
Pred = Compose{Flip(Sub), 1}
Even = Compose{fp{Eq, 0}, fp{Flip(Mod), 2}}
Odd  = Compose{Not, Even}

/*---------------------------------------------------------------------------
Functional logical operators and conditions
---------------------------------------------------------------------------*/
FAnd = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if not val[1] then return unpack(val) end
        end
        if val then return unpack(val) end
    end
end

FOr = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if val[1] then return unpack(val) end
        end
        return false, unpack(val, 2)
    end
end

Not = function(x) return not x end

If = function(f, Then, Else)
    return function(x)
        if f(x) then
            return Then
        else
            return Else
        end
    end
end

/*---------------------------------------------------------------------------
List operations
---------------------------------------------------------------------------*/
Map = function(f, xs)
    for k, v in pairs(xs) do
        xs[k] = f(v)
    end
    return xs
end

Append = function(xs, ys)
    return table.Add(xs, ys)
end

Filter = function(f, xs)
    local res = {}
    for k,v in pairs(xs) do
        if f(v) then res[k] = v end
    end
    return res
end

ForEach = function(f, xs)
    for k,v in pairs(xs) do
        local val = f(k, v)
        if val ~= nil then return val end
    end
end

Head = function(xs)
    return table.GetFirstValue(xs)
end

Last = function(xs)
    return xs[#xs] or table.GetLastValue(xs)
end

Tail = function(xs)
    table.remove(xs, 1)
    return xs
end

Init = function(xs)
    xs[#xs] = nil
    return xs
end

GetValue = function(i, xs)
    return xs[i]
end

Null = function(xs)
    for k, v in pairs(xs) do
        return false
    end
    return true
end

Length = function(xs)
    return #xs
end

Index = function(xs, i)
    return xs[i]
end

Reverse = function(xs)
    local res = {}
    for i = #xs, 1, -1 do
        res[#xs - i + 1] = xs[i]
    end
    return res
end

/*---------------------------------------------------------------------------
Folds
---------------------------------------------------------------------------*/
Foldr = function(func, val, xs)
    for i = #xs, 1, -1 do
        val = func(xs[i], val)
    end

    return val
end

Foldl = function(func, val, xs)
    for k, v in ipairs(xs) do
        val = func(val, v)
    end

    return val
end

And = function(xs)
    for k, v in pairs(xs) do
        if v ~= true then return false end
    end
    return true
end

Or = function(xs)
    for k, v in pairs(xs) do
        if v == true then return true end
    end
    return false
end

Any = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) == true then return true end
    end
    return false
end

All = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) ~= true then return false end
    end
    return true
end

Sum = _G.fp{Foldr, Add, 0}

Product = _G.fp{Foldr, Mul, 1}

Concat = _G.fp{Foldr, Append, {}}

Maximum = _G.fp{Foldl, math.Max, -math.huge}

Minimum = _G.fp{Foldl, math.Min, math.huge}

Snd = _G.fp{select, 2}

Thrd = _G.fp{select, 3}

--gamemodes/darkrp/gamemode/libraries/interfaceloader.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/doorsystem/cl_interface.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/chat/cl_interface.lua:
DarkRP.addChatReceiver = DarkRP.stub{
    name = "addChatReceiver",
    description = "Add a chat command with specific receivers",
    parameters = {
        {
            name = "prefix",
            description = "The chat command itself (\"/pm\", \"/ooc\", \"/me\" are some examples)",
            type = "string",
            optional = false
        },
        {
            name = "text",
            description = "The text that shows up when it says \"Some people can hear you X\"",
            type = "string",
            optional = false
        },
        {
            name = "hearFunc",
            description = "A function(ply, splitText) that decides whether this player can or cannot hear you.",
            type = "function",
            optional = false
        }
    },
    returns = {},
    metatable = DarkRP
}

DarkRP.removeChatReceiver = DarkRP.stub{
    name = "removeChatReceiver",
    description = "Remove a chat command receiver",
    parameters = {
        {
            name = "prefix",
            description = "The chat command itself (\"/pm\", \"/ooc\", \"/me\" are some examples)",
            type = "string",
            optional = false
        }
    },
    returns = {},
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "chatHideRecipient",
    description = "Hide a receipent from who can hear/see your text GUI.",
    parameters = {
        {
            name = "ply",
            description = "The player who spoke.",
            type = "Player"
        }
    },
    returns = {

    }
}

--addons/darkrpmodification/lua/darkrp_config/settings.lua:
--[[-------------------------------------------------------------------------
DarkRP config settings.
-----------------------------------------------------------------------------

This is the settings file of DarkRskeypaP. Every DarkRP setting is listed here.

Warning:
If this file is missing settings (because of e.g. an update), DarkRP will assume default values for these settings.
You need not worry about updating this file. If a new setting is added you can manually add them to this file.
---------------------------------------------------------------------------]]


--[[
Toggle settings.
Set to true or false.
]]

-- voice3D - Enable/disable 3DVoice is enabled.
GM.Config.voice3D                       = true
-- AdminsCopWeapons - Enable/disable admins spawning with cop weapons.
GM.Config.AdminsCopWeapons              = true
-- adminBypassJobCustomCheck - Enable/disable whether an admin can force set a job with whenever customCheck returns false.
GM.Config.adminBypassJobRestrictions    = true
-- Acts/Taunts - Enable/disable Taunts (e.g. act salute)
GM.Config.allowActs                     = false
-- allow people getting their own custom jobs.
GM.Config.allowjobswitch                = true
-- allowrpnames - Allow Players to Set their RP names using the /rpname command.
GM.Config.allowrpnames                  = true
-- allowsprays - Enable/disable the use of sprays on the server.
GM.Config.allowsprays                   = false
-- allowvehicleowning - Enable/disable whether people can own vehicles.
GM.Config.allowvehicleowning            = true
-- allowvnocollide - Enable/disable the ability to no-collide a vehicle (for security).
GM.Config.allowvnocollide               = false
-- alltalk - Enable for global chat, disable for local chat.
GM.Config.alltalk                       = false
-- antimultirun - Disallow people joining your server(s) twice on the same account.
GM.Config.antimultirun                  = true
-- autovehiclelock - Enable/Disable automatic locking of a vehicle when a player exits it.
GM.Config.autovehiclelock               = false
-- babygod - people spawn godded (prevent spawn killing).
GM.Config.babygod                       = true
-- canforcedooropen - whether players can force an unownable door open with lockpick or battering ram or w/e.
GM.Config.canforcedooropen              = true
-- chatsounds - sounds are played when some things are said in chat.
GM.Config.chatsounds                    = true
-- chiefjailpos - Allow the Chief to set the jail positions.
GM.Config.chiefjailpos                  = true
-- cit_propertytax - Enable/disable property tax that is exclusive only for citizens.
GM.Config.cit_propertytax               = false
-- copscanunfreeze - Enable/disable the ability of cops to unfreeze other people's props.
GM.Config.copscanunfreeze               = false
-- copscanunweld - Enable/disable the ability of cops to unweld other people's props.
GM.Config.copscanunweld                 = false
-- cpcanarrestcp - Allow/Disallow CPs to arrest other CPs.
GM.Config.cpcanarrestcp                 = true
-- currencyLeft - The position of the currency symbol. true for left, false for right.
GM.Config.currencyLeft                  = true
-- customjobs - Enable/disable the /job command (personalized job names).
GM.Config.customjobs                    = true
-- customspawns - Enable/disable whether custom spawns should be used.
GM.Config.customspawns                  = true
-- deathblack - Whether or not a player sees black on death.
GM.Config.deathblack                    = false
-- showdeaths - Display kill information in the upper right corner of everyone's screen.
GM.Config.showdeaths                    = true
-- deadtalk - Enable/disable whether people talk and use commands while dead.
GM.Config.deadtalk                      = false
-- deadvoice - Enable/disable whether people talk through the microphone while dead.
GM.Config.deadvoice                     = false
-- deathpov - Enable/disable whether people see their death in first person view.
GM.Config.deathpov                      = false
-- decalcleaner - Enable/Disable clearing every player's decals.
GM.Config.decalcleaner                  = false
-- disallowClientsideScripts - Clientside scripts can be very useful for customizing the HUD or to aid in building. This option bans those scripts.
GM.Config.disallowClientsideScripts     = false
-- doorwarrants - Enable/disable Warrant requirement to enter property.
GM.Config.doorwarrants                  = true
-- dropmoneyondeath - Enable/disable whether people drop money on death.
GM.Config.dropmoneyondeath              = false
-- droppocketarrest - Enable/disable whether people drop the stuff in their pockets when they get arrested.
GM.Config.droppocketarrest              = false
-- droppocketdeath - Enable/disable whether people drop the stuff in their pockets when they die.
GM.Config.droppocketdeath               = true
-- dropweapondeath - Enable/disable whether people drop their current weapon when they die.
GM.Config.dropweapondeath               = false
-- Whether players can drop the weapons they spawn with.
GM.Config.dropspawnedweapons            = false
-- dynamicvoice - Enable/disable whether only people in the same room as you can hear your mic.
GM.Config.dynamicvoice                  = true
-- earthquakes - Enable/disable earthquakes.
GM.Config.earthquakes                   = false
-- enablebuypistol - Turn /buy on of off.
GM.Config.enablebuypistol               = true
-- enforceplayermodel - Whether or not to force players to use their role-defined character models.
GM.Config.enforceplayermodel            = true
-- globalshow - Whether or not to display player info above players' heads in-game.
GM.Config.globalshow                    = false
-- ironshoot - Enable/disable whether people need iron sights to shoot.
GM.Config.ironshoot                     = true
-- showjob - Whether or not to display a player's job above their head in-game.
GM.Config.showjob                       = true
-- letters - Enable/disable letter writing / typing.
GM.Config.letters                       = true
-- license - Enable/disable People need a license to be able to pick up guns.
GM.Config.license                       = false
-- lockdown - Enable/Disable initiating lockdowns for mayors.
GM.Config.lockdown                      = true
-- lockpickfading - Enable/disable the lockpicking of fading doors.
GM.Config.lockpickfading                = true
-- logging - Enable/disable logging everything that happens.
GM.Config.logging                       = true
-- lottery - Enable/disable creating lotteries for mayors.
GM.Config.lottery                       = true
-- showname - Whether or not to display a player's name above their head in-game.
GM.Config.showname                      = true
-- showhealth - Whether or not to display a player's health above their head in-game.
GM.Config.showhealth                    = true
-- needwantedforarrest - Enable/disable Cops can only arrest wanted people.
GM.Config.needwantedforarrest           = false
-- noguns - Enabling this feature bans Guns and Gun Dealers.
GM.Config.noguns                        = false
-- norespawn - Enable/Disable that people don't have to respawn when they change job.
GM.Config.norespawn                     = false
-- instantjob - Enable/Disable instantly respawning when norespawn is false
GM.Config.instantjob                    = false
-- npcarrest - Enable/disable arresting npc's.
GM.Config.npcarrest                     = true
-- ooc - Whether or not OOC tags are enabled.
GM.Config.ooc                           = true
-- propertytax - Enable/disable property tax.
GM.Config.propertytax                   = false
-- proppaying - Whether or not players should pay for spawning props.
GM.Config.proppaying                    = false
-- propspawning - Enable/disable props spawning. Applies to admins too.
GM.Config.propspawning                  = true
-- removeclassitems - Enable/disable shipments/microwaves/etc. removal when someone changes team.
GM.Config.removeclassitems              = true
-- removeondisconnect - Enable/disable shipments/microwaves/etc. removal when someone disconnects.
GM.Config.removeondisconnect            = true
-- respawninjail - Enable/disable whether people can respawn in jail when they die.
GM.Config.respawninjail                 = true
-- restrictallteams - Enable/disable Players can only be citizen until an admin allows them.
GM.Config.restrictallteams              = false
-- restrictbuypistol - Enabling this feature makes /buy available only to Gun Dealers.
GM.Config.restrictbuypistol             = false
-- restrictdrop - Enable/disable restricting the weapons players can drop. Setting this to true disallows weapons from shipments from being dropped.
GM.Config.restrictdrop                  = false
-- revokeLicenseOnJobChange - Whether licenses are revoked when a player changes jobs.
GM.Config.revokeLicenseOnJobChange      = true
-- shouldResetLaws - Enable/Disable resetting the laws back to the default law set when the mayor changes.
GM.Config.shouldResetLaws               = false
-- strictsuicide - Whether or not players should spawn where they suicided.
GM.Config.strictsuicide                 = false
-- telefromjail - Enable/disable teleporting from jail.
GM.Config.telefromjail                  = true
-- teletojail - Enable/disable teleporting to jail.
GM.Config.teletojail                    = true
-- unlockdoorsonstart - Enable/Disable unlocking all doors on map start.
GM.Config.unlockdoorsonstart            = false
-- voiceradius - Enable/disable local voice chat.
GM.Config.voiceradius                   = true
-- tax - Whether players pay taxes on their wallets.
GM.Config.wallettax                     = false
-- wantedrespawn - Whether players remain wanted on respawn.
GM.Config.wantedrespawn                 = false
-- wantedsuicide - Enable/Disable suiciding while you are wanted by the police.
GM.Config.wantedsuicide                 = false
-- realisticfalldamage - Enable/Disable dynamic fall damage. Setting mp_falldamage to 1 will over-ride this.
GM.Config.realisticfalldamage           = true
-- printeroverheat - Whether the default money printer can overheat on its own.
GM.Config.printeroverheat               = true
-- weaponCheckerHideDefault - Hide default weapons when checking weapons.
GM.Config.weaponCheckerHideDefault      = true
-- weaponCheckerHideNoLicense - Hide weapons that do not require a license.
GM.Config.weaponCheckerHideNoLicense    = false

--[[
Value settings
]]
-- adminnpcs - Whether or not NPCs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminnpcs                     = 3
-- adminsents - Whether or not SENTs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminsents                    = 1
-- adminvehicles - Whether or not vehicles should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminvehicles                 = 0
-- adminweapons - Who can spawn weapons: 0: admins only, 1: supadmins only, 2: no one, 3: everyone
GM.Config.adminweapons                  = 1
-- arrestspeed - Sets the max arrest speed.
GM.Config.arrestspeed                   = 120
-- babygodtime - How long the babygod lasts.
GM.Config.babygodtime                   = 5
-- chatsoundsdelay - How long to wait before letting a player emit a sound from their chat again.
-- Leave this on at least a few seconds to prevent people from spamming sounds. Set to 0 to disable.
GM.Config.chatsoundsdelay               = 5
-- deathfee - the amount of money someone drops when dead.
GM.Config.deathfee                      = 1000
-- decaltimer - Sets the time to clear clientside decals (in seconds).
GM.Config.decaltimer                    = 120
-- demotetime - Number of seconds before a player can rejoin a team after demotion from that team.
GM.Config.demotetime                    = 120
-- doorcost - Sets the cost of a door.
GM.Config.doorcost                      = 60
-- entremovedelay - how long to wait before removing a bought entity after disconnect.
GM.Config.entremovedelay                = 0
-- gunlabweapon - The weapon that the gunlab spawns.
GM.Config.gunlabweapon                  = "weapon_p2282"
-- jailtimer - Sets the jailtimer (in seconds).
GM.Config.jailtimer                     = 300
-- lockdowndelay - The amount of time a mayor must wait before starting the next lockdown.
GM.Config.lockdowndelay                 = 1800
-- maxadvertbillboards - The maximum number of /advert billboards a player can place.
GM.Config.maxadvertbillboards           = 0
-- maxCheques - The maximum number of cheques someone can write
GM.Config.maxCheques                    = 5
-- maxdoors - Sets the max amount of doors one can own.
GM.Config.maxdoors                      = 20
-- maxdrugs - Sets max drugs.
GM.Config.maxdrugs                      = 2
-- maxfoods - Sets the max food cartons per Microwave owner.
GM.Config.maxfoods                      = 2
-- maxfooditems - Sets the max amount of food items a player can buy from the F4 menu.
GM.Config.maxfooditems                  = 20
-- maxlawboards - The maximum number of law boards the mayor can place.
GM.Config.maxlawboards                  = 2
-- maxletters - Sets max letters.
GM.Config.maxletters                    = 10
-- maxlotterycost - Maximum payment the mayor can set to join a lottery.
GM.Config.maxlotterycost                = 250
-- maxvehicles - Sets how many vehicles one can buy.
GM.Config.maxvehicles                   = 5
-- microwavefoodcost - Sets the sale price of Microwave Food.
GM.Config.microwavefoodcost             = 30
-- minlotterycost - Minimum payment the mayor can set to join a lottery.
GM.Config.minlotterycost                = 30
-- Money packets will get removed if they don't get picked up after a while. Set to 0 to disable.
GM.Config.moneyRemoveTime               = 600
-- mprintamount - Value of the money printed by the money printer.
GM.Config.mprintamount                  = 250
-- normalsalary - Sets the starting salary for newly joined players.
GM.Config.normalsalary                  = 45
-- npckillpay - Sets the money given for each NPC kill.
GM.Config.npckillpay                    = 10
-- paydelay - Sets how long it takes before people get salary.
GM.Config.paydelay                      = 250
-- pocketitems - Sets the amount of objects the pocket can carry.
GM.Config.pocketitems                   = 5
-- pricecap - The maximum price of items (using /price).
GM.Config.pricecap                      = 500
-- pricemin - The minimum price of items (using /price).
GM.Config.pricemin                      = 50
-- propcost - How much prop spawning should cost (prop paying must be enabled for this to have an effect).
GM.Config.propcost                      = 10
-- quakechance - Chance of an earthquake happening.
GM.Config.quakechance                   = 4000
-- respawntime - Minimum amount of seconds a player has to wait before respawning.
GM.Config.respawntime                   = 1
-- changejobtime - Minimum amount of seconds a player has to wait before changing job.
GM.Config.changejobtime                 = 10
-- runspeed - Sets the max running speed.
GM.Config.runspeed                      = 240
-- runspeed - Sets the max running speed for CP teams.
GM.Config.runspeedcp                    = 255
-- searchtime - Number of seconds for which a search warrant is valid.
GM.Config.searchtime                    = 300
-- ShipmentSpawnTime - Antispam time between spawning shipments.
GM.Config.ShipmentSpamTime              = 3
-- shipmenttime - The number of seconds it takes for a shipment to spawn.
GM.Config.shipmentspawntime             = 10
-- startinghealth - the health when you spawn.
GM.Config.startinghealth                = 100
-- startingmoney - your wallet when you join for the first time.
GM.Config.startingmoney                 = 50000
-- stunstickdamage - amount of damage the stunstick will do to entities.
-- When between 0 and 1, the damage is relative, where 1 takes the entire health of the entity.
-- When above 1, the damage is absolute
GM.Config.stunstickdamage               = 1000
-- vehiclecost - Sets the cost of a vehicle (To own it).
GM.Config.vehiclecost                   = 40
-- wallettaxmax - Maximum percentage of tax to be paid.
GM.Config.wallettaxmax                  = 5
-- wallettaxmin - Minimum percentage of tax to be paid.
GM.Config.wallettaxmin                  = 1
-- wallettaxtime - Time in seconds between taxing players. Requires server restart.
GM.Config.wallettaxtime                 = 600
-- wantedtime - Number of seconds for which a player is wanted for.
GM.Config.wantedtime                    = 1200
-- walkspeed - Sets the max walking speed.
GM.Config.walkspeed                     = 160
-- falldamagedamper - The damper on realistic fall damage. Default is 15. Decrease this for more damage.
GM.Config.falldamagedamper              = 15
-- falldamageamount - The base damage taken from falling for static fall damage. Default is 10.
GM.Config.falldamageamount              = 10
-- printeroverheatchance - The likelyhood of a printer overheating. The higher this number, the less likely (minimum 3, default 22).
GM.Config.printeroverheatchance         = 22
-- printerreward - Reward for destroying a money printer.
GM.Config.printerreward                 = 950

--[[---------------------------------------------------------------------------
Chat distance settings
Distance is in source units (similar to inches)
---------------------------------------------------------------------------]]
GM.Config.talkDistance    = 250
GM.Config.whisperDistance = 90
GM.Config.yellDistance    = 550
GM.Config.meDistance      = 250
GM.Config.voiceDistance   = 550

--[[---------------------------------------------------------------------------
Other settings
---------------------------------------------------------------------------]]

-- The classname of money packets. Use this to create your own money entity!
-- Note: the money packet must support the "Setamount" method (or the amount DTVar).
GM.Config.MoneyClass = "spawned_money"
-- In case you do wish to keep the default money, but change the model, this option is the way to go:
GM.Config.moneyModel = "models/props/cs_assault/money.mdl"
-- You can set your own, custom sound to be played for all players whenever a lockdown is initiated.
-- Note: Remember to include the folder where the sound file is located.npc/overwatch/cityvoice/f_confirmcivilstatus_1_spkr.wav
GM.Config.lockdownsound = "npc/overwatch/cityvoice/f_confirmcivilstatus_1_spkr.wav" //

-- The skin DarkRP uses. Set to "default" to use the GMod default derma theme.
GM.Config.DarkRPSkin = "DarkRP"
GM.Config.currency = "₺"
GM.Config.chatCommandPrefix = "/"
GM.Config.F1MenuHelpPage = "https://darkrp.miraheze.org/wiki/Main_Page"
GM.Config.F1MenuHelpPageTitle = "DarkRP Wiki"

-- The sound that plays when you get a DarkRP notification
GM.Config.notificationSound = "buttons/lightswitch2.wav"

-- Put Steam ID's and ranks in this list, and the players will have that rank when they join.
GM.Config.DefaultPlayerGroups = {
    ["STEAM_0:0:193476148"] = "superadmin",
}

-- Custom modules in this addon that are disabled.
GM.Config.DisabledCustomModules = {
       ["hudreplacement"] = false,
       ["extraf4tab"] = false,
}

-- The list of weapons that players are not allowed to drop. Items set to true are not allowed to be dropped.
GM.Config.DisallowDrop = {
    ["arrest_stick"] = true,
    ["door_ram"] = true,
    ["gmod_camera"] = true,
    ["gmod_tool"] = true,
    ["keys"] = true,
    ["lockpick"] = true,
    ["med_kit"] = true,
    ["glorifiedhandcuffs_handcuffs"] = true,
    ["pocket"] = true,
    ["stunstick"] = true,
    ["unarrest_stick"] = true,
    ["weapon_keypadchecker"] = true,
    ["weapon_physcannon"] = true,
    ["weapon_physgun"] = true,
    ["weaponchecker"] = true,
}

-- The list of weapons people spawn with.
GM.Config.DefaultWeapons = {
    "keys",
    "weapon_fists",
    "aphone",
    "inventory",
    "weapon_physcannon",
    "gmod_tool",
    "weapon_physgun",
    "weapon_ch_atm_card",
    "pocket"
}

-- Override categories.
-- NOTE: categories are to be set in the "category" field of the custom jobs/shipments/entities/ammo/pistols/vehicles.
-- Use this only to override the categories of _default_ things.
-- This will NOT work for your own custom stuff.
-- Make sure the category is created in the darkrp_customthings/categories.lua, otherwise it won't work!
GM.Config.CategoryOverride = {
    jobs = {
        ["Citizen"]                             = "Vatandas",
        ["Hobo"]                                = "Vatandas",
        ["Gun Dealer"]                          = "Vatandas",
        ["Medic"]                               = "Vatandas",
        ["Civil Protection"]                    = "Devlet Görevlisi",
        ["Gangster"]                            = "İllegal",
        ["Mob boss"]                            = "İllegal",
        ["Civil Protection Chief"]              = "Devlet Görevlisi",
        ["Mayor"]                               = "Devlet Görevlisi",
    },
    entities = {
        ["Drug lab"]                            = "Other",
        ["Money printer"]                       = "Other",
        ["Gun lab"]                             = "Other",

    },
    shipments = {
        ["AK47"]                                = "Rifles",
        ["MP5"]                                 = "Rifles",
        ["M4"]                                  = "Rifles",
        ["Mac 10"]                              = "Other",
        ["Pump shotgun"]                        = "Shotguns",
        ["Sniper rifle"]                        = "Snipers",

    },
    weapons = {
        ["Desert eagle"]                        = "Pistols",
        ["Fiveseven"]                           = "Pistols",
        ["Glock"]                               = "Pistols",
        ["P228"]                                = "Pistols",
    },
    vehicles = {}, -- There are no default vehicles.
    ammo = {
        ["Pistol ammo"]                         = "Other",
        ["Shotgun ammo"]                        = "Other",
        ["Rifle ammo"]                          = "Other",
    },
}

-- The list of weapons admins spawn with, in addition to the default weapons, a job's weapons and GM.Config.AdminsCopWeapons.
GM.Config.AdminWeapons = {
    "weapon_keypadchecker",
}

-- These are the default laws, they're unchangeable in-game.
GM.Config.DefaultLaws = {
    "Nefsi müdafaa dışında başka vatandaşlara saldırmayın.",
    "Çalmayın veya insanların evlerine girmeyin.",
    "Printer ve uyuşturucular yasa dışıdır.",
}

GM.Config.PocketBlacklist = {
    ["zrms_ore"] = true,
    ["ch_mayor_desk"] = true,
    ["s_keypad"] = true,
    ["pilav_stand"] = true,
    ["stone_oven"] = true,
    ["bufe"] = true,
    ["ice_stand"] = true,
    ["kofte_stand"] = true,
    ["item_suitcharger"] = true,
    ["item_healthcharger"] = true,
    ["realistic_police_computer"] = true,
    ["glorifiedbanking_atm"] = true,
    ["zmlab2_dropoff"] = true,
    ["ztm_trashburner"] = true,
    ["ztm_buyermachine"] = true,
    ["ztm_leafpile"] = true,
    ["ztm_manhole"] = true,
    ["zmlab2_tent_door"] = true,
    ["fadmin_jail"] = true,
    ["meteor"] = true,
    ["door"] = true,
    ["func_"] = true,
    ["player"] = true,
    ["beam"] = true,
    ["worldspawn"] = true,
    ["env_"] = true,
    ["path_"] = true,
    ["prop_physics"] = true,
    ["money_printer"] = true,
    ["gunlab"] = true,
    ["prop_dynamic"] = true,
    ["prop_vehicle_prisoner_pod"] = true,
    ["keypad_wire"] = true,
    ["gmod_button"] = true,
    ["gmod_rtcameraprop"] = true,
    ["gmod_cameraprop"] = true,
    ["gmod_dynamite"] = true,
    ["gmod_thruster"] = true,
    ["gmod_light"] = true,
    ["gmod_lamp"] = true,
    ["gmod_emitter"] = true,
    ["awl_computer"] = true,
    ["ch_atm"] = true,
    ["ch_atm_card_scanner"] = true,
    ["ch_cryptocurrencies_exchange_rates"] = true,
    ["realistic_police_camera"] = true,
    ["ice-stand"] = true,
    ["bm2_extra_fuel_tank"] = true,
    ["zmlab2_machine_filler"] = true,
    ["zmlab2_machine_filter"] = true,
    ["zmlab2_machine_frezzer"] = true,
    ["zmlab2_machine_furnace"] = true,
    ["zmlab2_item_frezzertray"] = true,
    ["zmlab2_machine_mixer"] = true,
    ["zmlab2_item_palette"] = true,
    ["zmlab2_storage"] = true,
    ["zmlab2_table"] = true,
    ["zmlab2_machine_ventilation"] = true,
    ["zmlab2_equipment"] = true,
    ["zmlab2_item_autobreaker"] = true,
    ["keypad"] = true,
    ["f_amethyst_printer"] = true,
    ["f_topaz_printer"] = true,
    ["f_emerald_printer"] = true,
    ["f_ruby_printer"] = true,
    ["f_sapphire_printer"] = true,
    ["f_vip_printer"] = true,
    ["realistic_police_camera"] = true,
    ["realistic_police_screen"] = true,
    ["f_topaz_printer"] = true,
    ["oneprint"] = true,
    ["zgw_bucket"] = true,
    ["zgw_bucket_follow"] = true,
    ["zgw_lantern"] = true,
    ["zgw_goldwasher"] = true,
    ["zwf_autopacker"] = true,
    ["zwf_packingstation"] = true,
    ["zwf_doobytable"] = true,
    ["zwf_drystation"] = true,
    ["zwf_pot"] = true,
    ["zwf_generator"] = true,
    ["zwf_pot_hydro"] = true,
    ["zwf_lamp"] = true,
    ["zwf_mixer"] = true,
    ["zwf_outlet"] = true,
    ["zwf_oven"] = true,
	["gmod_sent_vehicle_fphysics_gaspump_diesel"] = true,
	["gmod_sent_vehicle_fphysics_gaspump_electric"] = true,
	["gmod_sent_vehicle_fphysics_gaspump"] = true,
	["zwf_muffinmix"] = true,
	["zld_bar_counter"] = true,
	["zld_machine_stagelight01"] = true,
	["zld_machine_speaker04"] = true,
	["zld_machine_speaker03"] = true,
	["zld_machine_speaker02"] = true,
	["zld_machine_speaker01"] = true,
	["zld_scafold_09"] = true,
	["zld_scafold_08"] = true,
	["zld_scafold_07"] = true,
	["zld_scafold_06"] = true,
	["zld_scafold_05"] = true,
	["zld_scafold_04"] = true,
	["zld_scafold_03"] = true,
	["zld_scafold_02"] = true,
	["zld_scafold_01"] = true,
	["zld_controller"] = true,
	["zld_machine_fogmachine01"] = true,
	["zld_machine_fluorescenttube02"] = true,
	["zld_machine_fluorescenttube01"] = true,
	["zld_machine_effectmaker01"] = true,
	["zld_machine_displayscreen03"] = true,
	["zld_machine_displayscreen02"] = true,
	["zld_machine_displayscreen01"] = true,
	["zld_machine_displayscreen07"] = true,
	["zld_machine_displayscreen14"] = true,
	["zld_machine_displayscreen15"] = true,
	["zld_machine_displayscreen06"] = true,
	["zld_machine_displayscreen13"] = true,
	["zld_machine_displayscreen12"] = true,
	["zld_machine_displayscreen05"] = true,
	["zld_machine_displayscreen10"] = true,
	["zld_machine_displayscreen11"] = true,
	["zld_machine_displayscreen04"] = true,
	["zld_machine_displayscreen09"] = true,
	["zld_machine_displayscreen08"] = true,
    ["bricks_server_bank_vault"] = true,
	["zld_bar_mixer"] = true,
	["zld_bar_counter"] = true,
	["zmlab2_tent"] = true,
        ["gmod_sent_vehicle_fphysics_gaspump_diesel"] = true,
        ["gmod_sent_vehicle_fphysics_gaspump_electric"] = true,
        ["gmod_sent_vehicle_fphysics_gaspump"] = true,
        ["wheel_of_luck"] = true,
    ["ent_jack_job_weedbag"] = false,
    ["gmod_sent_vehicle_fphysics_wheel"] = true,
    ["trash_trashcan"] = true,
    ["bens_dumpster"] = true,
    ["logomuz"] = true,
    ["mcasino_kiosk"] = true,
    ["bricks_server_armory"] = true,
    ["bodyman_closet"] = true,
    ["hacktool_server"] = true,
    ["ch_christmas_tree"] = true
    
}

-- These weapons are classed as 'legal' in the weapon checker and are not stripped when confiscating weapons.
-- This setting is used IN ADDITION to GM.Config.weaponCheckerHideDefault and GM.Config.weaponCheckerHideNoLicense.
-- You should use the former if you want to class the default weapons (GM.Config.DefaultWeapons and, if admin, GM.Config.AdminWeapons) and a player's job weapons as legal.
-- The latter takes GM.NoLicense weapons as legal (see licenseweapons.lua).
-- The format of this config is similar to GM.Config.DisallowDrop.
GM.Config.noStripWeapons = {

}

-- The entities listed here will not be removed when a player changes their job.
-- This only applies when removeclassitems is set to true.
-- Note: entities will only be removed when the player changes to a job that is not allowed to have the entity.
GM.Config.preventClassItemRemoval = {
    ["gunlab"] = false,
    ["microwave"] = false,
    ["spawned_shipment"] = false,
}

-- Properties set to true are allowed to be used. Values set to false or are missing from this list are blocked.
GM.Config.allowedProperties = {
    remover = true,
    ignite = false,
    extinguish = true,
    keepupright = true,
    gravity = true,
    collision = true,
    skin = true,
    bodygroups = true,
}

--[[---------------------------------------------------------------------------
F4 menu
---------------------------------------------------------------------------]]
-- hide the items that you can't buy and the jobs you can't get (instead of graying them out).
-- this option hides items when you don't have enough money, when the maximum is reached for a job or any other reason.
GM.Config.hideNonBuyable = false

-- Hide only the items that you have the wrong job for (or for which the customCheck says no).
-- When you set this option to true and hideNonBuyable to false, you WILL see e.g. items that are too expensive for you to buy.
-- but you won't see gundealer shipments when you have the citizen job.
GM.Config.hideTeamUnbuyable = true

--[[---------------------------------------------------------------------------
AFK module
---------------------------------------------------------------------------]]
-- The time of inactivity before being demoted.
GM.Config.afkdemotetime = 600
-- Prevent people from spamming AFK.
GM.Config.AFKDelay = 300

--[[---------------------------------------------------------------------------
Hitmenu module
---------------------------------------------------------------------------]]
-- The minimum price for a hit.
GM.Config.minHitPrice = 2000
-- The maximum price for a hit.
GM.Config.maxHitPrice = 500000
-- The minimum distance between a hitman and his customer when they make the deal.
GM.Config.minHitDistance = 150
-- The text that tells the player he can press use on the hitman to request a hit.
GM.Config.hudText = "I am a hitman.\nPress E on me to request a hit!"
-- The text above a hitman when he's got a hit.
GM.Config.hitmanText = "Hit\naccepted!"
-- The cooldown time for a hit target (so they aren't spam killed).
GM.Config.hitTargetCooldown = 120
-- How long a customer has to wait to be able to buy another hit (from the moment the hit is accepted).
GM.Config.hitCustomerCooldown = 240

--[[---------------------------------------------------------------------------
Hungermod module
---------------------------------------------------------------------------]]
-- hungerspeed <Amount> - Set the rate at which players will become hungry (2 is the default).
GM.Config.hungerspeed = 1
-- starverate <Amount> - How much health that is taken away every second the player is starving  (3 is the default).
GM.Config.starverate = 3

--gamemodes/darkrp/gamemode/modules/tipjar/cl_model.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/tipjar/cl_frame.lua:
local updateModel, getModelValue, onModelUpdate =
    DarkRP.tipJarUIModel.updateModel,
    DarkRP.tipJarUIModel.getModelValue,
    DarkRP.tipJarUIModel.onModelUpdate


--[[-------------------------------------------------------------------------
Donation amount entry
---------------------------------------------------------------------------]]
local DONATE_ENTRY = {}

function DONATE_ENTRY:Init()
    self.BaseClass.Init(self)

    self:SetNumeric(true)
    self:SetSize(290, 70)
    self:SetFont("HUDNumber5")
    self:SetText("")

    onModelUpdate("amount", function(new, _, src)
        if not IsValid(self) or src == self then return end

        local pos = self:GetCaretPos()
        self:SetText(new)
        self:SetCaretPos(math.min(pos, string.len(new)))
    end)

    onModelUpdate("lastTipAmount", function()
        self:SelectAllText()
        self:RequestFocus()
    end)
end

function DONATE_ENTRY:CheckNumeric(value)
    if DarkRP.toInt(value) then return false end

    return true
end

function DONATE_ENTRY:OnChange()
    local value = DarkRP.toInt(self:GetText())

    if not value then return end

    updateModel("amount", value, self)
end

function DONATE_ENTRY:OnEnter()
    updateModel("frameVisible", false)
    updateModel("lastTipAmount", getModelValue("amount"))
end

derma.DefineControl("DarkRP_TipJar_DONATE_ENTRY", "", DONATE_ENTRY, "DTextEntry")

local DONATE_BUTTON = {}

function DONATE_BUTTON:Init()
    self.BaseClass.Init(self)

    self:SetSize(290, 80)
    self:SetText("")

    self.donateLabel = vgui.Create("DLabel", self)
    self.donateLabel:SetFont("HUDNumber5")
    self.donateLabel:SetText(DarkRP.getPhrase("Donate"))
    self.donateLabel:SizeToContents()
    self.donateLabel:SetPos(50, 10)
    self.donateLabel:CenterHorizontal()

    self.amountLabel = vgui.Create("DLabel", self)
    self.amountLabel:SetFont("HUDNumber5")
    self.amountLabel:SetPos(50, 40)

    onModelUpdate("amount", function(new)
        if not IsValid(self) then return end

        self.amountLabel:SetText(DarkRP.formatMoney(new))
        self.amountLabel:SizeToContents()
        self.amountLabel:CenterHorizontal()
    end)
end

function DONATE_BUTTON:DoClick()
    -- updateModel("frameVisible", false)
    updateModel("lastTipAmount", getModelValue("amount"))
end

derma.DefineControl("DarkRP_TipJar_DONATE_BUTTON", "", DONATE_BUTTON, "DButton")


local DONATE_LIST_ITEM = {}

function DONATE_LIST_ITEM:Init()
    self:SetSize(470, 25)
    self:SetPaintBackground(false)

    self.textL = vgui.Create("DLabel", self)
    self.textL:SetFont("DarkRPHUD2")
    self.textL:Dock(LEFT)

    self.textR = vgui.Create("DLabel", self)
    self.textR:SetFont("DarkRPHUD2")
    self.textR:DockMargin(5, 5, 20, 5)
    self.textR:Dock(RIGHT)

    self.donatedColor = Color(50, 130, 50)
    self.activeColor = Color(180, 180, 180)
    self.moneyColor = Color(50, 130, 50)
end

function DONATE_LIST_ITEM:SetActive(name, amount)
    self.textL:SetText(name)
    self.textL:SetTextColor(self.activeColor)
    self.textL:SizeToContents()

    self.textR:SetText(amount)
    self.textR:SetTextColor(self.activeColor)
    self.textR:SizeToContents()
end

function DONATE_LIST_ITEM:SetDonated(name, amount)
    self.textL:SetText(name)
    self.textL:SetTextColor(self.donatedColor)
    self.textL:SizeToContents()

    self.textR:SetText(amount)
    self.textR:SetTextColor(self.moneyColor)
    self.textR:SizeToContents()
end

derma.DefineControl("DarkRP_TipJar_DONATE_LIST_ITEM", "", DONATE_LIST_ITEM, "DPanel")


local DONATE_LIST = {}

function DONATE_LIST:Init()
    self.activeLines = {}
    self.donatedLines = {}

    self:SetSize(480, 465)

    self:SetBackgroundColor(color_transparent)
    self:EnableVerticalScrollbar()
    self:SetSpacing(10)
    self.VBar.Paint = fn.Id
    self.VBar.btnUp.Paint = fn.Id
    self.VBar.btnDown.Paint = fn.Id


    onModelUpdate("activeDonationUpdate", function()
        local tipjar = getModelValue("tipjar")

        if not IsValid(self) then return end
        if not IsValid(tipjar) then return end

        self:RebuildLines(tipjar)
    end)

    onModelUpdate("donatedUpdate", function()
        local tipjar = getModelValue("tipjar")

        if not IsValid(self) then return end
        if not IsValid(tipjar) then return end

        self:RebuildLines(tipjar)

        self:PerformLayout()
        self.VBar:SetScroll(math.huge)
    end)
end

function DONATE_LIST:AddActiveLine(name, amount)
    local line = vgui.Create("DarkRP_TipJar_DONATE_LIST_ITEM", self)
    line:SetActive(name, amount)
    self:AddItem(line)

    table.insert(self.activeLines, line)
end

function DONATE_LIST:AddDonatedLine(name, amount)
    local line = vgui.Create("DarkRP_TipJar_DONATE_LIST_ITEM", self)
    line:SetDonated(name, amount)
    self:AddItem(line)

    table.insert(self.donatedLines, line)
end

function DONATE_LIST:ClearLines()
    for _, line in ipairs(self.activeLines) do
        line:Remove()
    end

    for _, line in ipairs(self.donatedLines) do
        line:Remove()
    end

    table.Empty(self.activeLines)
    table.Empty(self.donatedLines)
end

function DONATE_LIST:RebuildLines(tipjar)
    self:ClearLines()

    for _, donation in ipairs(tipjar.madeDonations) do
        self:AddDonatedLine(donation.name, DarkRP.formatMoney(donation.amount))
    end

    for ply, amount in pairs(tipjar.activeDonations) do
        -- Don't show the owner looking at this page
        if ply == tipjar:Getowning_ent() then continue end

        self.activeLines[ply:Nick()] = DarkRP.formatMoney(amount)
    end

    for name, amount in SortedPairs(self.activeLines) do
        self:AddActiveLine(name, amount)
    end
end

derma.DefineControl("DarkRP_TipJar_DONATE_LIST", "", DONATE_LIST, "DPanelList")


--[[-------------------------------------------------------------------------
Main frame
---------------------------------------------------------------------------]]
local FRAME = {}

function FRAME:Init()
    self:SetTitle("Tipping jar")
    self:SetSize(800, 500)
    self:Center()
    self:SetVisible(true)
    self:MakePopup()
    self:SetDeleteOnClose(false)

    self.donateEntry = vgui.Create("DarkRP_TipJar_DONATE_ENTRY", self)
    self.donateEntry:SetPos(10, 175)

    self.donateButton = vgui.Create("DarkRP_TipJar_DONATE_BUTTON", self)
    self.donateButton:SetPos(10, 245)

    self.donateList = vgui.Create("DarkRP_TipJar_DONATE_LIST", self)
    self.donateList:SetPos(310, 25)


    self:SetSkin(GAMEMODE.Config.DarkRPSkin)
end

function FRAME:OnClose()
    updateModel("frameVisible", false)
end

function FRAME:Think()
    local tipJar = getModelValue("tipjar")

    if not IsValid(tipJar) or
       tipJar:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100 * 100 then
        updateModel("frameVisible", false)
   end
end

derma.DefineControl("DarkRP_TipJar_FRAME", "", FRAME, "DFrame")

onModelUpdate("frameVisible", function(visible)
    local tipjar = getModelValue("tipjar")
    if not IsValid(tipjar) then return end

    if not getModelValue("frame") then
        if not visible then return end

        updateModel("frame", vgui.Create("DarkRP_TipJar_FRAME"))
    end

    local frame = getModelValue("frame")

    frame:SetVisible(visible)

    if visible then
        updateModel("amount", 0)
        frame.donateEntry:SelectAllText()
        frame.donateEntry:RequestFocus()

        local disable = getModelValue("isOwner")
        frame.donateEntry:SetDisabled(disable)
        frame.donateButton:SetDisabled(disable)
    end
end)

function DarkRP.tipJarUI(tipjar)
    updateModel("tipjar", tipjar)
    updateModel("isOwner", tipjar:Getowning_ent() == LocalPlayer())
    updateModel("amount", 0)
    updateModel("frameVisible", true)
end

--gamemodes/darkrp/gamemode/modules/tipjar/cl_communication.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/doorsystem/cl_doors.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/doorsystem/cl_doors.lua:
local meta = FindMetaTable("Entity")
local black = color_black
local white = Color(255, 255, 255, 200)
local red = Color(128, 30, 30, 255)
local changeDoorAccess = false

local function updatePrivs()
    CAMI.PlayerHasAccess(LocalPlayer(), "DarkRP_ChangeDoorSettings", function(b, _)
        changeDoorAccess = b
    end)
end
-- Timer due to lack of "on privilege changed" hook
hook.Add("InitPostEntity", "Load door privileges", function()
    updatePrivs()
    timer.Create("Door changeDoorAccess checker", 1, 0, updatePrivs)
end)

function meta:drawOwnableInfo()
    local ply = LocalPlayer()
    if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

    -- Look, if you want to change the way door ownership is drawn, don't edit this file, use the hook instead!
    local doorDrawing = hook.Call("HUDDrawDoorData", nil, self)
    if doorDrawing == true then return end

    local blocked = self:getKeysNonOwnable()
    local doorTeams = self:getKeysDoorTeams()
    local doorGroup = self:getKeysDoorGroup()
    local playerOwned = self:isKeysOwned() or table.GetFirstValue(self:getKeysCoOwners() or {}) ~= nil
    local owned = playerOwned or doorGroup or doorTeams

    local doorInfo = {}

    local title = self:getKeysTitle()
    if title then table.insert(doorInfo, title) end

    if owned then
        table.insert(doorInfo, DarkRP.getPhrase("keys_owned_by"))
    end

    if playerOwned then
        if self:isKeysOwned() then table.insert(doorInfo, self:getDoorOwner():Nick()) end
        for k in pairs(self:getKeysCoOwners() or {}) do
            local ent = Player(k)
            if not IsValid(ent) or not ent:IsPlayer() then continue end
            table.insert(doorInfo, ent:Nick())
        end

        local allowedCoOwn = self:getKeysAllowedToOwn()
        if allowedCoOwn and not fn.Null(allowedCoOwn) then
            table.insert(doorInfo, DarkRP.getPhrase("keys_other_allowed"))

            for k in pairs(allowedCoOwn) do
                local ent = Player(k)
                if not IsValid(ent) or not ent:IsPlayer() then continue end
                table.insert(doorInfo, ent:Nick())
            end
        end
    elseif doorGroup then
        table.insert(doorInfo, doorGroup)
    elseif doorTeams then
        for k, v in pairs(doorTeams) do
            if not v or not RPExtraTeams[k] then continue end

            table.insert(doorInfo, RPExtraTeams[k].name)
        end
    elseif blocked and changeDoorAccess then
        table.insert(doorInfo, DarkRP.getPhrase("keys_allow_ownership"))
    elseif not blocked then
        table.insert(doorInfo, DarkRP.getPhrase("keys_unowned"))
        if changeDoorAccess then
            table.insert(doorInfo, DarkRP.getPhrase("keys_disallow_ownership"))
        end
    end

    if self:IsVehicle() then
        local driver = self:GetDriver()
        if driver:IsPlayer() then
            table.insert(doorInfo, DarkRP.getPhrase("driver", driver:Nick()))
        end
    end

    local x, y = ScrW() / 2, ScrH() / 2
    local text = table.concat(doorInfo, "\n")
    draw.DrawNonParsedText(text, "Roboto20", x , y + 1 , black, 1)
    draw.DrawNonParsedText(text, "Roboto20", x, y, (blocked or owned) and white or red, 1)
end


--[[---------------------------------------------------------------------------
Door data
---------------------------------------------------------------------------]]
DarkRP.doorData = DarkRP.doorData or {}

--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function meta:getDoorData()
    local doorData = DarkRP.doorData[self:EntIndex()] or {}

    self.DoorData = doorData -- Backwards compatibility

    return doorData
end

--[[---------------------------------------------------------------------------
Networking
---------------------------------------------------------------------------]]

--[[---------------------------------------------------------------------------
Retrieve all the data for all doors
---------------------------------------------------------------------------]]
local function retrieveAllDoorData(len)
    local count = net.ReadUInt(16)

    for i = 1, count do
        local ix = net.ReadUInt(16)
        local varCount = net.ReadUInt(8)

        DarkRP.doorData[ix] = DarkRP.doorData[ix] or {}

        for vc = 1, varCount do
            local name, value = DarkRP.readNetDoorVar()
            DarkRP.doorData[ix][name] = value
        end
    end
end
net.Receive("DarkRP_AllDoorData", retrieveAllDoorData)

--[[---------------------------------------------------------------------------
Update changed variables
---------------------------------------------------------------------------]]
local function updateDoorData()
    local door = net.ReadUInt(32)

    DarkRP.doorData[door] = DarkRP.doorData[door] or {}

    local var, value = DarkRP.readNetDoorVar()

    DarkRP.doorData[door][var] = value
end
net.Receive("DarkRP_UpdateDoorData", updateDoorData)

--[[---------------------------------------------------------------------------
Set a value of a single doorvar to nil
---------------------------------------------------------------------------]]
local function removeDoorVar()
    local door = net.ReadUInt(16)
    local id = net.ReadUInt(8)

    local name = id == 0 and net.ReadString() or DarkRP.getDoorVars()[id].name

    if not DarkRP.doorData[door] then return end
    DarkRP.doorData[door][name] = nil
end
net.Receive("DarkRP_RemoveDoorVar", removeDoorVar)

--[[---------------------------------------------------------------------------
Remove doordata of removed entity
---------------------------------------------------------------------------]]
local function removeDoorData()
    local door = net.ReadUInt(32)
    DarkRP.doorData[door] = nil
end
net.Receive("DarkRP_RemoveDoorData", removeDoorData)

--gamemodes/darkrp/gamemode/modules/chat/sh_chatcommands.lua:
local plyMeta = FindMetaTable("Player")
DarkRP.chatCommands = DarkRP.chatCommands or {}

local validChatCommand = {
    command = isstring,
    description = isstring,
    condition = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isfunction},
    delay = isnumber,
    tableArgs = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isbool},
}

local checkChatCommand = function(tbl)
    for k in pairs(validChatCommand) do
        if not validChatCommand[k](tbl[k]) then
            return false, k
        end
    end
    return true
end

function DarkRP.declareChatCommand(tbl)
    local valid, element = checkChatCommand(tbl)
    if not valid then
        DarkRP.error("Incorrect chat command! " .. element .. " is invalid!", 2)
    end

    tbl.command = string.lower(tbl.command)
    DarkRP.chatCommands[tbl.command] = DarkRP.chatCommands[tbl.command] or tbl
    for k, v in pairs(tbl) do
        DarkRP.chatCommands[tbl.command][k] = v
    end
end

function DarkRP.removeChatCommand(command)
    DarkRP.chatCommands[string.lower(command)] = nil
end

function DarkRP.chatCommandAlias(command, ...)
    local name
    for k, v in pairs{...} do
        name = string.lower(v)

        DarkRP.chatCommands[name] = {command = name}
        setmetatable(DarkRP.chatCommands[name], {
            __index = DarkRP.chatCommands[command]
        })
    end
end

function DarkRP.getChatCommand(command)
    return DarkRP.chatCommands[string.lower(command)]
end

function DarkRP.getChatCommands()
    return DarkRP.chatCommands
end

function DarkRP.getSortedChatCommands()
    local tbl = fn.Compose{table.ClearKeys, table.Copy, DarkRP.getChatCommands}()
    table.SortByMember(tbl, "command", true)

    return tbl
end

-- chat commands that have been defined, but not declared
DarkRP.getIncompleteChatCommands = fn.Curry(fn.Filter, 3)(fn.Compose{fn.Not, checkChatCommand})(DarkRP.chatCommands)

--[[---------------------------------------------------------------------------
Chat commands
---------------------------------------------------------------------------]]
DarkRP.declareChatCommand{
    command = "pm",
    description = "Send a private message to someone.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "w",
    description = "Say something in whisper voice.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "y",
    description = "Yell something out loud.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "me",
    description = "Chat roleplay to say you're doing things that you can't show otherwise.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "/",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "a",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "ooc",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "broadcast",
    description = "Broadcast something as a mayor.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "channel",
    description = "Tune into a radio channel.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "radio",
    description = "Say something through the radio.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "g",
    description = "Group chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "credits",
    description = "Send the DarkRP credits to someone.",
    delay = 1.5
}

--gamemodes/darkrp/gamemode/modules/chat/cl_chat.lua:
function GM:OnPlayerChat()
end
local function AddToChat(bits)
    local col1 = Color(net.ReadUInt(8), net.ReadUInt(8), net.ReadUInt(8))

    local prefixText = net.ReadString()
    local ply = net.ReadEntity()
    ply = IsValid(ply) and ply or LocalPlayer()

    if not IsValid(ply) then return end

    if prefixText == "" or not prefixText then
        prefixText = ply:Nick()
        prefixText = prefixText ~= "" and prefixText or ply:SteamName()
    end

    local col2 = Color(net.ReadUInt(8), net.ReadUInt(8), net.ReadUInt(8))

    local text = net.ReadString()
    local shouldShow
    if text and text ~= "" then
        if IsValid(ply) then
            shouldShow = hook.Call("OnPlayerChat", GAMEMODE, ply, text, false, not ply:Alive(), prefixText, col1, col2)
        end

        if shouldShow ~= true then
            chat.AddNonParsedText(col1, prefixText, col2, ": " .. text)
        end
    else
        shouldShow = hook.Call("ChatText", GAMEMODE, "0", prefixText, prefixText, "darkrp")

        if shouldShow ~= true then
            chat.AddNonParsedText(col1, prefixText)
        end
    end
    chat.PlaySound()
end
net.Receive("DarkRP_Chat", AddToChat)

--gamemodes/darkrp/gamemode/modules/base/cl_util.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/localization/sh_glorifiedleveling_russian.lua:

GlorifiedLeveling.i18n.RegisterPhrases( "ru", {
    glDarkTheme = "Темная",
    glLevelNotHighEnough = "Ваш уровень недостаточно высок для этого!.",
    glYouReceivedXP = "Вы получили %s XP.",
    glYouReceivedXPKill = "Вы получили %s опыта за убийство %s.",
    glLevelX = "%s уровень",
    glLevelUp = "Уровень повышен!", 
    glAdminMenuLockdown = "КАРАНТИН", 
    glAdminMenuPlayers = "ИГРОКИ",
    glPlayersOnline = "Игроков онлайн: %s",
    glSetLevel = "Установить уровень",
    glResetLevel = "Сбросить уровень",
    glAddXP = "Добавить XP",
    glConfirmation = "Подтвердить",
    glYes = "да",
    glNo = "Нет",
    glConfirmationResetLevel = "Вы хотите сбросить уровень этого игрока?",
    glEnterLevel = "Войдите на новый уровень игрока ниже.",
    glEnterXP = "Введите, сколько XP вы хотите добавить.",
    glEnter = "поступать",
    glInvalidAmount = "Выбрана неверная сумма.",
    glMaxLevel = "Максимальный уровень",

    -- Leaderboard localization.
    glLeaderboard = "Таблица лидеров",
    glName = "имя",
    glXP = "XP",
    glLevel = "уровень",
    glNobodyHere = "Здесь никого нет :(",

    -- Perk localization.
    glSkills = "Навыки и умения",
    glPoints = "%s очков",
    glComplete = "законченный",

    glHasteBoots = "Сапоги спешки",
    glHasteBootsDescription = "Дополнительная скорость",

    glFeralLeaping = "Сапоги дикого прыжка",
    glFeralLeapingDescription = "Большая высота прыжка, меньше повреждений при падении",

    glIronSkin = "Железная кожа",
    glIronSkinDescription = "Дополнительная броня при появлении",

    glJuggernaut = "Джаггернаут",
    glJuggernautDescription = "Дополнительное здоровье при появлении",

    glBulletAbsorption = "Поглощение пули",
    glBulletAbsorptionDescription = "Меньше получаемого урона",

    glHighGradeBullets = "Пули высокого качества",
    glHighGradeBulletsDescription = "больше урона",
} )
--addons/glorifiedleveling/lua/glorifiedleveling/modules/core/cl_glorifiedleveling_playermeta.lua:

local defaultPerkTbl = GlorifiedLeveling.Perks.Enum.DEFAULT_PERK_TABLE

GlorifiedLeveling.PerkTable = defaultPerkTbl
GlorifiedLeveling.PerkTableCache = nil

net.Receive( "GlorifiedLeveling.Perks.SendPerkTableToClient", function()
    GlorifiedLeveling.PerkTable = net.ReadTableAsString() or defaultPerkTbl
end )

net.Receive( "GlorifiedLeveling.PlayerLeveledUp", function()
    hook.Run( "GlorifiedLeveling.LevelUp", net.ReadEntity() )
end )

net.Receive( "GlorifiedLeveling.PlayerXPUpdated", function()
    hook.Run( "GlorifiedLeveling.XPUpdated", net.ReadEntity(), net.ReadUInt( 64 ), net.ReadUInt( 64 ) )
end )

function GlorifiedLeveling.GetPlayerLevel( ply )
    if not ply then ply = LocalPlayer() end
    return tonumber( ply:GetNWInt( "GlorifiedLeveling.Level", 1 ) )
end

function GlorifiedLeveling.PlayerHasLevel( ply, level )
    if not ply then ply = LocalPlayer() end
    return GlorifiedLeveling.GetPlayerLevel() >= level
end

function GlorifiedLeveling.GetPlayerXP( ply )
    if not ply then ply = LocalPlayer() end
    return tonumber( ply:GetNWInt( "GlorifiedLeveling.XP", 0 ) )
end

function GlorifiedLeveling.GetPlayerMaxXP( ply )
    if not ply then ply = LocalPlayer() end
    local level = GlorifiedLeveling.GetPlayerLevel( ply )
    return ( 100 + ( level * ( level + 1 ) * 75 ) ) * GlorifiedLeveling.Config.MAX_XP_MULTIPLIER
end

function GlorifiedLeveling.GetPlayerPerkTable()
    return GlorifiedLeveling.PerkTable or defaultPerkTbl
end

function GlorifiedLeveling.GetPlayerPerkLevel( perk )
    return GlorifiedLeveling.GetPlayerPerkTable()[perk] or 0
end

function GlorifiedLeveling.GetTotalPerkPoints()
    return math.Round( math.floor( GlorifiedLeveling.GetPlayerLevel() / GlorifiedLeveling.Config.LEVELS_UNTIL_GAIN ) * GlorifiedLeveling.Config.POINTS_PER_GAIN )
end

function GlorifiedLeveling.GetTotalFreePerkPoints( fromCache )
    local totalPoints = GlorifiedLeveling.GetTotalPerkPoints()
    local freePoints = totalPoints
    for k, v in ipairs( fromCache and ( GlorifiedLeveling.PerkTableCache or GlorifiedLeveling.GetPlayerPerkTable() ) or GlorifiedLeveling.GetPlayerPerkTable() ) do
        freePoints = freePoints - v
    end
    return math.max( freePoints, 0 )
end

net.Receive( "GlorifiedLeveling.CacheTopTen", function()
    GlorifiedLeveling.TopTen = net.ReadTableAsString()
end )
--addons/darkrpmodification/lua/darkrp_language/english.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/darkrp_modules/zmlab/sh_zmlab_darkrp.lua:
return gluapack()()
--addons/cityworker/lua/darkrp_modules/cityworker/sh_cityworker.lua:
-- 76561198401674034
-- #NoSimplerr#

TEAM_CITYWORKER = DarkRP.createJob( CITYWORKER.Config.Job.name, CITYWORKER.Config.Job )
--addons/darkrpmodification/lua/darkrp_customthings/ammo.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/libraries/sh_glorifiedhandcuffs_i18n.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/localization/sh_glorifiedhandcuffs_polish.lua:

GlorifiedHandcuffs.i18n.RegisterPhrases( "pl", {
        cuffed = "Kelepçelisin",
    blindfolded = "Gözlerin bağlı",
    gagged = "Ağzın bağlı",
    hitToFree = "%s  tuşunu spamlayarak kelepçeden kurtulabilirsin",
    brokenFreeWanted = "Tutsaklıktan kaçtı",
    bailMenu = "Kefalet Menüsü",
    bailPlayer = "Oyuncunun Kefaletini Öde",
    bailNpc = "Kefalet NPC’si",
    jailerNpc = "Gardiyan NPC’si",
    noPlayers = "Tutuklu hiçbir oyuncu yok.",
    surrendering = "Teslim oluyorsun",
    putHandsDown = "Ellerini indirmek için %s  tuşuna bas",
    playersJailed = "%s’yı %s süreliğine hapise attın.",
    name = "İsim",
    job = "Meslek",
    wallet = "Cüzdan",
    confiscateAll = "Tüm Eşyalarına El Koy",
    confiscateIllegal = "İllegal Eşyalarına El Koy",
    takeAll = "Hepsini Al",
    takeIllegal = "İllegal Eşyasını Al",
    dragPlayer = "Oyuncuyu Sürükle",
    blindfoldPlayer = "Oyuncunun Gözlerini Bağla",
    removeBlindfold = "Göz Bağını Çıkar",
    gagPlayer = "Oyuncunun Ağzını Bağla",
    removeGag = "Oyuncunun Ağzını Çöz",
    confiscate = "El Koy",
    handcuffs = "Kelepçe",
    baton = "Cop",
    --[[
    cuffed = "You are cuffed",
    blindfolded = "You are blindfolded",
    gagged = "You are gagged",
    hitToFree = "Spam  %s  to break free",
    brokenFreeWanted = "Escaped from custody",
    bailMenu = "Bail Menu",
    bailPlayer = "Bail Player",
    bailNpc = "Bail NPC",
    jailerNpc = "Jailer NPC",
    noPlayers = "There are no arrested players.",
    surrendering = "You are surrendering",
    putHandsDown = "Press  %s  to put your hands down",
    playersJailed = "You jailed %s player(s) for %s.",
    name = "Name",
    job = "Job",
    wallet = "Wallet",
    confiscateAll = "Confiscate All",
    confiscateIllegal = "Confiscate Illegal",
    takeAll = "Take All",
    takeIllegal = "Take Illegal",
    dragPlayer = "Drag Player",
    blindfoldPlayer = "Blindfold Player",
    removeBlindfold = "Remove Blindfold",
    gagPlayer = "Gag Player",
    removeGag = "Remove Gag",
    confiscate = "Confiscate",
    handcuffs = "Handcuffs",
    baton = "Baton",
    --]]
} )
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/localization/sh_glorifiedhandcuffs_spanish.lua:

GlorifiedHandcuffs.i18n.RegisterPhrases( "es-ES", {
        cuffed = "Kelepçelisin",
    blindfolded = "Gözlerin bağlı",
    gagged = "Ağzın bağlı",
    hitToFree = "%s  tuşunu spamlayarak kelepçeden kurtulabilirsin",
    brokenFreeWanted = "Tutsaklıktan kaçtı",
    bailMenu = "Kefalet Menüsü",
    bailPlayer = "Oyuncunun Kefaletini Öde",
    bailNpc = "Kefalet NPC’si",
    jailerNpc = "Gardiyan NPC’si",
    noPlayers = "Tutuklu hiçbir oyuncu yok.",
    surrendering = "Teslim oluyorsun",
    putHandsDown = "Ellerini indirmek için %s  tuşuna bas",
    playersJailed = "%s’yı %s süreliğine hapise attın.",
    name = "İsim",
    job = "Meslek",
    wallet = "Cüzdan",
    confiscateAll = "Tüm Eşyalarına El Koy",
    confiscateIllegal = "İllegal Eşyalarına El Koy",
    takeAll = "Hepsini Al",
    takeIllegal = "İllegal Eşyasını Al",
    dragPlayer = "Oyuncuyu Sürükle",
    blindfoldPlayer = "Oyuncunun Gözlerini Bağla",
    removeBlindfold = "Göz Bağını Çıkar",
    gagPlayer = "Oyuncunun Ağzını Bağla",
    removeGag = "Oyuncunun Ağzını Çöz",
    confiscate = "El Koy",
    handcuffs = "Kelepçe",
    baton = "Cop",
    --[[
    cuffed = "You are cuffed",
    blindfolded = "You are blindfolded",
    gagged = "You are gagged",
    hitToFree = "Spam  %s  to break free",
    brokenFreeWanted = "Escaped from custody",
    bailMenu = "Bail Menu",
    bailPlayer = "Bail Player",
    bailNpc = "Bail NPC",
    jailerNpc = "Jailer NPC",
    noPlayers = "There are no arrested players.",
    surrendering = "You are surrendering",
    putHandsDown = "Press  %s  to put your hands down",
    playersJailed = "You jailed %s player(s) for %s.",
    name = "Name",
    job = "Job",
    wallet = "Wallet",
    confiscateAll = "Confiscate All",
    confiscateIllegal = "Confiscate Illegal",
    takeAll = "Take All",
    takeIllegal = "Take Illegal",
    dragPlayer = "Drag Player",
    blindfoldPlayer = "Blindfold Player",
    removeBlindfold = "Remove Blindfold",
    gagPlayer = "Gag Player",
    removeGag = "Remove Gag",
    confiscate = "Confiscate",
    handcuffs = "Handcuffs",
    baton = "Baton",
    --]]
} )
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/localization/sh_glorifiedhandcuffs_turkish.lua:

GlorifiedHandcuffs.i18n.RegisterPhrases( "tr", {
    cuffed = "Kelepçelisin",
    blindfolded = "Gözlerin bağlı",
    gagged = "Ağzın bağlı",
    hitToFree = "%s  tuşunu spamlayarak kelepçeden kurtulabilirsin",
    brokenFreeWanted = "Tutsaklıktan kaçtı",
    bailMenu = "Kefalet Menüsü",
    bailPlayer = "Oyuncunun Kefaletini Öde",
    bailNpc = "Kefalet NPC’si",
    jailerNpc = "Gardiyan NPC’si",
    noPlayers = "Tutuklu hiçbir oyuncu yok.",
    surrendering = "Teslim oluyorsun",
    putHandsDown = "Ellerini indirmek için %s  tuşuna bas",
    playersJailed = "%s’yı %s süreliğine hapise attın.",
    name = "İsim",
    job = "Meslek",
    wallet = "Cüzdan",
    confiscateAll = "Tüm Eşyalarına El Koy",
    confiscateIllegal = "İllegal Eşyalarına El Koy",
    takeAll = "Hepsini Al",
    takeIllegal = "İllegal Eşyasını Al",
    dragPlayer = "Oyuncuyu Sürükle",
    blindfoldPlayer = "Oyuncunun Gözlerini Bağla",
    removeBlindfold = "Göz Bağını Çıkar",
    gagPlayer = "Oyuncunun Ağzını Bağla",
    removeGag = "Oyuncunun Ağzını Çöz",
    confiscate = "El Koy",
    handcuffs = "Kelepçe",
    baton = "Cob",
} )
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/libraries/cl_glorifiedhandcuffs_circleavatar.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_masksize", "MaskSize", FORCE_NUMBER )

function PANEL:Init()
    self.Avatar = vgui.Create( "AvatarImage", self )
    self.Avatar:SetPaintedManually( true )

    self:SetMaskSize( 1 )

    self:SetText( "" )
end

function PANEL:DoClick()
    if not self.SteamID then return end

    gui.OpenURL( "https://steamcommunity.com/profiles/" .. self.SteamID )
end

function PANEL:PerformLayout()
    self.Avatar:SetSize( self:GetWide(), self:GetTall() )
end

function PANEL:SetPlayer( id, size )
    self.Avatar:SetPlayer( id, size )
end

function PANEL:SetSteamID( steamid, size )
    if not isstring( steamid ) then return end

    self.SteamID = steamid
    self.Avatar:SetSteamID( steamid, size )
end

function PANEL:Paint( w, h )
    render.ClearStencil()
    render.SetStencilEnable( true )
    render.SetStencilWriteMask( 1 )
    render.SetStencilTestMask( 1 )
    render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
    render.SetStencilPassOperation( STENCILOPERATION_ZERO )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
    render.SetStencilReferenceValue( 1 )

    local _m = self.m_masksize
    local circle, t = {}, 0

    for i = 1, 360 do
        t = math.rad( i * 720 ) / 720

        circle[i] = {
            x = w / 2 + math.cos( t ) * _m,
            y = h / 2 + math.sin( t ) * _m
        }
    end

    draw.NoTexture()
    surface.SetDrawColor( color_white )
    surface.DrawPoly( circle )
    render.SetStencilFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
    render.SetStencilReferenceValue( 1 )

    self.Avatar:SetPaintedManually( false )
    self.Avatar:PaintManual()
    self.Avatar:SetPaintedManually( true )

    render.SetStencilEnable( false )
    render.ClearStencil()
end

vgui.Register( "GlorifiedHandcuffs.CircleAvatar", PANEL, "DButton" )
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/libraries/cl_glorifiedhandcuffs_scrollpanel.lua:

local PANEL = {}

function PANEL:Init()
    self.Theme = self:GetParent().Theme

    self.VBar:SetHideButtons( true )

    function self.VBar:Paint( w, h ) end

    self.VBar.btnGrip.Color = Color( 255, 255, 255 )
    self.VBar.btnGrip.Paint = function( s, w, h )
        s.Color = GlorifiedHandcuffs.UI.LerpColor( FrameTime() * 15, s.Color, ( self.VBar.Dragging or s:IsHovered() ) and self.Theme.Data.Colors.scrollBarHoverCol or self.Theme.Data.Colors.scrollBarCol )
        draw.RoundedBox( w * 0.46, 0, 0, w, h, s.Color )
    end
end

function PANEL:PerformLayout( w, h )
    if not ( w or h ) then return end

    self.VBar:SetWidth( w * 0.018 )
    self.VBar:Dock( RIGHT )

    self:Rebuild()

    self.VBar:SetUp( h, self.pnlCanvas:GetTall() )

    if self.VBar.Enabled then w = w - self.VBar:GetWide() end

    self.pnlCanvas:SetPos( 0, self.VBar:GetOffset() )
    self.pnlCanvas:SetWide( w )

    self:Rebuild()

    if h != self.pnlCanvas:GetTall() then
        self.VBar:SetScroll( self.VBar:GetScroll() )
    end
end

vgui.Register( "GlorifiedHandcuffs.ScrollPanel", PANEL, "DScrollPanel" )
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/bailmenu/cl_glorifiedhandcuffs_bailmenu_arrestedplayers.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/interactionmenu/cl_glorifiedhandcuffs_interactionmenu_infobox.lua:

local PANEL = {}

function PANEL:Init()
    self.Theme = self:GetParent().Theme

    self.LeftIconPanel = vgui.Create( "EditablePanel", self )
    self.LeftIconPanel:Dock( LEFT )
    self.LeftIconPanel:SetSize( 48, 0 )

    self.LeftIcon = vgui.Create( "DImage", self.LeftIconPanel )
    self.LeftIcon:SetSize( 36, 36 )
    self.LeftIcon:SetPos( 10, self:GetTall() / 2 )

    self.LeftLabel = vgui.Create( "DLabel", self )
    self.LeftLabel:SetFont( "GlorifiedHandcuffs.InteractionMenu.InfoBox" )
    self.LeftLabel:SetColor( self.Theme.Data.Colors.interactionMenuInfoBoxTextColor )
    self.LeftLabel:DockMargin( 10, 0, 0, 0 )
    self.LeftLabel:Dock( LEFT )

    self.RightLabel = vgui.Create( "DButton", self )
    self.RightLabel:SetFont( "GlorifiedHandcuffs.InteractionMenu.InfoBoxInfo" )
    self.RightLabel:DockMargin( 0, 0, 10, 0 )
    self.RightLabel:Dock( RIGHT )
end

function PANEL:PerformLayout( w, h )
    self.LeftIcon:SetPos( 10, h / 2 - self.LeftIcon:GetTall() / 2 - 2 )
end

function PANEL:Paint( w, h )
    draw.RoundedBox( 6, 0, 0, w, h, self.Theme.Data.Colors.interactionMenuInfoBoxBackgroundColor )
end

function PANEL:SetLabelInfo( leftLabelName, rightLabelName, rightLabelColor, rightLabelTextColor, iconMaterial )
    self.LeftIcon:SetMaterial( iconMaterial )

    self.LeftLabel:SetText( leftLabelName )
    self.LeftLabel:SizeToContents()

    self.RightLabel:SetText( rightLabelName )
    self.RightLabel:SetTextColor( rightLabelTextColor )
    self.RightLabel:SizeToContents()
    self.RightLabel:SetWidth( self.RightLabel:GetWide() * 1.2 )
    self.RightLabel.Paint = function( rightLabel, rightLabelW, rightLabelH )
        draw.RoundedBox( 8, 0, 9, rightLabelW, rightLabelH - 18, rightLabelColor )
    end
end

vgui.Register( "GlorifiedHandcuffs.InteractionMenu.InfoBox", PANEL, "Panel" )
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/cl_holosight.lua:
function SWEP:DoHolosight()

    -- In VRMod, we draw all holosights all the time
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        for i, asight in pairs(self.SightTable) do
            local aslot = self.Attachments[asight.Slot] or {}
            local atttbl = asight.HolosightData

            if !atttbl and aslot.Installed then
                atttbl = ArcCW.AttachmentTable[aslot.Installed]

                if !atttbl.Holosight then return end
            end

            if atttbl then
                local hsp = asight.HolosightPiece or self.HSPElement
                local hsm = asight.HolosightModel

                if !hsp and !hsm then
                    self:SetupActiveSights()
                    return
                end

                self:DrawHolosight(atttbl, hsm, hsp, asight)
            end
        end

        return
    end

    local asight = self:GetActiveSights()
    if !asight then return end
    local aslot = self.Attachments[asight.Slot] or {}

    local atttbl = asight.HolosightData

    if !atttbl and aslot.Installed then
        atttbl = ArcCW.AttachmentTable[aslot.Installed]

        if !atttbl.Holosight then return end
    end

    if atttbl then
        local hsp = asight.HolosightPiece or self.HSPElement
        local hsm = asight.HolosightModel

        if !hsp and !hsm then
            self:SetupActiveSights()
            return
        end

        self:DrawHolosight(atttbl, hsm, hsp)
    end
end

function SWEP:ShouldFlatScope()
    return false -- this system was removed, but we need to keep this function
end

local rtsize = ScrH()

local rtmat = GetRenderTarget("arccw_rtmat", rtsize, rtsize, false)
local rtmat_cheap = GetRenderTarget("arccw_rtmat_cheap", ScrW(), ScrH(), false)
local rtmat_spare = GetRenderTarget("arccw_rtmat_spare", ScrW(), ScrH(), false)


local thermal = Material("models/debug/debugwhite")
local colormod = Material("pp/colour")
local coldtime = 30

local additionalFOVconvar = ArcCW.ConVars["vm_add_ads"]

local matRefract = Material("pp/arccw/refract_rt")
local matRefract_cheap = Material("pp/arccw/refract_cs") -- cheap scopes stretches square overlays so i need to make it 16x9

matRefract:SetTexture("$fbtexture", render.GetScreenEffectTexture())
matRefract_cheap:SetTexture("$fbtexture", render.GetScreenEffectTexture())

timer.Create("ihategmod", 5, 0, function() -- i really dont know what the fucking problem with cheap scopes they dont want to set texture as not cheap ones
    matRefract_cheap:SetTexture("$fbtexture", render.GetScreenEffectTexture())
    matRefract:SetTexture("$fbtexture", render.GetScreenEffectTexture()) -- not cheap scope here why not
end)

local pp_ca_base, pp_ca_r, pp_ca_g, pp_ca_b = Material("pp/arccw/ca_base"), Material("pp/arccw/ca_r"), Material("pp/arccw/ca_g"), Material("pp/arccw/ca_b")
local pp_ca_r_thermal, pp_ca_g_thermal, pp_ca_b_thermal = Material("pp/arccw/ca_r_thermal"), Material("pp/arccw/ca_g_thermal"), Material("pp/arccw/ca_b_thermal")

pp_ca_r:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_g:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_b:SetTexture("$basetexture", render.GetScreenEffectTexture())

pp_ca_r_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_g_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_b_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())

local greenColor = Color(0, 255, 0)  -- optimized +10000fps
local whiteColor = Color(255, 255, 255)
local blackColor = Color(0, 0, 0)

local function DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 ) -- stolen from gmod wiki
    local mathrot = math.rad( rot )
    local c = math.cos( mathrot )
    local s = math.sin( mathrot )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end


local function IsWHOT(ent)
    if !ent:IsValid() or ent:IsWorld() then return false end

    if ent:IsPlayer() then -- balling
        if ent.ArcticMedShots_ActiveEffects and ent.ArcticMedShots_ActiveEffects["coldblooded"] or ent:Health() <= 0 then return false end -- arc stims
        return true
    end

    if ent:IsNPC() or ent:IsNextBot() then -- npcs
        if ent.ArcCWCLHealth and ent.ArcCWCLHealth <= 0 or ent:Health() <= 0 then return false end
        return true
    end

    if ent:IsRagdoll() then -- ragdolling
        if !ent.ArcCW_ColdTime then ent.ArcCW_ColdTime = CurTime() + coldtime end
        return ent.ArcCW_ColdTime > CurTime()
    end

    if ent:IsVehicle() or ent:IsOnFire() or ent.ArcCW_Hot or ent:IsScripted() and !ent:GetOwner():IsValid() then -- vroom vroom + :fire: + ents but not guns (guns on ground will be fine)
        return true
    end

    return false
end

function SWEP:FormThermalImaging(tex)
    local scrw, scrh = ScrW(), ScrH()
    if !tex then
        tex = render.GetRenderTarget()
    end

    render.PushRenderTarget(tex)

    cam.Start3D()

    if tex then
        colormod:SetTexture("$fbtexture", tex)
    else
        colormod:SetTexture("$fbtexture", render.GetScreenEffectTexture())
    end

    local asight = self:GetActiveSights()

    local nvsc = asight.ThermalScopeColor or whiteColor
    local tvsc = asight.ThermalHighlightColor or whiteColor



    -- table.Add(tab, player.GetAll())
    -- table.Add(tab, ents.FindByClass("npc_*"))

    render.SetStencilEnable(true)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.ClearStencil()

    local sw = scrh
    local sh = sw

    local sx = (scrw - sw) / 2
    local sy = (scrh - sh) / 2

    render.SetScissorRect( sx, sy, sx + sw, sy + sh, true )

    render.SetStencilReferenceValue(64)

    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)

    for _, v in ents.Iterator() do

        if !IsWHOT(v) then continue end

        if !asight.ThermalScopeSimple then
            render.SetBlend(0.5)
            render.SuppressEngineLighting(true)

            render.SetColorModulation(250, 250, 250)

            v:DrawModel()
        end
    end

    render.SetColorModulation(1, 1, 1)

    render.SuppressEngineLighting(false)

    render.MaterialOverride()

    render.SetBlend(1)

    render.SetStencilCompareFunction(STENCIL_EQUAL)

    if asight.ThermalScopeSimple then
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, scrw, scrh)
    end

    DrawColorModify({
        ["$pp_colour_addr"] = 0,
        ["$pp_colour_addg"] = 0,
        ["$pp_colour_addb"] = 0,
        ["$pp_colour_brightness"] = 0,
        ["$pp_colour_contrast"] = 1,
        ["$pp_colour_colour"] = 0,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    DrawColorModify({
        ["$pp_colour_addr"] = tvsc.r - 255,
        ["$pp_colour_addg"] = tvsc.g - 255,
        ["$pp_colour_addb"] = tvsc.b - 255,
        ["$pp_colour_addr"] = 0,
        ["$pp_colour_addg"] = 0,
        ["$pp_colour_addb"] = 0,
        ["$pp_colour_brightness"] = 0,
        ["$pp_colour_contrast"] = 1,
        ["$pp_colour_colour"] = 1,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    if !asight.ThermalNoCC then
        render.SetStencilCompareFunction(STENCIL_NOTEQUAL)
        render.SetStencilPassOperation(STENCIL_KEEP)

        if !asight.ThermalFullColor then
            DrawColorModify({
                ["$pp_colour_addr"] = 0,
                ["$pp_colour_addg"] = 0,
                ["$pp_colour_addb"] = 0,
                ["$pp_colour_brightness"] = 0,
                ["$pp_colour_contrast"] = 1,
                ["$pp_colour_colour"] = 0,
                ["$pp_colour_mulr"] = 0,
                ["$pp_colour_mulg"] = 0,
                ["$pp_colour_mulb"] = 0
            })
        end

 /*       if ArcCW.ConVars["thermalpp"]:GetBool() and ArcCW.ConVars["scopepp"]:GetBool() then
            -- chromatic abberation

            render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())

            render.SetMaterial( pp_ca_base )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_r_thermal )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_g_thermal )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_b_thermal )
            render.DrawScreenQuad()
            -- pasted here cause otherwise either target colors will get fucked either pp either motion blur
        end */

        DrawColorModify({
            ["$pp_colour_addr"] = nvsc.r - 255,
            ["$pp_colour_addg"] = nvsc.g - 255,
            ["$pp_colour_addb"] = nvsc.b - 255,
            -- ["$pp_colour_addr"] = 0,
            -- ["$pp_colour_addg"] = 0,
            -- ["$pp_colour_addb"] = 0,
            ["$pp_colour_brightness"] = asight.Brightness or 0.1,
            ["$pp_colour_contrast"] = asight.Contrast or 0.5,
            ["$pp_colour_colour"] = asight.Colormult or 1,
            ["$pp_colour_mulr"] = 0,
            ["$pp_colour_mulg"] = 0,
            ["$pp_colour_mulb"] = 0
        })
    end

    render.SetScissorRect( sx, sy, sx + sw, sy + sh, false )

    render.SetStencilEnable(false)

    colormod:SetTexture("$fbtexture", render.GetScreenEffectTexture())

    cam.End3D()

  /*  if ArcCW.ConVars["thermalpp"]:GetBool() then
        if !render.SupportsPixelShaders_2_0() then return end

        DrawSharpen(0.3,0.9)
        DrawBloom(0,0.3,5,5,3,0.5,1,1,1)
        -- DrawMotionBlur(0.7,1,1/(asight.FPSLock or 45)) -- upd i changed order and it fucking worked lmao     //////i cant fucking understand why motionblur fucks render target
    end */

    render.PopRenderTarget()
end

function SWEP:FormNightVision(tex)
    local asight = self:GetActiveSights()

    local orig = colormod:GetTexture("$fbtexture")

    colormod:SetTexture("$fbtexture", tex)

    render.PushRenderTarget(tex)

    local nvsc = asight.NVScopeColor or greenColor

    if !asight.NVFullColor then
        DrawColorModify({
            ["$pp_colour_addr"] = 0,
            ["$pp_colour_addg"] = 0,
            ["$pp_colour_addb"] = 0,
            ["$pp_colour_brightness"] = 0,
            ["$pp_colour_contrast"] = 1,
            ["$pp_colour_colour"] = 0,
            ["$pp_colour_mulr"] = 0,
            ["$pp_colour_mulg"] = 0,
            ["$pp_colour_mulb"] = 0
        })
    end

    DrawColorModify({
        ["$pp_colour_addr"] = nvsc.r - 255,
        ["$pp_colour_addg"] = nvsc.g - 255,
        ["$pp_colour_addb"] = nvsc.b - 255,
        ["$pp_colour_brightness"] = asight.Brightness or -0.05,
        ["$pp_colour_contrast"] = asight.Contrast or 4,
        ["$pp_colour_colour"] = 1,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    render.PopRenderTarget()

    colormod:SetTexture("$fbtexture", orig)
end

local pp_cc_tab = {
    ["$pp_colour_addr"] = 0,
    ["$pp_colour_addg"] = 0,
    ["$pp_colour_addb"] = 0,
    ["$pp_colour_brightness"] = 0, -- why nothing works hh
    ["$pp_colour_contrast"] = 0.9,  -- but same time chroma dont work without calling it
    ["$pp_colour_colour"] = 1,
    ["$pp_colour_mulr"] = 0,
    ["$pp_colour_mulg"] = 0,
    ["$pp_colour_mulb"] = 0
}

function SWEP:FormPP(tex)
    if !render.SupportsPixelShaders_2_0() then return end

    local asight = self:GetActiveSights()

    if asight.Thermal then return end -- eyah
/*
    local cs = ArcCW.ConVars["cheapscopes"]:GetBool()
    local refract = ArcCW.ConVars["scopepp_refract"]:GetBool()
    local pp = ArcCW.ConVars["scopepp"]:GetBool()


    if refract or pp then
        if !cs then render.PushRenderTarget(tex) end
        render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())

        if pp then
            render.SetMaterial( pp_ca_base )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_r )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_g )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_b )
            render.DrawScreenQuad()
                -- Color modify

            DrawColorModify( pp_cc_tab )
                -- Sharpen
            DrawSharpen(-0.1, 5) -- dont work for some reason
        end

        if refract then
            local addads = math.Clamp(0, -2, 14)
            local refractratio = 0.75
            local refractamount = (-0.6 + addads / 30) * refractratio
            local refractmat = cs and matRefract_cheap or matRefract

            refractmat:SetFloat( "$refractamount", refractamount )

            render.SetMaterial(refractmat)
            render.DrawScreenQuad()
        end

        if !cs then render.PopRenderTarget() end
    end
*/
end

function SWEP:FormCheapScope()
    local screen = render.GetRenderTarget()

    render.CopyTexture( screen, rtmat_spare )

    render.PushRenderTarget(screen)
    cam.Start3D(EyePos(), EyeAngles(), nil, nil, nil, nil, nil, 0, nil)
        ArcCW.LaserBehavior = true
        self:DoLaser(false)
        ArcCW.LaserBehavior = false
    cam.End3D()

    self:FormPP(screen)

    render.PopRenderTarget()

    -- so, in order to avoid the fact that copying RTs doesn't transfer depth buffer data, we just take the screen texture and...
    -- redraw it to cover up the thermal scope stuff. Don't think too hard about this. You have plenty of VRAM.

    local asight = self:GetActiveSights()

    if asight.Thermal then
        self:FormThermalImaging(screen)
    end

    if asight.SpecialScopeFunction then
        asight.SpecialScopeFunction(screen)
    end

    -- integrated render delay for better optimization
    if asight.FPSLock then
        asight.fpsdelay = CurTime() + 1 / (asight.FPSLock or 45)
    end

    render.CopyTexture( screen, rtmat_cheap )

    render.DrawTextureToScreen(rtmat_spare)

    render.UpdateFullScreenDepthTexture()
end

function SWEP:FormRTScope()
    local asight = self:GetActiveSights()

    if !asight then return end

    if !asight.MagnifiedOptic then return end
    local scrw, scrh = ScrW(), ScrH()
    local getstate = self:GetState()
    local mag = asight.ScopeMagnification

    cam.Start3D()

    ArcCW.Overdraw = true
    ArcCW.LaserBehavior = true
    ArcCW.VMInRT = true

    local rtangles, rtpos, rtdrawvm

    if getstate == ArcCW.STATE_SIGHTS then
     /*   if ArcCW.ConVars["drawbarrel"]:GetBool() and ArcCW.ConVars["vm_coolsway"]:GetBool() and asight.Slot and asight.Slot == 1 then -- slot check to ignore integrated
            rtangles = self.VMAng - self.VMAngOffset - (self:GetOurViewPunchAngles() * mag * 0.1)
            rtangles.x = rtangles.x - self.VMPosOffset_Lerp.z * 10
            rtangles.y = rtangles.y + self.VMPosOffset_Lerp.y * 10

            rtpos = self.VMPos + self.VMAng:Forward() * (asight.EVPos.y + 7 + (asight.ScopeMagnificationMax and asight.ScopeMagnificationMax / 3 or asight.HolosightData.HolosightMagnification / 3)) -- eh
            rtdrawvm = true
        else */
            rtangles = EyeAngles()
            rtpos = EyePos()
            rtdrawvm = false

            -- HACK HACK HACK HACK HACK
            -- If we do not draw the viewmodel in RT scope, calling GetAttachment on the vm seems to break LHIK.
            -- So... just draw it! The results gets drawn over again so it doesn't affect the outcome
           -- render.RenderView({drawviewmodel = true}) -- ?????
       -- end
    end

    local addads = math.Clamp(0, -2, 14)

    local rt = {
        w = rtsize,
        h = rtsize,
        angles = rtangles,
        origin = rtpos,
        drawviewmodel = rtdrawvm,
        fov = self:GetOwner():GetFOV() / mag / 1.2 - (addads or 0) / 4,
    }

    rtsize = scrh

    if scrw > scrh then rtsize = scrw end

    local rtres = asight.ForceLowRes and scrw * 0.6 or scrh -- we can emit low res lcd displays for scopes

    rtmat = GetRenderTarget("arccw_rtmat" .. rtres, rtres, rtres, false)

    render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)

    render.ClearRenderTarget(rt, blackColor)

    if getstate == ArcCW.STATE_SIGHTS then
        render.RenderView(rt)
        cam.Start3D(EyePos(), EyeAngles(), rt.fov, 0, 0, nil, nil, 0, nil)
            self:DoLaser(false)
        cam.End3D()
    end

    ArcCW.Overdraw = false
    ArcCW.LaserBehavior = false
    ArcCW.VMInRT = false

    self:FormPP(rtmat)

    render.PopRenderTarget()

    cam.End3D()

    if asight.Thermal then
        self:FormThermalImaging(rtmat)
    end

    if asight.SpecialScopeFunction then
       -- asight.SpecialScopeFunction(rtmat)
    end

    -- integrated render delay for better optimization
    if asight.FPSLock then
        asight.fpsdelay = CurTime() + 1 / (asight.FPSLock or 45)
    end

end

hook.Add("RenderScene", "ArcCW", function()
    if ArcCW.ConVars["cheapscopes"]:GetBool() then return end

    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn.ArcCW then return end
    if wpn:GetActiveSights() and wpn:GetActiveSights().FPSLock
            and (wpn:GetActiveSights().fpsdelay or 0) > CurTime() then
        return
    end
    wpn:FormRTScope()
end)

local black = Material("arccw/hud/black.png")
local defaultdot = Material("arccw/hud/hit_dot.png")
local beyaz = Color(255, 255, 255)
local vectorcache = Vector(1, 1, 1)
function SWEP:DrawHolosight(hs, hsm, hsp, asight)
    -- holosight structure
    -- holosight model

    local ref = 32

    asight = asight or self:GetActiveSights()
    local delta = self:GetSightDelta()

    if asight.HolosightData then
        hs = asight.HolosightData
    end

    if self:GetState() != ArcCW.STATE_SIGHTS and delta > 0.5 or self:GetBarrelNearWall() > 0 then return end

    if !hs then return end

    if delta != 0  then
        pp_ca_r:SetVector("$color2", Vector(1-delta, 0, 0))
        pp_ca_g:SetVector("$color2", Vector(0, 1-delta, 0))
        pp_ca_b:SetVector("$color2", Vector(0, 0, 1-delta))
        pp_ca_base:SetFloat("$alpha", 1-delta)
    end

    local hsc = beyaz -- putting here global or white local SOMEHOW FUCKS IT EVEN GLOBAL BEING FUCKED WTF I HATE

    if hs.Colorable then
        hsc.r = 255
        hsc.g = 0
        hsc.b = 0
    else
        hsc = hs.HolosightColor or hsc
    end

    local attid = 0

    if hsm then

        attid = hsm:LookupAttachment(asight.HolosightBone or hs.HolosightBone or "holosight")

        if attid == 0 then
            attid = hsm:LookupAttachment("holosight")
        end

    end

    local ret, pos, ang
    local eyepos = EyePos()
    if attid != 0 then

        ret = hsm:GetAttachment(attid)
        pos = ret.Pos
        ang = ret.Ang

    else

        pos = eyepos
        ang = EyeAngles()

    end

    local hsmag = asight.ScopeMagnification or 1

    local size = hs.HolosightSize or 1

    local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)

    local addconvar = asight.MagnifiedOptic and (addads or 0) or 0

    size = size + addconvar + (addconvar > 5.5 and (addconvar-5.5) * 2 or 0)


    -- if asight.NightVision then

    if hsmag and hsmag > 1 and delta < 1 and asight.NVScope then
        local screen = rtmat

        if asight.NVScope then
            self:FormNightVision(screen)
        end
    end

    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_REPLACE)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)

    render.SetBlend(0)

        render.SetStencilReferenceValue(ref)

        ArcCW.Overdraw = true

        render.OverrideDepthEnable( true, true )

        if !hsm then
            hsp:DrawModel()
        else

            hsm:SetBodygroup(1, 0)

            if !hsp or hs.HolosightNoHSP then
                hsm:DrawModel()
            end

            -- render.MaterialOverride()

            render.SetStencilReferenceValue(0)

            hsm:SetBodygroup(1, 1)
            -- hsm:SetSubMaterial(0, "dev/no_pixel_write")
            hsm:DrawModel()
            -- hsm:SetSubMaterial()
            hsm:SetBodygroup(1, 0)

            -- local vm = self:GetOwner():GetViewModel()

            -- ArcCW.Overdraw = true
            -- vm:DrawModel()

            -- ArcCW.Overdraw = false

            render.SetStencilReferenceValue(ref)

            if hsp then
                hsp:DrawModel()
            end
        end

        -- render.MaterialOverride()

        render.OverrideDepthEnable( false, true )

        ArcCW.Overdraw = false

    render.SetBlend(1)

    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilCompareFunction(STENCIL_EQUAL)

    -- local pos = EyePos()
    -- local ang = EyeAngles()

    ang:RotateAroundAxis(ang:Forward(), -90)

    local dir = ang:Up()

    local pdiff = (pos - eyepos):Length()

    pos = LerpVector(delta, eyepos, pos)
    local getownerply = self:GetOwner()
    local eyeangs = getownerply:EyeAngles() - self:GetOurViewPunchAngles() * hsmag * 0.1

    -- local vm = hsm or hsp

    -- eyeangs = eyeangs + (eyeangs - vm:GetAngles())

    dir = LerpVector(delta, eyeangs:Forward(), dir:GetNormalized())

    pdiff = Lerp(delta, pdiff, 0)

    local d = (8 + pdiff)

    d = hs.HolosightConstDist or d

    local vmscale = (self.Attachments[asight.Slot] or {}).VMScale or vectorcache

    if hs.HolosightConstDist then
        vmscale = vectorcache
    end

    local hsx = vmscale[2] or 1
    local hsy = vmscale[3] or 1

    pos = pos + (dir * d)

    local pos2 = pos + (dir * -8)

    local a = pos:ToScreen()
    local x = a.x - (self.VMAngOffset.y - self.VMPosOffset_Lerp.y * 10) * (hsmag * 1.5) ^ 2
    local y = a.y + (self.VMAngOffset.x * 5 + self.VMPosOffset_Lerp.z * 10) * (hsmag * 1.5) ^ 2

    local a2 = pos2:ToScreen()

    local scrw = ScrW()
    local scrh = ScrH()

    local off_x = a2.x - (scrw / 2)
    local off_y = a2.y - (scrh / 2)

    --pos = pos + Vector(ArcCW.StrafeTilt(self), 0, 0)

    -- local corner1, corner2, corner3, corner4

    -- corner2 = pos + (ang:Right() * (-0.5 * size)) + (ang:Forward() * (0.5 * size))
    -- corner1 = pos + (ang:Right() * (-0.5 * size)) + (ang:Forward() * (-0.5 * size))
    -- corner4 = pos + (ang:Right() * (0.5 * size)) + (ang:Forward() * (-0.5 * size))
    -- corner3 = pos + (ang:Right() * (0.5 * size)) + (ang:Forward() * (0.5 * size))

    -- render.SetColorMaterialIgnoreZ()
    -- render.DrawScreenQuad()

    -- render.SetStencilEnable( false )
    -- local fovmag = asight.Magnification or 1
    
    if hsmag and hsmag > 1 and delta < 1 then
        local screen = rtmat

        -- local sw2 = ScrH()
        -- local sh2 = sw2

        -- local sx2 = (ScrW() - sw2) / 2
        -- local sy2 = (ScrH() - sh2) / 2

        -- render.SetScissorRect( sx2, sy2, sx2 + sw2, sy2 + sh2, true )

        if render.GetHDREnabled() and delta < 0.07 then
            render.SetToneMappingScaleLinear(Vector(1,1,1)) -- hdr fix
        end



            local sw = scrh
            local sh = sw

            local sx = ((scrw - sw) / 2) - off_x
            local sy = ((scrh - sh) / 2) - off_x

            render.SetMaterial(black)
            render.DrawScreenQuad()

            render.DrawTextureToScreenRect(screen, sx, sy, sw, sh)

   
    end

    -- cam.Start3D()

    -- render.SetColorMaterialIgnoreZ()
    -- render.DrawScreenQuad()

    -- render.DrawQuad( corner1, corner2, corner3, corner4, hsc or hs.HolosightColor )
    cam.IgnoreZ( true )

    render.SetStencilReferenceValue(ref)

    -- render.SetMaterial(hs.HolosightReticle or defaultdot)
    -- render.DrawSprite( pos, size * hsx, size * hsy, hsc or Color(255, 255, 255) )
    -- if !hs.HolosightNoFlare then
    --     render.SetMaterial(hs.HolosightFlare or hs.HolosightReticle or defaultdot)
    --     local hss = 0.75
    --     if hs.HolosightFlare then
    --         hss = 1
    --     end
    --     render.DrawSprite( pos, size * hss * hsx, size * hss * hsy, Color(255, 255, 255, 255) )
    -- end

    cam.Start2D()

    if hs.HolosightBlackbox then
        render.SetStencilPassOperation(STENCIL_KEEP)

        surface.SetDrawColor(0, 0, 0, 255 * delta)
        surface.DrawRect(0, 0, scrw, scrh)
    end

    render.SetStencilPassOperation(STENCIL_DECR)
    render.SetStencilCompareFunction(STENCIL_EQUAL)

    local hss = size * 32 * math.min(scrw, scrh) / 800

    --local thej = self.TheJ.anga + LocalPlayer():GetViewPunchAngles() + self:GetOurViewPunchAngles()
                    -- AYE, UR ACTIVE ANG BEIN TWISTED DUNT GIVE AUH SHET

    surface.SetMaterial(hs.HolosightReticle or defaultdot)
    surface.SetDrawColor(hsc or 255, 255, 255)
    -- surface.DrawTexturedRect(x - (hss / 2), y - (hss / 2), hss, hss)

    DrawTexturedRectRotatedPoint(x, y, hss, hss, -(self.VMAngOffset.r+self.VMAngOffset_Lerp.r+self:GetOurViewPunchAngles().r)*5 , 0, 0)

    if !hs.HolosightNoFlare then
        render.SetStencilPassOperation(STENCIL_KEEP)
        render.SetStencilReferenceValue(ref - 1)
        surface.SetMaterial(hs.HolosightFlare or hs.HolosightReticle or defaultdot)
        surface.SetDrawColor(255, 255, 255, 150)

        local hss2 = hss

        if !hs.HolosightFlare then
            hss2 = hss - 2
        end

        surface.DrawTexturedRect(x - (hss2 / 2), y - (hss2 / 2), hss2, hss2)
        --surface.DrawTexturedRectRotated(x, y, hss2, hss2, -thej.r or 0)

        render.SetStencilReferenceValue(ref)
    end

    if hs.HolosightBlackbox then
        -- render.SetColorMaterialIgnoreZ()
        -- render.DrawScreenQuad()

        surface.SetDrawColor(0, 0, 0)
        surface.DrawRect(0, 0, scrw, scrh)
        -- surface.DrawRect(0, (ScrH() - hss) / 2, ScrW(), (ScrH() - hss) / 2)
    end

    cam.End2D()

    render.SetStencilEnable( false )

    cam.IgnoreZ( false )

    -- cam.End3D()

    if hsp then

        cam.IgnoreZ(true)

        if ArcCW.ConVars["glare"]:GetBool() then
            render.SetBlend(delta + 0.1)
        else
            render.SetBlend(delta)
        end
        hsp:DrawModel()
        render.SetBlend(1)

        cam.IgnoreZ( false )

    end
end


--           I wanted to make here procedural normal map for refract using rt but steamsnooze


-- local TEX_SIZE = 512

-- local tex = GetRenderTarget( "ExampleRT", TEX_SIZE, TEX_SIZE )

-- local txBackground = surface.GetTextureID( "pp/arccw/lense_nrm2" )
-- local myMat = CreateMaterial( "ExampleRTMat3", "UnlitGeneric", {
-- 	["$basetexture"] = tex:GetName() -- Make the material use our render target texture
-- } )

-- hook.Add( "HUDPaint", "DrawExampleMat", function()
    -- render.PushRenderTarget( tex )
    -- cam.Start2D()

    --     surface.SetDrawColor( 128,128,255 )
    --     surface.DrawRect(0,0,TEX_SIZE, TEX_SIZE)
    --     surface.SetDrawColor( color_white )
    --     surface.SetTexture( txBackground )
        -- local joke = math.sin(CurTime()*5)/4

    --     surface.DrawTexturedRect( TEX_SIZE/4-joke/2, TEX_SIZE/4-joke/2, TEX_SIZE/2+joke, TEX_SIZE/2+joke )

    -- cam.End2D()
    -- render.PopRenderTarget()
    -- surface.SetDrawColor( color_white )
    -- surface.SetMaterial( myMat )
    -- surface.DrawTexturedRect( 25, 25, TEX_SIZE, TEX_SIZE )
    -- print()
    -- DrawTexturedRectRotatedPoint(250+250/2,250+250/2,250,250,(CurTime()%360)*50,0,0)
    -- surface.DrawRect(250,250,250,250)

-- end )
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/cl_lhik.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_grenade.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_heat.lua:
SWEP.NextHeatDissipateTime = 0
SWEP.Heat = 0

function SWEP:GetMaxHeat()
    return self:GetBuff("HeatCapacity")
end

function SWEP:AddHeat(a)
    local single = game.SinglePlayer()
    a = tonumber(a)

    if !(self.Jamming or self:GetBuff_Override("Override_Jamming")) then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("AddHeat", a) end
    -- if !single and !IsFirstTimePredicted() then return end

    local max = self:GetBuff("HeatCapacity")
    local mult = 1 * self:GetBuff_Mult("Mult_FixTime")
    local heat = self:GetHeat()
    local anim = self:SelectAnimation("fix")
    anim = self:GetBuff_Hook("Hook_SelectFixAnim", anim) or anim
    local amount = a or 1
    local t = CurTime() + self:GetAnimKeyTime(anim) * mult
    self.Heat = math.max(0, heat + amount * ArcCW.ConVars["mult_heat"]:GetFloat())

    self.NextHeatDissipateTime = CurTime() + (self:GetBuff("HeatDelayTime"))
    local overheat = self.Heat >= max
    if overheat then
        local h = self:GetBuff_Hook("Hook_Overheat", self.Heat)
        if h == true then overheat = false end
    end
    if overheat then
        self.Heat = math.min(self.Heat, max)
        if self:GetBuff_Override("Override_HeatFix", self.HeatFix) then
            self.NextHeatDissipateTime = t
        elseif self:GetBuff_Override("Override_HeatLockout", self.HeatLockout) then
            self.NextHeatDissipateTime = t
        end
    elseif !self:GetBuff_Override("Override_HeatOverflow", self.HeatOverflow) then
        self.Heat = math.min(self.Heat, max)
    end

    if single and CLIENT then return end

    self:SetHeat(self.Heat)

    if overheat then

        local ret = self:GetBuff_Hook("Hook_OnOverheat")
        if ret then return end

        if anim then
            self:PlayAnimation(anim, mult, true, 0, true)
            self:SetPriorityAnim(t)
            self:SetNextPrimaryFire(t)

            if self:GetBuff_Override("Override_HeatFix", self.HeatFix) then
                self:SetTimer(t - CurTime(),
                function()
                    self:SetHeat(0)
                end)
            end
        end

        if self.HeatLockout or self:GetBuff_Override("Override_HeatLockout") then
            self:SetHeatLocked(true)
        end

        self:GetBuff_Hook("Hook_PostOverheat")
    end
end

function SWEP:DoHeat()
    if self.NextHeatDissipateTime > CurTime() then return end

    --local diss = self.HeatDissipation or 2
    --diss = diss * self:GetBuff_Mult("Mult_HeatDissipation")
    local diss = self:GetBuff("HeatDissipation") or 2
    local ft = FrameTime()
    self.Heat = self:GetHeat() - (ft * diss)

    self.Heat = math.max(self.Heat, 0)

    self:SetHeat(self.Heat)

    if self.Heat <= 0 and self:GetHeatLocked() then
        self:SetHeatLocked(false)
    end
end

function SWEP:HeatEnabled()
    return self.Jamming or self:GetBuff_Override("Override_Jamming")
end

function SWEP:MalfunctionEnabled()
    local cvar = ArcCW.ConVars["malfunction"]:GetInt()
    return cvar == 2 or (cvar == 1 and self:GetBuff_Override("Override_Malfunction", self.Malfunction))
end

function SWEP:GetMalfunctionAnimation()
    local anim = self:SelectAnimation("unjam")
    if !self.Animations[anim] then
        anim = self:SelectAnimation("fix")
        anim = self:GetBuff_Hook("Hook_SelectFixAnim", anim) or anim
    end
    if !self.Animations[anim] then anim = self:SelectAnimation("cycle") end
    if !self.Animations[anim] then anim = nil end
    return anim
end

function SWEP:DoMalfunction(post)

    if !IsFirstTimePredicted() then return end
    if !self:MalfunctionEnabled() then return false end
    local shouldpost = self:GetBuff_Override("Override_MalfunctionPostFire", self.MalfunctionPostFire)
    if post != shouldpost then return false end

    -- Auto calculated malfunction mean
    if self.MalfunctionMean == nil then
        local mm
        if self.Jamming then mm = self.HeatCapacity * 4
        else mm = self.Primary.ClipSize * 8 end

        if self.ManualAction then
            -- Manual guns are less likely to jam
            mm = mm * 2
        else
            -- Burst and semi only guns are less likely to jam
            local a, b = false, false
            for k, v in pairs(self.Firemodes) do
                if !v.Mode then continue end
                if v.Mode == 2 then a = true
                elseif v.Mode < 0 then b = true end
            end
            if !a and b then
                mm = mm * 1.25
            elseif !a and !b then
                mm = mm * 1.5
            end
        end
        self.MalfunctionMean = mm
    end

    local cvar = math.max(ArcCW.ConVars["mult_malfunction"]:GetFloat(), 0.00000001)
    local mean = self:GetBuff("MalfunctionMean") / cvar
    local var = mean * math.Clamp(self:GetBuff("MalfunctionVariance") * math.max(1, math.sqrt(cvar)), 0, 1)
    local count = (self.ShotsSinceMalfunction or 0)

    if !self.NextMalfunction then
        math.randomseed(math.Round(util.SharedRandom(count, -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)))
        self.NextMalfunction = math.ceil(math.sqrt(-2 * var * math.log(math.random())) * math.cos(2 * math.pi * math.random()))
    end

    local ret = self:GetBuff_Hook("Hook_Malfunction", count, true)
    if ret != nil then return ret end

    -- if self:Clip1() <= 1 then return false end -- Don't fucking

    --print(mean, var, count, self.NextMalfunction)
    if count >= self.NextMalfunction + mean then
        local ret2 = self:GetBuff_Hook("Hook_OnMalfunction", count, true)
        if ret2 then return false end

        self:MyEmitSound(self:GetBuff_Override("Override_MalfunctionSound") or self.MalfunctionSound, 75, 100, 1, CHAN_ITEM)

        local wait = self:GetBuff("MalfunctionWait")
        self:SetNextPrimaryFire(CurTime() + wait)

        local anim = self:GetMalfunctionAnimation()
        if !anim or self:GetBuff_Override("Override_MalfunctionJam", self.MalfunctionJam) then
            self:SetMalfunctionJam(true)
        else
            self:SetTimer(wait,
            function()
                self:MalfunctionClear()
            end)
        end

        self:GetBuff_Hook("Hook_PostMalfunction")
        self.ShotsSinceMalfunction = 0
        self.NextMalfunction = nil

        self:SetBurstCount(0)

        return true
    else
        self.ShotsSinceMalfunction = (self.ShotsSinceMalfunction or 0) + 1
        return false
    end
end

function SWEP:MalfunctionClear()

    if self:GetBuff_Override("Override_MalfunctionTakeRound", self.MalfunctionTakeRound) then
        self:TakePrimaryAmmo(self:GetBuff("AmmoPerShot"))
    end

    local anim = self:GetMalfunctionAnimation()
    if anim then
        self:PlayAnimation(anim, self:GetBuff_Mult("Mult_MalfunctionFixTime"), true, 0, true)
        local wait = self:GetAnimKeyTime(anim) - 0.01
        self:SetTimer(wait,
        function()
            self:SetMalfunctionJam(false)
            self:PlayIdleAnimation(true)
        end)
        return true
    else
        self:SetMalfunctionJam(false)
        return false
    end
end
--lua/weapons/arccw_mw2_abase.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = false
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "ArcCW MW2 Sub-Base"
SWEP.Trivia_Class = "California Compliant"
SWEP.Trivia_Desc = "Sub Base"

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_m4_3a.mdl"
SWEP.WorldModel = "models/weapons/w_rif_m4a1.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 0
SWEP.DamageMin = 0
SWEP.Range = 0
SWEP.Penetration = 0
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 0
SWEP.ExtendedClipSize = 0
SWEP.ReducedClipSize = 0

SWEP.Recoil = 0
SWEP.RecoilSide = 0
SWEP.RecoilRise = 0
SWEP.MaxRecoilBlowback = 0
SWEP.VisualRecoilMult = 0
SWEP.RecoilPunch = 0
SWEP.RecoilVMShake = 0
SWEP.RecoilPunchBackMax = 0
SWEP.RecoilPunchBackMaxSights = 0

SWEP.IronSightStruct = {
	Pos = Vector(0, 0, 0),
	Ang = Angle(0, 0, 0),
    ViewModelFOV = 65 / 1.3,
	Magnification = 1.3,
	SwitchToSound = "",
}

--[[SWEP.Hook_ModifyRecoil = function(wep)
	return {
		Recoil = 0,
		RecoilSide = 0,
		VisualRecoilMult = 0,
	}
end]]


SWEP.ShootMechSound = nil


 -- hipfire
 -- maximum accuracy
    SWEP.Inaccuracy_Hip_Max_Stand	= 7
    SWEP.Inaccuracy_Hip_Max_Duck	= 6
    SWEP.Inaccuracy_Hip_Max_Prone	= 5
 -- minimum accuracy
    SWEP.Inaccuracy_Hip_Min_Stand   = 3
    SWEP.Inaccuracy_Hip_Min_Duck    = 2.5
    SWEP.Inaccuracy_Hip_Min_Prone   = 2

 -- sighted fire
 -- yeah
    SWEP.Inaccuracy_ADS = 0

 -- inaccuracy when you're... i don't remember
SWEP.Inaccuracy_Add_ADS			= 0
SWEP.Inaccuracy_Add_Hip			= 0.6
SWEP.Inaccuracy_Add_Move		= 5

 -- how fast to decay inaccuracy
 -- additive
SWEP.Inaccuracy_Hip_Decay_Stand	= 4
SWEP.Inaccuracy_Hip_Decay_Duck	= 1.05
SWEP.Inaccuracy_Hip_Decay_Prone	= 1.1

local idk = 1/45*2

DEFINE_BASECLASS("arccw_base")


function SWEP:DoShootSound(sndoverride, dsndoverride, voloverride, pitchoverride)
    local fsound = self.ShootSound
    local msound = self.ShootMechSound
    local suppressed = self:GetBuff_Override("Silencer")
    if suppressed then
        fsound = self.ShootSoundSilenced
        msound = nil
    end

    fsound = self:GetBuff_Hook("Hook_GetShootSound", fsound)

    local spv    = self.ShootPitchVariation
    local volume = self.ShootVol
    local pitch  = self.ShootPitch * math.Rand(1 - spv, 1 + spv) * self:GetBuff_Mult("Mult_ShootPitch")

    local v = GetConVar("arccw_weakensounds"):GetFloat()
    volume = volume - v

    volume = volume * self:GetBuff_Mult("Mult_ShootVol")

    volume = math.Clamp(volume, 51, 149)
    pitch  = math.Clamp(pitch, 0, 255)

    if sndoverride then fsound = sndoverride end
    if voloverride then volume = voloverride end
    if pitchoverride then pitch = pitchoverride end

    if suppressed then
        pitch = 100
        msound = nil
    end

    if fsound then self:MyEmitSound(fsound, volume, pitch, 1, CHAN_WEAPON) end
    if msound then self:MyEmitSound(msound, 45, math.Rand(95, 105), .45, CHAN_AUTO) end

    local data = {
        sound   = fsound,
        volume  = volume,
        pitch   = pitch,
    }

    self:GetBuff_Hook("Hook_AddShootSound", data)
end


function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )
    
    self:NetworkVar("Bool", 30, "MW2Masterkey_NeedPump")
    self:NetworkVar("Bool", 31, "MW2Masterkey_Reloading")

    self:NetworkVar("Float", 29, "MW2Masterkey_ShellInsertTime")
    self:NetworkVar("Float", 30, "MW2Masterkey_ReloadingTimer")
	--self:NetworkVar("Float", 31, "Inaccuracy")
end
--[[SWEP.Override_NoRandSpread = true
function SWEP:GetDispersion()
	return 0
end
function SWEP:Think()
    if IsValid(self:GetOwner()) and self:GetClass() == "arccw_mw2_abase" then
        self:Remove()
        return
    end
	BaseClass.Think( self )
    local InADS = 1 - self:GetSightDelta()
    local InHip = self:GetSightDelta()

	local Owner = self:GetOwner()

	local max = self.Inaccuracy_Hip_Max_Stand
	local state = self.Inaccuracy_Hip_Min_Stand
	local decay = self.Inaccuracy_Hip_Decay_Stand
    
	if Owner:Crouching() then
		state = self.Inaccuracy_Hip_Min_Duck
		max = self.Inaccuracy_Hip_Max_Duck
		decay = decay + self.Inaccuracy_Hip_Decay_Duck
	end

	local speed    = Owner:GetAbsVelocity():Length()
	local maxspeed = Owner:GetWalkSpeed() * self:GetBuff("SpeedMult")
	speed = math.Clamp(speed / maxspeed, 0, 1)

	state = state + ( speed * self.Inaccuracy_Add_Move * FrameTime() )
	max = max + ( speed * self.Inaccuracy_Add_Move * FrameTime() )

	state = ( ( state * InHip ) + ( self.Inaccuracy_ADS * InADS ) ) * idk
	max = ( ( max * self:GetBuff_Mult("Mult_HipDispersion") * InHip ) + ( self.Inaccuracy_ADS * InADS ) ) * idk

    if self:InBipod() then state = state * ((self.BipodDispersion or 1) * self:GetBuff_Mult("Mult_BipodDispersion") or 0.1)
    max = max * ((self.BipodDispersion or 1) * self:GetBuff_Mult("Mult_BipodDispersion") or 0.1) end

	self:SetInaccuracy( math.Clamp( self:GetInaccuracy() - (decay*idk) * FrameTime(), state, max ) )
end
SWEP.Hook_FireBullets = function(wep, bullet)
	local ro = wep:GetInaccuracy() * wep:GetBuff_Mult("Mult_AccuracyMOA")
	bullet.Dir = wep:GetOwner():GetAimVector() + VectorRand(-ro/2, ro/2	)
	--bullet.Spread = Vector(0, 0, 0)

	wep:SetInaccuracy( wep:GetInaccuracy() + ( wep:GetSightDelta() * (wep.Inaccuracy_Add_Hip*idk) ) + ( (1-wep:GetSightDelta()) * (wep.Inaccuracy_Add_ADS*idk) ) )
	return bullet
end

SWEP.Hook_DrawHUD = function(wep)
    if true then return end
    local mr = math.Round

    surface.SetFont("ArcCW_26")
    surface.SetTextColor(255, 255, 255, 255)

    surface.SetTextPos(ScrW() / 2, 26 * 8)
    surface.DrawText( mr( wep:GetInaccuracy(), 4 ))

    surface.SetTextPos(ScrW() / 2, 26 * 10)
    surface.DrawText( mr( wep:GetInaccuracy() * ( 10 * 180 * 60 ), 0 ) )

    local speed    = wep:GetOwner():GetAbsVelocity():Length()
    local maxspeed = wep:GetOwner():GetWalkSpeed() * wep:GetBuff("SpeedMult")
    speed = math.Clamp(speed / maxspeed, 0, 1)
    surface.SetTextPos(ScrW() / 2, 26 * 12)
    surface.DrawText( mr( speed*100, 0 ).."%" )

    surface.SetFont("ArcCW_8")
    surface.SetTextPos(ScrW() / 2, 26 * 8)
    surface.DrawText("INACCURACY")

    surface.SetTextPos(ScrW() / 2, 26 * 10)
    surface.DrawText("MOA")

    surface.SetTextPos(ScrW() / 2, 26 * 12)
    surface.DrawText("MOVESPEED")
end

local delta = 0
local size = 0
local cw = nil

function SWEP:ShouldDrawCrosshair()
    if GetConVar("arccw_override_crosshair_off"):GetBool() then return false end
    if !GetConVar("arccw_crosshair"):GetBool() then return false end
    if self:GetReloading() then return false end
    local asight = self:GetActiveSights()

    if !self:GetOwner():ShouldDrawLocalPlayer()
            and self:GetState() == ArcCW.STATE_SIGHTS and !asight.CrosshairInSights then
        return false
    end

    if self:GetState() == ArcCW.STATE_SPRINT and !(self:GetBuff_Override("Override_ShootWhileSprint") or self.ShootWhileSprint) then return false end
    if self:GetCurrentFiremode().Mode == 0 then return false end
    if self:GetBuff_Hook("Hook_ShouldNotFire") then return false end
    if self:GetState() == ArcCW.STATE_CUSTOMIZE then return false end

    return true
end

function SWEP:DoDrawCrosshair(x, y)
	local pos = LocalPlayer():EyePos()
	local ang = LocalPlayer():EyeAngles() - self:GetOurViewPunchAngles()
	local dot = true
	local prong_top = true
	local prong_left = true
	local prong_right = true
	local prong_down = true

	local prong_len = GetConVar("arccw_crosshair_length"):GetFloat()
	local prong_wid = GetConVar("arccw_crosshair_thickness"):GetFloat()
	local prong_out = GetConVar("arccw_crosshair_outline"):GetInt()

	local clr = Color(GetConVar("arccw_crosshair_clr_r"):GetInt(),
			GetConVar("arccw_crosshair_clr_g"):GetInt(),
			GetConVar("arccw_crosshair_clr_b"):GetInt())
	if GetConVar("arccw_ttt_rolecrosshair") and GetConVar("arccw_ttt_rolecrosshair"):GetBool() then
		if GetRoundState() == ROUND_PREP or GetRoundState() == ROUND_POST then
			clr = Color(255, 255, 255)
		elseif LocalPlayer().GetRoleColor and LocalPlayer():GetRoleColor() then
			clr = LocalPlayer():GetRoleColor() -- TTT2 feature
		elseif LocalPlayer():IsActiveTraitor() then
			clr = Color(255, 50, 50)
		elseif LocalPlayer():IsActiveDetective() then
			clr = Color(50, 50, 255)
		else
			clr = Color(50, 255, 50)
		end
	end
    if GetConVar("arccw_crosshair_aa"):GetBool() and LocalPlayer().ArcCW_AATarget != nil and GetConVar("arccw_aimassist"):GetBool() and GetConVar("arccw_aimassist_cl"):GetBool() then
            -- whooie
        clr = Color(255, 0, 0)
    end
	clr.a = GetConVar("arccw_crosshair_clr_a"):GetInt()

	local outlineClr = Color(GetConVar("arccw_crosshair_outline_r"):GetInt(),
			GetConVar("arccw_crosshair_outline_g"):GetInt(),
			GetConVar("arccw_crosshair_outline_b"):GetInt(),
			GetConVar("arccw_crosshair_outline_a"):GetInt())

	local gap = ScreenScale(24)
			* (GetConVar("arccw_crosshair_static"):GetBool() and 0.25 or math.Clamp(self:GetInaccuracy() * 10, 0.1, 100))
			* GetConVar("arccw_crosshair_gap"):GetFloat()
	gap = gap + ScreenScale(8) * math.Clamp(self.RecoilAmount, 0, 1)
    gap = gap / 2

	local prong = ScreenScale(prong_len)
	local p_w = ScreenScale(prong_wid)
	local p_w2 = p_w + prong_out

	cw = cw or self

	cam.Start3D()
	local sp = (pos + (ang:Forward() * 3200)):ToScreen()
	cam.End3D()

	x, y = sp.x, sp.y

	local st = self:GetSightTime() / 2

	if self:ShouldDrawCrosshair() then
		delta = math.Approach(delta, 1, RealFrameTime() * 1 / st)
	else
		delta = math.Approach(delta, 0, RealFrameTime() * 1 / st)
	end

	if GetConVar("arccw_crosshair_dot"):GetBool() and dot then
		surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * delta)
		surface.DrawRect(x - p_w2 / 2, y - p_w2 / 2, p_w2, p_w2)

		surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * delta)
		surface.DrawRect(x - p_w / 2, y - p_w / 2, p_w, p_w)
	end

	size = math.Approach(size, gap, RealFrameTime() * 32 * gap)

	if cw != self then
		delta = 0
		size = gap
	end

	cw = self
	gap = size
	local prong2 = prong + prong_out

	surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * delta)

	if prong_left then
		surface.DrawRect(x - gap - prong2 + prong_out / 2, y - p_w2 / 2, prong2, p_w2)
	end
	if prong_right then
		surface.DrawRect(x + gap - prong_out / 2, y - p_w2 / 2, prong2, p_w2)
	end
	if prong_top then
		surface.DrawRect(x - p_w2 / 2, y - gap - prong2 + prong_out / 2, p_w2, prong2)
	end
	if prong_down then
		surface.DrawRect(x - p_w2 / 2, y + gap - prong_out / 2, p_w2, prong2)
	end
		
		surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * delta)

	if prong_left then
		surface.DrawRect(x - gap - prong, y - p_w / 2, prong, p_w)
	end
	if prong_right then
		surface.DrawRect(x + gap, y - p_w / 2, prong, p_w)
	end
	if prong_top then
		surface.DrawRect(x - p_w / 2, y - gap - prong, p_w, prong)
	end
	if prong_down then
		surface.DrawRect(x - p_w / 2, y + gap, p_w, prong)
	end


	return true
end]]
--lua/weapons/arccw_mw2_f2000.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "F2000"
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Fully automatic, all purpose weapon.\n\n\nFish."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_f2000_2a.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-10, 3, -4),
    ang = Angle(-10, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_rif_famas.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 30
SWEP.DamageMin = 20
SWEP.RangeMin = 1500 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Range = 2000 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 7
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 45
SWEP.ReducedClipSize = 15

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.45
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0

SWEP.Delay = 0.065 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 600 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 300

SWEP.Primary.Ammo = "smg1" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/f2000.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/f2000.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/m4_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_4"
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.38
SWEP.SightTime = 0.25

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-3.025, -4.65, 0.881),
    Ang = Angle(-1.201, 0, 0),
    ViewModelFOV = 65 / 1.3,
    Magnification = 1.3,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10.479, 0, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 27

SWEP.AttachmentElements = {
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
    ["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
    ["nocover"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
        WMBodygroups = {},
    },

            ["mw2_ubgl_m203"] = {
                VMBodygroups = {{ind = 2, bg = 1}},
            },
            ["mw2_ubgl_masterkey"] = {
                VMBodygroups = {{ind = 2, bg = 2}},
            },
}

SWEP.ExtraSightDist = 5

SWEP.RejectAttachments = {
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = { "optic" },
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(5.75, 0, 3.35),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(15, 0, 1.55),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "ubgl", "bipod", "mw2_ubgl"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(10, 0, -1.04),
            vang = Angle(0, 0, 0),
        },
        SlideAmount = {
            vmin = Vector(8, 0, 0),
            vmax = Vector(11, 0, 0.8),
        },
        InstalledEles = {"nocover"},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(5, -1.35, 1.25),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(5.4, -0.8, 0.8),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Hook_TranslateAnimation = function(wep, anim)
	local attached = wep.Attachments[3].Installed
	
	-- m203 is 1, masterkey is 2, fgrip is 3
	local attthing
		if 		attached == "mw2_ubgl_m203" 		then attthing = 1
		elseif 	attached == "mw2_ubgl_masterkey" 	then attthing = 2
		elseif 	attached 							then attthing = 3
		else 											 attthing = 0
	end
	
	-- when entering ubgl
	if anim == "enter_ubgl" then
		if attthing == 1 then
			return "switch2_alt_m203"
		elseif attthing == 2 then
			return "switch2_alt_masterkey"
		end
	elseif anim == "exit_ubgl" then
		if attthing == 1 then
			return "switch2_gun_m203"
		elseif attthing == 2 then
			return "switch2_gun_masterkey"
		end
	end
	
    if attthing == 1 and wep:GetInUBGL() then
        return "alt_" .. anim .. "_m203"
		
	elseif attthing == 2 and wep:GetInUBGL() then
        return "alt_" .. anim .. "_masterkey"
		
    elseif attthing == 3 then
        return anim .. "_fgrip"
		
    end
end

SWEP.Animations = {
		["enter_ubgl"] = {
			Source = "idle",
			Time = 0/30
		},
		["exit_ubgl"] = {
			Source = "idle",
			Time = 0/30
		}, 						-- Fuck you.
    ["idle"] = {
        Source = "idle",
        Time = 1/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 33/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 20/30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 35/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_first_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_first_chamber_v1.wav", 	t = 13/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["fire"] = {
        Source = "fire",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 90/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_clipout_v1.wav", 	t = 16/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_clipin_v1.wav", 	    t = 60/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 103/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_clipout_v1.wav", 	t = 15/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_clipin_v1.wav", 	    t = 61/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fn2000_reload_chamber_v1.wav",		t = 76/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
    },
------------------------------------------------
------ Here lies M203 IN THE ANIMATIONS........... ... AWESOME ---
------------------------------------------------
    ["alt_idle_m203"] = {
        Source = "alt_idle_m203",
        Time = 1/30
    },
    ["alt_enter_sprint_m203"] = {
        Source = "alt_sprint_in_m203",
        Time = 11/30
    },
    ["alt_idle_sprint_m203"] = {
        Source = "alt_sprint_loop_m203",
        Time = 31/40
    },
    ["alt_exit_sprint_m203"] = {
        Source = "alt_sprint_out_m203",
        Time = 11/30
    },
    ["alt_draw_m203"] = {
        Source = "alt_pullout_m203",
        Time = 33/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["alt_holster_m203"] = {
        Source = "alt_putaway_m203",
        Time = 20/30,
    },
    ["alt_fire_m203"] = {
        Source = "alt_fire_m203",
        Time = 6/30,
    },
    ["alt_reload_m203"] = {
        Source = "alt_reload_m203",
        Time = 79/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m203_chamber_open_v12.wav", 		t = 12/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m203_load_v12.wav", 	t = 39/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m203_chamber_close_v12.wav", 	t = 60/30},
					},
    },
------------------------------------------------
------ Here lies MASTERKEY IN THE ANIMATIONS........... ... AWESOME ---
------------------------------------------------
    ["alt_idle_masterkey"] = {
        Source = "alt_idle_masterkey",
        Time = 1/30
    },
    ["alt_enter_sprint_masterkey"] = {
        Source = "alt_sprint_in_masterkey",
        Time = 11/30
    },
    ["alt_idle_sprint_masterkey"] = {
        Source = "alt_sprint_loop_masterkey",
        Time = 31/40
    },
    ["alt_exit_sprint_masterkey"] = {
        Source = "alt_sprint_out_masterkey",
        Time = 11/30
    },
    ["alt_draw_masterkey"] = {
        Source = "alt_pullout_masterkey",
        Time = 33/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["alt_holster_masterkey"] = {
        Source = "alt_putaway_masterkey",
        Time = 20/30,
    },
    ["alt_fire_masterkey"] = {
        Source = "alt_fire_masterkey",
        Time = 22/30,
    },
    ["alt_cycle_masterkey"] = {
        Source = "alt_cycle_masterkey",
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 		t = 3/30}},
        Time = 15/30,
    },
    ["alt_reload_start_masterkey"] = {
        Source = "alt_reload_start_masterkey",
        Time = 35/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_shotattach_reload_lift_v1.wav", 		t = 0/30},
						{s = "MW2Common.Masterkey_Load", 		t = 26/30},
					},
    },
    ["alt_reload_loop_masterkey"] = {
        Source = "alt_reload_loop_masterkey",
        Time = 33/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "MW2Common.Masterkey_Load", 	t = 24/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_shotattach_reload_end_v1.wav", 	t = 33/30}, -- end
					},
    },
    ["alt_reload_finish_masterkey"] = {
        Source = "alt_reload_finish_masterkey",
        Time = 50/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						--{s = "MW2Common.Masterkey_Load", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_shotattach_reload_end_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 	t = 22/30},
					},
    },
-----------------------------------------------------
    ["switch2_gun_m203"] = {
        Source = "switch2_gun_m203",
        SoundTable = {{s = "MW2Common.Underbarrel", 		t = 0}},
        Time = 25/30
    },
    ["switch2_alt_m203"] = {
        Source = "switch2_alt_m203",
        SoundTable = {{s = "MW2Common.Underbarrel", 		t = 0}},
        Time = 25/30
    },
    ["switch2_gun_masterkey"] = {
        Source = "switch2_gun_masterkey",
        SoundTable = {{s = "MW2Common.Underbarrel", 		t = 0}},
        Time = 25/30
    },
    ["switch2_alt_masterkey"] = {
        Source = "switch2_alt_masterkey",
        SoundTable = {
						{s = "MW2Common.Underbarrel", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 		t = 14/30},
					},
        Time = 25/30
    },
}
--lua/weapons/arccw_mw2_fal.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.CamAttachment = 3

SWEP.PrintName = "FAL"
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Semi-automatic (single fire)"

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2_2/c_fal.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-5, 3, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_rif_m4a1.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 55
SWEP.DamageMin = 35
SWEP.RangeMin = 1000 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Range = 1500 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 7
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 30
SWEP.ReducedClipSize = 10

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.7
SWEP.RecoilRise = 0.2

SWEP.Delay = 0.079 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 2.5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/fal.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/m4_mp.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/m4_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_4"
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 1

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.38
SWEP.SightTime = 0.25
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.59, -2, 1.09), --
    Ang = Angle(-0.7, 0, 0),
    ViewModelFOV = 65 / 1.3,
    Magnification = 1.3,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10.479, 0, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 27

SWEP.AttachmentElements = {
    ["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
            ["mw2_ubgl_m203"] = {
                VMBodygroups = {{ind = 2, bg = 1}},
            },
            ["mw2_ubgl_masterkey"] = {
                VMBodygroups = {{ind = 2, bg = 2}},
            },
}

SWEP.ExtraSightDist = 5

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.5, 0, 2.4),
            vang = Angle(0, 0, 0),
            wang = Angle(-9.738, 0, 180)
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(29, 0, 1.1),
            vang = Angle(0, 0, 0),
            wpos = Vector(33.719, -2.122, -5.573),
            wang = Angle(0, 6.034, 180)
        },
		WMScale = Vector(1, 1, 1),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "ubgl", "bipod", "mw2_ubgl"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(18.427, 0, -1.04),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-2.461, -6.525, 176.662)
        },
        SlideAmount = {
            vmin = Vector(10, 0, 0.4),
            vmax = Vector(15, 0, 0.4),
            wmin = Vector(20.996, -0.991, -3.837),
            wmax = Vector(13.661, -0.078, -3.837),
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(12.5, -1, 2.25),
            vang = Angle(0, 0, 90),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(4, -0.4, 1.25),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}



SWEP.Hook_TranslateAnimation = function(wep, anim)
	local attached = wep.Attachments[3].Installed
	
	-- m203 is 1, masterkey is 2, fgrip is 3
	local attthing
		if 		attached == "mw2_ubgl_m203" 		then attthing = 1
		elseif 	attached == "mw2_ubgl_masterkey" 	then attthing = 2
		else 											 attthing = 0
	end
    
	-- when entering ubgl
	if anim == "enter_ubgl" then
		if attthing == 1 then
			return "switch2_alt_m203"
		elseif attthing == 2 then
			return "switch2_alt_masterkey"
		end
	elseif anim == "exit_ubgl" then
		if attthing == 1 then
			return "switch2_gun_m203"
		elseif attthing == 2 then
			return "switch2_gun_masterkey"
		end
	end

    if attthing == 1 and wep:GetInUBGL() then
        return "alt_" .. anim .. "_m203"
		elseif attthing == 1 then
			return anim .. "_m203"
		
	elseif attthing == 2 and wep:GetInUBGL() then
        return "alt_" .. anim .. "_masterkey"
		elseif attthing == 2 then
			return anim .. "_masterkey"
		
    end
end

SWEP.Animations = {
		["enter_ubgl"] = {
			Source = "idle",
			Time = 1/30
		},
		["exit_ubgl"] = {
			Source = "idle",
			Time = 1/30
		}, 						-- Fuck you.
    ["idle"] = {
        Source = "idle",
        Time = 0--100/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 32/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 35/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["fire"] = {
        Source = "fire",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 81/30,
        MinProgress = 1.799,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipout_v1.wav", 	t = 29/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipin_v1.wav", 	    t = 47/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 98/30,
        MinProgress = 1.799,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipout_v1.wav", 	t = 34/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipin_v1.wav", 	    t = 50/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_chamber_v1.wav",		t = 69/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
    },
    ["reload_empty_hb"] = {
        Source = "reload_empty_hb",
        Time = 93/30,
        MinProgress = 1.799,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipout_v1.wav", 	t = 33/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipin_v1.wav", 	    t = 48/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_chamber_v1.wav",		t = 67/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
    },
------------------------------------------------
------ Here lies M203 ANIMATIONS ... AWESOME ---
------------------------------------------------
    ["idle_m203"] = {
        Source = "idle_m203",
        Time = 0--100/30
    },
    ["enter_sprint_m203"] = {
        Source = "sprint_in_m203",
        Time = 10/30
    },
    ["idle_sprint_m203"] = {
        Source = "sprint_loop_m203",
        Time = 32/40
    },
    ["exit_sprint_m203"] = {
        Source = "sprint_out_m203",
        Time = 10/30
    },
    ["draw_m203"] = {
        Source = "pullout_m203",
        Time = 36/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["holster_m203"] = {
        Source = "putaway_m203",
        Time = 26/30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["fire_m203"] = {
        Source = "fire_m203",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_m203"] = {
        Source = "fire_ads_m203",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["reload_m203"] = {
        Source = "reload_m203",
        Time = 80/30,
        MinProgress = 1.799,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipout_v1.wav", 	t = 33/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipin_v1.wav", 	    t = 49/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty_m203"] = {
        Source = "reload_empty_m203",
        Time = 98/30,
        MinProgress = 1.799,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipout_v1.wav", 	t = 34/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipin_v1.wav", 	    t = 50/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_chamber_v1.wav",		t = 68/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
    },
------------------------------------------------
------ Here lies M203 IN THE ANIMATIONS........... ... AWESOME ---
------------------------------------------------
    ["alt_idle_m203"] = {
        Source = "alt_idle_m203",
        Time = 1/30
    },
    ["alt_enter_sprint_m203"] = {
        Source = "alt_sprint_in_m203",
        Time = 10/30
    },
    ["alt_idle_sprint_m203"] = {
        Source = "alt_sprint_loop_m203",
        Time = 30/40
    },
    ["alt_exit_sprint_m203"] = {
        Source = "alt_sprint_out_m203",
        Time = 10/30
    },
    ["alt_draw_m203"] = {
        Source = "alt_pullout_m203",
        Time = 30/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["alt_holster_m203"] = {
        Source = "alt_putaway_m203",
        Time = 18/30,
    },
    ["alt_fire_m203"] = {
        Source = "alt_fire_m203",
        Time = 10/30,
    },
    ["alt_reload_m203"] = {
        Source = "alt_reload_m203",
        Time = 78/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m203_chamber_open_v12.wav", 		t = 12/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m203_load_v12.wav", 	t = 39/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m203_chamber_close_v12.wav", 	t = 61/30},
					},
    },
------------------------------------------------
------ Here lies MASTERKEY ANIMATIONS ... AWESOME ---
------------------------------------------------
    ["idle_masterkey"] = {
        Source = "idle_masterkey",
        Time = 0--100/30
    },
    ["enter_sprint_masterkey"] = {
        Source = "sprint_in_masterkey",
        Time = 10/30
    },
    ["idle_sprint_masterkey"] = {
        Source = "sprint_loop_masterkey",
        Time = 32/40
    },
    ["exit_sprint_masterkey"] = {
        Source = "sprint_out_masterkey",
        Time = 10/30
    },
    ["draw_masterkey"] = {
        Source = "pullout_masterkey",
        Time = 36/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["holster_masterkey"] = {
        Source = "putaway_masterkey",
        Time = 23/30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
    },
    ["fire_masterkey"] = {
        Source = "fire_masterkey",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_masterkey"] = {
        Source = "fire_ads_masterkey",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["reload_masterkey"] = {
        Source = "reload_masterkey",
        Time = 80/30,
        MinProgress = 1.799,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipout_v1.wav", 	t = 33/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipin_v1.wav", 	    t = 49/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty_masterkey"] = {
        Source = "reload_empty_masterkey",
        Time = 98/30,
        MinProgress = 1.799,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipout_v1.wav", 	t = 34/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_clipin_v1.wav", 	    t = 50/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_fal_reload_chamber_v1.wav",		t = 68/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
    },
------------------------------------------------
------ Here lies MASTERKEY IN THE ANIMATIONS........... ... AWESOME ---
------------------------------------------------
    ["alt_idle_masterkey"] = {
        Source = "alt_idle_masterkey",
        Time = 1/30
    },
    ["alt_enter_sprint_masterkey"] = {
        Source = "alt_sprint_in_masterkey",
        Time = 10/30
    },
    ["alt_idle_sprint_masterkey"] = {
        Source = "alt_sprint_loop_masterkey",
        Time = 30/40
    },
    ["alt_exit_sprint_masterkey"] = {
        Source = "alt_sprint_out_masterkey",
        Time = 10/30
    },
    ["alt_draw_masterkey"] = {
        Source = "alt_pullout_masterkey",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["alt_holster_masterkey"] = {
        Source = "alt_putaway_masterkey",
        Time = 19/30,
    },
    ["alt_fire_masterkey"] = {
        Source = "alt_fire_masterkey",
        Time = 10/30,
    },
    ["alt_cycle_masterkey"] = {
        Source = "alt_cycle_masterkey",
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 		t = 0/30}},
        Time = 15/30,
    },
    ["alt_reload_start_masterkey"] = {
        Source = "alt_reload_start_masterkey",
        Time = 35/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_shotattach_reload_lift_v1.wav", 		t = 0/30},
						{s = "MW2Common.Masterkey_Load", 		t = 25/30},
					},
    },
    ["alt_reload_loop_masterkey"] = {
        Source = "alt_reload_loop_masterkey",
        Time = 33/40,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "MW2Common.Masterkey_Load", 	t = 24/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_shotattach_reload_end_v1.wav", 	t = 33/30}, -- end
					},
    },
    ["alt_reload_finish_masterkey"] = {
        Source = "alt_reload_finish_masterkey",
        Time = 49/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						--{s = "MW2Common.Masterkey_Load", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 	t = 20/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_shotattach_reload_end_v1.wav", 	t = 33/30},
					},
    },
-----------------------------------------------------
    ["switch2_gun_m203"] = {
        Source = "switch2_gun_m203",
        SoundTable = {{s = "MW2Common.Underbarrel", 		t = 0}},
        Time = 24/30
    },
    ["switch2_alt_m203"] = {
        Source = "switch2_alt_m203",
        SoundTable = {{s = "MW2Common.Underbarrel", 		t = 0}},
        Time = 24/30
    },
    ["switch2_gun_masterkey"] = {
        Source = "switch2_gun_masterkey",
        SoundTable = {{s = "MW2Common.Underbarrel", 		t = 0}},
        Time = 22/30
    },
    ["switch2_alt_masterkey"] = {
        Source = "switch2_alt_masterkey",
        SoundTable = {
						{s = "MW2Common.Underbarrel", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 		t = 14/30},
					},
        Time = 25/30
    },
}
--lua/weapons/arccw_mw2_g18.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "G18"
SWEP.Trivia_Class = "Machine Pistol"
SWEP.Trivia_Desc = "Fully automatic, close range."

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_glock.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-12.5, 3, -2.5),
    ang = Angle(-7, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_pist_glock18.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 30
SWEP.DamageMin = 20
SWEP.Range = 250 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 4
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 33 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 18

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.70
SWEP.RecoilRise = 0.25

SWEP.Delay = 0.054 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = {"weapon_pistol"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 250 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 175

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 110 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/glock.wav"
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/glock.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/usp45_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_4"
SWEP.ShellModel = "models/shells/shell_9mm.mdl"
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 0.2

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.773, 4.524, 0.565),
    Ang = Angle(0.339, 0, 0),
    Magnification = 1.13,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(7, -3, -1)
SWEP.CustomizeAng = Angle(10, 30, 0)

SWEP.CrouchPos = Vector(-3.364, -1.27, -0.802)
SWEP.CrouchAng = Angle(1.12, 0, -21.444)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 18

SWEP.ExtraSightDist = 5

SWEP.AttachmentElements = {
    ["railthegrind"] = {
        VMElements = {
            {
                Model = "models/weapons/arccw/fesiugmw2/atts/pistolrail_1.mdl",
                Bone = "tag_weapon",
                Offset = {
                    pos = Vector(-0.5, -0.025, -0.4),
                    ang = Angle(0, 0, 0),
                }
            }
        },
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = "optic_lp",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-1.2, 0, 2),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"railthegrind"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(4.6, -0.085, 1.1),
            vang = Angle(0, 0, 0),
            wpos = Vector(26.648, 0.782, -8.042),
            wang = Angle(-9.79, 0, 180)
        },
		VMScale = Vector(0.75, 0.75, 0.75),
    },
    {
        PrintName = "Underbarrel",
		Slot = {"foregrip_pistol"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(1.9, 0, -0.5),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-10.216, 0, 180)
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac_pistol",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(3.5, -0.05, 0),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.5, -0.45, 0.2),
            vang = Angle(0, 0, 0),
            wpos = Vector(8, 2.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.35,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.35,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 28/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_first_lift_v1.wav", 	t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_first_chamber_v1.wav", 	t = 12/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.35,
    },
    ["fire"] = {
        Source = "fire",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 69/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_lift_v1.wav", 	t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_clipout_v1.wav", 	t = 13/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_clipin_v1.wav", 	t = 51/30},
					},
        Checkpoints = {36, 126},
        FrameRate = 80,
        LHIK = true,
        LHIKIn = 0.65,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 88/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_lift_v1.wav", 	t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_clipout_v1.wav", 	t = 12/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_clipin_v1.wav", 	t = 51/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_glock_reload_chamber_v1.wav", 	t = 68/30},
					},
        Checkpoints = {36, 126, 178},
        FrameRate = 80,
        LHIK = true,
        LHIKIn = 0.65,
        LHIKOut = 0.6,
    },
}
--lua/weapons/arccw_mw2_masterkey.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2 - Unofficial"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "Masterkey"
SWEP.Trivia_Class = "Shotgun"
SWEP.Trivia_Desc = "Pump action.\nUnofficial."

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_mifl_masterkey_1.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-4, 3, -6),
    ang = Angle(-10, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_shot_m3super90.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 25
SWEP.DamageMin = 0
SWEP.Range = 1750 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 4 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 6
SWEP.ReducedClipSize = 2

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 2
SWEP.RecoilSide = 2

SWEP.ShotgunReload = true
SWEP.ManualAction = true

SWEP.Delay = 10/30 -- 60 / RPM.
SWEP.Num = 6 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        PrintName = "PUMP",
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.NPCWeaponType = "weapon_shotgun"
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 160 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights

SWEP.Primary.Ammo = "buckshot" -- what ammo type the gun uses

SWEP.ShootVol = 120 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/shot_attach.wav"
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/shot_w1200.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/shot_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_m3"
SWEP.ShellModel = "models/shells/shell_12gauge.mdl"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.ShotgunShellSoundsTable
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.9
SWEP.SightTime = 0.2

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.701, 0, 2.279),
    Ang = Angle(2.005, 0, 0),
    ViewModelFOV = 65 / 1.18,
    Magnification = 1.18,
}


SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-0.2, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(5.479, -5, -1.321) + Vector(-0.2, 0, 2)
SWEP.CustomizeAng = Angle(10.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(3, 0, 0) + Vector(0, 2, 2)
SWEP.HolsterAng = Angle(-10, 25, 0)

SWEP.SprintPos = Vector(2.5, -0.75, 1)
SWEP.SprintAng = Angle(-5, 15, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.ExtraSightDist = 5

SWEP.AttachmentElements = {
    ["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
}

SWEP.Attachments = {
	{
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(9.5, -0.05, 0.65),
            vang = Angle(0, 0, 0),
            wang = Angle(-9.738, 0, 180)
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle_shotgun",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(21, -0.075, -0.2),
            vang = Angle(0, 0, 0),
            wpos = Vector(26.648, 0.782, -8.042),
            wang = Angle(-9.79, 0, 180)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "j_pump_shotgun",
        Offset = {
            vpos = Vector(0, 0, -0.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-10.216, 0, 180)
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "j_pump_shotgun",
        Offset = {
            vpos = Vector(2, 0.5, 0),
            vang = Angle(0, 0, -90),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
		VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_shotgun"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(11, -0.4, -0.75),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}


--- no sprint, first deploy and holster for you jidhsfjkhsdfjogGNASJIODNJODAJKOnajiognv-
--- NIGGA SHOE ---
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 2/30,
    },
    ["draw"] = {
        Source = "draw",
        Time = 19/30/2,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire"] = {
        Source = "alt_fire",
        Time = 15/30,
    },
    ["fire_iron"] = {
        Source = "alt_fire",
        Time = 11/30,
    },
    ["cycle"] = {
        Source = "alt_cycle",
        Time = 15/30,
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 		t = 2/30}},
        ShellEjectAt = 2/30,
		MinProgress = 0.333, -- how much time in seconds must pass before the animation can be cancelled
    },
    ["sgreload_start"] = {
        Source = "alt_reload_start",
        Time = (35/30)*0.8,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
		RestoreAmmo = 1, -- only used by shotgun empty insert reload
		-- it's modified, i'm sorry
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_lift_v1.wav", 	t = (0/30)*0.8},
						{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_loop_v1.wav", 	t = (26/30)*0.8},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert"] = {
        Source = "alt_reload_loop",
        Time = (33/30)*0.8,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_loop_v1.wav", 		t = (23/30)*0.8}},
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish"] = {
        Source = "alt_reload_finish",
        Time = (50/30)*0.8,
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 		t = (21/30)*0.8}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.8,
    },
    ["sgreload_finish_empty"] = {
        Source = "alt_reload_finish",
        Time = (50/30)*0.8,
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_pump_v1.wav", 		t = (21/30)*0.8}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.8,
    },
}

 -- Super fucky temp!
 -- S H U T  U P    A N D   K E E P  T H E M   P I N N E D  D O W N  

 -- hipfire
 -- maximum accuracy
    SWEP.Inaccuracy_Hip_Max_Stand	= 7
    SWEP.Inaccuracy_Hip_Max_Duck	= 7
    SWEP.Inaccuracy_Hip_Max_Prone	= 7
 -- minimum accuracy
    SWEP.Inaccuracy_Hip_Min_Stand   = 5
    SWEP.Inaccuracy_Hip_Min_Duck    = 5
    SWEP.Inaccuracy_Hip_Min_Prone   = 5

 -- sighted fire
 -- yeah
    SWEP.Inaccuracy_ADS = 5.5

 -- inaccuracy when you're... i don't remember
SWEP.Inaccuracy_Add_ADS			= 0
SWEP.Inaccuracy_Add_Hip			= 0
SWEP.Inaccuracy_Add_Move		= 0.1
--lua/weapons/arccw_mw2_mp5k.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "MP5K"
SWEP.Trivia_Class = "Sub Machine Gun"
SWEP.Trivia_Desc = "Fully automatic, close range."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_mp5k.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -5),
    ang = Angle(-7, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_smg_mp5.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 25
SWEP.DamageMin = 20
SWEP.Range = 750 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 3
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 45
SWEP.ReducedClipSize = 15

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.4
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0

SWEP.Delay = 0.067 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 10 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 300 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 175

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 95 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/mp5.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/mp5.wav"
SWEP.ShootDrySound =        "weapons/fesiugmw2/fire/dryfire_smg.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/mp5_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_smg"
SWEP.ShellModel = "models/shells/shell_9mm.mdl"
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.80
SWEP.SightTime = 0.2

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.91, -3.79, 0.95),
    Ang = Angle(-0.278, 0.008, 0),
    ViewModelFOV = 65 / 1.18,
    Magnification = 1.18,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10.479, 0, -3.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["grip"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
    ["nors"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        WMBodygroups = {},
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.ExtraSightDist = 5

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_lp"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-4.7, 0, 2.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(1.998, 0.17, -5.025),
            wang = Angle(-3.074, -23.004, -172.249)
        },
        SlideAmount = {
            vmin = Vector(1, 0, 3.9),
            vmax = Vector(6, 0, 3.9),
            wmin = Vector(5.36, 0.739, -5.401),
            wmax = Vector(5.36, 0.739, -5.401),
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(11, 0, 1.9),
            vang = Angle(0, 0, 0),
            wpos = Vector(12.057, 4.317, -3.858),
            wang = Angle(-3.074, -23.004, 0)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "foregrip_mw2exclusive", "bipod", "style_pistol"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(9.5, 0, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(8.425, 2.96, -2.54),
            wang = Angle(-3.074, -23.004, -172.249)
        },
        SlideAmount = {
            vmin = Vector(7, 0, 1),
            vmax = Vector(9, 0, 1),
        },
        Installed = "foregrip_exclusive"
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(8, -1.1, 2),
            vang = Angle(0, 0, 90),
            wpos = Vector(8.425, 3.891, -4.147),
            wang = Angle(-3.074, -23.004, -77.301)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.5, -0.5, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Hook_TranslateAnimation = function(wep, anim)
    if !wep.Attachments[3].Installed then
        return anim .. "_nofg"
    end
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 2/30,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 40/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_hit_v1.wav", 	t = 17/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire"] = {
        Source = "fire",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 75/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 15/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 52/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 90/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 15/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 52/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_chamber_v1.wav", 	t = 68/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
-----------------------------------------------------
-----------------------------------------------------
    ["idle_nofg"] = {
        Source = "idle_nofg",
        Time = 2/30,
    },
    ["enter_sprint_nofg"] = {
        Source = "sprint_in_nofg",
        Time = 10/30
    },
    ["idle_sprint_nofg"] = {
        Source = "sprint_loop_nofg",
        Time = 30/40
    },
    ["exit_sprint_nofg"] = {
        Source = "sprint_out_nofg",
        Time = 10/30
    },
    ["draw_nofg"] = {
        Source = "pullout_nofg",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready_nofg"] = {
        Source = "pullout_first_nofg",
        Time = 40/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_hit_v1.wav", 	t = 17/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster_nofg"] = {
        Source = "putaway_nofg",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire_nofg"] = {
        Source = "fire_nofg",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_nofg"] = {
        Source = "fire_ads_nofg",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["reload_nofg"] = {
        Source = "reload_nofg",
        Time = 75/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 15/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 52/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
    ["reload_empty_nofg"] = {
        Source = "reload_empty_nofg",
        Time = 90/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 15/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 52/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_chamber_v1.wav", 	t = 68/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
}
--lua/weapons/arccw_mw2_mp5n.lua:
return gluapack()()
--lua/weapons/arccw_mw2_ranger.lua:
return gluapack()()
--lua/weapons/arccw_mw2_rpd.lua:
return gluapack()()
--lua/weapons/arccw_ud_m16.lua:
return gluapack()()
--lua/weapons/arccw_ud_car15.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_m16.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Rifles"
end

SWEP.PrintName = "AMCAR-2" -- Stoner Commando is better, fuck you
SWEP.TrueName = "M609"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ud_m16_barrel_10in"
SWEP.Attachments[4].Installed = "ud_m16_muzzle_xm177"
SWEP.Attachments[5].Installed = "ud_m16_receiver_a1"
SWEP.Attachments[6].Installed = "ud_m16_receiver_auto"
SWEP.Attachments[10].Installed = "ud_m16_stock_carbine"

SWEP.NPCWeaponType = "weapon_smg1"
SWEP.Attachments[10].ToggleNum = 2
SWEP.Attachments[10].ToggleLock = true
--lua/weapons/arccw_ud_glock.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.PistolShellSoundsTable

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "GEN3"

-- True name --

SWEP.TrueName = "Glock 17"

-- Trivia --

SWEP.Trivia_Class = "Pistol"
SWEP.Trivia_Desc = [[Handgun originally designed by a curtain rod manufacturer for the Austrian military. Its reliable and cost-effective polymer design has since made it one of the most popular and widely used pistols in the world, common in military, police and civilian use alike.

Great backup weapon due to its quick draw and sight times, but a relatively low damage output makes it a less than ideal primary.]]
SWEP.Trivia_Manufacturer = "Next Generation Weapons Inc."
SWEP.Trivia_Calibre = "9x19mm Parabellum"
SWEP.Trivia_Mechanism = "Short Recoil"
SWEP.Trivia_Country = "Austria"
SWEP.Trivia_Year = 1982

-- Weapon slot --

SWEP.Slot = 1

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Glock Ges.m.b.H."
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_glock.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_glock.mdl"
SWEP.ViewModelFOV = 60
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["9mm"].max -- 4 shot close range kill (3 on chest)
SWEP.DamageMin = ArcCW.UC.StdDmg["9mm"].min -- 5 shot long range kill
SWEP.Penetration = ArcCW.UC.StdDmg["9mm"].pen

SWEP.RangeMin = 15
SWEP.Range = 50 -- 4 shot until ~35m
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 375
SWEP.PhysBulletMuzzleVelocity = 375

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 17
SWEP.ExtendedClipSize = 33
SWEP.ReducedClipSize = 10

-- Recoil --

SWEP.Recoil = 1.0
SWEP.RecoilSide = 0.5

SWEP.RecoilRise = 0.24
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 0.5
SWEP.MaxRecoilPunch = 0.6

SWEP.Sway = 1

-- Firerate / Firemodes --

SWEP.Delay = 60 / 525
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        PrintName = "fcg.safe2",
        Mode = 0,
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_pistol"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 7
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "glock"

SWEP.HeatCapacity = 50
SWEP.HeatDissipation = 20
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 150
SWEP.MalfunctionTakeRound = false

-- Speed multipliers --

SWEP.SpeedMult = 0.975
SWEP.SightedSpeedMult = 0.9
SWEP.SightTime = 0.25
SWEP.ShootSpeedMult = 1

-- Length --

SWEP.BarrelLength = 8
SWEP.ExtraSightDist = 10

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(-0.5, -2, -1)
SWEP.HolsterAng = Angle(3.5, 7, -20)

SWEP.HolsterPos = Vector(-1, -2, 3)
SWEP.HolsterAng = Angle(-15.5, 2, -7)

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.IronSightStruct = {
     Pos = Vector(-2.3, 1, 2.52),
     Ang = Angle(0.3, 0, 0),
     Magnification = 1,
     ViewModelFOV = 55,
     SwitchToSound = ratel, -- sound that plays when switching to this sight
     SwitchFromSound = ratel
}

SWEP.ActivePos = Vector(-0.2, -2, 2)
SWEP.ActiveAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(7, -2, -2)
SWEP.CustomizeAng = Angle(15, 25, 0)

SWEP.CrouchPos = Vector(-2, -6, 1)
SWEP.CrouchAng = Angle(0, 0, -20)

SWEP.BarrelOffsetHip = Vector(3.5, 0, -3)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-10.5, 3.5, -4.8),
    ang        =    Angle(-6, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
}

-- Firing sounds --

local path = ")weapons/arccw_ud/glock/"
local path1 = ")weapons/arccw_ud/uzi/"
local common = ")/arccw_uc/common/"
SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}

SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/9x19/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-9x19-pistol-ext-01.ogg",
    tail .. "fire-dist-9x19-pistol-ext-02.ogg",
    tail .. "fire-dist-9x19-pistol-ext-03.ogg",
    tail .. "fire-dist-9x19-pistol-ext-04.ogg",
    tail .. "fire-dist-9x19-pistol-ext-05.ogg",
    tail .. "fire-dist-9x19-pistol-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg",
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [2] = "glock_bullet1"
}

SWEP.AttachmentElements = {
    ["ud_glock_skin_tan"] = {
        VMSkin = 1,
    },
    ["ud_glock_skin_olive"] = {
        VMSkin = 2,
    },
    ["ud_glock_skin_custom"] = {
        VMSkin = 3,
    },
    ["ud_glock_mag_10"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        AttPosMods = {
            [8] = {
            vpos = Vector(0.1, 1, -1.2),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_frame_subcompact"] = {
        VMBodygroups = {{ind = 0, bg = 2}},
    },
    ["ud_glock_frame_flared"] = {
        VMBodygroups = {{ind = 0, bg = 1}},
    },
    ["ud_glock_mag_33"] = {
        VMBodygroups = {{ind = 1, bg = 2}},
    },
    ["ud_glock_mag_100"] = {
        VMBodygroups = {{ind = 1, bg = 3}},
    },

    ["ud_glock_rail_optic"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_glock_slide_comp"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
        NameChange = "GEN3 Custom",
        TrueNameChange = "Glock 17 Custom",
        Override_IronSightStruct = {
            Pos = Vector(-2.283, 0, 2.506),
            Ang = Angle(0.58, 0, 0),
            Magnification = 1,
        }
    },
    ["ud_glock_slide_lb"] = {
        VMBodygroups = {{ind = 3, bg = 2}},
        NameChange = "GEN3 Extended",
        TrueNameChange = "Glock 17L",
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0, 1.5),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_slide_auto"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
        NameChange = "GEN3 Auto",
        TrueNameChange = "Glock 18C",
    },
    ["ud_glock_slide_subcompact"] = {
        VMBodygroups = {{ind = 3, bg = 8}},
        NameChange = "GEN3K",
        TrueNameChange = "Glock 26",
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0, -0.5),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_slide_cs"] = {
        VMBodygroups = {{ind = 3, bg = 6}},
        NameChange = "GEN3 CS",
        TrueNameChange = "Glock 18CS",
    },
    ["ud_glock_slide_carbine"] = {
        VMBodygroups = {{ind = 3, bg = 4}},
        NameChange = "GEN3 Euro Carbine",
        TrueNameChange = "Glock 17XXXL",
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0, 11.2),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_slide_sd"] = {
        VMBodygroups = {{ind = 3, bg = 5}},
        NameChange = "GEN3 Silent Mistress",
        TrueNameChange = "Glock 17SD",
        GivesFlags = {"sd"},
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.1, 5),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(0, 0.1, 5),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["ud_glock_slide_nytesyte"] = {
        VMBodygroups = {{ind = 3, bg = 7}},
        NameChange = "GEN3 Homeboy",
        TrueNameChange = "Glock 17 NyteSyte",
        AttPosMods = {
            [1] = {
                vpos = Vector(-0.5, 0.05, -0.5),
                vang = Angle(90, 0, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-3.057, 0, 3.397),
            Ang = Angle(0, 0, -90),
            Magnification = 1,
        }
    },
}

local desg_barr = {
    ["ud_glock_slide_auto"] = 1,
    ["ud_glock_slide_lb"] = 2,
    ["ud_glock_slide_carbine"] = 3,
    ["ud_glock_slide_comp"] = 4,
    ["ud_glock_slide_cs"] = 5,
    ["ud_glock_slide_sd"] = 6,
    ["ud_glock_slide_nytesyte"] = 7,
    ["ud_glock_slide_subcompact"] = 8,
}
local desg_cal = {
    ["ud_glock_caliber_40sw"] = 1,
    ["ud_glock_caliber_357sig"] = 2,
    ["ud_glock_caliber_10auto"] = 3,
    ["ud_glock_caliber_45acp"] = 4,
    ["ud_glock_caliber_22lr"] = 5,
    ["ud_glock_caliber_380acp"] = 6,
    ["ud_glock_caliber_460"] = 7,
    ["ud_glock_caliber_50gi"] = 8,
}

SWEP.Hook_NameChange = function(wep,name)
    barrel = desg_barr[wep.Attachments[2].Installed] or 0
    caliber = desg_cal[wep.Attachments[4].Installed] or 0
    trueNames = GetConVar("arccw_truenames"):GetBool()

    start = ""
    mid = ""
    suffix = ""

    if trueNames then
        start = "Glock "

        if caliber == 0 then
            if barrel == 1 then
                mid = "18C"
            elseif barrel == 2 then
                mid = "17L"
            elseif barrel == 5 then
                mid = "18"
            elseif barrel == 8 then
                mid = "26"
            else
                mid = "17"
            end
        else
            if caliber == 1 then
                if barrel == 2 then
                    mid = "24"
                elseif barrel == 8 then
                    mid = "27"
                else
                    mid = "22"
                end
            elseif caliber == 2 then
                if barrel == 8 then
                    mid = "33"
                else
                    mid = "31"
                end
            elseif caliber == 3 then
                if barrel == 2 then
                    mid = "40"
                elseif barrel == 8 then
                    mid = "29"
                else
                    mid = "20"
                end
            elseif caliber == 4 then
                if barrel == 8 then
                    mid = "30"
                else
                    mid = "21"
                end
            elseif caliber == 5 then
                mid = "44"
            elseif caliber == 6 then
                if barrel == 8 then
                    mid = "28"
                else
                    mid = "25"
                end
            elseif caliber == 7 then
                if barrel == 8 then
                    mid = "30"
                else
                    mid = "21"
                end
            elseif caliber == 8 then
                if barrel == 8 then
                    mid = "30"
                else
                    mid = "21"
                end
            end
        end
    else
        start = "GEN"

        if caliber == 0 then
            mid = "3"
        elseif caliber == 1 then
            mid = "5"
        elseif caliber == 2 then
            mid = "6"
        elseif caliber == 3 then
            mid = "8"
        elseif caliber == 4 then
            mid = "11"
        elseif caliber == 5 then
            mid = "22"
        elseif caliber == 6 then
            mid = "15"
        end

        if barrel == 2 then
            suffix = "L"
        elseif barrel == 8 then
            suffix = "K"
        end
    end

    if barrel == 1 and (caliber ~= 0 or !trueNames) then
        suffix = " Auto"
    elseif barrel == 2 and !trueNames then
        suffix = "L"
    elseif barrel == 3 then
        if trueNames then
            suffix = "XXXL"
        else
            suffix = " Euro Carbine"
        end
    elseif barrel == 4 then
        suffix = " Custom"
    elseif barrel == 5 then
        suffix = "CS"
    elseif barrel == 6 then
        if trueNames then
            suffix = " Hush Puppy"
        else
            suffix = " Silent Mistress"
        end
    elseif barrel == 7 then
        if trueNames then
            suffix = " NyteSyte"
        else
            suffix = " Homeboy"
        end
    end

    -- Todo: Subcompact variants when the barrel variant comes out
    return start .. mid .. suffix
end

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

-- CHAN_ITEM doesn't sound too right
local ci = CHAN_AUTO
local ratel = {path .. "pistol_rattle_1.ogg", path .. "pistol_rattle_2.ogg", path .. "pistol_rattle_3.ogg"}
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}

SWEP.Animations = {
    ["ready"] = {
        Source = "fix_100",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            {s = common .. "raise.ogg", t = 0.05},
            {s = ratel, t = 0},
            {s = path .. "slide_pull_new.ogg",  t = 0.4, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.4, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.6, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            {s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 12 / 30,
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            {s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0,
        LHIKOut = 0,
        SoundTable = {
            {s = common .. "cloth_2.ogg", t = 0},
            {s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = 12 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0,
        LHIKOut = 0,
        SoundTable = {
            {s = common .. "cloth_2.ogg", t = 0},
            {s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },
    ["fire"] = {
        Source = "fire",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.5 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Not Temporary
        },
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Not Temporary
        },
    },
    ["fire_stock"] = {
        Source = "fire_stock",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0.03 }},
    },
    ["fire_empty_stock"] = {
        Source = "fire_empty_stock",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0, c = ci}, -- Not Temporary
        },
    },
    ["fire_cycle"] = {
        Source = "fire_cycle",
        Time = 16 / 30,
    },

    ["fix"] = {
        Source = "fix",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.7, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty"] = {
        Source = "fix_empty",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_10"] = {
        Source = "fix_10",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.7, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty_10"] = {
        Source = "fix_empty_10",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_33"] = {
        Source = "fix_33",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.7, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty_33"] = {
        Source = "fix_empty_33",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_100"] = {
        Source = "fix_100",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "slide_pull_new.ogg",  t = 0.4, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.4, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.6, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty_100"] = {
        Source = "cycle_empty",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },

    ["cycle"] = {
        Source = "cycle",
        Time = 32 / 30,
        ShellEjectAt = 0.4,
        SoundTable = {
            {s = rottle, t = 0, v = 50},
            {s = path .. "slide_pull_new.ogg",  t = 0.3, c = ci, v = 50},
            {s = path .. "sliderel_deact.ogg",  t = 0.3, c = ci, v = 50},
            {s = path .. "slide_rel_new.ogg",        t = 0.55, c = ci, v = 50},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["cycle_empty"] = {
        Source = "cycle_empty",
        Time = 32 / 30,
        ShellEjectAt = 0.4,
        SoundTable = {
            {s = rottle, t = 0, v = 50},
            {s = path .. "slide_pull_new.ogg",  t = 0.3, c = ci, v = 50},
            {s = path .. "sliderel_deact.ogg",  t = 0.3, c = ci, v = 50},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },

    -- 17 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch_pull_small.ogg", t = 0.075},
            {s = ratel, t = 0.3},
            {s = path .. "magout_partial.ogg",        t = 0.35, c = ci},
            {s = ratel, t = 0.4},
            {s = path .. "magin_new.ogg",         t = 0.45, c = ci},
            {s = rottle, t = 0.6},
            {s = common .. "magpouch_replace_small.ogg", t = 1.25},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 65 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magout_empty.ogg",        t = 0.13, c = ci},
            {s = common .. "magpouch_pull_small.ogg", t = 0.35},
            {s = path .. "magin_new.ogg",         t = 0.5, v = 1.5},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = rottle, t = 1.15},
            {s = path .. "chamber.ogg",      t = 1.39},
        },
    },
    ["reload_empty_fesiug"] = {
        Source = "reload_empty_fesiug",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 78 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magout_empty.ogg",        t = 0.13, c = ci},
            {s = common .. "magpouch_pull_small.ogg", t = 0.35},
            {s = path .. "magin_new.ogg",         t = 0.55, c = ci},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = ratel, t = 1.2},
            {s = path .. "sliderel_deact.ogg",  t = 1.62, c = ci},
            {s = path .. "chamber.ogg",        t = 1.85, v = 1.5},
            {s = rottle, t = 1.9},
        },
    },

    -- 10 Round Reloads --

    ["reload_10"] = {
        Source = "reload_10",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "magpouch_pull_small.ogg", t = 0.025, c = ci},
            {s = ratel, t = 0.3},
            {s = path .. "magout_partial.ogg",        t = 0.2, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.33, v = 1.5},
            {s = common .. "magpouch_replace_small.ogg", t = 1.2},
            {s = rottle, t = 0.65},
        },
    },
    ["reload_empty_10"] = {
        Source = "reload_empty_10",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 65 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",    t = 0.15, c = ci},
            {s = path .. "magout_empty.ogg",        t = 0.1, c = ci},
            {s = common .. "magpouch_pull_small.ogg", t = 0.3, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.45, c = ci},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = rottle, t = 0.9},
            {s = path .. "chamber.ogg",      t = 1.35, c = ci},
        },
    },

    -- 33 Round Reloads --

    ["reload_33"] = {
        Source = "reload_33",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = ratel, t = 0.3},
            {s = path .. "magout_partial.ogg",        t = 0.4, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.49},
            {s = rottle, t = 0.75},
            {s = common .. "magpouchin.ogg", t = 1.25, v = .35},
        },
    },
    ["reload_empty_33"] = {
        Source = "reload_empty_33",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 66 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",    t = 0.16, c = ci},
            {s = path .. "magout_empty.ogg",        t = 0.16, c = ci},
            {s = common .. "magpouch.ogg", t = 0.35, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.55, c = ci},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = rottle, t = 1.3},
            {s = path .. "chamber.ogg",      t = 1.42, c = ci},
        },
    },

    -- 100 Round Reloads --

    ["reload_100"] = {
        Source = "reload_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.3,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",    t = 0.3, c = ci},
            {s = path .. "magout.ogg",        t = 0.3, c = ci},
            {s = ratel, t = 0.7},
            {s = path .. "magin.ogg",         t = 1.0, c = ci},
            {s = rottle, t = 1.1},
        },
    },
    ["reload_empty_100"] = {
        Source = "reload_empty_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 66 / 30,
        MinProgress = 1.75,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",      t = 0.12, c = ci},
            {s = path .. "magout.ogg",        t = 0.12, c = ci},
            {s = path .. "magin.ogg",           t = 0.5, c = ci},
            {s = common .. "magdrop.ogg",  t = 0.55},
            {s = ratel, t = 0.7},
            {s = path .. "sliderel_deact.ogg",  t = 1.33, c = ci},
            {s = path .. "chamber.ogg",        t = 1.525, c = ci},
            {s = rottle, t = 1.6},
        },
    },
}

SWEP.AutosolveSourceSeq = "idle"

SWEP.Hook_TranslateAnimation = function(wep, anim)
    if wep.Attachments[9].Installed and (anim == "fire" or anim == "fire_empty") then
        return anim .. "_stock"
    end
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp"},
        Bone = "glock_slide",
        Offset = {
            vpos = Vector(-0.025, -0.4, -0.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0.02),
        VMScale = Vector(.9, .9, .9),
        WMScale = VMScale,
        --WMScale = Vector(1.25, 1.25, 1.25),
        --InstalledEles = {"ud_glock_rail_optic"},
    },
    {
        PrintName = "Slide",
        DefaultAttName = "Standard Slide",
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_slide.png", "smooth mips"),
        Slot = "ud_glock_slide",
        Bone = "glock_flash",
        Offset = {
            vpos = Vector(2.4, -0.2, -29.2), -- Op. CS slide
            vang = Angle(90, 3, -90),
        },
    },
    {
        PrintName = "Frame",
        DefaultAttName = "Standard Frame",
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_frame.png", "smooth mips"),
        Slot = "ud_glock_frame",
    },
    {
        PrintName = "Caliber",
        DefaultAttName = "9x19mm Parabellum",
        DefaultAttIcon = Material("entities/att/uc_bullets/9x19.png", "smooth mips"),
        Slot = "ud_glock_caliber",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "ud_glock_muzzle"},
        Bone = "glock_flash",
        Offset = {
            vpos = Vector(0, 0, 0.0),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"},
        VMScale = Vector(0.8, 0.8, 0.8)
    },
    {
        PrintName = "Tactical",
        Slot = {"tac_pistol", "uce_pistol_foregrip"},
        Bone = "glock_parent",
        Offset = {
            vpos = Vector(0, -1.3, 5),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {7},
        ExcludeFlags = {"ud_glock_slide_subcompact"}
    },
    {
        Hidden = true,
        PrintName = "Tactical",
        Slot = {"tac_pistol"},
        Bone = "glock_parent",
        Offset = {
            vpos = Vector(0, -1.3, 5),
            vang = Angle(90, 0, -90),
        }, -- This slot is obsolete and exists solely for compatiblity with old loadouts. Do not remove.
    },
    {
        PrintName = "Magazine",
        Slot = {"ud_glock_mag"},
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_mag_17.png", "smooth mips"),
        DefaultAttName = "17-Round Mag",
    },
    {
        PrintName = "Stock",
        Slot = {"uc_stock", "go_stock_pistol_bt"},
        DefaultAttName = "No Stock",
        Bone = "glock_parent",
        Offset = {
            vpos = Vector(0.1, 2, -1.4),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"ud_glock_frame_subcompact"}
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "glock_slide",
        Offset = {
            vpos = Vector(0.45, 0.1, 4),
            vang = Angle(90, 0, -90),
        },
        VMScale = Vector(0.8, 0.8, 0.8),
    },
    {
        PrintName = "Material",
        DefaultAttName = "Black Polymer",
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_material.png", "smooth mips"),
        Slot = "ud_glock_skin",
        FreeSlot = true,
    },
}
--lua/weapons/arccw_ud_glock.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.PistolShellSoundsTable

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "GEN3"

-- True name --

SWEP.TrueName = "Glock 17"

-- Trivia --

SWEP.Trivia_Class = "Pistol"
SWEP.Trivia_Desc = [[Handgun originally designed by a curtain rod manufacturer for the Austrian military. Its reliable and cost-effective polymer design has since made it one of the most popular and widely used pistols in the world, common in military, police and civilian use alike.

Great backup weapon due to its quick draw and sight times, but a relatively low damage output makes it a less than ideal primary.]]
SWEP.Trivia_Manufacturer = "Next Generation Weapons Inc."
SWEP.Trivia_Calibre = "9x19mm Parabellum"
SWEP.Trivia_Mechanism = "Short Recoil"
SWEP.Trivia_Country = "Austria"
SWEP.Trivia_Year = 1982

-- Weapon slot --

SWEP.Slot = 1

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Glock Ges.m.b.H."
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_glock.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_glock.mdl"
SWEP.ViewModelFOV = 60
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["9mm"].max -- 4 shot close range kill (3 on chest)
SWEP.DamageMin = ArcCW.UC.StdDmg["9mm"].min -- 5 shot long range kill
SWEP.Penetration = ArcCW.UC.StdDmg["9mm"].pen

SWEP.RangeMin = 15
SWEP.Range = 50 -- 4 shot until ~35m
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 375
SWEP.PhysBulletMuzzleVelocity = 375

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 17
SWEP.ExtendedClipSize = 33
SWEP.ReducedClipSize = 10

-- Recoil --

SWEP.Recoil = 1.0
SWEP.RecoilSide = 0.5

SWEP.RecoilRise = 0.24
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 0.5
SWEP.MaxRecoilPunch = 0.6

SWEP.Sway = 1

-- Firerate / Firemodes --

SWEP.Delay = 60 / 525
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        PrintName = "fcg.safe2",
        Mode = 0,
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_pistol"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 7
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "glock"

SWEP.HeatCapacity = 50
SWEP.HeatDissipation = 20
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 150
SWEP.MalfunctionTakeRound = false

-- Speed multipliers --

SWEP.SpeedMult = 0.975
SWEP.SightedSpeedMult = 0.9
SWEP.SightTime = 0.25
SWEP.ShootSpeedMult = 1

-- Length --

SWEP.BarrelLength = 8
SWEP.ExtraSightDist = 10

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(-0.5, -2, -1)
SWEP.HolsterAng = Angle(3.5, 7, -20)

SWEP.HolsterPos = Vector(-1, -2, 3)
SWEP.HolsterAng = Angle(-15.5, 2, -7)

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.IronSightStruct = {
     Pos = Vector(-2.3, 1, 2.52),
     Ang = Angle(0.3, 0, 0),
     Magnification = 1,
     ViewModelFOV = 55,
     SwitchToSound = ratel, -- sound that plays when switching to this sight
     SwitchFromSound = ratel
}

SWEP.ActivePos = Vector(-0.2, -2, 2)
SWEP.ActiveAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(7, -2, -2)
SWEP.CustomizeAng = Angle(15, 25, 0)

SWEP.CrouchPos = Vector(-2, -6, 1)
SWEP.CrouchAng = Angle(0, 0, -20)

SWEP.BarrelOffsetHip = Vector(3.5, 0, -3)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-10.5, 3.5, -4.8),
    ang        =    Angle(-6, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
}

-- Firing sounds --

local path = ")weapons/arccw_ud/glock/"
local path1 = ")weapons/arccw_ud/uzi/"
local common = ")/arccw_uc/common/"
SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}

SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/9x19/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-9x19-pistol-ext-01.ogg",
    tail .. "fire-dist-9x19-pistol-ext-02.ogg",
    tail .. "fire-dist-9x19-pistol-ext-03.ogg",
    tail .. "fire-dist-9x19-pistol-ext-04.ogg",
    tail .. "fire-dist-9x19-pistol-ext-05.ogg",
    tail .. "fire-dist-9x19-pistol-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg",
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [2] = "glock_bullet1"
}

SWEP.AttachmentElements = {
    ["ud_glock_skin_tan"] = {
        VMSkin = 1,
    },
    ["ud_glock_skin_olive"] = {
        VMSkin = 2,
    },
    ["ud_glock_skin_custom"] = {
        VMSkin = 3,
    },
    ["ud_glock_mag_10"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        AttPosMods = {
            [8] = {
            vpos = Vector(0.1, 1, -1.2),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_frame_subcompact"] = {
        VMBodygroups = {{ind = 0, bg = 2}},
    },
    ["ud_glock_frame_flared"] = {
        VMBodygroups = {{ind = 0, bg = 1}},
    },
    ["ud_glock_mag_33"] = {
        VMBodygroups = {{ind = 1, bg = 2}},
    },
    ["ud_glock_mag_100"] = {
        VMBodygroups = {{ind = 1, bg = 3}},
    },

    ["ud_glock_rail_optic"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_glock_slide_comp"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
        NameChange = "GEN3 Custom",
        TrueNameChange = "Glock 17 Custom",
        Override_IronSightStruct = {
            Pos = Vector(-2.283, 0, 2.506),
            Ang = Angle(0.58, 0, 0),
            Magnification = 1,
        }
    },
    ["ud_glock_slide_lb"] = {
        VMBodygroups = {{ind = 3, bg = 2}},
        NameChange = "GEN3 Extended",
        TrueNameChange = "Glock 17L",
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0, 1.5),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_slide_auto"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
        NameChange = "GEN3 Auto",
        TrueNameChange = "Glock 18C",
    },
    ["ud_glock_slide_subcompact"] = {
        VMBodygroups = {{ind = 3, bg = 8}},
        NameChange = "GEN3K",
        TrueNameChange = "Glock 26",
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0, -0.5),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_slide_cs"] = {
        VMBodygroups = {{ind = 3, bg = 6}},
        NameChange = "GEN3 CS",
        TrueNameChange = "Glock 18CS",
    },
    ["ud_glock_slide_carbine"] = {
        VMBodygroups = {{ind = 3, bg = 4}},
        NameChange = "GEN3 Euro Carbine",
        TrueNameChange = "Glock 17XXXL",
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0, 11.2),
                vang = Angle(90, 0, -90),
            }
        }
    },
    ["ud_glock_slide_sd"] = {
        VMBodygroups = {{ind = 3, bg = 5}},
        NameChange = "GEN3 Silent Mistress",
        TrueNameChange = "Glock 17SD",
        GivesFlags = {"sd"},
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.1, 5),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(0, 0.1, 5),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["ud_glock_slide_nytesyte"] = {
        VMBodygroups = {{ind = 3, bg = 7}},
        NameChange = "GEN3 Homeboy",
        TrueNameChange = "Glock 17 NyteSyte",
        AttPosMods = {
            [1] = {
                vpos = Vector(-0.5, 0.05, -0.5),
                vang = Angle(90, 0, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-3.057, 0, 3.397),
            Ang = Angle(0, 0, -90),
            Magnification = 1,
        }
    },
}

local desg_barr = {
    ["ud_glock_slide_auto"] = 1,
    ["ud_glock_slide_lb"] = 2,
    ["ud_glock_slide_carbine"] = 3,
    ["ud_glock_slide_comp"] = 4,
    ["ud_glock_slide_cs"] = 5,
    ["ud_glock_slide_sd"] = 6,
    ["ud_glock_slide_nytesyte"] = 7,
    ["ud_glock_slide_subcompact"] = 8,
}
local desg_cal = {
    ["ud_glock_caliber_40sw"] = 1,
    ["ud_glock_caliber_357sig"] = 2,
    ["ud_glock_caliber_10auto"] = 3,
    ["ud_glock_caliber_45acp"] = 4,
    ["ud_glock_caliber_22lr"] = 5,
    ["ud_glock_caliber_380acp"] = 6,
    ["ud_glock_caliber_460"] = 7,
    ["ud_glock_caliber_50gi"] = 8,
}

SWEP.Hook_NameChange = function(wep,name)
    barrel = desg_barr[wep.Attachments[2].Installed] or 0
    caliber = desg_cal[wep.Attachments[4].Installed] or 0
    trueNames = GetConVar("arccw_truenames"):GetBool()

    start = ""
    mid = ""
    suffix = ""

    if trueNames then
        start = "Glock "

        if caliber == 0 then
            if barrel == 1 then
                mid = "18C"
            elseif barrel == 2 then
                mid = "17L"
            elseif barrel == 5 then
                mid = "18"
            elseif barrel == 8 then
                mid = "26"
            else
                mid = "17"
            end
        else
            if caliber == 1 then
                if barrel == 2 then
                    mid = "24"
                elseif barrel == 8 then
                    mid = "27"
                else
                    mid = "22"
                end
            elseif caliber == 2 then
                if barrel == 8 then
                    mid = "33"
                else
                    mid = "31"
                end
            elseif caliber == 3 then
                if barrel == 2 then
                    mid = "40"
                elseif barrel == 8 then
                    mid = "29"
                else
                    mid = "20"
                end
            elseif caliber == 4 then
                if barrel == 8 then
                    mid = "30"
                else
                    mid = "21"
                end
            elseif caliber == 5 then
                mid = "44"
            elseif caliber == 6 then
                if barrel == 8 then
                    mid = "28"
                else
                    mid = "25"
                end
            elseif caliber == 7 then
                if barrel == 8 then
                    mid = "30"
                else
                    mid = "21"
                end
            elseif caliber == 8 then
                if barrel == 8 then
                    mid = "30"
                else
                    mid = "21"
                end
            end
        end
    else
        start = "GEN"

        if caliber == 0 then
            mid = "3"
        elseif caliber == 1 then
            mid = "5"
        elseif caliber == 2 then
            mid = "6"
        elseif caliber == 3 then
            mid = "8"
        elseif caliber == 4 then
            mid = "11"
        elseif caliber == 5 then
            mid = "22"
        elseif caliber == 6 then
            mid = "15"
        end

        if barrel == 2 then
            suffix = "L"
        elseif barrel == 8 then
            suffix = "K"
        end
    end

    if barrel == 1 and (caliber ~= 0 or !trueNames) then
        suffix = " Auto"
    elseif barrel == 2 and !trueNames then
        suffix = "L"
    elseif barrel == 3 then
        if trueNames then
            suffix = "XXXL"
        else
            suffix = " Euro Carbine"
        end
    elseif barrel == 4 then
        suffix = " Custom"
    elseif barrel == 5 then
        suffix = "CS"
    elseif barrel == 6 then
        if trueNames then
            suffix = " Hush Puppy"
        else
            suffix = " Silent Mistress"
        end
    elseif barrel == 7 then
        if trueNames then
            suffix = " NyteSyte"
        else
            suffix = " Homeboy"
        end
    end

    -- Todo: Subcompact variants when the barrel variant comes out
    return start .. mid .. suffix
end

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

-- CHAN_ITEM doesn't sound too right
local ci = CHAN_AUTO
local ratel = {path .. "pistol_rattle_1.ogg", path .. "pistol_rattle_2.ogg", path .. "pistol_rattle_3.ogg"}
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}

SWEP.Animations = {
    ["ready"] = {
        Source = "fix_100",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            {s = common .. "raise.ogg", t = 0.05},
            {s = ratel, t = 0},
            {s = path .. "slide_pull_new.ogg",  t = 0.4, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.4, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.6, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            {s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 12 / 30,
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            {s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0,
        LHIKOut = 0,
        SoundTable = {
            {s = common .. "cloth_2.ogg", t = 0},
            {s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = 12 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0,
        LHIKOut = 0,
        SoundTable = {
            {s = common .. "cloth_2.ogg", t = 0},
            {s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },
    ["fire"] = {
        Source = "fire",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.5 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Not Temporary
        },
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Not Temporary
        },
    },
    ["fire_stock"] = {
        Source = "fire_stock",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0.03 }},
    },
    ["fire_empty_stock"] = {
        Source = "fire_empty_stock",
        Time = 16 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0, c = ci}, -- Not Temporary
        },
    },
    ["fire_cycle"] = {
        Source = "fire_cycle",
        Time = 16 / 30,
    },

    ["fix"] = {
        Source = "fix",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.7, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty"] = {
        Source = "fix_empty",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_10"] = {
        Source = "fix_10",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.7, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty_10"] = {
        Source = "fix_empty_10",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_33"] = {
        Source = "fix_33",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.7, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty_33"] = {
        Source = "fix_empty_33",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = path .. "magtap.ogg",    t = 0.18, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_100"] = {
        Source = "fix_100",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "slide_pull_new.ogg",  t = 0.4, c = ci},
            {s = path .. "sliderel_deact.ogg",  t = 0.4, c = ci},
            {s = path .. "slide_rel_new.ogg",        t = 0.6, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["fix_empty_100"] = {
        Source = "cycle_empty",
        Time = 40 / 30,
        ShellEjectAt = false,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "sliderel_deact.ogg",  t = 0.5, c = ci},
            {s = path .. "slide_pull_new.ogg",  t = 0.5, c = ci},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },

    ["cycle"] = {
        Source = "cycle",
        Time = 32 / 30,
        ShellEjectAt = 0.4,
        SoundTable = {
            {s = rottle, t = 0, v = 50},
            {s = path .. "slide_pull_new.ogg",  t = 0.3, c = ci, v = 50},
            {s = path .. "sliderel_deact.ogg",  t = 0.3, c = ci, v = 50},
            {s = path .. "slide_rel_new.ogg",        t = 0.55, c = ci, v = 50},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },
    ["cycle_empty"] = {
        Source = "cycle_empty",
        Time = 32 / 30,
        ShellEjectAt = 0.4,
        SoundTable = {
            {s = rottle, t = 0, v = 50},
            {s = path .. "slide_pull_new.ogg",  t = 0.3, c = ci, v = 50},
            {s = path .. "sliderel_deact.ogg",  t = 0.3, c = ci, v = 50},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.1,
        LHIKOut = 0.2,
    },

    -- 17 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch_pull_small.ogg", t = 0.075},
            {s = ratel, t = 0.3},
            {s = path .. "magout_partial.ogg",        t = 0.35, c = ci},
            {s = ratel, t = 0.4},
            {s = path .. "magin_new.ogg",         t = 0.45, c = ci},
            {s = rottle, t = 0.6},
            {s = common .. "magpouch_replace_small.ogg", t = 1.25},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 65 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magout_empty.ogg",        t = 0.13, c = ci},
            {s = common .. "magpouch_pull_small.ogg", t = 0.35},
            {s = path .. "magin_new.ogg",         t = 0.5, v = 1.5},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = rottle, t = 1.15},
            {s = path .. "chamber.ogg",      t = 1.39},
        },
    },
    ["reload_empty_fesiug"] = {
        Source = "reload_empty_fesiug",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 78 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magout_empty.ogg",        t = 0.13, c = ci},
            {s = common .. "magpouch_pull_small.ogg", t = 0.35},
            {s = path .. "magin_new.ogg",         t = 0.55, c = ci},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = ratel, t = 1.2},
            {s = path .. "sliderel_deact.ogg",  t = 1.62, c = ci},
            {s = path .. "chamber.ogg",        t = 1.85, v = 1.5},
            {s = rottle, t = 1.9},
        },
    },

    -- 10 Round Reloads --

    ["reload_10"] = {
        Source = "reload_10",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "magpouch_pull_small.ogg", t = 0.025, c = ci},
            {s = ratel, t = 0.3},
            {s = path .. "magout_partial.ogg",        t = 0.2, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.33, v = 1.5},
            {s = common .. "magpouch_replace_small.ogg", t = 1.2},
            {s = rottle, t = 0.65},
        },
    },
    ["reload_empty_10"] = {
        Source = "reload_empty_10",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 65 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",    t = 0.15, c = ci},
            {s = path .. "magout_empty.ogg",        t = 0.1, c = ci},
            {s = common .. "magpouch_pull_small.ogg", t = 0.3, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.45, c = ci},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = rottle, t = 0.9},
            {s = path .. "chamber.ogg",      t = 1.35, c = ci},
        },
    },

    -- 33 Round Reloads --

    ["reload_33"] = {
        Source = "reload_33",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = ratel, t = 0.3},
            {s = path .. "magout_partial.ogg",        t = 0.4, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.49},
            {s = rottle, t = 0.75},
            {s = common .. "magpouchin.ogg", t = 1.25, v = .35},
        },
    },
    ["reload_empty_33"] = {
        Source = "reload_empty_33",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 66 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",    t = 0.16, c = ci},
            {s = path .. "magout_empty.ogg",        t = 0.16, c = ci},
            {s = common .. "magpouch.ogg", t = 0.35, c = ci},
            {s = path .. "magin_new.ogg",         t = 0.55, c = ci},
            {s = ratel, t = 0.5},
            {s = common .. "pistol_magdrop.ogg",  t = 0.65},
            {s = rottle, t = 1.3},
            {s = path .. "chamber.ogg",      t = 1.42, c = ci},
        },
    },

    -- 100 Round Reloads --

    ["reload_100"] = {
        Source = "reload_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 56 / 30,
        MinProgress = 1.3,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",    t = 0.3, c = ci},
            {s = path .. "magout.ogg",        t = 0.3, c = ci},
            {s = ratel, t = 0.7},
            {s = path .. "magin.ogg",         t = 1.0, c = ci},
            {s = rottle, t = 1.1},
        },
    },
    ["reload_empty_100"] = {
        Source = "reload_empty_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 66 / 30,
        MinProgress = 1.75,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.3,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "magrelease.ogg",      t = 0.12, c = ci},
            {s = path .. "magout.ogg",        t = 0.12, c = ci},
            {s = path .. "magin.ogg",           t = 0.5, c = ci},
            {s = common .. "magdrop.ogg",  t = 0.55},
            {s = ratel, t = 0.7},
            {s = path .. "sliderel_deact.ogg",  t = 1.33, c = ci},
            {s = path .. "chamber.ogg",        t = 1.525, c = ci},
            {s = rottle, t = 1.6},
        },
    },
}

SWEP.AutosolveSourceSeq = "idle"

SWEP.Hook_TranslateAnimation = function(wep, anim)
    if wep.Attachments[9].Installed and (anim == "fire" or anim == "fire_empty") then
        return anim .. "_stock"
    end
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp"},
        Bone = "glock_slide",
        Offset = {
            vpos = Vector(-0.025, -0.4, -0.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0.02),
        VMScale = Vector(.9, .9, .9),
        WMScale = VMScale,
        --WMScale = Vector(1.25, 1.25, 1.25),
        --InstalledEles = {"ud_glock_rail_optic"},
    },
    {
        PrintName = "Slide",
        DefaultAttName = "Standard Slide",
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_slide.png", "smooth mips"),
        Slot = "ud_glock_slide",
        Bone = "glock_flash",
        Offset = {
            vpos = Vector(2.4, -0.2, -29.2), -- Op. CS slide
            vang = Angle(90, 3, -90),
        },
    },
    {
        PrintName = "Frame",
        DefaultAttName = "Standard Frame",
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_frame.png", "smooth mips"),
        Slot = "ud_glock_frame",
    },
    {
        PrintName = "Caliber",
        DefaultAttName = "9x19mm Parabellum",
        DefaultAttIcon = Material("entities/att/uc_bullets/9x19.png", "smooth mips"),
        Slot = "ud_glock_caliber",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "ud_glock_muzzle"},
        Bone = "glock_flash",
        Offset = {
            vpos = Vector(0, 0, 0.0),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"},
        VMScale = Vector(0.8, 0.8, 0.8)
    },
    {
        PrintName = "Tactical",
        Slot = {"tac_pistol", "uce_pistol_foregrip"},
        Bone = "glock_parent",
        Offset = {
            vpos = Vector(0, -1.3, 5),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {7},
        ExcludeFlags = {"ud_glock_slide_subcompact"}
    },
    {
        Hidden = true,
        PrintName = "Tactical",
        Slot = {"tac_pistol"},
        Bone = "glock_parent",
        Offset = {
            vpos = Vector(0, -1.3, 5),
            vang = Angle(90, 0, -90),
        }, -- This slot is obsolete and exists solely for compatiblity with old loadouts. Do not remove.
    },
    {
        PrintName = "Magazine",
        Slot = {"ud_glock_mag"},
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_mag_17.png", "smooth mips"),
        DefaultAttName = "17-Round Mag",
    },
    {
        PrintName = "Stock",
        Slot = {"uc_stock", "go_stock_pistol_bt"},
        DefaultAttName = "No Stock",
        Bone = "glock_parent",
        Offset = {
            vpos = Vector(0.1, 2, -1.4),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"ud_glock_frame_subcompact"}
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "glock_slide",
        Offset = {
            vpos = Vector(0.45, 0.1, 4),
            vang = Angle(90, 0, -90),
        },
        VMScale = Vector(0.8, 0.8, 0.8),
    },
    {
        PrintName = "Material",
        DefaultAttName = "Black Polymer",
        DefaultAttIcon = Material("entities/att/acwatt_ud_glock_material.png", "smooth mips"),
        Slot = "ud_glock_skin",
        FreeSlot = true,
    },
}
--lua/weapons/arccw_ud_m16a1.lua:
return gluapack()()
--lua/weapons/arccw_ud_m4a1.lua:
return gluapack()()
--lua/weapons/arccw_ud_m16.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = .666
SWEP.ShellPitch = 100

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "RAYCAR-0"
-- AMCAR stands for (american) Colt Assault Rifle, not Carbine!! ~Fesiug
-- shut up retard ~zenith

-- True name --

SWEP.TrueName = "M16A2"

-- Trivia --
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Third generation of America's iconic military rifle. Army tests showed that soldiers were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, they implemented a ratcheted three-round burst system which limited the maximum burst a soldier could fire to three shots.\n\nWell-rounded gun with no major downsides."
SWEP.Trivia_Manufacturer = "Rayter Arms Industries"
SWEP.Trivia_Calibre = "5.56x45mm NATO"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "USA"
SWEP.Trivia_Year = 1959


if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Stoner's Legacy Ltd."
end

local origDesc = SWEP.Trivia_Desc
local m4Desc = "Carbine variant of the M16 rifle. Originally designed in response to design faults in the CAR-15 family, it eventually replaced the M16 across much of the Army for its favorably low weight and comparable performance. The M4 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."
local ncrDesc = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."
local smgDesc = "Submachine gun based on the M16 rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle. More accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."
local blkDesc = "Aftermarket automatic variant of the M16 rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range."
local ukDesc = "AR-15 style rifles are a class of rifles linked to the M16, normally with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver. Bit cringe, innit?"
local arDesc = "Semi-automatic variant of the M16 series of rifles, produced for the civilian market. Wildly popular in the United States, this rifle can be seen in the hands of hobbyists, hunters and mass shooters alike.\n\nWell-rounded gun with no major downsides."
local beoDesc = "Aftermarket semi-automatic variant of the M16 rifle firing an oversized magnum cartridge. Provides extremely high stopping power at close range."
local carDesc = "Carbine variant of the M16 rifle, short enough to be classified as a submachine gun. Its features influenced the US Army's interest in the M4 Carbine, which went on to become their new standard rifle. Due to the small barrel, rifles of this family have high maneuverability but poor range compared to their parent platform."
local a1Desc = "Second generation of America's iconic military rifle. Developed to address problems with the original M16, which suffered notoriously frequent jamming that could get its wielder killed. The revised model evolved a positive reputation with those who used it, and is now a universal symbol of the Vietnam War.\n\nA well-rounded rifle, but difficult to control without trigger discipline - something the A2 model eventually addressed."
local a3Desc = "Variant of the M16A2 with the original full-automatic trigger group, relegated to niche roles in the US Army. Well-rounded gun with no major downsides."
local lmgDesc = "Configuration of the M16 designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi. Heavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."
local patriotDesc = "An assault pistol developed for The Boss. The feeder mechanism inside the drum magazine forms an \"∞\" shape.\n\nThe bottomless magazine more than makes up for the awkwardness of the configuration."

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Colt's Manufacturing Company"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.ViewModelFOV = 80
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["556"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["556"].min
SWEP.RangeMin = 50
SWEP.Range = 350 -- 4 shot until ~250m

SWEP.Penetration = ArcCW.UC.StdDmg["556"].pen
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 960
SWEP.PhysBulletMuzzleVelocity = 960

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 20

-- Recoil --

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25

SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 900
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false, -- https://en.wikipedia.org/wiki/Burst_mode_(weapons)
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 4
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "smg1"
SWEP.MagID = "m16"

SWEP.HeatCapacity = 150
SWEP.HeatDissipation = 10
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200
SWEP.MalfunctionTakeRound = false

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Length --

SWEP.BarrelLength = 48
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -1, 1.2)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-2.815, 0, 1.3),
     Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "",
}

SWEP.ActivePos = Vector(0.33, -2, 1.33)
SWEP.ActiveAng = Angle(0, 0, -3)

-- SWEP.CustomizePos = Vector(5, -2, -2)
-- SWEP.CustomizeAng = Angle(15, 25, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2.5, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(2, 0, -5)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8.5, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    --scale = .85
}

-- Firing sounds --

local path = ")weapons/arccw_ud/m16/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}

SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/556x45/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-556x45-rif-ext-01.ogg",
    tail .. "fire-dist-556x45-rif-ext-02.ogg",
    tail .. "fire-dist-556x45-rif-ext-03.ogg",
    tail .. "fire-dist-556x45-rif-ext-04.ogg",
    tail .. "fire-dist-556x45-rif-ext-05.ogg",
    tail .. "fire-dist-556x45-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [2] = "m16_bullets1",    [3] = "m16_bullets2"
}

SWEP.DefaultBodygroups = "00000000000000000000000"

SWEP.AttachmentElements = {

    ["ud_m16_mag_20"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_m16_mag_40"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["ud_m16_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 9}},
    },
    ["ud_m16_mag_60"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
    ["ud_m16_mag_100"] = {
        VMBodygroups = {{ind = 2, bg = 4}},
    },
    ["ud_m16_9mm_mag"] = {
        VMBodygroups = {{ind = 2, bg = 5}},
    },
    ["ud_m16_9mm_mag_32"] = {
        VMBodygroups = {{ind = 2, bg = 6}},
    },
    ["ud_m16_mag_50beo"] = {
        VMBodygroups = {{ind = 2, bg = 8}},
    },
    ["ud_m16_mag_50beo_12"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },

    ["upper_flat"] = {
        -- handled by code
        --[[]
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 3, bg = 3}
        },
        ]]
    },
    ["upper_classic"] = {
        VMBodygroups = {
            {ind = 1, bg = 3},
        },
    },
    ["rail_fg"] = {
        VMBodygroups = {{ind = 9, bg = 1}}
    },

    ["stock_231_ex"] = {
        VMBodygroups = {{ind = 7, bg = 1}},
    },
    ["stock_231_in"] = {
        VMBodygroups = {{ind = 7, bg = 2}},
    },
    ["stock_231_tube"] = {
        VMBodygroups = {{ind = 7, bg = 3}},
    },
    ["stock_607_ex"] = {
        VMBodygroups = {{ind = 7, bg = 4}},
    },
    ["stock_607_in"] = {
        VMBodygroups = {{ind = 7, bg = 5}},
    },
    ["stock_608"] = {
        VMBodygroups = {{ind = 7, bg = 6}},
    },
    ["stock_carbine_ex"] = {
        VMBodygroups = {{ind = 7, bg = 7}},
    },
    ["stock_carbine_in"] = {
        VMBodygroups = {{ind = 7, bg = 8}},
    },
    ["stock_wood"] = {
        VMBodygroups = {{ind = 7, bg = 9}},
    },
    ["stock_adar"] = {
        VMBodygroups = {
            {ind = 7, bg = 10},
            {ind = 8, bg = 4}
        },
    },
    ["stock_ru556"] = {
        VMBodygroups = {{ind = 7, bg = 11}},
    },
    ["grip_ergo"] = {
        VMBodygroups = {{ind = 8, bg = 1}},
    },
    ["grip_skel"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["grip_wood"] = {
        VMBodygroups = {{ind = 8, bg = 3}},
    },

    ["gasblock_carbine"] = {
        VMBodygroups = {{ind = 6, bg = 3}},
    },
    ["fs_adar"] = {
        VMBodygroups = {{ind = 6, bg = 4}},
    },
    ["remove_lug"] = {
        VMBodygroups = {{ind = 12, bg = 1}},
    },

    ["mount_14"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0, 0.3, 17.5),
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["mount_11"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.6, -0.3, 14.2),
                vang = Angle(90, 0, 0),
            },
        },
    },
    ["mount_tactical"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(-1, -.35, 11.5),
                vang = Angle(-90, 180, 0),
                wang = Angle(90, 0, 0),
            },
        },
        ExcludeFlags = {}
    },
    -- ["mount_tactical_short"] = {
    --     AttPosMods = {
    --         [8] = {
    --             vpos = Vector(-1, -.35, 11.5),
    --             vang = Angle(-90, 180, 0),
    --             wang = Angle(90, 0, 0),
    --         },
    --     },
    --     AttPosMods_Priority = 2,
    --     RequireFlags = {"barrel_short"}
    -- },

    ["barrel_14"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 18.85),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 15.7),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_fpw"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11_ru556"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.15, 0, 17.9),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["hg_m16a4_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 2},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(-0.1, 1.05, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.41, -.1, 20),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.75, 21.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m4a1_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 5},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 1.4, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(-1.41, -.2, 14),
                vang = Angle(90, 0, 180),
            },
            [15] = {
                vpos = Vector(0, -1.75, 15.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_ru556"] = {
        -- VMBodygroups = {
        --     {ind = 5, bg = 7},
        -- },
        AttPosMods = {
            -- [5] = {
            --     vpos = Vector(-0.1, 1.05, 12),
            --     vang = Angle(90, 0, -90),
            -- },
            -- [6] = {
            --     vpos = Vector(1.1, 0, 14),
            --     vang = Angle(90, 0, 0),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_m4a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        }
    },
    ["hg_cqbr"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        },
    },
    ["hg_adar"] = {
        VMBodygroups = {
            {ind = 5, bg = 8},
        },
    },
    ["hg_fpw"] = {
        VMBodygroups = {
            {ind = 5, bg = 6},
            --{ind = 6, bg = 4},
        }
    },
    ["hg_m16a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        }
    },
    ["hg_m16a1_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        },
        VMSkin = 1
    },
    ["ud_m16_hg_heat"] = {
        VMElements = {
            {
                Model = "models/weapons/arccw/atts/m203iron.mdl",
                Bone = "m16_parent",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, -1.2, 14.9),
                    ang = Angle(90, 0, -90),
                }
            }
        },
        UC_UseClassicM203Mount = true,
    },
    ["hg_m605"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.05, 25.58),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.9, 22.2),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m605_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, 0, 25),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.8, 22),
                vang = Angle(90, 0, -90),
            },
        },
        VMSkin = 1
    },
    ["hg_lmg"] = {
        VMBodygroups = {
            {ind = 5, bg = 3},
        }
    },
    ["hg_sd"] = {
        VMBodygroups = {
            {ind = 5, bg = 9},
            {ind = 4, bg = 3},
            {ind = 6, bg = 5}
        },
        AttPosMods = { -- no rail, just pretend it's mounted to something
            -- [8] = {
            --     vpos = Vector(0, 0.7, 17.5),
            --     vang = Angle(90, 0, -90),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 11.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["ud_m16_upper_charm"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4, 3),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.4, 3 - 1.5),
                    vmax = Vector(0, -3.4, 3 + 1.5),
                }
            },
        },
    },
    ["ud_m16_upper_charm2"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4.1, 3.5),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.5, 3.5 - 2),
                    vmax = Vector(0, -3.5, 3.5 + 1),
                }
            },
        },
    },
    ["bravo_dicks_going_fart"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.25, -1.4, 12),
                vang = Angle(90, 0, 90),
            },
        },
    },

    ---- Cut content
    ["hg_stub"] = {
        VMBodygroups = {
            {ind = 5, bg = 7},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.35, 7),
                vang = Angle(90, 0, -90)
            },
            [6] = {
                vpos = Vector(1.1, -0.4, 9),
                vang = Angle(90, 0, 0),
            },
        }
    },
    ["barrel_stub"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 4},
        }
    },
    ["hg_smg"] = {
        VMBodygroups = {
            {ind = 5, bg = 0},
        }
    },
    ["m16_strap"] = {
        VMBodygroups = {
             {ind = 13, bg = 1},
        },
    },
}

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local sr_pmag = {
	[path .. "magout_empty.ogg"] = path .. "pmagout.ogg",
	[path .. "magin.ogg"] = path .. "pmagin.ogg",
}

local pmag1, pmag2 = {}, {"ud_m16_pmag"}
SWEP.Hook_TranslateSound = function(wep, data)
	if wep:CheckFlags(pmag1, pmag2) and sr_pmag[data] then return sr_pmag[data] end
end

local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}

SWEP.Animations = {
    ["ready"] = {
        Source = "fix",
        Time = 45 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 20 / 30,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = 20 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["trigger"] = {
        Source = "idle",
        MinProgress = .1,
        SoundTable = {
            {s = ")weapons/arccw_ud/uzi/prefire.ogg",         t = 0, c = ci},
        },
    },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },

    ["fire_cycle"] = {
        Source = "fire",
        Time = 13 / 30,
    },

    ["cycle"] = {
        Source = "fix",
        Time = 36 / 30 * 0.7,
        ShellEjectAt = 0.3,
        LHIK = true,
        LHIKIn = 0.3 * 0.7,
        LHIKEaseIn = 0.4 * 0.7,
        LHIKEaseOut = 0.15 * 0.7,
        LHIKOut = 0.4 * 0.7,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.05},
            {s = common .. "cloth_4.ogg",  t = 0.2},
            {s = path .. "chamber.ogg",  t = 0.3},
        },
    },

    ["fix"] = {
        Source = "fix",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
    },
    ["fix_empty"] = {
        Source = "fix_empty",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "ch_forward_empty.ogg",  t = 0.5},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2, v = 0.5},
            {s = ratel, t = 0.25},
            {s = path .. "magout_empty.ogg", 	 t = 0.23},
            {s = ratel, t = 0.5},
            {s = path .. "struggle.ogg",    t = 1, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab-polymer.ogg", t = 1.77, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.7},
            {s = common .. "shoulder.ogg", t = 1.8},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 87 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.25},
            {s = common .. "magpouch_gear.ogg", t = 0.1, v = 0.5},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = ratel, t = 0.5},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.39},
            {s = path .. "boltdrop.ogg", t = 1.7},
            {s = ratel, t = 1.9},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.0},
            {s = common .. "grab-polymer.ogg", t = 2.1, v = 0.35},
            {s = common .. "shoulder.ogg", t = 2.1},
        },
    },

    -- 20 Round Reloads --

    ["reload_20"] = {
        Source = "reload_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.09},
            {s = common .. "magpouch_gear.ogg", t = 0.1},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 0.85},
            {s = path .. "struggle.ogg",    t = 0.9, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = rottle,  t = 1.1},
            {s = ratel, t = 1.125},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "grab-polymer.ogg", t = 1.7, v = 0.25},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_20"] = {
        Source = "reload_empty_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 86 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.8,
        SoundTable = {
            {s = common .. "magpouch_gear.ogg", t = 0},
            {s = rottle, t = 0.01},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.075},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.9},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.8, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.85},
            {s = rottle, t = 1.4},
            {s = ratel, t = 1.4},
            {s = path .. "chamber_press.ogg", t = 1.72},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.95},
            {s = common .. "grab-polymer.ogg", t = 2.075, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.13},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = ratel, t = 0.1},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.8},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.0},
            {s = rottle, t = 1.1},
            {s = ratel, t = 1.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle,  t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle,  t = 1.475},
            {s = ratel,  t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.78},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 60 Round Reloads --

    ["reload_60"] = {
        Source = "reload_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.1},
            {s = common .. "grab-polymer.ogg", t = 1.78, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "shoulder.ogg", t = 1.9},
        },
    },
    ["reload_empty_60"] = {
        Source = "reload_empty_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.475},
            {s = ratel, t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.8},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "grab-polymer.ogg", t = 2.15, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 100 Round Reloads --

    ["reload_100"] = {
        Source = "reload_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.75,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle, t = 1.1},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "grab-polymer.ogg", t = 1.85, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.0},
        },
    },
    ["reload_empty_100"] = {
        Source = "reload_empty_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 90 / 30,
        MinProgress = 2.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = rottle, t = 1.75},
            {s = path .. "chback.ogg",   t = 2.0},
            {s = common .. "cloth_4.ogg",  t = 2.05},
            {s = path .. "chamber.ogg",  t = 2.22},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.5},
            {s = common .. "grab-polymer.ogg", t = 2.55, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.6},
        },
    },

    -- 9mm 32 Round Reloads --

    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 70 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.15},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 16 / 30},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 27 / 30},
            {s = rottle, t = 1.1},
            {s = common .. "magpouchin.ogg", t = 1.55},
            {s = common .. "shoulder.ogg", t = 1.93},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_empty_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 80 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 0.1},
            {s = common .. "magpouch.ogg", t = 0.45},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 0.8},
            {s = path .. "chamber_press.ogg", t = 1.7},
            {s = rottle, t = 1.39},
            {s = common .. "shoulder.ogg", t = 2.15},
        },
    },


    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_inspect_empty"] = {
        Source = "inspect_enter_empty",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop_empty",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit_empty",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
}

local hgLookup = {
    ["default"]     = {0,4,0},
    ["tactical"]    = {2,5,0},
    ["a1"]          = {1,1,1},
    ["heat"]          = {10,10,1},
    ["heatm203"]          = {11,11,1},
    ["wood"]          = {1,1,1},
    ["lmg"]          = {3,3,1},
    ["fpw"]          = {6,6,2},
    ["ru556"]          = {7,7,3},
    ["adar"]          = {8,8,2},
    ["hk416"]          = {9,9,3},
    ["607"]          = {9,9,0},
}
-- Structure: 20in appearance, 14/11in appearance, gas block mode
-- Gas block modes: 0 standard, 1 always at 20" position, 2 at ADAR position when short, 3 at ADAR position when short and not flat

local barrLookup = {
    ["sd"] = -1,
    ["20in"] = 0,
    ["14in"] = 1,
    ["fpw"] = 1,
    ["10in"] = 2,
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    local atts = wep.Attachments
    if !IsValid(vm) then return end

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    hg = string.Replace(hg,"uf_m16_hg_","")

    local optic = atts[1].Installed
    local muzz = atts[4].Installed or barrel == "sd"
    local laser = atts[8].Installed
    local fs = atts[16].Installed
    local retro = wep:GetBuff_Override("TopMount")

    -- Retro rail
    if optic then
        if retro then
            -- Raised rail (retro)
            vm:SetBodygroup(3, retro)
        else
            -- Flat rail
            vm:SetBodygroup(1, 1)
            vm:SetBodygroup(3, 2)
        end
    end

    -- Dynamic handguard
    if barr == -1 then
        vm:SetBodygroup(5,9)
    elseif barr == 0 and hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][1])
    elseif hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][2])
    else
        vm:SetBodygroup(5,9)
    end

    -- Gas block
    if barrel == "sd" or (atts[6].Installed == "ud_m16_receiver_fpw" and barr > 0) then
        vm:SetBodygroup(6,5)
    else
        local gbPos = hgLookup[hg] and hgLookup[hg][3] or 0
        local lwr = atts[6].Installed
        local flat = (
            wep:GetBuff_Override("FrontSight")
            or atts[6].Installed == "ud_m16_receiver_fpw"
            or (optic and fs ~= "ud_m16_charm_fs" and !(wep:GetBuff_Override("IronSight") or wep:GetBuff_Override("TopMount")))
        ) and 1 or 0

        if gbPos == 1 or barr == 0 then
            vm:SetBodygroup(6, 0 + flat)
        elseif gbPos == 2 then
            vm:SetBodygroup(6, 4 + flat * 2)
        elseif gbPos == 3 then
            vm:SetBodygroup(6, 4 - flat)
        else
            vm:SetBodygroup(6, 2 + flat)
        end
    end

    -- Default flash hider
    if !muzz then
        if barr == 0 then
            vm:SetBodygroup(11,1)
        elseif barr == 1 then
            vm:SetBodygroup(11,2)
        else
            vm:SetBodygroup(11,3)
        end
    else
        vm:SetBodygroup(11,0)
    end

    -- Tactical clamp
    if laser and hg ~= "tactical" then
        if barr == 0 then
            vm:SetBodygroup(10,1)
        elseif barr == 1 then
            vm:SetBodygroup(10,3)
        else
            vm:SetBodygroup(10,2)
        end
    else
        vm:SetBodygroup(10,0)
    end

    -- Disable tac rail element with tac hg
    if hg == "tactical" and (atts[7].Installed or atts[18].Installed) then
        vm:SetBodygroup(9,0)
    end

    -- .50 Beowulf magazines
    if atts[5].Installed == "ud_m16_receiver_50beo" and !atts[11].Installed then
        vm:SetBodygroup(2, 8)
    end
end

-- RAYCAR-0, rifle barrel
local bar0_fake = "First variation of the RAYCAR rifle. Tests showed that users were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, a ratcheted three-round burst system was implemented which limited the maximum burst a user could fire to three shots.\n\nWell-rounded gun with no major downsides."

-- RAYCAR-1, carbine barrel
local bar1_fake = "Second variation of the RAYCAR rifle. It eventually replaced the RAYCAR-0 across much of the Army for its favorably low weight and comparable performance. The -1 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."

-- RAYCAR-2, commando barrel
local bar2_fake = "Third variation of the RAYCAR rifle. Developed with assistance from the Navy, the \"commando\" barrel allows for the weapon to be very compact, even short enough to be classified as a submachine gun, enhancing usability in vehicles and in enclosed spaces.\n\nVery lightweight and manuverable, but with very aggressive recoil to match."

-- RAYPAW :3
local smgDesc_fake = "Submachine gun based on the RAYCAR rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle.\n\nMore accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."

-- RBY50
local beoDesc_fake = "Aftermarket semi-automatic variant of the RAYCAR rifle firing an oversized magnum cartridge.\n\nProvides extremely high stopping power at close range."

-- RBY300
local blkDesc_fake = "Aftermarket automatic variant of the RAYCAR rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range.\n\nSlightly more inaccurate, made up with a higher stopping power and a subsonic projectile."

-- UKCAR
local ukDesc_fake = "Normally, RAYCAR style rifles are imported with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver.\n\nBit cringe, innit?"

-- RAYSAW
local lmgDesc_fake = "Configuration of the RAYCAR designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi.\n\nHeavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."

-- Fallout barrel or sumn idk
local ncrDesc_fake = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."

-- Patriot easter egg. Is it overpowered? I don't think so, a configuration like this is already pretty uncontrollable and imprecise as is, and overheating is the new magazine.
local a1, a2 = {}, {"patr1", "patr2", "patr3", "patr4", "patr5"}
SWEP.O_Hook_Override_BottomlessClip = function(wep, data)
    if wep:CheckFlags(a1, a2) then
        data.current = true
    end
end


SWEP.Hook_NameChange = function(wep, name)
    local trueNames = GetConVar("arccw_truenames"):GetBool()
    local atts = wep.Attachments
    local flat = atts[1].Installed and !wep:GetBuff_Override("TopMount")

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    local upr = string.Replace(atts[5].Installed or "default","ud_m16_receiver_","")
    local lwr = string.Replace(atts[6].Installed or "default","ud_m16_receiver_","")

    if wep:CheckFlags(a1, a2) then -- Patriot configuration
        wep.Trivia_Desc = patriotDesc
        return "The Patriot"
    elseif !trueNames then -- Custom lore-based fake names
        local pre = (lwr == "auto" and "AM" or "RAY")
        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc_fake
            if flat then
                return (sd and pre .. "SSMG-NG") or pre .. "PAW-" .. barr .. "NG"
            end
            return (sd and pre .. "SSMG") or pre .. "PAW-" .. barr
        elseif upr == "50beo" then
            wep.Trivia_Desc = beoDesc_fake
            return "RBY"--50"
        elseif upr == "300blk" then
            wep.Trivia_Desc = blkDesc_fake
            return "RBY"--300"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = bar1_fake
            return pre .. "FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc_fake
            return "UKCAR"
        else
            if barr == 0 then
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc_fake
                    return pre .. "SAW" .. (flat and "-NG" or "")
                elseif flat then
                    return pre .. "CAR-0NG"
                else
                    wep.Trivia_Desc = bar0_fake
                    return pre .. "CAR-0"
                end
            elseif barr == 1 then
                wep.Trivia_Desc = bar1_fake
                if flat then
                    return pre .. "CAR-1NG"
                end
                return pre .. "CAR-1"
            elseif barr == 2 then
                wep.Trivia_Desc = bar2_fake
                if flat then
                    return pre .. "CAR-2NG"
                end
                return pre .. "CAR-2"
            end
        end

        wep.Trivia_Desc = bar0_fake
        return pre .. "CAR-0"

    else

        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc
            if lwr == "semi" then
                return "AR-15 9mm"
            elseif flat then
                return "R0991"
            end
            return "R0635"

        end

        if lwr == "auto" then
            if upr == "a1" then
                wep.Trivia_Desc = a1Desc
                if barr == 0 then
                    return "M16A1"
                elseif barr == 1 then
                    return "M605"
                end
                wep.Trivia_Desc = carDesc
                return "CAR-15"
            end
            if barr == 0 then
                wep.Trivia_Desc = a3Desc
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc
                    return "Colt LMG"
                elseif flat and hg == "tactical" then
                    return "R0901"
                end
                return "M16A3"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                if flat then
                    return "M4A1"
                end
                return "XM4"
            else
                wep.Trivia_Desc = carDesc
                if flat then
                    wep.Trivia_Desc = m4Desc
                    if upr == "300blk" then
                        return "Mk 18"
                    end
                    return "Mk 18 Mod 0"
                end
                return "CAR-15"
            end
        elseif lwr == "semi" or upr == "50beo" then
            wep.Trivia_Desc = arDesc
            if hg == "wood" then
                wep.Trivia_Desc = ncrDesc
                if barr == 0 then
                    return "Service Rifle"
                end
                return "Service Carbine"
            elseif flat and hg == "adar" then
                return "ADAR 2-15"
            elseif barr > 0 then
                if barr == 2 and atts[10].Installed == "ud_m16_stock_buffer" then
                    return "AR-15 Pistol"
                elseif upr == "a1" and barr == 1 then
                    return "CRXM177E2B"
                else
                    return "AR-15 SBR"
                end
            elseif upr == "a1" then
                return "CRM16A1"
            end
            return "AR-15"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = m4Desc
            return "M231 FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc
            return "AR-15GB"
        else
            wep.Trivia_Desc = origDesc
            if barr == 0 and flat then
                return "M16A4"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                return "M4 Carbine"
            elseif barr == 2 then
                return "M16 Commando"
            end
        end

        wep.Trivia_Desc = origDesc
        return "M16A2"

    end
end



SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        InstalledEles = {"upper_flat"},
        Slot = {"optic","optic_sniper","ud_m16_rs"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.75, 3),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
            vmin = Vector(0, -1.6, 3 - 2),
            vmax = Vector(0, -1.6, 3 + 1),
        },
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "20\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_barrel_20.png", "smooth mips"),
        Slot = "ud_m16_blen",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Ribbed Handguard",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_hg_ribbed.png", "smooth mips"),
        Slot = "ud_m16_hg",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.63, -0.41),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "ud_m16_muzzle"},
        Bone = "m16_parent",
        VMScale = Vector(1, 1, 1),
        WMScale = VMScale,
        Offset = {
            vpos = Vector(0, -.33, 23.27),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd", "m16_stub"},
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "5.56x45mm Upper",
        DefaultAttIcon = Material("entities/att/uc_bullets/556x45.png", "smooth mips"),
        Slot = {"ud_m16_receiver"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"ud_m16_fpw"}
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Burst Lower",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_receiver_default.png", "smooth mips"),
        Slot = {"ud_m16_fcg"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"m16_nolower"}
    },
    {
        PrintName = "Underbarrel",
        Slot = "foregrip",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 6, 11),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
        SlideAmount = {
            vmin = Vector(0, .65, 11.5),
            vmax = Vector(0, .65, 7.5),
        },
		MergeSlots = {18},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 0.3, 21.25),
            vang = Angle(90, 0, -90),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ud_m16_grip"},
        DefaultAttName = "Standard Grip",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_grip_default.png", "smooth mips"),
        ExcludeFlags = {"m16_adar"}
    },
    {
        PrintName = "Stock",
        Slot = {"ud_m16_stock","go_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_stock_default.png", "smooth mips"),
        -- GSO support
        InstalledEles = {"stock_231_tube"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(-0.02, 0, -2.7),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Magazine",
        Slot = {"ud_m16_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_mag_30.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Front Sight",
        Slot = {"ud_m16_fs", "ud_m16_charm"},
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.65, 16.75), -- 21.75 or 15.75
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sight_magpul"}
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"}, -- "ud_m16_charm"
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0.48, 0.5, 3.9),
            vang = Angle(90, 0, -90),
        },
        -- MergeSlots = {17}
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -0.4, 7.2),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
    }
}
--lua/weapons/arccw_ud_miniuzi.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_uzi.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets SMGs"
end

SWEP.PrintName = "IAL-S9"
SWEP.TrueName = "Mini Uzi"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ud_uzi_body_mini"
SWEP.Attachments[7].Installed = "ud_uzi_stock_remove"

SWEP.Hook_NameChange = function(wep)
    if !wep.Attachments[2].Installed then
        return GetConVar("arccw_truenames"):GetBool() and "Uzi" or "IAL-9"
    end
end
--lua/weapons/arccw_ud_m16.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = .666
SWEP.ShellPitch = 100

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "RAYCAR-0"
-- AMCAR stands for (american) Colt Assault Rifle, not Carbine!! ~Fesiug
-- shut up retard ~zenith

-- True name --

SWEP.TrueName = "M16A2"

-- Trivia --
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Third generation of America's iconic military rifle. Army tests showed that soldiers were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, they implemented a ratcheted three-round burst system which limited the maximum burst a soldier could fire to three shots.\n\nWell-rounded gun with no major downsides."
SWEP.Trivia_Manufacturer = "Rayter Arms Industries"
SWEP.Trivia_Calibre = "5.56x45mm NATO"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "USA"
SWEP.Trivia_Year = 1959


if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Stoner's Legacy Ltd."
end

local origDesc = SWEP.Trivia_Desc
local m4Desc = "Carbine variant of the M16 rifle. Originally designed in response to design faults in the CAR-15 family, it eventually replaced the M16 across much of the Army for its favorably low weight and comparable performance. The M4 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."
local ncrDesc = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."
local smgDesc = "Submachine gun based on the M16 rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle. More accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."
local blkDesc = "Aftermarket automatic variant of the M16 rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range."
local ukDesc = "AR-15 style rifles are a class of rifles linked to the M16, normally with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver. Bit cringe, innit?"
local arDesc = "Semi-automatic variant of the M16 series of rifles, produced for the civilian market. Wildly popular in the United States, this rifle can be seen in the hands of hobbyists, hunters and mass shooters alike.\n\nWell-rounded gun with no major downsides."
local beoDesc = "Aftermarket semi-automatic variant of the M16 rifle firing an oversized magnum cartridge. Provides extremely high stopping power at close range."
local carDesc = "Carbine variant of the M16 rifle, short enough to be classified as a submachine gun. Its features influenced the US Army's interest in the M4 Carbine, which went on to become their new standard rifle. Due to the small barrel, rifles of this family have high maneuverability but poor range compared to their parent platform."
local a1Desc = "Second generation of America's iconic military rifle. Developed to address problems with the original M16, which suffered notoriously frequent jamming that could get its wielder killed. The revised model evolved a positive reputation with those who used it, and is now a universal symbol of the Vietnam War.\n\nA well-rounded rifle, but difficult to control without trigger discipline - something the A2 model eventually addressed."
local a3Desc = "Variant of the M16A2 with the original full-automatic trigger group, relegated to niche roles in the US Army. Well-rounded gun with no major downsides."
local lmgDesc = "Configuration of the M16 designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi. Heavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."
local patriotDesc = "An assault pistol developed for The Boss. The feeder mechanism inside the drum magazine forms an \"∞\" shape.\n\nThe bottomless magazine more than makes up for the awkwardness of the configuration."

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Colt's Manufacturing Company"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.ViewModelFOV = 80
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["556"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["556"].min
SWEP.RangeMin = 50
SWEP.Range = 350 -- 4 shot until ~250m

SWEP.Penetration = ArcCW.UC.StdDmg["556"].pen
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 960
SWEP.PhysBulletMuzzleVelocity = 960

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 20

-- Recoil --

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25

SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 900
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false, -- https://en.wikipedia.org/wiki/Burst_mode_(weapons)
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 4
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "smg1"
SWEP.MagID = "m16"

SWEP.HeatCapacity = 150
SWEP.HeatDissipation = 10
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200
SWEP.MalfunctionTakeRound = false

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Length --

SWEP.BarrelLength = 48
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -1, 1.2)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-2.815, 0, 1.3),
     Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "",
}

SWEP.ActivePos = Vector(0.33, -2, 1.33)
SWEP.ActiveAng = Angle(0, 0, -3)

-- SWEP.CustomizePos = Vector(5, -2, -2)
-- SWEP.CustomizeAng = Angle(15, 25, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2.5, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(2, 0, -5)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8.5, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    --scale = .85
}

-- Firing sounds --

local path = ")weapons/arccw_ud/m16/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}

SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/556x45/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-556x45-rif-ext-01.ogg",
    tail .. "fire-dist-556x45-rif-ext-02.ogg",
    tail .. "fire-dist-556x45-rif-ext-03.ogg",
    tail .. "fire-dist-556x45-rif-ext-04.ogg",
    tail .. "fire-dist-556x45-rif-ext-05.ogg",
    tail .. "fire-dist-556x45-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [2] = "m16_bullets1",    [3] = "m16_bullets2"
}

SWEP.DefaultBodygroups = "00000000000000000000000"

SWEP.AttachmentElements = {

    ["ud_m16_mag_20"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_m16_mag_40"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["ud_m16_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 9}},
    },
    ["ud_m16_mag_60"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
    ["ud_m16_mag_100"] = {
        VMBodygroups = {{ind = 2, bg = 4}},
    },
    ["ud_m16_9mm_mag"] = {
        VMBodygroups = {{ind = 2, bg = 5}},
    },
    ["ud_m16_9mm_mag_32"] = {
        VMBodygroups = {{ind = 2, bg = 6}},
    },
    ["ud_m16_mag_50beo"] = {
        VMBodygroups = {{ind = 2, bg = 8}},
    },
    ["ud_m16_mag_50beo_12"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },

    ["upper_flat"] = {
        -- handled by code
        --[[]
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 3, bg = 3}
        },
        ]]
    },
    ["upper_classic"] = {
        VMBodygroups = {
            {ind = 1, bg = 3},
        },
    },
    ["rail_fg"] = {
        VMBodygroups = {{ind = 9, bg = 1}}
    },

    ["stock_231_ex"] = {
        VMBodygroups = {{ind = 7, bg = 1}},
    },
    ["stock_231_in"] = {
        VMBodygroups = {{ind = 7, bg = 2}},
    },
    ["stock_231_tube"] = {
        VMBodygroups = {{ind = 7, bg = 3}},
    },
    ["stock_607_ex"] = {
        VMBodygroups = {{ind = 7, bg = 4}},
    },
    ["stock_607_in"] = {
        VMBodygroups = {{ind = 7, bg = 5}},
    },
    ["stock_608"] = {
        VMBodygroups = {{ind = 7, bg = 6}},
    },
    ["stock_carbine_ex"] = {
        VMBodygroups = {{ind = 7, bg = 7}},
    },
    ["stock_carbine_in"] = {
        VMBodygroups = {{ind = 7, bg = 8}},
    },
    ["stock_wood"] = {
        VMBodygroups = {{ind = 7, bg = 9}},
    },
    ["stock_adar"] = {
        VMBodygroups = {
            {ind = 7, bg = 10},
            {ind = 8, bg = 4}
        },
    },
    ["stock_ru556"] = {
        VMBodygroups = {{ind = 7, bg = 11}},
    },
    ["grip_ergo"] = {
        VMBodygroups = {{ind = 8, bg = 1}},
    },
    ["grip_skel"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["grip_wood"] = {
        VMBodygroups = {{ind = 8, bg = 3}},
    },

    ["gasblock_carbine"] = {
        VMBodygroups = {{ind = 6, bg = 3}},
    },
    ["fs_adar"] = {
        VMBodygroups = {{ind = 6, bg = 4}},
    },
    ["remove_lug"] = {
        VMBodygroups = {{ind = 12, bg = 1}},
    },

    ["mount_14"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0, 0.3, 17.5),
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["mount_11"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.6, -0.3, 14.2),
                vang = Angle(90, 0, 0),
            },
        },
    },
    ["mount_tactical"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(-1, -.35, 11.5),
                vang = Angle(-90, 180, 0),
                wang = Angle(90, 0, 0),
            },
        },
        ExcludeFlags = {}
    },
    -- ["mount_tactical_short"] = {
    --     AttPosMods = {
    --         [8] = {
    --             vpos = Vector(-1, -.35, 11.5),
    --             vang = Angle(-90, 180, 0),
    --             wang = Angle(90, 0, 0),
    --         },
    --     },
    --     AttPosMods_Priority = 2,
    --     RequireFlags = {"barrel_short"}
    -- },

    ["barrel_14"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 18.85),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 15.7),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_fpw"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11_ru556"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.15, 0, 17.9),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["hg_m16a4_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 2},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(-0.1, 1.05, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.41, -.1, 20),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.75, 21.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m4a1_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 5},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 1.4, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(-1.41, -.2, 14),
                vang = Angle(90, 0, 180),
            },
            [15] = {
                vpos = Vector(0, -1.75, 15.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_ru556"] = {
        -- VMBodygroups = {
        --     {ind = 5, bg = 7},
        -- },
        AttPosMods = {
            -- [5] = {
            --     vpos = Vector(-0.1, 1.05, 12),
            --     vang = Angle(90, 0, -90),
            -- },
            -- [6] = {
            --     vpos = Vector(1.1, 0, 14),
            --     vang = Angle(90, 0, 0),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_m4a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        }
    },
    ["hg_cqbr"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        },
    },
    ["hg_adar"] = {
        VMBodygroups = {
            {ind = 5, bg = 8},
        },
    },
    ["hg_fpw"] = {
        VMBodygroups = {
            {ind = 5, bg = 6},
            --{ind = 6, bg = 4},
        }
    },
    ["hg_m16a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        }
    },
    ["hg_m16a1_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        },
        VMSkin = 1
    },
    ["ud_m16_hg_heat"] = {
        VMElements = {
            {
                Model = "models/weapons/arccw/atts/m203iron.mdl",
                Bone = "m16_parent",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, -1.2, 14.9),
                    ang = Angle(90, 0, -90),
                }
            }
        },
        UC_UseClassicM203Mount = true,
    },
    ["hg_m605"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.05, 25.58),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.9, 22.2),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m605_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, 0, 25),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.8, 22),
                vang = Angle(90, 0, -90),
            },
        },
        VMSkin = 1
    },
    ["hg_lmg"] = {
        VMBodygroups = {
            {ind = 5, bg = 3},
        }
    },
    ["hg_sd"] = {
        VMBodygroups = {
            {ind = 5, bg = 9},
            {ind = 4, bg = 3},
            {ind = 6, bg = 5}
        },
        AttPosMods = { -- no rail, just pretend it's mounted to something
            -- [8] = {
            --     vpos = Vector(0, 0.7, 17.5),
            --     vang = Angle(90, 0, -90),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 11.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["ud_m16_upper_charm"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4, 3),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.4, 3 - 1.5),
                    vmax = Vector(0, -3.4, 3 + 1.5),
                }
            },
        },
    },
    ["ud_m16_upper_charm2"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4.1, 3.5),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.5, 3.5 - 2),
                    vmax = Vector(0, -3.5, 3.5 + 1),
                }
            },
        },
    },
    ["bravo_dicks_going_fart"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.25, -1.4, 12),
                vang = Angle(90, 0, 90),
            },
        },
    },

    ---- Cut content
    ["hg_stub"] = {
        VMBodygroups = {
            {ind = 5, bg = 7},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.35, 7),
                vang = Angle(90, 0, -90)
            },
            [6] = {
                vpos = Vector(1.1, -0.4, 9),
                vang = Angle(90, 0, 0),
            },
        }
    },
    ["barrel_stub"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 4},
        }
    },
    ["hg_smg"] = {
        VMBodygroups = {
            {ind = 5, bg = 0},
        }
    },
    ["m16_strap"] = {
        VMBodygroups = {
             {ind = 13, bg = 1},
        },
    },
}

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local sr_pmag = {
	[path .. "magout_empty.ogg"] = path .. "pmagout.ogg",
	[path .. "magin.ogg"] = path .. "pmagin.ogg",
}

local pmag1, pmag2 = {}, {"ud_m16_pmag"}
SWEP.Hook_TranslateSound = function(wep, data)
	if wep:CheckFlags(pmag1, pmag2) and sr_pmag[data] then return sr_pmag[data] end
end

local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}

SWEP.Animations = {
    ["ready"] = {
        Source = "fix",
        Time = 45 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 20 / 30,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = 20 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["trigger"] = {
        Source = "idle",
        MinProgress = .1,
        SoundTable = {
            {s = ")weapons/arccw_ud/uzi/prefire.ogg",         t = 0, c = ci},
        },
    },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },

    ["fire_cycle"] = {
        Source = "fire",
        Time = 13 / 30,
    },

    ["cycle"] = {
        Source = "fix",
        Time = 36 / 30 * 0.7,
        ShellEjectAt = 0.3,
        LHIK = true,
        LHIKIn = 0.3 * 0.7,
        LHIKEaseIn = 0.4 * 0.7,
        LHIKEaseOut = 0.15 * 0.7,
        LHIKOut = 0.4 * 0.7,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.05},
            {s = common .. "cloth_4.ogg",  t = 0.2},
            {s = path .. "chamber.ogg",  t = 0.3},
        },
    },

    ["fix"] = {
        Source = "fix",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
    },
    ["fix_empty"] = {
        Source = "fix_empty",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "ch_forward_empty.ogg",  t = 0.5},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2, v = 0.5},
            {s = ratel, t = 0.25},
            {s = path .. "magout_empty.ogg", 	 t = 0.23},
            {s = ratel, t = 0.5},
            {s = path .. "struggle.ogg",    t = 1, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab-polymer.ogg", t = 1.77, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.7},
            {s = common .. "shoulder.ogg", t = 1.8},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 87 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.25},
            {s = common .. "magpouch_gear.ogg", t = 0.1, v = 0.5},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = ratel, t = 0.5},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.39},
            {s = path .. "boltdrop.ogg", t = 1.7},
            {s = ratel, t = 1.9},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.0},
            {s = common .. "grab-polymer.ogg", t = 2.1, v = 0.35},
            {s = common .. "shoulder.ogg", t = 2.1},
        },
    },

    -- 20 Round Reloads --

    ["reload_20"] = {
        Source = "reload_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.09},
            {s = common .. "magpouch_gear.ogg", t = 0.1},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 0.85},
            {s = path .. "struggle.ogg",    t = 0.9, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = rottle,  t = 1.1},
            {s = ratel, t = 1.125},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "grab-polymer.ogg", t = 1.7, v = 0.25},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_20"] = {
        Source = "reload_empty_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 86 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.8,
        SoundTable = {
            {s = common .. "magpouch_gear.ogg", t = 0},
            {s = rottle, t = 0.01},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.075},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.9},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.8, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.85},
            {s = rottle, t = 1.4},
            {s = ratel, t = 1.4},
            {s = path .. "chamber_press.ogg", t = 1.72},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.95},
            {s = common .. "grab-polymer.ogg", t = 2.075, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.13},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = ratel, t = 0.1},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.8},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.0},
            {s = rottle, t = 1.1},
            {s = ratel, t = 1.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle,  t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle,  t = 1.475},
            {s = ratel,  t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.78},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 60 Round Reloads --

    ["reload_60"] = {
        Source = "reload_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.1},
            {s = common .. "grab-polymer.ogg", t = 1.78, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "shoulder.ogg", t = 1.9},
        },
    },
    ["reload_empty_60"] = {
        Source = "reload_empty_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.475},
            {s = ratel, t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.8},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "grab-polymer.ogg", t = 2.15, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 100 Round Reloads --

    ["reload_100"] = {
        Source = "reload_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.75,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle, t = 1.1},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "grab-polymer.ogg", t = 1.85, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.0},
        },
    },
    ["reload_empty_100"] = {
        Source = "reload_empty_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 90 / 30,
        MinProgress = 2.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = rottle, t = 1.75},
            {s = path .. "chback.ogg",   t = 2.0},
            {s = common .. "cloth_4.ogg",  t = 2.05},
            {s = path .. "chamber.ogg",  t = 2.22},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.5},
            {s = common .. "grab-polymer.ogg", t = 2.55, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.6},
        },
    },

    -- 9mm 32 Round Reloads --

    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 70 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.15},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 16 / 30},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 27 / 30},
            {s = rottle, t = 1.1},
            {s = common .. "magpouchin.ogg", t = 1.55},
            {s = common .. "shoulder.ogg", t = 1.93},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_empty_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 80 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 0.1},
            {s = common .. "magpouch.ogg", t = 0.45},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 0.8},
            {s = path .. "chamber_press.ogg", t = 1.7},
            {s = rottle, t = 1.39},
            {s = common .. "shoulder.ogg", t = 2.15},
        },
    },


    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_inspect_empty"] = {
        Source = "inspect_enter_empty",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop_empty",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit_empty",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
}

local hgLookup = {
    ["default"]     = {0,4,0},
    ["tactical"]    = {2,5,0},
    ["a1"]          = {1,1,1},
    ["heat"]          = {10,10,1},
    ["heatm203"]          = {11,11,1},
    ["wood"]          = {1,1,1},
    ["lmg"]          = {3,3,1},
    ["fpw"]          = {6,6,2},
    ["ru556"]          = {7,7,3},
    ["adar"]          = {8,8,2},
    ["hk416"]          = {9,9,3},
    ["607"]          = {9,9,0},
}
-- Structure: 20in appearance, 14/11in appearance, gas block mode
-- Gas block modes: 0 standard, 1 always at 20" position, 2 at ADAR position when short, 3 at ADAR position when short and not flat

local barrLookup = {
    ["sd"] = -1,
    ["20in"] = 0,
    ["14in"] = 1,
    ["fpw"] = 1,
    ["10in"] = 2,
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    local atts = wep.Attachments
    if !IsValid(vm) then return end

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    hg = string.Replace(hg,"uf_m16_hg_","")

    local optic = atts[1].Installed
    local muzz = atts[4].Installed or barrel == "sd"
    local laser = atts[8].Installed
    local fs = atts[16].Installed
    local retro = wep:GetBuff_Override("TopMount")

    -- Retro rail
    if optic then
        if retro then
            -- Raised rail (retro)
            vm:SetBodygroup(3, retro)
        else
            -- Flat rail
            vm:SetBodygroup(1, 1)
            vm:SetBodygroup(3, 2)
        end
    end

    -- Dynamic handguard
    if barr == -1 then
        vm:SetBodygroup(5,9)
    elseif barr == 0 and hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][1])
    elseif hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][2])
    else
        vm:SetBodygroup(5,9)
    end

    -- Gas block
    if barrel == "sd" or (atts[6].Installed == "ud_m16_receiver_fpw" and barr > 0) then
        vm:SetBodygroup(6,5)
    else
        local gbPos = hgLookup[hg] and hgLookup[hg][3] or 0
        local lwr = atts[6].Installed
        local flat = (
            wep:GetBuff_Override("FrontSight")
            or atts[6].Installed == "ud_m16_receiver_fpw"
            or (optic and fs ~= "ud_m16_charm_fs" and !(wep:GetBuff_Override("IronSight") or wep:GetBuff_Override("TopMount")))
        ) and 1 or 0

        if gbPos == 1 or barr == 0 then
            vm:SetBodygroup(6, 0 + flat)
        elseif gbPos == 2 then
            vm:SetBodygroup(6, 4 + flat * 2)
        elseif gbPos == 3 then
            vm:SetBodygroup(6, 4 - flat)
        else
            vm:SetBodygroup(6, 2 + flat)
        end
    end

    -- Default flash hider
    if !muzz then
        if barr == 0 then
            vm:SetBodygroup(11,1)
        elseif barr == 1 then
            vm:SetBodygroup(11,2)
        else
            vm:SetBodygroup(11,3)
        end
    else
        vm:SetBodygroup(11,0)
    end

    -- Tactical clamp
    if laser and hg ~= "tactical" then
        if barr == 0 then
            vm:SetBodygroup(10,1)
        elseif barr == 1 then
            vm:SetBodygroup(10,3)
        else
            vm:SetBodygroup(10,2)
        end
    else
        vm:SetBodygroup(10,0)
    end

    -- Disable tac rail element with tac hg
    if hg == "tactical" and (atts[7].Installed or atts[18].Installed) then
        vm:SetBodygroup(9,0)
    end

    -- .50 Beowulf magazines
    if atts[5].Installed == "ud_m16_receiver_50beo" and !atts[11].Installed then
        vm:SetBodygroup(2, 8)
    end
end

-- RAYCAR-0, rifle barrel
local bar0_fake = "First variation of the RAYCAR rifle. Tests showed that users were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, a ratcheted three-round burst system was implemented which limited the maximum burst a user could fire to three shots.\n\nWell-rounded gun with no major downsides."

-- RAYCAR-1, carbine barrel
local bar1_fake = "Second variation of the RAYCAR rifle. It eventually replaced the RAYCAR-0 across much of the Army for its favorably low weight and comparable performance. The -1 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."

-- RAYCAR-2, commando barrel
local bar2_fake = "Third variation of the RAYCAR rifle. Developed with assistance from the Navy, the \"commando\" barrel allows for the weapon to be very compact, even short enough to be classified as a submachine gun, enhancing usability in vehicles and in enclosed spaces.\n\nVery lightweight and manuverable, but with very aggressive recoil to match."

-- RAYPAW :3
local smgDesc_fake = "Submachine gun based on the RAYCAR rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle.\n\nMore accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."

-- RBY50
local beoDesc_fake = "Aftermarket semi-automatic variant of the RAYCAR rifle firing an oversized magnum cartridge.\n\nProvides extremely high stopping power at close range."

-- RBY300
local blkDesc_fake = "Aftermarket automatic variant of the RAYCAR rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range.\n\nSlightly more inaccurate, made up with a higher stopping power and a subsonic projectile."

-- UKCAR
local ukDesc_fake = "Normally, RAYCAR style rifles are imported with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver.\n\nBit cringe, innit?"

-- RAYSAW
local lmgDesc_fake = "Configuration of the RAYCAR designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi.\n\nHeavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."

-- Fallout barrel or sumn idk
local ncrDesc_fake = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."

-- Patriot easter egg. Is it overpowered? I don't think so, a configuration like this is already pretty uncontrollable and imprecise as is, and overheating is the new magazine.
local a1, a2 = {}, {"patr1", "patr2", "patr3", "patr4", "patr5"}
SWEP.O_Hook_Override_BottomlessClip = function(wep, data)
    if wep:CheckFlags(a1, a2) then
        data.current = true
    end
end


SWEP.Hook_NameChange = function(wep, name)
    local trueNames = GetConVar("arccw_truenames"):GetBool()
    local atts = wep.Attachments
    local flat = atts[1].Installed and !wep:GetBuff_Override("TopMount")

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    local upr = string.Replace(atts[5].Installed or "default","ud_m16_receiver_","")
    local lwr = string.Replace(atts[6].Installed or "default","ud_m16_receiver_","")

    if wep:CheckFlags(a1, a2) then -- Patriot configuration
        wep.Trivia_Desc = patriotDesc
        return "The Patriot"
    elseif !trueNames then -- Custom lore-based fake names
        local pre = (lwr == "auto" and "AM" or "RAY")
        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc_fake
            if flat then
                return (sd and pre .. "SSMG-NG") or pre .. "PAW-" .. barr .. "NG"
            end
            return (sd and pre .. "SSMG") or pre .. "PAW-" .. barr
        elseif upr == "50beo" then
            wep.Trivia_Desc = beoDesc_fake
            return "RBY"--50"
        elseif upr == "300blk" then
            wep.Trivia_Desc = blkDesc_fake
            return "RBY"--300"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = bar1_fake
            return pre .. "FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc_fake
            return "UKCAR"
        else
            if barr == 0 then
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc_fake
                    return pre .. "SAW" .. (flat and "-NG" or "")
                elseif flat then
                    return pre .. "CAR-0NG"
                else
                    wep.Trivia_Desc = bar0_fake
                    return pre .. "CAR-0"
                end
            elseif barr == 1 then
                wep.Trivia_Desc = bar1_fake
                if flat then
                    return pre .. "CAR-1NG"
                end
                return pre .. "CAR-1"
            elseif barr == 2 then
                wep.Trivia_Desc = bar2_fake
                if flat then
                    return pre .. "CAR-2NG"
                end
                return pre .. "CAR-2"
            end
        end

        wep.Trivia_Desc = bar0_fake
        return pre .. "CAR-0"

    else

        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc
            if lwr == "semi" then
                return "AR-15 9mm"
            elseif flat then
                return "R0991"
            end
            return "R0635"

        end

        if lwr == "auto" then
            if upr == "a1" then
                wep.Trivia_Desc = a1Desc
                if barr == 0 then
                    return "M16A1"
                elseif barr == 1 then
                    return "M605"
                end
                wep.Trivia_Desc = carDesc
                return "CAR-15"
            end
            if barr == 0 then
                wep.Trivia_Desc = a3Desc
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc
                    return "Colt LMG"
                elseif flat and hg == "tactical" then
                    return "R0901"
                end
                return "M16A3"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                if flat then
                    return "M4A1"
                end
                return "XM4"
            else
                wep.Trivia_Desc = carDesc
                if flat then
                    wep.Trivia_Desc = m4Desc
                    if upr == "300blk" then
                        return "Mk 18"
                    end
                    return "Mk 18 Mod 0"
                end
                return "CAR-15"
            end
        elseif lwr == "semi" or upr == "50beo" then
            wep.Trivia_Desc = arDesc
            if hg == "wood" then
                wep.Trivia_Desc = ncrDesc
                if barr == 0 then
                    return "Service Rifle"
                end
                return "Service Carbine"
            elseif flat and hg == "adar" then
                return "ADAR 2-15"
            elseif barr > 0 then
                if barr == 2 and atts[10].Installed == "ud_m16_stock_buffer" then
                    return "AR-15 Pistol"
                elseif upr == "a1" and barr == 1 then
                    return "CRXM177E2B"
                else
                    return "AR-15 SBR"
                end
            elseif upr == "a1" then
                return "CRM16A1"
            end
            return "AR-15"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = m4Desc
            return "M231 FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc
            return "AR-15GB"
        else
            wep.Trivia_Desc = origDesc
            if barr == 0 and flat then
                return "M16A4"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                return "M4 Carbine"
            elseif barr == 2 then
                return "M16 Commando"
            end
        end

        wep.Trivia_Desc = origDesc
        return "M16A2"

    end
end



SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        InstalledEles = {"upper_flat"},
        Slot = {"optic","optic_sniper","ud_m16_rs"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.75, 3),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
            vmin = Vector(0, -1.6, 3 - 2),
            vmax = Vector(0, -1.6, 3 + 1),
        },
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "20\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_barrel_20.png", "smooth mips"),
        Slot = "ud_m16_blen",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Ribbed Handguard",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_hg_ribbed.png", "smooth mips"),
        Slot = "ud_m16_hg",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.63, -0.41),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "ud_m16_muzzle"},
        Bone = "m16_parent",
        VMScale = Vector(1, 1, 1),
        WMScale = VMScale,
        Offset = {
            vpos = Vector(0, -.33, 23.27),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd", "m16_stub"},
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "5.56x45mm Upper",
        DefaultAttIcon = Material("entities/att/uc_bullets/556x45.png", "smooth mips"),
        Slot = {"ud_m16_receiver"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"ud_m16_fpw"}
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Burst Lower",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_receiver_default.png", "smooth mips"),
        Slot = {"ud_m16_fcg"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"m16_nolower"}
    },
    {
        PrintName = "Underbarrel",
        Slot = "foregrip",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 6, 11),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
        SlideAmount = {
            vmin = Vector(0, .65, 11.5),
            vmax = Vector(0, .65, 7.5),
        },
		MergeSlots = {18},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 0.3, 21.25),
            vang = Angle(90, 0, -90),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ud_m16_grip"},
        DefaultAttName = "Standard Grip",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_grip_default.png", "smooth mips"),
        ExcludeFlags = {"m16_adar"}
    },
    {
        PrintName = "Stock",
        Slot = {"ud_m16_stock","go_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_stock_default.png", "smooth mips"),
        -- GSO support
        InstalledEles = {"stock_231_tube"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(-0.02, 0, -2.7),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Magazine",
        Slot = {"ud_m16_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_mag_30.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Front Sight",
        Slot = {"ud_m16_fs", "ud_m16_charm"},
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.65, 16.75), -- 21.75 or 15.75
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sight_magpul"}
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"}, -- "ud_m16_charm"
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0.48, 0.5, 3.9),
            vang = Angle(90, 0, -90),
        },
        -- MergeSlots = {17}
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -0.4, 7.2),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
    }
}
--lua/weapons/arccw_ud_r870long.lua:
return gluapack()()
--lua/weapons/arccw_ud_tac14.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_870.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Shotguns"
end

SWEP.PrintName = "Express-12 Raptor"
SWEP.TrueName = "R870 Tac-14"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ud_870_barrel_sawnoff"
SWEP.Attachments[4].Installed = "ud_870_slide_moe"
SWEP.Attachments[7].Installed = "ud_870_stock_raptor"
SWEP.Attachments[8].Installed = "ud_870_tube_reduced"

SWEP.Hook_NameChange = function()
    return (GetConVar("arccw_truenames"):GetBool() and "Remington 870") or "Express-12"
end
--lua/weapons/arccw_ud_uzicarbine.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_uzi.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets SMGs"
end

SWEP.PrintName = "IAL-C9"
SWEP.TrueName = "Uzi Carbine"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ud_uzi_body_carbine"
SWEP.Attachments[7].Installed = "ud_uzi_stock_wood"

SWEP.Hook_NameChange = function(wep)
    if !wep.Attachments[2].Installed then
        return GetConVar("arccw_truenames"):GetBool() and "Uzi" or "IAL-9"
    end
end
--lua/weapons/arccw_ur_ak.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "KF-67"
SWEP.TrueName = "AKM"

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

local descStart = "One of the first assault rifles, wielded around the world to this day for its cheap price, quick production, ease of maintenance, and infallible reliability. Consequently, it has become the most popular rifle ever; a constant of freedom fighters and third-world dictators virtually everywhere. One fifth of all small arms in existence can be traced to this design.\n\n"
local desc_762 = "The default pattern is well-rounded and hard-hitting, but kicks harder than other weapons of its class."
local desc_545 = "With a heavier frame than other service rifles, the AK-74 platform is accurate and easy to control."
local desc_74u = "This PDW variant sacrifices range and control to fit the power of a rifle into a very compact form."
local desc_9mm = "Well-rounded submachine gun that shares common parts with AK rifles. For its widespread use by a variety of security divisions, it can be described as a Russian counterpart to the MP5.\n\nThe moniker \"Vityaz\" translates to \"knight.\""
local desc_12g = "Magazine-fed semi automatic shotgun based on the Kalashnikov pattern. It is a popular civilian weapon due to the comparative simplicity of Russia's smoothbore gun licenses, but it has also been used by security firms around the world.\n\nIts low accuracy is compensated for by a much faster reload time than tube-fed designs."
local desc_556 = "This international variant has a lower damage output than the Russian cartridges, but boasts substantially lower recoil."
local desc_366 = "AK-pattern shotgun chambered in .366 TKM, a sporting cartridge that uses reshaped M43 casings. It is considered a shotgun because of its smoothbore barrel, a change made to circumvent Russian rifle laws. Despite the lack of rifling, it achieves similar ballistics to a proper AK-47."

SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = descStart .. desc_762
SWEP.Trivia_Manufacturer = "Izhmash"
SWEP.Trivia_Calibre = "7.62x39mm Soviet"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "Soviet Union"
SWEP.Trivia_Year = 1959

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "010000800120"

-- Damage --

SWEP.Damage = 50 -- 2 shot close range kill
SWEP.DamageMin = 25 -- 4 shot long range kill
SWEP.RangeMin = 30
SWEP.Range = 300 -- 3 shot until ~170m
SWEP.Penetration = 16
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.6

-- Firerate / Firemodes --

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/ak/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-rifle-01.ogg",common .. "movement-rifle-02.ogg",common .. "movement-rifle-03.ogg",common .. "movement-rifle-04.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/762x39/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-762x39-rif-ext-01.ogg",
    tail .. "fire-dist-762x39-rif-ext-02.ogg",
    tail .. "fire-dist-762x39-rif-ext-03.ogg",
    tail .. "fire-dist-762x39-rif-ext-04.ogg",
    tail .. "fire-dist-762x39-rif-ext-05.ogg",
    tail .. "fire-dist-762x39-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/762x39.mdl"
SWEP.ShellPitch = 90
SWEP.ShellScale = .666
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7 * 255, 0.2 * 255, 0.2 * 255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    [1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.61, -2, 0.45),
    Ang = Angle(0.60, 0.274, 5.53),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.5, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(6.5, 0.8, -0.2)
-- SWEP.CustomizeAng = Angle(8, 22, 15)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["barrel_74m"] = {
        VMBodygroups = {{ind = 1, bg = 3}}
    },
    ["barrel_74m_red"] = {
        VMBodygroups = {{ind = 1, bg = 10}}
    },
    ["barrel_74m_green"] = {
        VMBodygroups = {{ind = 1, bg = 11}}
    },
    ["barrel_akm"] = {
        VMBodygroups = {{ind = 1, bg = 0}}
    },
    ["barrel_alpha"] = {
        VMBodygroups = {
            {ind = 1, bg = 7},
            -- {ind = 7, bg = 6},
            -- {ind = 8, bg = 2},
        },
    },
    ["barrel_rpk"] = {
        VMBodygroups = {
            {ind = 7, bg = 1},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 32.2, 2.6),
            vang = Angle(0, 270, 0),
        }},
    Override_IronSightStruct = {
            Pos = Vector(-2.625, -2, 0.68),
            Ang = Angle(-0.1, 0.274, 5.53),
            Magnification = 1,
    }
    },
    ["barrel_rpk74m"] = {
        VMBodygroups = {
            {ind = 1, bg = 5},
            -- {ind = 7, bg = 1},
            -- {ind = 8, bg = 2}
        },
        -- AttPosMods = {[4] = {
        --     vpos = Vector(0, 32.2, 2.6),
        --     vang = Angle(0, 270, 0),
        -- }},
        -- Override_IronSightStruct = {
        -- 	Pos = Vector(-2.625, -2, 0.68),
        -- 	Ang = Angle(-0.1, 0.274, 5.53),
        -- 	Magnification = 1,
        -- }
    },
    ["barrel_krinkov"] = {
        VMBodygroups = {
            {ind = 1, bg = 6},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 4, bg = 1},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 15, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,10,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,10,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.638, -2, 0.9),
            Ang = Angle(-1, 0.12, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_vityaz"] = {
        VMBodygroups = {
            {ind = 1, bg = 8},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 16.5, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,11,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,11,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.62, -2, 0.75),
            Ang = Angle(-0.42, 0.2, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_t56"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 2},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_t56_ext"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 3},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_vepr"] = {
        VMBodygroups = {
            --{ind = 1, bg = 9},
            {ind = 7, bg = 4},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 28.5, 2.7),
            vang = Angle(0, 270, -0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, -2, 0.76),
            Ang = Angle(-0.3, 0.18, 5.53),
            Magnification = 1,
        }
    },

    ["ur_ak_hg_vepr"] = {
        VMBodygroups = {
            {ind = 1, bg = 9},
        },
    },

    ["barrel_105"] = {
        VMBodygroups = {
            --{ind = 1, bg = 3},
            {ind = 7, bg = 2},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 19.9, 2.7),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.6, -2, 0.48),
            Ang = Angle(0.6, 0.265, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_dong"] = {
        VMBodygroups = {{ind = 1, bg = 2}}, -- This will show up regardless of barrel selection because underbarrel atts are always processed after barrel atts
        AttPosMods = {[6] = {
            SlideAmount = {
                vmin = Vector(0,12,1.9),
                vmax = Vector(0,12,1.9)
            },
        }}
    },

    ["muzzle_akm"] = {
        VMBodygroups = {{ind = 8, bg = 1}}
    },
    ["muzzle_ak74"] = {
        VMBodygroups = {{ind = 8, bg = 3}}
    },
    ["muzzle_aku"] = {
        VMBodygroups = {{ind = 8, bg = 6}}
    },
    ["muzzle_bayonet"] = {
        VMBodygroups = {{ind = 11, bg = 1}}
    },

    ["stock_alpha"] = {
        VMBodygroups = {
            {ind = 6, bg = 4},
            {ind = 3, bg = 1},
        }

    },
    ["stock_aks"] = {
        VMBodygroups = {
            {ind = 6, bg = 3},
            {ind = 3, bg = 1},
    }
    },
    ["stock_aks_folded"] = {
        VMBodygroups = {
            {ind = 6, bg = 10},
            {ind = 3, bg = 1},
        }

    },
    ["stock_underfolder"] = {
        VMBodygroups = {{ind = 6, bg = 2}}
    },
    ["stock_underfolder_folded"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["stock_ak74m"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 12}
        }
    },
    ["stock_ak74m_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 13}
        }
    },
    ["stock_rpk"] = {
        VMBodygroups = {{ind = 6, bg = 5}}
    },
    ["stock_akn"] = {
        VMBodygroups = {{ind = 6, bg = 0}}
    },
    ["stock_skeletal"] = {
        VMBodygroups = {
            {ind = 6, bg = 6},
            {ind = 3, bg = 1},
        }
    },
    ["stock_vepr"] = {
        VMBodygroups = {
            {ind = 6, bg = 7},
            {ind = 9, bg = 4}
        }
    },
    ["stock_none"] = {
        VMBodygroups = {
            {ind = 6, bg = 9},
            {ind = 3, bg = 1},
        }
    },

    ["mag_762_75"] = {
        VMBodygroups = {{ind = 2, bg = 1}}
    },
    ["mag_762_bakelite"] = {
        VMBodygroups = {{ind = 2, bg = 11}}
    },
    ["mag_762_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 12}}
    },
    ["mag_545_30"] = {
        VMBodygroups = {{ind = 2, bg = 2}}
    },
    ["mag_556_30"] = {
        VMBodygroups = {{ind = 2, bg = 10}}
    },
    ["mag_545_45"] = {
        VMBodygroups = {{ind = 2, bg = 3}}
    },
    ["mag_9mm"] = {
        VMBodygroups = {{ind = 2, bg = 4}}
    },
    ["mag_12g"] = {
        VMBodygroups = {{ind = 2, bg = 5}}
    },
    ["mag_366"] = {
        VMBodygroups = {{ind = 2, bg = 6}}
    },

    ["grip_akm"] = {
        VMBodygroups = {{ind = 9, bg = 0}}
    },
    ["grip_alpha"] = {
        VMBodygroups = {{ind = 9, bg = 2}}
    },
    ["grip_saiga"] = {
        VMBodygroups = {{ind = 9, bg = 3}}
    },

    ["cover_ribbed"] = {
        VMBodygroups = {{ind = 10, bg = 0}}
    },
    ["cover_alpha"] = {
        VMBodygroups = {{ind = 10, bg = 1}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.68),
            vang = Angle(0, -90, 0),
        }}
    },
    ["optic_raillaser"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.95, 2.5, 4.05),
                vang = Angle(0, -90, 125),
            },
        },
    },
    ["cover_ak12"] = {
        VMBodygroups = {{ind = 10, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.67),
            vang = Angle(0, -90, 0),
        }}
    },

    ["grip_ak12"] = {
        VMBodygroups = {{ind = 9, bg = 5}}
    },
    ["stock_ak12"] = {
        VMBodygroups = {{ind = 6, bg = 11}},
    },
    ["handguard_ak12"] = {
        VMBodygroups = {{ind = 1, bg = 12}},
        --[[AttPosMods = {[6] = {
            vpos = Vector(0, 11.75, 2.2),
            vang = Angle(90, -90, -90),
        }}]]
        AttPosMods = {
            [8] = {
                vpos = Vector(-0.7, 13.5, 3.8),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            },
            [7] = {
                vpos = Vector(0, 11.75, 2.2),
                vang = Angle(90, -90, -90),
            }
        },
    },
    ["barrel_ak12"] = {
        VMBodygroups = {
            {ind = 7, bg = 6},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 23.5, 2.8),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.68, 0, 1.3),
            Ang = Angle(-2.02, 0.028, 5.53),
            Magnification = 1,
        }
        --RequireFlags = {"cover_rail"},
    },
    ["muzzle_ak12"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["reciever_ak12"] = {
        VMBodygroups = {{ind = 0, bg = 1}}
    },
    ["sight_ak12"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
        RequireFlags = {"cover_rail", "ak_railedguard"},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, 0, 0.79),
            Ang = Angle(-1.12, 0.116, 5.53),
            Magnification = 1,
        },
        Override_IronSightStruct_Priority = 2,
    },
    ["mag_545_ak12"] = {
        VMBodygroups = {{ind = 2, bg = 7}}
    },
    ["mag_545_black"] = {
        VMBodygroups = {{ind = 2, bg = 9}}
    },
    ["mag_308"] = {
        VMBodygroups = {{ind = 2, bg = 8}}
    },

    ["cover_trail"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 8.2, 5.20),
            vang = Angle(0, -90, 0),
        }}
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local akOptics = {["uc_optic_pso1"] = true, ["uc_optic_kobra"] = true} -- Will need to update this list if more AK optics get added
    local railHgs = {["default"] = true, ["type3"] = true}
    local bipodBarrs = {["rpk"] = true}
    local shortBarrs = {["krinkov"] = true, ["vityaz"] = true}
    local intCals = {["545"] = true, ["556"] = true, ["545_ak12"] = true}

    local optic = wep.Attachments[1].Installed
    local barr = string.Replace(wep.Attachments[2].Installed or "default","ur_ak_barrel_","")
    local hg = string.Replace(wep.Attachments[3].Installed or "default","ur_ak_hg_","")
    local muzz = wep.Attachments[4].Installed
    local cal = string.Replace(wep.Attachments[5].Installed or "default","ur_ak_cal_","")
    local ub = wep.Attachments[7].Installed-- or wep.Attachments[17].Installed
    local upper = wep.Attachments[15].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    local taclaser = (wep.Attachments[16].Installed == "ur_ak_charm_tl")

    local vm = data.vm
    if !IsValid(vm) then return end

    -- Default muzzle devices
    if !muzz or muzz == "ur_ak_muzzle_bayonet" then
        if barr == "ak12" and (cal == "default" or intCals[cal]) then
            vm:SetBodygroup(8,3)
        elseif barr == "krinkov" then
            vm:SetBodygroup(8,4)
        elseif barr == "default" or barr == "t56" then
            if cal == "default" then
                vm:SetBodygroup(8,1)
            elseif intCals[cal] then
                vm:SetBodygroup(8,3)
            else
                vm:SetBodygroup(8,0)
            end
        end
    elseif barr == "default" then
        vm:SetBodygroup(8,0)
    else
        vm:SetBodygroup(8,2)
    end

    --
    if taclaser and !akOptics[optic] then
        vm:SetBodygroup(12,2)
    else
        if optic and !alpha and !akOptics[optic] then
            vm:SetBodygroup(12,1)
        else
            vm:SetBodygroup(12,0)
        end
    end

    -- Railed underbarrel
    if ub and hg != "ur_ak_hg_dong" and barr != "vityaz" then
        if barr == "krinkov" then
            vm:SetBodygroup(13,2)
        elseif railHgs[hg] then
            vm:SetBodygroup(1,13)
        else
            vm:SetBodygroup(13,1)
        end
    else
        vm:SetBodygroup(13,0)
    end

    -- RPK bipod
    if bipodBarrs[barr] then
        vm:SetBodygroup(7, (wep:GetInBipod() and (wep.LastAnimKey ~= "enter_bipod" or wep.LastAnimFinishTime < CurTime())) and 7 or 1)
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-7, 4, -4),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_sniper","ur_ak_optic"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 2, 4.92),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, -0.0),
        CorrectiveAng = Angle(-1.9, 180.15, 0),
        VMScale = Vector(1, 1, 1),
        -- SlideAmount = {
        --     vmin = Vector(0, 2-1, 4.55),
        --     vmax = Vector(0, 2+0.5, 4.55),
        -- },
--        RequireFlags = {"cover_rail"},
--        HideIfBlocked = true,
        -- InstalledEles = {"optic_rail"},
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "16\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_ak/barrel/std.png", "mips smooth"),
        Slot = "ur_ak_barrel",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Factory Handguard",
        DefaultAttIcon = Material("entities/att/ur_ak/handguards/std.png", "mips smooth"),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        Slot = "ur_ak_hg",
        ExcludeFlags = {"barrel_carbine"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle","ur_ak_muzzle"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 24.1, 2.7),
            vang = Angle(0, 270, 0),
        },
        ExcludeFlags = {"ur_ak_nomuzzle"},
        --Installed = "ur_ak_muzzle_akm"
    },
    {
        PrintName = "Receiver",
        DefaultAttName = "7.62x39mm Reciever",
        DefaultAttIcon = Material("entities/att/uc_bullets/762x39.png", "mips smooth"),
        Slot = {"ur_ak_cal"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        DefaultFlags = {"cal_default"}
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_ak_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_ak/magazines/762_30.png", "mips smooth"),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip","ur_ak_ub"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        VMScale = Vector(1, 1, 1),
        SlideAmount = {
            vmin = Vector(0,10.5,1.9),
            vmax = Vector(0,13.5,1.9)
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs"},
        MergeSlots = {17},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 19.6, 2.1),
            vang = Angle(0, 270, 0),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ur_ak_grip"},
        DefaultAttName = "Factory Grip",
        DefaultAttIcon = Material("entities/att/ur_ak/grip_modern.png", "mips smooth"),
        ExcludeFlags = {"stock_vepr"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_ak_stock"},
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_ak/stock/n.png", "mips smooth"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Dust Cover",
        DefaultAttName = "Ribbed Dust Cover",
        DefaultAttIcon = Material("entities/att/ur_ak/dustcover_stock.png", "mips smooth"),
        Slot = {"ur_ak_cover"},
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "ur_ak_charm"},
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0.6, 6.7, 2.2),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 9.9, 2.9),
            vang = Angle(90, -90, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs","barrel_rpk"},
        Hidden = true,
    }
}

function SWEP:Hook_TranslateAnimation(anim)
    if anim == "fire_iron" then
        if self:GetBuff_Override("NoStock") then return "fire" end
    elseif anim == "fire_iron_empty" then
        if self:GetBuff_Override("NoStock") then return "fire_empty" end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local foldStocks = {["underfolder"] = true,["aks"] = true}
    local akCals = {["762"] = true,["545"] = true}
    local shortBarrs = {["krinkov"] = true,["vityaz"] = true}
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()

    local start = "AK"
    local mid = ""
    local post = "M"
    local noN = false

    if fakeNames then
        start = "KF"
        post = "-67"
    end

    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default", "ur_ak_barrel_", "")
    local hg = string.Replace(atts[3].Installed or "default", "ur_ak_hg_", "")
    local cal = string.Replace(atts[5].Installed or "762", "ur_ak_cal_", "")
    local stock = string.Replace(atts[10].Installed or "default", "ur_ak_stock_", "")
    local upper = atts[11].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    -- local ak12 = alpha and barr == "ak12"

    wep.Trivia_Desc = descStart .. desc_762
    wep.Trivia_Mechanism = "Gas-Operated Rotating Bolt"

    if alpha then noN = true end

    if atts[14].Installed == "uc_fg_civvy" then
        start = (fakeNames and "Amur") or "Vepr"
        if cal == "12g" then
            post = "-12"
            wep.Trivia_Desc = desc_12g
        elseif cal == "545_ak12" or cal == "545" then
            post = " 5.45"
            wep.Trivia_Desc = descStart .. desc_545
        elseif cal == "762" then
            post = " 7.62"
        elseif cal == "9mm" then
            start = "Saiga"
            post = "-9"
            wep.Trivia_Desc = desc_9mm
            wep.Trivia_Mechanism = "Blowback"
        else
            post = " ." .. cal
        end
        return start .. post
    end

    if cal == "9mm" then
        if fakeNames then
            start = "Bogatyr"
            post = " SMG"
        else
            start = "PP"
            post = "-19 Vityaz"
        end
        wep.Trivia_Desc = desc_9mm
        wep.Trivia_Mechanism = "Blowback"
    -- elseif cal == "12g" then
    --     start = "Saiga"
    --     if shortBarrs[barr] then
    --         post = "-12K"
    --     else
    --         post = "-12"
    --     end
    --     wep.Trivia_Desc = desc_12g -- Obsolete
    elseif cal == "366" then
        if barr == "vepr" or string.find(atts[14].Installed or "","rifling") then
            start = (fakeNames and "Amur") or "Vepr"
            post = " .366"
        else
            start = (fakeNames and "KFN") or "VPO"
            post = "-209"
            wep.Trivia_Desc = desc_366
        end
    elseif cal == "308" then
        post = "-308"
    -- elseif cal == "545_ak12" or ak12 then
    --     noN = true
    --     if string.StartWith(cal,"545") then
    --         post = "-12"
    --         wep.Trivia_Desc = descStart .. desc_545
    --     elseif cal == "762" then
    --         post = "-15"
    --     elseif cal == "556" then
    --         post = "-18"
    --     end
    --     if string.EndsWith(barr,"105") or shortBarrs[barr] then
    --         post = post .. "K"
    --     end -- Obsolete
    elseif barr == "rpk" or barr == "rpk74m" then
        start = (fakeNames and "PKF") or "RPK"
        if !fakeNames and barr == "rpk" and cal == "762" then
            post = ""
        end
    elseif cal == "762" then
        if barr == "t56" then
            noN = true
            if fakeNames then
                start = "Yucha"
                post = " 7"
            else
                start = "Type "
                post = "56"
            end
        elseif (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = "-103"
        end
    elseif cal == "556" then
        if fakeNames then
            post = "-45"
        elseif string.EndsWith(barr,"105") then
            post = "-102"
        else
            post = "-101"
        end
        wep.Trivia_Desc = descStart .. desc_556
    end

    if foldStocks[stock] and akCals[cal] and !string.StartWith(barr,"105") then
        if cal == "762" then
            if barr == "t56" then
                post = post .. "-1"
            elseif !fakeNames then
                post = "MS"
            else
                mid = "S"
            end
        else
            mid = "S"
        end
    end

    if cal == "545" then
        wep.Trivia_Desc = descStart .. desc_545
        if (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = (fakeNames and "-76M") or "-74M"
        elseif shortBarrs[barr] then
            if fakeNames then
                post = "-76"
                mid = mid .. "U"
            else
                post = "-74U"
            end
            wep.Trivia_Desc = descStart .. desc_74u
        else
            post = (fakeNames and "-76") or "-74"
        end
    end

    if akCals[cal] then
        if string.EndsWith(barr,"105") then
            noN = true
            if cal == "545" then
                post = "-105"
            elseif cal == "762" then
                post = "-104"
            elseif cal == "556" then
                post = "-102"
            end
        else
            -- if shortBarrs[barr] then
            --     post = post .. "U" -- I know I said the AK-47U doesn't exist, but we have fucking Glock 44 Autos so I warmed up to it
            --     wep.Trivia_Desc = descStart .. desc_74u
            -- end
            if !noN and atts[1].Installed then
                post = post .. "N"
            end
        end

    end

    return start .. mid .. post
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },
    ["fire"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = common .. "magpouch.ogg", t = 0.0, v = 0.45},
            {s = path .. "reload_start.ogg", 	 t = 0.025},
            {s = rottle,  t = 0.05},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.38},
            {s = path .. "grab.ogg", t = 1.9, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.0},
            {s = path .. "shoulder.ogg", t = 2.15},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15, v = 0.5},
            {s = rottle,  t = 1.16},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = path .. "grab.ogg", t = 2.3, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.4},
            {s = path .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_75"] = {
        Source = "reload_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.6,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = rottle,  t = 1.75},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.1},
            {s = path .. "shoulder.ogg", t = 2.25},
        },
    },
    ["reload_empty_75"] = {
        Source = "reload_drum_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.6,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = rottle,  t = 1.9},
            {s = path .. "chback.ogg",    t = 2.37},
            {s = path .. "chamber.ogg",    t = 2.48},
            {s = common .. "shoulder.ogg", t = 2.78},
            {s = path .. "shoulder.ogg", t = 2.93},
        },
    },
    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.73},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.4},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_9mm_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.85},
            {s = ratel, t = 1.1},
            {s = common .. "pistol_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_9.ogg",    t = 1.8},
            {s = path .. "chamber_9.ogg",    t = 2.05},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_10rnd"] = {
        Source = "reload_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_10rnd"] = {
        Source = "reload_10rnd_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_308"] = {
        Source = "reload_308",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_308"] = {
        Source = "reload_308_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 1.0},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_308.ogg",    t = 1.85},
            {s = path .. "chamber_308.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_12g"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_12g"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5, v = 0.25},
            {s = ratel, t = 0.55},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.75},
            {s = path .. "12ga/chback.ogg",    t = 1.85},
            {s = path .. "12ga/chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_sprint"] = {
        Source = "sprint_start",
        Time = 0.9,
    },
    ["idle_sprint"] = {
        Source = "sprint_idle",
    },
    ["exit_sprint"] = {
        Source = "sprint_end",
        Time = 1.25,
    },
    ["unjam"] = {
        Source = "jamfix",
        -- Time = 45 / 30,
        ShellEjectAt = 0.65,
        -- LHIK = true,
        -- LHIKIn = 0.3,
        -- LHIKEaseIn = 0.4,
        -- LHIKEaseOut = 0.15,
        -- LHIKOut = 0.4,
        -- SoundTable = {                                             zenith do noises here
        --     {s = path .. "chback.ogg",   t = 0.15},
        --     {s = common .. "cloth_4.ogg",  t = 0.5},
        --     {s = path .. "chamber.ogg",  t = 0.5},
        -- },
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "presscheck_1.ogg",    t = 0.2},
            {s = path .. "chback.ogg",    t = 0.6},
            {s = path .. "chamber.ogg",    t = 0.7},
            {s = common .. "grab.ogg", t = 1.1},
            {s = common .. "shoulder.ogg", t = 1.15},
        }
    },
    ["bash_bayonet"] = {
        Source = "bayonet",
        --Time = 1.2,
        --MinProgress = .7,
        SoundTable = {
            {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },

    ["exit_bipod"] = {
        Source = "bipod_undeploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },
    ["enter_bipod"] = {
        Source = "bipod_deploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}                   -- yeah here too
        }
    },
}

SWEP.Hook_Think = ArcCW.UC.ADSReload
--lua/weapons/arccw_ur_akms.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_ak.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Rifles"
end

SWEP.PrintName = "KFS-67" -- make this something russian and cool
SWEP.TrueName = "AKMS"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[6].Installed = "ur_ak_mag_762_bakelite"
SWEP.Attachments[3].Installed = "ur_ak_hg_dong"
SWEP.Attachments[10].Installed = "ur_ak_stock_underfolder"

SWEP.Attachments[10].ToggleLock = true
--lua/weapons/arccw_ur_at.lua:
return gluapack()()
--lua/weapons/arccw_ur_aw.lua:
return gluapack()()
--lua/weapons/arccw_ur_db.lua:
return gluapack()()
--lua/weapons/arccw_ur_deagle.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_pistol_deagle"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/50ae.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 90
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.TracerNum = 1
SWEP.TracerWidth = 1
SWEP.ShootPitch = 100

-- Fake name --

SWEP.PrintName = "Predator .50"

-- True name --

SWEP.TrueName = "Desert Eagle"

-- Trivia --

SWEP.Trivia_Class = "Pistol"
SWEP.Trivia_Desc = "Unorthodox pistol in both weight and design, marketed as an alternative to high-caliber revolvers. Its huge rounds, unrivaled in power for a handgun cartridge, can easily blast a human skull apart.\nDespite being one of the most famous weapons in action culture, it rarely sees practical use because of its massive, bulky frame and pointlessly large caliber.\n\nWe both know that won't stop you."
SWEP.Trivia_Manufacturer = "ISM"
SWEP.Trivia_Calibre = ".50 Action Express"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "Israel"
SWEP.Trivia_Year = 1983

-- Weapon slot --

SWEP.Slot = 1

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Magnum Research"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_deagle.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_deagle.mdl"
SWEP.ViewModelFOV = 60
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER

-- Damage parameters --

SWEP.Damage = 80 -- 2 shot close range kill
SWEP.DamageMin = 12 -- 9 shot long range kill (big bullet falls off quickly)
SWEP.RangeMin = 10
SWEP.Range = 120 -- 2 shot until ~50m
SWEP.Penetration = 9
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 470
SWEP.PhysBulletMuzzleVelocity = 470

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Jamming --

--SWEP.Malfunction = true
SWEP.MalfunctionJam = true
--SWEP.MalfunctionMean = 21
SWEP.MalfunctionPostFire = true
SWEP.MalfunctionTakeRound = false

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 7
SWEP.ExtendedClipSize = 14
SWEP.ReducedClipSize = 5

-- Recoil --

SWEP.Recoil = 3.95
SWEP.RecoilSide = 1

SWEP.RecoilRise = 0.5
SWEP.VisualRecoilMult = 1.5
SWEP.MaxRecoilBlowback = 2
SWEP.MaxRecoilPunch = 6

SWEP.Sway = 1.1

-- Firerate / Firemodes --

SWEP.Delay = 60 / 200
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_357"
SWEP.NPCWeight = 70

-- Accuracy --

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 600
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "357"
SWEP.MagID = "deagle"

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.25
SWEP.ShootSpeedMult = 0.8

-- Length --

SWEP.BarrelLength = 12
SWEP.ExtraSightDist = 10

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.3, 3, 1)
SWEP.HolsterAng = Angle(-5, 15, -20)

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"

SWEP.IronSightStruct = {
     Pos = Vector(-2.549, 1, 1.505),
     Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "",
     ViewModelFOV = 55,
}

SWEP.ActivePos = Vector(-0.5, 1.5, 1.15)
SWEP.ActiveAng = Angle(0.5, 0.5, -2)

SWEP.CustomizePos = Vector(-1, -2, 2)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2.2, 1, 0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-10.5, 4, -4),
    ang        =    Angle(-6, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
}

-- Weapon sounds --

local path = ")weapons/arccw_ur/deagle/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local rutle = {common .. "movement-smg-03.ogg",common .. "movement-smg-04.ogg"}

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}

SWEP.ShootSoundSilenced = path .. "fire_sup.ogg"
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = common .. "sup_tail.ogg"
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/50ae/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-50ae-pistol-ext-01.ogg",
    tail .. "fire-dist-50ae-pistol-ext-02.ogg",
    tail .. "fire-dist-50ae-pistol-ext-03.ogg",
    tail .. "fire-dist-50ae-pistol-ext-04.ogg",
    tail .. "fire-dist-50ae-pistol-ext-05.ogg",
    tail .. "fire-dist-50ae-pistol-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-shotgun-01.ogg",
    common .. "fire-dist-int-shotgun-02.ogg",
    common .. "fire-dist-int-shotgun-03.ogg",
    common .. "fire-dist-int-shotgun-04.ogg",
    common .. "fire-dist-int-shotgun-05.ogg",
    common .. "fire-dist-int-shotgun-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 0.75
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [1] = "Bullet1",    [2] = "Bullet2",    [3] = "Bullet3", [4] = "Bullet4",    [5] = "Bullet5",    [6] = "Bullet6", [7] = "Bullet7"
}

SWEP.DefaultBodygroups = "000000000"

SWEP.AttachmentElements = {
    ["ur_deagle_barrel_modern"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["ur_deagle_barrel_compact"] = {
        VMBodygroups = {{ind = 1, bg = 5}},
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 0, .15),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["ur_deagle_barrel_compen"] = {
        VMBodygroups = {{ind = 1, bg = 4}},
    },
    ["ur_deagle_barrel_ext"] = {
        VMBodygroups = {{ind = 1, bg = 2}},
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 0, 1.95),
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["ur_deagle_barrel_marksman"] = {
        VMBodygroups = {{ind = 1, bg = 3}},
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.05, 5.1),
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["ur_deagle_barrel_annihilator"] = {
        VMBodygroups = {{ind = 1, bg = 6}},
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.05, 1.25),
                vang = Angle(90, 0, -90),
            },
        },
    },

    ["ur_deagle_mag_ext"] = {
        VMBodygroups = {{ind = 2, bg = 1}}
    },

    ["ur_deagle_grip_wooden"] = {
        VMBodygroups = {{ind = 4, bg = 1}}
    },
    ["ur_deagle_grip_rubber"] = {
        VMBodygroups = {{ind = 4, bg = 2}}
    },

    ["tac_rail"] = {
        VMBodygroups = {{ind = 5, bg = 1}}
    },
    ["ur_deagle_caliber_44"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["ur_deagle_caliber_357"] = {
        VMBodygroups = {{ind = 6, bg = 2}}
    },
    ["ur_deagle_caliber_410"] = {
        VMBodygroups = {{ind = 6, bg = 3}}
    },

    ["ur_deagle_skin_black"] = {
        VMSkin = 1,
    },
    ["ur_deagle_skin_gold"] = {
        VMSkin = 2,
    },
    ["ur_deagle_skin_chrome"] = {
        VMSkin = 3,
    },
    ["ur_deagle_skin_modern"] = {
        VMBodygroups = {{ind = 0, bg = 1}},
        VMSkin = 3,
    },    
    ["ur_deagle_skin_sex"] = {
        VMBodygroups = {{ind = 0, bg = 1}},
        VMSkin = 4,
    },
}

SWEP.Hook_ModifyBodygroups = function(wep,data)
    local vm = data.vm
    if !IsValid(vm) then return end
    local optic = wep.Attachments[1].Installed
    local tritium = (optic == "ur_deagle_tritium")
    local barrel = wep.Attachments[2].Installed or 0

    if tritium then
        -- Setup for when we introduce new barrel options
        if barrel == "ur_deagle_barrel_marksman" then
            vm:SetBodygroup(3,3)
        elseif barrel == "ur_deagle_barrel_ext" then
            vm:SetBodygroup(3,2)
        elseif barrel == "ur_deagle_barrel_compact" then
            vm:SetBodygroup(3,4)
        elseif barrel == "ur_deagle_barrel_annihilator" then
            vm:SetBodygroup(3,5)
        else
            vm:SetBodygroup(3,1)
        end
    -- elseif optic and barrel == 0 then
    --     vm:SetBodygroup(1,1)
    end

    if barrel == "ur_deagle_barrel_annihilator" then
        if vm:GetBodygroup(5) == 1 then
            vm:SetBodygroup(5,2)
        end
    end
end

SWEP.Hook_NameChange = function(wep, name)
    if wep.Attachments[2].Installed == "ur_deagle_barrel_annihilator" then
        return "Annihilator"
    elseif !GetConVar("arccw_truenames"):GetBool() then
        local add = ".50"
        local cal = wep.Attachments[3].Installed

        if cal == "ur_deagle_caliber_357" then
            add = ".357"
        elseif cal == "ur_deagle_caliber_44" then
            add = ".44"
        elseif cal == "ur_deagle_caliber_410" then
            add = ".410"
        end

        return "Predator " .. add
    else
        return "Desert Eagle"
    end
end

-- Animations --

SWEP.Animations = {
    ["idle_empty"] = {
        Source = "idle_empty",
        Time = 120 / 60,
    },
    ["idle_jammed"] = {  -- pistol-like malfucntions not implemented yet in arccw
        Source = "idle_jammed",
        Time = 120 / 60,
    },
    ["idle"] = {
        Source = "idle",
        Time = 120 / 60,
    },
    ["ready"] = {
        Source = "ready",
        Time = 73 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = path .. "slidepull.ogg", t = 12 / 60, c = ca },
            { s = path .. "chamber.ogg", t = 20 / 60, c = ca },
        },
    },
    ["draw"] = {
        Source = "draw",
        ProcDraw = true,
        SoundTable = {
            --{s = path .. "draw.ogg", t = 0}, -- Not Temporary
            {s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["holster"] = {
        Source = "holster",
        ProcHolster = true,
        SoundTable = {
            {s = rottle, t = 0},
            --{s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },

    ["fire"] = {
        Source = {"fire_01", "fire_02", "fire_03"},
        Time = 0.9,
        ShellEjectAt = 0.05,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire_01", "fire_02", "fire_03"},
        Time = 0.9,
        ShellEjectAt = 0.05,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_jammed"] = {
        Source = "fire_jammed",
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 0.9,
        ShellEjectAt = 0.05,
        SoundTable = {{ s = path .. "mech_last.ogg", t = 0 }},
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 0.9,
        ShellEjectAt = 0.05,
        SoundTable = {{ s = path .. "mech_last.ogg", t = 0 }},
    },

    -- 7-R Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.3525,
        Time = 2.2,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.6,
        LHIKOut = 0.62,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = common .. "magrelease.ogg", t = 7 / 60, c = ca },
            { s = path .. "magout.ogg", t = 6 / 60, c = ca },
            { s = rottle, t = 10 / 60, c = ca },
            { s = common .. "magpouch_pull_small.ogg", t = 30 / 60, c = ca },
            { s = rottle, t = 55 / 60, c = ca },
            { s = path .. "magin_miss.ogg", t = 61 / 60, c = ca },
            { s = path .. "magin_old.ogg", t = 66 / 60, c = ca },
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.75,
        Time = 2.55,
        LastClip1OutTime = 0.76,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.55,
        LHIKOut = 0.7,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = common .. "magrelease.ogg", t = 7 / 60, c = ca },
            { s = path .. "magout_old.ogg", t = 8 / 60, c = ca },
            { s = rottle, t = 10 / 60, c = ca },
            { s = common .. "magpouch_pull_small.ogg", t = 26 / 60, c = ca },
            { s = common .. "pistol_magdrop.ogg", t = 40 / 60, c = ca },
            { s = rottle, t = 55 / 60, c = ca },
            { s = path .. "magin_miss.ogg", t = 58 / 60, c = ca },
            { s = path .. "magin_old.ogg", t = 62 / 60, c = ca },
            { s = path .. "chamber.ogg", t = 90 / 60, c = ca },
            { s = rottle, t = 75 / 60, c = ca },
        },
    },

    -- 10-R Reloads --

    ["reload_10"] = {
        Source = "reload_exte",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.3525,
        Time = 139 / 60,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.6,
        LHIKOut = 0.62,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = common .. "magrelease.ogg", t = 7 / 60, c = ca },
            { s = path .. "magout.ogg", t = 6 / 60, c = ca },
            { s = rottle, t = 10 / 60, c = ca },
            { s = common .. "magpouch.ogg", t = 30 / 60, c = ca },
            { s = rottle, t = 55 / 60, c = ca },
            { s = path .. "magin_miss.ogg", t = 64 / 60, c = ca },
            { s = path .. "magin_old.ogg", t = 71 / 60, c = ca },
        },
    },
    ["reload_empty_10"] = {
        Source = "reload_empty_exte",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.75,
        Time = 160 / 60,
        LastClip1OutTime = 0.76,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.55,
        LHIKOut = 0.7,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = common .. "magrelease.ogg", t = 7 / 60, c = ca },
            { s = path .. "magout_old.ogg", t = 8 / 60, c = ca },
            { s = rottle, t = 10 / 60, c = ca },
            { s = common .. "magpouch.ogg", t = 26 / 60, c = ca },
            { s = common .. "pistol_magdrop.ogg", t = 40 / 60, c = ca },
            { s = rottle, t = 55 / 60, c = ca },
            { s = path .. "magin_miss.ogg", t = 60 / 60, c = ca },
            { s = path .. "magin_old.ogg", t = 66 / 60, c = ca },
            { s = path .. "chamber.ogg", t = 94 / 60, c = ca },
            { s = rottle, t = 75 / 60, c = ca },
        },
    },

    ["unjam"] = {
        Source = "unjam",
        Time = 0.9,
        -- ShellEjectAt = 0.65,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "unjam.ogg", t = .4}
        },
        LHIK = true,
        LHIKIn = .2,
        LHIKOut = .2,
        LHIKEaseOut = .75,
    },
    -- Inspecc --
                                    -- disabled due to suck balls
    ["enter_inspect"] = {
        Source = "enter_inspect",
        time = 35 / 60,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = rutle, t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "idle_inspect",
        time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect"] = {
        Source = "exit_inspect",
        time = 66 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.84,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = common .. "magrelease.ogg", t = 7 / 60, c = ca },
            { s = path .. "magout.ogg", t = 8 / 60, c = ca },
            { s = rottle, t = 100 / 60, c = ca },
            { s = path .. "magin_miss.ogg", t = 106 / 60, c = ca },
            { s = path .. "magin_old.ogg", t = 114 / 60, c = ca },
            { s = path .. "rack1.ogg", t = 155 / 60, c = ca },
            { s = rottle, t = 160 / 60, c = ca },
            { s = path .. "rack2.ogg", t = 178 / 60, c = ca },
            { s = rottle, t = 180 / 60, c = ca },
        },
    },

    ["enter_inspect_empty"] = {
        Source = "enter_inspect_empty",
        time = 35 / 60,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKOut = 0,
        SoundTable = {
        },
    },
    ["idle_inspect_empty"] = {
        Source = "idle_inspect_empty",
        time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty"] = {
        Source = "exit_inspect_empty",
        time = 66 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.84,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = common .. "magrelease.ogg", t = 7 / 60, c = ca },
            { s = path .. "magout.ogg", t = 8 / 60, c = ca },
            { s = rottle, t = 100 / 60, c = ca },
            { s = path .. "magin_miss.ogg", t = 106 / 60, c = ca },
            { s = path .. "magin_old.ogg", t = 114 / 60, c = ca },
            { s = rottle, t = 160 / 60, c = ca },
        },
    },

    ["enter_inspect_jammed"] = {
        Source = "enter_inspect_jammed",
        time = 35 / 60,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKOut = 0,
        SoundTable = {
        },
    },
    ["idle_inspect_jammed"] = {
        Source = "idle_inspect_jammed",
        time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_jammed"] = {
        Source = "exit_inspect_jammed",
        time = 66 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.84,
        SoundTable = {
            { s = rottle, t = 0 / 60, c = ca },
            { s = common .. "magrelease.ogg", t = 7 / 60, c = ca },
            { s = path .. "magout.ogg", t = 8 / 60, c = ca },
            { s = rottle, t = 100 / 60, c = ca },
            { s = path .. "magin_miss.ogg", t = 106 / 60, c = ca },
            { s = path .. "magin_old.ogg", t = 114 / 60, c = ca },
            { s = rottle, t = 160 / 60, c = ca },
        },
    },
}

-- ADS animation blending, thanks fesiug --

SWEP.Hook_Think = function(wep)
    if IsValid(wep) and wep.ArcCW then
        local vm = wep:GetOwner():GetViewModel()

        local delta = 1-wep:GetSightDelta()

        local bipoded = wep:GetInBipod()
        wep.ADSBipodAnims = math.Approach(wep.ADSBipodAnims or 0, bipoded and 1 or 0, FrameTime() / 0.5)

        vm:SetPoseParameter("sights", Lerp( math.ease.InOutCubic(math.max(delta, wep.ADSBipodAnims)), 0, 1)) -- thanks fesiug

        local slot = wep.Attachments[3].Installed
        if wep.Attachments[7].Installed or slot == "ur_deagle_caliber_357" then
            vm:SetPoseParameter("light", 1)
        elseif slot == "ur_deagle_caliber_44" then
            vm:SetPoseParameter("light", .5)
        else
            vm:SetPoseParameter("light", 0)
        end
    end
end


-- Attachments --

SWEP.CamAttachment = 3

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = {"optic_lp","ur_deagle_tritium","optic"},
        DefaultAttName = "Iron Sights",
        Bone = "Body",
        Offset = {
            vpos = Vector(0, -5.15, 6.4),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Barrel",
        Slot = {"ur_deagle_barrel"},
        DefaultAttIcon = Material("entities/att/acwatt_ur_deagle_barrel.png","mips smooth"),
        DefaultAttName = "6\" Standard Barrel",
        Bone = "Body",
        Offset = {
            vpos = Vector(3.07, -3.8, -27),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Caliber",
        Slot = {"ur_deagle_caliber"},
        DefaultAttIcon = Material("entities/att/uc_bullets/50ae.png","mips smooth"),
        DefaultAttName = ".50 Action Express",
        Bone = "Body",
        Offset = {
            vpos = Vector(3.07, -3.8, -27),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "Barrel",
        Offset = {
            vpos = Vector(0, 0, 0.75),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"nofh"},
        ExcludeFlags = {"barrel_annihilator"},
		Hidden = true,
		Integral = true,
    },
    {
        PrintName = "Tactical",
        InstalledEles = {"tac_rail"},
        Slot = {"tac_pistol"},
        Bone = "Body",
        Offset = {
            vpos = Vector(0, -3.5, 7),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {15},
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_deagle_mag"},
        DefaultAttIcon = Material("entities/att/acwatt_ur_deagle_mag_7.png","mips smooth"),
        DefaultAttName = "7-Round Mag",
    },
    {
        PrintName = "Stock",
        Slot = {"uc_stock", "go_stock_pistol_bt"},
        VMScale = Vector(1.1, 1.1, 1.1),
        Bone = "Body",
        Offset = {
            vpos = Vector(0, -0.25, -1),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Grip",
        DefaultAttName = "Factory Grip",
        DefaultAttIcon = Material("entities/att/acwatt_ur_deagle_grip_plastic.png","mips smooth"),
        Slot = "ur_deagle_grip"
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm","fml_charm"},
        FreeSlot = true,
        Bone = "Body",
        Offset = {
            vpos = Vector(0.55, -3.4, 4.2),
            vang = Angle(90, 0, -90),
        },
        VMScale = Vector(.65,.65,.65),
    },
    {
        PrintName = "Finish",
        Slot = {"ur_deagle_skin"},
        DefaultAttName = "Stainless Steel",
        DefaultAttIcon = Material("entities/att/acwatt_ur_deagle_finish_default.png","mips smooth"),
        FreeSlot = true,
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "Body",
        Offset = {
            vpos = Vector(0, -4.8, 6.0),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
    }
}
--lua/weapons/arccw_ur_g3.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "AG58"
SWEP.TrueName = "G3A3"

SWEP.Trivia_Class = "Battle Rifle"
SWEP.Trivia_Desc = [[Heckler & Koch's earliest major weapon design, conceived in collaboration with Spanish research group CETME. As a pioneer of the roller-delay system, its success within the Bundeswehr inspired HK to derive subsequent designs from its layout, including the MP5 submachine gun.

Well known for its excellent accuracy and range, but its powerful cartridge makes sustained fire difficult.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = "7.62x51mm NATO"
SWEP.Trivia_Mechanism = "Roller-Delayed Blowback"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1958

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_g3.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_g3.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "000000000000"

-- Damage --

SWEP.Damage = 65
SWEP.DamageMin = 35
SWEP.RangeMin = 50
SWEP.Range = 400
SWEP.Penetration = 20
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 20

-- Recoil --

SWEP.Recoil = 1.4
SWEP.RecoilSide = 0.6

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.4

-- Firerate / Firemodes --

SWEP.Delay = 60 / 520
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 2
SWEP.HipDispersion = 900
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/g3/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/308/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-308-rif-ext-01.ogg",
    tail .. "fire-dist-308-rif-ext-02.ogg",
    tail .. "fire-dist-308-rif-ext-03.ogg",
    tail .. "fire-dist-308-rif-ext-04.ogg",
    tail .. "fire-dist-308-rif-ext-05.ogg",
    tail .. "fire-dist-308-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "sup_tail.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = 1.145
SWEP.ShellPitch = 90
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    --[1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.3, -1, 0.9),
    Ang = Angle(0, 0.02, 0),
    Magnification = 1.1,
    ViewModelFOV = 65,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.3, 1, 0.8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0.5, 1, 0.5)
SWEP.SprintAng = Angle(-8.5, 15, -10)

SWEP.CrouchPos = Vector(-0.7, 0.6, 0)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(10.5, 4, 1)
-- SWEP.CustomizeAng = Angle(8, 30, 15)
SWEP.CustomizePos = Vector(0.3, 1, 0.8)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["ur_g3_skin_wood"] = { VMSkin = 1 },
    ["ur_g3_skin_olive"] = { VMSkin = 2 },
    ["ur_g3_skin_tan"] = { VMSkin = 3 },
    ["ur_g3_skin_custom"] = { VMSkin = 4 },

    ["stock_g3_collapsible"] = {
        VMBodygroups = {
            {ind = 5, bg = 2},
        }
    },
    ["stock_g3_collapsed"] = {
        VMBodygroups = {
            {ind = 5, bg = 3},
        }
    },
    ["ur_g3_stock_psg"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        }
    },
    ["ur_g3_stock_sg"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        }
    },
    ["ur_g3_stock_rucar"] = {
        VMBodygroups = {
            {ind = 5, bg = 5},
        }
    },

    ["ur_g3_rec_hk33"] = {
        VMBodygroups = {
            {ind = 0, bg = 1},
            {ind = 3, bg = 1},
            {ind = 4, bg = 4},
        },
    },
    ["ur_g3_rec_psg"] = {
        VMBodygroups = {
            -- {ind = 1, bg = 1},
            {ind = 3, bg = 2},
        },
        NameChange = "PMR-2",
        TrueNameChange = "PSG1",
    },

    ["ur_g3_mag_10"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        }
    },
    ["ur_g3_mag_50"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
        }
    },
    ["ur_g3_mag_20_556"] = {
        VMBodygroups = {
            {ind = 4, bg = 3},
        }
    },
    ["ur_g3_mag_40_556"] = {
        VMBodygroups = {
            {ind = 4, bg = 5},
        }
    },

    ["ur_g3_barrel_12"] = {
        VMBodygroups = {
            {ind = 2, bg = 1},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 17.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 14),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_15"] = {
        VMBodygroups = {
            {ind = 2, bg = 4},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 20),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 14),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_8"] = {
        VMBodygroups = {
            {ind = 2, bg = 2},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 13.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 11),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_26"] = {
        VMBodygroups = {
            {ind = 2, bg = 3},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 29.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 17),
                vang = Angle(90, 0, 180),
            },
        }
    },

    ["ur_g3_hg_slim"] = {
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.66, 9),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["ur_g3_hg_pica"] = {
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.75, 9.2),
                vang = Angle(90, 0, -90),
            },
        }
    },
}

local hgbg = {
    ["ur_g3_hg_slim"] = 1,
    ["ur_g3_hg_pica"] = 2,
    ["ur_mp5_ub_mlok"] = 3,
    ["ur_mp5_ub_surefire"] = 4,
}
local muzzlebg = {
    ["ur_g3_barrel_8"] = 2,
    ["ur_g3_barrel_12"] = 1,
    ["ur_g3_barrel_15"] = 4,
    ["ur_g3_barrel_26"] = 3,
    ["default"] = 0,
}
local opticbg = {
    ["ur_g3_optic_psg1"] = 2,
    ["ur_g3_optic_sg1"] = 3,
}
local ubmountbg = {
    ["ur_g3_hg_slim"] = 2,
    ["ur_g3_hg_pica"] = 0,
}

SWEP.Hook_ModifyBodygroups = function(wep,data)
    local vm = data.vm
    if !IsValid(vm) then return end

    local atts = wep.Attachments
    local barrel = atts[2].Installed or "default"
    local hg = atts[4].Installed
    local muzzle = atts[5].Installed
    local ub = atts[6].Installed or atts[15].Installed
    local optic = atts[1].Installed
    local charm = atts[14].Installed
    local bayobipod = atts[17].Installed

    local hgind = hgbg[hg] or 0

    if barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" then
        vm:SetBodygroup(6, hgind + 3)

        if ub == "ur_g3_ub_bayonet" then
            vm:SetBodygroup(7, 2)
        elseif ub == "ur_g3_ub_bipod" then
            vm:SetBodygroup(7, 4)
        end
    elseif barrel == "ur_g3_barrel_8" then
        vm:SetBodygroup(6, hgind + 6)
    elseif barrel == "ur_g3_barrel_26" then
        vm:SetBodygroup(6, 11)
    else
        vm:SetBodygroup(6, hgind)
    end

    if (barrel == "default" or barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" or barrel == "ur_g3_barrel_8") and ub == "uc_ubgl_hk79" then
        vm:SetBodygroup(6, 11)
        atts[15].Offset.vpos = Vector(0, -0.7, 7.3)
    else
        atts[15].Offset.vpos = Vector(0, 0.1, 6.9)
    end

    if barrel == "ur_g3_barrel_26" then
        vm:SetBodygroup(1, 1)
    end

    vm:SetBodygroup(9, !muzzle and muzzlebg[barrel] or 3)

    vm:SetBodygroup(10, (optic or charm == "ur_mp5_optic_mount") and (opticbg[optic] and 0 or 1) or 0)

    vm:SetBodygroup(8, ub and (ubmountbg[hg] or 1) or 0)

    local todo = 0
    local short = barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15"
    if bayobipod == "ur_g3_bayobipod_bayonet" then
        todo = short and 2 or 1
    elseif bayobipod == "ur_g3_bayobipod_bipod" then
        todo = short and 4 or 3
    end
    vm:SetBodygroup(7, todo)
end

SWEP.Hook_NameChange = function(wep)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default","ur_g3_barrel_","")
    local rec = string.Replace(atts[3].Installed or "default","ur_g3_rec_","")
    local stock = string.Replace(atts[8].Installed or "default","ur_g3_stock_","")
    local trueNames = GetConVar("arccw_truenames"):GetBool()


    if rec == "hk33" then
        if trueNames then
            local bLookup = {
                ["8"] = "HK53",
                ["12"] = "HK33KA3",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "HK33SG/1"
            else
                return (stock == "collapsible" and "HK33A3") or "HK33A2"
            end
        else
            local bLookup = {
                ["8"] = "CN109",
                ["12"] = "CN66K",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "CN66-SSR"
            else
                return "CN66"
            end
        end
    elseif rec == "default" then -- not "else" here to allow the base's PSG1 namechange to happen
        if trueNames then
            if atts[13].Installed == "uc_fg_civvy" then return "HK91" end

            local bLookup = {
                ["8"] = "HK51",
                ["12"] = "G3KA4",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "G3SG/1"
            else
                return (stock == "collapsible" and "G3A4") or wep.TrueName
            end
        else
            local bLookup = {
                ["8"] = "CN102",
                ["12"] = "AG58K",
            }
            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "AG-SSR"
            else
                return "AG58"
            end
        end
    end
end

SWEP.O_Hook_UC_UseClassicHK79Mount = function(wep, data)
    local atts = wep.Attachments
    local barrel = atts[2].Installed or "default"
    local ub = atts[6].Installed or atts[15].Installed

    if ub == "uc_ubgl_hk79" and (barrel == "default" or barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" or barrel == "ur_g3_barrel_8") then
        data.current = true
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-5, 3, -5),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true


SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = {"ur_g3_optic", "optic"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, -1.6, -0.55),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"mount_optic"},
        CorrectivePos = Vector(0.018, 0, -0.0),
        CorrectiveAng = Angle(0, 0.3, 0.45),
    },
    {
        PrintName = "Barrel",
        Slot = "ur_g3_barrel",
        DefaultAttName = "18\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_g3/barrel_std.png", "smooth mips"),
        DefaultFlags = {"g3_not8"}
    },
    {
        PrintName = "Reciever",
        Slot = "ur_g3_rec",
        DefaultAttName = "Standard Reciever",
        DefaultAttIcon = Material("entities/att/ur_g3/rec_std.png", "smooth mips"),
    },
    {
        PrintName = "Handguard",
        Slot = "ur_g3_handguard",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.5, 10),
            vang = Angle(90, 0, -90),
        },
        DefaultAttName = "Standard Handguard",
        DefaultAttIcon = Material("entities/att/ur_g3/hg_std.png", "smooth mips"),
        ExcludeFlags = {"hk79_pro","g3_nohg"},
    },
    {
        PrintName = "Muzzle",
        Slot = "muzzle",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.06, 22.5),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {17},
    },
    {
        PrintName = "Underbarrel",
        Slot = "foregrip",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.17, 8.6),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"mount_underbarrel"},
        ExcludeFlags = {"g3_noub"},
        MergeSlots = {15},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.8, 0, 17),
            vang = Angle(90, 0, 180),
        },
        InstalledEles = {"mount_tactical"},
    },
    {
        PrintName = "Stock",
        Slot = "ur_g3_stock",
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_g3/stock_std.png", "smooth mips"),
    },
    {
        PrintName = "Magazine",
        Slot = "ur_g3_mag",
        DefaultAttName = "20-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_g3/mag20.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg",
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "mp5_charm"},
        FreeSlot = true,
        Bone = "body",
        Offset = {
            vpos = Vector(0.5, 1.3, 3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.1, 6.9), -- this is also changed by ModifyBodygroups
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"mount_underbarrel"},
    },
    {
        PrintName = "Furniture",
        Slot = "ur_g3_skin",
        DefaultAttName = "Gray",
        DefaultAttIcon = Material("entities/att/ur_g3/skin_gray.png", "smooth mips"),
    },
    {
        PrintName = "UR G3 bayobipod slot",
        Slot = "ur_g3_bayobipod",
        ExcludeFlags = {"g3_hk51hg"},
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },

    ["fire"] = {
        Source = {"fire_01","fire_02","fire_03"},
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire_01","fire_02","fire_03"},
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },

   ["reload"] = {
       Source = "reload",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = common .. "magpouch_gear.ogg", t = 9/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 36/30},
            {s = path .. "magin.ogg", t = 42/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 52/30},
            {s = common .. "shoulder.ogg", t = 54/30},
       },
   },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 5/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 23/30},
            {s = rottle,  t = 24/30},
            {s = common .. "magpouch_gear.ogg", t = 25/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 87/30},
            {s = common .. "shoulder.ogg", t = 88/30},
        },
    },
    ["reload_empty_scope"] = {
        Source = "reload_empty_scope",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 23/30},
            {s = rottle,  t = 24/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_30rnd"] = {
       Source = "reload_30rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 39/30},
            {s = path .. "magin.ogg", t = 44/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 56/30},
            {s = common .. "shoulder.ogg", t = 61/30},
       },
   },
    ["reload_empty_30rnd"] = {
        Source = "reload_empty_30rnd",
        RareSource = "reload_empty_30rnd_rare",
        RareSourceChance = 100,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
    ["reload_empty_30rnd_scope"] = {
        Source = "reload_empty_scope_30rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_10rnd"] = {
       Source = "reload_10rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 10/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 36/30},
            {s = path .. "magin.ogg", t = 42/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 52/30},
            {s = common .. "shoulder.ogg", t = 56/30},
       },
   },
    ["reload_empty_10rnd"] = {
        Source = "reload_empty_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
    ["reload_empty_10rnd_scope"] = {
        Source = "reload_empty_scope_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 74/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_50rnd"] = {
       Source = "reload_50rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 42/30},
            {s = path .. "magin.ogg", t = 48/30},
            {s = ratel, t = 1.1+5/30},
            {s = rottle,  t = 1.15+5/30},
            {s = common .. "grab.ogg", t = 58/30},
            {s = common .. "shoulder.ogg", t = 62/30},
       },
   },
    ["reload_empty_50rnd"] = {
        Source = "reload_empty_50rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 62/30},
            {s = path .. "magin.ogg", t = 67/30},
            {s = rottle,  t = 80/30},
            {s = path .. "chslap.ogg", t = 85/30},
            {s = ratel,  t = 86/30},
            {s = common .. "grab.ogg", t = 97/30},
            {s = common .. "shoulder.ogg", t = 98/30},
        },
    },
    ["reload_empty_50rnd_scope"] = {
        Source = "reload_empty_scope_50rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 62/30},
            {s = path .. "magin.ogg", t = 67/30},
            {s = rottle,  t = 80/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 85/30},
            {s = ratel,  t = 86/30},
            {s = common .. "grab.ogg", t = 97/30},
            {s = common .. "shoulder.ogg", t = 98/30},
        },
    },
    ["unjam"] = {
        Source = "jamfix",
        ShellEjectAt = 0.5,
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "chback.ogg",    t = 0.3},
            {s = path .. "chamber.ogg",    t = 0.6},
            {s = common .. "grab.ogg", t = 0.9},
            {s = common .. "shoulder.ogg", t = 0.95},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
}

-- SWEP.Hook_Think = ArcCW.UC.ADSReload

SWEP.Hook_Think = function(wep)
    local vm = wep:GetOwner():GetViewModel()

    vm:SetPoseParameter("short", wep.Attachments[2].Installed == "ur_g3_barrel_8" and 1 or 0)

    ArcCW.UC.ADSReload(wep)
end

SWEP.Hook_SelectReloadAnimation = function(wep, anim) -- not in atts cause _scope wont work
    local seq = anim

    if wep.Attachments[9].Installed == "ur_g3_mag_50" then
        seq = seq .. "_50rnd"
    elseif wep.Attachments[9].Installed == "ur_g3_mag_10" then
        seq = seq .. "_10rnd"
    elseif wep.Attachments[9].Installed == "ur_g3_mag_40_556" or wep.Attachments[3].Installed == "ur_g3_rec_hk33" and !wep.Attachments[9].Installed then
        seq = seq .. "_30rnd"
    end
    if anim == "reload_empty" and wep.Attachments[1].Installed then
        seq = seq .. "_scope"
    end

    return seq
end
--lua/weapons/arccw_ur_g3sg1.lua:
return gluapack()()
--lua/weapons/arccw_ur_hk53.lua:
return gluapack()()
--lua/weapons/arccw_ur_m1911.lua:
return gluapack()()
--lua/weapons/arccw_ur_mp5k.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_mp5.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets SMGs"
end

SWEP.PrintName = "PK5C" -- make this something russian and cool
SWEP.TrueName = "MP5K"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ur_mp5_barrel_kurz"
SWEP.Attachments[3].Installed = "ur_mp5_caliber_noburst"
SWEP.Attachments[5].Installed = "ur_mp5_ub_kurzgrip"
SWEP.Attachments[8].Installed = "ur_mp5_stock_none"
--lua/weapons/arccw_ur_mp5sd3.lua:
return gluapack()()
--lua/weapons/arccw_ur_mp5.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Effects --

SWEP.MuzzleEffect = "muzzleflash_mp5"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.PistolShellSoundsTable

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
-- SWEP.CamAttachment = 3 ---------------------------------------------------------------------------
-- SWEP.TracerNum = 1
-- SWEP.TracerCol = Color(25, 255, 25)
-- SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "PK5-4"

-- True name --

SWEP.TrueName = "MP5A4"

-- Trivia --

SWEP.Trivia_Class = "Submachine Gun"
SWEP.Trivia_Desc = [[Versatile submachine gun known for its use by high profile police units around the world, most famously by the British SAS during the Iranian embassy siege. Its reliable closed-bolt design and craftsmanship allowed it to remain relevant among new generations of submachine guns.

If accurate, sophisticated close-combat performance is what you're looking for, no weapon has a better track record.

Switch to burst fire mode to reduce dispersion from moving and hipfiring.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = "9x19mm Parabellum"
SWEP.Trivia_Mechanism = "Roller-Delayed Blowback"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1966

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.ViewModelFOV = 70
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.ProceduralIronFire = true

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["9mm"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["9mm"].min
SWEP.Penetration = ArcCW.UC.StdDmg["9mm"].pen
SWEP.RangeMin = 20
SWEP.Range = 100

SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 400
SWEP.PhysBulletMuzzleVelocity = 400

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.22
SWEP.RecoilSide = 0.17

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1.25
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 0.6
SWEP.RecoilPunchBack = 1.5

SWEP.Sway = 0.25

-- Firerate / Firemodes --

SWEP.Delay = 60 / 800
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = -3,
        Mult_MoveDispersion = 0.75,
        Mult_HipDispersion = 0.9,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_smg1"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 3
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 150
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "mp5"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.3
SWEP.ShootSpeedMult = 0.95

-- Length --

SWEP.BarrelLength = 24
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -2, 1)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-3.17, -1, 0.6),
     Ang = Angle(0.45, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}

SWEP.ActivePos = Vector(-0.3, 1.1, 0.6)
SWEP.ActiveAng = Angle(0, 0, -1)

-- SWEP.SprintPos = Vector(-0.5, 3, 1.5)
-- SWEP.SprintAng = Angle(-12, 15, -15)

SWEP.SprintPos = Vector(0, -3, 0)
SWEP.SprintAng = Angle(0, 0, 0)
-- SWEP.CustomizePos = Vector(6, -2, -1.5)
-- SWEP.CustomizeAng = Angle(16, 28, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, 0.5, 0)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(4, 0, -4)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Firing sounds --
local path = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

SWEP.DistantShootSoundOutdoors = {
    path .. "fire-dist-01.ogg",
    path .. "fire-dist-02.ogg",
    path .. "fire-dist-03.ogg",
    path .. "fire-dist-04.ogg",
    path .. "fire-dist-05.ogg",
    path .. "fire-dist-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 0.6
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    -- [1] = "uzi_b1", [2] = "uzi_b2", [3] = "uzi_b3", [4] = "uzi_b4"
}

--[[

1 --- 	id: 0
     [	name: iron
    num: 1
    submodels:
    0 --- ironSIGHT.smd
2 --- 	id: 1
     [	name: 1
    num: 4
    submodels:
    0 --- mp5UPPER.smd
    1 --- mp5sdUPPER.smd
    2 --- mp5kUPPER.smd
    3 --- swordUPPER.smd
3 --- 	id: 2
     [	name: 2
    num: 2
    submodels:
    0 --- fourLOWER.smd
    1 --- sefLOWER.smd
4 --- 	id: 3
     [	name: 3
    num: 11
    submodels:
    0 --- fixedSTOCK.smd
    1 --- collapseSTOCK.smd
    2 --- collapseSTOCKcoll.smd
    3 --- pdwSTOCK.smd
    4 --- pdwSTOCKfold.smd
    5 --- tacticSTOCK.smd
    6 --- tacticSTOCKfold.smd
    7 --- futureSTOCK.smd
    8 --- futureSTOCKcoll.smd
    9 --- futureSTOCKfold.smd
    10 --- buttSTOCK.smd
5 --- 	id: 4
     [	name: 4
    num: 10
    submodels:
    0 --- standardHG.smd
    1 --- flashHG.smd
    2 --- flashmlokHG.smd
    3 --- slimHG.smd
    4 --- picaHG.smd
    5 --- mlokHG.smd
    6 --- kurzgripHG.smd
    7 --- kurzslimHG.smd
    8 --- kurzmlokHG.smd
    9 ---
6 --- 	id: 5
     [	name: 5
    num: 4
    submodels:
    0 --- standardMAG.smd
    1 --- smallMAG.smd
    2 --- straightMAG.smd
    3 --- drumMAG.smd
7 --- 	id: 6
     [	name: 6
    num: 2
    submodels:
    0 ---
    1 --- mp5RAIL.smd

]]

SWEP.AttachmentElements = {
    ["ur_mp5_barrel_sd"] = {
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 4, bg = 9},
            //{ind = 8, bg = 1},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.3, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-1.15, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
        },
    },
    ["ur_mp5_barrel_eod"] = {
        VMBodygroups = {
            {ind = 4, bg = 10},
            //{ind = 8, bg = 2},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.5, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-0.95, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
		}
    },
    ["ur_mp5_barrel_kurz"] = {
        VMBodygroups = {
            {ind = 1, bg = 2},
            {ind = 4, bg = 7},
        },
        AttPosMods = {[4] = {
            vpos = Vector(-0.1, 0.3, 11.5),
            vang = Angle(90, 0, -90),
        }}
    },
    ["ur_mp5_barrel_swordfish"] = {
        VMBodygroups = {
            --{ind = 0, bg = 1},
            {ind = 1, bg = 3},
            {ind = 6, bg = 0},
        },
    },

    ["ur_mp5_rail_fg"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
    },
    ["ur_mp5_ub_classic"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
    },
    ["ur_mp5_ub_surefire"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["ur_mp5_ub_surelock"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
    ["ur_mp5_ub_kurzgrip"] = {
        VMBodygroups = {{ind = 4, bg = 6}},
    },
    ["ur_mp5_ub_kurzmlok"] = {
        VMBodygroups = {{ind = 4, bg = 8}},
    },
    ["ur_mp5_ub_wood"] = {
        VMBodygroups = {{ind = 4, bg = 3}}, -- insert wood handguard here
    },

    ["ur_mp5_mag_15"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
    ["ur_mp5_mag_40"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_50"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_waffle"] = {
        VMBodygroups = {{ind = 5, bg = 2}},
    },

    ["ur_mp5_rail_optic"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },

    ["ur_mp5_clamp"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },

    ["receiver_lower"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["receiver_lower_semi"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["receiver_lower_0"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },
    ["receiver_upper_0"] = {
        VMBodygroups = {{ind = 7, bg = 0}},
    },

    ["stock_a3"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
    ["stock_a3_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 2},
        },
    },
    ["ur_mp5_stock_remove"] = {
        VMBodygroups = {{ind = 3, bg = 10}},
    },
    ["ur_mp5_stock_wood"] = {
        -- VMBodygroups = {{ind = 0, bg = 4}},
        -- Make this part of the VMSkin
    },
    ["stock_pdw"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["stock_pdw_folded"] = {
        VMBodygroups = {{ind = 3, bg = 4}},
    },
    ["stock_ump"] = {
        VMBodygroups = {{ind = 3, bg = 5}},
    },
    ["stock_ump_folded"] = {
        VMBodygroups = {{ind = 3, bg = 6}},
    },
    ["stock_future"] = {
        VMBodygroups = {{ind = 3, bg = 7}},
    },
    ["stock_future_folded"] = {
        VMBodygroups = {{ind = 3, bg = 8}},
    },
    ["ur_mp5_precision_irons"] = {
        VMBodygroups = {
            {ind = 0, bg = 2},
            {ind = 6, bg = 0},
            },
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local atts = wep.Attachments
    local vm = data.vm
    if IsValid(vm) then
        local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
        local hg = string.Replace(atts[5].Installed or "default","ur_mp5_ub_","")
        
        if atts[6].Installed or atts[7].Installed then
            if barr == "sd" then
                vm:SetBodygroup(8, 1)
            elseif barr == "eod" then
                vm:SetBodygroup(8, 2)
            elseif hg == "default" or hg == "classic" then
                vm:SetBodygroup(4, 4)
                vm:SetBodygroup(8, 0)
            else
                vm:SetBodygroup(8, 0)
            end
        else
            vm:SetBodygroup(8, 0)
        end

        if hg == "mlok" then
            if barr == "kurz" then
                vm:SetBodygroup(4,8)
            else
                vm:SetBodygroup(4,5)
            end
        end

        if barr == "sword" then
            vm:SetBodygroup(0,(atts[1].Installed and 3) or 1)
        end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
    local cal = string.Replace(atts[3].Installed or "default","ur_mp5_caliber_","")
    local stock = string.Replace(atts[8].Installed or "default","ur_mp5_stock_","")
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()
    local defaultCals = {
        ["default"] = true,
        ["noburst"] = true,
        ["semi"] = true
    }

    local start = "MP5"
    local mid = "A"
    local num = "4"
    if fakeNames then
        start = "PK5"
        mid = "-"
    end

    if cal == "semi" or atts[12].Installed == "uc_fg_civvy" then
        if fakeNames then
            return "PK5-CIV"
        else
            if barr == "long" or barr == "sd" then
                start = "HK94" -- I know how prolific civies can get with their gunbuilds, so the nonsensical names will continue
            else
                return "SP5" .. ((barr == "kurz" and "K-PDW") or "")
            end
        end
    end

    if !defaultCals[cal] then
        if barr == "sd" then
            num = "SD"
        else
            num = ""
        end
        if cal == "10auto" then
            mid = "/10"
        elseif cal == "40sw" then
            mid = "/40"
        elseif cal == "22lr" then
            if barr == "sd" then
                mid = "SD"
                num = " .22 LR"
            else
                mid = " .22 LR"
            end
        end
    else
        if barr == "kurz" then
            if fakeNames then
                mid = "C"
            else
                mid = "K"
            end
            if stock == "pdw" then
                num = "-PDW"
            elseif cal == "default" then
                if fakeNames then
                    num = "-4"
                else
                    num = "A4"
                end
            else
                num = ""
            end
        else
            if barr == "sd" then
                mid = "SD"
            end

            if cal == "noburst" or cal == "semi" then
                if stock == "a3" then
                    num = "3"
                elseif stock == "none" then
                    num = "1"
                else
                    num = "2"
                end
            else
                if stock == "a3" then
                    if barr == "sd" then
                        num = "6"
                    else
                        num = "5"
                    end
                elseif stock == "none" then
                    if barr == "sd" then
                        num = "4"
                    end
                else
                    if barr == "sd" then
                        num = "5"
                    end
                end
            end
        end
    end

    return start .. mid .. num
end

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local rutle = {common .. "movement-smg-03.ogg",common .. "movement-smg-04.ogg"}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    -- ["idle_empty"] = {
    --     Source = "idle",
    -- },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.15, c = ci},
            {s = path .. "rack2.ogg",         t = 0.38, c = ci},
            {s = ratel,         t = 0.75},
        }
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = ArcCW.UC.DrawSounds,
    },
    -- ["draw_empty"] = {
    --     Source = "draw_empty",
    --     SoundTable = ArcCW.UC.DrawSounds,
    -- },
    ["holster"] = {
        Source = "holster",
        --Time = 0.25,
        SoundTable = ArcCW.UC.HolsterSounds,
    },
    -- ["holster_empty"] = {
    --     Source = "holster_empty",
    --     --Time = 0.25,
    --     SoundTable = ArcCW.UC.HolsterSounds,
    -- },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    -- ["fire_empty"] = {
    --     Source = "fire",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },
    ["fire_iron"] = {
        Source = "idle",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    -- ["fire_empty_iron"] = {
    --     Source = "idle",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },

    ["fix"] = {
        Source = "fix",
        Time = 40 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        ShellEjectAt = 0.36,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.27, c = ci},
            {s = path .. "rack2.ogg",         t = 0.5, c = ci},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.61, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.045, c = ci},
            {s = path .. "chlock.ogg",         t = 0.18, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.05, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_kurz"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.63, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_kurz"] = {
        Source = "reload_empty_kurz",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.066, c = ci},
            {s = path .. "chlock.ogg",         t = 0.2, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.1, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 15 Round Reloads --

    ["reload_15"] = {
        Source = "reload",--"reload_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_15"] = {
        Source = "reload_empty",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_15"] = {
        Source = "reload_empty_kurz",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload",--"reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_40"] = {
        Source = "reload_empty_kurz",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 100 Round Reloads --

    ["reload_drum"] = {
        Source = "reload_drum",--"reload_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.6,
        LastClip1OutTime = 1,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.32, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.25},
        },
    },
    ["reload_empty_drum"] = {
        Source = "reload_empty_drum",--"reload_empty_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.4,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 1,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.3, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = path .. "rack1.ogg",         t = 2.3, c = ci},
            {s = path .. "rack2.ogg",         t = 2.5, c = ci},
            {s = common .. "shoulder.ogg",  t = 3.0},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-smg-03.ogg", t = 0},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-smg-01.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-smg-04.ogg", t = 1.25},
        },
    },

    ["enter_sprint"] = {
        Source = "sprint_enter",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKOut = 0,
        Time = .5,
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_sprint"] = {
        Source = "sprint_exit",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.5,
        Time = .5,
    },
}

SWEP.AutosolveSourceSeq = "idle"

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp","optic","ur_mp5_optic"}, -- ,"optic"
        Bone = "body",
        Offset = {
            vpos = Vector(-0.1, -1.6, 3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(-0.09, 0, 0),
        CorrectiveAng = Angle(1, 0.6, -4.0),
        InstalledEles = {"ur_mp5_rail_optic"}
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "9\" Standard Upper",
        DefaultAttIcon = Material("entities/att/ur_mp5/upper_std.png", "smooth mips"),
        Slot = "ur_mp5_barrel",
        Bone = "body",
        Offset = {
            vpos = Vector(2.6, -3.7, -17.3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Navy Lower",
        DefaultAttIcon = Material("entities/att/ur_mp5/grip.png", "smooth mips"),
        Slot = "ur_mp5_caliber",
        DefaultEles = {"receiver_lower_0"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.3, 14.8),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"barrel_sd","barrel_eod","barrel_sword"}
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Tropical Handguard",
        DefaultAttIcon = Material("entities/att/ur_mp5/hg_std.png", "smooth mips"),
        Slot = {"ur_mp5_hg"},
        ExcludeFlags = {"barrel_sd", "barrel_eod"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
        --InstalledEles = {"ur_mp5_rail_fg"},
        GivesFlags = {"mp5_rail"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
        MergeSlots = {15},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.9, 0.2, 8),
            vang = Angle(90, 0, 180),
        },
        VMScale = Vector(.8,.8,.8),
        --InstalledEles = {"ur_mp5_clamp"}
        GivesFlags = {"mp5_rail"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_mp5_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/ur_mp5/stock_std.png", "smooth mips"),
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_mp5_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_mp5/mag30.png", "smooth mips"),
        ExcludeFlags = {"ur_mp5_cal_40sw","ur_mp5_cal_10mm"}
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load",
        ExcludeFlags = {"barrel_sd"}
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "mp5_charm"},
        FreeSlot = true,
        Bone = "Body",
        Offset = {
            vpos = Vector(0.6, 1.1, 2.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "Body",
        Offset = {
            vpos = Vector(0, 0, 7.9),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        --RequireFlags = {"barrel_eod"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
    }
}

-- SWEP.AttachmentOverrides = {
--     ["uc_grip_handstop"] = {
--         LHIK = false
--     }
-- } -- THIS SHIT DOESN'T WORK

--lua/weapons/arccw_ur_g3.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "AG58"
SWEP.TrueName = "G3A3"

SWEP.Trivia_Class = "Battle Rifle"
SWEP.Trivia_Desc = [[Heckler & Koch's earliest major weapon design, conceived in collaboration with Spanish research group CETME. As a pioneer of the roller-delay system, its success within the Bundeswehr inspired HK to derive subsequent designs from its layout, including the MP5 submachine gun.

Well known for its excellent accuracy and range, but its powerful cartridge makes sustained fire difficult.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = "7.62x51mm NATO"
SWEP.Trivia_Mechanism = "Roller-Delayed Blowback"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1958

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_g3.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_g3.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "000000000000"

-- Damage --

SWEP.Damage = 65
SWEP.DamageMin = 35
SWEP.RangeMin = 50
SWEP.Range = 400
SWEP.Penetration = 20
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 20

-- Recoil --

SWEP.Recoil = 1.4
SWEP.RecoilSide = 0.6

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.4

-- Firerate / Firemodes --

SWEP.Delay = 60 / 520
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 2
SWEP.HipDispersion = 900
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/g3/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/308/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-308-rif-ext-01.ogg",
    tail .. "fire-dist-308-rif-ext-02.ogg",
    tail .. "fire-dist-308-rif-ext-03.ogg",
    tail .. "fire-dist-308-rif-ext-04.ogg",
    tail .. "fire-dist-308-rif-ext-05.ogg",
    tail .. "fire-dist-308-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "sup_tail.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = 1.145
SWEP.ShellPitch = 90
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    --[1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.3, -1, 0.9),
    Ang = Angle(0, 0.02, 0),
    Magnification = 1.1,
    ViewModelFOV = 65,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.3, 1, 0.8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0.5, 1, 0.5)
SWEP.SprintAng = Angle(-8.5, 15, -10)

SWEP.CrouchPos = Vector(-0.7, 0.6, 0)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(10.5, 4, 1)
-- SWEP.CustomizeAng = Angle(8, 30, 15)
SWEP.CustomizePos = Vector(0.3, 1, 0.8)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["ur_g3_skin_wood"] = { VMSkin = 1 },
    ["ur_g3_skin_olive"] = { VMSkin = 2 },
    ["ur_g3_skin_tan"] = { VMSkin = 3 },
    ["ur_g3_skin_custom"] = { VMSkin = 4 },

    ["stock_g3_collapsible"] = {
        VMBodygroups = {
            {ind = 5, bg = 2},
        }
    },
    ["stock_g3_collapsed"] = {
        VMBodygroups = {
            {ind = 5, bg = 3},
        }
    },
    ["ur_g3_stock_psg"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        }
    },
    ["ur_g3_stock_sg"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        }
    },
    ["ur_g3_stock_rucar"] = {
        VMBodygroups = {
            {ind = 5, bg = 5},
        }
    },

    ["ur_g3_rec_hk33"] = {
        VMBodygroups = {
            {ind = 0, bg = 1},
            {ind = 3, bg = 1},
            {ind = 4, bg = 4},
        },
    },
    ["ur_g3_rec_psg"] = {
        VMBodygroups = {
            -- {ind = 1, bg = 1},
            {ind = 3, bg = 2},
        },
        NameChange = "PMR-2",
        TrueNameChange = "PSG1",
    },

    ["ur_g3_mag_10"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        }
    },
    ["ur_g3_mag_50"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
        }
    },
    ["ur_g3_mag_20_556"] = {
        VMBodygroups = {
            {ind = 4, bg = 3},
        }
    },
    ["ur_g3_mag_40_556"] = {
        VMBodygroups = {
            {ind = 4, bg = 5},
        }
    },

    ["ur_g3_barrel_12"] = {
        VMBodygroups = {
            {ind = 2, bg = 1},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 17.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 14),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_15"] = {
        VMBodygroups = {
            {ind = 2, bg = 4},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 20),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 14),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_8"] = {
        VMBodygroups = {
            {ind = 2, bg = 2},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 13.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 11),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_26"] = {
        VMBodygroups = {
            {ind = 2, bg = 3},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 29.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 17),
                vang = Angle(90, 0, 180),
            },
        }
    },

    ["ur_g3_hg_slim"] = {
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.66, 9),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["ur_g3_hg_pica"] = {
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.75, 9.2),
                vang = Angle(90, 0, -90),
            },
        }
    },
}

local hgbg = {
    ["ur_g3_hg_slim"] = 1,
    ["ur_g3_hg_pica"] = 2,
    ["ur_mp5_ub_mlok"] = 3,
    ["ur_mp5_ub_surefire"] = 4,
}
local muzzlebg = {
    ["ur_g3_barrel_8"] = 2,
    ["ur_g3_barrel_12"] = 1,
    ["ur_g3_barrel_15"] = 4,
    ["ur_g3_barrel_26"] = 3,
    ["default"] = 0,
}
local opticbg = {
    ["ur_g3_optic_psg1"] = 2,
    ["ur_g3_optic_sg1"] = 3,
}
local ubmountbg = {
    ["ur_g3_hg_slim"] = 2,
    ["ur_g3_hg_pica"] = 0,
}

SWEP.Hook_ModifyBodygroups = function(wep,data)
    local vm = data.vm
    if !IsValid(vm) then return end

    local atts = wep.Attachments
    local barrel = atts[2].Installed or "default"
    local hg = atts[4].Installed
    local muzzle = atts[5].Installed
    local ub = atts[6].Installed or atts[15].Installed
    local optic = atts[1].Installed
    local charm = atts[14].Installed
    local bayobipod = atts[17].Installed

    local hgind = hgbg[hg] or 0

    if barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" then
        vm:SetBodygroup(6, hgind + 3)

        if ub == "ur_g3_ub_bayonet" then
            vm:SetBodygroup(7, 2)
        elseif ub == "ur_g3_ub_bipod" then
            vm:SetBodygroup(7, 4)
        end
    elseif barrel == "ur_g3_barrel_8" then
        vm:SetBodygroup(6, hgind + 6)
    elseif barrel == "ur_g3_barrel_26" then
        vm:SetBodygroup(6, 11)
    else
        vm:SetBodygroup(6, hgind)
    end

    if (barrel == "default" or barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" or barrel == "ur_g3_barrel_8") and ub == "uc_ubgl_hk79" then
        vm:SetBodygroup(6, 11)
        atts[15].Offset.vpos = Vector(0, -0.7, 7.3)
    else
        atts[15].Offset.vpos = Vector(0, 0.1, 6.9)
    end

    if barrel == "ur_g3_barrel_26" then
        vm:SetBodygroup(1, 1)
    end

    vm:SetBodygroup(9, !muzzle and muzzlebg[barrel] or 3)

    vm:SetBodygroup(10, (optic or charm == "ur_mp5_optic_mount") and (opticbg[optic] and 0 or 1) or 0)

    vm:SetBodygroup(8, ub and (ubmountbg[hg] or 1) or 0)

    local todo = 0
    local short = barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15"
    if bayobipod == "ur_g3_bayobipod_bayonet" then
        todo = short and 2 or 1
    elseif bayobipod == "ur_g3_bayobipod_bipod" then
        todo = short and 4 or 3
    end
    vm:SetBodygroup(7, todo)
end

SWEP.Hook_NameChange = function(wep)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default","ur_g3_barrel_","")
    local rec = string.Replace(atts[3].Installed or "default","ur_g3_rec_","")
    local stock = string.Replace(atts[8].Installed or "default","ur_g3_stock_","")
    local trueNames = GetConVar("arccw_truenames"):GetBool()


    if rec == "hk33" then
        if trueNames then
            local bLookup = {
                ["8"] = "HK53",
                ["12"] = "HK33KA3",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "HK33SG/1"
            else
                return (stock == "collapsible" and "HK33A3") or "HK33A2"
            end
        else
            local bLookup = {
                ["8"] = "CN109",
                ["12"] = "CN66K",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "CN66-SSR"
            else
                return "CN66"
            end
        end
    elseif rec == "default" then -- not "else" here to allow the base's PSG1 namechange to happen
        if trueNames then
            if atts[13].Installed == "uc_fg_civvy" then return "HK91" end

            local bLookup = {
                ["8"] = "HK51",
                ["12"] = "G3KA4",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "G3SG/1"
            else
                return (stock == "collapsible" and "G3A4") or wep.TrueName
            end
        else
            local bLookup = {
                ["8"] = "CN102",
                ["12"] = "AG58K",
            }
            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "AG-SSR"
            else
                return "AG58"
            end
        end
    end
end

SWEP.O_Hook_UC_UseClassicHK79Mount = function(wep, data)
    local atts = wep.Attachments
    local barrel = atts[2].Installed or "default"
    local ub = atts[6].Installed or atts[15].Installed

    if ub == "uc_ubgl_hk79" and (barrel == "default" or barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" or barrel == "ur_g3_barrel_8") then
        data.current = true
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-5, 3, -5),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true


SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = {"ur_g3_optic", "optic"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, -1.6, -0.55),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"mount_optic"},
        CorrectivePos = Vector(0.018, 0, -0.0),
        CorrectiveAng = Angle(0, 0.3, 0.45),
    },
    {
        PrintName = "Barrel",
        Slot = "ur_g3_barrel",
        DefaultAttName = "18\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_g3/barrel_std.png", "smooth mips"),
        DefaultFlags = {"g3_not8"}
    },
    {
        PrintName = "Reciever",
        Slot = "ur_g3_rec",
        DefaultAttName = "Standard Reciever",
        DefaultAttIcon = Material("entities/att/ur_g3/rec_std.png", "smooth mips"),
    },
    {
        PrintName = "Handguard",
        Slot = "ur_g3_handguard",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.5, 10),
            vang = Angle(90, 0, -90),
        },
        DefaultAttName = "Standard Handguard",
        DefaultAttIcon = Material("entities/att/ur_g3/hg_std.png", "smooth mips"),
        ExcludeFlags = {"hk79_pro","g3_nohg"},
    },
    {
        PrintName = "Muzzle",
        Slot = "muzzle",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.06, 22.5),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {17},
    },
    {
        PrintName = "Underbarrel",
        Slot = "foregrip",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.17, 8.6),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"mount_underbarrel"},
        ExcludeFlags = {"g3_noub"},
        MergeSlots = {15},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.8, 0, 17),
            vang = Angle(90, 0, 180),
        },
        InstalledEles = {"mount_tactical"},
    },
    {
        PrintName = "Stock",
        Slot = "ur_g3_stock",
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_g3/stock_std.png", "smooth mips"),
    },
    {
        PrintName = "Magazine",
        Slot = "ur_g3_mag",
        DefaultAttName = "20-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_g3/mag20.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg",
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "mp5_charm"},
        FreeSlot = true,
        Bone = "body",
        Offset = {
            vpos = Vector(0.5, 1.3, 3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.1, 6.9), -- this is also changed by ModifyBodygroups
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"mount_underbarrel"},
    },
    {
        PrintName = "Furniture",
        Slot = "ur_g3_skin",
        DefaultAttName = "Gray",
        DefaultAttIcon = Material("entities/att/ur_g3/skin_gray.png", "smooth mips"),
    },
    {
        PrintName = "UR G3 bayobipod slot",
        Slot = "ur_g3_bayobipod",
        ExcludeFlags = {"g3_hk51hg"},
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },

    ["fire"] = {
        Source = {"fire_01","fire_02","fire_03"},
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire_01","fire_02","fire_03"},
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },

   ["reload"] = {
       Source = "reload",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = common .. "magpouch_gear.ogg", t = 9/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 36/30},
            {s = path .. "magin.ogg", t = 42/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 52/30},
            {s = common .. "shoulder.ogg", t = 54/30},
       },
   },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 5/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 23/30},
            {s = rottle,  t = 24/30},
            {s = common .. "magpouch_gear.ogg", t = 25/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 87/30},
            {s = common .. "shoulder.ogg", t = 88/30},
        },
    },
    ["reload_empty_scope"] = {
        Source = "reload_empty_scope",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 23/30},
            {s = rottle,  t = 24/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_30rnd"] = {
       Source = "reload_30rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 39/30},
            {s = path .. "magin.ogg", t = 44/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 56/30},
            {s = common .. "shoulder.ogg", t = 61/30},
       },
   },
    ["reload_empty_30rnd"] = {
        Source = "reload_empty_30rnd",
        RareSource = "reload_empty_30rnd_rare",
        RareSourceChance = 100,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
    ["reload_empty_30rnd_scope"] = {
        Source = "reload_empty_scope_30rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_10rnd"] = {
       Source = "reload_10rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 10/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 36/30},
            {s = path .. "magin.ogg", t = 42/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 52/30},
            {s = common .. "shoulder.ogg", t = 56/30},
       },
   },
    ["reload_empty_10rnd"] = {
        Source = "reload_empty_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
    ["reload_empty_10rnd_scope"] = {
        Source = "reload_empty_scope_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 74/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_50rnd"] = {
       Source = "reload_50rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 42/30},
            {s = path .. "magin.ogg", t = 48/30},
            {s = ratel, t = 1.1+5/30},
            {s = rottle,  t = 1.15+5/30},
            {s = common .. "grab.ogg", t = 58/30},
            {s = common .. "shoulder.ogg", t = 62/30},
       },
   },
    ["reload_empty_50rnd"] = {
        Source = "reload_empty_50rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 62/30},
            {s = path .. "magin.ogg", t = 67/30},
            {s = rottle,  t = 80/30},
            {s = path .. "chslap.ogg", t = 85/30},
            {s = ratel,  t = 86/30},
            {s = common .. "grab.ogg", t = 97/30},
            {s = common .. "shoulder.ogg", t = 98/30},
        },
    },
    ["reload_empty_50rnd_scope"] = {
        Source = "reload_empty_scope_50rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 62/30},
            {s = path .. "magin.ogg", t = 67/30},
            {s = rottle,  t = 80/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 85/30},
            {s = ratel,  t = 86/30},
            {s = common .. "grab.ogg", t = 97/30},
            {s = common .. "shoulder.ogg", t = 98/30},
        },
    },
    ["unjam"] = {
        Source = "jamfix",
        ShellEjectAt = 0.5,
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "chback.ogg",    t = 0.3},
            {s = path .. "chamber.ogg",    t = 0.6},
            {s = common .. "grab.ogg", t = 0.9},
            {s = common .. "shoulder.ogg", t = 0.95},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
}

-- SWEP.Hook_Think = ArcCW.UC.ADSReload

SWEP.Hook_Think = function(wep)
    local vm = wep:GetOwner():GetViewModel()

    vm:SetPoseParameter("short", wep.Attachments[2].Installed == "ur_g3_barrel_8" and 1 or 0)

    ArcCW.UC.ADSReload(wep)
end

SWEP.Hook_SelectReloadAnimation = function(wep, anim) -- not in atts cause _scope wont work
    local seq = anim

    if wep.Attachments[9].Installed == "ur_g3_mag_50" then
        seq = seq .. "_50rnd"
    elseif wep.Attachments[9].Installed == "ur_g3_mag_10" then
        seq = seq .. "_10rnd"
    elseif wep.Attachments[9].Installed == "ur_g3_mag_40_556" or wep.Attachments[3].Installed == "ur_g3_rec_hk33" and !wep.Attachments[9].Installed then
        seq = seq .. "_30rnd"
    end
    if anim == "reload_empty" and wep.Attachments[1].Installed then
        seq = seq .. "_scope"
    end

    return seq
end
--lua/weapons/arccw_ur_rpk.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_ak.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets LMGs"
end

SWEP.PrintName = "PKF-67"
SWEP.TrueName = "RPK"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ur_ak_barrel_rpk"
SWEP.Attachments[6].Installed = "ur_ak_mag_762_75"
SWEP.Attachments[10].Installed = "ur_ak_stock_rpk"
--gamemodes/darkrp/entities/weapons/arrest_stick/shared.lua:
return gluapack()()
--addons/[binbon]misc/lua/weapons/bomonti_filtresiz.lua:
SWEP.PrintName 		= "Bomonti Filtresiz"
SWEP.Category		= "Turkish Haram Mod Icki"

SWEP.Author 		= "RebS"

SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.AdminOnly 		= false

SWEP.BounceWeaponIcon = false
SWEP.DrawWeaponInfoBox = false

SWEP.ViewModelFOV 	= 54

SWEP.ViewModel 		= "models/rebs/icikiler_sigaralar/bomonti_filtresiz_c.mdl"
SWEP.WorldModel 	= "models/rebs/icikiler_sigaralar/bomonti_filtresiz_w.mdl"

SWEP.ViewModelFlip 	= false

SWEP.AutoSwitchTo 	= false
SWEP.AutoSwitchFrom = false

SWEP.Slot 			= 1
SWEP.SlotPos 		= 1

SWEP.Primary.Ammo     = ""
SWEP.Secondary.Ammo 	= ""
SWEP.Primary.ClipSize     = 3
SWEP.Secondary.ClipSize 	= -1
SWEP.Primary.DefaultClip     = 3
SWEP.Secondary.DefaultClip     = -1

SWEP.UseHands         = true

SWEP.HoldType         = "slam" 

SWEP.DrawCrosshair     = false
SWEP.DrawAmmo          = false

SWEP.Primary.Automatic 		= false 
SWEP.Secondary.Automatic 	= false

SWEP.Opened = false

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

if SERVER then
	util.AddNetworkString("drink")
	util.AddNetworkString("drink_start")
end

function SWEP:PrimaryAttack()

	local randomsounds = {
		"/haram/beer_drink1.wav",
		"/haram/beer_drink2.wav",
	}
	
	local randomnum = math.floor(math.random(2))
	local randomsound = randomsounds[randomnum]

	if ( CLIENT ) then return end

	local ply = self.Owner
	local DeductAmount = 1

	if (IsValid(ply)) then math.floor(ply:Health() - DeductAmount - ply:GetMaxHealth(), self.DeductAmount) end

		self:SetClip1(self:Clip1() - 1)

		if self.Opened then
			if (self:Clip1() < -1) then return end
			if SERVER then
				self.Owner:EmitSound(randomsound)
			end
			self:SendWeaponAnim(ACT_VM_RELEASE)
			self.Owner:GetViewModel():SetBodygroup(2,1)
		else
			self.Opened = true

			if SERVER then
				self.Owner:EmitSound("haram/beer_opendrink.wav", 100)
			end
			self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
			timer.Simple(4, function() self.Owner:GetViewModel():SetBodygroup(2,1) end)
		end	

			self:SetNextPrimaryFire(CurTime() + self:SequenceDuration() + 0.5)
			self.Owner:SetAnimation(PLAYER_ATTACK1)

			timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() 
				if (IsValid(self)) && self:Clip1() > -1 then
					self:SendWeaponAnim(ACT_VM_IDLE)
				elseif self:Clip1() < 0 then
					if SERVER then
						self.Owner:EmitSound("haram/soda_holster.wav", 100)
					end
				self:SetBodygroup(0,1)
				self:SetBodygroup(1,1)
				self:SetBodygroup(2,1)
				self:SendWeaponAnim(ACT_VM_HOLSTER)
				timer.Create("weapon_holster" .. self:EntIndex(), self:SequenceDuration(), 1, function() if (IsValid(self)) then 
					self:DropJunk()
					timer.Create("weapon_drunk" .. ply:EntIndex(), 1, 35, function() if ply:Alive() then if DeductAmount < ply:Health() then ply:SetHealth(math.min(ply:GetMaxHealth(), ply:Health() - DeductAmount)) else ply:Kill() end end end)

					ply:SetNWBool("IsDrunk", true)
					timer.Create("IsDrunk" .. ply:EntIndex(), 35, 1, function() ply:SetNWBool("IsDrunk", false) end)
				end
			end)
		end
	end)
end

hook.Add("RenderScreenspaceEffects", "RenderDrunkScreen", function()

	local ply = LocalPlayer()

	if ply:GetNWBool("IsDrunk") then
		DrawMotionBlur(0.4, 0.8, 0.01)
		DrawSharpen(0.85, 0.85)
	end

end)

hook.Add("PlayerSpawn", "ResetAll", function(ply)
	if ply:GetNWBool("IsDrunk") then
	ply:SetNWBool("IsDrunk", false)
	timer.Remove("weapon_drunk" .. ply:EntIndex())
	end
end)

function SWEP:Think()

	local vm = self.Owner:GetViewModel()
	
	local seq = vm:GetSequence()
	local seqinfo = vm:GetSequenceInfo(seq)

	local seqname = seqinfo.label
	local cyc = vm:GetCycle()
	
	if (self:Clip1() < 3) then
		self:SetBodygroup(1,1)
	end

	if (string.find(seqname, "chug") and cyc > 0.75 and cyc < 0.95) and self:Clip1() < 0 then
		self.Owner:GetViewModel():SetBodygroup(1,1)
		self.Owner:GetViewModel():SetBodygroup(2,1)
		self.Owner:GetViewModel():SetBodygroup(3,1)
	end

end

function SWEP:DropJunk()


	self:Holster()


end

function SWEP:OnRemove()

	timer.Remove("weapon_idle" .. self:EntIndex())
	timer.Remove("weapon_holster" .. self:EntIndex())
	timer.Remove("weapon_drink" .. self:EntIndex())

end

function SWEP:Deploy()

    if (self:Clip1() < 3) then
        self:SendWeaponAnim(ACT_VM_DRAW_EMPTY)
    end

end

function SWEP:Holster(wep)
	if SERVER then 
	if self:Clip1() < 0 then 
		if self.Owner then 
		self.Owner:StripWeapon("bomonti_filtresiz") 
		end 
	end
	end
	timer.Remove("weapon_idle" .. self:EntIndex())
	timer.Remove("weapon_holster" .. self:EntIndex())

	return true

end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end
--addons/cityworker/lua/weapons/cityworker_pliers.lua:
SWEP.PrintName              = "Pense"
SWEP.Author                 = "Silhouhat"
SWEP.Purpose                = "City Worker"
SWEP.Instructions           = "LMB to fix electronics"

SWEP.Category               = "City Worker"
SWEP.Spawnable              = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		    = "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		    = "none"

SWEP.Weight			        = 5
SWEP.AutoSwitchTo		    = false
SWEP.AutoSwitchFrom		    = false

SWEP.Slot			        = 3
SWEP.SlotPos			    = 1
SWEP.DrawAmmo			    = false
SWEP.DrawCrosshair		    = true

SWEP.ViewModel			    = "models/props_c17/tools_pliers01a.mdl"
SWEP.WorldModel			    = "models/props_c17/tools_pliers01a.mdl"

function SWEP:Initialize()
    self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()
    if CLIENT then return end
    if not IsFirstTimePredicted() then return end

    self:SetNextPrimaryFire( CurTime() + 1 )

    local ent = self.Owner:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    if ent:GetClass() != "cityworker_electric" then return end
    if ent:GetPos():Distance( self.Owner:GetPos() ) > 200 then return end

    CITYWORKER.Begin( self.Owner, ent )
end

function SWEP:SecondaryAttack()
    return
end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    /*
    if not IsValid( self.Owner ) then return end

    local pos, ang = self.Owner:GetBonePosition( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) )
    local offsetPos = ang:Right() * 1 + ang:Forward() * 4 + ang:Up() * -2

    ang:RotateAroundAxis( ang:Right(), 0 )
    ang:RotateAroundAxis( ang:Forward(), 90 )
    ang:RotateAroundAxis( ang:Up(), 180 )

    self:SetRenderOrigin( pos + offsetPos )
    self:SetRenderAngles( ang )

    self:DrawModel()
    */
end

function SWEP:GetViewModelPosition( pos, ang )
    pos = pos + ang:Right() * 9 + ang:Forward() * 18 + ang:Up() * -9

    ang:RotateAroundAxis( ang:Right(), 90 )
    ang:RotateAroundAxis( ang:Up(), -90 )

    return pos, ang
end
--addons/dradio/lua/weapons/dradio/cl_init.lua:
return gluapack()()
--lua/weapons/gmod_tool/stools/fading_door.lua:
return gluapack()()
--lua/improvedstacker/localify.lua:
--[[--------------------------------------------------------------------------
	Localify Module
	
	Author:
		Mista-Tea ([IJWTB] Thomas)
	
	License:
		The MIT License (MIT)

		Copyright (c) 2015 Mista-Tea

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
			
	Changelog:
----------------------------------------------------------------------------]]

--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

module( "localify", package.seeall )

languages = {
	bg        = "Bulgarian",
	cs        = "Czech",
	da        = "Danish",
	de        = "German",
	el        = "Greek",
	["en-pt"] = "Pirate",
	en        = "English",
	es        = "Spanish",
	et        = "Estonian",
	fi        = "Finnish",
	fr        = "French",
	he        = "Hebrew",
	hr        = "Croatian",
	hu        = "Hungarian",
	it        = "Italian",
	ja        = "Japanese",
	ko        = "Korean",
	lt        = "Lithuanian",
	nl        = "Dutch",
	no        = "Norwegian",
	pl        = "Polish",
	["pt-br"] = "Brazilian Portuguese",
	["pt-pt"] = "Portuguese",
	ru        = "Russian",
	sk        = "Slovak",
	["sv-se"] = "Swedish",
	th        = "Thai",
	tr        = "Turkish",
	uk        = "Ukranian",
	vi        = "Vietnamese",
	["zh-cn"] = "Simplified Chinese",
	["zh-tw"] = "Traditional Chinese",
}

localizations = localizations or {
	bg        = {},
	cs        = {},
	da        = {},
	de        = {},
	el        = {},
	["en-pt"] = {},
	en        = {},
	es        = {},
	et        = {},
	fi        = {},
	fr        = {},
	he        = {},
	hr        = {},
	hu        = {},
	it        = {},
	ja        = {},
	ko        = {},
	lt        = {},
	nl        = {},
	no        = {},
	pl        = {},
	["pt-br"] = {},
	["pt-pt"] = {},
	ru        = {},
	sk        = {},
	["sv-se"] = {},
	th        = {},
	tr        = {},
	uk        = {},
	vi        = {},
	["zh-cn"] = {},
	["zh-tw"] = {},
}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local error = error
local include = include
local tostring = tostring
local GetConVar = GetConVar
local AddCSLuaFile = AddCSLuaFile

FALLBACK = FALLBACK or "en"

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	localify.Bind( string, string, string )
--
--	Binds the token <key> and localized phrase <value> to the given language <lang>.
--
--	Example: localify.Bind( "en", "#Hello", "Hello" )
--	Example: localify.Bind( "es", "#Hello", "Hola" )
--	Example: localify.Bind( "fr", "#Hello", "Bonjour" )
--]]--
function Bind( lang, key, value )
	if ( not IsValidLanguage( lang ) ) then error( "Invalid language provided ('"..tostring(lang).."')" ) return end
	
	localizations[ lang:lower() ][ key ] = value
end

--[[--------------------------------------------------------------------------
-- 	localify.Localize( string, string, boolean [optional] )
--
--	Returns the localized phrase associated with the token <key>.
--
--	If a language <lang> is provided, the phrase bound to that language will be returned.
--	If no language is provided, the language will default to the client or server's locale.
--	If a localized phrase is not found and (returnKey) is truthsy, the key will be returned.
--	If a localized phrase is not found and (returnKey) is falsey, the phrase associated with the fallback language (en' by default) will be returned, if any.
--	Otherwise, nil will be returned if no binding exists.
--
--	Example: local str = localify.Localize( "#Hello" )             -- Returns either the locale's binding or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "es" )       -- Returns either a Spanish binding, the locale's binding, or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "fr" )       -- Returns either a French  binding, the locale's binding, or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "de", true ) -- Returns either a German  binding, the locale's binding, or the key
--	Example: local str = localify.Localize( "#Hello",  nil, true ) -- Returns either the locale's binding or the key
--]]--
function Localize( key, lang, returnKey )
	-- If for some reason the given language isn't valid (e.g. user set it themselves), show an
	-- error in console letting them know and try to use the fallback language.
	if ( lang and not IsValidLanguage( lang ) ) then
		ErrorNoHalt( "Invalid localify_language provided ('"..tostring(lang).."')\n" )
		lang = FALLBACK
	end
	
	local tbl = localizations[ (lang and lang:lower()) or GetLocale() ]

	return ( tbl and tbl[ key ] )                                             -- If there is a bind, return it
		or ( returnKey and key )                                              -- If there is no bind and we want to return the key on failure, return the key
		or ( localizations[ FALLBACK ] and localizations[ FALLBACK ][ key ] ) -- If there is a bind in the fallback language, return it
		or nil                                                                -- Otherwise return nil
end



--[[--------------------------------------------------------------------------
-- 	localify.AddLanguage( string, string )
--
--	Adds a non-GMod language <lang> with the given <name> to the table of valid languages.
--
--	Example: localify.AddLanguage( "zom", "Zombie" )
--	Example: localify.AddLanguage( "fil", "Filipino" )
--]]--
function AddLanguage( lang, name )
	if ( IsValidLanguage( lang ) ) then return end
	
	    languages[ lang:lower() ] = name
	localizations[ lang:lower() ] = {}
end

--[[--------------------------------------------------------------------------
-- 	localify.RemoveLanguage( string )
--
--	Removes a language <lang> from the table of valid languages.
--	If the removed language was the fallback language, "en" (English) will be
--	set as the new fallback language automatically.
--
--	Example: localify.RemoveLanguage( "zom" )
--	Example: localify.RemoveLanguage( "fil" )
--]]--
function RemoveLanguage( lang )
	if ( not IsValidLanguage( lang ) ) then return end
	
	    languages[ lang:lower() ] = nil
	localizations[ lang:lower() ] = nil
	
	if ( lang:lower() == FALLBACK ) then FALLBACK = "en" end
end

--[[--------------------------------------------------------------------------
-- 	localify.IsValidLanguage( string )
--
--	Checks if the language <lang> has been added to Localify.
--	Returns true if valid, false if invalid.
--
--	Example: localify.IsValidLanguage( "vi" ) -- Vietnamese is supported by default, so this is true
--	Example: localify.IsValidLanguage( "zz" ) -- false by default, unless manually added
--]]--
function IsValidLanguage( lang )
	return lang and languages[ lang:lower() ]
end

--[[--------------------------------------------------------------------------
-- 	localify.SetFallbackLanguage( string )
--
--	Sets the fallback language <lang> to use when a localized phrase is unavailable.
--	This is set to "en" (English) by default.
--
--	Example: localify.SetFallbackLanguage( "de" ) -- fallback language is now German
--]]--
function SetFallbackLanguage( lang )
	if ( not IsValidLanguage( lang ) ) then error( "Invalid language provided ('"..tostring(lang).."')" ) return end
	
	FALLBACK = lang:lower()
end



--[[--------------------------------------------------------------------------
-- 	localify.GetLocale( player [optional] )
--
--	If used clientside, this will return the passed player's <ply> Localify language setting.
--	If used serverside, this will return the client's Localify language setting.
--
--	Returns the fallback language if the cvar is empty.
--	The cvar holding this value is "gmod_language".
--]]--
function GetLocale( ply )
	return ( SERVER and ply and ply:GetInfo( "localify_language" ):lower() )
	    or ( GetConVarString( "localify_language" ) == "" and FALLBACK or GetConVarString( "localify_language" ):lower() )
end

--[[--------------------------------------------------------------------------
-- 	localify.GetLanguages()
--
--	Returns the table of valid languages and their associated names.
--]]--
function GetLanguages()
	return languages
end

--[[--------------------------------------------------------------------------
-- 	localify.GetLocalizations( string )
--
--	Gets the table of all phrases that have been bound to the passed language <lang>.
--
--	Returns the table of ALL phrases (indexed by language token) if no language <lang> is passed.
--  Returns an empty table if the language is valid but doesn't contain any bound phrases.
--	Returns nil if the language has not been added to Localify.
--
--	Example: localify.GetLocalizations()       -- returns bindings for every language
--	Example: localify.GetLocalizations( "en" ) -- returns all English bindings
--	Example: localify.GetLocalizations( "zz" ) -- returns nil by default
--]]--
function GetLocalizations( lang )
	return ( not lang and localizations ) or ( lang and localizations[ lang:lower() ] ) or nil
end

--[[--------------------------------------------------------------------------
-- 	localify.GetFallbackLanguage()
--
--	Returns the current fallback language ("en" by default).
--]]--
function GetFallbackLanguage()
	return FALLBACK
end



--[[--------------------------------------------------------------------------
-- 	localify.LoadSharedFile( string )
--
--	Loads a file <path> containing localization phrases onto the server and for connecting clients.
--]]--
function LoadSharedFile( path )
	include( path )
	if ( SERVER ) then AddCSLuaFile( path ) end
end

--[[--------------------------------------------------------------------------
-- 	localify.LoadServerFile( string )
--
--	Loads a file <path> containing localization phrases onto the server.
--]]--
function LoadServerFile( path )
	if ( CLIENT ) then return end
	include( path )
end

--[[--------------------------------------------------------------------------
-- 	localify.LoadClientFile( string )
--
--	Loads a file <path> containing localization phrases onto connecting clients.
--]]--
function LoadClientFile( path )
	if ( SERVER ) then AddCSLuaFile( path ) return end
	include( path )
end



if ( CLIENT ) then

	-- Create a client cvar that copies the gmod_language cvar so that we can retrieve it from
	-- the server with ply:GetInfo( "localify_language" )
	CreateClientConVar( "localify_language", GetConVarString( "gmod_language" ), false, true )

	-- Check for changes to the gmod_language cvar and replicate them to localify_language
	cvars.AddChangeCallback( "gmod_language", function( name, old, new )
		if ( not IsValidLanguage( new ) ) then return end
		
		RunConsoleCommand( "localify_language", new )
	end, "localify" )

end

--addons/hackable_server/lua/languages/hacktool/lang_fr.lua:
return "french",{
    ["Wanted"] = "Recherché",
    ["Unwanted"] = "Annuler avis de Recherche",
    ["Unarrest"] = "Libéré",
    ["Warrant"] = "Mandat de perquisition",
    ["Remove warrant"] = "Retirer Mandat de perquisition",
    ["Add a law"] = "Ajouter une loi",
    ["Remove the law"] = "Supprimer la loi",
    ["Initiate a lockdown"] = "Déclencher un Couvre Feu",
    ["Cancel the lockdown"] = "Annuler le Couvre Feu",
    ["Steal money"] = "Voler de l'argent",
    ["Reason"] = "Raison",
    ["Error"] = "Erreur",
    ["Time"] = "Temps",
    ["Nobody is wanted"] = "Personne n'est recherché",
    ["Nobody is arrested"] = "Personne n'est arrêté",
    ["There is no mayor"] = "Il n'y a pas de maire",
    ["Law"] = "Loi",
    ["Law added"] = "Loi ajoutée",
    ["Success"] = "Succès",
    ["There is no laws"] = "Il n'y a pas de lois",
    ["Success! You got $"] = "Bravo ! Vous avez gagnez €",
    ["Success chance"] = "Chance de réussite",
    ["Not enough police"] = "Pas assez de policiers",
    ["LOADING..."] = "CHARGEMENT...",
    ["RELOADING..."] = "RECHARGEMENT...",
    ["CPU OVERHEAT!"] = "SURCHAUFFE DU PROCESSEUR!",
    ["SYSTEM ERROR!"] = "ERREUR DU SYSTÈME!",
    ["READY"] = "PRÊT"
}
--addons/hackable_server/lua/weapons/hacktool/settings.lua:
local settings = {
    reloadingTime = CreateConVar("hacktool_reloadingtime", "5", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    overheatTime = CreateConVar("hacktool_overheattime", "10", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    hackingTime = CreateConVar("hacktool_hackingtime", "30", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    ropeLength = CreateConVar("hacktool_ropelength", "150", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    hackMoney = CreateConVar("hacktool_hackmoney", "3000", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    alertTime = CreateConVar("hacktool_server_alerttime", "120", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    alertTime = CreateConVar("hacktool_minpolice", "1", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    initialhackchance = CreateConVar("hacktool_server_initialhackchance", "1", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    languagesv = CreateConVar("hacktool_language_default", "turkish", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    canhackdoors = CreateConVar("hacktool_canhack_doors", "1", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    canhackkeypads = CreateConVar("hacktool_canhack_keypads", "1", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
    canhackvehicles = CreateConVar("hacktool_canhack_vehicles", "1", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE),
}
if CLIENT then
	CreateConVar("hacktool_language", "tr", FCVAR_ARCHIVE)
end


local cvrs = {
	{
		text = "Default language",
		cvar = GetConVar("hacktool_language_default"),
		type = "cbox",
		setVals = function(cbox)
			local langs = hacktoolTranslate.GetLanguages()
			for i=1,#langs do
				cbox:AddChoice(langs[i], langs[i] == GetConVar("hacktool_language_default"):GetString())
			end
			cbox:SetValue(GetConVar("hacktool_language_default"):GetString())
		end
	},
	{
		text = "Reloading time",
		cvar = GetConVar("hacktool_reloadingtime"),
		type = "slider",
		min = 1, max = 60
	},
	{
		text = "Error reloading time",
		cvar = GetConVar("hacktool_overheattime"),
		type = "slider",
		min = 1, max = 60
	},
	{
		text = "Hacking time",
		cvar = GetConVar("hacktool_hackingtime"),
		type = "slider",
		min = 1, max = 60
	},
	{
		text = "Cable length",
		cvar = GetConVar("hacktool_ropelength"),
		type = "slider",
		min = 100, max = 300
	},
	{
		text = "Hacked money amount",
		cvar = GetConVar("hacktool_hackmoney"),
		type = "slider",
		min = 200, max = 20000, intOnly = true
	},
	{
		text = "Server alert time",
		cvar = GetConVar("hacktool_server_alerttime"),
		type = "slider",
		min = 10, max = 600
	},
	{
		text = "Initial hack chance",
		cvar = GetConVar("hacktool_server_initialhackchance"),
		type = "slider",
		min = 0.1, max = 1
	},
	{
		text = "Minimum police to steal money",
		cvar = GetConVar("hacktool_minpolice"),
		type = "slider",
		min = 0, max = 6, intOnly = true
	},
	{
		text = "Can hack doors",
		cvar = GetConVar("hacktool_canhack_doors"),
		type = "checkbox"
	},
	{
		text = "Can hack keypads",
		cvar = GetConVar("hacktool_canhack_keypads"),
		type = "checkbox"
	},
	{
		text = "Can hack vehicles",
		cvar = GetConVar("hacktool_canhack_vehicles"),
		type = "checkbox"
	}
}


local menuOptions = include("cl_hackmenuoptions.lua")

hackMenuSettings = {}

for k,v in ipairs(menuOptions) do
	local chance = "hacktool_server_"..v.id.."_chance"
	local enabled = "hacktool_server_"..v.id.."_enabled"
	CreateConVar(chance, "0.5", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE)
	CreateConVar(enabled, v.isCustom and "0" or "1", FCVAR_ARCHIVE+FCVAR_REPLICATED+FCVAR_SERVER_CAN_EXECUTE)
	hackMenuSettings[v.id] = {
		text = v.isCustom and "[custom] "..v.text or v.text,
		chance = GetConVar(chance),
		enabled = GetConVar(enabled)
	}
end


if CLIENT then

	local emptyFunction = function() end


	local ignoreChanges = false

	local updateList = {}

	local function addToUpdateList(panel, cvar, fun)
		updateList[#updateList + 1] = {panel = panel, cvar = cvar, fun = fun}
	end

	local function updateSettings()
		ignoreChanges = true
		for k,v in ipairs(updateList) do
			if v.fun and v.cvar then
				v.panel:SetValue(v.fun(v.cvar))
			end
		end
		ignoreChanges = false
	end

	local function onValueChanged(self, val)
		if ignoreChanges then return end
		if not LocalPlayer():IsSuperAdmin() then
			updateSettings()
			return
		end
		if self.intOnly then
			if self.lastIntValue == val then return end
			val = math.Round(val)
			if self.lastIntValue == val then
				self:SetValue(val)
				return
			end
			self.lastIntValue = val
		end
		net.Start('hack_tool.settings')
			net.WriteUInt(self.cvarid,8)
			if cvrs[self.cvarid].type == "cbox" then
				net.WriteString(val)
			elseif cvrs[self.cvarid].type == "slider" then
				net.WriteFloat(val)
			elseif cvrs[self.cvarid].type == "checkbox" then
				net.WriteBool(val)
			end
		net.SendToServer()
	end

	local function onOpValueChanged(self, val)
		if ignoreChanges then return end
		if not LocalPlayer():IsSuperAdmin() then
			updateSettings()
			return
		end
		net.Start('hack_tool.optionsSettings')
			net.WriteString(self.opid)
			net.WriteBool(self.isSlider)
			if self.isSlider then
				net.WriteFloat(val)
			else
				net.WriteBool(val)
			end
		net.SendToServer()
	end



	net.Receive("hack_tool.settings", function()
		updateSettings()
	end)

	local function createAdminsMenu(panel)
		updateList = {}
		local notAllowed = not LocalPlayer():IsSuperAdmin()
		if notAllowed then
			local permissionNotice = panel:Help("You are not a superadmin - you cannot change these settings, only view them.")
	    	permissionNotice:SetColor(Color(153, 51, 0, 255))
		end

		for k,v in ipairs(cvrs) do
			if v.type == "cbox" then
				local langBlock = vgui.Create("Panel", panel)
				langBlock:SetSize(0,20)
				langBlock:Dock(TOP)
				langBlock:DockMargin(10,10,10,10)
				local label = vgui.Create("DLabel", langBlock)
				label:Dock(FILL)
				label:DockMargin(0,5,0,0)
				label:SetText(v.text)
				label:SetDark(true)

				local cbox = vgui.Create("DComboBox", langBlock)
				cbox.cvarid = k
				v.setVals(cbox)
				addToUpdateList(cbox, v.cvar, v.cvar.GetString)
				cbox.OnSelect = function(self,id,value)
					onValueChanged(self, value)
				end
				cbox:SetSize(120,0)
				cbox:Dock(RIGHT)
			elseif v.type == "slider" then
				local item = vgui.Create("DNumSlider", panel)
				item:SetText( v.text )
				item:SetMin( v.min )
				item:SetMax( v.max )
				item:SetValue( v.cvar:GetFloat())
				addToUpdateList(item, v.cvar, v.cvar.GetFloat)
				item.intOnly = v.intOnly
				item:Dock(TOP)
				item:DockMargin(10,5,10,0)
				item:SetDark(true)
				item.cvarid = k
				item:SetEnabled(true)
				item.OnValueChanged = onValueChanged
				item:SizeToContents()
			elseif v.type == "checkbox" then
				local cb = vgui.Create("DCheckBoxLabel", panel)
				cb:SetText(v.text)
				cb:SetValue(v.cvar:GetBool())
				addToUpdateList(cb, v.cvar, v.cvar.GetBool)
				cb:SetDark(true)
				cb:Dock(TOP)
				cb:DockMargin(10,10,10,0)
				cb.cvarid = k
				cb.OnChange = onValueChanged
			end
		end

		local collapsibleCategory = vgui.Create("DCollapsibleCategory", panel)

		collapsibleCategory:Dock(TOP)
		collapsibleCategory:DockMargin(0,10,0,0)
		collapsibleCategory:SetLabel("Hacking options")
		collapsibleCategory:SetExpanded(true)

		for k,v in pairs(hackMenuSettings) do
			local label = vgui.Create("DLabel", collapsibleCategory)
			label:SetText(v.text)
			label:Dock(TOP)
			label:DockMargin(10,5,5,0)
			label:SetDark(true)			

			local slider = vgui.Create("DNumSlider", collapsibleCategory)
			slider:SetText("Hack chance multiplier")
			slider:SetMin( 0 )
			slider:SetMax( 1 )
			slider:SetValue(v.chance:GetFloat())
			addToUpdateList(slider, v.chance, v.chance.GetFloat)
			slider:Dock(TOP)
			slider:DockMargin(20,0,10,0)
			slider:SetDark(true)
			slider:SetEnabled(true)
			slider:SizeToContents()
			slider.opid = k
			slider.isSlider = true

			slider.OnValueChanged = onOpValueChanged

			local cb = vgui.Create("DCheckBoxLabel", collapsibleCategory)
			cb:SetText("Enabled")
			cb:SetValue(v.enabled:GetBool())
			addToUpdateList(cb, v.enabled, v.enabled.GetBool)
			cb:SetDark(true)
			cb:Dock(TOP)
			cb:DockMargin(20,0,10,10)
			cb.opid = k

			cb.OnChange = onOpValueChanged
		end
	end

	hook.Add( "PopulateToolMenu", "HackToolMenuSettings", function()
		local langs = hacktoolTranslate.GetLanguages()
		spawnmenu.AddToolMenuOption( "Utilities", "HackingTool", "hackingtoolmenu_admin", "Admin", "", "", createAdminsMenu)
		spawnmenu.AddToolMenuOption( "Utilities", "HackingTool", "hackingtoolmenu_user", "User", "", "", function( panel )
			panel:ClearControls()
			panel:CheckBox( "Show panel in the center of the screen", "hacktool_showpanel")

			local langBlock = vgui.Create("Panel", panel)
			langBlock:SetSize(0,20)
			langBlock:Dock(TOP)
			langBlock:DockMargin(10,10,10,10)
			local label = vgui.Create("DLabel", langBlock)
			label:Dock(LEFT)
			label:SetText("Language: ")
			label:SetDark(true)

			local cbox = vgui.Create("DComboBox", langBlock)
			for i=1,#langs do
				cbox:AddChoice(langs[i], langs[i] == GetConVar("hacktool_language"):GetString())
			end
			cbox:SetValue(GetConVar("hacktool_language"):GetString())
			cbox.OnSelect = function(self,id,value)
				GetConVar("hacktool_language"):SetString(value)
			end
			cbox:SetSize(120,0)
			cbox:Dock(RIGHT)
		end )
	end)
else
	util.AddNetworkString('hack_tool.settings')
	util.AddNetworkString('hack_tool.optionsSettings')

	local function sendUpdateRequest()
		net.Start('hack_tool.settings')
		net.Broadcast()
	end

	net.Receive('hack_tool.optionsSettings', function(len, ply)
		if not (IsValid(ply) and ply:IsSuperAdmin()) then return end
		local id = net.ReadString()
		if hackMenuSettings[id] then
			timer.Create("SendSettingsUpdate", 0.5, 1, sendUpdateRequest)
			if net.ReadBool() then
				hackMenuSettings[id].chance:SetFloat(net.ReadFloat())
			else
				hackMenuSettings[id].enabled:SetBool(net.ReadBool())
			end
		end
	end)

	net.Receive('hack_tool.settings', function(len, ply)
		if not (IsValid(ply) and ply:IsSuperAdmin()) then return end 
		local ind = net.ReadUInt(8)
		if not ind or not cvrs[ind] then return end

		timer.Create("SendSettingsUpdate", 0.5, 1, sendUpdateRequest)

		if cvrs[ind].type == "cbox" then
			local val = net.ReadString()
			if cvrs[ind].cvar then
				cvrs[ind].cvar:SetString(val)
			end
		elseif cvrs[ind].type == "slider" then
			local val = net.ReadFloat()
			if cvrs[ind].cvar then
				cvrs[ind].cvar:SetFloat(val)
			end
		elseif cvrs[ind].type == "checkbox" then
			local val = net.ReadBool()
			if cvrs[ind].cvar then
				cvrs[ind].cvar:SetBool(val)
			end
		end
	end)
end



--addons/hackable_server/lua/weapons/hacktool/cl_hackanim3.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/cl_hackanim3.lua:
local function fixLen(s,l)
	s=tostring(s)
	while string.len(s) < l do
		s='0'..s
	end
	return s
end

local Panel = {}

function Panel:Init()

	self.drawToScreen = true

	self.h = ScrH()*0.6
	self.w = self.h*1.5
	self.speed = 0.5
	self.difficulty = 0.05

	self:SetSize(self.w, self.h)
	self:SetPos((ScrW()-self.w)/2,(ScrH() - self.h)/2)

	self.pos = 1
	self:NoClipping(true)
	self:SetUpBindings()
end

function Panel:SetTimeout(timeStart, timeEnd)
	self.timeStart = timeStart
	self.timeEnd = timeEnd
	timer.Create('hackingPanel_timeout', self.timeEnd - self.timeStart, 1, function() 
		self.OnTimeOut()
	end)
end

function Panel:SetUpBindings()
	local nextTime = SysTime()+0.4
	local lastKey = nil
	hook.Add("PlayerButtonDown", "Hacking1", function(ply, key)
		if SysTime() < nextTime or not IsFirstTimePredicted() then return end
		nextTime = SysTime()+0.4
		local flag = true
		if key == KEY_ENTER or key == MOUSE_LEFT then
			local val = math.sin(self.pos + (1+0.1*self.pos)*(SysTime()-self.timeStart))
			if math.abs(val)<0.12 then
				if self.pos == 8 then
					self.doBeep('bebeep',0.5)
					self:OnSuccess()
					return
				end
				self.doBeep('beep',0.5)
				self.pos = self.pos + 1
			else
				self.doBeep('bzz',0.8)
				self.pos = self.pos == 1 and 1 or self.pos - 1
			end
		else
			flag = false
		end
		if flag then
			lastKey = key
		end
	end)

	hook.Add("PlayerButtonUp", "Hacking1", function(ply, key)
		if lastKey == key and SysTime() < nextTime then
			nextTime = SysTime()+0.02
			lastKey = nil
		end
	end)

	hook.Add("PlayerBindPress","Hacking2", function(ply, bind, pressed)
		bind = input.LookupBinding(bind)
		if bind == "MWHEELDOWN" or bind == "MWHEELUP" then return true end
		if pressed and "MOUSE1" == bind then
			return true
		end
	end,-1)
end

local gradient_u = Material("vgui/gradient-u")
local gradient_d = Material("vgui/gradient-d")

function Panel:OnRemove()
	timer.Remove('hackingPanel_timeout')
	hook.Remove("PlayerBindPress","Hacking2")
	hook.Remove("PlayerButtonDown", "Hacking1")
	hook.Remove("PlayerButtonUp", "Hacking1")
end

local function drawOutlinedBox( x, y, w, h, thickness)
	for i=0, thickness - 1 do
		surface.DrawOutlinedRect( x + i, y + i, w - i * 2, h - i * 2 )
	end
end

function Panel:DrawOnRt(rt)
	local w, h = rt:Width(), rt:Height()

	local function drawStick(pos, sel)
		local sx, sy = w * 0.031, h * 0.163
		local ad = 0
		if sel then
			surface.SetDrawColor(229,208,53)
			ad = sx*0.13
		else
			surface.SetDrawColor(255,255,255,255)
		end
		local val = pos < self.pos and 0 or math.sin(pos + (1+0.1*pos)*(SysTime()-self.timeStart))
		local px,py = w*(0.5 + (pos - 4.5)*0.06), h * (0.573 + 0.16 * val)
		surface.DrawRect(px - sx/2-ad, py - sy - h*0.025 - ad, sx + ad*2, sy + ad*2)
		surface.DrawRect(px - sx/2-ad, py + h*0.025 - ad, sx + ad*2, sy + ad*2)
	end

	render.PushRenderTarget(rt, 0, 0, w, h)
	cam.Start2D()

	surface.SetDrawColor(0,0,0,255)
	surface.DrawRect( 0, 0, w, h )

	surface.SetDrawColor(255,0,0,255)
	local px,py,sx,sy = w/2, h*0.573, w*0.62, h*0.8
	drawOutlinedBox(px-sx/2, py - sy/2,sx,sy,h*0.006)
	sy = h*0.04
	surface.DrawRect(px-sx/2, py - sy/2, sx, sy)

	drawStick(self.pos, true)
	for i=1,8 do
		drawStick(i, false)
	end

	--Draw time
	local timeLeft = (self.timeEnd - CurTime())
	text = '00:'..fixLen(math.Round(timeLeft),2)..':'..fixLen((math.Round(timeLeft%1*1000)),3)
	surface.SetFont(hacktoolMats.font12)
	local tw,th = surface.GetTextSize(text)
	surface.SetTextPos(w/2 - tw/2,h*0.1)
	surface.SetTextColor(48,163,47,255)
	surface.DrawText(text)

	cam.End2D()
	render.PopRenderTarget()


	return rt
end

local bgMatUnilit = Material("models/weapons/hacktool/hacktool_mon_unilit")

local col_panelBorder = Color(28,67,176)

function Panel:Paint()

	local noerr, text = pcall(self.DrawOnRt, self, hacktoolMats.panelRt)

	if not noerr then
		cam.End2D()
		render.PopRenderTarget()
		print("Render error:",text)
	end
	hacktoolMats.panelMat:SetTexture('$basetexture', hacktoolMats.panelRt)

	if self.drawToScreen then
		draw.RoundedBox( 8, 0, 0, self.w, self.h, col_panelBorder)
		surface.SetMaterial(hacktoolMats.panelMat)
		surface.DrawTexturedRect( self.w*0.013, self.h*0.075, self.w*0.974, self.h*0.912 )		
	end

	local w,h = hacktoolMats.vmatrt:Width(),hacktoolMats.vmatrt:Height()

	render.PushRenderTarget(hacktoolMats.vmatrt)
	cam.Start2D()
	render.Clear(0,0,0,255,true)
		render.ClearDepth()
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD )

		surface.SetDrawColor( 255, 255, 255, 255 )

		surface.SetMaterial(bgMatUnilit)
		surface.DrawTexturedRect(0,0,w,h)


		surface.SetMaterial(hacktoolMats.panelMat)
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ZERO, BLEND_ONE, BLENDFUNC_ADD )

		surface.DrawTexturedRectRotated(w/2,h/2,996/1024*w,656/1024*h,180)
		render.OverrideBlend( false )
	
	cam.End2D()
	render.PopRenderTarget()

	hacktoolMats.vmmat:SetTexture('$basetexture', hacktoolMats.vmatrt)

end
vgui.Register("HackPanel3", Panel, "DPanel")
--addons/xenin-inventory/lua/weapons/inventory/shared.lua:
return gluapack()()
--lua/weapons/sv_spikestrip_spawner/cl_init.lua:
return gluapack()()
--lua/weapons/sv_spikestrip_spawner/cl_init.lua:
include('shared.lua')
SWEP.PrintName			= 'Spike Strip'
SWEP.Slot				= 2
SWEP.SlotPos			= 2
SWEP.DrawAmmo			= false

local previewModel

function SWEP:Think()
    if IsValid(previewModel) then
        local tr = {}
        tr.start = LocalPlayer():GetShootPos()
        tr.endpos = LocalPlayer():GetShootPos() + 200 * LocalPlayer():GetAimVector()
        tr.filter = {LocalPlayer()}
        local trace = util.TraceLine(tr)
        previewModel:SetPos(trace.HitPos)
        previewModel:SetAngles(Angle(0, LocalPlayer():GetAngles().y, 0))
    else
        previewModel = ClientsideModel('models/novacars/spikestrip/spikestrip.mdl', RENDERGROUP_BOTH)
        previewModel:SetRenderMode(RENDERMODE_TRANSCOLOR)
        previewModel:SetColor(Color(0, 255, 0, 150))
    end
end

function SWEP:OnRemove()
    if previewModel then
        previewModel:Remove()
        previewModel = nil
    end
end

function SWEP:Holster(weapon)
    if IsValid(previewModel) then
        previewModel:Remove()
        previewModel = nil
    end
    return true
end
--gamemodes/darkrp/entities/weapons/unarrest_stick/shared.lua:
return gluapack()()
--addons/[binbon]misc/lua/weapons/weapon_ciga/cl_init.lua:
return gluapack()()
--gamemodes/darkrp/entities/weapons/weapon_cs_base2/shared.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_bayonet.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_bowie.lua:
sound.Add( { name = "Weapon_Bowie.Draw", channel = CHAN_STATIC, volume = 0.70, level = SNDLVL_NORM, sound = "weapons/knife_bowie/draw.wav" } )
sound.Add( { name = "Weapon_Bowie.LookEnd", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_bowie/lookend.wav" } )
sound.Add( { name = "Weapon_Bowie.LookStart", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_bowie/lookstart.wav" } )

if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then							
	SWEP.Slot				= SWEP.WeaponSlot or 0
	SWEP.SlotPos			= 0
	SWEP.ViewModelFOV		= 60
	SWEP.DrawCrosshair		= true
end

SWEP.Base					= "weapon_csgobase_knife"

SWEP.PrintName				= "Bowie Knife"
SWEP.Category				= "CS:GO Knives"
SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.ViewModel				= Model( "models/weapons/knife_bowie/v_bowie.mdl" )
SWEP.WorldModel				= Model( "models/weapons/knife_bowie/w_bowie.mdl" )
SWEP.HoldType				= "knife"
--lua/weapons/weapon_csgo_knife_falchion.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_karambit.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_push.lua:
return gluapack()()
--lua/weapons/weapon_pet/shared.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--addons/vape_swep/lua/weapons/weapon_vape_medicinal.lua:
return gluapack()()
--gamemodes/darkrp/entities/weapons/weaponchecker/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 1
    SWEP.SlotPos = 9
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to weapon check\nRight click to confiscate weapons\nReload to give back the weapons"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPWeaponChecker = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"

SWEP.PrintName = "Weapon Checker"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.MinCheckTime = 5
SWEP.MaxCheckTime = 10

DarkRP.hookStub{
    name = "playerWeaponsChecked",
    description = "Called when a player with a weapon checker has checked another player's weapons. Note: Only called when the player looks at the weapons without confiscating. Please see playerWeaponsConfiscated for when weapons are actually confiscated.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been checked.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been checked.",
            type = "table"
        },
    },
    returns = {},
    realm = "Shared"
}

DarkRP.hookStub{
    name = "playerWeaponsReturned",
    description = "Called when a player with a weapon checker has returned another player's weapons.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been returned.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been returned.",
            type = "table"
        },
    },
    returns = {},
    realm = "Server"
}

DarkRP.hookStub{
    name = "playerWeaponsConfiscated",
    description = "Called when a player with a weapon checker has confiscated another player's weapons.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been confiscated.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been confiscated.",
            type = "table"
        },
    },
    returns = {},
    realm = "Server"
}

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IsWeaponChecking")
    self:NetworkVar("Float", 0, "StartCheckTime")
    self:NetworkVar("Float", 1, "EndCheckTime")
    self:NetworkVar("Float", 2, "NextSoundTime")
    self:NetworkVar("Int", 0, "TotalWeaponChecks")
end

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    return true
end

function SWEP:DrawWorldModel()
end

function SWEP:PreDrawViewModel(vm)
    return true
end

function SWEP:GetStrippableWeapons(ent, callback)
    CAMI.PlayerHasAccess(ent, "DarkRP_GetAdminWeapons", function(access)
        for _, v in ipairs(ent:GetWeapons()) do
            local class = v:GetClass()

            if GAMEMODE.Config.weaponCheckerHideDefault and (table.HasValue(GAMEMODE.Config.DefaultWeapons, class) or
                access and table.HasValue(GAMEMODE.Config.AdminWeapons, class) or
                ent:getJobTable() and ent:getJobTable().weapons and table.HasValue(ent:getJobTable().weapons, class)) then
                continue
            end

            if (GAMEMODE.Config.weaponCheckerHideNoLicense and GAMEMODE.NoLicense[class]) or GAMEMODE.Config.noStripWeapons[class] then continue end

            callback(v)
        end
    end)
end

function SWEP:PrimaryAttack()
    if self:GetIsWeaponChecking() then return end
    self:SetNextPrimaryFire(CurTime() + 0.3)

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = Owner:GetEyeTrace()
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() or ent:GetPos():DistToSqr(Owner:GetPos()) > 10000 then
        return
    end

    self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
    self:SetNextSoundTime(CurTime() + 0.3)

    if not IsFirstTimePredicted() then return end

    local weps = {}
    self:GetStrippableWeapons(ent, function(wep)
        table.insert(weps, wep)
    end)

    hook.Call("playerWeaponsChecked", nil, Owner, ent, weps)

    if not CLIENT then return end

    self:PrintWeapons(ent, DarkRP.getPhrase("persons_weapons", ent:Nick()))
end

function SWEP:SecondaryAttack()
    if self:GetIsWeaponChecking() then return end
    self:SetNextSecondaryFire(CurTime() + 0.3)

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = Owner:GetEyeTrace()
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() or ent:GetPos():DistToSqr(Owner:GetPos()) > 10000 then
        return
    end

    self:SetIsWeaponChecking(true)
    self:SetStartCheckTime(CurTime())
    self:SetEndCheckTime(CurTime() + util.SharedRandom("DarkRP_WeaponChecker" .. self:EntIndex() .. "_" .. self:GetTotalWeaponChecks(), self.MinCheckTime, self.MaxCheckTime))
    self:SetTotalWeaponChecks(self:GetTotalWeaponChecks() + 1)

    self:SetNextSoundTime(CurTime() + 0.5)

    if CLIENT then
        self.Dots = ""
        self.NextDotsTime = CurTime() + 0.5
    end
end

function SWEP:Reload()
    if CLIENT or CurTime() < (self.NextReloadTime or 0) then return end
    self.NextReloadTime = CurTime() + 1

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local trace = Owner:GetEyeTrace()

    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() or ent:GetPos():DistToSqr(Owner:GetPos()) > 10000 then
        return
    end

    if not ent.ConfiscatedWeapons then
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("no_weapons_confiscated", ent:Nick()))
        return
    else
        ent:RemoveAllAmmo()
        for _, v in pairs(ent.ConfiscatedWeapons) do
            local wep = ent:Give(v.class, true)

            -- :Give returns NULL when the player already has the weapon
            wep = IsValid(wep) and wep or ent:GetWeapon(v.class)
            if not IsValid(wep) then continue end

            ent:GiveAmmo(v.primaryAmmoCount, v.primaryAmmoType, true)
            ent:GiveAmmo(v.secondaryAmmoCount, v.secondaryAmmoType, true)

            wep:SetClip1(v.clip1)
            wep:SetClip2(v.clip2)

        end
        DarkRP.notify(Owner, 2, 4, DarkRP.getPhrase("returned_persons_weapons", ent:Nick()))

        hook.Call("playerWeaponsReturned", nil, Owner, ent, ent.ConfiscatedWeapons)
        ent.ConfiscatedWeapons = nil
    end
end

function SWEP:Holster()
    self:SetIsWeaponChecking(false)
    self:SetNextSoundTime(0)
    return true
end

function SWEP:Succeed()
    if not IsValid(self:GetOwner()) then return end
    self:SetIsWeaponChecking(false)

    local trace = self:GetOwner():GetEyeTrace()
    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() then return end

    if CLIENT then
        if not IsFirstTimePredicted() then return end
        self:PrintWeapons(ent, DarkRP.getPhrase("confiscated_these_weapons"))
        return
    end

    local stripped = {}

    self:GetStrippableWeapons(ent, function(wep)
        ent:StripWeapon(wep:GetClass())
        stripped[wep:GetClass()] = {
            class = wep:GetClass(),
            primaryAmmoCount = ent:GetAmmoCount(wep:GetPrimaryAmmoType()),
            primaryAmmoType = wep:GetPrimaryAmmoType(),
            secondaryAmmoCount = ent:GetAmmoCount(wep:GetSecondaryAmmoType()),
            secondaryAmmoType = wep:GetSecondaryAmmoType(),
            clip1 = wep:Clip1(),
            clip2 = wep:Clip2()
        }
    end)

    if not ent.ConfiscatedWeapons then
        if next(stripped) ~= nil then ent.ConfiscatedWeapons = stripped end
    else
        -- Merge stripped weapons into confiscated weapons
        for k,v in pairs(stripped) do
            if ent.ConfiscatedWeapons[k] then continue end

            ent.ConfiscatedWeapons[k] = v
        end
    end

    hook.Call("playerWeaponsConfiscated", nil, self:GetOwner(), ent, ent.ConfiscatedWeapons)

    if next(stripped) ~= nil then
        self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
        self:SetNextSoundTime(CurTime() + 0.3)
    else
        self:EmitSound("ambient/energy/zap1.wav", 50, 100)
        self:SetNextSoundTime(0)
    end
end

function SWEP:PrintWeapons(ent, weaponsFoundPhrase)
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local result = {}
    local weps = {}
    self:GetStrippableWeapons(ent, function(wep)
        table.insert(weps, wep)
    end)

    for _, wep in ipairs(weps) do
        table.insert(result, wep:GetPrintName() and language.GetPhrase(wep:GetPrintName()) or wep:GetClass())
    end

    result = table.concat(result, ", ")

    if result == "" then
        Owner:ChatPrint(DarkRP.getPhrase("no_illegal_weapons", ent:Nick()))
        return
    end

    Owner:ChatPrint(weaponsFoundPhrase)
    if string.len(result) >= 126 then
        local amount = math.ceil(string.len(result) / 126)
        for i = 1, amount, 1 do
            Owner:ChatPrint(string.sub(result, (i-1) * 126, i * 126 - 1))
        end
    else
        Owner:ChatPrint(result)
    end
end

function SWEP:Fail()
    self:SetIsWeaponChecking(false)
    self:SetHoldType("normal")
    self:SetNextSoundTime(0)
end

function SWEP:Think()
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    if self:GetIsWeaponChecking() and self:GetEndCheckTime() ~= 0 then
        Owner:LagCompensation(true)
        local trace = Owner:GetEyeTrace()
        Owner:LagCompensation(false)
        if not IsValid(trace.Entity) or trace.HitPos:DistToSqr(Owner:GetShootPos()) > 10000 or not trace.Entity:IsPlayer() then
            self:Fail()
        end
        if self:GetEndCheckTime() <= CurTime() then
            self:Succeed()
        end
    end
    if self:GetNextSoundTime() ~= 0 and CurTime() >= self:GetNextSoundTime() then
        if self:GetIsWeaponChecking() then
            self:SetNextSoundTime(CurTime() + 0.5)
            self:EmitSound("npc/combine_soldier/gear5.wav", 100, 100)
        else
            self:SetNextSoundTime(0)
            self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
        end
    end
    if CLIENT and self.NextDotsTime and CurTime() >= self.NextDotsTime then
        self.NextDotsTime = CurTime() + 0.5
        self.Dots = self.Dots or ""
        local len = string.len(self.Dots)
        local dots = {
            [0] = ".",
            [1] = "..",
            [2] = "...",
            [3] = ""
        }
        self.Dots = dots[len]
    end
end

local colorBackground = Color(10, 10, 10, 120)

function SWEP:DrawHUD()
    if self:GetIsWeaponChecking() and self:GetEndCheckTime() ~= 0 then
        self.Dots = self.Dots or ""
        local w = ScrW()
        local h = ScrH()
        local x, y, width, height = w / 2 - w / 10, h / 2, w / 5, h / 15
        local time = self:GetEndCheckTime() - self:GetStartCheckTime()
        local curtime = CurTime() - self:GetStartCheckTime()
        local status = math.Clamp(curtime / time, 0, 1)
        local BarWidth = status * (width - 16)
        local cornerRadius = math.Min(8, BarWidth / 3 * 2 - BarWidth / 3 * 2 % 2)

        draw.RoundedBox(8, x, y, width, height, colorBackground)
        draw.RoundedBox(cornerRadius, x + 8, y + 8, BarWidth, height - 16, Color(0, 0 + (status * 255), 255 - (status * 255), 255))
        draw.DrawNonParsedSimpleText(DarkRP.getPhrase("checking_weapons") .. self.Dots, "Trebuchet24", w / 2, y + height / 2, color_white, 1, 1)
    end
end

--addons/zeros_golddiggger/lua/weapons/zgw_shovel/cl_init.lua:


include("shared.lua")
function SWEP:Initialize()
	zgw.Shovel.Initialize(self)
end

function SWEP:SecondaryAttack()
	zgw.Shovel.Secondary(self)
end

function SWEP:PrimaryAttack()
	zgw.Shovel.Primary(self)
end

function SWEP:Deploy()
	zgw.Shovel.Deploy(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198872838622

function SWEP:Holster(swep)
	zgw.Shovel.Holster(self)
end

function SWEP:Reload()
	zgw.Shovel.Reload(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198872838622
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 0a5818b862f942a32f280da19656bfe6fb14cbd620f4eff776b06ce3fb51fd0e

function SWEP:DrawHUD()
	zgw.Shovel.DrawHUD(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198872838622

function SWEP:Think()
	zgw.Shovel.Think(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 549ca24f37f8589f265ca557954c28b4325c41edf21ed3859b40baf576d8adf4

--addons/zeros_golddiggger/lua/weapons/zgw_shovel/shared.lua:
return gluapack()()
--addons/zeros_golddiggger/lua/weapons/zgw_shovel/shared.lua:


SWEP.PrintName = "Shovel"
SWEP.Author = "Zero"
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = "Used to dig up dirt."
SWEP.AdminSpawnable = false
SWEP.Spawnable = true

SWEP.AutomaticFrameAdvance = true
SWEP.ViewModelFOV = 90
SWEP.ViewModel = "models/zerochain/props_goldwash/zgw_v_shovel.mdl"
SWEP.WorldModel = "models/zerochain/props_goldwash/zgw_w_shovel.mdl"
SWEP.UseHands = true

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Slot = 3
SWEP.SlotPos = 15
SWEP.HoldType = "melee2"
SWEP.FiresUnderwater = true
SWEP.Weight = 1
SWEP.DrawCrosshair = true
SWEP.AccurateCrosshair = true
SWEP.Category = "Zeros GoldWasher"
SWEP.DrawAmmo = false
SWEP.base = "weapon_base"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 0.25

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 1

SWEP.DisableDuplicator = true

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("zerochain/zgw/vgui/zgw_vgui_shovel")
	SWEP.BounceWeaponIcon = false
end

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198872838622

function SWEP:SetupDataTables()

	self:NetworkVar("Int", 0, "Dirt")

	if SERVER then
		self:SetDirt(0)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 9ac369ca150c22e64f828cd5857ffea33c11645bd3819881a5581360ebf7ce05
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f6df0a94af3a750a3d331a6881d44d3c6811e6ae1489523704d95e9e8195831d

--addons/zeros_golddiggger/lua/weapons/zgw_sieve/shared.lua:
return gluapack()()
--addons/spzones/lua/weapons/zones_tool/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/zrmine_config.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/weapons/ztm_trashcollector/shared.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

include("sh_ztm_config.lua")
SWEP.PrintName = "Trash Collector" // The name of your SWEP
SWEP.Author = "ZeroChain" // Your name
SWEP.Instructions = "LMB - Blow Leafs | RMB - Collect Trash | MMB - Drop Trashbag" // How do people use your SWEP?
SWEP.Contact = "https://www.gmodstore.com/users/ZeroChain" // How people should contact you if they find bugs, errors, etc
SWEP.Purpose = "Used to collect trash." // What is the purpose of the SWEP?
SWEP.AdminSpawnable = true // Is the SWEP spawnable for admins?
SWEP.Spawnable = true // Can everybody spawn this SWEP? - If you want only admins to spawn it, keep this false and admin spawnable true.
SWEP.ViewModelFOV = 100 // How much of the weapon do you see?
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

SWEP.ViewModel = "models/zerochain/props_trashman/ztm_trashcollector_vm.mdl"
SWEP.WorldModel =  "models/zerochain/props_trashman/ztm_trashcollector.mdl"


SWEP.AutoSwitchTo = false // When someone picks up the SWEP, should it automatically change to your SWEP?
SWEP.AutoSwitchFrom = false // Should the weapon change to the a different SWEP if another SWEP is picked up?
SWEP.Slot = 3 // Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos = 2 // Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.HoldType = "smg" // How is the SWEP held? (Pistol SMG Grenade Melee)
SWEP.FiresUnderwater = false // Does your SWEP fire under water?
SWEP.Weight = 5 // Set the weight of your SWEP.
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?
SWEP.Category = "Zeros Trashman"
SWEP.DrawAmmo = false // Does the ammo show up when you are using it? True / False
SWEP.base = "weapon_base" //What your weapon is based on.

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 0.5

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 0.5

SWEP.UseHands = true

function SWEP:SetupDataTables()

	self:NetworkVar("Int", 0, "Trash")
	self:NetworkVar("Bool", 0, "IsBusy")
	self:NetworkVar("Bool", 1, "IsCollectingTrash")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	self:NetworkVar("Int", 1, "PlayerLevel")
	self:NetworkVar("Float", 2, "PlayerXP")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	self:NetworkVar("Float", 3, "Last_Primary")
	self:NetworkVar("Float", 4, "Last_Secondary")


	if SERVER then
		self:SetTrash(0)
		self:SetIsBusy(false)
		self:SetIsCollectingTrash(false)
		self:SetPlayerLevel(1)
		self:SetPlayerXP(0)

		self:SetLast_Primary(0)
		self:SetLast_Secondary(0)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/turkish_food_mod-main/lua/entities/adana/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Adana Kebap"
ENT.Category = "Turkish Food Mod"
ENT.Spawnable = true
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo.lua:
AddCSLuaFile()

ENT.Type                     = "anim"
ENT.Base                     = "base_entity"
ENT.RenderGroup              = RENDERGROUP_TRANSLUCENT

ENT.PrintName                = "Base Ammo"
ENT.Category                 = "ArcCW - Ammo"
ENT.ArcCW_Ammo = true

ENT.Spawnable                = false
ENT.Model                    = "models/items/sniper_round_box.mdl"
ENT.MaxHealth = 40
ENT.Scale = 1

ENT.AmmoType = "SniperPenetratedRound"
ENT.AmmoCount = 5
ENT.DetonationDamage = 10 -- Per-round damage
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/arccw/glock18/glock18-1.wav" -- string or table

ENT.ShellModel = "models/shells/shell_9mm.mdl"
ENT.ShellScale = 1.5

ENT.ResistanceMult = {
    [DMG_BURN] = 3,
    [DMG_DIRECT] = 3, -- This is also fire
    [DMG_BLAST] = 2,
    [DMG_BULLET] = 0.5,
    [DMG_BUCKSHOT] = 0.5,
    [DMG_CLUB] = 0.25,
    [DMG_SLASH] = 0.25,
    [DMG_CRUSH] = 0.25,
    [DMG_NERVEGAS] = 0,
    [DMG_POISON] = 0
}

function ENT:Initialize()
    self:SetModel(self.Model)
    self:SetHealth(math.max(math.ceil(self.MaxHealth * ArcCW.ConVars["mult_ammohealth"]:GetFloat()), 1))
    self.AmmoCount = math.max(math.ceil(self.AmmoCount * ArcCW.ConVars["mult_ammoamount"]:GetFloat(), 1))
    self.MaxAmmoCount = self.AmmoCount

    if engine.ActiveGamemode() == "terrortown" and ArcCW.TTTReplaceTable then
        self.AmmoType = ArcCW.TTTReplaceTable[self.AmmoType] or self.AmmoType
    end

    if self.Scale != 1 then
        self:SetModelScale(self.Scale)
    end

    if self:SkinCount() > 1 and math.random() <= ArcCW.ConVars["ammo_rareskin"]:GetFloat() then
        self:SetSkin(math.random(1, self:SkinCount() - 1))
    end

    if SERVER then

        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
        self:SetUseType(SIMPLE_USE)
        self:PhysWake()

        self:SetTrigger(true) -- Enables Touch() to be called even when not colliding
        if ArcCW.ConVars["ammo_largetrigger"]:GetBool() then
            self:UseTriggerBounds(true, 24)
        end
    end
end

-- Adapted from TTT's ammo - we don't use it otherwise
function ENT:TTT_PlayerCanPickup(ply)
    if ply == self:GetOwner() then return false end

    local result = hook.Call("TTTCanPickupAmmo", nil, ply, self)
    if result then
        return result
    end

    local ent = self
    local phys = ent:GetPhysicsObject()
    local spos = phys:IsValid() and phys:GetPos() or ent:OBBCenter()
    local epos = ply:GetShootPos()

    local tr = util.TraceLine({start = spos, endpos = epos, filter = {ply, ent}, mask = MASK_SOLID})

    -- can pickup if trace was not stopped
    return tr.Fraction == 1.0
end

-- Ditto - unused outside of TTT
function ENT:TTT_CheckForWeapon(ply)
    --[[]
    if !self.CachedWeapons then
        local tbl = {}
        for k,v in pairs(weapons.GetList()) do
            if v and v.Primary.Ammo == self.AmmoType then
                tbl[v.ClassName] = true -- WEPS.GetClass(v)
            end
        end
        self.CachedWeapons = tbl
    end
    ]]

    -- Why does TTT not iterate over the player's weapons? This is obviously faster
    for _, wep in ipairs(ply:GetWeapons()) do
        --if self.CachedWeapons[wep:GetClass()] then return true end
        -- Perform check for overwritten ammo types (attachments) and UBGLs
        if wep.ArcCW and
                (wep:GetBuff_Override("UBGL_Ammo") == self.AmmoType
                or wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo) == self.AmmoType
                or wep:GetBuff_Override("Akimbo_Ammo") == self.AmmoType) then
            return true
        end
    end
    return false
end

function ENT:ApplyAmmo(ply)
    if self.USED then return end
    if engine.ActiveGamemode() == "terrortown" then
        -- Stupid checks mate... but we'll play along unless an override exists
        if !self.IgnoreTTTChecks and !self:TTT_PlayerCanPickup(ply) or !self:TTT_CheckForWeapon(ply) then return end

        local giveCount = math.min(self.AmmoCount, ArcCW.TTTAmmoToClipMax[string.lower(self.AmmoType)] - ply:GetAmmoCount(self.AmmoType))
        if giveCount <= 0 then return end

        self.AmmoCount = self.AmmoCount - giveCount
        ply:GiveAmmo(giveCount, self.AmmoType)

        -- Ugly hack to let client update ammo count
        -- Why not just use NWInts or NetworkVars to begin with? Good question!
        self:SetNWInt("truecount", self.AmmoCount)

        if self.AmmoCount <= 0 then
            self.USED = true
            self:Remove()
        end
    else
        self.USED = true -- Prevent multiple uses
        ply:GiveAmmo(self.AmmoCount, self.AmmoType)
        self:Remove()
    end
end

function ENT:DetonateRound()
    local count = math.Clamp(math.random(1, self.MaxAmmoCount / 5), 1, self.AmmoCount)
    -- Default function
    self:FireBullets({
        Attacker = self.Burner,
        Damage = self.DetonationDamage,
        Force = self.DetonationDamage / 5,
        Num = count,
        AmmoType = self.AmmoType,
        Src = self:WorldSpaceCenter(),
        Dir = self:GetUp(),
        Spread = Vector(math.pi * 2, math.pi * 2, 0),
        IgnoreEntity = self
    })
    self.AmmoCount = self.AmmoCount - count

    self:GetPhysicsObject():AddVelocity(VectorRand() * math.random(30, 50) * self:GetPhysicsObject():GetMass())
    self:GetPhysicsObject():AddAngleVelocity(VectorRand() * math.random(60, 300))

    if self.DetonationSound then
        self:EmitSound(istable(self.DetonationSound) and table.Random(self.DetonationSound) or self.DetonationSound)
    end
end

function ENT:Detonate(wet, attacker)
    if wet then
        self:FireBullets({
            Attacker = attacker,
            Damage = self.DetonationDamage,
            Force = self.DetonationDamage / 5,
            Num = math.max(self.AmmoCount, 50),
            AmmoType = self.AmmoType,
            Src = self:WorldSpaceCenter(),
            Dir = self:GetUp(),
            Spread = Vector(math.pi * 2, math.pi * 2, 0),
            IgnoreEntity = self
        })
    end

    local e = EffectData()
    e:SetOrigin(self:GetPos())
    util.Effect("Explosion", e)

    util.BlastDamage(self, attacker, self:GetPos(), self.DetonationRadius, self.DetonationDamage * (wet and 0.5 or 1))
    self:Remove()
end

if SERVER then

    function ENT:Use(ply)
        if !ply:IsPlayer() then return end
        self:ApplyAmmo(ply)
    end


    function ENT:Touch(ply)
        if !ply:IsPlayer() or !ArcCW.ConVars["ammo_autopickup"]:GetBool() then return end
        self:ApplyAmmo(ply)
    end

    function ENT:Burn(attacker)
        self.Burning = true
        self.Burner = attacker
        self:Ignite(30)
        self:SetHealth(-1)
    end

    function ENT:OnTakeDamage(dmginfo)

        if self:Health() <= 0 or self.USED then return end

        --self:TakePhysicsDamage(dmginfo)
        self:SetHealth(self:Health() - dmginfo:GetDamage())

        if self:Health() <= 0 then

            self.USED = true

            local cvar = ArcCW.ConVars["ammo_detonationmode"]:GetInt()

            if cvar == -1 or (!ArcCW.ConVars["ammo_chaindet"]:GetBool() and dmginfo:GetInflictor().ArcCW_Ammo) or self.DetonationDamage <= 0 then
                -- Go quietly
                local e = EffectData()
                e:SetOrigin(self:GetPos())
                e:SetMagnitude(8)
                e:SetScale(2)
                util.Effect("Sparks", e)
                self:EmitSound("physics/cardboard/cardboard_box_break2.wav", 80, 120)
                self:Remove()
            elseif cvar == 2 and (math.random() <= 0.25 or dmginfo:IsDamageType(DMG_BURN)) then
                -- Fancy ammobox burning
                self:Burn(dmginfo:GetAttacker())
            else
                -- Plain old explosion
                self:Detonate(cvar >= 1, dmginfo:GetAttacker())
            end
        end

    end

    function ENT:Think()
        if self.Burning then

            if self.AmmoCount <= 0 then
                self:Detonate(false, IsValid(self.Burner) and self.Burner or self)
            else
                self:DetonateRound()
            end

            self:NextThink(CurTime() + math.random() * 0.3 + 0.2)
            return true
        end
    end

    -- Do it during the hook so that hit damage numbers show up properly (yes, I am _that_ pedantic)
    hook.Add("EntityTakeDamage", "ArcCW_Ammo", function(ent, dmginfo)
        if ent.ArcCW_Ammo then
            if ArcCW.ConVars["mult_ammohealth"]:GetFloat() < 0 then
                dmginfo:ScaleDamage(0)
            elseif ent.ResistanceMult then
                -- Only apply one multiplier, and prioritize larger ones
                for k, v in SortedPairsByValue(ent.ResistanceMult, true) do if dmginfo:IsDamageType(k) then dmginfo:ScaleDamage(v) break end end
            end
        end
    end)

elseif CLIENT then

    function ENT:DrawTranslucent()
        self:Draw()
    end

    function ENT:Draw()
        self:DrawModel()

        local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
        if cvar2d3d == 0 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity != self) then return end

        if (EyePos() - self:GetPos()):LengthSqr() <= 262144 then -- 512^2
            local ang = LocalPlayer():EyeAngles()

            ang:RotateAroundAxis(ang:Forward(), 180)
            ang:RotateAroundAxis(ang:Right(), 90)
            ang:RotateAroundAxis(ang:Up(), 90)

            cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, (self:OBBMaxs().z - self:OBBMins().z) * 0.5 + 8) , ang, 0.1)
                surface.SetFont("ArcCW_32_Unscaled")

                local w = surface.GetTextSize(self.PrintName)

                surface.SetTextPos(-w / 2 + 2, 2)
                surface.SetTextColor(0, 0, 0, 150)
                surface.DrawText(self.PrintName)

                surface.SetTextPos(-w / 2, 0)
                surface.SetTextColor(255, 255, 255, 255)
                surface.DrawText(self.PrintName)

                local ammo = self:GetNWInt("truecount", -1) != -1 and self:GetNWInt("truecount", -1) or self.AmmoCount
                if ammo then
                    w = surface.GetTextSize("×" .. ammo)

                    surface.SetTextColor(0, 0, 0, 150)
                    surface.SetTextPos(-w / 2 + 2, 27)
                    surface.DrawText("×" .. ammo)

                    surface.SetTextColor(255, 255, 255, 255)
                    surface.SetTextPos(-w / 2, 25)
                    surface.DrawText("×" .. ammo)
                end
            cam.End3D2D()
        end
    end

end
--lua/entities/arccw_ammo_plinking.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_smg1.lua:
return gluapack()()
--lua/entities/arccw_gl_he_mw2/shared.lua:
return gluapack()()
--lua/entities/arccw_uc_40mm_incendiary.lua:
return gluapack()()
--addons/xenin-inventory/lua/entities/bank_npc/shared.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

ENT.Type = "anim"
ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.PrintName = "Bank NPC"
ENT.Author = "sleeppyy"
ENT.Category = "Xenin"
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetAutomaticFrameAdvance(bUsingAnim)
  self.AutomaticFrameAdvance = bUsingAnim
end

--lua/entities/base_streamradio_gui.lua:
AddCSLuaFile()
DEFINE_BASECLASS("base_streamradio")

local StreamRadioLib = StreamRadioLib

local LIBModel = StreamRadioLib.Model
local LIBSkin = StreamRadioLib.Skin
local LIBWire = StreamRadioLib.Wire
local LIBUtil = StreamRadioLib.Util

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminOnly = false

local ang_zero = Angle( )
local vec_zero = Vector( )

local g_isLoaded = StreamRadioLib and StreamRadioLib.Loaded
local g_isWiremodLoaded = g_isLoaded and LIBWire.HasWiremod()

local g_displayBuildTimer = 0

function ENT:SetScale(scale)
	self.Scale = scale or 0
end

function ENT:IsSeen()
	return SERVER or self.isseen
end

function ENT:GetScale()
	return self.Scale or 0
end

function ENT:SetDisplayPosAngOffset(pos, ang)
	self.DisplayPosOffset = pos
	self.DisplayPosAngles = ang
end

function ENT:GetDisplayPosAngOffset()
	return self.DisplayPosOffset, self.DisplayPosAngles
end

function ENT:CalcDisplayPosAngWorld()
	if self.DisplayLess then return end

	local pos = self:GetPos()
	local ang = self:GetAngles()

	local dpos, dang = LocalToWorld(self.DisplayPosOffset or vec_zero, self.DisplayPosAngles or ang_zero, pos, ang)

	self.DisplayPos = dpos
	self.DisplayAng = dang

	return dpos, dang
end

function ENT:CanControlInternal(ply, userEntity)
	if self.DisplayLess then return false end
	if self:GetDisableInput() then return false end

	local GUI = self.GUI

	if not IsValid(GUI) then
		return false
	end

	if not GUI:IsReady() then
		return false
	end

	-- Check the player for +use permission
	if not StreamRadioLib.CheckPropProtectionAgainstUse(self, ply) then
		return false
	end

	if userEntity:IsPlayer() then
		if not userEntity:Alive() then
			return false
		end

		if StreamRadioLib.IsGUIHidden(userEntity) then
			return false
		end

		if not self:OnGUIShowCheck(userEntity) then
			return false
		end
	end

	local scale = self:GetScale()
	if scale <= 0 then return false end

	local pos = self.DisplayPos
	if not pos then return false end

	local ang = self.DisplayAng
	if not ang then return false end

	local controlpos = StreamRadioLib.GetControlPosDir(userEntity)
	if not controlpos then return false end

	-- Return false if from the backside
	local a = controlpos - pos
	local b = ang:Up():Dot( a ) / a:Length()

	local displayVisAng = math.acos( b ) / math.pi * 180
	return displayVisAng < 90
end

function ENT:CanControl(ply, userEntity)
	if not g_isLoaded then return false end

	if not IsValid(ply) then return false end
	if not ply:IsPlayer() then return false end

	if not IsValid(userEntity) then
		userEntity = ply
	end

	local cacheId = tostring(ply) .. "_" .. tostring(userEntity)
	local now = RealTime()

	-- cache the check result for a short time to avoid running expensive functions every tick
	if self._canControlCacheExpire and self._canControlCacheExpire <= now then
		self._canControlCache = nil
		self._canControlCacheExpire = nil
	end

	if self._canControlCache and self._canControlCache[cacheId] ~= nil then
		return self._canControlCache[cacheId]
	end

	if not self._canControlCache then
		self._canControlCache = {}
		self._canControlCacheExpire = now + 0.25
	end

	local result = self:CanControlInternal(ply, userEntity)

	self._canControlCache[cacheId] = result
	return result
end

function ENT:CursorInGUI(cx, cy)
	if not IsValid(self.GUI) then return false end

	local px, py = self.GUI:GetAbsolutePos()
	return self.GUI:IsInBounds(cx - px, cy - py)
end

function ENT:GetCursor( ply, trace, userEntity )
	if not g_isLoaded then return false end

	if not IsValid(ply) then return false end
	if not ply:IsPlayer() then return false end

	if not IsValid(userEntity) then
		userEntity = ply
	end

	if not self:CanControl(ply, userEntity) then
		return false
	end

	if not trace then
		trace = StreamRadioLib.Trace(userEntity)
		if not trace or not trace.Hit then
			return false
		end
	end

	if not self:OnGUIInteractionCheck(ply, trace, userEntity) then
		return false
	end

	-- Ignore distances when we are using via an entity that is not a player
	if userEntity:IsPlayer() and not self:CheckDistanceToEntity(userEntity, self.MaxCursorTraceDist, trace.HitPos) then
		return false
	end

	local Cursor = trace.Entity == self

	if not Cursor then
		return false
	end

	local scale = self:GetScale()
	if scale <= 0 then return false end

	local pos = self.DisplayPos
	if not pos then return false end

	local ang = self.DisplayAng
	if not ang then return false end

	local TraceHitPos = util.IntersectRayWithPlane( trace.StartPos, trace.Normal, pos, ang:Up( ) )

	if not TraceHitPos then
		return false
	end

	local HitPos = WorldToLocal( TraceHitPos, ang_zero, pos, ang )
	local CursorX = math.Round( HitPos.x / scale )
	local CursorY = math.Round( -HitPos.y / scale )

	Cursor = self:CursorInGUI(CursorX, CursorY)

	if not Cursor then
		return false
	end

	return Cursor, CursorX, CursorY
end

function ENT:HasModelFunction(index)
	if not index then return false end

	local modalData = self.ModelData
	if not modalData then return false end

	local func = modalData[index]
	if not isfunction(func) then return false end

	return true
end

function ENT:GetModelFunction(index)
	if not index then return end

	local modalData = self.ModelData
	if not modalData then return end

	local func = modalData[index]
	if not isfunction(func) then return end

	return func
end

function ENT:CallModelFunction(index, ...)
	if not index then return end

	local modalData = self.ModelData
	if not modalData then return end

	local func = modalData[index]
	if not isfunction(func) then return end

	return func(modalData, self, ...)
end

function ENT:SetUpModel()
	if not g_isLoaded then return end
	if not IsValid(self.StreamObj) then return end
	if self._badModel then return end

	local model = self:GetModel()
	if not StreamRadioLib.Util.IsValidModel(model) then
		self._badModel = true
		return
	end

	self.ModelData = LIBModel.GetModelSettings(model) or {}
	local MD = self.ModelData

	self:CallModelFunction("Initialize", model)

	self:SetDisplayPosAngOffset(MD.DisplayOffset, MD.DisplayAngles)
	self:SetScale(MD.DisplayScale or 1)

	self.NoDisplay = MD.NoDisplay or false
	self.MaxCursorTraceDist = MD.MaxCursorTraceDist or 100

	if MD.Sounds then
		self.Sounds_Tune = MD.Sounds.Tune or self.Sounds_Tune
		self.Sounds_Noise = MD.Sounds.Noise or self.Sounds_Noise
		self.Sounds_Use = MD.Sounds.Use or self.Sounds_Use
	end

	self:SetSoundPosAngOffset(MD.SoundPosOffset, MD.SoundAngOffset)

	if self.OnModelSetup then
		self:OnModelSetup()
	end
end

function ENT:RemoveGui()
	local tmpGui = self.GUI
	local tmpGuiMain = self.GUI_Main

	local hasGui = IsValid(tmpGui)
	local hasGuiMain = IsValid(tmpGuiMain)

	if (hasGui or hasGuiMain) and self.OnGUIRemove then
		self:OnGUIRemove(tmpGui, tmpGuiMain)
	end

	self.GUI = nil
	self.GUI_Main = nil

	if hasGui then
		tmpGui.OnLoadDone = nil
		tmpGui.OnReady = nil
		tmpGui:Remove()
		tmpGui = nil
	end

	if hasGuiMain then
		tmpGuiMain:Remove()
		tmpGuiMain = nil
	end
end

function ENT:SetupGui(callback)
	if not IsValid(self.GUI) then
		self.GUI = StreamRadioLib.CreateOBJ("gui_controller")
	end

	local GUI = self.GUI

	GUI:SetName("gui")
	GUI:SetNWName("g")
	GUI:SetEntity(self)
	GUI:ActivateNetworkedMode()

	if SERVER and LIBUtil.IsDebug() then
		self:SetEnableDebug(true)
	end

	GUI:SetDebug(self:GetEnableDebug())

	if not IsValid(self.GUI_Main) then
		self.GUI_Main = GUI:AddPanelByClassname("radio/gui_main")
	end

	local GUI_Main = self.GUI_Main

	GUI_Main:SetPos(0, 0)
	GUI_Main:SetName("main")
	GUI_Main:SetNWName("m")
	GUI_Main:SetSkinIdentifyer("main")
	GUI_Main:SetStream(self.StreamObj)
	GUI_Main:SetHasPlaylist(self:GetHasPlaylist())

	GUI_Main.OnToolButtonClick = function(this)
		if not IsValid(self) then return end
		self:OnToolButtonClick()
	end

	GUI_Main.OnWireButtonClick = function(this)
		if not IsValid(self) then return end
		self:OnWireButtonClick()
	end

	GUI_Main.OnPlayerClosed = function(this)
		if not IsValid(self) then return end
		self:OnPlayerClosed()
	end

	GUI_Main.OnPlayerShown = function(this)
		if not IsValid(self) then return end
		self:OnPlayerShown()
	end

	GUI_Main.OnPlaylistClose = function(this)
		if not IsValid(self) then return end
		self:ClearPlaylist()
	end

	if SERVER then
		GUI_Main.OnPlaylistBack = function(this)
			if not IsValid(self) then return end
			self:PlayPreviousPlaylistItem()
		end

		GUI_Main.OnPlaylistForward = function(this)
			if not IsValid(self) then return end
			self:PlayNextPlaylistItem()
		end

		GUI_Main.OnPlaylistStartBuild = function(this)
			if not IsValid(self) then return end

			if self._dupePlaylistData then
				self:ReapplyPlaylistFromDupe()
				return
			end

			self:ClearPlaylist()
		end

		GUI_Main.OnPlaylistEndBuild = function(this, playlistItems)
			if not IsValid(self) then return end

			if self._dupePlaylistData then
				self:ReapplyPlaylistFromDupe()
				return
			end

			if not playlistItems then
				self:ClearPlaylist()
				return
			end

			self:SetPlaylist(playlistItems, 1)
		end

		GUI_Main.OnStop = function(this)
			if not IsValid(self) then return end

			self:StopStreamInternal()
		end

		GUI_Main.OnPlayItem = function(this, item)
			if not IsValid(self) then return end

			self:PlayFromPlaylistItem(item)
		end
	end

	local model = self:GetModel()
	self:CallModelFunction("InitializeFonts", model)
	self:CallModelFunction("SetupGUI", GUI, GUI_Main)

	GUI:SetSkin(LIBSkin.GetDefaultSkin())
	GUI:PerformRerender(true)

	GUI.OnReady = function()
		GUI.OnReady = nil

		local THIS_GUI = self.GUI
		local THIS_GUI_Main = self.GUI_Main

		if not IsValid(self) then
			return
		end

		if not IsValid(THIS_GUI) then
			return
		end

		if not IsValid(THIS_GUI_Main) then
			return
		end

		self:AddObjToNwRegister(THIS_GUI)
		self:CallModelFunction("OnGUIReady", GUI, GUI_Main)

		if self.OnGUIReady then
			self:OnGUIReady(THIS_GUI, THIS_GUI_Main)
		end
	end

	if self.OnGUISetup then
		self:OnGUISetup(GUI, GUI_Main)
	end
end

function ENT:StreamOnConnect(stream, channel, metadata)
	BaseClass.StreamOnConnect(self, stream, channel, metadata)
	self:CallModelFunction("OnPlay", stream)
	return true
end

function ENT:StreamOnSearch(stream)
	BaseClass.StreamOnSearch(self, stream)
	self:CallModelFunction("OnSearch", stream)
	return true
end

function ENT:StreamOnError(stream, err)
	BaseClass.StreamOnError(self, stream, err)
	self:CallModelFunction("OnError", stream, err)
end

function ENT:StreamOnClose(stream)
	BaseClass.StreamOnClose(self, stream)
	self:CallModelFunction("OnStop", stream)
end

function ENT:StreamOnTrackEnd(stream)
	self:CallModelFunction("OnTrackEnd", stream)
end

function ENT:HasGUI()
	if not IsValid(self.GUI) then
		return false
	end

	return true
end

function ENT:GetGUI()
	return self.GUI
end

function ENT:GetGUIMain()
	return self.GUI_Main
end

function ENT:PollGuiSetup()
	if self.DisplayLess then
		return
	end

	if self.GUI then
		return
	end

	-- delay the GUI rebuild in case many newly spawned radios are seen at once
	if SysTime() > g_displayBuildTimer then
		self:SetupGui()

		g_displayBuildTimer = SysTime() + 0.2
	end
end

function ENT:InternalThink()
	BaseClass.InternalThink(self)

	self.isseen = false
	self.DisplayLess = self.NoDisplay or self:GetDisableDisplay()

	if SERVER then
		self:PollGuiSetup()
	end
end

function ENT:InternalSlowThink()
	BaseClass.InternalSlowThink(self)

	self:PlaylistThink()
end

function ENT:NonDormantThink()
	BaseClass.NonDormantThink(self)

	if self:IsSeen() then
		self:ControlThink(self:GetLastUser(), self:GetLastUsingEntity())
	end
end

function ENT:ControlThink(ply, userEntity)
	local GUI = self.GUI

	if not IsValid(GUI) then
		return
	end

	local pos, ang = self:CalcDisplayPosAngWorld()

	if CLIENT and self:ShowDebug() then
		debugoverlay.Axis(pos, ang, 5, 0.05, color_white)
		debugoverlay.EntityTextAtPosition(pos, 1, "Display pos", 0.05, color_white)
	end

	if not IsValid(ply) then
		return
	end

	local Cursor, CursorX, CursorY = self:GetCursor(ply, nil, userEntity)

	if not Cursor then
		if GUI:GetCursor() ~= -1 then
			GUI:Click(false)
			GUI:SetCursor(-1, -1)
		end

		return
	end

	GUI:SetCursor(CursorX or -1, CursorY or -1)
end

function ENT:Control(ply, trace, pressed, userEntity)
	local GUI = self.GUI

	if not IsValid(GUI) then return end
	if not IsValid(ply) then return end

	if pressed then
		if not self:CanControl(ply, userEntity) then
			return
		end

		-- anti click spam
		local now = RealTime()

		if (now - (self._oldusetime or 0)) < 0.1 then
			return
		end

		self._oldusetime = now
	end

	local Cursor, CursorX, CursorY = self:GetCursor(ply, trace, userEntity)
	if not Cursor then
		if GUI:GetCursor() ~= -1 then
			GUI:Click(false)
			GUI:SetCursor(-1, -1)
		end

		return
	end

	GUI:SetCursor(CursorX or -1, CursorY or -1)
	GUI:Click(pressed)

	if SERVER and pressed then
		self:EmitSoundIfExist(self.Sounds_Use, 50, 100, 0.40, CHAN_ITEM)

		self:SetLastUser(ply)
		self:SetLastUsingEntity(userEntity)
	end
end

function ENT:SetupDataTables()
	if not g_isLoaded then return end
	BaseClass.SetupDataTables(self)

	self:AddDTNetworkVar( "Bool", "HasPlaylist" )

	self:AddDTNetworkVar( "Bool", "DisableDisplay", {
		KeyName = "DisableDisplay",
		Edit = {
			category = "GUI",
			title = "Disable display",
			type = "Boolean",
			order = 10
		}
	})

	self:AddDTNetworkVar( "Bool", "DisableInput", {
		KeyName = "DisableInput",
		Edit = {
			category = "GUI",
			title = "Disable user input",
			type = "Boolean",
			order = 11
		}
	})

	self:AddDTNetworkVar( "Bool", "DisableSpectrum", {
		KeyName = "DisableSpectrum",
		Edit = {
			category = "GUI",
			title = "Disable spectrum",
			type = "Boolean",
			order = 12
		}
	})

	self:AddDTNetworkVar( "Bool", "EnableDebug", {
		KeyName = "EnableDebug",
		Edit = {
			category = "GUI",
			title = "Show debug panel",
			type = "Boolean",
			order = 13
		}
	})

	self:SetDTVarCallback("EnableDebug", function(this, name, oldv, newv)
		if not IsValid(self.GUI) then return end
		self.GUI:SetDebug(newv)
	end)

	self:SetDTVarCallback("HasPlaylist", function(this, name, oldv, newv)
		if not IsValid(self.GUI_Main) then return end
		self.GUI_Main:SetHasPlaylist(newv)
	end)

	if CLIENT then
		self:SetDTVarCallback("DisableDisplay", function(this, name, oldv, newv)
			if newv then
				self:RemoveGui()
			end
		end)
	end
end

function ENT:AddItemToPlaylist(newItem)
	if CLIENT then return end

	local url = string.Trim(
		tostring(
			newItem.url or
			newItem.uri or
			newItem.link or
			newItem.source or
			newItem.path or ""
		)
	)

	local name = string.Trim(
		tostring(
			newItem.name or
			newItem.title or ""
		)
	)

	if url == "" then
		return
	end

	if name == "" then
		name = url
	end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	local index = #data + 1

	local entry = {
		name = name,
		url = url,
		index = index,
	}

	data[index] = entry

	self._updatedPlaylist = true
	self._nextPlaylistSwitch = nil

	if index > 1 then
		self:SetHasPlaylist(true)
	end
end

function ENT:AddItemsToPlaylist(newItems)
	if CLIENT then return end

	for i, newItem in ipairs(newItems) do
		self:AddItemToPlaylist(newItem)
	end
end

function ENT:SetPlaylist(playlist, pos)
	if CLIENT then return end

	if not pos then
		pos = 1
	end

	self:ClearPlaylist()
	self:AddItemsToPlaylist(playlist)

	local playlistObj = self.PlaylistData
	playlistObj.pos = math.Clamp(pos or 1, 1, #playlistObj.data)
end

function ENT:ClearPlaylist()
	if CLIENT then return end

	local playlistObj = self.PlaylistData

	StreamRadioLib.Util.EmptyTableSafe(playlistObj.data)
	playlistObj.pos = 0

	self._updatedPlaylist = true
	self._nextPlaylistSwitch = nil

	self:SetHasPlaylist(false)
end

function ENT:HasPlaylistInternal()
	if CLIENT then
		return false
	end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	if #data <= 1 then
		return false
	end

	return true
end

function ENT:PlayPreviousPlaylistItem()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	local len = #data
	if len <= 1 then return end

	local index = playlistObj.pos - 1
	if index <= 0 then
		index = len
	end

	index = math.Clamp(index, 1, len)

	local playlistItem = data[index]
	self:PlayFromPlaylistItem(playlistItem)
end

function ENT:PlayNextPlaylistItem()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	local len = #data
	if len <= 1 then return end

	local index = playlistObj.pos + 1
	if index > len then
		index = 1
	end

	index = math.Clamp(index, 1, len)

	local playlistItem = data[index]
	self:PlayFromPlaylistItem(playlistItem)
end

function ENT:PlayFromPlaylistItemByIndex(index)
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	index = math.Clamp(index or 1, 1, #data)

	local playlistItem = data[index]
	if not playlistItem then return end

	self:PlayFromPlaylistItem(playlistItem)
end

function ENT:PlayFromCurrentPlaylistItem()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	self:PlayFromPlaylistItemByIndex(playlistObj.pos or 1)
end

function ENT:PlayFromPlaylistItem(playlistItem)
	if CLIENT then return end
	if not playlistItem then return end

	local now = RealTime()
	if self._nextPlaylistSwitch and self._nextPlaylistSwitch > now then
		-- Prevent playlist abuse/spam
		return
	end

	local url = playlistItem.url
	local name = playlistItem.name

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	playlistObj.pos = math.Clamp(playlistItem.index or 1, 1, #data)
	self:PlayStreamInternal(url, name)

	self._nextPlaylistSwitch = now + 0.25
end

function ENT:GetPlaylist()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	return data
end

function ENT:GetPlaylistPos()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local pos = playlistObj.pos or 1

	return pos
end

function ENT:PlaylistThink()
	if CLIENT then return end

	if not self._updatedPlaylist then return end
	self._updatedPlaylist = nil

	self:SetHasPlaylist(self:HasPlaylistInternal())

	self:OnPlaylistChanged()
end

function ENT:Initialize()
	BaseClass.Initialize(self)

	if SERVER then
		self.PlaylistData = {
			data = {},
			pos = 0,
		}

		self:ClearPlaylist()
	end

	self:SetUpModel()
end

function ENT:OnRemove()
	self:CallModelFunction("OnRemove", model)
	self:RemoveGui()
	self:ClearPlaylist()

	BaseClass.OnRemove(self)
end

function ENT:OnToolButtonClick()
	-- Override me
end

function ENT:OnWireButtonClick()
	-- Override me
end

function ENT:OnPlaylistChanged()
	-- Override me
end

function ENT:OnPlayerClosed()
	-- Override me
end

function ENT:OnPlayerShown()
	-- Override me
end

function ENT:OnModelSetup()
	-- Override me
end

function ENT:OnGUIReady()
	if CLIENT then return end

	if self._postClasssystemPasteLoadDupeOnGUIReady then
		self:ReapplyClasssystemPaste()
	end

	if self._dupePlaylistData then
		self:ReapplyPlaylistFromDupe()
	end
end

function ENT:OnGUISetup(GUI, GUI_Main)
	-- Override me
end

function ENT:OnGUIRemove()
	-- Override me
end

function ENT:OnGUIShowCheck(ply)
	-- Override me
	return true
end

function ENT:OnGUIInteractionCheck(ply, trace, userEntity)
	-- Override me
	return true
end

if CLIENT then
	function ENT:CanSeeDisplay()
		if not g_isLoaded then return false end

		if self._cacheCanSeeDisplay ~= nil then
			return self._cacheCanSeeDisplay
		end

		self._cacheCanSeeDisplay = false

		if self.DisplayLess then return false end

		local ply = LocalPlayer()
		if StreamRadioLib.IsGUIHidden(ply) then return false end
		if not self:OnGUIShowCheck(ply) then return false end
		local scale = self:GetScale()
		if scale <= 0 then return false end

		local pos = self.DisplayPos
		if not pos then return false end

		local ang = self.DisplayAng
		if not ang then return false end

		local campos = StreamRadioLib.GetCameraViewPos(ply)
		if not campos then return false end

		-- Return false if from the backside
		local a = campos - pos
		local b = ang:Up():Dot( a ) / a:Length()

		local displayVisAng = math.acos( b ) / math.pi * 180
		local isSeen = displayVisAng < 90

		if not isSeen then return false end

		self._cacheCanSeeDisplay = true
		return true
	end

	function ENT:GetCursorFromLastUser()
		if not g_isLoaded then return false end

		local lastUser = self:GetLastUser()
		local userEntity = self:GetLastUsingEntity()

		if not IsValid(lastUser) then
			lastUser = LocalPlayer()
		end

		if not IsValid(userEntity) then
			userEntity = lastUser
		end

		return self:GetCursor(lastUser, nil, userEntity)
	end

	function ENT:ShouldRemoveGUI()
		if self.DisplayLess then
			return true
		end

		local ply = LocalPlayer()
		if StreamRadioLib.IsGUIHidden(ply) then
			return true
		end

		return false
	end

	function ENT:DrawGUI()
		if not g_isLoaded then return end

		self._cacheCanSeeDisplay = nil
		self._cacheCanDrawSpectrum = nil

		if self:ShouldRemoveGUI() then
			if self.GUI then
				self:RemoveGui()
			end

			return
		end

		local ply = LocalPlayer()
		if not self:CheckDistanceToEntity(ply, StreamRadioLib.GetDrawDistance(), nil, StreamRadioLib.GetCameraViewPos(ply)) then
			return
		end

		self:PollGuiSetup()

		local GUI = self.GUI

		if not IsValid(GUI) then
			return
		end

		local pos, ang = self:CalcDisplayPosAngWorld()
		if not pos then
			return
		end

		if not ang then
			return
		end

		if not self:CanSeeDisplay() then
			return
		end

		local lastUser = self:GetLastUsingEntity()
		local scale = self:GetScale()

		local Cursor, CursorX, CursorY = self:GetCursorFromLastUser()

		local col = self:GetColor()
		GUI:SetAllowCursor(StreamRadioLib.IsCursorEnabled())
		GUI:SetDrawAlpha(col.a / 255)

		if Cursor or not IsValid(lastUser) then
			GUI:SetCursor(CursorX or -1, CursorY or -1)
		end

		cam.Start3D2D( pos, ang, scale )
			GUI:RenderSystem()
		cam.End3D2D( )
	end

	function ENT:DrawTranslucent(...)
		BaseClass.DrawTranslucent(self, ...)
		self.isseen = true
		self:DrawGUI()
	end

	function ENT:CanDrawSpectrum()
		if not g_isLoaded then return false end

		if self._cacheCanDrawSpectrum ~= nil then
			return self._cacheCanDrawSpectrum
		end

		self._cacheCanDrawSpectrum = false

		if not IsValid(self.GUI) then return false end

		if StreamRadioLib.IsSpectrumHidden() then return false end
		if self:GetDisableSpectrum() then return false end

		if not self:CanSeeDisplay() then return false end

		local ply = LocalPlayer()
		if not self:CheckDistanceToEntity(ply, StreamRadioLib.GetSpectrumDistance(), nil, StreamRadioLib.GetCameraViewPos(ply)) then return false end

		self._cacheCanDrawSpectrum = true
		return true
	end
else
	function ENT:Use(activator, ...)
		if not g_isWiremodLoaded then return false end

		local GUI = self.GUI

		if not IsValid(GUI) then
			return false
		end

		if not GUI:IsReady() then
			return false
		end

		if not IsValid(activator) then
			return false
		end

		if not activator:IsPlayer() then
			return false
		end

		local data = LIBWire.FindCallingWireUserEntityData()
		if not data then
			return false
		end

		local now = RealTime()

		if (now - (self._oldwireusetime or 0)) < 0.1 then
			return false
		end

		self._oldwireusetime = now

		StreamRadioLib.TabControl(activator, data.trace, data.userEntity)
		return true
	end

	function ENT:ReapplyPlaylistFromDupe()
		-- Reapply the duped playlist data once.
		-- This is needed, because gui would override it on creation, which is not wanted.

		local timerId = "KillDupePlaylist_" .. tostring(self)
		StreamRadioLib.Timer.Remove(timerId)

		if self.DisplayLess then
			self._dupePlaylistData = nil
			return
		end

		local playlist = self._dupePlaylistData
		if not playlist then
			return
		end

		StreamRadioLib.Timer.Once(timerId, 1, function()
			if not IsValid(self) then
				return
			end

			-- Remove the list data late to avoid any race conditions
			self._dupePlaylistData = nil
		end)

		local data = playlist.data
		if not data then return end

		local pos = playlist.pos or 1

		self:SetPlaylist(data, pos)
	end

	function ENT:OnSetupCopyData(data)
		BaseClass.OnPreEntityCopy(self, data)

		data.GUI = nil
		data.GUI_Main = nil
		data.PlaylistData = nil
	end

	function ENT:OnPreEntityCopy()
		BaseClass.OnPreEntityCopy(self)

		self:SetDupeData("PlaylistData", self.PlaylistData)
	end

	function ENT:DupeDataApply(key, value)
		BaseClass.DupeDataApply(self, key, value)

		if key ~= "PlaylistData" then return end

		local data = value.data
		if not data then return end

		local pos = value.pos or 1

		self:SetPlaylist(data, pos)

		if self.DisplayLess then
			self._dupePlaylistData = nil
			return
		end

		self._dupePlaylistData = value
	end

	function ENT:PostClasssystemPaste(data)
		if not IsValid(self.StreamObj) then
			return
		end

		if not self._postClasssystemPasteBaseCalled then
			BaseClass.PostClasssystemPaste(self, data)
			self._postClasssystemPasteBaseCalled = true
		end

		if self.DisplayLess then
			return
		end

		if not IsValid(self.GUI) then
			self._postClasssystemPasteLoadDupeOnGUIReady = true
			return
		end

		if self.GUI:IsLoading() then
			self._postClasssystemPasteLoadDupeOnGUIReady = true
			return
		end

		self._postClasssystemPasteLoadDupeOnGUIReady = nil
		self.GUI:LoadFromDupe(data)
	end

	function ENT:PreClasssystemCopy(data)
		BaseClass.PreClasssystemCopy(self, data)

		if IsValid(self.GUI) then
			self.GUI:LoadToDupe(data)
		end
	end
end

--addons/[binbon]misc/lua/entities/bb_perk_npc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
  self:DrawModel()
  if not binbonentdraw then return end
  binbonentdraw(self, "Yetenekçi", true, 0, 10, 20, true)
  binbonentdraw(self, "Seviye yeteneklerini buradan düzenleyebilirsin.", false, 0,100, 20, false)

end
--addons/[binbon]misc/lua/entities/bb_perk_npc/shared.lua:
return gluapack()()
--addons/bodygroupr/lua/entities/bodyman_closet/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/bufe/shared.lua:
return gluapack()()
--addons/ch_atm/lua/entities/ch_atm_card_scanner/cl_init.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_bitcoin_screen/cl_init.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_bitcoin_screen/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
end

local color_green = Color( 0, 125, 0, 255 )
local color_orange = Color( 240, 137, 19, 255 )

local color_icon = Color( 100, 100, 100, 150 )
local bitcoin_icon = Material( "craphead_scripts/bitminers/bitcoin.png" )

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr( LocalPlayer():GetPos() ) > 3000000 then
		return
	end
	
	self:DrawModel()
	
	local Pos = self:GetPos()
	local Ang = self:GetAngles()
	
	Ang:RotateAroundAxis( Ang:Forward(), 90 )
	Ang:RotateAroundAxis( Ang:Right(), 180 )
	
	local bitcoin_rate = 0
	
	if CH_Bitminers.Config.IntegrateCryptoCurrencies then
		if CH_CryptoCurrencies then
			if CH_CryptoCurrencies.CryptosCL[ CH_Bitminers.CryptoBTCIndexCL ] then
				bitcoin_rate = CH_CryptoCurrencies.CryptosCL[ CH_Bitminers.CryptoBTCIndexCL ].Price
			end
		end
	else
		bitcoin_rate = CH_Bitminers.Config.BitcoinRate
	end
	
	cam.Start3D2D( Pos + Ang:Up() * 0.5, Ang, 0.1 )		
		surface.SetDrawColor( color_icon )
		surface.SetMaterial( bitcoin_icon )
		surface.DrawTexturedRect( -256, -300, 512, 512 )

		-- Text
		draw.DrawText( DarkRP.formatMoney( bitcoin_rate ), "BITMINER_RateScreenText", 0, -200, color_green, TEXT_ALIGN_CENTER )
		
		draw.DrawText( CH_Bitminers.LangString( "Bitcoin Price" ), "BITMINER_RateScreenText", 0, -80, color_orange, TEXT_ALIGN_CENTER )
	cam.End3D2D()
end
--addons/ch_bitminers_dlc/lua/entities/ch_bitminer_hacking_usb/cl_init.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_power_solar/cl_init.lua:
include( "shared.lua" )

local col_bg = Color( 60, 60, 60, 200 )
local col_dirt = Color( 102, 51, 0, 200 )

function ENT:DrawTranslucent()
	self:DrawModel()
	
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) >= CH_Bitminers.Config.ShowDirt3D2D then
		return
	end
	
	local Pos = self:GetPos()
	Pos = Pos + self:GetUp() * 38 + self:GetForward() * -12
	
	local Ang = self:GetAngles()

	Ang:RotateAroundAxis( Ang:Forward(), 90 )
	Ang:RotateAroundAxis( Ang:Right(), -90 )

	cam.Start3D2D( Pos, Ang, 0.015 )
		draw.SimpleText( CH_Bitminers.LangString( "Dirt" ) .." - ".. self:GetDirtAmount() .."%", "BITMINER_ScreenText30b", 350, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.RoundedBox( 12, -150, 100, 1000, 150, col_bg )
		
		draw.RoundedBox( 12, -150, 100, self:GetDirtAmount() * 10, 150, col_dirt )
	cam.End3D2D()
end
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_clean_dirt/shared.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_cooling2/cl_init.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_ups/cl_init.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_trashcan/cl_init.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_vault/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Mayor Vault"
ENT.Author = "Crap-Head"
ENT.Category = "Mayor by Crap-Head"

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true
--addons/cityworker/lua/entities/cityworker_electric/shared.lua:
return gluapack()()
--addons/cityworker/lua/entities/cityworker_hydrant/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
    self.emitter = ParticleEmitter( self:GetPos() )

    self.nextEmit = 0

    self.sound = CreateSound( self, "ambient/water/water_flow_loop1.wav" )
    self.sound:SetSoundLevel( 60 )
    --self.sound:Play()
end

function ENT:OnRemove()
    self.sound:Stop()
end

function ENT:Think()
    if self:GetLeaking() then
        if not self.sound:IsPlaying() then
            self.sound:Play()
        end

        if LocalPlayer():GetPos():Distance( self:GetPos() ) <= 2048 then
            if CurTime() > self.nextEmit then
                local v = Vector( 0, 70, 550 )
                v:Rotate( self:GetAngles() )

                -- 2 ^ math.random( 0, 2 ) because we want only 1, 2, and 4 lmao
                local water = self.emitter:Add( "effects/splash"..2 ^ math.random( 0, 2 ), self:LocalToWorld( Vector( 0, 0, 35 ) ) )
                water:SetVelocity( v )
                water:SetDieTime( 2 )
                water:SetStartAlpha( 200 )
                water:SetEndAlpha( 50 )
                water:SetAngles( AngleRand() )
                water:SetStartSize( 10 )
                water:SetEndSize( 50 )
                water:SetGravity( Vector( 0, 0, -600 ) )
                water:SetColor( 255, 255, 255 )
                water:SetAirResistance( 0 )

                self.nextEmit = CurTime() + 0.02
            end
        end
    else
        if self.sound:IsPlaying() then
            self.sound:Stop()
        end
    end

    self:DrawModel()
end
--addons/cityworker/lua/entities/cityworker_rubble/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/corba/cl_init.lua:
return gluapack()()
--gamemodes/darkrp/entities/entities/darkrp_tip_jar/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/gazoz/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--addons/ledscreen/lua/entities/gb_rp_sign_wire/shared.lua:
return gluapack()()
--addons/glicence/lua/entities/glicence_npc/cl_init.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/entities/glorifiedhandcuffs_bailnpc/shared.lua:

ENT.Type = "ai"
ENT.Base = "base_ai"

ENT.PrintName		= "Bail NPC"
ENT.Author			= "GlorifiedPig"
ENT.Category        = "GlorifiedHandcuffs"
ENT.Spawnable       = true

--addons/turkish_food_mod-main/lua/entities/hosbes/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--addons/turkish_food_mod-main/lua/entities/kofte_stand/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Çiğköfte Tezgahı"
ENT.Category = "Turkish Food Mod Tezgahlar"
ENT.Spawnable = true

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
end
--addons/turkish_food_mod-main/lua/entities/kulah/shared.lua:
return gluapack()()
--gamemodes/darkrp/entities/entities/letter/cl_init.lua:
return gluapack()()
--lua/entities/light_armor/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Light Armor"
ENT.Category = "improved Armor"
ENT.Author = "LunkLoafGrumble"
ENT.Contact = ""
ENT.Purpose = "Gives body protection."
ENT.Instructions = "Press E to apply."
ENT.Spawnable = true
ENT.AdminSpawnable = false
--lua/entities/light_armor_stackable/cl_init.lua:
return gluapack()()
--lua/entities/light_armor_stackable/shared.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/entities/mediaplayer_base/shared.lua:
return gluapack()()
--lua/entities/medium_armor/shared.lua:
return gluapack()()
--lua/entities/medium_armor_stackable/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Medium Armor Stackable"
ENT.Category = "improved Armor"
ENT.Author = "LunkLoafGrumble"
ENT.Contact = ""
ENT.Purpose = "Gives body protection."
ENT.Instructions = "Press E to apply."
ENT.Spawnable = true
ENT.AdminSpawnable = false
--addons/minigame-tool-assistant/lua/entities/minigame_square.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/nohutlu_pilav/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--addons/turkish_food_mod-main/lua/entities/nohutlu_pilav/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Nohutlu Pilav"
ENT.Category = "Turkish Food Mod"
ENT.Spawnable = true
--addons/mayor_voting/lua/entities/npc_mayorvoting/cl_init.lua:
return gluapack()()
--addons/oneprint/lua/entities/oneprint/cl_init.lua:
return gluapack()()
--addons/oneprint/lua/entities/oneprint/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/patkof/cl_init.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_mystery_wheel/shared.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_roulette_table/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/pilav_stand/cl_init.lua:
include("shared.lua")
include("tfm_config.lua")

local tfm_colors = {
    ["white"] = Color(255, 255, 255),
    ["white_fade"] = Color(255, 255, 255, 200),
    ["black"] = Color(0, 0, 0),
    ["black_fade"] = Color(0, 0, 0, 200),
}

local function TFM_PILAV_UI(button_sound,stand)
    local pilav_menu = vgui.Create("DPanel")
    local scrw, scrh = ScrW(), ScrH()
    pilav_menu:SetSize(scrw / 4, scrh / 4)
    pilav_menu:Center()
    pilav_menu:MakePopup()

    pilav_menu.Paint = function(self, w, h)
        draw.RoundedBox(8,0,0,w,h,Color(63, 36, 36))
    end

    local close_pilav_menu = vgui.Create("DButton", pilav_menu)
    close_pilav_menu:SetSize(scrw * 0.02, scrh * 0.02)
    close_pilav_menu:SetPos(scrw * 0.22, scrh * 0.01)
    close_pilav_menu:SetColor(tfm_colors["white"])
    close_pilav_menu:SetText("x")

    close_pilav_menu.DoClick = function()
        pilav_menu:Remove()
        button_sound:Play()
    end

    close_pilav_menu.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(255, 255, 255, 255))
            draw.RoundedBox(6,0,0,w,h,Color(168, 36, 36))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(6,0,0,w,h,Color(92, 51, 51))
        end
    end

    local report_btn = vgui.Create("DButton", pilav_menu)
    report_btn:SetSize(scrw * 0.05, scrh * 0.04)
    report_btn:SetPos(scrw * 0.01, scrh * 0.01)
    report_btn:SetText("Hata Bildir")

    report_btn.DoClick = function()
        pilav_menu:Remove()
        button_sound:Play()
        gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=2073492700")
    end

    report_btn.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(255, 255, 255, 255))
            draw.RoundedBox(6,0,0,w,h,Color(255, 215, 128))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(6,0,0,w,h,Color(92, 51, 51))
        end
    end

    local sade_buy = vgui.Create("DButton", pilav_menu)
    sade_buy:SetSize(scrw / 10, scrh / 20)
    sade_buy:SetPos(scrw * 0.08, scrh * 0.04)
    sade_buy:SetColor(tfm_colors["white"])
    sade_buy:SetText("Sade Pilav")

    sade_buy.DoClick = function()
        net.Start("tfm_pilav_network")
        net.WriteEntity(stand)
        net.WriteUInt(1,3)
        net.WriteEntity(stand)
        net.SendToServer()
        button_sound:Play()
        pilav_menu:Remove()
    end

    sade_buy.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(146, 146, 146))
            draw.RoundedBox(6,0,0,w,h,Color(255, 234, 190))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(6,0,0,w,h,Color(92, 51, 51))
        end
    end

    local nohutlu_pilav = vgui.Create("DButton", pilav_menu)
    nohutlu_pilav:SetSize(scrw / 10, scrh / 20)
    nohutlu_pilav:SetPos(scrw * 0.08, scrh * 0.1)
    nohutlu_pilav:SetColor(tfm_colors["white"])
    nohutlu_pilav:SetText("Nohutlu Pilav")

    nohutlu_pilav.DoClick = function()
        net.Start("tfm_pilav_network")
        net.WriteEntity(stand)
        net.WriteUInt(2,3)
        net.WriteEntity(stand)
        net.SendToServer()
        button_sound:Play()
        pilav_menu:Remove()
    end

    nohutlu_pilav.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(146, 146, 146))
            draw.RoundedBox(6,0,0,w,h,Color(255, 234, 190))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(6,0,0,w,h,Color(92, 51, 51))
        end
    end

    local tavuklu_pilav = vgui.Create("DButton", pilav_menu)
    tavuklu_pilav:SetSize(scrw / 10, scrh / 20)
    tavuklu_pilav:SetPos(scrw * 0.08, scrh * 0.16)
    tavuklu_pilav:SetColor(tfm_colors["white"])
    tavuklu_pilav:SetText("Tavuklu Pilav")

    tavuklu_pilav.DoClick = function()
        net.Start("tfm_pilav_network")
        net.WriteEntity(stand)
        net.WriteUInt(3,3)
        net.WriteEntity(stand)
        net.SendToServer()
        button_sound:Play()
        pilav_menu:Remove()
    end

    tavuklu_pilav.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(146, 146, 146))
            draw.RoundedBox(6,0,0,w,h,Color(255, 234, 190))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(6,0,0,w,h,Color(92, 51, 51))
        end
    end
end

function ENT:Initialize()
    self.start = false
    self.delay = 0
    self.cache = 0
    self.n = TFM.Stands["pilav_stand"].time_of_pilavs or 15
    self.icecreem_name = "ERROR"
end

net.Receive("tfm_pilav_network", function(len, pl)
    local stand = net.ReadEntity()
    local read_pilav_flag = net.ReadUInt(3)
    local read_pilav_name = net.ReadUInt(3)
    if read_pilav_flag == 1 then
        local button_sound = CreateSound(LocalPlayer(), Sound("fm_button1.wav"))
        TFM_PILAV_UI(button_sound,stand)
    elseif read_pilav_flag == 2 and read_pilav_name then
        stand.pilav_name = TFM.Stands["pilav_stand"].info_of_pilavs[read_pilav_name].name
        stand.start = true
        stand.cache = CurTime() + stand.n
    elseif read_pilav_flag >= 2 and read_pilav_flag <= 5 then
        stand.start = false
        stand.delay = 0
    end
end)
local drawroundedboxcolor_cache, drawsimpletextcolor_cache = Color(0, 0, 0, 200), Color(255, 255, 255)
function ENT:Draw()
    self:DrawModel()
    if self.start then
        if self.delay > self.cache then return end
        self.delay = CurTime() + 1
        local mathdelay = math.Round(self.cache - self.delay) 
        local ang, scrw, scrh = LocalPlayer():EyeAngles(), ScrW(), ScrH()
        ang = Angle(0, ang.y, 0)
        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)
        cam.Start3D2D(self:WorldSpaceCenter(), ang, 0.1)
        draw.RoundedBox(10, scrw - 1600, scrh - 1500, scrw * 0.4, scrh * 0.2, drawroundedboxcolor_cache)
        draw.SimpleText(self.pilav_name .. " Pilav Hazırlanıyor... " .. mathdelay .. " saniye", "ice-stand_f1", scrw - 1350, scrh - 1450, drawsimpletextcolor_cache, 1, 1)
        draw.RoundedBox(10, scrw - 1580, scrh - 1400,mathdelay * (510 / self.n), scrh * 0.05, tfm_colors["white"])
        cam.End3D2D()
    end
end

function ENT:OnRemove()
    self.delay = 0
end

--addons/turkish_food_mod-main/lua/entities/pilav_stand/shared.lua:
return gluapack()()
--addons/realisticcardealer/lua/entities/rcd_paper/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()    
end
--addons/realisticcardealer/lua/entities/rcd_showcase/cl_init.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/entities/s_keypad/cl_init.lua:
include("shared.lua")

local keycardMat = Material("skeypad/mdl_keycard.png", "noclamp smooth")
local logo_col = Color(200,200,200)

local function drawHandeling(ent)
	if !sKeypad then return end
	
	if ent:GetBodygroup(2) == 0 then
		sKeypad.DrawKeypad(ent)
	end
	
	sKeypad.DrawScreen(ent)

	if ent:GetBodygroup(2) == 2 then
		local pos = ent:LocalToWorld(Vector(1.164121, 0.010070, -2.142578))
		local ang = ent:LocalToWorldAngles(Angle(90,0,0))
		local size = 158
	
		cam.Start3D2D(pos, ang, .03)
			surface.SetDrawColor(logo_col)
			surface.SetMaterial(keycardMat)
			surface.DrawTexturedRect(-(size * .5),-(size * .5),size,size)
		cam.End3D2D()
	end
end

function ENT:GetHoveredElement()
	return false
end

function ENT:Draw()
	if util.IsValidModel("models/sterling/stromic_skeypad.mdl") then
		self:DrawModel()
	else
		local pos, ang, mins, maxs = self:GetPos(), self:GetAngles(), self:OBBMins(), self:OBBMaxs()
		if !pos or !ang or !mins or !maxs then return end
		render.DrawBox(pos, ang, mins, maxs - Vector(.25,0,0), color_white)
	end

	drawHandeling(self)
end
--addons/serious_business/lua/entities/sb_crime_guide/cl_init.lua:
return gluapack()()
--lua/entities/sent_streamradio/cl_init.lua:
return gluapack()()
--lua/entities/sv_repair/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/tavuklu_pilav/shared.lua:
return gluapack()()
--lua/entities/used_bomonti.lua:
return gluapack()()
--lua/entities/used_efes.lua:
return gluapack()()
--addons/xenin-coinflip/lua/entities/xenin_coinflip_npc/shared.lua:
return gluapack()()
--addons/xenin-coinflip/lua/entities/xenin_coinflip_npc/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.PrintName = "Coinflip NPC"
ENT.Author = "sleeppyy"
ENT.Category = "Xenin"
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetAutomaticFrameAdvance(bUsingAnim)
	self.AutomaticFrameAdvance = bUsingAnim
end
--addons/zerosfruitslicer/lua/entities/zfs_fruitbox/cl_init.lua:
include("shared.lua")

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Draw()
	self:DrawModel()
	zfs.Fruitbox.Draw(self)
end

--addons/zerosfruitslicer/lua/entities/zfs_mixer.lua:
return gluapack()()
--addons/zerosfruitslicer/lua/entities/zfs_shop/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_backpack_ent/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_crate/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_dryline/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_dryline/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Dryline"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_dryline.mdl"
ENT.RenderGroup             = RENDERGROUP_BOTH
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

function ENT:SetupDataTables()
	self:NetworkVar("Vector", 0, "EndPoint")
	self:NetworkVar("Angle", 0, "WallAngle")
	self:NetworkVar("Angle", 1, "WallEndAngle")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a

	if SERVER then
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

		self:SetEndPoint(self:GetPos())
		timer.Simple(0.5,function() if IsValid(self) then self:SetEndPoint(self:GetPos()) end end)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

		self:SetWallAngle(angle_zero)
		self:SetWallEndAngle(angle_zero)
	end
end

function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end

function ENT:CanDrive(ply)
    return false
end

function ENT:GravGunPickupAllowed( ply )
	return false
end

function ENT:GravGunPunt( ply )
	return false
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_jarcrate.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_palette.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zgo2_item_base")
ENT.Type                    = "anim"
ENT.Base                    = "zgo2_item_base"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Palette"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_palette.mdl"
ENT.RenderGroup             = RENDERGROUP_BOTH

function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end

function ENT:CanDrive(ply)
    return false
end

if SERVER then
	function ENT:Initialize()
		zgo2.Palette.Initialize(self)
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

	function ENT:OnRemove()
		zgo2.Palette.OnRemove(self)
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

	function ENT:AcceptInput(inputName, activator, caller, data)
		if inputName == "Use" and IsValid(activator) and activator:IsPlayer() and activator:Alive() then
			zgo2.Palette.OnUse(self, activator)
		end
	end

	function ENT:StartTouch(other)
		zgo2.Palette.OnStartTouch(self, other)
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

	function ENT:UpdateTransmitState()
		return TRANSMIT_ALWAYS
	end
else
	function ENT:Initialize()
		zgo2.Palette.Initialize(self)
	end

	function ENT:Draw()
		self:DrawModel()
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

	function ENT:OnRemove()
		zgo2.Palette.OnRemove(self)
	end

	function ENT:Think()
		zgo2.Palette.Think(self)
	end
end

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_rack/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_seedlibary/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_seedlibary/cl_init.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:Draw()
	self:DrawModel()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

--addons/zeros_golddiggger/lua/entities/zgw_lantern/shared.lua:


ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.AutomaticFrameAdvance = true
ENT.Model = "models/zerochain/props_goldwash/zgw_lantern.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Lantern"
ENT.Category = "Zeros GoldWasher"
ENT.RenderGroup = RENDERGROUP_OPAQUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f6df0a94af3a750a3d331a6881d44d3c6811e6ae1489523704d95e9e8195831d

function ENT:SetupDataTables()
    self:NetworkVar("Int", 1, "Gold")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 0a5818b862f942a32f280da19656bfe6fb14cbd620f4eff776b06ce3fb51fd0e
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f6df0a94af3a750a3d331a6881d44d3c6811e6ae1489523704d95e9e8195831d

    if (SERVER) then
        self:SetGold(0)
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198872838622
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 549ca24f37f8589f265ca557954c28b4325c41edf21ed3859b40baf576d8adf4

--addons/zeros_golddiggger/lua/entities/zgw_pumphead/shared.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_dropoff/shared.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_dropoff.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "DropOff"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE

function ENT:SetupDataTables()
    self:NetworkVar("Bool", 1, "IsClosed")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

    if (SERVER) then
        self:SetIsClosed(true)
    end
end

function ENT:GravGunPunt()
	return false
end
function ENT:GravGunPickupAllowed()
	return false
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

function ENT:CanProperty(ply)
    return zclib.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:CanDrive(ply)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_equipment/cl_init.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	zmlab2.Equipment.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea

function ENT:Draw()
	self:DrawModel()
	zmlab2.Equipment.DrawUI(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- ce15eec833bf47ebbcf6161ad127d2657901fd54a4bc9d5aa5fcda90913684bc

function ENT:OnRemove()
	zmlab2.Equipment.OnRemove(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_machine_filler/cl_init.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_npc/shared.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.AutomaticFrameAdvance = true
ENT.Model = "models/Humans/Group03/male_07.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "NPC"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_BOTH
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_tent_door/cl_init.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_aluminium/cl_init.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_combiner/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

	self.LastStage = 1
	self.HasFilter = false
	self.HasTray = false

	self.LastMethSludge = 0

	self.stageinfo = {
		[1] = zmlab.language.combiner_step01,
		[2] = zmlab.language.combiner_step02,
		[3] = zmlab.language.combiner_step03,
		[4] = zmlab.language.combiner_step04,
		[5] = zmlab.language.combiner_step05,
		[6] = zmlab.language.combiner_step06,
		[7] = zmlab.language.combiner_step07,
		[8] = zmlab.language.combiner_step08
	}
end

// Draw
function ENT:Draw()
	self:DrawModel()

	if zmlab.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then
		self:DrawInfo()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end

// UI
function ENT:DrawInfo()

	cam.Start3D2D(self:LocalToWorld(Vector(0,64.1,59.2)), self:LocalToWorldAngles(Angle(180,0,-75)), 0.05)
		// BG
		draw.RoundedBox(3, -380, -200, 760, 400, zmlab.default_colors["black01"])
		draw.RoundedBox(0, -380, -100, 760, 5, zmlab.default_colors["grey01"])
		draw.RoundedBox(0, -380, 13, 760, 5, zmlab.default_colors["grey01"])

		// NextStep Text
		draw.DrawText(zmlab.language.combiner_nextstep, "zmlab_nextstep", -350, -90, zmlab.default_colors["white01"], TEXT_ALIGN_LEFT)

		if self.LastStage and self.stageinfo[self.LastStage] then
			draw.DrawText(self.stageinfo[self.LastStage], "zmlab_font_info", -80, -88, zmlab.default_colors["yellow01"], TEXT_ALIGN_LEFT)
		end

		if self.LastStage == 3 then
			draw.DrawText(zmlab.language.aluminium .. ": " .. self:GetNeedAluminium() .. " (" .. self:GetAluminium() .. ")", "zmlab_font1", -350, -170, zmlab.default_colors["white01"], TEXT_ALIGN_LEFT)
		end

		if self.LastStage == 1 then
			draw.DrawText(zmlab.language.methylamin .. ": " .. self:GetNeedMethylamin() .. " (" .. self:GetMethylamin() .. ")", "zmlab_font1", -350, -170, zmlab.default_colors["white01"], TEXT_ALIGN_LEFT)
		end

		// Filter
		if self.HasFilter then
			draw.DrawText(zmlab.language.combiner_filter, "zmlab_font2", 340, -160, zmlab.default_colors["green01"], TEXT_ALIGN_RIGHT)
		else
			if self.LastStage == 5 then
				local glow = math.abs(math.sin(CurTime() * 6) * 255) // Math stuff for flashing.
				local warncolor = Color(glow, 0, 0) // This flashes red.
				draw.DrawText(zmlab.language.combiner_danger, "zmlab_font3", 350, -175, warncolor, TEXT_ALIGN_RIGHT)
			end
		end


		local MaxTime = self:GetMaxProcessingTime()
		local StartTime = self:GetStartProcessingTime()
		local EndTime = (StartTime + MaxTime) -  CurTime()
		EndTime = MaxTime - EndTime

		local methSludge = self:GetMethSludge()
		local cleanProcess = self:GetCleaningProgress()

		// Processing Bar
		if (StartTime > 0) then
			draw.RoundedBox(12, -349, 55, 695 , 100, zmlab.default_colors["black02"])
			draw.RoundedBox(12, -349, 55, math.Clamp((695 / MaxTime) * EndTime,0,695), 100, zmlab.default_colors["green02"])
			draw.DrawText(zmlab.language.combiner_processing, "zmlab_font_processing", 0, 76, zmlab.default_colors["white01"], TEXT_ALIGN_CENTER)
		end

		// Methsludge Amount
		if (methSludge > 0) then
			draw.RoundedBox(12, -349, 55, 695 , 100, zmlab.default_colors["black02"])
			draw.RoundedBox(12, -349, 55, (695 / self:GetMaxMethSludge()) * methSludge, 100, zmlab.default_colors["methsludge"])
			draw.DrawText(zmlab.language.combiner_methsludge .. math.Round(methSludge), "zmlab_font_processing", 0, 76, zmlab.default_colors["white01"], TEXT_ALIGN_CENTER)
		end

		// Cleaning Process
		if (cleanProcess > 0) then
			local progress = (1 / zmlab.config.Combiner.DirtAmount) * cleanProcess
			local progressColor = zmlab.f.LerpColor(progress, zmlab.default_colors["dirt01"], zmlab.default_colors["dirt02"])

			draw.RoundedBox(12, -349, 55, 695 , 100, zmlab.default_colors["black02"])
			draw.RoundedBox(12, -349, 55, (695 / zmlab.config.Combiner.DirtAmount) * cleanProcess, 100, progressColor)
		end
	cam.End3D2D()
end


function ENT:CreateFilterEffects()
	if self:GetModel() == nil then return end
	if GetConVar("zmlab_cl_vfx_particleeffects"):GetInt() ~= 1 then return end

	self:StopParticles()

	if self.LastStage == 5 then
		if self.HasFilter then
			ParticleEffectAttach("zmlab_cleand_gas", PATTACH_POINT_FOLLOW, self, 7)
		else
			ParticleEffectAttach("zmlab_poison_gas", PATTACH_POINT_FOLLOW, self, 7)
		end
	else
		self:StopParticles()
	end
end

function ENT:Think()
	if zmlab.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 600) then

		zmlab.f.LoopedSound(self, "Combiner_poision", self.LastStage == 5 and self.HasFilter == false)
		zmlab.f.LoopedSound(self, "Combiner_filtering", self.LastStage == 5 and self.HasFilter == true)
		zmlab.f.LoopedSound(self, "progress_cooking", self.LastStage == 2 or self.LastStage == 4 or self.LastStage == 6)


		// PumpSound and Effects
		self:OutputVFX()

		if self.ClientProps then

			if not IsValid(self.ClientProps["MethSludge"]) then
				self:SpawnClientModel_MethSludge()
			else


				local hasFilter = self:GetHasFilter()
				local hasTray = self:GetHasTray()
				local currentStage = self:GetStage()

				if self.LastStage ~= currentStage or hasFilter ~= self.HasFilter or hasTray ~= self.HasTray then

					self.LastStage = currentStage
					self.HasFilter = hasFilter
					self.HasTray = hasTray

					self:CreateFilterEffects()

					self.ClientProps["MethSludge"]:SetNoDraw(false)

					if self.LastStage == 1 then

						self.ClientProps["MethSludge"]:SetNoDraw(true)
						zmlab.f.ClientAnim(self.ClientProps["MethSludge"], "idle", 1)
						zmlab.f.ClientAnim(self, "mode_idle", 1)

					elseif self.LastStage == 2 then

						zmlab.f.ClientAnim(self.ClientProps["MethSludge"], "half", 1)
						zmlab.f.ClientAnim(self, "mode_mix", 1)

					elseif self.LastStage == 3 then

						zmlab.f.ClientAnim(self, "mode_idle", 1)
						self:EmitSound("progress_done")

					elseif self.LastStage == 4 then

						zmlab.f.ClientAnim(self.ClientProps["MethSludge"], "full", 1)
						zmlab.f.ClientAnim(self, "mode_mix", 1)

					elseif self.LastStage == 5 then

						zmlab.f.ClientAnim(self, "mode_mix", 1)
						zmlab.f.ClientAnim(self.ClientProps["MethSludge"], "full", 1)

					elseif self.LastStage == 6 then

						zmlab.f.ClientAnim(self, "mode_mix", 1)
						zmlab.f.ClientAnim(self.ClientProps["MethSludge"], "full", 1)

					elseif self.LastStage == 7 then

						if self.HasTray then
							zmlab.f.ClientAnim(self, "mode_pump", 1)
						else
							zmlab.f.ClientAnim(self, "mode_idle", 1)
						end

						zmlab.f.ClientAnim(self.ClientProps["MethSludge"], "full", 1)

					elseif self.LastStage == 8 then

						zmlab.f.ClientAnim(self, "mode_idle", 1)
						self.ClientProps["MethSludge"]:SetNoDraw(true)
						zmlab.f.ClientAnim(self.ClientProps["MethSludge"], "idle", 1)
					end
				end
			end
		else
			self.ClientProps = {}
		end

	else
		self.LastStage = -1
		self.HasFilter = -1
		self.HasTray = -1

		self:StopSound("progress_cooking")
		self:StopSound("progress_done")

		self:RemoveClientModels()

		self:StopParticles()
	end

	self:SetNextClientThink(CurTime())

	return true
end


function ENT:OutputVFX()
	local currentMeth = self:GetMethSludge()

	if self.LastMethSludge ~= currentMeth and self.HasTray then

		self:EmitSound("MethylaminSludge_pump")

		local attach = self:LookupAttachment("effect0" .. math.random(1, 5))
		local attachData = self:GetAttachment(attach)
		if GetConVar("zmlab_cl_vfx_particleeffects"):GetInt() == 1 then
			ParticleEffect("zmlab_methsludge_fill", attachData.Pos, attachData.Ang, self)
		end
		self.LastMethSludge = currentMeth
	end
end


// Client Model
function ENT:SpawnClientModel_MethSludge()
	local ent = ents.CreateClientProp()
	if not IsValid(ent) then return end

	ent:SetPos(self:GetPos() + self:GetUp() * 20)
	ent:SetModel("models/zerochain/zmlab/zmlab_sludge.mdl")
	ent:SetAngles(self:GetAngles())
	ent:Spawn()
	ent:Activate()
	ent:SetParent(self)
	ent:SetNoDraw(true)
	self.ClientProps["MethSludge"] = ent
end

function ENT:RemoveClientModels()
	if (self.ClientProps and table.Count(self.ClientProps) > 0) then
		for k, v in pairs(self.ClientProps) do
			if IsValid(v) then
				v:Remove()
			end
		end
	end

	self.ClientProps = {}
	self.RollCount = 0
end

function ENT:OnRemove()
	self:StopSound("progress_cooking")
	self:StopSound("progress_done")
	self:StopSound("Combiner_filtering")

	self:RemoveClientModels()

	if self.Sounds == nil then return end

	for k, v in pairs(self.Sounds) do
		if v and v:IsPlaying() then
			v:Stop()
		end
	end
end

--addons/zeros_methlab_1.6.4/lua/entities/zmlab_combiner/shared.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_frezzer/shared.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_frezzingtray/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.Spawnable = false
ENT.AdminSpawnable = true
ENT.PrintName = "Freezing Tray"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros Meth Lab"

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "InBucket")
	self:NetworkVar("Float", 1, "FrezzingProgress")

	if SERVER then
		self:SetInBucket(0)
		self:SetFrezzingProgress(0)
	end
end

--addons/zeros_methlab_1.6.4/lua/entities/zmlab_methdropoff/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Meth DropOff"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros Meth Lab"

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "Deliver_PlayerID")
	self:NetworkVar("Bool", 0, "IsClosed")

	if SERVER then
		self:SetDeliver_PlayerID("nil")
		self:SetIsClosed(true)
	end
end

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_bar/shared.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Bar"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/Zerochain/props_mining/zrms_bar.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "MetalType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetMetalType("Iron")
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_bar_iron.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_bar_silver.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_basket_iron.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_basket")
ENT.Type = "anim"
ENT.Base = "zrms_basket"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Crate - Iron"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "ResourceAmount")
	self:NetworkVar("String", 0, "ResourceType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetResourceAmount(zrmine.config.ResourceCrates_Capacity)
		self:SetResourceType("Iron")
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_basket_silver.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_buyer/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_buyer/shared.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Buyer NPC"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "BuyRate")
	self:NetworkVar("Int", 1, "CurrentState")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetBuyRate(100)
		self:SetCurrentState(0)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_ore/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_resource_silver.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_resource")
ENT.Type = "anim"
ENT.Base = "zrms_resource"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Gravel - Silver"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/Zerochain/props_mining/zrms_resource.mdl"
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "ResourceAmount")
	self:NetworkVar("String", 0, "ResourceType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetResourceType("Silver")
		self:SetResourceAmount(25)
	end
end

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter_gold.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_splitter/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	self.InsertEffect = ParticleEmitter(self:GetPos())
	zrmine.f.EntList_Add(self)
end

function ENT:ReturnStorage()
	return self:GetCoal() + self:GetIron() + self:GetBronze() + self:GetSilver() + self:GetGold()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SplittSound()
	local MoveSound = CreateSound(self, "zrmine_sfx_conveyorbelt_move")

	if (self:GetCurrentState() == 1) then
		if self.SoundObj == nil then
			self.SoundObj = MoveSound
		end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

		if self.SoundObj:IsPlaying() == false then
			self.SoundObj:Play()
			self.SoundObj:ChangeVolume(0, 0)
			self.SoundObj:ChangeVolume(GetConVar("zrms_cl_audiovolume"):GetFloat(), 1)
		end
	else
		if self.SoundObj == nil then
			self.SoundObj = MoveSound
		end

		if self.SoundObj:IsPlaying() == true then
			self.SoundObj:ChangeVolume(0, 1)
			if ((self.lastSoundStop or CurTime()) > CurTime()) then return end
			self.lastSoundStop = CurTime() + 5

			timer.Simple(2, function()
				if (IsValid(self)) then
					self.SoundObj:Stop()
				end
			end)
		end
	end
end

function ENT:OnRemove()
	if (self.SoundObj ~= nil and self.SoundObj:IsPlaying()) then
		self.SoundObj:Stop()
	end
end

function ENT:Think()
	if zrmine.f.InDistance(self:GetPos(), LocalPlayer():GetPos(), 1000) then
		self:SplittSound()
	end
	self:SetNextClientThink(CurTime())
	return true
end

function ENT:Draw()
	self:DrawModel()

	if self.ShowInfo then
		zrmine.f.Belt_DrawInfo(self)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:DrawTranslucent()
	self:Draw()
end

--addons/zeros_trashman_v1.6.3/lua/entities/ztm_leafpile/cl_init.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/entities/ztm_leafpile/shared.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.AutomaticFrameAdvance = true
ENT.Model = "models/zerochain/props_trashman/ztm_leafpile.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "LeafPile"
ENT.Category = "Zeros Trashman"
ENT.RenderGroup = RENDERGROUP_OPAQUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_trashman_v1.6.3/lua/entities/ztm_trash/cl_init.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Initialize()
	ztm.Trash.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Draw()
	self:DrawModel()
	ztm.Trash.Draw(self)
end

function ENT:OnRemove()
	ztm.Trash.OnRemove(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_trashman_v1.6.3/lua/entities/ztm_trash/shared.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/entities/ztm_trashburner/cl_init.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Initialize()
	ztm.Trashburner.Initialize(self)
end

function ENT:Draw()
	self:DrawModel()
	ztm.Trashburner.Draw(self)
end

function ENT:Think()
	ztm.Trashburner.Think(self)
	self:SetNextClientThink(CurTime())

	return true
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:UpdateVisuals()
	ztm.Trashburner.UpdateVisuals(self)
end

function ENT:Remove()
	ztm.Trashburner.Remove(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_constructionkit_cooler.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_distillery/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.c_YeastStew = -1
	self.l_YeastStew = -1
	self.c_Fuel = 0
	self.CurrentFuelLevel = 0
	self.CurrentPressureLevel = 0
	self.Depressuring = false
	self.HeatEffect = false
	self.Pressure = 0
	self.OverHeatEffect = false
end


function ENT:Draw()
	self:DrawModel()

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		self:DrawInfo()
		self:DrawHeatInfo()
		self:DrawValveInfo()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:DrawInfo()

	local cooler_ent = self:GetCooler()
	local condenser_ent = self:GetCondenser()

	cam.Start3D2D(self:LocalToWorld(Vector(38, 0, 49)), self:LocalToWorldAngles(Angle(0,90,90)), 0.05)

		-- Title
		draw.RoundedBox(25, -350, 0, 700, 90, zyb.default_colors["black01"])
		draw.SimpleText(zyb.language.General["Distillery"], "zyb_barrel_font01", 0, 10, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		--Info
		draw.RoundedBox(25, -350, 100, 700, 220, zyb.default_colors["black01"])

		if not IsValid(cooler_ent) then
			draw.SimpleText(zyb.language.General["MissingCooler"], "zyb_barrel_font02", -330, 115, zyb.default_colors["red01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		elseif not IsValid(condenser_ent) then
			draw.SimpleText(zyb.language.General["MissingCondenser"], "zyb_barrel_font02", -330, 175, zyb.default_colors["red01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

		elseif IsValid(cooler_ent) and IsValid(condenser_ent) then

			local YeastStew = self:GetYeastStew()

			local y_bar = 650 / zyb.config.Distillery.YeastStewAmount * YeastStew
			self.c_YeastStew = self.c_YeastStew + 100 * FrameTime()
			self.c_YeastStew = math.Clamp(self.c_YeastStew, 0, y_bar)

			draw.RoundedBox(5, -325, 130, 650, 70, zyb.default_colors["black03"])
			draw.RoundedBox(5, -325, 130, self.c_YeastStew, 70, zyb.default_colors["brown01"])

			draw.SimpleText(zyb.language.General["YeastStew"] .. ": " .. YeastStew .. zyb.config.LiquidUnit, "zyb_barrel_font02", -320, 140, zyb.default_colors["white01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

			local fuel = self:GetFuel()

			local f_bar = 650 / zyb.config.Distillery.FuelAmount * fuel
			self.c_Fuel = self.c_Fuel + 100 * FrameTime()
			self.c_Fuel = math.Clamp(self.c_Fuel, 0, f_bar)

			draw.RoundedBox(5, -325, 220, 650, 70, zyb.default_colors["black03"])
			draw.RoundedBox(5, -325, 220, self.c_Fuel, 70, zyb.default_colors["red02"])

			draw.SimpleText(zyb.language.General["Fuel"] .. ": " .. fuel, "zyb_barrel_font02", -320, 230, zyb.default_colors["white01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
	cam.End3D2D()
end

function ENT:DrawHeatInfo()

	local pressure = self.Pressure

	self.CurrentPressureLevel = (1 / 100) * pressure

	local iSize = (200 / 100) * pressure

	local c_Step = 0
	local color = zyb.default_colors["white01"]


	if pressure < 40 then
		c_Step = (1 / 40) * pressure
		color = zyb.f.LerpColor(c_Step, zyb.default_colors["blue01"], zyb.default_colors["green01"])
	elseif pressure >= 40 and pressure < 80 then
		c_Step = (1 / 40) * (pressure-40)
		color = zyb.f.LerpColor(c_Step, zyb.default_colors["green01"], zyb.default_colors["yellow01"])
	elseif pressure >= 80 then
		c_Step = (1 / 20) * (pressure-80)
		color = zyb.f.LerpColor(c_Step, zyb.default_colors["yellow01"], zyb.default_colors["red03"])
	end

	cam.Start3D2D(self:LocalToWorld(Vector(0.5, -34.8, 74.4)), self:LocalToWorldAngles(Angle(0,90,90)), 0.05)

		surface.SetDrawColor(zyb.default_colors["grey01"])
		surface.SetMaterial(zyb.default_materials["circle"])
		surface.DrawTexturedRect(-100,-100, 200, 200)


		surface.SetDrawColor(color)
		surface.SetMaterial(zyb.default_materials["circle"])
		surface.DrawTexturedRect( -iSize / 2,  -iSize / 2, iSize, iSize)


		draw.SimpleText(pressure .. zyb.config.HeatUnit, "zyb_heater_font01", 0, -20, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		surface.SetDrawColor(zyb.default_colors["black04"])
		surface.SetMaterial(zyb.default_materials["shadowcircle"])
		surface.DrawTexturedRect(-84,-84, 170, 170)


		surface.SetDrawColor(zyb.default_colors["white02"])
		surface.SetMaterial(zyb.default_materials["glamcircle"])
		surface.DrawTexturedRect(-95,-97, 196, 196)


		surface.SetDrawColor(zyb.default_colors["white01"])
		surface.SetMaterial(zyb.default_materials["heaterzone"])
		surface.DrawTexturedRect(-85,-85, 170, 170)

	cam.End3D2D()
end

function ENT:DrawValveInfo()
	cam.Start3D2D(self:LocalToWorld(Vector(0, -30, 98.4)), self:LocalToWorldAngles(Angle(0,90,90)), 0.05)
		local text = zyb.language.General["Depressurize"]

		local bSize = zyb.f.GetTextSize(text,"zyb_barrel_font02")

		if self:OnPressureValve(LocalPlayer()) then
			draw.RoundedBox(20, -bSize / 2, -20, bSize, 80, zyb.default_colors["red04"])
		else
			draw.RoundedBox(20, -bSize / 2, -20, bSize, 80, zyb.default_colors["grey02"])
		end

		draw.SimpleText(text, "zyb_barrel_font02", 0, -10, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	cam.End3D2D()
end

function ENT:HasFuel()
	if self:GetFuel() > 0  then
		return true
	else
		return false
	end
end

function ENT:IsCooking()
	if self:GetFuel() > 0 and self:GetYeastStew() > 0 then
		return true
	else
		return false
	end
end

function ENT:IsOverheating()
	if self.Pressure > 81 then
		return true
	else
		return false
	end
end

function ENT:Think()

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then

		local pressure = self:GetPressureLevel()

		if self.Pressure ~= pressure then
			self.Pressure = pressure

			if self.Pressure > 81 then
				if self.OverHeatEffect == false then

					zyb.f.ParticleEffectAttach("yb_overheat", self, 4)
					self.OverHeatEffect = true
				end
			else
				if self.OverHeatEffect == true then
					self:StopParticlesNamed("yb_overheat")
					self.OverHeatEffect = false
				end
			end
		end


		local depress = self:GetDepressuring()

		if self.Depressuring ~= depress then
			self.Depressuring = depress

			if self.Depressuring then
				zyb.f.PlayClientAnimation(self, "ventil_release", 1)

				local attach = self:GetAttachment(1)
				local ang = attach.Ang
				ang:RotateAroundAxis(ang:Right(),90)

				zyb.f.ParticleEffect("yb_steamjet", attach.Pos, ang, self )
			else
				zyb.f.PlayClientAnimation(self, "ventil_close", 1)
				self:StopParticlesNamed("yb_steamjet")
			end
		end



		if self.ClientProps then
			if not IsValid(self.ClientProps["Fuel"]) then
				self:SpawnClientModel_Fuel()
			else

				local newFuelLvl = (1 / zyb.config.Distillery.FuelAmount) * self:GetFuel()
				local newyeaststew = self:GetYeastStew()

				if self.CurrentFuelLevel ~= newFuelLvl or self.l_YeastStew ~= newyeaststew then

					self.l_YeastStew = newyeaststew

					self.CurrentFuelLevel = self.CurrentFuelLevel + 0.25 * FrameTime()
					self.CurrentFuelLevel = math.Clamp(self.CurrentFuelLevel,0,newFuelLvl)

					self.ClientProps["Fuel"]:SetModelScale(self.CurrentFuelLevel)

					if self.HeatEffect == false then

						zyb.f.ParticleEffectAttach("yb_heaterflame", self, 3)
						self.HeatEffect = true
						self.ClientProps["Fuel"]:SetColor(zyb.default_colors["white01"])
					end

					if newFuelLvl <= 0 or self.l_YeastStew <= 0 and self.HeatEffect then
						self:StopParticlesNamed("yb_heaterflame")
						self.HeatEffect = false
						self.ClientProps["Fuel"]:SetColor(zyb.default_colors["grey02"])
					end

					if newFuelLvl <= 0 then
						self.ClientProps["Fuel"]:SetNoDraw(true)

					else
						self.ClientProps["Fuel"]:SetNoDraw(false)
					end
				end

			end
		else
			self.ClientProps = {}
		end
	else

		if self.HeatEffect then
			self:StopParticlesNamed("yb_heaterflame")
			self.HeatEffect = false
			self.CurrentFuelLevel = 0
		end

		if self.OverHeatEffect == true then
			self:StopParticlesNamed("yb_overheat")
			self.OverHeatEffect = false
			self.Pressure = 0
		end

		self:RemoveClientModels()
	end

	zyb.f.LoopedSound(self, "zyb_steam_loop", self.Depressuring)

	zyb.f.LoopedSound(self, "zyb_burning", self:IsCooking())

	zyb.f.LoopedSound(self, "zyb_cooking", self:IsCooking())

	zyb.f.LoopedSound(self, "zyb_overheat_loop", self:IsOverheating())



	self:SetNextClientThink(CurTime())
	return true
end

function ENT:SpawnClientModel_Fuel()
	local ent = ents.CreateClientProp()
	ent:SetPos( self:LocalToWorld( Vector( 0, 0, 5 ) ) )
	ent:SetModel("models/zerochain/props_yeastbeast/yb_firepit.mdl")
	ent:SetAngles( self:LocalToWorldAngles( Angle( 0, 0, 0 ) ) )
	ent:Spawn()
	ent:Activate()
	ent:SetParent(self)

	self.ClientProps["Fuel"] = ent

	local newFuelLvl = (1 / zyb.config.Distillery.FuelAmount) * self:GetFuel()

	self.CurrentFuelLevel = self.CurrentFuelLevel + 0.25 * FrameTime()
	self.CurrentFuelLevel = math.Clamp(self.CurrentFuelLevel,0,newFuelLvl)

	self.ClientProps["Fuel"]:SetModelScale(self.CurrentFuelLevel)

	if newFuelLvl <= 0 then
		self.ClientProps["Fuel"]:SetNoDraw(true)
	else
		self.ClientProps["Fuel"]:SetNoDraw(false)
	end
end

function ENT:RemoveClientModels()
	if (self.ClientProps and table.Count(self.ClientProps) > 0) then
		for k, v in pairs(self.ClientProps) do
			if IsValid(v) then
				v:Remove()
			end
		end
	end
	self.ClientProps = {}
end

function ENT:OnRemove()
	self:StopSound("zyb_steam_loop")
	self:StopSound("zyb_burning")
	self:StopSound("zyb_cooking")
	self:StopSound("zyb_overheat_loop")
	self:RemoveClientModels()
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_fermbarrel/cl_init.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_jar/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_yeastbeast/yb_jar.mdl"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Jar"
ENT.Category = "Zeros YeastBeast"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT


function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "MoonShine")

    if (SERVER) then
        self:SetMoonShine(0)
    end
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_jarcrate/shared.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_jarcrate/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_yeastbeast/yb_jarcrate.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Jar Crate"
ENT.Category = "Zeros YeastBeast"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "JarCount")

    if SERVER then
        self:SetJarCount(0)
    end
end

function ENT:OnCollectButton(ply)
    local trace = ply:GetEyeTrace()
    if zyb.f.InDistance(self:LocalToWorld(Vector(0, 11, 9)), trace.HitPos, 3) then
        return true
    else
        return false
    end
end

function ENT:OnExtractButton(ply)
    local trace = ply:GetEyeTrace()
    if zyb.f.InDistance(self:LocalToWorld(Vector(0, 11, 3)), trace.HitPos, 3) then
        return true
    else
        return false
    end
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_jarpack/shared.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_upgrade/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		self:DrawUpgradeInfo()
		self:DrawUpgradeTypeInfo()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Initialize()
	self.u_Id = 0
	self.u_val = "+25%"
	self.u_dirty = false
end

function ENT:Think()
	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		local u_id = self:GetUpgradeID()
		local isDirty = self:GetIsDirty()

		if u_id > 0 and (u_id ~= self.u_Id or isDirty ~= self.u_dirty) then
			self.u_Id = u_id
			self.u_dirty = isDirty


			local u_Data = zyb.config.Upgrades[self.u_Id]
			self.u_type = u_Data.u_type

			local boostAmount = 100 * u_Data.u_amount

			if isDirty then
				boostAmount = boostAmount / 2
			end

			if u_Data.u_type == 1 then
				self.u_val = "+" .. boostAmount .. "%"
			elseif u_Data.u_type == 2 then
				self.u_val = "+" .. boostAmount .. "%"
			end
		end
	else
		self.u_Id = -1
	end

end

function ENT:DrawUpgradeInfo()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(self:GetUp(),90)
	ang:RotateAroundAxis(self:GetRight(),-90)

	cam.Start3D2D(self:LocalToWorld(Vector(3.9, 0, 0)), ang, 0.05)

		surface.SetDrawColor(zyb.default_colors["black04"])
		surface.SetMaterial(zyb.default_materials["circle"])
		surface.DrawTexturedRect(-50,-50, 100, 100)
		draw.NoTexture()

		if self.u_dirty then
			draw.SimpleText(self.u_val, "zyb_upgrade_font01", 0, -20, zyb.default_colors["red05"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		else
			draw.SimpleText(self.u_val, "zyb_upgrade_font01", 0, -20, zyb.default_colors["white03"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		end

		surface.SetDrawColor(zyb.default_colors["black04"])
		surface.SetMaterial(zyb.default_materials["shadowcircle"])
		surface.DrawTexturedRect(-43,-43, 86, 86)
		draw.NoTexture()

		surface.SetDrawColor(zyb.default_colors["white02"])
		surface.SetMaterial(zyb.default_materials["glamcircle"])
		surface.DrawTexturedRect(-43,-43, 86, 86)
		draw.NoTexture()

	cam.End3D2D()
end

function ENT:DrawUpgradeTypeInfo()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(self:GetUp(),90)
	ang:RotateAroundAxis(self:GetRight(),-90)
	ang:RotateAroundAxis(self:GetUp(),90)
	cam.Start3D2D(self:LocalToWorld(Vector(0, 4, 0)), ang, 0.05)


		if self.u_type == 1 then
			surface.SetDrawColor(zyb.default_colors["white03"])
			surface.SetMaterial(zyb.default_materials["speedboost"])
			surface.DrawTexturedRect(-60, -60, 120, 120)
			draw.NoTexture()

		elseif self.u_type == 2 then
			surface.SetDrawColor(zyb.default_colors["white03"])
			surface.SetMaterial(zyb.default_materials["productionboost"])
			surface.DrawTexturedRect(-60, -60, 120, 120)
			draw.NoTexture()
		end

	cam.End3D2D()
end

--lua/effects/arccw_uc_shelleffect.lua:

EFFECT.Sounds = {}
EFFECT.Pitch = 90
EFFECT.Scale = 1.5
EFFECT.PhysScale = 1
EFFECT.Model = "models/shells/shell_57.mdl"
EFFECT.Material = nil
EFFECT.JustOnce = true
EFFECT.AlreadyPlayedSound = false
EFFECT.ShellTime = 1

EFFECT.SpawnTime = 0

EFFECT.UC_ShellColor = color_white

function EFFECT:Init(data)

    local att = data:GetAttachment()
    local ent = data:GetEntity()
    local mag = data:GetMagnitude()

    local mdl = LocalPlayer():GetViewModel()

    if LocalPlayer():ShouldDrawLocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if !IsValid(ent) then self:Remove() return end

    local owner = ent:GetOwner()
    if owner != LocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if owner != LocalPlayer() and !GetConVar("arccw_shelleffects"):GetBool() then self:Remove() return end
    if !IsValid(mdl) then self:Remove() return end
    if !mdl:GetAttachment(att) then self:Remove() return end

    local origin, ang = mdl:GetAttachment(att).Pos, mdl:GetAttachment(att).Ang

    ang:RotateAroundAxis(ang:Right(), -90 + ent.ShellRotate)

    ang:RotateAroundAxis(ang:Right(), (ent.ShellRotateAngle or Angle(0, 0, 0))[1])
    ang:RotateAroundAxis(ang:Up(), (ent.ShellRotateAngle or Angle(0, 0, 0))[2])
    ang:RotateAroundAxis(ang:Forward(), (ent.ShellRotateAngle or Angle(0, 0, 0))[3])

    local dir = ang:Up()

    local st = GetConVar("arccw_shelltime"):GetFloat()

    if ent then
        self.Model = ent:GetBuff_Override("Override_ShellModel") or ent.ShellModel
        self.Material = ent:GetBuff_Override("Override_ShellMaterial") or ent.ShellMaterial
        self.Scale = ent:GetBuff("ShellScale") or 1--ent:GetBuff_Override("Override_ShellScale") or ent.ShellScale or 1
        self.PhysScale = ent:GetBuff_Override("Override_ShellPhysScale") or ent.ShellPhysScale or 1
        self.Pitch = ent:GetBuff_Override("Override_ShellPitch") or ent.ShellPitch or 100
        self.Sounds = ent:GetBuff_Override("Override_ShellSounds") or ent.ShellSounds
        self.ShellTime = (ent.ShellTime or 0) + st

        if self.Sounds == "autocheck" and ent:GetPrimaryAmmoType() then
            local t = ent:GetPrimaryAmmoType()
            if t == game.GetAmmoID("buckshot") then
                self.Sounds = ArcCW.ShotgunShellSoundsTable
            elseif ent.Trivia_Calibre and string.find(ent.Trivia_Calibre, ".22") then
                self.Sounds = ArcCW.TinyShellSoundsTable
            elseif t == game.GetAmmoID("pistol") or t == game.GetAmmoID("357") or t == game.GetAmmoID("AlyxGun") then
                self.Sounds = ArcCW.PistolShellSoundsTable
            elseif t == game.GetAmmoID("ar2") then
                self.Sounds = ArcCW.MediumShellSoundsTable
            else
                self.Sounds = ArcCW.ShellSoundsTable
            end
        end

        self.UC_ShellColor = ent:GetBuff_Override("Override_UC_ShellColor") or ent.UC_ShellColor or self.UC_ShellColor
    end

    self:SetPos(origin)
    self:SetModel(self.Model)
    self:SetModelScale(self.Scale)
    self:DrawShadow(true)
    self:SetAngles(ang)

    if self.Material then
        self:SetMaterial(self.Material)
    end

    local pb_vert = 2 * self.Scale * self.PhysScale
    local pb_hor = 0.5 * self.Scale * self.PhysScale

    self:PhysicsInitBox(Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor))

    self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE_DEBRIS)

    local phys = self:GetPhysicsObject()

    local plyvel = Vector(0, 0, 0)

    if IsValid(owner) then
        plyvel = owner:GetAbsVelocity()
    end


    phys:Wake()
    phys:SetDamping(0, 0)
    phys:SetMass(1)
    phys:SetMaterial("gmod_silent")

    phys:SetVelocity((dir * mag * math.Rand(1, 2)) + plyvel)

    phys:AddAngleVelocity(VectorRand() * 100)
    phys:AddAngleVelocity(ang:Up() * 2500 * math.Rand(0.75, 1.25))

    self.HitPitch = self.Pitch + math.Rand(-5,5)

    local emitter = ParticleEmitter(origin)

    for i = 1, 3 do
        local particle = emitter:Add("particles/smokey", origin + (dir * 2))

        if (particle) then
            particle:SetVelocity(VectorRand() * 10 + (dir * i * math.Rand(48, 64)) + plyvel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.05, 0.15))
            particle:SetStartAlpha(math.Rand(40, 60))
            particle:SetEndAlpha(0)
            particle:SetStartSize(0)
            particle:SetEndSize(math.Rand(18, 24))
            particle:SetRoll(math.rad(math.Rand(0, 360)))
            particle:SetRollDelta(math.Rand(-1, 1))
            particle:SetLighting(true)
            particle:SetAirResistance(96)
            particle:SetGravity(Vector(-7, 3, 20))
            particle:SetColor(150, 150, 150)
        end
    end

    self.SpawnTime = CurTime()
end

function EFFECT:PhysicsCollide()
    if self.AlreadyPlayedSound and self.JustOnce then return end

    sound.Play(self.Sounds[math.random(#self.Sounds)], self:GetPos(), 65, self.HitPitch, 1)

    self.AlreadyPlayedSound = true
end

function EFFECT:Think()
    if (self.SpawnTime + self.ShellTime) <= CurTime() then
        if !IsValid(self) then return end
        self:SetRenderFX( kRenderFxFadeFast )
        if (self.SpawnTime + self.ShellTime + 1) <= CurTime() then
            if !IsValid(self:GetPhysicsObject()) then return end
            self:GetPhysicsObject():EnableMotion(false)
            if (self.SpawnTime + self.ShellTime + 1.5) <= CurTime() then
                self:Remove()
                return
            end
        end
    end
    return true
end

function EFFECT:Render()
    if !IsValid(self) then return end
    self:DrawModel()
end
--addons/oneprint/lua/oneprint/shared/player.lua:
local mPlayer = FindMetaTable( "Player" )

--[[

    mPlayer:OP_CanAfford

]]--

function mPlayer:OP_CanAfford( iPrice )
    if ( iPrice == 0 ) then
        return true
    end

    if DarkRP then
        return self:canAfford( iPrice )
    end
end

--[[

    mPlayer:OP_GetMoney

]]--

local tWallet = {
    [ "DarkRP" ] = function( pPlayer )
        return ( pPlayer:getDarkRPVar( "money" ) or 0 )
    end,
    [ "Nutscript" ] = function( pPlayer )
        return ( pPlayer:getChar():getMoney() or 0 )
    end,
    [ "Helix" ] = function( pPlayer )
        return ( pPlayer:GetCharacter():GetMoney() or 0 )
    end
}

function mPlayer:OP_GetMoney()
    if DarkRP then
        return tWallet[ "DarkRP" ]( self )
    elseif nut then
        return tWallet[ "Nutscript" ]( self )
    elseif ( ix and ix.currency ) then
        return tWallet[ "Helix" ]( self )
    end

    return 0
end

--[[

    mPlayer:OP_IsHaxor

]]--

function mPlayer:OP_IsHaxor()
    if not OnePrint.Cfg.HackingEnabled then
        return false
    end

    if not OnePrint.Cfg.HackingJobs or ( istable( OnePrint.Cfg.HackingJobs ) and table.IsEmpty( OnePrint.Cfg.HackingJobs ) ) then
        return true
    end

    return OnePrint.Cfg.HackingJobs[ team.GetName( self:Team() ) ]
end