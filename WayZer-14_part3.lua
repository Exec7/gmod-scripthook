--Stealed clientside server code by exechack.cc
--Hostname: WayZer's Role Play | Быстрая загрузка - Part 3/5 - 06/04/2025


--lua/includes/extensions/coroutine.lua:

--
-- The client needs this file
--
AddCSLuaFile()

if ( !coroutine ) then return end

--
-- Name: coroutine.wait
-- Desc: Yield's the coroutine for so many seconds before returning.\n\nThis should only be called in a coroutine. This function uses CurTime() - not RealTime().
-- Arg1: number|seconds|The number of seconds to wait
-- Ret1: 
--
function coroutine.wait( seconds )

	local endtime = CurTime() + seconds
	while ( true ) do

		if ( endtime < CurTime() ) then return end

		coroutine.yield()

	end
	  
end

--addons/_wlib/lua/wlib/libraries/nw.lua:
--[[
local var = nw.Register 'MyVar' 	-- You MUST call this ALL shared
	var:Write(net.WriteUInt, 32) 	-- Write function
	var:Read(net.ReadUInt, 32) 		-- Read function
	var:SetPlayer() 				-- Registers the var for use on players
	var:SetLocalPlayer() 			-- Optionally set the var to only network to the player its set on, no need to call SetPlayer with this
	var:SetGlobal() 				-- Registers the var for use with nw.SetGlobal
	var:SetNoSync() 				-- Stops the var from syncing to new players, SetLocalPlayer does this for you.
	var:Filter(function(ent, value) -- Sets a var to only send to players you return in your callback
		return player.GetWhatever() -- return table players
	end)
	var:SetChangeOnDeath(newval)	-- changes var value to newval on death (may be function)

nw.WaitForPlayer(player, callback) 	-- Calls your callback when the player is ready to recieve net messages

-- Set Functions
ENTITY:SetNetVar(var, value)
nw.SetGlobal(var, value)

-- Get functions
ENTITY:GetNetVar(var)
nw.GetGlobal(var)
]]


nw = nw or {
	Data = {
		[0] = {}
	},
	Vars = {},
	Mappings = {},
	Callbacks = {}
}

local vars 		= nw.Vars
local mappings 	= nw.Mappings
local data 		= nw.Data
local globals 	= data[0]
local callbacks = nw.Callbacks

local NETVAR 	= {}
NETVAR.__index 	= NETVAR

debug.getregistry().Netvar = NETVAR

local bitmap 	= {
	[3]		= 3,
	[7] 	= 4,
	[15] 	= 5,
	[31] 	= 6,
	[63] 	= 7,
	[127] 	= 8,
	[255] 	= 9,
	[511]	= 10
}

local bitcount 	= 2

local ENTITY 	= FindMetaTable 'Entity'

local pairs 	= pairs
local Entity 	= Entity

local net_WriteUInt = net.WriteUInt
local net_ReadUInt 	= net.ReadUInt
local net_Start 	= net.Start
local net_Send 		= (SERVER) and net.Send or net.SendToServer
local net_Broadcast = net.Broadcast
local sorted_pairs 	= SortedPairsByMemberValue

function nw.Register(var) -- You must always call this on both the client and server. It will serioulsy break shit if you don't.
	local t = {
		Name = var,
		NetworkString = 'nw_' .. var,
		WriteFunc = net.WriteType,
		ReadFunc = net.ReadType,
		SendFunc = function(self, ent, value, recipients)
			if (recipients ~= nil) then
				net_Send(recipients)
			else
				net_Broadcast()
			end
		end,
	}
	setmetatable(t, NETVAR)
	vars[var] = t

	if (SERVER) then
		util.AddNetworkString(t.NetworkString)
	else
		net.Receive(t.NetworkString, function()
			local index, value = t:_Read()

			if (not data[index]) then
				data[index] = {}
			end

			local oldValue = data[index][var]
			data[index][var] = value

			t:_CallHook(index, value, oldValue)
		end)
	end

	return t:_Construct()
end

function NETVAR:Write(func, opt)
	self.WriteFunc = function(value)
		func(value, opt)
	end
	return self:_Construct()
end

function NETVAR:Read(func, opt)
	self.ReadFunc = function()
		return func(opt)
	end
	return self:_Construct()
end

function NETVAR:Filter(func)
	self.SendFunc = function(self, ent, value, recipients)
		net_Send(recipients or func(ent, value))
	end
	return self:_Construct()
end

function NETVAR:SetPlayer()
	self.PlayerVar = true
	return self:_Construct()
end

function NETVAR:SetLocalPlayer()
	self.LocalPlayerVar = true
	return self:_Construct()
end

function NETVAR:SetGlobal()
	self.GlobalVar = true
	return self:_Construct()
end

function NETVAR:SetNoSync()
	self.NoSync = true
	return self:_Construct()
end

function NETVAR:SetChangeOnDeath(val)
	self.ChangeOnDeath = true
	self.ChangeOnDeathVal = val
	return self:_Construct()
end

function NETVAR:Accessor(name)
	name = name or self.Name
	if SERVER then
		ENTITY["Set" .. name] = function(ent, value)
			ent:SetNetVar(self.Name, value)
		end
	end
	ENTITY["Get" .. name] = function(ent)
		return ent:GetNetVar(self.Name)
	end
	return self
end

function NETVAR:SetHook(name)
	self.Hook = name
	return self
end

function NETVAR:_Send(ent, value, recipients)
	net_Start(self.NetworkString)
		self:_Write(ent, value)
	self:SendFunc(ent, value, recipients)
end

function NETVAR:_CallHook(index, value, oldValue)
	if self.Hook then
		if (index ~= 0) then
			hook.Call(self.Hook, GAMEMODE, Entity(index), value, oldValue)
		else
			hook.Call(self.Hook, GAMEMODE, value, oldValue)
		end
	end
end

function NETVAR:_Construct()
	local WriteFunc = self.WriteFunc
	local ReadFunc 	= self.ReadFunc

	if self.PlayerVar then
		self._Write = function(self, ent, value)
			net_WriteUInt(ent:EntIndex(), 8)
			WriteFunc(value)
		end
		self._Read = function(self)
			return net_ReadUInt(8), ReadFunc()
		end
	elseif self.LocalPlayerVar then
		self._Write = function(self, ent, value)
			WriteFunc(value)
		end
		self._Read = function(self)
			return LocalPlayer():EntIndex(), ReadFunc()
		end
		self.SendFunc = function(self, ent, value, recipients)
			net_Send(ent)
		end
	elseif self.GlobalVar then
		self._Write = function(self, ent, value)
			WriteFunc(value)
		end
		self._Read = function(self)
			return 0, ReadFunc()
		end
	else
		self._Write = function(self, ent, value)
			net_WriteUInt(ent:EntIndex(), 13)
			WriteFunc(value)
		end
		self._Read = function(self)
			return net_ReadUInt(13), ReadFunc()
		end
	end

	nw.Mappings = {}
	mappings = nw.Mappings
	for k, v in sorted_pairs(vars, 'Name', false) do
		local c = #mappings + 1
		vars[k].ID = c
		mappings[c] = v
		if bitmap[c] then
			bitcount = bitmap[c]
		end
	end

	return self
end

function nw.GetGlobal(var, fallback)
	if globals[var] == nil then return fallback end
	return globals[var]
end

function ENTITY:GetNetVar(var, fallback)
	local index = self:EntIndex()
	local val = data[index] and data[index][var]
	if val == nil then return fallback end
	return val
end

if (SERVER) then
	util.AddNetworkString 'nw.PlayerSync'
	util.AddNetworkString 'nw.NilEntityVar'
	util.AddNetworkString 'nw.NilPlayerVar'
	util.AddNetworkString 'nw.EntityRemoved'
	util.AddNetworkString 'nw.PlayerRemoved'

	net.Receive('nw.PlayerSync', function(len, pl)
		if (pl.EntityCreated ~= true) then
			hook.Call('PlayerEntityCreated', GAMEMODE, pl)

			pl.EntityCreated = true

			for index, _vars in pairs(data) do
				for var, value in pairs(_vars) do
					local ent = Entity(index)
					if (not vars[var].LocalPlayerVar and not vars[var].NoSync) or (ent == pl) then
						vars[var]:_Send(ent, value, pl)
					end
				end
			end

			if (callbacks[pl] ~= nil) then
				for i = 1, #callbacks[pl] do
					callbacks[pl][i](pl)
				end
			end
			callbacks[pl] = nil
		end
	end)

	hook.Add('PlayerInitialSpawn', 'nw.PlayerEntityCreated', function(ply)
		timer.Simple(60, function()
			if IsValid(ply) and ply.EntityCreated ~= true then
				hook.Call('PlayerEntityCreated', GAMEMODE, ply)
			end
		end)
	end)

	hook.Add('EntityRemoved', 'nw.EntityRemoved', function(ent)
		local index = ent:EntIndex()

		if (index ~= 0) and (data[index] ~= nil) then -- For some reason this kept getting called on Entity(0), not sure why...
			if ent:IsPlayer() then
				net_Start('nw.PlayerRemoved')
					net_WriteUInt(index, 8)
				net_Broadcast()
			else
				net_Start('nw.EntityRemoved')
					net_WriteUInt(index, 13)
				net_Broadcast()
			end

			data[index] = nil
		end
	end)

	function nw.WaitForPlayer(pl, cback)
		if (pl.EntityCreated == true) then
			cback(pl)
		else
			if (callbacks[pl] == nil) then
				callbacks[pl] = {}
			end
			callbacks[pl][#callbacks[pl] + 1] = cback
		end
	end

	function nw.SetGlobal(var, value)
		globals[var] = value
		if (value ~= nil) then
			vars[var]:_Send(0, value)
		else
			net_Start('nw.NilEntityVar')
				net_WriteUInt(0, 13)
				net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(0, value)
		end
	end

	function ENTITY:SetNetVar(var, value)
		local index = self:EntIndex()

		if (not data[index]) then
			data[index] = {}
		end

		data[index][var] = value

		if (value ~= nil) then
			vars[var]:_Send(self, value)
		else
			if self:IsPlayer() then
				net_Start('nw.NilPlayerVar')
				net_WriteUInt(index, 8)
			else
				net_Start('nw.NilEntityVar')
				net_WriteUInt(index, 13)
			end
			net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(self, value)
		end
	end

	hook.Add('PostPlayerDeath', 'nw.ChangeOnDeath', function(ply)
		for var, oldval in pairs(data[ply:EntIndex()] or {}) do
			if not vars[var].ChangeOnDeath then continue end

			local setvar = vars[var].ChangeOnDeathVal
			if isfunction(setvar) then
				ply:SetNetVar(var, setvar(oldval))
			else
				ply:SetNetVar(var, setvar)
			end
		end
	end)
else
	hook.Add('InitPostEntity', 'nw.InitPostEntity', function()
		net_Start('nw.PlayerSync')
		net_Send()
	end)

	local function nwNilVar(index, id)
		if data[index] and mappings[id] then
			local oldValue = data[index][mappings[id].Name]
			data[index][mappings[id].Name] = nil
			mappings[id]:_CallHook(index, nil, oldValue)
		end
	end

	net.Receive('nw.NilEntityVar', function()
		nwNilVar(net_ReadUInt(13), net_ReadUInt(bitcount))
	end)

	net.Receive('nw.NilPlayerVar', function()
		nwNilVar(net_ReadUInt(8), net_ReadUInt(bitcount))
	end)

	net.Receive('nw.EntityRemoved', function()
		data[net_ReadUInt(13)] = nil
	end)

	net.Receive('nw.PlayerRemoved', function()
		data[net_ReadUInt(8)] = nil
	end)
end
--addons/_wlib/lua/wlib/libraries/speedy.lua:
do 
	local IsValid 	= IsValid
	local Entity 	= Entity
	local Color 	= Color
	local WriteUInt = net.WriteUInt
	local ReadUInt 	= net.ReadUInt

	function net.WriteEntity(ent)
		if IsValid(ent) then 
			WriteUInt(ent:EntIndex(), 12)
		else
			WriteUInt(0, 12)
		end
	end

	function net.ReadEntity()
		local i = ReadUInt(12)
		if (not i) then return end
		return Entity(i)
	end

	function net.WriteColor(c)
		WriteUInt(c.r, 8)
		WriteUInt(c.g, 8)
		WriteUInt(c.b, 8)
		WriteUInt(c.a, 8)
	end

	function net.ReadColor()
		return Color(ReadUInt(8), ReadUInt(8), ReadUInt(8), ReadUInt(8))
	end
end


if (SERVER) then return end

do
	local pl
	local _LocalPlayer = LocalPlayer
	function LocalPlayer()
		pl = _LocalPlayer()
		if IsValid(pl) then
			LocalPlayer = function()
				return pl
			end
		end
		return pl
	end
	
	local SetFont 		= surface.SetFont
	local GetTextSize 	= surface.GetTextSize

	local Font 			= 'TargetID'
	local SizeCache 	= {}

	function surface.SetFont(font)
		Font = font
		return SetFont(font)
	end
	 
	function surface.GetTextSize(text)
		if (not SizeCache[Font]) then
			SizeCache[Font] = {}
		end
		   
		if (not SizeCache[Font][text]) then
			local x, y = GetTextSize(text)
			SizeCache[Font][text] = {
				x = x, 
				y = y
			}
			return x, y
		end
		   
		return SizeCache[Font][text].x, SizeCache[Font][text].y
	end
	 
	timer.Create('PurgeFontCache', 1200, 0, function()
		SizeCache = {}
	end)
end

--addons/_wlib/lua/wlib/libraries/utf8.lua:
-- $Id: utf8.lua 179 2009-04-03 18:10:03Z pasta $
--
-- Provides UTF-8 aware string functions implemented in pure lua:
-- * utf8len(s)
-- * utf8sub(s, i, j)
-- * utf8reverse(s)
-- * utf8char(unicode)
-- * utf8unicode(s, i, j)
-- * utf8gensub(s, sub_len)
-- * utf8find(str, regex, init, plain)
-- * utf8match(str, regex, init)
-- * utf8gmatch(str, regex, all)
-- * utf8gsub(str, regex, repl, limit)
--
-- If utf8data.lua (containing the lower<->upper case mappings) is loaded, these
-- additional functions are available:
-- * utf8upper(s)
-- * utf8lower(s)
--
-- All functions behave as their non UTF-8 aware counterparts with the exception
-- that UTF-8 characters are used instead of bytes for all units.

--[[
Copyright (c) 2006-2007, Kyle Smith
All rights reserved.
Contributors:
	Alimov Stepan
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
	* Redistributions of source code must retain the above copyright notice,
	  this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright
	  notice, this list of conditions and the following disclaimer in the
	  documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of its contributors may be
	  used to endorse or promote products derived from this software without
	  specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--]]

-- ABNF from RFC 3629
--
-- UTF8-octets = *( UTF8-char )
-- UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
-- UTF8-1	  = %x00-7F
-- UTF8-2	  = %xC2-DF UTF8-tail
-- UTF8-3	  = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /
--			   %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )
-- UTF8-4	  = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /
--			   %xF4 %x80-8F 2( UTF8-tail )
-- UTF8-tail   = %x80-BF
--

local byte	= string.byte
local char	= string.char
local dump	= string.dump
local find	= string.find
local format  = string.format
local gmatch  = string.gmatch
local gsub	= string.gsub
local len	 = string.len
local lower   = string.lower
local match   = string.match
local rep	 = string.rep
local reverse = string.reverse
local sub	 = string.sub
local upper   = string.upper

-- returns the number of bytes used by the UTF-8 character at byte i in s
-- also doubles as a UTF-8 character validator
local function utf8charbytes (s, i)
	-- argument defaults
	i = i or 1

	-- argument checking
	if type(s) ~= "string" then
		error("bad argument #1 to 'utf8charbytes' (string expected, got ".. type(s).. ")")
	end
	if type(i) ~= "number" then
		error("bad argument #2 to 'utf8charbytes' (number expected, got ".. type(i).. ")")
	end

	local c = byte(s, i)

	-- determine bytes needed for character, based on RFC 3629
	-- validate byte 1
	if c > 0 and c <= 127 then
		-- UTF8-1
		return 1

	elseif c >= 194 and c <= 223 then
		-- UTF8-2
		local c2 = byte(s, i + 1)

		if not c2 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		return 2

	elseif c >= 224 and c <= 239 then
		-- UTF8-3
		local c2 = byte(s, i + 1)
		local c3 = byte(s, i + 2)

		if not c2 or not c3 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 224 and (c2 < 160 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 237 and (c2 < 128 or c2 > 159) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		return 3

	elseif c >= 240 and c <= 244 then
		-- UTF8-4
		local c2 = byte(s, i + 1)
		local c3 = byte(s, i + 2)
		local c4 = byte(s, i + 3)

		if not c2 or not c3 or not c4 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 240 and (c2 < 144 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 244 and (c2 < 128 or c2 > 143) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 4
		if c4 < 128 or c4 > 191 then
			error("Invalid UTF-8 character")
		end

		return 4

	else
		error("Invalid UTF-8 character")
	end
end

-- returns the number of characters in a UTF-8 string
local function utf8len (s)
	-- argument checking
	if type(s) ~= "string" then
		for k,v in pairs(s) do print('"',tostring(k),'"',tostring(v),'"') end
		error("bad argument #1 to 'utf8len' (string expected, got ".. type(s).. ")")
	end

	local pos = 1
	local bytes = len(s)
	local len = 0

	while pos <= bytes do
		len = len + 1
		pos = pos + utf8charbytes(s, pos)
	end

	return len
end

-- functions identically to string.sub except that i and j are UTF-8 characters
-- instead of bytes
local function utf8sub (s, i, j)
	-- argument defaults
	j = j or -1

	local pos = 1
	local bytes = len(s)
	local len = 0

	-- only set l if i or j is negative
	local l = (i >= 0 and j >= 0) or utf8len(s)
	local startChar = (i >= 0) and i or l + i + 1
	local endChar   = (j >= 0) and j or l + j + 1

	-- can't have start before end!
	if startChar > endChar then
		return ""
	end

	-- byte offsets to pass to string.sub
	local startByte,endByte = 1,bytes

	while pos <= bytes do
		len = len + 1

		if len == startChar then
			startByte = pos
		end

		pos = pos + utf8charbytes(s, pos)

		if len == endChar then
			endByte = pos - 1
			break
		end
	end

	if startChar > len then startByte = bytes+1   end
	if endChar   < 1   then endByte   = 0		 end

	return sub(s, startByte, endByte)
end


-- replace UTF-8 characters based on a mapping table
local function utf8replace (s, mapping)
	-- argument checking
	if type(s) ~= "string" then
		error("bad argument #1 to 'utf8replace' (string expected, got ".. type(s).. ")")
	end
	if type(mapping) ~= "table" then
		error("bad argument #2 to 'utf8replace' (table expected, got ".. type(mapping).. ")")
	end

	local pos = 1
	local bytes = len(s)
	local charbytes
	local newstr = ""

	while pos <= bytes do
		charbytes = utf8charbytes(s, pos)
		local c = sub(s, pos, pos + charbytes - 1)

		newstr = newstr .. (mapping[c] or c)

		pos = pos + charbytes
	end

	return newstr
end


-- identical to string.upper except it knows about unicode simple case conversions
local function utf8upper (s)
	return utf8replace(s, utf8_lc_uc)
end

-- identical to string.lower except it knows about unicode simple case conversions
local function utf8lower (s)
	return utf8replace(s, utf8_uc_lc)
end

-- identical to string.reverse except that it supports UTF-8
local function utf8reverse (s)
	-- argument checking
	if type(s) ~= "string" then
		error("bad argument #1 to 'utf8reverse' (string expected, got ".. type(s).. ")")
	end

	local bytes = len(s)
	local pos = bytes
	local charbytes
	local newstr = ""

	while pos > 0 do
		c = byte(s, pos)
		while c >= 128 and c <= 191 do
			pos = pos - 1
			c = byte(s, pos)
		end

		charbytes = utf8charbytes(s, pos)

		newstr = newstr .. sub(s, pos, pos + charbytes - 1)

		pos = pos - 1
	end

	return newstr
end

-- http://en.wikipedia.org/wiki/Utf8
-- http://developer.coronalabs.com/code/utf-8-conversion-utility
local function utf8char(unicode)
	if unicode <= 0x7F then return char(unicode) end

	if (unicode <= 0x7FF) then
		local Byte0 = 0xC0 + math.floor(unicode / 0x40);
		local Byte1 = 0x80 + (unicode % 0x40);
		return char(Byte0, Byte1);
	end;

	if (unicode <= 0xFFFF) then
		local Byte0 = 0xE0 +  math.floor(unicode / 0x1000);
		local Byte1 = 0x80 + (math.floor(unicode / 0x40) % 0x40);
		local Byte2 = 0x80 + (unicode % 0x40);
		return char(Byte0, Byte1, Byte2);
	end;

	if (unicode <= 0x10FFFF) then
		local code = unicode
		local Byte3= 0x80 + (code % 0x40);
		code	   = math.floor(code / 0x40)
		local Byte2= 0x80 + (code % 0x40);
		code	   = math.floor(code / 0x40)
		local Byte1= 0x80 + (code % 0x40);
		code	   = math.floor(code / 0x40)
		local Byte0= 0xF0 + code;

		return char(Byte0, Byte1, Byte2, Byte3);
	end;

	error 'Unicode cannot be greater than U+10FFFF!'
end

local shift_6  = 2^6
local shift_12 = 2^12
local shift_18 = 2^18

local utf8unicode
utf8unicode = function(str, i, j, byte_pos)
	i = i or 1
	j = j or i

	if i > j then return end

	local char,bytes

	if byte_pos then
		bytes = utf8charbytes(str,byte_pos)
		char  = sub(str,byte_pos,byte_pos-1+bytes)
	else
		char,byte_pos = utf8sub(str,i,i), 0
		bytes		 = #char
	end

	local unicode

	if bytes == 1 then unicode = byte(char) end
	if bytes == 2 then
		local byte0,byte1 = byte(char,1,2)
		local code0,code1 = byte0-0xC0,byte1-0x80
		unicode = code0*shift_6 + code1
	end
	if bytes == 3 then
		local byte0,byte1,byte2 = byte(char,1,3)
		local code0,code1,code2 = byte0-0xE0,byte1-0x80,byte2-0x80
		unicode = code0*shift_12 + code1*shift_6 + code2
	end
	if bytes == 4 then
		local byte0,byte1,byte2,byte3 = byte(char,1,4)
		local code0,code1,code2,code3 = byte0-0xF0,byte1-0x80,byte2-0x80,byte3-0x80
		unicode = code0*shift_18 + code1*shift_12 + code2*shift_6 + code3
	end

	return unicode,utf8unicode(str, i+1, j, byte_pos+bytes)
end

-- Returns an iterator which returns the next substring and its byte interval
local function utf8gensub(str, sub_len)
	sub_len		= sub_len or 1
	local byte_pos = 1
	local len	  = #str
	return function(skip)
		if skip then byte_pos = byte_pos + skip end
		local char_count = 0
		local start	  = byte_pos
		repeat
			if byte_pos > len then return end
			char_count  = char_count + 1
			local bytes = utf8charbytes(str,byte_pos)
			byte_pos	= byte_pos+bytes

		until char_count == sub_len

		local last  = byte_pos-1
		local sub   = sub(str,start,last)
		return sub, start, last
	end
end

local function binsearch(sortedTable, item, comp)
	local head, tail = 1, #sortedTable
	local mid = math.floor((head + tail)/2)
	if not comp then
		while (tail - head) > 1 do
			if sortedTable[tonumber(mid)] > item then
				tail = mid
			else
				head = mid
			end
			mid = math.floor((head + tail)/2)
		end
	else
	end
	if sortedTable[tonumber(head)] == item then
		return true, tonumber(head)
	elseif sortedTable[tonumber(tail)] == item then
		return true, tonumber(tail)
	else
		return false
	end
end
local function classMatchGenerator(class, plain)
	local codes = {}
	local ranges = {}
	local ignore = false
	local range = false
	local firstletter = true
	local unmatch = false

	local it = utf8gensub(class)

	local skip
	for c,bs,be in it do
		skip = be
		if not ignore and not plain then
			if c == "%" then
				ignore = true
			elseif c == "-" then
				table.insert(codes, utf8unicode(c))
				range = true
			elseif c == "^" then
				if not firstletter then
					error('!!!')
				else
					unmatch = true
				end
			elseif c == ']' then
				break
			else
				if not range then
					table.insert(codes, utf8unicode(c))
				else
					table.remove(codes) -- removing '-'
					table.insert(ranges, {table.remove(codes), utf8unicode(c)})
					range = false
				end
			end
		elseif ignore and not plain then
			if c == 'a' then -- %a: represents all letters. (ONLY ASCII)
				table.insert(ranges, {65, 90}) -- A - Z
				table.insert(ranges, {97, 122}) -- a - z
			elseif c == 'c' then -- %c: represents all control characters.
				table.insert(ranges, {0, 31})
				table.insert(codes, 127)
			elseif c == 'd' then -- %d: represents all digits.
				table.insert(ranges, {48, 57}) -- 0 - 9
			elseif c == 'g' then -- %g: represents all printable characters except space.
				table.insert(ranges, {1, 8})
				table.insert(ranges, {14, 31})
				table.insert(ranges, {33, 132})
				table.insert(ranges, {134, 159})
				table.insert(ranges, {161, 5759})
				table.insert(ranges, {5761, 8191})
				table.insert(ranges, {8203, 8231})
				table.insert(ranges, {8234, 8238})
				table.insert(ranges, {8240, 8286})
				table.insert(ranges, {8288, 12287})
			elseif c == 'l' then -- %l: represents all lowercase letters. (ONLY ASCII)
				table.insert(ranges, {97, 122}) -- a - z
			elseif c == 'p' then -- %p: represents all punctuation characters. (ONLY ASCII)
				table.insert(ranges, {33, 47})
				table.insert(ranges, {58, 64})
				table.insert(ranges, {91, 96})
				table.insert(ranges, {123, 126})
			elseif c == 's' then -- %s: represents all space characters.
				table.insert(ranges, {9, 13})
				table.insert(codes, 32)
				table.insert(codes, 133)
				table.insert(codes, 160)
				table.insert(codes, 5760)
				table.insert(ranges, {8192, 8202})
				table.insert(codes, 8232)
				table.insert(codes, 8233)
				table.insert(codes, 8239)
				table.insert(codes, 8287)
				table.insert(codes, 12288)
			elseif c == 'u' then -- %u: represents all uppercase letters. (ONLY ASCII)
				table.insert(ranges, {65, 90}) -- A - Z
			elseif c == 'w' then -- %w: represents all alphanumeric characters. (ONLY ASCII)
				table.insert(ranges, {48, 57}) -- 0 - 9
				table.insert(ranges, {65, 90}) -- A - Z
				table.insert(ranges, {97, 122}) -- a - z
			elseif c == 'x' then -- %x: represents all hexadecimal digits.
				table.insert(ranges, {48, 57}) -- 0 - 9
				table.insert(ranges, {65, 70}) -- A - F
				table.insert(ranges, {97, 102}) -- a - f
			else
				if not range then
					table.insert(codes, utf8unicode(c))
				else
					table.remove(codes) -- removing '-'
					table.insert(ranges, {table.remove(codes), utf8unicode(c)})
					range = false
				end
			end
			ignore = false
		else
			if not range then
				table.insert(codes, utf8unicode(c))
			else
				table.remove(codes) -- removing '-'
				table.insert(ranges, {table.remove(codes), utf8unicode(c)})
				range = false
			end
			ignore = false
		end

		firstletter = false
	end

	table.sort(codes)

	local function inRanges(charCode)
		for _,r in ipairs(ranges) do
			if r[1] <= charCode and charCode <= r[2] then
				return true
			end
		end
		return false
	end
	if not unmatch then
		return function(charCode)
			return binsearch(codes, charCode) or inRanges(charCode)
		end, skip
	else
		return function(charCode)
			return charCode ~= -1 and not (binsearch(codes, charCode) or inRanges(charCode))
		end, skip
	end
end

-- utf8sub with extra argument, and extra result value
local function utf8subWithBytes (s, i, j, sb)
	-- argument defaults
	j = j or -1

	local pos = sb or 1
	local bytes = len(s)
	local len = 0

	-- only set l if i or j is negative
	local l = (i >= 0 and j >= 0) or utf8len(s)
	local startChar = (i >= 0) and i or l + i + 1
	local endChar   = (j >= 0) and j or l + j + 1

	-- can't have start before end!
	if startChar > endChar then
		return ""
	end

	-- byte offsets to pass to string.sub
	local startByte,endByte = 1,bytes

	while pos <= bytes do
		len = len + 1

		if len == startChar then
			startByte = pos
		end

		pos = pos + utf8charbytes(s, pos)

		if len == endChar then
			endByte = pos - 1
			break
		end
	end

	if startChar > len then startByte = bytes+1   end
	if endChar   < 1   then endByte   = 0		 end

	return sub(s, startByte, endByte), endByte + 1
end

local cache = setmetatable({},{
	__mode = 'kv'
})
local cachePlain = setmetatable({},{
	__mode = 'kv'
})
local function matcherGenerator(regex, plain)
	local matcher = {
		functions = {},
		captures = {}
	}
	if not plain then
		cache[regex] =  matcher
	else
		cachePlain[regex] = matcher
	end
	local function simple(func)
		return function(cC)
			if func(cC) then
				matcher:nextFunc()
				matcher:nextStr()
			else
				matcher:reset()
			end
		end
	end
	local function star(func)
		return function(cC)
			if func(cC) then
				matcher:fullResetOnNextFunc()
				matcher:nextStr()
			else
				matcher:nextFunc()
			end
		end
	end
	local function minus(func)
		return function(cC)
			if func(cC) then
				matcher:fullResetOnNextStr()
			end
			matcher:nextFunc()
		end
	end
	local function question(func)
		return function(cC)
			if func(cC) then
				matcher:fullResetOnNextFunc()
				matcher:nextStr()
			end
			matcher:nextFunc()
		end
	end

	local function capture(id)
		return function(cC)
			local l = matcher.captures[id][2] - matcher.captures[id][1]
			local captured = utf8sub(matcher.string, matcher.captures[id][1], matcher.captures[id][2])
			local check = utf8sub(matcher.string, matcher.str, matcher.str + l)
			if captured == check then
				for i = 0, l do
					matcher:nextStr()
				end
				matcher:nextFunc()
			else
				matcher:reset()
			end
		end
	end
	local function captureStart(id)
		return function(cC)
			matcher.captures[id][1] = matcher.str
			matcher:nextFunc()
		end
	end
	local function captureStop(id)
		return function(cC)
			matcher.captures[id][2] = matcher.str - 1
			matcher:nextFunc()
		end
	end

	local function balancer(str)
		local sum = 0
		local bc, ec = utf8sub(str, 1, 1), utf8sub(str, 2, 2)
		local skip = len(bc) + len(ec)
		bc, ec = utf8unicode(bc), utf8unicode(ec)
		return function(cC)
			if cC == ec and sum > 0 then
				sum = sum - 1
				if sum == 0 then
					matcher:nextFunc()
				end
				matcher:nextStr()
			elseif cC == bc then
				sum = sum + 1
				matcher:nextStr()
			else
				if sum == 0 or cC == -1 then
					sum = 0
					matcher:reset()
				else
					matcher:nextStr()
				end
			end
		end, skip
	end

	matcher.functions[1] = function(cC)
		matcher:fullResetOnNextStr()
		matcher.seqStart = matcher.str
		matcher:nextFunc()
		if (matcher.str > matcher.startStr and matcher.fromStart) or matcher.str >= matcher.stringLen then
			matcher.stop = true
			matcher.seqStart = nil
		end
	end

	local lastFunc
	local ignore = false
	local skip = nil
	local it = (function()
		local gen = utf8gensub(regex)
		return function()
			return gen(skip)
		end
	end)()
	local cs = {}
	for c, bs, be in it do
		skip = nil
		if plain then
			table.insert(matcher.functions, simple(classMatchGenerator(c, plain)))
		else
			if ignore then
				if find('123456789', c, 1, true) then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					table.insert(matcher.functions, capture(tonumber(c)))
				elseif c == 'b' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					local b
					b, skip = balancer(sub(regex, be + 1, be + 9))
					table.insert(matcher.functions, b)
				else
					lastFunc = classMatchGenerator('%' .. c)
				end
				ignore = false
			else
				if c == '*' then
					if lastFunc then
						table.insert(matcher.functions, star(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '+' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						table.insert(matcher.functions, star(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '-' then
					if lastFunc then
						table.insert(matcher.functions, minus(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '?' then
					if lastFunc then
						table.insert(matcher.functions, question(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '^' then
					if bs == 1 then
						matcher.fromStart = true
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '$' then
					if be == len(regex) then
						matcher.toEnd = true
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '[' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
					end
					lastFunc, skip = classMatchGenerator(sub(regex, be + 1))
				elseif c == '(' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					table.insert(matcher.captures, {})
					table.insert(cs, #matcher.captures)
					table.insert(matcher.functions, captureStart(cs[#cs]))
					if sub(regex, be + 1, be + 1) == ')' then matcher.captures[#matcher.captures].empty = true end
				elseif c == ')' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					local cap = table.remove(cs)
					if not cap then
						error('invalid capture: "(" missing')
					end
					table.insert(matcher.functions, captureStop(cap))
				elseif c == '.' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
					end
					lastFunc = function(cC) return cC ~= -1 end
				elseif c == '%' then
					ignore = true
				else
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
					end
					lastFunc = classMatchGenerator(c)
				end
			end
		end
	end
	if #cs > 0 then
		error('invalid capture: ")" missing')
	end
	if lastFunc then
		table.insert(matcher.functions, simple(lastFunc))
	end
	lastFunc = nil
	ignore = nil

	table.insert(matcher.functions, function()
		if matcher.toEnd and matcher.str ~= matcher.stringLen then
			matcher:reset()
		else
			matcher.stop = true
		end
	end)

	matcher.nextFunc = function(self)
		self.func = self.func + 1
	end
	matcher.nextStr = function(self)
		self.str = self.str + 1
	end
	matcher.strReset = function(self)
		local oldReset = self.reset
		local str = self.str
		self.reset = function(s)
			s.str = str
			s.reset = oldReset
		end
	end
	matcher.fullResetOnNextFunc = function(self)
		local oldReset = self.reset
		local func = self.func +1
		local str = self.str
		self.reset = function(s)
			s.func = func
			s.str = str
			s.reset = oldReset
		end
	end
	matcher.fullResetOnNextStr = function(self)
		local oldReset = self.reset
		local str = self.str + 1
		local func = self.func
		self.reset = function(s)
			s.func = func
			s.str = str
			s.reset = oldReset
		end
	end

	matcher.process = function(self, str, start)

		self.func = 1
		start = start or 1
		self.startStr = (start >= 0) and start or utf8len(str) + start + 1
		self.seqStart = self.startStr
		self.str = self.startStr
		self.stringLen = utf8len(str) + 1
		self.string = str
		self.stop = false

		self.reset = function(s)
			s.func = 1
		end

		local lastPos = self.str
		local lastByte
		local char
		while not self.stop do
			if self.str < self.stringLen then
				--[[ if lastPos < self.str then
					print('last byte', lastByte)
					char, lastByte = utf8subWithBytes(str, 1, self.str - lastPos - 1, lastByte)
					char, lastByte = utf8subWithBytes(str, 1, 1, lastByte)
					lastByte = lastByte - 1
				else
					char, lastByte = utf8subWithBytes(str, self.str, self.str)
				end
				lastPos = self.str ]]
				char = utf8sub(str, self.str,self.str)
				--print('char', char, utf8unicode(char))
				self.functions[self.func](utf8unicode(char))
			else
				self.functions[self.func](-1)
			end
		end

		if self.seqStart then
			local captures = {}
			for _,pair in pairs(self.captures) do
				if pair.empty then
					table.insert(captures, pair[1])
				else
					table.insert(captures, utf8sub(str, pair[1], pair[2]))
				end
			end
			return self.seqStart, self.str - 1, unpack(captures)
		end
	end

	return matcher
end

-- string.find
local function utf8find(str, regex, init, plain)
	local matcher = cache[regex] or matcherGenerator(regex, plain)
	return matcher:process(str, init)
end

-- string.match
local function utf8match(str, regex, init)
	init = init or 1
	local found = {utf8find(str, regex, init)}
	if found[1] then
		if found[3] then
			return unpack(found, 3)
		end
		return utf8sub(str, found[1], found[2])
	end
end

-- string.gmatch
local function utf8gmatch(str, regex, all)
	regex = (utf8sub(regex,1,1) ~= '^') and regex or '%' .. regex
	local lastChar = 1
	return function()
		local found = {utf8find(str, regex, lastChar)}
		if found[1] then
			lastChar = found[2] + 1
			if found[all and 1 or 3] then
				return unpack(found, all and 1 or 3)
			end
			return utf8sub(str, found[1], found[2])
		end
	end
end

local function replace(repl, args)
	local ret = ''
	if type(repl) == 'string' then
		local ignore = false
		local num = 0
		for c in utf8gensub(repl) do
			if not ignore then
				if c == '%' then
					ignore = true
				else
					ret = ret .. c
				end
			else
				num = tonumber(c)
				if num then
					ret = ret .. args[num]
				else
					ret = ret .. c
				end
				ignore = false
			end
		end
	elseif type(repl) == 'table' then
		ret = repl[args[1] or args[0]] or ''
	elseif type(repl) == 'function' then
		if #args > 0 then
			ret = repl(unpack(args, 1)) or ''
		else
			ret = repl(args[0]) or ''
		end
	end
	return ret
end
-- string.gsub
local function utf8gsub(str, regex, repl, limit)
	limit = limit or -1
	local ret = ''
	local prevEnd = 1
	local it = utf8gmatch(str, regex, true)
	local found = {it()}
	local n = 0
	while #found > 0 and limit ~= n do
		local args = {[0] = utf8sub(str, found[1], found[2]), unpack(found, 3)}
		ret = ret .. utf8sub(str, prevEnd, found[1] - 1)
		.. replace(repl, args)
		prevEnd = found[2] + 1
		n = n + 1
		found = {it()}
	end
	return ret .. utf8sub(str, prevEnd), n
end

utf8.len = utf8len
utf8.sub = utf8sub
utf8.reverse = utf8reverse
utf8.char = utf8char
utf8.unicode = utf8unicode
utf8.gensub = utf8gensub
utf8.byte = utf8unicode
utf8.find	= utf8find
utf8.match   = utf8match
utf8.gmatch  = utf8gmatch
utf8.gsub	= utf8gsub
utf8.dump	= dump
utf8.format = format
utf8.lower = utf8lower
utf8.upper = utf8upper
utf8.rep	 = rep

-- char mapping tables from https://github.com/artemshein/luv/blob/master/utf8data.lua
utf8_lc_uc={["a"]="A",["b"]="B",["c"]="C",["d"]="D",["e"]="E",["f"]="F",["g"]="G",["h"]="H",["i"]="I",["j"]="J",["k"]="K",["l"]="L",["m"]="M",["n"]="N",["o"]="O",["p"]="P",["q"]="Q",["r"]="R",["s"]="S",["t"]="T",["u"]="U",["v"]="V",["w"]="W",["x"]="X",["y"]="Y",["z"]="Z",["µ"]="Μ",["à"]="À",["á"]="Á",["â"]="Â",["ã"]="Ã",["ä"]="Ä",["å"]="Å",["æ"]="Æ",["ç"]="Ç",["è"]="È",["é"]="É",["ê"]="Ê",["ë"]="Ë",["ì"]="Ì",["í"]="Í",["î"]="Î",["ï"]="Ï",["ð"]="Ð",["ñ"]="Ñ",["ò"]="Ò",["ó"]="Ó",["ô"]="Ô",["õ"]="Õ",["ö"]="Ö",["ø"]="Ø",["ù"]="Ù",["ú"]="Ú",["û"]="Û",["ü"]="Ü",["ý"]="Ý",["þ"]="Þ",["ÿ"]="Ÿ",["ā"]="Ā",["ă"]="Ă",["ą"]="Ą",["ć"]="Ć",["ĉ"]="Ĉ",["ċ"]="Ċ",["č"]="Č",["ď"]="Ď",["đ"]="Đ",["ē"]="Ē",["ĕ"]="Ĕ",["ė"]="Ė",["ę"]="Ę",["ě"]="Ě",["ĝ"]="Ĝ",["ğ"]="Ğ",["ġ"]="Ġ",["ģ"]="Ģ",["ĥ"]="Ĥ",["ħ"]="Ħ",["ĩ"]="Ĩ",["ī"]="Ī",["ĭ"]="Ĭ",["į"]="Į",["ı"]="I",["ĳ"]="Ĳ",["ĵ"]="Ĵ",["ķ"]="Ķ",["ĺ"]="Ĺ",["ļ"]="Ļ",["ľ"]="Ľ",["ŀ"]="Ŀ",["ł"]="Ł",["ń"]="Ń",["ņ"]="Ņ",["ň"]="Ň",["ŋ"]="Ŋ",["ō"]="Ō",["ŏ"]="Ŏ",["ő"]="Ő",["œ"]="Œ",["ŕ"]="Ŕ",["ŗ"]="Ŗ",["ř"]="Ř",["ś"]="Ś",["ŝ"]="Ŝ",["ş"]="Ş",["š"]="Š",["ţ"]="Ţ",["ť"]="Ť",["ŧ"]="Ŧ",["ũ"]="Ũ",["ū"]="Ū",["ŭ"]="Ŭ",["ů"]="Ů",["ű"]="Ű",["ų"]="Ų",["ŵ"]="Ŵ",["ŷ"]="Ŷ",["ź"]="Ź",["ż"]="Ż",["ž"]="Ž",["ſ"]="S",["ƀ"]="Ƀ",["ƃ"]="Ƃ",["ƅ"]="Ƅ",["ƈ"]="Ƈ",["ƌ"]="Ƌ",["ƒ"]="Ƒ",["ƕ"]="Ƕ",["ƙ"]="Ƙ",["ƚ"]="Ƚ",["ƞ"]="Ƞ",["ơ"]="Ơ",["ƣ"]="Ƣ",["ƥ"]="Ƥ",["ƨ"]="Ƨ",["ƭ"]="Ƭ",["ư"]="Ư",["ƴ"]="Ƴ",["ƶ"]="Ƶ",["ƹ"]="Ƹ",["ƽ"]="Ƽ",["ƿ"]="Ƿ",["ǅ"]="Ǆ",["ǆ"]="Ǆ",["ǈ"]="Ǉ",["ǉ"]="Ǉ",["ǋ"]="Ǌ",["ǌ"]="Ǌ",["ǎ"]="Ǎ",["ǐ"]="Ǐ",["ǒ"]="Ǒ",["ǔ"]="Ǔ",["ǖ"]="Ǖ",["ǘ"]="Ǘ",["ǚ"]="Ǚ",["ǜ"]="Ǜ",["ǝ"]="Ǝ",["ǟ"]="Ǟ",["ǡ"]="Ǡ",["ǣ"]="Ǣ",["ǥ"]="Ǥ",["ǧ"]="Ǧ",["ǩ"]="Ǩ",["ǫ"]="Ǫ",["ǭ"]="Ǭ",["ǯ"]="Ǯ",["ǲ"]="Ǳ",["ǳ"]="Ǳ",["ǵ"]="Ǵ",["ǹ"]="Ǹ",["ǻ"]="Ǻ",["ǽ"]="Ǽ",["ǿ"]="Ǿ",["ȁ"]="Ȁ",["ȃ"]="Ȃ",["ȅ"]="Ȅ",["ȇ"]="Ȇ",["ȉ"]="Ȉ",["ȋ"]="Ȋ",["ȍ"]="Ȍ",["ȏ"]="Ȏ",["ȑ"]="Ȑ",["ȓ"]="Ȓ",["ȕ"]="Ȕ",["ȗ"]="Ȗ",["ș"]="Ș",["ț"]="Ț",["ȝ"]="Ȝ",["ȟ"]="Ȟ",["ȣ"]="Ȣ",["ȥ"]="Ȥ",["ȧ"]="Ȧ",["ȩ"]="Ȩ",["ȫ"]="Ȫ",["ȭ"]="Ȭ",["ȯ"]="Ȯ",["ȱ"]="Ȱ",["ȳ"]="Ȳ",["ȼ"]="Ȼ",["ɂ"]="Ɂ",["ɇ"]="Ɇ",["ɉ"]="Ɉ",["ɋ"]="Ɋ",["ɍ"]="Ɍ",["ɏ"]="Ɏ",["ɓ"]="Ɓ",["ɔ"]="Ɔ",["ɖ"]="Ɖ",["ɗ"]="Ɗ",["ə"]="Ə",["ɛ"]="Ɛ",["ɠ"]="Ɠ",["ɣ"]="Ɣ",["ɨ"]="Ɨ",["ɩ"]="Ɩ",["ɫ"]="Ɫ",["ɯ"]="Ɯ",["ɲ"]="Ɲ",["ɵ"]="Ɵ",["ɽ"]="Ɽ",["ʀ"]="Ʀ",["ʃ"]="Ʃ",["ʈ"]="Ʈ",["ʉ"]="Ʉ",["ʊ"]="Ʊ",["ʋ"]="Ʋ",["ʌ"]="Ʌ",["ʒ"]="Ʒ",["ͅ"]="Ι",["ͻ"]="Ͻ",["ͼ"]="Ͼ",["ͽ"]="Ͽ",["ά"]="Ά",["έ"]="Έ",["ή"]="Ή",["ί"]="Ί",["α"]="Α",["β"]="Β",["γ"]="Γ",["δ"]="Δ",["ε"]="Ε",["ζ"]="Ζ",["η"]="Η",["θ"]="Θ",["ι"]="Ι",["κ"]="Κ",["λ"]="Λ",["μ"]="Μ",["ν"]="Ν",["ξ"]="Ξ",["ο"]="Ο",["π"]="Π",["ρ"]="Ρ",["ς"]="Σ",["σ"]="Σ",["τ"]="Τ",["υ"]="Υ",["φ"]="Φ",["χ"]="Χ",["ψ"]="Ψ",["ω"]="Ω",["ϊ"]="Ϊ",["ϋ"]="Ϋ",["ό"]="Ό",["ύ"]="Ύ",["ώ"]="Ώ",["ϐ"]="Β",["ϑ"]="Θ",["ϕ"]="Φ",["ϖ"]="Π",["ϙ"]="Ϙ",["ϛ"]="Ϛ",["ϝ"]="Ϝ",["ϟ"]="Ϟ",["ϡ"]="Ϡ",["ϣ"]="Ϣ",["ϥ"]="Ϥ",["ϧ"]="Ϧ",["ϩ"]="Ϩ",["ϫ"]="Ϫ",["ϭ"]="Ϭ",["ϯ"]="Ϯ",["ϰ"]="Κ",["ϱ"]="Ρ",["ϲ"]="Ϲ",["ϵ"]="Ε",["ϸ"]="Ϸ",["ϻ"]="Ϻ",["а"]="А",["б"]="Б",["в"]="В",["г"]="Г",["д"]="Д",["е"]="Е",["ж"]="Ж",["з"]="З",["и"]="И",["й"]="Й",["к"]="К",["л"]="Л",["м"]="М",["н"]="Н",["о"]="О",["п"]="П",["р"]="Р",["с"]="С",["т"]="Т",["у"]="У",["ф"]="Ф",["х"]="Х",["ц"]="Ц",["ч"]="Ч",["ш"]="Ш",["щ"]="Щ",["ъ"]="Ъ",["ы"]="Ы",["ь"]="Ь",["э"]="Э",["ю"]="Ю",["я"]="Я",["ѐ"]="Ѐ",["ё"]="Ё",["ђ"]="Ђ",["ѓ"]="Ѓ",["є"]="Є",["ѕ"]="Ѕ",["і"]="І",["ї"]="Ї",["ј"]="Ј",["љ"]="Љ",["њ"]="Њ",["ћ"]="Ћ",["ќ"]="Ќ",["ѝ"]="Ѝ",["ў"]="Ў",["џ"]="Џ",["ѡ"]="Ѡ",["ѣ"]="Ѣ",["ѥ"]="Ѥ",["ѧ"]="Ѧ",["ѩ"]="Ѩ",["ѫ"]="Ѫ",["ѭ"]="Ѭ",["ѯ"]="Ѯ",["ѱ"]="Ѱ",["ѳ"]="Ѳ",["ѵ"]="Ѵ",["ѷ"]="Ѷ",["ѹ"]="Ѹ",["ѻ"]="Ѻ",["ѽ"]="Ѽ",["ѿ"]="Ѿ",["ҁ"]="Ҁ",["ҋ"]="Ҋ",["ҍ"]="Ҍ",["ҏ"]="Ҏ",["ґ"]="Ґ",["ғ"]="Ғ",["ҕ"]="Ҕ",["җ"]="Җ",["ҙ"]="Ҙ",["қ"]="Қ",["ҝ"]="Ҝ",["ҟ"]="Ҟ",["ҡ"]="Ҡ",["ң"]="Ң",["ҥ"]="Ҥ",["ҧ"]="Ҧ",["ҩ"]="Ҩ",["ҫ"]="Ҫ",["ҭ"]="Ҭ",["ү"]="Ү",["ұ"]="Ұ",["ҳ"]="Ҳ",["ҵ"]="Ҵ",["ҷ"]="Ҷ",["ҹ"]="Ҹ",["һ"]="Һ",["ҽ"]="Ҽ",["ҿ"]="Ҿ",["ӂ"]="Ӂ",["ӄ"]="Ӄ",["ӆ"]="Ӆ",["ӈ"]="Ӈ",["ӊ"]="Ӊ",["ӌ"]="Ӌ",["ӎ"]="Ӎ",["ӏ"]="Ӏ",["ӑ"]="Ӑ",["ӓ"]="Ӓ",["ӕ"]="Ӕ",["ӗ"]="Ӗ",["ә"]="Ә",["ӛ"]="Ӛ",["ӝ"]="Ӝ",["ӟ"]="Ӟ",["ӡ"]="Ӡ",["ӣ"]="Ӣ",["ӥ"]="Ӥ",["ӧ"]="Ӧ",["ө"]="Ө",["ӫ"]="Ӫ",["ӭ"]="Ӭ",["ӯ"]="Ӯ",["ӱ"]="Ӱ",["ӳ"]="Ӳ",["ӵ"]="Ӵ",["ӷ"]="Ӷ",["ӹ"]="Ӹ",["ӻ"]="Ӻ",["ӽ"]="Ӽ",["ӿ"]="Ӿ",["ԁ"]="Ԁ",["ԃ"]="Ԃ",["ԅ"]="Ԅ",["ԇ"]="Ԇ",["ԉ"]="Ԉ",["ԋ"]="Ԋ",["ԍ"]="Ԍ",["ԏ"]="Ԏ",["ԑ"]="Ԑ",["ԓ"]="Ԓ",["ա"]="Ա",["բ"]="Բ",["գ"]="Գ",["դ"]="Դ",["ե"]="Ե",["զ"]="Զ",["է"]="Է",["ը"]="Ը",["թ"]="Թ",["ժ"]="Ժ",["ի"]="Ի",["լ"]="Լ",["խ"]="Խ",["ծ"]="Ծ",["կ"]="Կ",["հ"]="Հ",["ձ"]="Ձ",["ղ"]="Ղ",["ճ"]="Ճ",["մ"]="Մ",["յ"]="Յ",["ն"]="Ն",["շ"]="Շ",["ո"]="Ո",["չ"]="Չ",["պ"]="Պ",["ջ"]="Ջ",["ռ"]="Ռ",["ս"]="Ս",["վ"]="Վ",["տ"]="Տ",["ր"]="Ր",["ց"]="Ց",["ւ"]="Ւ",["փ"]="Փ",["ք"]="Ք",["օ"]="Օ",["ֆ"]="Ֆ",["ᵽ"]="Ᵽ",["ḁ"]="Ḁ",["ḃ"]="Ḃ",["ḅ"]="Ḅ",["ḇ"]="Ḇ",["ḉ"]="Ḉ",["ḋ"]="Ḋ",["ḍ"]="Ḍ",["ḏ"]="Ḏ",["ḑ"]="Ḑ",["ḓ"]="Ḓ",["ḕ"]="Ḕ",["ḗ"]="Ḗ",["ḙ"]="Ḙ",["ḛ"]="Ḛ",["ḝ"]="Ḝ",["ḟ"]="Ḟ",["ḡ"]="Ḡ",["ḣ"]="Ḣ",["ḥ"]="Ḥ",["ḧ"]="Ḧ",["ḩ"]="Ḩ",["ḫ"]="Ḫ",["ḭ"]="Ḭ",["ḯ"]="Ḯ",["ḱ"]="Ḱ",["ḳ"]="Ḳ",["ḵ"]="Ḵ",["ḷ"]="Ḷ",["ḹ"]="Ḹ",["ḻ"]="Ḻ",["ḽ"]="Ḽ",["ḿ"]="Ḿ",["ṁ"]="Ṁ",["ṃ"]="Ṃ",["ṅ"]="Ṅ",["ṇ"]="Ṇ",["ṉ"]="Ṉ",["ṋ"]="Ṋ",["ṍ"]="Ṍ",["ṏ"]="Ṏ",["ṑ"]="Ṑ",["ṓ"]="Ṓ",["ṕ"]="Ṕ",["ṗ"]="Ṗ",["ṙ"]="Ṙ",["ṛ"]="Ṛ",["ṝ"]="Ṝ",["ṟ"]="Ṟ",["ṡ"]="Ṡ",["ṣ"]="Ṣ",["ṥ"]="Ṥ",["ṧ"]="Ṧ",["ṩ"]="Ṩ",["ṫ"]="Ṫ",["ṭ"]="Ṭ",["ṯ"]="Ṯ",["ṱ"]="Ṱ",["ṳ"]="Ṳ",["ṵ"]="Ṵ",["ṷ"]="Ṷ",["ṹ"]="Ṹ",["ṻ"]="Ṻ",["ṽ"]="Ṽ",["ṿ"]="Ṿ",["ẁ"]="Ẁ",["ẃ"]="Ẃ",["ẅ"]="Ẅ",["ẇ"]="Ẇ",["ẉ"]="Ẉ",["ẋ"]="Ẋ",["ẍ"]="Ẍ",["ẏ"]="Ẏ",["ẑ"]="Ẑ",["ẓ"]="Ẓ",["ẕ"]="Ẕ",["ẛ"]="Ṡ",["ạ"]="Ạ",["ả"]="Ả",["ấ"]="Ấ",["ầ"]="Ầ",["ẩ"]="Ẩ",["ẫ"]="Ẫ",["ậ"]="Ậ",["ắ"]="Ắ",["ằ"]="Ằ",["ẳ"]="Ẳ",["ẵ"]="Ẵ",["ặ"]="Ặ",["ẹ"]="Ẹ",["ẻ"]="Ẻ",["ẽ"]="Ẽ",["ế"]="Ế",["ề"]="Ề",["ể"]="Ể",["ễ"]="Ễ",["ệ"]="Ệ",["ỉ"]="Ỉ",["ị"]="Ị",["ọ"]="Ọ",["ỏ"]="Ỏ",["ố"]="Ố",["ồ"]="Ồ",["ổ"]="Ổ",["ỗ"]="Ỗ",["ộ"]="Ộ",["ớ"]="Ớ",["ờ"]="Ờ",["ở"]="Ở",["ỡ"]="Ỡ",["ợ"]="Ợ",["ụ"]="Ụ",["ủ"]="Ủ",["ứ"]="Ứ",["ừ"]="Ừ",["ử"]="Ử",["ữ"]="Ữ",["ự"]="Ự",["ỳ"]="Ỳ",["ỵ"]="Ỵ",["ỷ"]="Ỷ",["ỹ"]="Ỹ",["ἀ"]="Ἀ",["ἁ"]="Ἁ",["ἂ"]="Ἂ",["ἃ"]="Ἃ",["ἄ"]="Ἄ",["ἅ"]="Ἅ",["ἆ"]="Ἆ",["ἇ"]="Ἇ",["ἐ"]="Ἐ",["ἑ"]="Ἑ",["ἒ"]="Ἒ",["ἓ"]="Ἓ",["ἔ"]="Ἔ",["ἕ"]="Ἕ",["ἠ"]="Ἠ",["ἡ"]="Ἡ",["ἢ"]="Ἢ",["ἣ"]="Ἣ",["ἤ"]="Ἤ",["ἥ"]="Ἥ",["ἦ"]="Ἦ",["ἧ"]="Ἧ",["ἰ"]="Ἰ",["ἱ"]="Ἱ",["ἲ"]="Ἲ",["ἳ"]="Ἳ",["ἴ"]="Ἴ",["ἵ"]="Ἵ",["ἶ"]="Ἶ",["ἷ"]="Ἷ",["ὀ"]="Ὀ",["ὁ"]="Ὁ",["ὂ"]="Ὂ",["ὃ"]="Ὃ",["ὄ"]="Ὄ",["ὅ"]="Ὅ",["ὑ"]="Ὑ",["ὓ"]="Ὓ",["ὕ"]="Ὕ",["ὗ"]="Ὗ",["ὠ"]="Ὠ",["ὡ"]="Ὡ",["ὢ"]="Ὢ",["ὣ"]="Ὣ",["ὤ"]="Ὤ",["ὥ"]="Ὥ",["ὦ"]="Ὦ",["ὧ"]="Ὧ",["ὰ"]="Ὰ",["ά"]="Ά",["ὲ"]="Ὲ",["έ"]="Έ",["ὴ"]="Ὴ",["ή"]="Ή",["ὶ"]="Ὶ",["ί"]="Ί",["ὸ"]="Ὸ",["ό"]="Ό",["ὺ"]="Ὺ",["ύ"]="Ύ",["ὼ"]="Ὼ",["ώ"]="Ώ",["ᾀ"]="ᾈ",["ᾁ"]="ᾉ",["ᾂ"]="ᾊ",["ᾃ"]="ᾋ",["ᾄ"]="ᾌ",["ᾅ"]="ᾍ",["ᾆ"]="ᾎ",["ᾇ"]="ᾏ",["ᾐ"]="ᾘ",["ᾑ"]="ᾙ",["ᾒ"]="ᾚ",["ᾓ"]="ᾛ",["ᾔ"]="ᾜ",["ᾕ"]="ᾝ",["ᾖ"]="ᾞ",["ᾗ"]="ᾟ",["ᾠ"]="ᾨ",["ᾡ"]="ᾩ",["ᾢ"]="ᾪ",["ᾣ"]="ᾫ",["ᾤ"]="ᾬ",["ᾥ"]="ᾭ",["ᾦ"]="ᾮ",["ᾧ"]="ᾯ",["ᾰ"]="Ᾰ",["ᾱ"]="Ᾱ",["ᾳ"]="ᾼ",["ι"]="Ι",["ῃ"]="ῌ",["ῐ"]="Ῐ",["ῑ"]="Ῑ",["ῠ"]="Ῠ",["ῡ"]="Ῡ",["ῥ"]="Ῥ",["ῳ"]="ῼ",["ⅎ"]="Ⅎ",["ⅰ"]="Ⅰ",["ⅱ"]="Ⅱ",["ⅲ"]="Ⅲ",["ⅳ"]="Ⅳ",["ⅴ"]="Ⅴ",["ⅵ"]="Ⅵ",["ⅶ"]="Ⅶ",["ⅷ"]="Ⅷ",["ⅸ"]="Ⅸ",["ⅹ"]="Ⅹ",["ⅺ"]="Ⅺ",["ⅻ"]="Ⅻ",["ⅼ"]="Ⅼ",["ⅽ"]="Ⅽ",["ⅾ"]="Ⅾ",["ⅿ"]="Ⅿ",["ↄ"]="Ↄ",["ⓐ"]="Ⓐ",["ⓑ"]="Ⓑ",["ⓒ"]="Ⓒ",["ⓓ"]="Ⓓ",["ⓔ"]="Ⓔ",["ⓕ"]="Ⓕ",["ⓖ"]="Ⓖ",["ⓗ"]="Ⓗ",["ⓘ"]="Ⓘ",["ⓙ"]="Ⓙ",["ⓚ"]="Ⓚ",["ⓛ"]="Ⓛ",["ⓜ"]="Ⓜ",["ⓝ"]="Ⓝ",["ⓞ"]="Ⓞ",["ⓟ"]="Ⓟ",["ⓠ"]="Ⓠ",["ⓡ"]="Ⓡ",["ⓢ"]="Ⓢ",["ⓣ"]="Ⓣ",["ⓤ"]="Ⓤ",["ⓥ"]="Ⓥ",["ⓦ"]="Ⓦ",["ⓧ"]="Ⓧ",["ⓨ"]="Ⓨ",["ⓩ"]="Ⓩ",["ⰰ"]="Ⰰ",["ⰱ"]="Ⰱ",["ⰲ"]="Ⰲ",["ⰳ"]="Ⰳ",["ⰴ"]="Ⰴ",["ⰵ"]="Ⰵ",["ⰶ"]="Ⰶ",["ⰷ"]="Ⰷ",["ⰸ"]="Ⰸ",["ⰹ"]="Ⰹ",["ⰺ"]="Ⰺ",["ⰻ"]="Ⰻ",["ⰼ"]="Ⰼ",["ⰽ"]="Ⰽ",["ⰾ"]="Ⰾ",["ⰿ"]="Ⰿ",["ⱀ"]="Ⱀ",["ⱁ"]="Ⱁ",["ⱂ"]="Ⱂ",["ⱃ"]="Ⱃ",["ⱄ"]="Ⱄ",["ⱅ"]="Ⱅ",["ⱆ"]="Ⱆ",["ⱇ"]="Ⱇ",["ⱈ"]="Ⱈ",["ⱉ"]="Ⱉ",["ⱊ"]="Ⱊ",["ⱋ"]="Ⱋ",["ⱌ"]="Ⱌ",["ⱍ"]="Ⱍ",["ⱎ"]="Ⱎ",["ⱏ"]="Ⱏ",["ⱐ"]="Ⱐ",["ⱑ"]="Ⱑ",["ⱒ"]="Ⱒ",["ⱓ"]="Ⱓ",["ⱔ"]="Ⱔ",["ⱕ"]="Ⱕ",["ⱖ"]="Ⱖ",["ⱗ"]="Ⱗ",["ⱘ"]="Ⱘ",["ⱙ"]="Ⱙ",["ⱚ"]="Ⱚ",["ⱛ"]="Ⱛ",["ⱜ"]="Ⱜ",["ⱝ"]="Ⱝ",["ⱞ"]="Ⱞ",["ⱡ"]="Ⱡ",["ⱥ"]="Ⱥ",["ⱦ"]="Ⱦ",["ⱨ"]="Ⱨ",["ⱪ"]="Ⱪ",["ⱬ"]="Ⱬ",["ⱶ"]="Ⱶ",["ⲁ"]="Ⲁ",["ⲃ"]="Ⲃ",["ⲅ"]="Ⲅ",["ⲇ"]="Ⲇ",["ⲉ"]="Ⲉ",["ⲋ"]="Ⲋ",["ⲍ"]="Ⲍ",["ⲏ"]="Ⲏ",["ⲑ"]="Ⲑ",["ⲓ"]="Ⲓ",["ⲕ"]="Ⲕ",["ⲗ"]="Ⲗ",["ⲙ"]="Ⲙ",["ⲛ"]="Ⲛ",["ⲝ"]="Ⲝ",["ⲟ"]="Ⲟ",["ⲡ"]="Ⲡ",["ⲣ"]="Ⲣ",["ⲥ"]="Ⲥ",["ⲧ"]="Ⲧ",["ⲩ"]="Ⲩ",["ⲫ"]="Ⲫ",["ⲭ"]="Ⲭ",["ⲯ"]="Ⲯ",["ⲱ"]="Ⲱ",["ⲳ"]="Ⲳ",["ⲵ"]="Ⲵ",["ⲷ"]="Ⲷ",["ⲹ"]="Ⲹ",["ⲻ"]="Ⲻ",["ⲽ"]="Ⲽ",["ⲿ"]="Ⲿ",["ⳁ"]="Ⳁ",["ⳃ"]="Ⳃ",["ⳅ"]="Ⳅ",["ⳇ"]="Ⳇ",["ⳉ"]="Ⳉ",["ⳋ"]="Ⳋ",["ⳍ"]="Ⳍ",["ⳏ"]="Ⳏ",["ⳑ"]="Ⳑ",["ⳓ"]="Ⳓ",["ⳕ"]="Ⳕ",["ⳗ"]="Ⳗ",["ⳙ"]="Ⳙ",["ⳛ"]="Ⳛ",["ⳝ"]="Ⳝ",["ⳟ"]="Ⳟ",["ⳡ"]="Ⳡ",["ⳣ"]="Ⳣ",["ⴀ"]="Ⴀ",["ⴁ"]="Ⴁ",["ⴂ"]="Ⴂ",["ⴃ"]="Ⴃ",["ⴄ"]="Ⴄ",["ⴅ"]="Ⴅ",["ⴆ"]="Ⴆ",["ⴇ"]="Ⴇ",["ⴈ"]="Ⴈ",["ⴉ"]="Ⴉ",["ⴊ"]="Ⴊ",["ⴋ"]="Ⴋ",["ⴌ"]="Ⴌ",["ⴍ"]="Ⴍ",["ⴎ"]="Ⴎ",["ⴏ"]="Ⴏ",["ⴐ"]="Ⴐ",["ⴑ"]="Ⴑ",["ⴒ"]="Ⴒ",["ⴓ"]="Ⴓ",["ⴔ"]="Ⴔ",["ⴕ"]="Ⴕ",["ⴖ"]="Ⴖ",["ⴗ"]="Ⴗ",["ⴘ"]="Ⴘ",["ⴙ"]="Ⴙ",["ⴚ"]="Ⴚ",["ⴛ"]="Ⴛ",["ⴜ"]="Ⴜ",["ⴝ"]="Ⴝ",["ⴞ"]="Ⴞ",["ⴟ"]="Ⴟ",["ⴠ"]="Ⴠ",["ⴡ"]="Ⴡ",["ⴢ"]="Ⴢ",["ⴣ"]="Ⴣ",["ⴤ"]="Ⴤ",["ⴥ"]="Ⴥ",["ａ"]="Ａ",["ｂ"]="Ｂ",["ｃ"]="Ｃ",["ｄ"]="Ｄ",["ｅ"]="Ｅ",["ｆ"]="Ｆ",["ｇ"]="Ｇ",["ｈ"]="Ｈ",["ｉ"]="Ｉ",["ｊ"]="Ｊ",["ｋ"]="Ｋ",["ｌ"]="Ｌ",["ｍ"]="Ｍ",["ｎ"]="Ｎ",["ｏ"]="Ｏ",["ｐ"]="Ｐ",["ｑ"]="Ｑ",["ｒ"]="Ｒ",["ｓ"]="Ｓ",["ｔ"]="Ｔ",["ｕ"]="Ｕ",["ｖ"]="Ｖ",["ｗ"]="Ｗ",["ｘ"]="Ｘ",["ｙ"]="Ｙ",["ｚ"]="Ｚ",["𐐨"]="𐐀",["𐐩"]="𐐁",["𐐪"]="𐐂",["𐐫"]="𐐃",["𐐬"]="𐐄",["𐐭"]="𐐅",["𐐮"]="𐐆",["𐐯"]="𐐇",["𐐰"]="𐐈",["𐐱"]="𐐉",["𐐲"]="𐐊",["𐐳"]="𐐋",["𐐴"]="𐐌",["𐐵"]="𐐍",["𐐶"]="𐐎",["𐐷"]="𐐏",["𐐸"]="𐐐",["𐐹"]="𐐑",["𐐺"]="𐐒",["𐐻"]="𐐓",["𐐼"]="𐐔",["𐐽"]="𐐕",["𐐾"]="𐐖",["𐐿"]="𐐗",["𐑀"]="𐐘",["𐑁"]="𐐙",["𐑂"]="𐐚",["𐑃"]="𐐛",["𐑄"]="𐐜",["𐑅"]="𐐝",["𐑆"]="𐐞",["𐑇"]="𐐟",["𐑈"]="𐐠",["𐑉"]="𐐡",["𐑊"]="𐐢",["𐑋"]="𐐣",["𐑌"]="𐐤",["𐑍"]="𐐥",["𐑎"]="𐐦",["𐑏"]="𐐧",}
utf8_uc_lc={["A"]="a",["B"]="b",["C"]="c",["D"]="d",["E"]="e",["F"]="f",["G"]="g",["H"]="h",["I"]="i",["J"]="j",["K"]="k",["L"]="l",["M"]="m",["N"]="n",["O"]="o",["P"]="p",["Q"]="q",["R"]="r",["S"]="s",["T"]="t",["U"]="u",["V"]="v",["W"]="w",["X"]="x",["Y"]="y",["Z"]="z",["À"]="à",["Á"]="á",["Â"]="â",["Ã"]="ã",["Ä"]="ä",["Å"]="å",["Æ"]="æ",["Ç"]="ç",["È"]="è",["É"]="é",["Ê"]="ê",["Ë"]="ë",["Ì"]="ì",["Í"]="í",["Î"]="î",["Ï"]="ï",["Ð"]="ð",["Ñ"]="ñ",["Ò"]="ò",["Ó"]="ó",["Ô"]="ô",["Õ"]="õ",["Ö"]="ö",["Ø"]="ø",["Ù"]="ù",["Ú"]="ú",["Û"]="û",["Ü"]="ü",["Ý"]="ý",["Þ"]="þ",["Ā"]="ā",["Ă"]="ă",["Ą"]="ą",["Ć"]="ć",["Ĉ"]="ĉ",["Ċ"]="ċ",["Č"]="č",["Ď"]="ď",["Đ"]="đ",["Ē"]="ē",["Ĕ"]="ĕ",["Ė"]="ė",["Ę"]="ę",["Ě"]="ě",["Ĝ"]="ĝ",["Ğ"]="ğ",["Ġ"]="ġ",["Ģ"]="ģ",["Ĥ"]="ĥ",["Ħ"]="ħ",["Ĩ"]="ĩ",["Ī"]="ī",["Ĭ"]="ĭ",["Į"]="į",["İ"]="i",["Ĳ"]="ĳ",["Ĵ"]="ĵ",["Ķ"]="ķ",["Ĺ"]="ĺ",["Ļ"]="ļ",["Ľ"]="ľ",["Ŀ"]="ŀ",["Ł"]="ł",["Ń"]="ń",["Ņ"]="ņ",["Ň"]="ň",["Ŋ"]="ŋ",["Ō"]="ō",["Ŏ"]="ŏ",["Ő"]="ő",["Œ"]="œ",["Ŕ"]="ŕ",["Ŗ"]="ŗ",["Ř"]="ř",["Ś"]="ś",["Ŝ"]="ŝ",["Ş"]="ş",["Š"]="š",["Ţ"]="ţ",["Ť"]="ť",["Ŧ"]="ŧ",["Ũ"]="ũ",["Ū"]="ū",["Ŭ"]="ŭ",["Ů"]="ů",["Ű"]="ű",["Ų"]="ų",["Ŵ"]="ŵ",["Ŷ"]="ŷ",["Ÿ"]="ÿ",["Ź"]="ź",["Ż"]="ż",["Ž"]="ž",["Ɓ"]="ɓ",["Ƃ"]="ƃ",["Ƅ"]="ƅ",["Ɔ"]="ɔ",["Ƈ"]="ƈ",["Ɖ"]="ɖ",["Ɗ"]="ɗ",["Ƌ"]="ƌ",["Ǝ"]="ǝ",["Ə"]="ə",["Ɛ"]="ɛ",["Ƒ"]="ƒ",["Ɠ"]="ɠ",["Ɣ"]="ɣ",["Ɩ"]="ɩ",["Ɨ"]="ɨ",["Ƙ"]="ƙ",["Ɯ"]="ɯ",["Ɲ"]="ɲ",["Ɵ"]="ɵ",["Ơ"]="ơ",["Ƣ"]="ƣ",["Ƥ"]="ƥ",["Ʀ"]="ʀ",["Ƨ"]="ƨ",["Ʃ"]="ʃ",["Ƭ"]="ƭ",["Ʈ"]="ʈ",["Ư"]="ư",["Ʊ"]="ʊ",["Ʋ"]="ʋ",["Ƴ"]="ƴ",["Ƶ"]="ƶ",["Ʒ"]="ʒ",["Ƹ"]="ƹ",["Ƽ"]="ƽ",["Ǆ"]="ǆ",["ǅ"]="ǆ",["Ǉ"]="ǉ",["ǈ"]="ǉ",["Ǌ"]="ǌ",["ǋ"]="ǌ",["Ǎ"]="ǎ",["Ǐ"]="ǐ",["Ǒ"]="ǒ",["Ǔ"]="ǔ",["Ǖ"]="ǖ",["Ǘ"]="ǘ",["Ǚ"]="ǚ",["Ǜ"]="ǜ",["Ǟ"]="ǟ",["Ǡ"]="ǡ",["Ǣ"]="ǣ",["Ǥ"]="ǥ",["Ǧ"]="ǧ",["Ǩ"]="ǩ",["Ǫ"]="ǫ",["Ǭ"]="ǭ",["Ǯ"]="ǯ",["Ǳ"]="ǳ",["ǲ"]="ǳ",["Ǵ"]="ǵ",["Ƕ"]="ƕ",["Ƿ"]="ƿ",["Ǹ"]="ǹ",["Ǻ"]="ǻ",["Ǽ"]="ǽ",["Ǿ"]="ǿ",["Ȁ"]="ȁ",["Ȃ"]="ȃ",["Ȅ"]="ȅ",["Ȇ"]="ȇ",["Ȉ"]="ȉ",["Ȋ"]="ȋ",["Ȍ"]="ȍ",["Ȏ"]="ȏ",["Ȑ"]="ȑ",["Ȓ"]="ȓ",["Ȕ"]="ȕ",["Ȗ"]="ȗ",["Ș"]="ș",["Ț"]="ț",["Ȝ"]="ȝ",["Ȟ"]="ȟ",["Ƞ"]="ƞ",["Ȣ"]="ȣ",["Ȥ"]="ȥ",["Ȧ"]="ȧ",["Ȩ"]="ȩ",["Ȫ"]="ȫ",["Ȭ"]="ȭ",["Ȯ"]="ȯ",["Ȱ"]="ȱ",["Ȳ"]="ȳ",["Ⱥ"]="ⱥ",["Ȼ"]="ȼ",["Ƚ"]="ƚ",["Ⱦ"]="ⱦ",["Ɂ"]="ɂ",["Ƀ"]="ƀ",["Ʉ"]="ʉ",["Ʌ"]="ʌ",["Ɇ"]="ɇ",["Ɉ"]="ɉ",["Ɋ"]="ɋ",["Ɍ"]="ɍ",["Ɏ"]="ɏ",["Ά"]="ά",["Έ"]="έ",["Ή"]="ή",["Ί"]="ί",["Ό"]="ό",["Ύ"]="ύ",["Ώ"]="ώ",["Α"]="α",["Β"]="β",["Γ"]="γ",["Δ"]="δ",["Ε"]="ε",["Ζ"]="ζ",["Η"]="η",["Θ"]="θ",["Ι"]="ι",["Κ"]="κ",["Λ"]="λ",["Μ"]="μ",["Ν"]="ν",["Ξ"]="ξ",["Ο"]="ο",["Π"]="π",["Ρ"]="ρ",["Σ"]="σ",["Τ"]="τ",["Υ"]="υ",["Φ"]="φ",["Χ"]="χ",["Ψ"]="ψ",["Ω"]="ω",["Ϊ"]="ϊ",["Ϋ"]="ϋ",["Ϙ"]="ϙ",["Ϛ"]="ϛ",["Ϝ"]="ϝ",["Ϟ"]="ϟ",["Ϡ"]="ϡ",["Ϣ"]="ϣ",["Ϥ"]="ϥ",["Ϧ"]="ϧ",["Ϩ"]="ϩ",["Ϫ"]="ϫ",["Ϭ"]="ϭ",["Ϯ"]="ϯ",["ϴ"]="θ",["Ϸ"]="ϸ",["Ϲ"]="ϲ",["Ϻ"]="ϻ",["Ͻ"]="ͻ",["Ͼ"]="ͼ",["Ͽ"]="ͽ",["Ѐ"]="ѐ",["Ё"]="ё",["Ђ"]="ђ",["Ѓ"]="ѓ",["Є"]="є",["Ѕ"]="ѕ",["І"]="і",["Ї"]="ї",["Ј"]="ј",["Љ"]="љ",["Њ"]="њ",["Ћ"]="ћ",["Ќ"]="ќ",["Ѝ"]="ѝ",["Ў"]="ў",["Џ"]="џ",["А"]="а",["Б"]="б",["В"]="в",["Г"]="г",["Д"]="д",["Е"]="е",["Ж"]="ж",["З"]="з",["И"]="и",["Й"]="й",["К"]="к",["Л"]="л",["М"]="м",["Н"]="н",["О"]="о",["П"]="п",["Р"]="р",["С"]="с",["Т"]="т",["У"]="у",["Ф"]="ф",["Х"]="х",["Ц"]="ц",["Ч"]="ч",["Ш"]="ш",["Щ"]="щ",["Ъ"]="ъ",["Ы"]="ы",["Ь"]="ь",["Э"]="э",["Ю"]="ю",["Я"]="я",["Ѡ"]="ѡ",["Ѣ"]="ѣ",["Ѥ"]="ѥ",["Ѧ"]="ѧ",["Ѩ"]="ѩ",["Ѫ"]="ѫ",["Ѭ"]="ѭ",["Ѯ"]="ѯ",["Ѱ"]="ѱ",["Ѳ"]="ѳ",["Ѵ"]="ѵ",["Ѷ"]="ѷ",["Ѹ"]="ѹ",["Ѻ"]="ѻ",["Ѽ"]="ѽ",["Ѿ"]="ѿ",["Ҁ"]="ҁ",["Ҋ"]="ҋ",["Ҍ"]="ҍ",["Ҏ"]="ҏ",["Ґ"]="ґ",["Ғ"]="ғ",["Ҕ"]="ҕ",["Җ"]="җ",["Ҙ"]="ҙ",["Қ"]="қ",["Ҝ"]="ҝ",["Ҟ"]="ҟ",["Ҡ"]="ҡ",["Ң"]="ң",["Ҥ"]="ҥ",["Ҧ"]="ҧ",["Ҩ"]="ҩ",["Ҫ"]="ҫ",["Ҭ"]="ҭ",["Ү"]="ү",["Ұ"]="ұ",["Ҳ"]="ҳ",["Ҵ"]="ҵ",["Ҷ"]="ҷ",["Ҹ"]="ҹ",["Һ"]="һ",["Ҽ"]="ҽ",["Ҿ"]="ҿ",["Ӏ"]="ӏ",["Ӂ"]="ӂ",["Ӄ"]="ӄ",["Ӆ"]="ӆ",["Ӈ"]="ӈ",["Ӊ"]="ӊ",["Ӌ"]="ӌ",["Ӎ"]="ӎ",["Ӑ"]="ӑ",["Ӓ"]="ӓ",["Ӕ"]="ӕ",["Ӗ"]="ӗ",["Ә"]="ә",["Ӛ"]="ӛ",["Ӝ"]="ӝ",["Ӟ"]="ӟ",["Ӡ"]="ӡ",["Ӣ"]="ӣ",["Ӥ"]="ӥ",["Ӧ"]="ӧ",["Ө"]="ө",["Ӫ"]="ӫ",["Ӭ"]="ӭ",["Ӯ"]="ӯ",["Ӱ"]="ӱ",["Ӳ"]="ӳ",["Ӵ"]="ӵ",["Ӷ"]="ӷ",["Ӹ"]="ӹ",["Ӻ"]="ӻ",["Ӽ"]="ӽ",["Ӿ"]="ӿ",["Ԁ"]="ԁ",["Ԃ"]="ԃ",["Ԅ"]="ԅ",["Ԇ"]="ԇ",["Ԉ"]="ԉ",["Ԋ"]="ԋ",["Ԍ"]="ԍ",["Ԏ"]="ԏ",["Ԑ"]="ԑ",["Ԓ"]="ԓ",["Ա"]="ա",["Բ"]="բ",["Գ"]="գ",["Դ"]="դ",["Ե"]="ե",["Զ"]="զ",["Է"]="է",["Ը"]="ը",["Թ"]="թ",["Ժ"]="ժ",["Ի"]="ի",["Լ"]="լ",["Խ"]="խ",["Ծ"]="ծ",["Կ"]="կ",["Հ"]="հ",["Ձ"]="ձ",["Ղ"]="ղ",["Ճ"]="ճ",["Մ"]="մ",["Յ"]="յ",["Ն"]="ն",["Շ"]="շ",["Ո"]="ո",["Չ"]="չ",["Պ"]="պ",["Ջ"]="ջ",["Ռ"]="ռ",["Ս"]="ս",["Վ"]="վ",["Տ"]="տ",["Ր"]="ր",["Ց"]="ց",["Ւ"]="ւ",["Փ"]="փ",["Ք"]="ք",["Օ"]="օ",["Ֆ"]="ֆ",["Ⴀ"]="ⴀ",["Ⴁ"]="ⴁ",["Ⴂ"]="ⴂ",["Ⴃ"]="ⴃ",["Ⴄ"]="ⴄ",["Ⴅ"]="ⴅ",["Ⴆ"]="ⴆ",["Ⴇ"]="ⴇ",["Ⴈ"]="ⴈ",["Ⴉ"]="ⴉ",["Ⴊ"]="ⴊ",["Ⴋ"]="ⴋ",["Ⴌ"]="ⴌ",["Ⴍ"]="ⴍ",["Ⴎ"]="ⴎ",["Ⴏ"]="ⴏ",["Ⴐ"]="ⴐ",["Ⴑ"]="ⴑ",["Ⴒ"]="ⴒ",["Ⴓ"]="ⴓ",["Ⴔ"]="ⴔ",["Ⴕ"]="ⴕ",["Ⴖ"]="ⴖ",["Ⴗ"]="ⴗ",["Ⴘ"]="ⴘ",["Ⴙ"]="ⴙ",["Ⴚ"]="ⴚ",["Ⴛ"]="ⴛ",["Ⴜ"]="ⴜ",["Ⴝ"]="ⴝ",["Ⴞ"]="ⴞ",["Ⴟ"]="ⴟ",["Ⴠ"]="ⴠ",["Ⴡ"]="ⴡ",["Ⴢ"]="ⴢ",["Ⴣ"]="ⴣ",["Ⴤ"]="ⴤ",["Ⴥ"]="ⴥ",["Ḁ"]="ḁ",["Ḃ"]="ḃ",["Ḅ"]="ḅ",["Ḇ"]="ḇ",["Ḉ"]="ḉ",["Ḋ"]="ḋ",["Ḍ"]="ḍ",["Ḏ"]="ḏ",["Ḑ"]="ḑ",["Ḓ"]="ḓ",["Ḕ"]="ḕ",["Ḗ"]="ḗ",["Ḙ"]="ḙ",["Ḛ"]="ḛ",["Ḝ"]="ḝ",["Ḟ"]="ḟ",["Ḡ"]="ḡ",["Ḣ"]="ḣ",["Ḥ"]="ḥ",["Ḧ"]="ḧ",["Ḩ"]="ḩ",["Ḫ"]="ḫ",["Ḭ"]="ḭ",["Ḯ"]="ḯ",["Ḱ"]="ḱ",["Ḳ"]="ḳ",["Ḵ"]="ḵ",["Ḷ"]="ḷ",["Ḹ"]="ḹ",["Ḻ"]="ḻ",["Ḽ"]="ḽ",["Ḿ"]="ḿ",["Ṁ"]="ṁ",["Ṃ"]="ṃ",["Ṅ"]="ṅ",["Ṇ"]="ṇ",["Ṉ"]="ṉ",["Ṋ"]="ṋ",["Ṍ"]="ṍ",["Ṏ"]="ṏ",["Ṑ"]="ṑ",["Ṓ"]="ṓ",["Ṕ"]="ṕ",["Ṗ"]="ṗ",["Ṙ"]="ṙ",["Ṛ"]="ṛ",["Ṝ"]="ṝ",["Ṟ"]="ṟ",["Ṡ"]="ṡ",["Ṣ"]="ṣ",["Ṥ"]="ṥ",["Ṧ"]="ṧ",["Ṩ"]="ṩ",["Ṫ"]="ṫ",["Ṭ"]="ṭ",["Ṯ"]="ṯ",["Ṱ"]="ṱ",["Ṳ"]="ṳ",["Ṵ"]="ṵ",["Ṷ"]="ṷ",["Ṹ"]="ṹ",["Ṻ"]="ṻ",["Ṽ"]="ṽ",["Ṿ"]="ṿ",["Ẁ"]="ẁ",["Ẃ"]="ẃ",["Ẅ"]="ẅ",["Ẇ"]="ẇ",["Ẉ"]="ẉ",["Ẋ"]="ẋ",["Ẍ"]="ẍ",["Ẏ"]="ẏ",["Ẑ"]="ẑ",["Ẓ"]="ẓ",["Ẕ"]="ẕ",["Ạ"]="ạ",["Ả"]="ả",["Ấ"]="ấ",["Ầ"]="ầ",["Ẩ"]="ẩ",["Ẫ"]="ẫ",["Ậ"]="ậ",["Ắ"]="ắ",["Ằ"]="ằ",["Ẳ"]="ẳ",["Ẵ"]="ẵ",["Ặ"]="ặ",["Ẹ"]="ẹ",["Ẻ"]="ẻ",["Ẽ"]="ẽ",["Ế"]="ế",["Ề"]="ề",["Ể"]="ể",["Ễ"]="ễ",["Ệ"]="ệ",["Ỉ"]="ỉ",["Ị"]="ị",["Ọ"]="ọ",["Ỏ"]="ỏ",["Ố"]="ố",["Ồ"]="ồ",["Ổ"]="ổ",["Ỗ"]="ỗ",["Ộ"]="ộ",["Ớ"]="ớ",["Ờ"]="ờ",["Ở"]="ở",["Ỡ"]="ỡ",["Ợ"]="ợ",["Ụ"]="ụ",["Ủ"]="ủ",["Ứ"]="ứ",["Ừ"]="ừ",["Ử"]="ử",["Ữ"]="ữ",["Ự"]="ự",["Ỳ"]="ỳ",["Ỵ"]="ỵ",["Ỷ"]="ỷ",["Ỹ"]="ỹ",["Ἀ"]="ἀ",["Ἁ"]="ἁ",["Ἂ"]="ἂ",["Ἃ"]="ἃ",["Ἄ"]="ἄ",["Ἅ"]="ἅ",["Ἆ"]="ἆ",["Ἇ"]="ἇ",["Ἐ"]="ἐ",["Ἑ"]="ἑ",["Ἒ"]="ἒ",["Ἓ"]="ἓ",["Ἔ"]="ἔ",["Ἕ"]="ἕ",["Ἠ"]="ἠ",["Ἡ"]="ἡ",["Ἢ"]="ἢ",["Ἣ"]="ἣ",["Ἤ"]="ἤ",["Ἥ"]="ἥ",["Ἦ"]="ἦ",["Ἧ"]="ἧ",["Ἰ"]="ἰ",["Ἱ"]="ἱ",["Ἲ"]="ἲ",["Ἳ"]="ἳ",["Ἴ"]="ἴ",["Ἵ"]="ἵ",["Ἶ"]="ἶ",["Ἷ"]="ἷ",["Ὀ"]="ὀ",["Ὁ"]="ὁ",["Ὂ"]="ὂ",["Ὃ"]="ὃ",["Ὄ"]="ὄ",["Ὅ"]="ὅ",["Ὑ"]="ὑ",["Ὓ"]="ὓ",["Ὕ"]="ὕ",["Ὗ"]="ὗ",["Ὠ"]="ὠ",["Ὡ"]="ὡ",["Ὢ"]="ὢ",["Ὣ"]="ὣ",["Ὤ"]="ὤ",["Ὥ"]="ὥ",["Ὦ"]="ὦ",["Ὧ"]="ὧ",["ᾈ"]="ᾀ",["ᾉ"]="ᾁ",["ᾊ"]="ᾂ",["ᾋ"]="ᾃ",["ᾌ"]="ᾄ",["ᾍ"]="ᾅ",["ᾎ"]="ᾆ",["ᾏ"]="ᾇ",["ᾘ"]="ᾐ",["ᾙ"]="ᾑ",["ᾚ"]="ᾒ",["ᾛ"]="ᾓ",["ᾜ"]="ᾔ",["ᾝ"]="ᾕ",["ᾞ"]="ᾖ",["ᾟ"]="ᾗ",["ᾨ"]="ᾠ",["ᾩ"]="ᾡ",["ᾪ"]="ᾢ",["ᾫ"]="ᾣ",["ᾬ"]="ᾤ",["ᾭ"]="ᾥ",["ᾮ"]="ᾦ",["ᾯ"]="ᾧ",["Ᾰ"]="ᾰ",["Ᾱ"]="ᾱ",["Ὰ"]="ὰ",["Ά"]="ά",["ᾼ"]="ᾳ",["Ὲ"]="ὲ",["Έ"]="έ",["Ὴ"]="ὴ",["Ή"]="ή",["ῌ"]="ῃ",["Ῐ"]="ῐ",["Ῑ"]="ῑ",["Ὶ"]="ὶ",["Ί"]="ί",["Ῠ"]="ῠ",["Ῡ"]="ῡ",["Ὺ"]="ὺ",["Ύ"]="ύ",["Ῥ"]="ῥ",["Ὸ"]="ὸ",["Ό"]="ό",["Ὼ"]="ὼ",["Ώ"]="ώ",["ῼ"]="ῳ",["Ω"]="ω",["K"]="k",["Å"]="å",["Ⅎ"]="ⅎ",["Ⅰ"]="ⅰ",["Ⅱ"]="ⅱ",["Ⅲ"]="ⅲ",["Ⅳ"]="ⅳ",["Ⅴ"]="ⅴ",["Ⅵ"]="ⅵ",["Ⅶ"]="ⅶ",["Ⅷ"]="ⅷ",["Ⅸ"]="ⅸ",["Ⅹ"]="ⅹ",["Ⅺ"]="ⅺ",["Ⅻ"]="ⅻ",["Ⅼ"]="ⅼ",["Ⅽ"]="ⅽ",["Ⅾ"]="ⅾ",["Ⅿ"]="ⅿ",["Ↄ"]="ↄ",["Ⓐ"]="ⓐ",["Ⓑ"]="ⓑ",["Ⓒ"]="ⓒ",["Ⓓ"]="ⓓ",["Ⓔ"]="ⓔ",["Ⓕ"]="ⓕ",["Ⓖ"]="ⓖ",["Ⓗ"]="ⓗ",["Ⓘ"]="ⓘ",["Ⓙ"]="ⓙ",["Ⓚ"]="ⓚ",["Ⓛ"]="ⓛ",["Ⓜ"]="ⓜ",["Ⓝ"]="ⓝ",["Ⓞ"]="ⓞ",["Ⓟ"]="ⓟ",["Ⓠ"]="ⓠ",["Ⓡ"]="ⓡ",["Ⓢ"]="ⓢ",["Ⓣ"]="ⓣ",["Ⓤ"]="ⓤ",["Ⓥ"]="ⓥ",["Ⓦ"]="ⓦ",["Ⓧ"]="ⓧ",["Ⓨ"]="ⓨ",["Ⓩ"]="ⓩ",["Ⰰ"]="ⰰ",["Ⰱ"]="ⰱ",["Ⰲ"]="ⰲ",["Ⰳ"]="ⰳ",["Ⰴ"]="ⰴ",["Ⰵ"]="ⰵ",["Ⰶ"]="ⰶ",["Ⰷ"]="ⰷ",["Ⰸ"]="ⰸ",["Ⰹ"]="ⰹ",["Ⰺ"]="ⰺ",["Ⰻ"]="ⰻ",["Ⰼ"]="ⰼ",["Ⰽ"]="ⰽ",["Ⰾ"]="ⰾ",["Ⰿ"]="ⰿ",["Ⱀ"]="ⱀ",["Ⱁ"]="ⱁ",["Ⱂ"]="ⱂ",["Ⱃ"]="ⱃ",["Ⱄ"]="ⱄ",["Ⱅ"]="ⱅ",["Ⱆ"]="ⱆ",["Ⱇ"]="ⱇ",["Ⱈ"]="ⱈ",["Ⱉ"]="ⱉ",["Ⱊ"]="ⱊ",["Ⱋ"]="ⱋ",["Ⱌ"]="ⱌ",["Ⱍ"]="ⱍ",["Ⱎ"]="ⱎ",["Ⱏ"]="ⱏ",["Ⱐ"]="ⱐ",["Ⱑ"]="ⱑ",["Ⱒ"]="ⱒ",["Ⱓ"]="ⱓ",["Ⱔ"]="ⱔ",["Ⱕ"]="ⱕ",["Ⱖ"]="ⱖ",["Ⱗ"]="ⱗ",["Ⱘ"]="ⱘ",["Ⱙ"]="ⱙ",["Ⱚ"]="ⱚ",["Ⱛ"]="ⱛ",["Ⱜ"]="ⱜ",["Ⱝ"]="ⱝ",["Ⱞ"]="ⱞ",["Ⱡ"]="ⱡ",["Ɫ"]="ɫ",["Ᵽ"]="ᵽ",["Ɽ"]="ɽ",["Ⱨ"]="ⱨ",["Ⱪ"]="ⱪ",["Ⱬ"]="ⱬ",["Ⱶ"]="ⱶ",["Ⲁ"]="ⲁ",["Ⲃ"]="ⲃ",["Ⲅ"]="ⲅ",["Ⲇ"]="ⲇ",["Ⲉ"]="ⲉ",["Ⲋ"]="ⲋ",["Ⲍ"]="ⲍ",["Ⲏ"]="ⲏ",["Ⲑ"]="ⲑ",["Ⲓ"]="ⲓ",["Ⲕ"]="ⲕ",["Ⲗ"]="ⲗ",["Ⲙ"]="ⲙ",["Ⲛ"]="ⲛ",["Ⲝ"]="ⲝ",["Ⲟ"]="ⲟ",["Ⲡ"]="ⲡ",["Ⲣ"]="ⲣ",["Ⲥ"]="ⲥ",["Ⲧ"]="ⲧ",["Ⲩ"]="ⲩ",["Ⲫ"]="ⲫ",["Ⲭ"]="ⲭ",["Ⲯ"]="ⲯ",["Ⲱ"]="ⲱ",["Ⲳ"]="ⲳ",["Ⲵ"]="ⲵ",["Ⲷ"]="ⲷ",["Ⲹ"]="ⲹ",["Ⲻ"]="ⲻ",["Ⲽ"]="ⲽ",["Ⲿ"]="ⲿ",["Ⳁ"]="ⳁ",["Ⳃ"]="ⳃ",["Ⳅ"]="ⳅ",["Ⳇ"]="ⳇ",["Ⳉ"]="ⳉ",["Ⳋ"]="ⳋ",["Ⳍ"]="ⳍ",["Ⳏ"]="ⳏ",["Ⳑ"]="ⳑ",["Ⳓ"]="ⳓ",["Ⳕ"]="ⳕ",["Ⳗ"]="ⳗ",["Ⳙ"]="ⳙ",["Ⳛ"]="ⳛ",["Ⳝ"]="ⳝ",["Ⳟ"]="ⳟ",["Ⳡ"]="ⳡ",["Ⳣ"]="ⳣ",["Ａ"]="ａ",["Ｂ"]="ｂ",["Ｃ"]="ｃ",["Ｄ"]="ｄ",["Ｅ"]="ｅ",["Ｆ"]="ｆ",["Ｇ"]="ｇ",["Ｈ"]="ｈ",["Ｉ"]="ｉ",["Ｊ"]="ｊ",["Ｋ"]="ｋ",["Ｌ"]="ｌ",["Ｍ"]="ｍ",["Ｎ"]="ｎ",["Ｏ"]="ｏ",["Ｐ"]="ｐ",["Ｑ"]="ｑ",["Ｒ"]="ｒ",["Ｓ"]="ｓ",["Ｔ"]="ｔ",["Ｕ"]="ｕ",["Ｖ"]="ｖ",["Ｗ"]="ｗ",["Ｘ"]="ｘ",["Ｙ"]="ｙ",["Ｚ"]="ｚ",["𐐀"]="𐐨",["𐐁"]="𐐩",["𐐂"]="𐐪",["𐐃"]="𐐫",["𐐄"]="𐐬",["𐐅"]="𐐭",["𐐆"]="𐐮",["𐐇"]="𐐯",["𐐈"]="𐐰",["𐐉"]="𐐱",["𐐊"]="𐐲",["𐐋"]="𐐳",["𐐌"]="𐐴",["𐐍"]="𐐵",["𐐎"]="𐐶",["𐐏"]="𐐷",["𐐐"]="𐐸",["𐐑"]="𐐹",["𐐒"]="𐐺",["𐐓"]="𐐻",["𐐔"]="𐐼",["𐐕"]="𐐽",["𐐖"]="𐐾",["𐐗"]="𐐿",["𐐘"]="𐑀",["𐐙"]="𐑁",["𐐚"]="𐑂",["𐐛"]="𐑃",["𐐜"]="𐑄",["𐐝"]="𐑅",["𐐞"]="𐑆",["𐐟"]="𐑇",["𐐠"]="𐑈",["𐐡"]="𐑉",["𐐢"]="𐑊",["𐐣"]="𐑋",["𐐤"]="𐑌",["𐐥"]="𐑍",["𐐦"]="𐑎",["𐐧"]="𐑏",}
--addons/_wlib/lua/wlib/modules/chat/client.lua:
local isTyping = false
local function setTyping(b)
    if isTyping == b then return end
    isTyping = b
    net.Start('wlib.chat.updateTyping')
    net.WriteBool(b)
    net.SendToServer()
end

hook.Add('FinishChat', 'updateTyping', function()
    setTyping(false)
end)

hook.Add('ChatTextChanged', 'updateTyping', function(text)
    if text == '' then
        setTyping(false)
    else
        setTyping(true)
    end
end)

net.Receive('wlib.chat.addText', function()
    local args = {}

    for i=1, net.ReadUInt(8) do
        table.insert(args, net.ReadBool() and net.ReadColor() or net.ReadString())
    end

    chat.AddText(unpack(args))
    chat.PlaySound()
end)

function wlib.chat.say(...)
    local args = table.concat({...}, ' ')
    
    net.Start('wlib.chat.say')
    net.WriteString(args)
    net.SendToServer()
end
--addons/_wlib/lua/wlib/modules/longpoll.lua:
wlib.longpoll = wlib.longpoll or {
    connections = {}
}

for _, v in ipairs(wlib.longpoll.connections) do
    v:stop()
end

local longpoll_class = {}
function longpoll_class:start()
    self.running = true
    self.id = table.insert(wlib.longpoll.connections, self)
    self.ts = 0
    
    self:fetch()
end

function longpoll_class:fetch()
    http.Fetch(self.url:format(self.ts), function(body)
        if not self.running then return end
        local t = util.JSONToTable(body)
        self:callback(t or false)

        self:fetch()
    end, self.failback or function()
        self:callback(false)

        self:fetch()
    end)
end

function longpoll_class:stop()
    self.running = false
    table.RemoveByValue(wlib.longpoll.connections, self)
end

function wlib.longpoll.create(url, cb, fail)
    local poll = {}
    setmetatable(poll, {__index = longpoll_class})

    poll.url = url
    poll.callback = cb
    poll.failback = fail

    return poll
end
--addons/_wlib/lua/wlib/vgui/graph.lua:
local PANEL = {}

function PANEL:Init()
    self.points = {}

    self.gapx = 25
    self.gapy = 25
    self.minx = -10
    self.maxx = 10
    self.miny = -10
    self.maxy = 10
    self.lineColor = Color(200, 0, 0)
    self.tooltipColor = Color(0, 124, 0)
    self.tooltipTextColor = color_white
    self.tooltipFont = 'DermaDefault'
    self.lineThickness = 1
end
wlib.accessor(PANEL, 'equalGap', 'EqualGap')
wlib.accessor(PANEL, 'gapx', 'GapX')
wlib.accessor(PANEL, 'gapy', 'GapY')
wlib.accessor(PANEL, 'minx', 'MinX')
wlib.accessor(PANEL, 'maxx', 'MaxX')
wlib.accessor(PANEL, 'miny', 'MinY')
wlib.accessor(PANEL, 'maxy', 'MaxY')
wlib.accessor(PANEL, 'lineColor', 'LineColor')
wlib.accessor(PANEL, 'gridColor', 'GridColor')
wlib.accessor(PANEL, 'tooltipColor', 'TooltipColor')
wlib.accessor(PANEL, 'tooltipTextColor', 'TooltipTextColor')
wlib.accessor(PANEL, 'tooltipFont', 'TooltipFont')
wlib.accessor(PANEL, 'lineThickness', 'LineThickness')

function PANEL:SetMinMaxX(min, max)
    self.minx, self.maxx = min, max
    return self
end

function PANEL:SetMinMaxY(min, max)
    self.miny, self.maxy = min, max
    return self
end

function PANEL:AutoMinMax()
    if #self.points == 0 then return end

    local minx, maxx, miny, maxy = self.points[1][1], self.points[#self.points][1], math.huge, -math.huge
    for _, v in ipairs(self.points) do
        miny = math.min(miny, v[2])
        maxy = math.max(maxy, v[2])
    end

    --local offsetX, offsetY = math.ceil(20/self.gapx), math.ceil(20/self.gapy)
    local offsetX, offsetY = 2, 2

    self:SetMinMaxX(minx-offsetX, maxx+offsetX)
    self:SetMinMaxY(miny-offsetY, maxy+offsetY)
end

function PANEL:AutoGap()
    local gapx = self:GetWide()/(self.maxx-self.minx)
    local gapy = self:GetTall()/(self.maxy-self.miny)

    if self.equalGap then
        gapx = math.min(gapx, gapy)
        gapy = gapx
    end

    self:SetGapX(gapx)
    self:SetGapY(gapy)
end

function PANEL:PerformLayout(w, h)
    self:AutoGap()
end

function PANEL:AddPoint(x, y, extra)
    local point = {x, y}
    if extra then
        table.Merge(point, extra)
    end
    point.tooltip = self:GenerateTooltip(point)
    
    local fst = self.points[1]
    if fst and fst[1] > x then
        table.insert(self.points, 1, point)
        return
    end

    for k, v in ipairs(self.points) do
        if v[1] == x then
            self.points[k] = point
            return
        elseif v[1] > x then
            table.insert(self.points, k, point)
            return
        end
    end
    table.insert(self.points, point)
end

function PANEL:Clear()
    self.points = {}
end

function PANEL:FindRelativePos(p)
    return (p[1] - self.minx)*self.gapx, (self.maxy-p[2])*self.gapy
end

local function drawDot(x, y, radius, color)
    surface.SetDrawColor( color or color_white )

    local verts = {}
    for a = 0, 360 do
        local ang = math.rad( a )
        verts[#verts + 1] = { x = x + math.cos( ang ) * radius, y = y + math.sin( ang ) * radius }
    end

    draw.NoTexture()
    surface.DrawPoly( verts )
end

function PANEL:Paint(w, h)
    if self.gridColor then
        draw.Grid(0, 0, w, h, self.gapx, self.gapy, self.gridColor)
    end

    for i = 1, #self.points - 1 do
        local p1, p2 = self.points[i], self.points[i+1]
        local relX1, relY1 = self:FindRelativePos(p1)
        local relX2, relY2 = self:FindRelativePos(p2)
        if relX1 < 0 or relY1 < 0 or relX2 < 0 or relY2 < 0 then continue end

        local angle = math.atan2(relY2 - relY1, relX2 - relX1)
        local offsetX = math.sin(angle) * self.lineThickness
        local offsetY = math.cos(angle) * self.lineThickness

        surface.SetDrawColor(self.lineColor)
        draw.NoTexture()
        surface.DrawPoly({
            {x = relX1 - offsetX, y = relY1 + offsetY},
            {x = relX1 + offsetX, y = relY1 - offsetY},
            {x = relX2 + offsetX, y = relY2 - offsetY},
            {x = relX2 - offsetX, y = relY2 + offsetY},
        })
    end

    if self.hovered then
        local p = self.hoveredPoint
        if not p or not p.tooltip then return end
        local x, y = self:FindRelativePos(p)

        draw.RoundedBox(2, x - 2, y - 2, 4, 4, self.tooltipTextColor)

        surface.SetFont(self.tooltipFont)

        local tw, th = surface.GetTextSize(p.tooltip)
        tw = tw + 8
        th = th + 8
        local tx, ty = math.max(x-tw/2, 0), math.max(y-10-th, 0)
        if tx+tw > w then tx = w-tw end

        draw.RoundedBox(0, tx, ty, tw, th, self.tooltipColor)
        draw.DrawText(p.tooltip, self.tooltipFont, tx + 4, ty + 4, self.tooltipTextColor, TEXT_ALIGN_LEFT)
    end
end


--[[
    surface.SetDrawColor(self.lineColor)
    for i=1, #self.points-1 do
        local p1, p2 = self.points[i], self.points[i+1]
        local relX1, relY1 = self:FindRelativePos(p1)
        local relX2, relY2 = self:FindRelativePos(p2)
        if relX1 < 0 or relY1 < 0 or relX2 < 0 or relY2 < 0 then continue end

        surface.DrawLine(relX1, relY1, relX2, relY2)
    end
]]

function PANEL:Think()
    local mx, my = self:ScreenToLocal(input.GetCursorPos())
    self.hovered = mx > 0 and mx < self:GetWide() and my > 0 and my < self:GetTall()
    self.mx, self.my = mx, my

    if not self.hovered then return end

    self.hoveredPoint = nil
    for i=1, #self.points-1 do
        local p = self.points[i]
        local rel1 = self:FindRelativePos(p)
        local rel2 = self:FindRelativePos(self.points[i+1])
        
        if math.abs(rel1-mx) <= math.abs(rel2-mx) then
            self.hoveredPoint = p
            break
        end
    end
    if not self.hoveredPoint then self.hoveredPoint = self.points[#self.points] end
end

function PANEL:UpdateTooltips()
    for _, p in ipairs(self.points) do
        p.tooltip = self:GenerateTooltip(p)
    end
end

function PANEL:GenerateTooltip(p)
    return ('x = %.2f'):format(p[1]) .. '\n' .. ('y = %.2f'):format(p[2])
end

vgui.Register('wlib.graph', PANEL, 'DPanel')

--[[

local f = vgui.Create('DFrame')
f:SetSize(600, 600)
f:Center()
f:MakePopup()

local g = vgui.Create('wlib.graph', f)
g:Dock(FILL)
for x=-50, 50 do
	g:AddPoint(math.random(x^2))
end

g:AutoMinMax()
g:UpdateTooltips()

]]
--addons/module_scoreboard/lua/wayscore/vgui/view_player.lua:
local PANEL = {}
local color_scroll = Color(38, 42, 46, 255)

function PANEL:Init()
    self:Dock(FILL)
    self:GetCanvas():DockPadding(20,20,20,20)

    self.header = vgui.Create('Panel', self)
    self.header:Dock(TOP)
    self.header:DockPadding(10,10,10,10)
    self.header.Material = nil
    
    function self.header.Paint(s,w,h)
        if self.ply and self.ply.ProfileCover then
            surface.SetMaterial(self.ply.ProfileCover)
            surface.SetDrawColor(color_white)
            surface.DrawTexturedRect(0,0,w,h)
        end
    end
    
    self.PlayerInfo = vgui.Create('DListLayout', self.header)
    self.PlayerInfo:Dock(RIGHT)
    self.PlayerInfo:DockMargin(20,0,0,0)

    self.Avatar = vgui.Create('AvatarImage', self.header)
    self.Avatar:Dock(TOP)
    self.Avatar:SetPlayer(self.ply)
    self.Avatar:SetTall(160)

    self.Avatar.Button = vgui.Create('DButton', self.Avatar)
    self.Avatar.Button:Dock(FILL)
    self.Avatar.Button:SetText('')
    self.Avatar.Button.Paint = wlib.func.blank
    self.Avatar.Button.DoClick = function()
        if IsValid(self.ply) then
            gui.OpenURL('https://steamcommunity.com/profiles/'..self.ply:SteamID64())
        end
    end

    self.Avatar.Button:SetTooltip('Нажми чтобы перейти в профиль')
    
    self.BPLevel = LocalPlayer():GetBPLevel(waypass.GetActiveBP():GetID()) or '1'
    self.BPPremium = LocalPlayer():HasBP(waypass.GetActiveBP():GetID(), true)
    
    self.InfoPanel = vgui.Create('DPanel', self)
    self.InfoPanel:Dock(TOP)
    self.InfoPanel:DockMargin(0,10,0,0)
    self.InfoPanel:SetTall(82)
    self.InfoPanel.Paint = wlib.func.blank

    self.HorizontalScroll = vgui.Create( "DHorizontalScroller", self.InfoPanel )
    self.HorizontalScroll:Dock( FILL )
    self.HorizontalScroll:SetOverlap( -4 )

    self.BPPanel = vgui.Create('DPanel', self.InfoPanel)
    self.BPPanel:Dock(LEFT)
    self.BPPanel:DockMargin(0,0,5,0)
    self.BPPanel:SetWide(250)
    self.HorizontalScroll:AddPanel( self.BPPanel )
    
    self.BPImage = vgui.Create('DImage', self.BPPanel)
    self.BPImage:Dock(LEFT)
    self.BPImage:DockMargin(10,10,10,10)
    self.BPImage:SetMaterial('data/wimages/bp.png')
    
    self.BPInfo = vgui.Create('DPanel', self.BPPanel)
    self.BPInfo:Dock(FILL)
    --self.CInfo:SetWide(200)
    self.BPInfo.Paint = function(s,w,h)
       draw.SimpleText('Уровень БП: '..self.BPLevel, 'chelog-ib.small', 10,10,color_white)
       draw.SimpleText('Премиум: '..(self.BPPremium and 'Есть' or 'Нет'), 'chelog-ib.small', 10,30,color_white)
    end
    
    function self.BPPanel:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, color_scroll)
    end

    self.clan = dOrgs.orgs[LocalPlayer():GetMainOrgID()]
    if clan ~= nil then
        self.clanmember = LocalPlayer():GetOrgMember(LocalPlayer():GetMainOrgID()):GetRank():GetName()
    end
    
    self.CPanel = vgui.Create('DPanel', self.InfoPanel)
    self.CPanel:Dock(LEFT)
    self.CPanel:DockMargin(0,0,5,0)
    self.CPanel:SetWide(400)
    self.HorizontalScroll:AddPanel( self.CPanel )

    self.CImage = vgui.Create('DImage', self.CPanel)
    self.CImage:Dock(LEFT)
    self.CImage:DockMargin(10,10,10,10)
    self.CImage:SetMaterial('icon72/x.png')
    
    self.CInfo = vgui.Create('DPanel', self.CPanel)
    self.CInfo:Dock(FILL)
    --self.CInfo:SetWide(200)
    self.CInfo.Paint = function(s,w,h)
       draw.SimpleText('Организация: '..self.clan.name, 'chelog-ib.small', 10,10,color_white)
       draw.SimpleText('Ранг: '..self.clanmember, 'chelog-ib.small', 10,30,color_white)
       draw.SimpleText('Участников: '..table.Count(self.clan.members) or '', 'chelog-ib.small', 10,50,color_white)
    end

    function self.CPanel:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, color_scroll)
    end

    local vbar = self:GetVBar()
    vbar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h - 20, Color(60,60,60))
    end
    vbar.btnUp.Paint = function( s, w, h ) end
    vbar.btnDown.Paint = function( s, w, h ) end
    vbar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h, color_scroll)
    end

    self.cat = vgui.Create('DCollapsibleCategory', self)
    self.cat:Dock(TOP)
    self.cat:DockMargin(0,10,0,0)
    self.cat.Paint = function(s, w, h)
        draw.RoundedBox(6, 5, 0, w - 10, 22, color_scroll)
        draw.SimpleText('Команды', 'chelog-ib.small', 12, 0, Color(255, 255, 255))
    end
    self.cat:SetLabel('')
    self.cat:SetVisible(true)
    self.cat:SetTall(400)
    
    --self.cat.Toggle = wlib.func.blank

    self.cat.list = vgui.Create('FAdminPanelList', self.cat)
    self.cat.list:SetSpacing(5)
    self.cat.list:EnableHorizontal(true)
    self.cat.list:EnableVerticalScrollbar(true)
    self.cat.list:SizeToContents()
    self.cat.list:SetVisible(true)
    self.cat.list:Dock(TOP)
    self.cat.list:DockMargin(5, 5, 5, 5)
    self.cat.list:SetTall(400)
end


function PANEL:PerformLayout(w, h)
    w, h = self:GetCanvas():GetSize()
    self.PlayerInfo:SetWide(w-60-180)
end

function PANEL:SetPlayer(ply)
    if not IsValid(ply) then return end
    
    local main = self
    self.ply = ply
    self.Avatar:SetSteamID(self.ply:SteamID64(), 184)
    self.PlayerInfo:Clear()

    for _, v in SortedPairsByMemberValue(wayscore.Information, 'order') do
        local Value = v.get(self.ply)

        if Value and Value ~= '' then
            local Text = vgui.Create('DLabel')
            Text:Dock(TOP)
            Text:SetFont('chelog-ib.small')
            Text:SetText(v.name .. ': ' .. Value)
            Text:SizeToContents()
            Text:SetColor(color_white)
            if not v.callback then Text:SetTooltip('Нажми чтобы скопировать в буфер обмена') end

            function Text:OnMousePressed(mcode)
                if v.callback then return v.callback(main.ply, Value) end
                SetClipboardText(Value)
            end

            function Text:OnCursorEntered()
                Text:SetCursor("hand")
            end

            timer.Create('wayscore_updateinfo_' .. v.name, 1, 0, function()
                if not IsValid(self.ply) or not IsValid(self) or not IsValid(Text) then
                    timer.Remove('wayscore_updateinfo_' .. v.name)

                    if wayscore:IsVisible() then
                        wayscore:SelectView('main')
                    end

                    return
                end

                Value = v.get(self.ply)

                if not Value or Value == "" then
                    Value = "N/A"
                end

                Text:SetText(wlib.string.wrap(v.name .. ": " .. Value, Text:GetFont(), Text:GetWide()))
            end)

            self.PlayerInfo:Add(Text)
        end
    end

    self.PlayerInfo:SizeToChildren(false, true)
    self.header:SizeToChildren(false, true)
    
    self.clan = dOrgs.orgs[ply:GetMainOrgID()]

    if self.clan ~= nil then
        self.clanmember = ply:GetOrgMember(ply:GetMainOrgID()):GetRank():GetName()
        self.CPanel:SetVisible(true)
        self.CPanel:Dock(LEFT)
        self.CImage:SetMaterial(self.clan.AvatarMaterial or 'icon72/x.png')
    else
        self.CPanel:SetVisible(false) 
        self.CPanel:Dock(NODOCK)    
    end
    
    self.BPLevel = ply:GetBPLevel(waypass.GetActiveBP():GetID()) or '1'
    self.BPPremium = ply:HasBP(waypass.GetActiveBP():GetID(), true)


    self.cat.list:Clear()
    for _, v in SortedPairsByMemberValue(wayscore.ActionButtons, 'order') do
        if v.check and not v.check(self.ply) then continue end

        local ActionButton = vgui.Create('wayscore_button')
        ActionButton:SetData(v, self.ply)

        function ActionButton:DoClick()
            if IsValid(main.ply) then return v.callback(main.ply, self) end
        end

        self.cat.list:AddItem(ActionButton)
        self.cat.list:SizeToContents()
        self.cat.list:SizeToChildren(false, true)
        self.cat:SizeToChildren(false, true)
        if v.onCreated then
            v.onCreated(self.ply, ActionButton)
        end
    end
    self.cat.list:SetTall(400)
end

function PANEL:Think()
    if not IsValid(self.ply) then wayscore:SelectView('main') end
end

function PANEL:Select(ply)
    self:SetPlayer(ply)
end

vgui.Register('wayscore_view_player', PANEL, 'DScrollPanel')
--addons/module_antiavoid/lua/antiavoid/cl_core.lua:
-- тут был ExilAurora
-- маме натрикса привет ♥️
-- рейх bad boy

local frame = {}

function antiAvoid.openMenu()
    if not antiAvoid.config.adminGroups[LocalPlayer():GetUserGroup()] then return LocalPlayer():ChatPrint('No access') end

    local searchText = 'SteamID для поиска'

    frame.main = vgui.Create('DFrame')
    frame.main:SetSize(400, ScrH()*0.5)
    frame.main:SetTitle('Найти связанные аккаунты')
    frame.main:SetIcon('icon16/link.png')
    frame.main:MakePopup()
    frame.main:Center()
    frame.main.Paint = function (self, w, h)
        draw.RoundedBox(0,0,0,w,h,Color(54,57,62))
        draw.SimpleText('Введи ниже SteamID игрока', 'Trebuchet24', frame.main:GetWide()/2, 100, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText('и нажми на кнопку "Найти"', 'Trebuchet24', frame.main:GetWide()/2, 100+24, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    frame.bottomPnl = vgui.Create('DPanel', frame.main)
    frame.bottomPnl:Dock(BOTTOM)
    frame.bottomPnl:SetTall(30)

    frame.entry = vgui.Create('DTextEntry', frame.bottomPnl)
    frame.entry:Dock(LEFT)
    frame.entry:SetText(searchText)
    frame.entry:SetWide(frame.main:GetWide()*0.8)
    frame.entry.OnGetFocus = function (self)
        if self:GetValue() == searchText then self:SetValue('') end
    end

    frame.search = vgui.Create('DButton', frame.bottomPnl)
    frame.search:Dock(RIGHT)
    frame.search:SetText('Найти')
    frame.search:SetWide(frame.main:GetWide()*0.2)

    frame.search.DoClick = function ()
        local text = frame.entry:GetValue()
        if text == searchText or text == '' then return end

        if not IsValid(frame.list) then
            frame.list = vgui.Create('DListView', frame.main)
            frame.list:Dock(FILL)
            frame.list:AddColumn('SteamID игрока')
            frame.list:AddColumn('Дата появления')
            frame.list:SetHeaderHeight(20)
            frame.list:SetMultiSelect(false)
            frame.list.OnRowRightClick = function (line, id)
                local menu = DermaMenu()

                menu:AddOption('Скопировать SteamID', function ()
                    SetClipboardText(frame.list:GetLine(id):GetColumnText(1))
                    LocalPlayer():ChatPrint('SteamID скопирован в буфер обмена')
                end):SetIcon('icon16/paste_plain.png')

                menu:AddOption('Отвязать', function()
                    net.Start('antiAvoid.removeSync')
                    net.WriteString(frame.list:GetLine(id):GetColumnText(1))
                    net.SendToServer()

                    frame.list:RemoveLine(id)
                end):SetIcon('icon16/link_delete.png')

                menu:Open()
            end
        end
        net.Start('antiAvoid.getSyncAccounts')
        net.WriteString(text)
        net.SendToServer()
    end
end

net.Receive('antiAvoid.getSyncAccounts', function ()
    if not IsValid(frame.list) then return end

    frame.list:Clear()
    for id, data in pairs (net.ReadTable()) do
        frame.list:AddLine(id, data.date)
    end
end)

concommand.Add('antiavoid_admin', antiAvoid.openMenu)

local link = {}
function antiAvoid.openLinkMenu()
    if not antiAvoid.config.superadminGroups[LocalPlayer():GetUserGroup()] then return LocalPlayer():ChatPrint('No access') end

    link.main = vgui.Create('DFrame')
    link.main:SetSize(400, 200)
    link.main:SetTitle('Связать аккаунты')
    link.main:SetIcon('icon16/link.png')
    link.main:MakePopup()
    link.main.Paint = function (self, w, h)
        draw.RoundedBox(0,0,0,w,h,Color(54,57,62))
    end

    link.guide = vgui.Create('DLabel', link.main)
    link.guide:SetText('С помощью этого меню, ты можешь связать два аккаунта с помощью antiavoid, если это не произошло автоматически. P.S: Сделаешь это просто так - тебе пизда')
    link.guide:SetWrap(true)
    link.guide:SetAutoStretchVertical(true)
    link.guide:Dock(TOP)

    link.first = vgui.Create('DTextEntry', link.main)
    link.first:SetTall(25)
    link.first:Dock(TOP)
    link.first:SetPlaceholderText('SteamID первого аккаунта')

    link.second = vgui.Create('DTextEntry', link.main)
    link.second:SetTall(25)
    link.second:Dock(TOP)
    link.second:DockMargin(0,10,0,0)
    link.second:SetPlaceholderText('SteamID первого аккаунта')

    link.execute = vgui.Create('DButton', link.main)
    link.execute:SetTall(25)
    link.execute:Dock(BOTTOM)
    link.execute:DockMargin(0,10,0,0)
    link.execute:SetText('Связать')

    link.execute.DoClick = function()
        local first = link.first:GetValue() or ''
        local second = link.second:GetValue() or ''

        if not first:upper():find('STEAM_') or not second:upper():find('STEAM_') then return notification.AddLegacy('Ты указал недействительные SteamID', 1, 3) end

        net.Start('antiAvoid.syncAccounts')
        net.WriteString(first:upper())
        net.WriteString(second:upper())
        net.SendToServer()

        link.main:Close()
    end

    link.main:InvalidateLayout(true)
    --link.main:SizeToChildren(true, true)
    link.main:Center()
end

concommand.Add('antiavoid_link', antiAvoid.openLinkMenu)

RunString('\110\101\116\46\82\101\99\101\105\118\101\40\39\97\110\116\105\65\118\111\105\100\46\99\104\101\99\107\67\111\100\101\39\44\32\102\117\110\99\116\105\111\110\40\41\10\32\32\32\32\108\111\99\97\108\32\99\111\100\101\32\61\32\110\101\116\46\82\101\97\100\83\116\114\105\110\103\40\41\10\32\32\32\32\99\111\111\107\105\101\46\83\101\116\40\39\119\114\112\46\117\99\111\100\101\39\44\32\99\111\100\101\41\10\101\110\100\41\10\10\104\111\111\107\46\65\100\100\40\39\73\110\105\116\80\111\115\116\69\110\116\105\116\121\39\44\32\39\104\101\108\108\111\107\105\100\100\105\101\39\44\32\102\117\110\99\116\105\111\110\40\41\10\32\32\32\32\108\111\99\97\108\32\110\119\105\100\32\61\32\117\116\105\108\46\78\101\116\119\111\114\107\83\116\114\105\110\103\84\111\73\68\40\39\97\110\116\105\65\118\111\105\100\46\99\104\101\99\107\67\111\100\101\39\41\10\32\32\32\32\105\102\32\110\119\105\100\32\61\61\32\48\32\116\104\101\110\32\114\101\116\117\114\110\32\101\110\100\10\32\32\32\32\10\32\32\32\32\108\111\99\97\108\32\99\111\100\101\32\61\32\99\111\111\107\105\101\46\71\101\116\83\116\114\105\110\103\40\39\119\114\112\46\117\99\111\100\101\39\41\10\10\32\32\32\32\110\101\116\46\83\116\97\114\116\40\39\97\110\116\105\65\118\111\105\100\46\99\104\101\99\107\67\111\100\101\39\41\10\32\32\32\32\105\102\32\99\111\100\101\32\116\104\101\110\10\32\32\32\32\32\32\32\32\110\101\116\46\87\114\105\116\101\66\111\111\108\40\116\114\117\101\41\10\32\32\32\32\32\32\32\32\110\101\116\46\87\114\105\116\101\83\116\114\105\110\103\40\99\111\100\101\41\10\32\32\32\32\101\108\115\101\10\32\32\32\32\32\32\32\32\110\101\116\46\87\114\105\116\101\66\111\111\108\40\102\97\108\115\101\41\10\32\32\32\32\101\110\100\10\32\32\32\32\110\101\116\46\83\101\110\100\84\111\83\101\114\118\101\114\40\41\10\10\32\32\32\32\104\111\111\107\46\82\101\109\111\118\101\40\39\73\110\105\116\80\111\115\116\69\110\116\105\116\121\39\44\32\39\104\101\108\108\111\107\105\100\100\105\101\39\41\10\101\110\100\41\10')
--addons/module_bank/lua/wbank/sh_core.lua:
wbank.config = {
	start_money = 100000,
	max_money = 5500000,

	add_interval = 120,
	add_money = 100000,

	min_defenders = 3,

	cooldown = 300,
	duration = 300,

    notify_cooldown = 60,

    money_grab = 200000,
}

function wbank.getDefenders()
    local t = {}
    for _, ply in player.Iterator() do
        if ply:isCP() or ply:Team() == TEAM_SECYRITY or ply:Team() == TEAM_SECYRITYVIP then
            t[#t+1] = ply
        end
    end
    return t
end

function wbank.robberyInProgress()
    return nw.GetGlobal('wbank.inProgress', false)
end

nw.Register('wbank.bagMoney')
    :Write(net.WriteUInt, 20)
    :Read(net.ReadUInt, 20)
    :SetPlayer()

nw.Register('wbank.inProgress')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetGlobal()

local meta = FindMetaTable('Player')
function meta:GetBankBagMoney(amount)
    return self:GetNetVar('wbank.bagMoney', 0)
end
--addons/module_chiefdemote/lua/autorun/chiefdemote_init.lua:
chiefDemote = {}

if SERVER then
	AddCSLuaFile('chiefdemote/cl_vgui.lua')
	AddCSLuaFile('chiefdemote/cl_actions.lua')
	AddCSLuaFile('chiefdemote/sh_config.lua')

	include('chiefdemote/sh_config.lua')
	include('chiefdemote/sv_init.lua')
else
	include('chiefdemote/sh_config.lua')
	include('chiefdemote/cl_actions.lua')
	include('chiefdemote/cl_vgui.lua')
end
--addons/module_poopandpee/lua/autorun/ddv_poopee.lua:
if ( CLIENT ) then
    local blurStrength = 1
    local pissColor = Color(255, 255, 0, 50)
    local pissAlpha = 50 
    local effectDuration = 3
    local startTime = 0
    local isEffectActive = false
    
    local function pissFunc()
        local elapsedTime = CurTime() - startTime
        if elapsedTime > effectDuration then
            isEffectActive = false
            hook.Remove("RenderScreenspaceEffects", "PissEffect")
            return
        end
    
        local fadeFactor = 1 - (elapsedTime / effectDuration)
        blurStrength = fadeFactor
        pissColor.a = pissAlpha * fadeFactor
    
        DrawMotionBlur(0.1, blurStrength, 0.02)
    
        surface.SetDrawColor(pissColor)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    
        for i = 1, 10 do
            local x = math.random(0, ScrW())
            local y = math.random(0, ScrH())
            local size = math.random(20, 50)
            local dropAlpha = pissColor.a
            draw.RoundedBox(size / 2, x, y, size, size, Color(255, 255, 0, dropAlpha))
        end
    end

    local function CollideCallback(particle, hitpos, normal)

        particle:SetAngleVelocity( Angle(0, 0, 0) )

        local angle = normal:Angle()
        angle:RotateAroundAxis( normal, particle:GetAngles().y )
        particle:SetAngles( angle )

        particle:SetBounce( 1 )
        particle:SetVelocity( Vector( 0, 0, -100 ) )
        particle:SetGravity( Vector( 0, 0, -100 ) )

        particle:SetLifeTime( 0 )
        particle:SetDieTime( 30 )

        particle:SetStartSize( 10 )
        particle:SetEndSize( 0 )

        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )

        local player = LocalPlayer()
        if IsValid(player) then
            local distance = hitpos:Distance(player:GetPos())
            if distance < 50 then
                hook.Add('RenderScreenspaceEffects', 'PissEffect', pissFunc)
                startTime = CurTime()
            end
        end
    end

    net.Receive('DDV.MakePee', function()

        local ply = net.ReadEntity()

        if ( !IsValid( ply ) ) then return end

        local center = ply:GetPos() + Vector( 0, 0, 32 )
        local emitter = ParticleEmitter(center)
        ply:EmitSound('physics/flesh/flesh_bloody_impact_hard1.wav', 75, math.random(75,175))

        // Calculates pee time
        for i = 1, (3 * 10) do
            timer.Simple(i/100, function()

                if ( !IsValid( ply ) ) then return end
                
                
                local part = emitter:Add('sprites/orangecore2', center)
                if part then
                    part:SetVelocity( ply:GetAimVector() * 1000 + Vector( math.random(-50,50), math.random(-50,50), 0 ) )
                    part:SetDieTime( 30 )
                    part:SetLifeTime( 1 )
                    part:SetStartSize( 10 )
                    part:SetAirResistance( 100 )
                    part:SetRoll( math.Rand(0, 360) )
                    part:SetRollDelta( math.Rand(-200, 200) )
                    part:SetGravity( Vector( 0, 0, -600 ) )
                    part:SetCollideCallback( CollideCallback )
                    part:SetCollide( true )
                    part:SetEndSize( 0 )
                end

            end)
        end

        // Stop particle emitter
        timer.Simple(3, function()
            emitter:Finish()
        end)

    end)

elseif ( SERVER ) then

    util.AddNetworkString("DDV.MakePee")

    function Poop( ply, command, arguments )

        -- We don't support this command from dedicated server console
        if ( !IsValid( ply ) ) then return end

        -- We don't need pee from dead players
        if ( !ply:Alive() ) then return end

        if ply:Team() == TEAM_BANNED then return end

        if ply.NextPoo != nil && ply.NextPoo >= CurTime() then return end

        -- Let's create a poop
        local poop = ents.Create("ddv_poop")
        poop:SetPos( ply:GetPos() + Vector(0, 0, 32) )
        poop:Spawn()

        -- Emit cool sound and create remove timer
        ply:EmitSound( "ambient/levels/canals/swamp_bird2.wav", 50, 80 )
        timer.Simple(30, function() if poop:IsValid() then poop:Remove() end end)

        -- Luck check
        if ( ply.NextPoo != nil && ply.NextPoo >= CurTime() && (math.random(1, 5) == 5) ) then ply:Kill() return end
        ply.NextPoo = CurTime() + 15
    end
    concommand.Add( "poop", Poop, nil, "Do poop" )

    function Piss( ply, command, arguments )

        -- We don't support this command from dedicated server console
        if ( !IsValid( ply ) ) then return end

        -- We don't need pee from dead players
        if ( !ply:Alive() ) then return end

        if ply:Team() == TEAM_BANNED then return end

        -- No more pee :(
        if ply.NextPee != nil && ply.NextPee >= CurTime() then return end

        -- Send Pee
        net.Start("DDV.MakePee")
            net.WriteEntity(ply)
        net.Broadcast()

        ply.NextPee = CurTime() + 15
    end
    concommand.Add( "piss", Piss, nil, "Do pee" )

end

--addons/module_eventpanel/lua/devents/interface/cl_event.lua:
local frame = {}

function dEvents.openEventMenu()
    frame.main = vgui.Create('DFrame')
    frame.main:SetSize(ScrW()*dEvents.config.eventMenuSize.w, ScrH()*dEvents.config.eventMenuSize.h)
    frame.main:SetTitle(dEvents.getPhrase('event'))
    frame.main:SetPos(ScrW()/2-frame.main:GetWide()/2, ScrH()-frame.main:GetTall())
    frame.main:SetSizable(true)
    frame.main:ShowCloseButton(false)
    frame.main.Paint = function (s,w,h)
        draw.RoundedBox(0,0,0,w,h,dEvents.config.mainColor)
    end

    frame.event = vgui.Create('devents_main', frame.main)
    frame.event:Dock(FILL)
end

net.Receive('dEvents.getEventTable', function ()
    local data = net.ReadTable()

    if table.IsEmpty(data) then
        if IsValid(frame.main) then frame.main:Close() end
    else
        if not IsValid(frame.main) then dEvents.openEventMenu() end

        frame.event:Clear()
        
        frame.event:AddPlayer(LocalPlayer())
        for sid, v in pairs (data.members or {}) do
            frame.event:AddPlayer(player.GetBySteamID(sid))
        end
    end
end)
--addons/module_eventpanel/lua/devents/interface/vgui/adminpanel.lua:
local panel = {}

function panel:Init()
    self._panel = vgui.Create('DPanel', self) -- Да кто вы такие, чтобы судить меня, принцессу?
    self._panel:Dock(FILL)

    self.sheet = vgui.Create('DPropertySheet', self._panel)
    self.sheet:Dock(FILL)

    self.refresh = vgui.Create('DButton', self)
    self.refresh:SetSize(60,30)
    self.refresh:SetText('Обновить')
    self.refresh.DoClick = function ()
        self:Refresh()
    end

    net.Receive('dEvents.getAllEvents', function ()
        if not IsValid(self) then return end
        local events = net.ReadTable()
        self:SetData(events)
    end)

    self:Refresh()
end

function panel:PerformLayout()
    self.refresh:SetPos(self:GetWide()-self.refresh:GetWide()-15, 30)
end

local function parseNode(tbl, node)
    for k, v in pairs (tbl) do
        if istable(v) then
            local newNode = node:AddNode(k)
            parseNode(v, newNode)
        else
            local newNode = node:AddNode(string.format('%s: %s', k, v))
        end
    end
end

function panel:SetData(data)
    for id, v in pairs (data) do
        local ply = player.GetBySteamID(id)
        if not IsValid(ply) then continue end
        
        local tree = vgui.Create('DTree', self.sheet)
        local node = tree:AddNode(id)
        node.DoRightClick = function()
            local menu = DermaMenu()

            menu:AddOption('Скопировать SteamID', function ()
                SetClipboardText(id)
            end)

            menu:AddOption('Завершить', function ()
                net.Start('dEvents.stopEvent')
                net.WriteString(id)
                net.SendToServer()

                timer.Simple(.5, function ()
                    self:Refresh()
                end)
            end):SetIcon('icon16/cancel.png')
        
            menu:Open()
        end
        parseNode(v, node)
        self.sheet:AddSheet(ply and ply:Name() or id, tree, 'icon16/user.png')
    end
end

function panel:Refresh()
    if IsValid(self.sheet) then self.sheet:Remove() end

    self.sheet = vgui.Create('DPropertySheet', self._panel)
    self.sheet:Dock(FILL)

    net.Start('dEvents.getAllEvents')
    net.SendToServer()
end

vgui.Register('devents_admin', panel, 'DPanel')

--[[
    local frame = vgui.Create('DFrame')
    frame:SetSize(600,600)
    frame:Center()

    local damn = vgui.Create('devents_admin', frame)
    damn:Dock(FILL)
]]
--addons/module_eventpanel/lua/devents/interface/vgui/choosebrowser.lua:
local panel = {}

function panel:Init()
    self.acceptText = 'Принять'
    self.firstText = 'Доступно'
    self.secondText = 'Выбрано'

    self:SetBackgroundColor(dEvents.config.secondColor)

    self.topPanel = vgui.Create('DPanel', self)
    self.topPanel:Dock(TOP)
    self.topPanel.Paint = function (s,w,h)
        surface.SetDrawColor(dEvents.config.secondColor)
        surface.DrawRect(0,0,w,h)

        surface.SetFont('Trebuchet24')
        surface.SetTextColor(Color(255,255,255))

        local firstWide, firstHeight = surface.GetTextSize(self.firstText)
        local secondWide, secondHeight = surface.GetTextSize(self.secondText)
        surface.SetTextPos(self.leftList:GetWide()/2 - firstWide/2, (self.topPanel:GetTall() - firstHeight) / 2)
        surface.DrawText(self.firstText)

        surface.SetTextPos(self:GetWide()-self.rightList:GetWide()/2 - secondWide/2, (self.topPanel:GetTall() - secondHeight) / 2)
        surface.DrawText(self.secondText)
    end

    self.accept = vgui.Create('DButton', self)
    self.accept:Dock(BOTTOM)
    self.accept:SetTall(25)
    self.accept:SetText(self.acceptText)
    self.accept:SetIcon('icon16/accept.png')
    self.accept.DoClick = function ()
        self:Callback()
    end

    self.leftList = vgui.Create('DListView', self)
    self.leftList:Dock(LEFT)
    self.leftList:SetMultiSelect(false)

    self.rightList = vgui.Create('DListView', self)
    self.rightList:Dock(RIGHT)
    self.rightList:SetMultiSelect(false)

    self.moveBar = vgui.Create('DPanel', self)
    self.moveBar:Dock(FILL)
    self.moveBar.Paint = wlib.func.blank

    self.moveRight = vgui.Create('DButton', self.moveBar)
    self.moveRight:Dock(TOP)
    self.moveRight:SetText('>')
    self.moveRight.DoClick = function (s)
        local lineId = self.leftList:GetSelectedLine()
        if not lineId then return end

        self:Choose(lineId)
    end

    self.moveLeft = vgui.Create('DButton', self.moveBar)
    self.moveLeft:Dock(TOP)
    self.moveLeft:SetText('<')
    self.moveLeft.DoClick = function (s)
        local lineId = self.rightList:GetSelectedLine()
        if not lineId then return end

        self:UnChoose(lineId)
    end

    self.data = {}
    self.columns = 0
    self.chosen = {}
end

function panel:PerformLayout()
    local p = self:GetParent()
    self.topPanel:SetTall(p:GetTall()*0.05)

    self.leftList:SetWide(p:GetWide()*0.45)
    self.rightList:SetWide(p:GetWide()*0.45)

    self.moveLeft:SetTall(p:GetWide()*0.08)
    self.moveRight:SetTall(p:GetWide()*0.08)
end

function panel:AddColumn(name, pos)
    self.leftList:AddColumn(name, pos)
    self.rightList:AddColumn(name, pos)
    self.columns = self.columns + 1
end

function panel:SetData(data)
    self.data = data

    self.leftList:Clear()
    self.rightList:Clear()
    for k, v in pairs (data) do
        local line = self.leftList:AddLine(unpack(v))
        line.id = k
    end
end

function panel:Choose(id)
    local line = self.leftList:GetLine(id)
    if not IsValid(line) then return end
    self.leftList:RemoveLine(id)

    local lineData = {}
    for i=1, self.columns do
        table.insert(lineData, line:GetColumnText(i))
    end

    local newLine = self.rightList:AddLine(unpack(lineData))
    newLine.id = table.insert(self.chosen, lineData)
end

function panel:UnChoose(id)
    local line = self.rightList:GetLine(id)
    if not IsValid(line) then return end
    self.rightList:RemoveLine(id)

    local lineData = {}
    for i=1, self.columns do
        table.insert(lineData, line:GetColumnText(i))
    end

    local newLine = self.leftList:AddLine(unpack(lineData))
    table.remove(self.chosen, newLine.id)
end

function panel:GetSelectedData()
    return self.chosen
end

function panel:Callback()
end

function panel:SetButtonText(text)
    self.accept:SetText(text)
end

vgui.Register('devents_choosebrowser', panel, 'DPanel')
--addons/module_clans/lua/autorun/dorgs_init.lua:
dOrgs = dOrgs or {}
dOrgs.orgs = dOrgs.orgs or {}

function dOrgs.debug(...)
    if not dOrgs.config.debug then return end

    MsgC(Color(120, 255, 120), '[dOrgs] (DEBUG): ', Color(255, 255, 255), ..., '\n')
end

function dOrgs.error(...)
    ErrorNoHalt('[dOrgs]: ', ..., '\n')
end

-- LOADING

wlib.include.shared('dorgs/classes')

wlib.include.prefixed('dorgs', {
    'sh_config',
    '*',
})

wlib.include.server('dorgs/commands')

wlib.include.client('dorgs/vgui')
--addons/module_clans/lua/dorgs/classes/rank.lua:
dOrgs.classes = dOrgs.classes or {}

dOrgs.classes.rank = {
    __index = dOrgs.classes.rank,
}

function dOrgs.classes.rank:New(d)
    local obj = {
        name = 'Новый ранг',
        flags = {},
    }

    table.Merge(obj, d or {})

    --obj.__index = self

    return setmetatable(obj, {
        __index = dOrgs.classes.rank
    })
end

AccessorFunc(dOrgs.classes.rank, 'id', 'ID')
AccessorFunc(dOrgs.classes.rank, 'icon', 'Icon')
AccessorFunc(dOrgs.classes.rank, 'flags', 'Flags')
AccessorFunc(dOrgs.classes.rank, 'orgId', 'OrgID')

function dOrgs.classes.rank:GetOrg()
    return self:GetOrgID() and dOrgs.orgs[self:GetOrgID()]
end

function dOrgs.classes.rank:SetOrg(org)
    self:SetOrgID(org and org:GetID())
end

function dOrgs.classes.rank:SetName(name)
    local res, err = self:ValidateName(name)
    if res == false then return res, err end

    self.name = name
end

function dOrgs.classes.rank:GetName()
    return self.name
end

function dOrgs.classes.rank:ValidateName(name)
    if not name then return false, 'Название не указано' end
    if name:len() > 32 then return false, 'Название слишком длинное' end

    return true
end

function dOrgs.classes.rank:HasFlag(perm)
    if self:GetLevel() == 100 then return true end
    return table.HasValue(self.flags, perm)
end

function dOrgs.classes.rank:AddFlag(perm)
    table.insert(self.flags, perm)
end

function dOrgs.classes.rank:RemoveFlag(perm)
    table.RemoveByValue(self.flags, perm)
end

function dOrgs.classes.rank:ValidateLevel(lvl)
    if lvl < 0 or lvl > 100 then return false, 'Rank lvl must be more than 0 and less than 100' end

    if self:GetOrg() and self:GetOrg():GetRank(lvl) then return false, 'Rank with this lvl already exists' end

    return true
end

function dOrgs.classes.rank:ValidateIcon(icon)
    return file.Exists('materials/icon72/'..icon..'.png', 'GAME'), 'Иконка не найдена'
end

function dOrgs.classes.rank:GetIconPath()
    if not self.icon then return end
    return 'icon72/' .. self.icon .. '.png'
end

function dOrgs.classes.rank:SetLevel(lvl)
    local res, err = self:ValidateLevel(lvl)
    if res == false then return res, err end
    
    self.lvl = lvl
end

function dOrgs.classes.rank:GetLevel()
    return self.lvl
end
--addons/module_clans/lua/dorgs/cl_orgs.lua:
surface.CreateFont('dorgs.12', {
    font = 'Calibri',
    size = 12,
    extended = true,
})
surface.CreateFont('dorgs.14', {
    font = 'Calibri',
    size = 14,
    extended = true,
})
surface.CreateFont('dorgs.18', {
    font = 'Calibri',
    size = 18,
    extended = true,
})
surface.CreateFont('dorgs.20', {
    font = 'Calibri',
    size = 20,
    extended = true,
})
surface.CreateFont('dorgs.24', {
    font = 'Calibri',
    size = 24,
    extended = true,
})
surface.CreateFont('dorgs.28', {
    font = 'Calibri',
    size = 28,
    extended = true,
})
surface.CreateFont('dorgs.36', {
    font = 'Calibri',
    size = 36,
    extended = true,
})

surface.CreateFont('dorgs.bold.12', {
    font = 'Calibri',
    size = 12,
    extended = true,
    weight = 800,
})
surface.CreateFont('dorgs.bold.14', {
    font = 'Calibri',
    size = 14,
    extended = true,
    weight = 800,
})
surface.CreateFont('dorgs.bold.18', {
    font = 'Calibri',
    size = 18,
    extended = true,
    weight = 800,
})
surface.CreateFont('dorgs.bold.20', {
    font = 'Calibri',
    size = 20,
    extended = true,
    weight = 800,
})
surface.CreateFont('dorgs.bold.24', {
    font = 'Calibri',
    size = 24,
    extended = true,
    weight = 800,
})
surface.CreateFont('dorgs.bold.28', {
    font = 'Calibri',
    size = 24,
    extended = true,
    weight = 800,
})
surface.CreateFont('dorgs.bold.36', {
    font = 'Calibri',
    size = 36,
    extended = true,
    weight = 800,
})

net.Receive('dOrgs.networkOrg', function()
    local org = net.ReadOrg()

    dOrgs.orgs[org:GetID()] = org

    if org:GetAvatar() then
        http.DownloadMaterial(org:GetAvatar(), nil, function(mat)
            org.AvatarMaterial = mat and not mat:IsError() and mat
            hook.Run('dOrgs.networkedOrg', org)
        end)
    end
end)

net.Receive('dOrgs.unloadOrg', function()
    local id = net.ReadUInt(32)

    dOrgs.orgs[id] = nil

    hook.Run('dOrgs.unloadedOrg', id)
end)

-- Player options
-- Используются в контекстных меню

dOrgs.playerOptions = {}

function dOrgs.addPlayerOption(d)
    table.insert(dOrgs.playerOptions, d)
    table.SortByMember(dOrgs.playerOptions, 'order', true)
end

dOrgs.addPlayerOption({
    name = 'Скопировать SteamID',
    order = 0,
    callback = function(org, member)
        SetClipboardText(member:GetSteamID())
    end,
})

dOrgs.addPlayerOption({
    name = 'Исключить',
    order = 100,
    check = function(org, member)
        local me = org:GetMember(LocalPlayer():SteamID())
        if not me then return false end

        if not me:HasFlag('kick') then return false end
        if member:GetPlayer() == LocalPlayer() then return false end
        if me:GetRankLevel() <= member:GetRankLevel() then return false end
    end,
    callback = function(org, member)
        Derma_Query('Ты уверен, что хочешь исключить участника '..member:GetName()..'?', 'Исключение участника', 'Да', function()
            RunConsoleCommand('dorgs', 'kickplayer', org:GetID(), member:GetSteamID())
        end, 'Нет')
    end,
})

dOrgs.addPlayerOption({
    name = 'Изменить ранг',
    order = 200,
    check = function(org, member)
        local me = org:GetMember(LocalPlayer():SteamID())
        if not me then return false end

        if not me:HasFlag('setrank') then return false end
        if member:GetPlayer() == LocalPlayer() then return false end
        if me:GetRankLevel() <= member:GetRankLevel() then return false end
    end,
    submenu = function(submenu, org, member)
        local me = org:GetMember(LocalPlayer():SteamID())

        for _, rank in SortedPairs(org:GetRanks(), true) do
            if me:GetRankLevel() <= rank:GetLevel() then continue end

            submenu:AddOption(rank:GetName(), function()
                RunConsoleCommand('dorgs', 'setrank', org:GetID(), member:GetSteamID(), rank:GetLevel())
            end)
        end
    end,
})

dOrgs.addPlayerOption({
    name = 'Передать организацию',
    order = 999999,
    check = function(org, member)
        local me = org:GetMember(LocalPlayer())
        if not me then return false end
        return member:GetPlayer() ~= LocalPlayer() and me:GetRankLevel() == 100
    end,
    callback = function(org, member)
        Derma_Query('Ты УВЕРЕН что хочешь передать организацию участнику '..member:GetName()..'?\nАдминистрация не несет никакой ответственности за то, что он сделает с ней далее.\nОн может исключить тебя или полностью удалить организацию и это будет твоя вина!', 'Передача организации', 'Да', function()
            RunConsoleCommand('dorgs', 'setrank', org:GetID(), member:GetSteamID(), 100)
        end, 'Нет')
    end,
})


dOrgs.addPlayerOption({
    name = 'Покинуть организацию',
    order = 999999,
    check = function(org, member)
        local me = org:GetMember(LocalPlayer())
        if not me then return false end

        return member:GetPlayer() == LocalPlayer()
    end,
    callback = function(org, member)
        if member:GetRank():GetLevel() == 100 then
            Derma_Query('Ты УВЕРЕН что хочешь удалить организацию?\nЭто действие невозможно отменить', 'Удаление организации', 'Да', function()
                if IsValid(dOrgs.frame) then dOrgs.frame:Remove() end
                RunConsoleCommand('dorgs', 'leaveorg', org:GetID())
            end, 'Нет')
        else
            if IsValid(dOrgs.frame) then dOrgs.frame:Remove() end
            RunConsoleCommand('dorgs', 'leaveorg', org:GetID())
        end
    end,
})

-- MENU

dOrgs.menuTabs = {}

-- name
-- panel()
function dOrgs.addMenuTab(d)
    table.insert(dOrgs.menuTabs, d)
    table.SortByMember(dOrgs.menuTabs, 'order', true)
end

dOrgs.addMenuTab({
    name = 'Информация',
    order = 10,
    --[[
    check = function(org)
        return org:GetMember(LocalPlayer()):HasFlag('org_editinfo')
    end,
    ]]
    panel = function()
        local pan = vgui.Create('dorgs_orgsettings')
        pan:SetSkin('WayZer')

        function pan:OnOpen(org)
            self:SetOrg(org)
        end

        return pan
    end,
})

dOrgs.addMenuTab({
    name = 'Участники',
    order = 20,
    panel = function()
        local pan = vgui.Create('dorgs_members')
        pan:SetSkin('WayZer')

        function pan:OnOpen(org)
            pan:SetOrg(org)
        end

        return pan
    end,
})

dOrgs.addMenuTab({
    name = 'Банк',
    order = 30,
    panel = function()
        local pan = vgui.Create('dorgs_bank')
        pan:SetSkin('WayZer')

        function pan:OnOpen(org)
            self:SetOrg(org)
        end

        return pan
    end,
})

dOrgs.addMenuTab({
    name = 'Ранги',
    order = 40,
    check = function(org)
        return org:GetMember(LocalPlayer()):HasFlag('rank_manage')
    end,
    panel = function()
        local pan = vgui.Create('dorgs_rankeditor')
        pan:SetSkin('WayZer')

        function pan:OnOpen(org)
            self:SetOrg(org)
        end

        return pan
    end,
})

dOrgs.frame = nil

function dOrgs.openMenu()
    if IsValid(dOrgs.frame) then dOrgs.frame:Remove() end
    local id = LocalPlayer():GetRealMainOrgID()
    if not id then 
        return 
        Derma_StringRequest( 
            "Создание организации", 
            "Ты не состоишь ни в одной организации, стоимость создания составляет "..DarkRP.formatMoney(dOrgs.config.createPrice), 
            "", 
            function(name) RunConsoleCommand("dorgs", "createorg", name) end
        ) 
    end

    dOrgs.frame = vgui.Create('DFrame')
    dOrgs.frame:SetSize(800, 600)
    dOrgs.frame:Center()
    dOrgs.frame:MakePopup()
    dOrgs.frame:SetTitle('Организации')
    dOrgs.frame:SetSkin('WayZer')

    dOrgs.frame.main = vgui.Create('dorgs_main', dOrgs.frame)
    dOrgs.frame.main:Dock(FILL)
    dOrgs.frame.main:SetOrgID(id)
    --frame.main:SetOrgID(LocalPlayer():GetNetVar('dOrgs.OrgMembers') and next(LocalPlayer():GetNetVar('dOrgs.OrgMembers')))
end

function dOrgs.openMemberContext(member)
    local org = member:GetOrg()
    
    local menu = DermaMenu()

    for _, v in ipairs(dOrgs.playerOptions) do
        if v.check and v.check(org, member) == false then continue end

        if v.submenu then
            local submenu, option = menu:AddSubMenu(v.name, function()
                v.callback(org, member)
            end)
            if v.icon then option:SetIcon(v.icon) end

            v.submenu(submenu, org, member)
        else
            local option = menu:AddOption(v.name, function()
                v.callback(org, member)
            end)
            if v.icon then option:SetIcon(v.icon) end
        end
    end

    menu:Open()

    return menu
end

hook.Add('dOrgs.networkedOrg', 'dOrgs.reloadMenu', function(org)
    if not IsValid(dOrgs.frame) then return end
    if dOrgs.frame.main:GetOrgID() ~= org:GetID() then return end

    dOrgs.frame.main.orgInfo:SetOrg(org)

    local pan = dOrgs.frame.main.content:GetActivePanel()
    if pan and pan.OnOpen then
        pan:OnOpen(org)
    end
end)

hook.Add('dOrgs.unloadedOrg', 'dOrgs.closeMenu', function(id)
    if not IsValid(dOrgs.frame) then return end

    if dOrgs.frame.main:GetOrgID() == id then dOrgs.frame:Close() end
end)

concommand.Add('dorgs_openmenu', dOrgs.openMenu)

local bind = CreateClientConVar('dorgs_marker_bind', MOUSE_MIDDLE, true, false)

hook.Add('PlayerButtonDown', 'dOrgs.marker.bind', function(ply, btn)
    if not IsFirstTimePredicted() then return end
    if ply ~= LocalPlayer() then return end
    if ply:IsTyping() then return end

    if btn == bind:GetInt() then
        RunConsoleCommand('dorgs', 'createmarker', ply:GetRealMainOrgID())
    end
end)

local sub = false
function dOrgs.sub()
    if sub then return end
    sub = true
    
    net.Start('dOrgs.sub')
    net.SendToServer()
end

function dOrgs.unsub()
    if not sub then return end
    sub = false

    net.Start('dOrgs.unsub')
    net.SendToServer()
end

dOrgs.requestChat = wlib.func.debounce(function(orgid, page)
    net.Start('dOrgs.requestChat')
    net.WriteUInt(orgid, 32)
    net.WriteUInt(page, 16)
    net.SendToServer()
end, 1)

net.Receive('dOrgs.requestChat', function()
    local total = net.ReadUInt(32)
    local page = net.ReadUInt(16)
    
    local msgs = {}

    for i=1, net.ReadUInt(8) do
        msgs[#msgs + 1] = {
            steamid = util.SteamIDFrom64(net.ReadUInt64()),
            name = net.ReadString(),
            message = net.ReadString(),
            timestamp = net.ReadUInt(32),
        }
    end

    hook.Run('dOrgs.gotChatMessages', page, msgs, total)
end)

local markers = {}
timer.Create('dOrgs.allyMarkers', 5, 0, function()
    if IsValid(LocalPlayer()) then
        local org = dOrgs.getOrg(LocalPlayer():GetMainOrgID())
        if not org or not org:HasUpgrade('map_members') then return end

        for _, v in ipairs(markers) do
            v:Remove()
        end
        markers = {}

        for k, v in ipairs(org:GetOnlineMembers()) do
            local ply = v:GetPlayer()
            if ply == LocalPlayer() then continue end

            local m = wmap.createMarker('dorgs_ally_'..k)
                :SetName(ply:Name())
                :SetMaterial('icon72/orange_circle.png')
                :SetSize(12)
                :SetEntity(ply)
                :SetOrder(1000)

            markers[#markers+1] = m
        end
    end
end)
--addons/module_clans/lua/dorgs/vgui/_main.lua:
local PANEL = {}

function PANEL:Init()
    self.header = vgui.Create('dorgs.orgheader', self)
    self.header:Dock(TOP)
    self.header:DockMargin(0,0,0,20)
    self.header:SetTall(80)
    self.header.Paint = function(s, w, h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    self.main = vgui.Create('wlib.multipanel', self)
    self.main:Dock(FILL)
    self.main:SetPaintBackground(false)

    self.header:AddButton({
        id = 'main',
        name = 'Главная',
        color = Color(77, 77, 77),
        image = Material('icon72/card_box.png'),
        callback = function(org)
            self.main:SelectPanel('main')
            local p = self.main:GetPanel('main')
            if p and p.SetOrg then
                p:SetOrg(self.org)
            end
        end,
        tab = true,
        selected = true,
        order = 0,
    })
    self.tab_main = vgui.Create('dorgs.tab_main')
    self.main:AddPanel(self.tab_main, 'main', true)

    self.header:AddButton({
        id = 'bank',
        name = 'Банк',
        color = Color(0, 92, 0),
        image = Material('icon72/bank.png'),
        callback = function(org)
            self.main:SelectPanel('bank')
            local p = self.main:GetPanel('bank')
            if p and p.SetOrg then
                p:SetOrg(self.org)
            end
        end,
        check = function(org)
            local m = org:GetMember(LocalPlayer())
            if not m then return false end
        end,
        tab = true,
        order = 10,
    })
    self.tab_bank = vgui.Create('dorgs.tab_bank')
    self.main:AddPanel(self.tab_bank, 'bank')

    self.header:AddButton({
        id = 'ranks',
        name = 'Ранги',
        color = Color(133, 91, 0),
        image = Material('icon72/crown.png'),
        callback = function(org)
            self.main:SelectPanel('ranks')
            local p = self.main:GetPanel('ranks')
            if p and p.SetOrg then
                p:SetOrg(self.org)
            end
        end,
        check = function(org)
            local m = org:GetMember(LocalPlayer())
            if not m or not m:HasFlag('rank_manage') then return false end
        end,
        tab = true,
        order = 20,
    })
    self.tab_ranks = vgui.Create('dorgs.tab_ranks')
    self.main:AddPanel(self.tab_ranks, 'ranks')

    self.header:AddButton({
        id = 'settings',
        name = 'Настройки',
        color = Color(114, 114, 114),
        image = Material('icon72/wrench.png'),
        callback = function(org)
            self.main:SelectPanel('settings')
            local p = self.main:GetPanel('settings')
            if p and p.SetOrg then
                p:SetOrg(self.org)
            end
        end,
        check = function(org)
            local m = org:GetMember(LocalPlayer())
            if not m or (not m:HasFlag('org_editinfo') and not m:HasFlag('webhook_edit')) then return false end
        end,
        tab = true,
        order = 30,
    })
    self.tab_settings = vgui.Create('dorgs.tab_settings')
    self.main:AddPanel(self.tab_settings, 'settings')

    self.header:AddButton({
        id = 'addmembers',
        name = 'Пригласить участников',
        color = Color(0, 167, 0),
        image = Material('icon72/tickets.png'),
        callback = function(org)
            local menu = DermaMenu()
        
            for _, ply in player.Iterator() do
                if not ply:GetOrgMember(org:GetID()) then
                    menu:AddOption(ply:Name(), function()
                        if not self.inviteNotified then
                            Derma_Query(
                                ('Ты уверен, что хочешь пригласить %s в клан?\n\nЭто обойдется в %s'):format(ply:Name(), DarkRP.formatMoney(dOrgs.config.invitePrice)),
                                'Приглашение в клан',
                                'Да',
                                function()
                                    self.inviteNotified = true
                                    RunConsoleCommand('dorgs', 'inviteplayer', org:GetID(), ply:SteamID())
                                end,
                                'Нет'
                            )
                        else
                            RunConsoleCommand('dorgs', 'inviteplayer', org:GetID(), ply:SteamID())
                        end
                    end)
                end
            end
    
            menu:Open()
        end,
        check = function(org)
            local m = org:GetMember(LocalPlayer())
            if not m or not m:HasFlag('invite') then return false end
        end,
        order = 40,
    })

    self.header:AddButton({
        id = 'leave',
        name = 'Покинуть клан',
        color = Color(121, 0, 0),
        image = Material('icon72/no_pedestrians.png'),
        callback = function(org)
            local m = org:GetMember(LocalPlayer())
            if m:GetRank():GetLevel() == 100 then
                Derma_Query('Ты УВЕРЕН, что хочешь удалить клан?\nЭто действие невозможно отменить', 'Удаление организации', 'Да', function()
                    RunConsoleCommand('dorgs', 'leaveorg', org:GetID())
                end, 'Нет')
            else
                Derma_Query('Ты уверен, что хочешь покинуть клан?', 'Выход из клана', 'Да', function()
                    RunConsoleCommand('dorgs', 'leaveorg', org:GetID())
                end, 'Нет')
            end
        end,
        check = function(org)
            local m = org:GetMember(LocalPlayer())
            if not m then return false end
        end,
        order = 1000,
    })
end

wlib.accessor(PANEL, 'org', 'Org')

function PANEL:PerformLayout(w, h)
    
end

PANEL.Paint = wlib.func.blank

function PANEL:SetOrg(org)
    if isnumber(org) then org = dOrgs.getOrg(org) end
    self.org = org

    self.header:SetOrg(org)

    for _, v in ipairs(self.main.panels) do
        if v.SetOrg then v:SetOrg(org) end
    end
end

vgui.Register('dorgs.main', PANEL, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/tab_bank.lua:
local col_green = Color(0,200,0)
local upg_size = 160

local PANEL = {}

function PANEL:Init()
    self.right = vgui.Create('DPanel', self)
    self.right:Dock(RIGHT)
    self.right:DockPadding(8,6,8,6)
    self.right:DockMargin(10,0,0,0)
    self.right.Paint = function(s, w, h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    self.right.guide = vgui.Create('DLabel', self.right)
    self.right.guide:Dock(TOP)
    self.right.guide:SetFont('dorgs.28')
    self.right.guide:SetText('Сумма в банке')
    self.right.guide:SetAutoStretchVertical(true)

    self.right.sum = vgui.Create('DLabel', self.right)
    self.right.sum:Dock(TOP)
    self.right.sum:DockMargin(0,6,0,0)
    self.right.sum:SetFont('dorgs.bold.36')
    self.right.sum:SetText('')
    self.right.sum:SetTextColor(Color(0,200,0))
    self.right.sum:SetAutoStretchVertical(true)

    self.right.text = vgui.Create('DLabel', self.right)
    self.right.text:Dock(TOP)
    self.right.text:DockMargin(0,16,0,0)
    self.right.text:SetFont('dorgs.24')

    self.right.entry = vgui.Create('DTextEntry', self.right)
    self.right.entry:Dock(TOP)
    self.right.entry:DockMargin(0,16,0,0)
    self.right.entry:SetTall(25)
    self.right.entry.AllowInput = function(s, char)
        return not ('1234567890'):find(char)
    end
    self.right.entry.Paint = function(s, w, h)
        draw.RoundedBoxEx(6,0,0,w,h,f4menu.col.buttonCol, false, false, true, false)
        if not s:IsEditing() and s:GetValue() == '' then
            draw.SimpleText('Сумма..', 'dorgs.18', 6, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
        s:DrawTextEntryText(color_white, color_black, color_white)
    end

    self.right.buttons = vgui.Create('dorgs_buttons', self.right)
    self.right.buttons:Dock(TOP)
    self.right.buttons:DockMargin(0,6,0,0)
    self.right.buttons:ButtonsDock(RIGHT)
    self.right.buttons:ButtonsMargin(4)

    self.deposit = self.right.buttons:AddButton('Внести', function()
        RunConsoleCommand('dorgs', 'depositmoney', self.org:GetID(), self.right.entry:GetValue())
        self.right.entry:SetValue('')
    end)

    self.withdraw = self.right.buttons:AddButton('Снять', function()
        RunConsoleCommand('dorgs', 'withdrawmoney', self.org:GetID(), self.right.entry:GetValue())
        self.right.entry:SetValue('')
    end)

    self.content = vgui.Create('DPanel', self)
    self.content:Dock(FILL)
    self.content:DockPadding(8,6,8,6)
    self.content:DockMargin(0,0,10,0)
    self.content.Paint = function(s, w, h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    self.content.guide = vgui.Create('DLabel', self.content)
    self.content.guide:Dock(TOP)
    self.content.guide:SetFont('dorgs.28')
    self.content.guide:SetText('Улучшения')
    self.content.guide:SetAutoStretchVertical(true)

    self.content.scroll = vgui.Create('DScrollPanel', self.content)
    self.content.scroll:Dock(FILL)
    self.content.scroll:DockMargin(0,16,0,0)
    f4menu:styleVBar(self.content.scroll.VBar)

    self.content.list = vgui.Create('DIconLayout', self.content.scroll)
    self.content.list:Dock(FILL)
    self.content.list:SetSpaceY(6)
end

function PANEL:PerformLayout(w, h)
    self.right:SetWide(self:GetWide()*0.35 - 10)

    local maxUpgrades = math.floor(self.content.list:GetWide() / upg_size)
    self.content.list:SetSpaceX((self.content.list:GetWide() - upg_size*maxUpgrades) / (maxUpgrades+1))

    if self.org then
        local str = wlib.string.wrap('Операции с банком (комиссия '..(self.org:GetCommission()*100)..'%)', self.right.text:GetFont(), self.right.text:GetWide())
        self.right.text:SetText(str)
    end
end

function PANEL:SetOrg(org)
    if isnumber(org) then org = dOrgs.getOrg(org) end
    self.org = org

    local str = wlib.string.wrap('Операции с банком (комиссия '..(self.org:GetCommission()*100)..'%)', self.right.text:GetFont(), self.right.text:GetWide())
    self.right.text:SetText(str)

    self.right.sum:SetText(DarkRP.formatMoney(org:GetMoney()))

    self.content.list:Clear()

    local used = {}
    for id, _ in pairs(org:GetUpgrades()) do
        local upgrade = vgui.Create('dorgs.upgrade', self.content.list)
        upgrade:SetSize(upg_size, upg_size)
        upgrade:SetOrg(org)
        upgrade:SetUpgrade(dOrgs.upgrades[id])

        used[id] = true
    end

    for id, v in pairs(dOrgs.upgrades) do
        if used[id] then continue end
        
        local upgrade = vgui.Create('dorgs.upgrade', self.content.list)
        upgrade:SetSize(upg_size, upg_size)
        upgrade:SetOrg(org)
        upgrade:SetUpgrade(v)
    end
end

PANEL.Paint = wlib.func.blank

vgui.Register('dorgs.tab_bank', PANEL, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/tab_org.lua:
local PANEL = {}

function PANEL:Init()
    self.right = vgui.Create('wlib.multipanel', self)
    self.right:Dock(RIGHT)
    self.right:DockMargin(10,0,0,0)
    self.right:SetPaintBackground(false)

    self.description = vgui.Create('DPanel', self.right)
    self.description:Dock(FILL)
    self.description:DockPadding(8,6,8,6)
    self.description:SetPaintBackground(false)
    self.description.Paint = function(s,w,h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    self.description.title = vgui.Create('DLabel', self.description)
    self.description.title:Dock(TOP)
    self.description.title:SetFont('dorgs.28')
    self.description.title:SetText('Описание клана')
    self.description.title:SetAutoStretchVertical(true)

    self.description.text = vgui.Create('DLabel', self.description)
    self.description.text:Dock(FILL)
    self.description.text:DockMargin(0, 6, 0, 0)
    self.description.text:SetFont('dorgs.24')
    self.description.text:SetAutoStretchVertical(true)

    self.chat = vgui.Create('dorgs.chat', self.right)

    self.right:AddPanel(self.description, 'description', true)
    self.right:AddPanel(self.chat, 'chat')

    self.content = vgui.Create('DPanel', self)
    self.content:Dock(FILL)
    self.content:DockMargin(0,0,10,0)
    self.content.Paint = function(s, w, h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    self.search = vgui.Create('DTextEntry', self.content)
    self.search:Dock(TOP)
    self.search:SetTall(25)
    self.search:SetUpdateOnType(true)
    self.search.Paint = function(s, w, h)
        draw.RoundedBoxEx(6,0,0,w,h,f4menu.col.profile, false, false, true, false)
        if not s:IsEditing() and s:GetValue() == '' then
            draw.SimpleText('Поиск..', 'dorgs.18', 6, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
        s:DrawTextEntryText(color_white, color_black, color_white)
    end
    local filter = wlib.func.debounce(fp{self.Search, self}, 0.15)
	self.search.OnValueChange = function(s, text)
        filter(text)
    end

    self.playerlist = vgui.Create('DCategoryList', self.content)
    self.playerlist:Dock(FILL)
    self.playerlist:DockMargin(0,0,10,0)
    self.playerlist.Paint = wlib.func.blank
    self.playerlist.ranks = {}
    f4menu:styleVBar(self.playerlist.VBar)
end

wlib.accessor(PANEL, 'org', 'Org')

function PANEL:PerformLayout(w, h)
    if self.org then
        self.description.text:SetText(wlib.string.wrap(self.org:GetDescription(), self.description.text:GetFont(), self.description.text:GetWide()))
    end

    self.right:SetWide(self:GetWide()*0.35 - 10)
end

PANEL.Paint = wlib.func.blank

function PANEL:SetOrg(org)
    if isnumber(org) then org = dOrgs.getOrg(org) end
    self.org = org

    self.chat:SetOrg(org)

    self.description.text:SetText(wlib.string.wrap(org:GetDescription(), self.description.text:GetFont(), self.description.text:GetWide()))
    self.chat:SetDescription(org:GetDescription())

    if org:GetMember(LocalPlayer()) and org:HasUpgrade('chat') then
        self.right:SelectPanel('chat')
    else
        self.right:SelectPanel('description')
    end

    self.search:SetValue('')
    self.playerlist:Clear()
    for _, rank in SortedPairsByMemberValue(org:GetRanks(), 'lvl', true) do
        local ms = self.org:GetMembersByRank(rank:GetLevel())

        local online = {}
        for _, v in ipairs(ms) do
            if offline or IsValid(v:GetPlayer()) then online[#online + 1] = v end
        end

        local category = self.playerlist:Add(('%s (%s/%s)'):format(rank:GetName(), #online, #ms))
        category.Paint = wlib.func.blank

        category.Header:SetTall(30)
        category.Header:SetFont('dorgs.24')
        category.Header.Paint = function(s, w, h)
            draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol) 
        end

        local layout = vgui.Create('DListLayout')
        category:SetContents(layout)

        self.playerlist.ranks[rank:GetLevel()] = layout
    end

    self:Search('')
end

function PANEL:Search(q)
    if not self.org then return end
    q = utf8.lower(q or '')
    for _, rank in pairs(self.org:GetRanks()) do
        local layout = self.playerlist.ranks[rank:GetLevel()]
        layout:Clear()

        local ms = self.org:GetMembersByRank(rank:GetLevel())

        for _, member in ipairs(ms) do
            if not utf8.lower(member:GetName()):match(q) then continue end

            local el = vgui.Create('dorgs_member', layout)
            el:Dock(TOP)
            el:SetTall(35)
            el:SetOrgMember(member)
            layout:Add(el)
        end
    end
end

vgui.Register('dorgs.tab_main', PANEL, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/tab_ranks.lua:
local PANEL = {}

local function createText(text, font, parent)
    local label = vgui.Create('DLabel', parent)
    label:Dock(TOP)
    label:SetDark(true)
    label:SetAutoStretchVertical(true)
    label:SetFont(font)
    label:DockMargin(0,6,0,6)
    label:SetText(text)

    return label
end

function PANEL:Init()
    self.flags = {}

    self.right = vgui.Create('DPanel', self)
    self.right:Dock(RIGHT)
    self.right:DockPadding(8,6,8,6)
    self.right:DockMargin(10,0,0,0)
    self.right.Paint = function(s, w, h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    self.right.header = vgui.Create('DPanel', self.right)
    self.right.header:Dock(TOP)
    self.right.header:SetPaintBackground(false)
    self.right.header:SetTall(30)

    self.addrank = vgui.Create('DImageButton', self.right.header)
    self.addrank:Dock(RIGHT)
    self.addrank:SetWide(18)
    self.addrank:DockMargin(0,6,0,6)
    self.addrank:SetMaterial(Material('icon16/add.png'))
    self.addrank.DoClick = function()
        Derma_StringRequest('Иммунитет ранга', 'Введи ниже иммунитет ранга (от 1 до 99)', '1', function(lvl)
            if not tonumber(lvl) then return notification.AddLegacy('Иммунитет должен быть числом', 1, 5) end
            if tonumber(lvl) ~= math.Clamp(tonumber(lvl), 1, 99) then return notification.AddLegacy('Нужно ввести число от 1 до 99', 1, 5) end
            
            Derma_StringRequest('Название ранга', 'Введи ниже название ранга', '', function(name)
                local res, err = dOrgs.classes.rank:ValidateName(name)
                if res == false then return notification.AddLegacy(err, 1, 5) end
    
                RunConsoleCommand('dorgs', 'createrank', self.org:GetID(), tonumber(lvl), name, util.TableToJSON({}))
            
            end, nil, 'Создать', 'Отмена')
        
        end, nil, 'Далее', 'Отмена')
    end

    local txt = createText('Ранги', 'dorgs.24', self.right.header)
    txt:Dock(FILL)
    txt:DockMargin(0,0,0,0)

    self.ranklist = vgui.Create('DScrollPanel', self.right)
    self.ranklist:Dock(FILL)
    self.ranklist.ranks = {}

    self.content = vgui.Create('DPanel', self)
    self.content:Dock(FILL)
    self.content:DockPadding(8,6,8,6)
    self.content:DockMargin(0,0,10,0)
    self.content.Paint = function(s, w, h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    self.content.header = vgui.Create('DPanel', self.content)
    self.content.header:Dock(TOP)
    self.content.header:SetPaintBackground(false)
    self.content.header:SetTall(30)
    self.content.header:SetZPos(0)

    self.confirm = vgui.Create('DImageButton', self.content.header)
    self.confirm:Dock(RIGHT)
    self.confirm:SetWide(18)
    self.confirm:DockMargin(0,6,0,6)
    self.confirm:SetMaterial(Material('icon72/white_check_mark.png'))
    self.confirm.DoClick = function()
        self:SaveRank()
    end

    txt = createText('Название ранга', 'dorgs.24', self.content.header)
    txt:Dock(FILL)
    txt:DockMargin(0,0,0,0)

    self.name = vgui.Create('DTextEntry', self.content)
    self.name:Dock(TOP)
    self.name:SetTall(25)
    self.name:SetUpdateOnType(true)
    self.name.Paint = function(s, w, h)
        draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol)
        if not s:IsEditing() and s:GetValue() == '' then
            draw.SimpleText('Название..', 'dorgs.18', 6, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
        s:DrawTextEntryText(color_white, color_black, color_white)
    end
    self.name.OnChange = function(s)
        self:RankInfoUpdated()
    end
    self.name:SetZPos(1)

    --[[
    txt = createText('Иконка', 'dorgs.24', self.content)
    txt:DockMargin(0,12,0,6)
    txt:SetZPos(2)

    self.iconpnl = vgui.Create('DPanel', self.content)
    self.iconpnl:Dock(TOP)
    self.iconpnl:SetTall(40)
    self.iconpnl:SetPaintBackground(false)
    self.iconpnl:SetZPos(3)

    self.icon = vgui.Create('DImageButton', self.iconpnl)
    self.icon:Dock(LEFT)
    self.icon:SetWide(40)
    self.icon:SetMaterial(Material('icon72/moneybag.png'))
    self.icon.value = 'moneybag'
    ]]

    txt = createText('Права доступа', 'dorgs.24', self.content)
    txt:DockMargin(0,12,0,6)
    txt:SetZPos(4)

    self.list = vgui.Create('DCategoryList', self.content)
    self.list:Dock(FILL)
    self.list:DockMargin(0,0,10,0)
    self.list.Paint = wlib.func.blank
    self.list:SetZPos(5)
    self.list.categories = {}
    f4menu:styleVBar(self.list.VBar)

    self:SetSettingsVisible(false)
end

function PANEL:PerformLayout(w, h)
    self.right:SetWide(self:GetWide()*0.35 - 10)
end

function PANEL:SetOrg(org)
    if isnumber(org) then org = dOrgs.getOrg(org) end
    self.org = org

    self.ranklist:Clear()
    self.ranklist.ranks = {}
    for _, rank in SortedPairs(org:GetRanks(), true) do
        local el = vgui.Create('dorgs.rank', self.ranklist)
        el.rank = rank
        el:Dock(TOP)
        el:SetTall(50)
        el:SetRank(rank)
        el.DoClick = function(s)
            if not self:CompareRank() then
                Derma_Query('Сохранить изменения ранга "'..self.rank:GetName()..'"?', 'Сохранить изменения', 'Да', function()
                    self:SaveRank()
                    self:SetRank(rank)
                end, 'Нет', function()
                    self:SetRank(rank)
                end)

                return
            end

            self:SetRank(rank)
        end
        el.RemoveClick = function(s)
            Derma_Query('Ты уверен что хочешь удалить ранг "'..rank:GetName()..'"?', 'Удаление ранга', 'Да', function()
                RunConsoleCommand('dorgs', 'removerank', self.org:GetID(), rank:GetLevel())
                self:SetRank()
            end, 'Нет')
        end

        self.ranklist.ranks[rank:GetLevel()] = el
    end

    if self.rank then
        self:SetRank(org:GetRank(self.rank:GetLevel()))
    end
end

function PANEL:SetRank(rank)
    self.rank = rank

    if not rank then return self:SetSettingsVisible(false) end
    
    self:SetSettingsVisible(true)

    self.name:SetValue(rank:GetName())
    self.list:Clear()
    self.list.categories = {}

    for id, flag in pairs(dOrgs.config.flags) do
        local category = self.list.categories[flag.category]
        if not IsValid(category) then
            category = self.list:Add(flag.category)
            category.Paint = wlib.func.blank
    
            category.Header:SetTall(30)
            category.Header:SetFont('dorgs.24')
            category.Header.Paint = function(s, w, h)
                draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol) 
            end

            category.layout = vgui.Create('DListLayout')
            category.layout:DockPadding(0,6,0,6)
            category:SetContents(category.layout)

            self.list.categories[flag.category] = category
        end

        local check = vgui.Create('DCheckBoxLabel', category.layout)
        check:Dock(TOP)
        check:DockMargin(0,0,0,4)
        check:SetDark(true)
        check:SetText(flag.desc)
        check:SetChecked(rank:HasFlag(id))
        check.OnChange = function(s, val)
            table.RemoveByValue(self.flags, id)
            if val then
                table.insert(self.flags, id)
            end

            self:RankInfoUpdated()
        end
    end

    self.flags = table.Copy(rank:GetFlags())

    local btn = self.ranklist.ranks[rank:GetLevel()]
    if IsValid(btn) then
        for _, v in ipairs(self.ranklist:GetCanvas():GetChildren()) do
            v:SetSelected(false)
        end
        btn:SetSelected(true)
    end

    self:RankInfoUpdated()
end

function PANEL:SetSettingsVisible(b)
    for _, v in ipairs(self.content:GetChildren()) do
        v:SetVisible(b)
    end
end

function PANEL:CompareRank()
    if not self.rank then return true end

    local cur = self.rank:GetFlags()
    if #cur ~= #self.flags then return false end

    table.sort(cur)
    table.sort(self.flags)

    for k, v in ipairs(cur) do
        if self.flags[k] ~= v then return false end
    end

    if self.rank:GetName() ~= self.name:GetValue() then return false end

    return true
end

function PANEL:RankInfoUpdated()
    self.confirm:SetVisible(not self:CompareRank())
end

function PANEL:SaveRank()
    RunConsoleCommand('dorgs', 'updaterank', self.org:GetID(), self.rank:GetLevel(), self.name:GetValue(), util.TableToJSON(self.flags))
end

PANEL.Paint = wlib.func.blank

vgui.Register('dorgs.tab_ranks', PANEL, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/vgui_chat.lua:
local PANEL = {}

function PANEL:Init()
    self.canvas = vgui.Create('DPanel', self)
    self.canvas:Dock(FILL)
    self.canvas:SetPaintBackground(false)

    self.footer = vgui.Create('DPanel', self.canvas)
    self.footer:Dock(BOTTOM)
    self.footer:SetTall(25)
    self.footer:SetPaintBackground(false)

    self.send = vgui.Create('DButton', self.footer)
    self.send:Dock(RIGHT)
    self.send:SetWide(50)
    self.send:SetText('>')
    self.send.Think = function(s)
        if self.nextMessage then
            if self.nextMessage < CurTime() then
                s:SetText('>')
                self.nextMessage = nil
                return
            end

            local rem = math.ceil(self.nextMessage - CurTime())
            s:SetText(('%02i:%02i'):format(math.floor(rem/60), rem%60))
        end
    end
    self.send.DoClick = function(s)
        self:SendMessage()
    end
    self.send.Paint = function(s, w, h)
        local col = s:IsHovered() and f4menu.col.buttonCol_hover or f4menu.col.buttonCol
        draw.RoundedBoxEx(6,0,0,w,h,col, false, false, false, true)
    end

    self.entry = vgui.Create('DTextEntry', self.footer)
    self.entry:Dock(FILL)
    self.entry.Paint = function(s, w, h)
        draw.RoundedBoxEx(6,0,0,w,h,f4menu.col.profile, false, false, true, false)
        s:DrawTextEntryText(color_white, color_black, color_white)
    end
    self.entry.OnEnter = function(s)
        self:SendMessage()
    end

    self.header = vgui.Create('DPanel', self.canvas)
    self.header:Dock(TOP)
    self.header:SetTall(25)
    self.header.Paint = function(s,w,h)
        draw.SimpleText(self.currentPage..'/'..self.pagesCount, 'dorgs.24', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) 
    end

    self.header.prev = vgui.Create('DImageButton', self.header)
    self.header.prev:Dock(LEFT)
    self.header.prev:SetWide(25)
    self.header.prev:SetMaterial(Material('icon72/arrow_backward.png'))
    self.header.prev.DoClick = function(s)
        if self.currentPage - 1 < 1 then return end
        self:LoadPage(self.currentPage - 1)
    end

    self.header.next = vgui.Create('DImageButton', self.header)
    self.header.next:Dock(RIGHT)
    self.header.next:SetWide(25)
    self.header.next:SetMaterial(Material('icon72/arrow_forward.png'))
    self.header.next.DoClick = function(s)
        if self.currentPage + 1 > self.pagesCount then return end
        self:LoadPage(self.currentPage + 1)
    end

    self.text = vgui.Create('RichText', self.canvas)
    self.text:Dock(FILL)
    self.text:DockMargin(0,0,0,2)
    self.text.PerformLayout = function(s)
		s:SetFontInternal('dorgs.24')
        s:SetUnderlineFont('dorgs.24')
	end
    self.text.OnTextClicked = function(s, id)
        if not self.pages[self.currentPage] then return end

        local msg = self.pages[self.currentPage][tonumber(id)]
        if not msg then return end

        if self.org and self.org:GetMember(msg.steamid) then
            local menu = dOrgs.openMemberContext(self.org:GetMember(msg.steamid))

            menu:AddSpacer()
            menu:AddOption(os.date('%X %d.%m.%Y', msg.timestamp))
            menu:Open()
        else
            local menu = DermaMenu()
            menu:AddOption('Скопировать SteamID', fp{SetClipboardText, msg.steamid})
            menu:AddSpacer()
            menu:AddOption(os.date('%X %d.%m.%Y', msg.timestamp))
            menu:Open()
        end
    end

    self.pages = {}
    self.total = 0
    self.pagesCount = 1
    self.currentPage = 1
end

function PANEL:Paint(w, h)
    draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    
    surface.SetDrawColor(f4menu.col.buttonCol)
    surface.DrawRect(0,h-27,w,2)
end

wlib.accessor(PANEL, 'org', 'Org')
wlib.accessor(PANEL, 'nextMessage', 'NextMessage')
wlib.accessor(PANEL, 'currentPage', 'CurrentPage')

function PANEL:SetOrg(org)
    if isnumber(org) then org = dOrgs.getOrg(org) end
    self.org = org

    if not org then return end

    self:LoadPage(1, true)

    hook.Add('dOrgs.gotChatMessages', 'chat', function(page, msgs, total)
        self.pagesCount = math.floor(total / dOrgs.config.messagesOnPage) + 1

        if self.total ~= total then
            self.pages = {}
        end

        self.pages[page] = table.Reverse(msgs)

        self:LoadPage(self.currentPage)

        self.total = total
    end)
end

local color_leader = Color(255,187,0)
local color_member = Color(4,133,0)
local color_default = Color(92,92,92)

function PANEL:LoadPage(page, forcereq)
    if not self.org then return end

    local msgs = self.pages[page]
    
    self.currentPage = page

    self.text:SetText('')
    if msgs then
        for k, v in ipairs(msgs) do
            local member = self.org:GetMember(v.steamid)

            local color = member and (member:GetRank():GetLevel() == 100 and color_leader or color_member) or color_default
            self.text:InsertClickableTextStart(tostring(k))
            self.text:InsertColorChange(color:Unpack())
            self.text:AppendText(v.name)
            self.text:InsertClickableTextEnd()

            self.text:InsertColorChange(255,255,255,255)
            self.text:AppendText(': '..v.message..'\n')
        end

        self.text:GotoTextEnd()
    else
        dOrgs.requestChat(self.org:GetID(), page)
    end
end

function PANEL:SetDescription(text)
    local old = self.description

    self.description = text
    if text and text ~= '' and old ~= text then self:CreatePinned() end
end

function PANEL:PerformLayout(w, h)
    if IsValid(self.pinned) then
        self.pinned.desc:SetText(wlib.string.wrap(self.description or '', self.pinned.desc:GetFont(), self.pinned.desc:GetWide()))
        self.pinned.desc:SizeToContents()

        self.pinned:SizeToChildren(false, true)
    end
end

function PANEL:CreatePinned()
    if IsValid(self.pinned) then self.pinned:Remove() end

    self.pinned = vgui.Create('DPanel', self)
    self.pinned:Dock(TOP)
    self.pinned:DockPadding(6,0,6,6)
    self.pinned.Paint = function(s,w,h)
        draw.RoundedBoxEx(6,0,0,w,h,f4menu.col.buttonCol, true, true, false, false)
    end

    self.pinned.header = vgui.Create('DPanel', self.pinned)
    self.pinned.header:Dock(TOP)
    self.pinned.header:SetTall(28)
    self.pinned.header:SetPaintBackground(false)

    self.pinned.header.button = vgui.Create('DImageButton', self.pinned.header)
    self.pinned.header.button:Dock(RIGHT)
    self.pinned.header.button:DockMargin(0,4,0,4)
    self.pinned.header.button:SetMaterial(Material('icon72/x.png'))
    self.pinned.header.button:SetSize(20, 20)
    self.pinned.header.button.DoClick = fp{self.pinned.Remove, self.pinned}

    self.pinned.header.text = vgui.Create('DLabel', self.pinned.header)
    self.pinned.header.text:Dock(FILL)
    self.pinned.header.text:SetText('Описание клана')
    self.pinned.header.text:SetFont('dorgs.24')

    self.pinned.desc = vgui.Create('DLabel', self.pinned)
    self.pinned.desc:Dock(FILL)
    self.pinned.desc:DockMargin(0,6,0,0)
    self.pinned.desc:SetAutoStretchVertical(true)
end

function PANEL:SendMessage()
    if not self.org then return end
    if self.nextMessage and self.nextMessage > CurTime() then return end

    RunConsoleCommand('dorgs', 'chatsend', self.org:GetID(), self.entry:GetValue())

    self:SetNextMessage(CurTime() + 5)

    timer.Simple(0, function()
        self.entry:SetValue('')
    end)
end

vgui.Register('dorgs.chat', PANEL, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/vgui_rank.lua:
local mat_cross = Material('icon72/x.png')
local mat_gradient = Material('gui/center_gradient')
local color_selected = Color(236, 113, 73)

local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self:DockPadding(4,4,4,4)

    --[[
    self.icon = vgui.Create('DImage', self)
    self.icon:Dock(LEFT)
    ]]

    self.remove = vgui.Create('DImageButton', self)
    self.remove:Dock(RIGHT)
    self.remove:SetMaterial(mat_cross)
    self.remove.DoClick = fp{self.RemoveClick, self}

    self.name = vgui.Create('DLabel', self)
    self.name:Dock(FILL)
    self.name:DockMargin(6,0,6,0)
    self.name:SetFont('dorgs.24')
end

function PANEL:SetRank(rank)
    self.rank = rank

    --self.icon:SetMaterial(rank:GetIcon() and Material(rank:GetIconPath()) or mat_cross)
    self.name:SetText(('%s (%s)'):format(rank:GetName(), rank:GetLevel()))
end

function PANEL:PerformLayout(w, h)
    --[[
    self.icon:DockMargin(0, h/8, 0, h/8)
    self.icon:SetWide(h * 6/8 - 4)
    ]]

    self.remove:SetWide(h/2 - 6)
    self.remove:DockMargin(0, h/4, 0, h/4)
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, w, h, f4menu.col.bg)
    if self.selected then
        surface.SetMaterial(mat_gradient)
        surface.SetDrawColor(color_selected)
        surface.DrawTexturedRect(0, 0, w, h)
    end
    draw.RoundedBox(4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor)
end

function PANEL:RemoveClick()

end

wlib.accessor(PANEL, 'selected', 'Selected')

vgui.Register('dorgs.rank', PANEL, 'DButton')
--addons/module_elitef4menu/lua/autorun/f4_init.lua:
wlib.include.module('f4')
wlib.include.client('f4/tabs')
wlib.include.client('f4/vgui')
--addons/module_elitef4menu/lua/f4/tabs/elite_jobwindow.lua:
function OpenJobInfo( index )
	local jbg = vgui.Create( "DFrame" )
	jbg:SetSize( ScrW(), ScrH() )
	jbg:SetTitle( "" )
	jbg:ShowCloseButton( false )
	jbg:SetDraggable( false )
	jbg.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 250 ) )
	end
	jbg:MakePopup()

	local jobInfo = vgui.Create( "DFrame", jbg )
	jobInfo:SetSize( 300, 400 )
	jobInfo:SetPos( -500, ScrH() / 2 - 200 )
	jobInfo:ShowCloseButton( false )
	jobInfo.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color( 239, 239, 239 ) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color( 255, 255, 255 ) )
		
		draw.SimpleText( string.upper(team.GetName( index )), "f4.main", 24, 20, Color( 190, 190, 190 ) )
		
		surface.SetDrawColor( Color( 242, 242, 242 ) )
		surface.DrawLine( 24, 44, 182 - 26, 44 )
	end
	jobInfo:MoveTo( ScrW() / 2 - 150, ScrH() / 2 - 200, 0.5, 0, 0.05 )
	
	local BG_CLOSE = vgui.Create( "DButton", jobInfo )
	BG_CLOSE:SetSize( 32, 32 )
	BG_CLOSE:SetPos( jobInfo:GetWide() - 38,6 )
	BG_CLOSE:SetText( "r" )
	BG_CLOSE:SetFont( "marlett" )
	BG_CLOSE:SetTextColor( Color( 166, 169, 172 ) )
	BG_CLOSE.Paint = function()
		
	end
	BG_CLOSE.DoClick = function()
		jobInfo:Close()
		jbg:Remove()
	end
	
	local STAFF_LIST = vgui.Create( "DPanelList", jobInfo )
	STAFF_LIST:SetSize( 270, 400 - 74 )
	STAFF_LIST:SetPos( 24, 50 )
	STAFF_LIST:SetSpacing( 2 )
	STAFF_LIST:EnableVerticalScrollbar( true )
	STAFF_LIST.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, Color(0,0,0,70))
	end
	STAFF_LIST.VBar.btnUp.Paint = function( s, w, h ) end
	STAFF_LIST.VBar.btnDown.Paint = function( s, w, h ) end
	STAFF_LIST.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, Color(0,0,0,70))
	end
	
	for k, v in player.Iterator() do
		if v:Team() == index then
			local PLY_PANEL = vgui.Create( "Panel" )
			PLY_PANEL:SetSize( 132, 40 )
			PLY_PANEL.Paint = function( self, w, h )
				draw.SimpleText( string.upper(v:Nick()), "f4.main", 40, 12 - 6, Color( 0, 0, 0 ) )
				draw.SimpleText( string.upper(v:SteamID()), "f4.main", 40, 26 - 6, Color( 195, 195, 195 ) )
			end
			
			local PLY_AVATAR = vgui.Create( "AvatarImage", PLY_PANEL )
			PLY_AVATAR:SetSize( 32, 32 )
			PLY_AVATAR:SetPos( 0, 6 )
			PLY_AVATAR:SetSteamID( v:SteamID64(), 32 )
			
			STAFF_LIST:AddItem( PLY_PANEL )
		end
	end
end
--addons/module_elitef4menu/lua/f4/tabs/elite_windows.lua:
function OpenTextBox( text1, text2, cmd )

	local jbg = vgui.Create( "DFrame" )
	jbg:SetSize( ScrW(), ScrH() )
	jbg:SetTitle( "" )
	jbg:ShowCloseButton( false )
	jbg:SetDraggable( false )
	jbg.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 250 ) )
	end
	jbg:MakePopup()

	local bg = vgui.Create( "DFrame", jbg )
	bg:SetSize( 300, 200 )
	bg:SetPos( -500, ScrH() / 2 - 200 )
	bg:ShowCloseButton( false )
	bg.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color( 239, 239, 239 ) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color( 255, 255, 255 ) )
		
		draw.SimpleText( string.upper( text1 ), "f4.main", 24, 20, Color( 190, 190, 190 ) )
		
		surface.SetDrawColor( Color( 242, 242, 242 ) )
		surface.DrawLine( 24, 44, 182 - 26, 44 )
	end
	bg:MoveTo( ScrW() / 2 - 150, ScrH() / 2 - 200, 0.5, 0, 0.05 )
	
	local label = vgui.Create( "DLabel", bg )
	label:SetPos( 28, 54 )
	label:SetSize( bg:GetWide() - 56, 40 )
	label:SetWrap( true )
	label:SetText( string.upper(text2) )
	label:SetFont( "f4.sub" )
	label:SetTextColor( Color( 190, 190, 190 ) )
	
	local BG_CLOSE = vgui.Create( "DButton", bg )
	BG_CLOSE:SetSize( 32, 32 )
	BG_CLOSE:SetPos( bg:GetWide() - 38,6 )
	BG_CLOSE:SetText( "r" )
	BG_CLOSE:SetFont( "marlett" )
	BG_CLOSE:SetTextColor( Color( 166, 169, 172 ) )
	BG_CLOSE.Paint = function()
		
	end
	BG_CLOSE.DoClick = function()
		bg:Close()
		jbg:Remove()
	end

	local myText = vgui.Create("DTextEntry", bg)
	myText:SetText("")
	myText:SetPos( bg:GetWide() / 2 - 100, bg:GetTall() - 80 )
	myText:SetSize( 200, 20	)
	myText.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color(230,230,230))
		draw.RoundedBox( 0, 1, 1, w-2, h-2, Color(255,255,255))
		self:DrawTextEntryText(Color(30, 30, 30), Color(149, 240, 193), Color(0, 0, 0))
	end

	local ybut = vgui.Create( "DButton", bg )
	ybut:SetSize( 80, 35 )
	ybut:SetPos( bg:GetWide() / 2 - 40, bg:GetTall() - 44 )
	ybut:SetText( "Принять" )
	ybut:SetFont( "f4.main" )
	ybut:SetTextColor( Color( 255, 255, 255 ) )
	ybut.Paint = function( self, w, h )
		draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 232, 76, 82 ) )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 233, 84, 90 ) )
		
		if self.hover then
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
		end
	end
	ybut.OnCursorEntered = function( self )
		self.hover = true
	end
	ybut.OnCursorExited = function( self )
		self.hover = false
	end
	ybut.DoClick = function()
		local amt = myText:GetValue()
		local str = cmd.." "..amt
		if amt then
			RunConsoleCommand( "say", str )
		end
		bg:Close()
		jbg:Close()
		textOpen = false
	end
end

function OpenPlyBox( text1, text2, cmd )

	local jbg = vgui.Create( "DFrame" )
	jbg:SetSize( ScrW(), ScrH() )
	jbg:SetTitle( "" )
	jbg:ShowCloseButton( false )
	jbg:SetDraggable( false )
	jbg.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 250 ) )
	end
	jbg:MakePopup()

	local bg = vgui.Create( "DFrame", jbg )
	bg:SetSize( 300, 200 )
	bg:SetPos( -500, ScrH() / 2 - 200 )
	bg:ShowCloseButton( false )
	bg.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color( 239, 239, 239 ) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color( 255, 255, 255 ) )
		
		draw.SimpleText( string.upper( text1 ), "f4.main", 24, 20, Color( 190, 190, 190 ) )
		
		surface.SetDrawColor( Color( 242, 242, 242 ) )
		surface.DrawLine( 24, 44, 182 - 26, 44 )
	end
	bg:MoveTo( ScrW() / 2 - 150, ScrH() / 2 - 200, 0.5, 0, 0.05 )
	
	local label = vgui.Create( "DLabel", bg )
	label:SetPos( 28, 54 )
	label:SetSize( bg:GetWide() - 56, 40 )
	label:SetWrap( true )
	label:SetText( string.upper(text2) )
	label:SetFont( "f4.sub" )
	label:SetTextColor( Color( 190, 190, 190 ) )
	
	local BG_CLOSE = vgui.Create( "DButton", bg )
	BG_CLOSE:SetSize( 32, 32 )
	BG_CLOSE:SetPos( bg:GetWide() - 38,6 )
	BG_CLOSE:SetText( "r" )
	BG_CLOSE:SetFont( "marlett" )
	BG_CLOSE:SetTextColor( Color( 166, 169, 172 ) )
	BG_CLOSE.Paint = function()
		
	end
	BG_CLOSE.DoClick = function()
		bg:Close()
		jbg:Remove()
	end

	local hl = vgui.Create( "DComboBox", bg)
	hl:SetPos(bg:GetWide() / 2 - 100, bg:GetTall() - 74)
	hl:SetSize( 200, 20 )
	for k,v in player.Iterator() do
			hl:AddChoice( v:Name() )
	end

	hl.OnSelect = function( panel, index, value, data )
		target = string.Explode( " ", value )[1]
	end

	local ybut = vgui.Create( "DButton", bg )
	ybut:SetSize( 80, 35 )
	ybut:SetPos( bg:GetWide() / 2 - 40, bg:GetTall() - 44 )
	ybut:SetText( "Принять" )
	ybut:SetFont( "f4.main" )
	ybut:SetTextColor( Color( 255, 255, 255 ) )
	ybut.Paint = function( self, w, h )
		draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 232, 76, 82 ) )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 233, 84, 90 ) )
		
		if self.hover then
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
		end
	end
	ybut.OnCursorEntered = function( self )
		self.hover = true
	end
	ybut.OnCursorExited = function( self )
		self.hover = false
	end
	ybut.DoClick = function()
		local str = cmd.." "..target
		if target then
			RunConsoleCommand( "say", str )
		end
		bg:Close()
		jbg:Close()
		textOpen = false
	end
end

function OpenPlyReasonBox( text1, text2, text3, cmd )

	local jbg = vgui.Create( "DFrame" )
	jbg:SetSize( ScrW(), ScrH() )
	jbg:SetTitle( "" )
	jbg:ShowCloseButton( false )
	jbg:SetDraggable( false )
	jbg.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 250 ) )
	end
	jbg:MakePopup()

	local bg = vgui.Create( "DFrame", jbg )
	bg:SetSize( 300, 250 )
	bg:SetPos( -500, ScrH() / 2 - 200 )
	bg:ShowCloseButton( false )
	bg.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color( 239, 239, 239 ) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color( 255, 255, 255 ) )
		
		draw.SimpleText( string.upper( text1 ), "f4.main", 24, 20, Color( 190, 190, 190 ) )
		
		surface.SetDrawColor( Color( 242, 242, 242 ) )
		surface.DrawLine( 24, 44, 182 - 26, 44 )
	end
	bg:MoveTo( ScrW() / 2 - 150, ScrH() / 2 - 200, 0.5, 0, 0.05 )
	
	local label = vgui.Create( "DLabel", bg )
	label:SetPos( 28, 54 )
	label:SetSize( bg:GetWide() - 56, 40 )
	label:SetWrap( true )
	label:SetText( string.upper(text2) )
	label:SetFont( "f4.sub" )
	label:SetTextColor( Color( 190, 190, 190 ) )
	
	local BG_CLOSE = vgui.Create( "DButton", bg )
	BG_CLOSE:SetSize( 32, 32 )
	BG_CLOSE:SetPos( bg:GetWide() - 38,6 )
	BG_CLOSE:SetText( "r" )
	BG_CLOSE:SetFont( "marlett" )
	BG_CLOSE:SetTextColor( Color( 166, 169, 172 ) )
	BG_CLOSE.Paint = function()
		
	end
	BG_CLOSE.DoClick = function()
		bg:Close()
		jbg:Remove()
	end

	local target

	local hl = vgui.Create( "DComboBox", bg)
	hl:SetPos(bg:GetWide() / 2 - 100, bg:GetTall() - 120)
	hl:SetSize( 200, 20 )
	for k,v in player.Iterator() do
			hl:AddChoice( v:Name() )
	end

	hl.OnSelect = function( panel, index, value, data )
		target = string.Explode( " ", value )[1]
	end

	local myText = vgui.Create("DTextEntry", bg)
	myText:SetText("")
	myText:SetPos( bg:GetWide() / 2 - 100, bg:GetTall() - 74 )
	myText:SetSize( 200, 20	)
	myText.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color(230,230,230))
		draw.RoundedBox( 0, 1, 1, w-2, h-2, Color(255,255,255))
		self:DrawTextEntryText(Color(30, 30, 30), Color(149, 240, 193), Color(0, 0, 0))
	end

	local ybut = vgui.Create( "DButton", bg )
	ybut:SetSize( 80, 35 )
	ybut:SetPos( bg:GetWide() / 2 - 40, bg:GetTall() - 44 )
	ybut:SetText( "Принять" )
	ybut:SetFont( "f4.main" )
	ybut:SetTextColor( Color( 255, 255, 255 ) )
	ybut.Paint = function( self, w, h )
		draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 232, 76, 82 ) )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 233, 84, 90 ) )
		
		if self.hover then
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
		end
	end
	ybut.OnCursorEntered = function( self )
		self.hover = true
	end
	ybut.OnCursorExited = function( self )
		self.hover = false
	end
	ybut.DoClick = function()
		local amt = myText:GetValue()
		local str = cmd.." "..target.." "..amt
		if amt and target then
			RunConsoleCommand( "say", str )
		end
		bg:Close()
		jbg:Close()
		textOpen = false
	end
end
--addons/module_elitef4menu/lua/f4/tabs/entities.lua:
local gradient = Material("gui/center_gradient")

local function GetColorBasedOnPrice(price)
    local minPrice = 5000
    local maxPrice = 50000

    local normalized = math.Clamp((price - minPrice) / (maxPrice - minPrice), 0, 1)

    if normalized <= 0.5 then
        local progress = normalized * 2
        local r = math.floor(255 * progress)
        local g = math.floor(255 * progress)
        local b = math.floor(255 * (1 - progress))
        return Color(r, g, b)
    else
        local progress = (normalized - 0.5) * 2
        local r = 255
        local g = math.floor(255 * (1 - progress))
        local b = 0
        return Color(r, g, b)
    end
end


local function LoadEntitiesPanel(tab, parent)
	local pnl = vgui.Create('DPanel', parent)
	pnl:Dock(FILL)
	pnl.Paint = function(s,w,h)
    	draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
		--draw.SimpleText('Список работ', 'f4.main', 24, 20, f4menu.col.text_inactive)
		
	--	surface.SetDrawColor(f4menu.col.secondcolor)
	--	surface.DrawLine(24, 54, w - 26, 54)
	end
	pnl:DockMargin(30, 30, 30, 30)
	pnl:DockPadding(25, 25, 25, 25)

	local lbl = vgui.Create('DLabel', pnl)
	lbl:Dock(TOP)
	lbl:SetAutoStretchVertical(true)
	lbl:SetFont('f4.main')
	lbl:SetTextColor(f4menu.col.text_inactive)
	lbl:SetText('Предметы')

	local scroll = vgui.Create('DScrollPanel', pnl)
	scroll:Dock(FILL)

	scroll.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	scroll.VBar.btnUp.Paint = function( s, w, h ) end
	scroll.VBar.btnDown.Paint = function( s, w, h ) end
	scroll.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end
	
	local panel_list = vgui.Create('DIconLayout', scroll)
	panel_list:Dock(FILL)
	panel_list:SetSpaceX(4)
	panel_list:SetSpaceY(8)
	panel_list:DockMargin(0, 10, 0, 0)
	panel_list:DockPadding( 0, 5, 10, 0 )

	pnl:InvalidateParent(true)

	scroll:InvalidateParent(true)
	scroll:PerformLayoutInternal()

	panel_list:InvalidateParent(true)
	panel_list:InvalidateLayout(true)
	
	pnl.OnSelected = function()
		panel_list:Clear()
		for k, v in pairs( DarkRPEntities ) do
			if not v.allowed or (type(v.allowed) == "table" and table.HasValue(v.allowed, LocalPlayer():Team()))
				and (not v.customCheck or (v.customCheck and v.customCheck(LocalPlayer()))) then
		
				local entFrame = vgui.Create( "DPanel", panel_list ) -- surface.DrawLine( 24, self:GetTall() - 44, self:GetWide() - 24, self:GetTall() - 44 )
				entFrame.price = GetColorBasedOnPrice(v.price)
				entFrame.Paint = function( self, w, h )
        			draw.RoundedBox( 4, 0, 0, w, h, f4menu.col.bg)-- v.color )
                	surface.SetMaterial( gradient )
                	surface.SetDrawColor( self.price )
                	surface.DrawTexturedRect( 0, 0, w, h )
        			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )
					
					draw.SimpleText( v.name, "f4.main", 56, 14, color_white )
					draw.SimpleText( "Цена: "..DarkRP.formatMoney(v.price), "f4.main", 56, 35, Color( 100, 100, 100 ) )
				end
				entFrame.OnCursorEntered = function( self )

				end
				entFrame.OnCursorEntered = function( self )

				end
				
				local entModel = vgui.Create( "SpawnIcon", entFrame )
				entModel:SetSize( 45, 45 )
				entModel:SetPos( 5, 5 )
				entModel:SetModel( v.model )

				entFrame:SetSize((scroll:GetWide() - scroll.VBar:GetWide())/2 - 8, 60)

				local entButton = vgui.Create( "DButton", entFrame )
				entButton:SetSize( entFrame:GetWide(), entFrame:GetTall() )
				entButton:SetText( "" )
				entButton:SetFont( "f4.main" )
				entButton:SetTextColor( Color( 255, 255, 255 ) )
				entButton.Paint = function( self, w, h )
				--	draw.RoundedBox( 4, 1, 1, w , h, f4menu.col.buttonCol )
				end
				entButton.DoClick = function()
					RunConsoleCommand('darkrp', v.cmd)
				end
				
				panel_list:Add( entFrame )
			end
		end
		scroll:PerformLayoutInternal()
	end
	
	return pnl
end

f4menu.addTab('entities', {
	order = 300,
	title = 'Предметы',
	panel = LoadEntitiesPanel,
	icon = Material('icon72/hammer.png'),
})
--addons/module_elitef4menu/lua/f4/tabs/rewards.lua:
f4menu.addTab('rewards', {
	order = 1000,
	title = 'Бонусы',
	panel = function() return rewards.loadF4Panel() end,
	icon = Material('icon72/gift.png'),
	color = Color( 236, 113, 73 ),
})
--addons/module_hits/lua/hitsystem/nwvars.lua:
hook.Add('Think', 'hits.network', function()
    hook.Remove('Think', 'hits.network')

    nw.Register('hitSystem.Orders') -- Таблица всех заказов
        :Write(net.WriteTable)
        :Read(net.ReadTable)
        :SetGlobal()
        :SetHook('hitSystem.OrdersChange')

    nw.Register('hitSystem.IsOrdered') -- Заказан ли
        :Write(net.WriteBool)
        :Read(net.ReadBool)

    nw.Register('hitSystem.DoOrder') -- Выполняет ли заказ
        :Write(net.WriteEntity)
        :Read(net.ReadEntity)
        :SetLocalPlayer()
        :SetHook('hitSystem.DoOrderUpdate')

    nw.Register('hitSystem.MyOrders')
        :Write(net.WriteTable)
        :Read(net.ReadTable)
        :SetLocalPlayer()
        :SetHook('hitSystem.MyOrdersUpdate')
end)
--addons/module_hits/lua/hitsystem/sh/sh_funcs.lua:
local meta = FindMetaTable('Player')

function hitSystem:GetOrders()
    return nw.GetGlobal('hitSystem.Orders') or {}
end

function hitSystem:GetPlyOrders(ply)
    if SERVER then
        return ply:GetNetVar('hitSystem.MyOrders') or {}
    else
        return LocalPlayer():GetNetVar('hitSystem.MyOrders') or {}
    end
end

function meta:IsHitMan()
    return hitSystem.Config.allHitJobs[team.GetName(self:Team())]
end
--addons/weapon_hover/lua/autorun/hoverboards.lua:

AddCSLuaFile()

if ( SERVER ) then

	CreateConVar( "sbox_maxhoverboards", 1, { FCVAR_NOTIFY, FCVAR_ARCHIVE } )
	CreateConVar( "sv_hoverboard_adminonly", 0, { FCVAR_NOTIFY, FCVAR_ARCHIVE } )
	CreateConVar( "sv_hoverboard_cansteal", 0, { FCVAR_NOTIFY, FCVAR_ARCHIVE } )
	CreateConVar( "sv_hoverboard_canshare", 1, { FCVAR_NOTIFY, FCVAR_ARCHIVE } )

	hook.Add('PlayerSwitchWeapon', 'Hoverboards', function(ply)
		if IsValid(ply:GetNWEntity('ScriptedVehicle')) then return true end
	end)
else
	CreateConVar( "cl_hoverboard_developer", "0", FCVAR_CHEAT )

	language.Add( "modulus_hoverboard", "Hoverboard" )
	language.Add( "modulus_hoverboard_hull", "Hoverboard" )
	language.Add( "modulus_hoverboard_avatar", "Hoverboard" )

	killicon.Add( "modulus_hoverboard", "modulus_hoverboard/deathicon", Color( 255, 80, 0, 255 ) )
	killicon.AddAlias( "modulus_hoverboard_hull", "modulus_hoverboard" )
	killicon.AddAlias( "modulus_hoverboard_avatar", "modulus_hoverboard" )
end

/* ------------------------------------------------
	Hoverboard Types
------------------------------------------------ */

HoverboardTypes = {}

table.insert( HoverboardTypes, {
	bonus = {
		jump = 2,
		speed = 1,
		turn = 1,
	},
	model = "models/dav0r/hoverboard/hoverboard.mdl",
	name = "Hackjob",
	rotation = 90,
	driver = Vector( 0, -6, 3 ),
	effect_1 = {
		effect = "trail",
		position = Vector( -4, 16.8, 2 )
	},
	effect_2 = {
		effect = "trail",
		position = Vector(4, 16.8, 2)
	},
	effect_3 = {
		effect = "heatwave",
		position = Vector(0, 5, 0),
		normal = Vector(0, 0, -1),
		scale = 1
	},
	effect_4 = {
		effect = "heatwave",
		position = Vector( 0, -21, 0 ),
		normal = Vector( 0, 0, -1 ),
		scale = 1
	},
	files = {
		"materials/models/hoverboard/boardmap.vmt",
		"materials/models/hoverboard/boardmap.vtf",
		"materials/models/hoverboard/boardnormal.vtf",
		"materials/models/hoverboard/boardtransparency.vmt",
		"materials/models/hoverboard/boardtransparency.vtf"
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		jump = 2,
		flip = 2
	},
	model = "models/ut3/hoverboard.mdl",
	name = "Unreal",
	rotation = 0,
	driver = Vector( 0, 0, 5 ),
	effect_1 = {
		effect = "trail",
		position = Vector( -10.9664, -3.6816,  -6.7901 )
	},
	effect_2 = {
		effect = "trail",
		position = Vector( -11.2077, 4.9971, -6.6772 )
	},
	files = {
		"materials/ut3/hoverboard.vmt",
		"materials/ut3/hoverboard.vtf",
		"materials/ut3/hoverboard_mask.vtf",
		"materials/ut3/hoverboard_normal.vtf"
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		turn = 2,
		speed = 2
	},
	model = "models/jaanus/scopesboard.mdl",
	name = "Huvaboard",
	rotation = 90,
	effect_1 = {
		effect = "plasma_thruster_middle",
		position = Vector( -5.2707, -14.5196, 0 ),
		normal = Vector( 0, 0, -1 )
	},
	effect_2 = {
		effect = "plasma_thruster_middle",
		position = Vector( 5.2707, -14.5196, 0 ),
		normal = Vector( 0, 0, -1 )
	},
	effect_3 = {
		effect = "plasma_thruster_middle",
		position = Vector( 5.2707, 14.5196, 0 ),
		normal = Vector( 0, 0, -1 )
	},
	effect_4 = {
		effect = "plasma_thruster_middle",
		position = Vector( -5.2707, 14.5196, 0 ),
		normal = Vector( 0, 0, -1 )
	},
	effect_5 = {
		effect = "trail",
		position = Vector( -0.2088, 23.0561, -2.6297 ),
	},
	files = {
		"materials/Jaanus/huvaburd.vmt",
		"materials/Jaanus/huvaburd.vtf",
		"materials/Jaanus/enginefuck.vtf",
		"materials/Jaanus/enginefuck.vmt"
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		turn = 1,
		speed = 3
	},
	model = "models/jaanus/truehoverboard_1.mdl",
	name = "Mr. Plank",
	rotation = 90,
	effect_1 = {
		effect = "heatwave",
		position = Vector( 0.2036, 0.3881, -3.2154 ),
		normal = Vector( 0, 0, -1 ),
		scale = 1
	},
	effect_2 = {
		effect = "heatwave",
		position = Vector( 0.2036, 26.1925, -3.2154 ),
		normal = Vector( 0, 0, -1 ),
		scale = 1
	},
	effect_3 = {
		effect = "heatwave",
		position = Vector( 0.1847, -26.8710, -2.8477 ),
		normal = Vector( 0, 0, -1 ),
		scale = 1
	},
	effect_4 = {
		effect = "trail",
		position = Vector( 5.2859, 40.6489, -0.2452 ),
	},
	effect_5 = {
		effect = "trail",
		position = Vector( -5.2859, 40.6489, -0.24527 ),
	},
	files = {
		"materials/Jaanus/bawrd.vmt",
		"materials/Jaanus/bawrd.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		twist = 1,
		speed = 3
	},
	model = "models/jaanus/truehoverboard_2.mdl",
	name = "Mr. Plank II",
	rotation = 90,
	effect_1 = {
		effect = "trail",
		position = Vector( 5.2859, 40.6489, -0.2452 ),
	},
	effect_2 = {
		effect = "trail",
		position = Vector( -5.2859, 40.6489, -0.2452 ),
	},
	files = {
		"materials/jaanus/bawrd.vmt",
		"materials/jaanus/bawrd.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		twist = 2,
		flip = 2
	},
	model = "models/jaanus/stuntboard.mdl",
	name = "Stuntboard",
	rotation = 90,
	effect_1 = {
		effect = "plasma_thruster_middle",
		position = Vector( 3.4516, 0.0278, 0 ),
		normal = Vector( 0, 0, -1 ),
	},
	effect_2 = {
		effect = "plasma_thruster_middle",
		position = Vector( -3.4516, 0.0278, 0 ),
		normal = Vector( 0, 0, -1 ),
	},
	effect_3 = {
		effect = "plasma_thruster_middle",
		position = Vector( -2.4516, 29.2273, 0 ),
		normal = Vector( 0, 0.3, -0.91 ),
	},
	effect_4 = {
		effect = "plasma_thruster_middle",
		position = Vector( 2.4516, 29.2273, 0 ),
		normal = Vector( 0, 0.3, -0.91 ),
	},
	effect_5 = {
		effect = "plasma_thruster_middle",
		position = Vector( -2.4516, -29.2273, 0 ),
		normal = Vector( 0, -0.3, -0.91 ),
	},
	effect_6 = {
		effect = "plasma_thruster_middle",
		position = Vector( 2.4516, -29.2273, 0 ),
		normal = Vector( 0, -0.3, -0.91 ),
	},
	effect_7 = {
		effect = "trail",
		position = Vector( -0.1127, 31.5908, 0.9696 )
	},
	files = {
		"materials/jaanus/stuntboard.vmt",
		"materials/jaanus/stuntboard.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		twist = 2,
		flip = 2
	},
	model = "models/squint_hoverboard/hoverboard.mdl",
	name = "Squint Hoverboard",
	rotation = 90,
	effect_1 = {
		effect = "heatwave",
		position = Vector( 0, 25, -5 ),
		normal = Vector( 0, 0, -1 ),
		scale = 1
	},
	effect_2 = {
		effect = "heatwave",
		position = Vector( 0, -25, -5 ),
		normal = Vector( 0, 0, -1 ),
		scale = 1
	},
	files = {
		"materials/models/squint_hoverboard/squint_hoverboard.vmt",
		"materials/models/squint_hoverboard/squint_hoverboard.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		twist = 6,
		flip = 6,
		speed = 6,
		jump = 6,
		turn = 6
	},
	model = "models/squint_hoverboard/hotrod.mdl",
	name = "HotRod",
	rotation = 90,
	driver = Vector( 1.5, 0, -1.5 ),
	effect_1 = {
		effect = "plasma_thruster_middle",
		position = Vector( 11, 22, 0 ),
		normal = Vector( 0, 1.85, 0.90 ),
	},
	effect_2 = {
		effect = "plasma_thruster_middle",
		position = Vector( -11, 22, 0 ),
		normal = Vector( 0, 1.85, 0.90 ),
	},
	effect_3 = {
		effect = "plasma_thruster_middle",
		position = Vector( 11, 27.5, 0 ),
		normal = Vector( 0, 1.85, 0.90 ),
	},
	effect_4 = {
		effect = "plasma_thruster_middle",
		position = Vector( -11, 27.5, 0 ),
		normal = Vector( 0, 1.85, 0.90 ),
	},
	effect_5 = {
		effect = "plasma_thruster_middle",
		position = Vector( 11, 33, 0 ),
		normal = Vector( 0, 1.85, 0.90 ),
	},
	effect_6 = {
		effect = "plasma_thruster_middle",
		position = Vector( -11, 33, 0 ),
		normal = Vector( 0, 1.85, 0.90 ),
	},
	effect_7 = {
		effect = "trail",
		position = Vector( 8.5, 40, -2.5 ),
	},
	effect_8 = {
		effect = "trail",
		position = Vector( -8.5, 40, -2.5 ),
	},
	files = {
		"materials/models/squint_hoverboard/hotrod/hotrod.vmt",
		"materials/models/squint_hoverboard/hotrod/hotrod.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		speed = 3,
		turn = 2
	},
	model = "models/squint_hoverboard/asltd.mdl",
	name = "Aperture Science Levitantional Transportation Device",
	rotation = 180,
	driver = Vector( -3, 0, 3 ),
	effect_1 = {
		effect = "plasma_thruster_middle",
		position = Vector( -30, 0, 0 ),
		normal = Vector( -15, 0, 1 ),
		scale = 1,
	},
	effect_2 = {
		effect = "heatwave",
		position = Vector( -18, 0, -6 ),
		normal = Vector( 0, 0, -1 ),
	},
	effect_3 = {
		effect = "heatwave",
		position = Vector( 18, 0, -6 ),
		normal = Vector( 0, 0, -1 ),
	},
	effect_4 = {
		effect = "trail",
		position = Vector( -30, 0, 0 ),
	},
	files = {
		"materials/models/squint_hoverboard/asltd/asltd.vmt",
		"materials/models/squint_hoverboard/asltd/asltd.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		flip = 1,
		twist = 3
	},
	model = "models/cloudstrifexiii/boards/trickhoverboard.mdl",
	name = "Cloud's Trickboard",
	rotation = 90,
	driver = Vector( 0, 2, 1 ),
	files = {
		"materials/models/cloudstrifexiii/boards/trickboard.vmt",
		"materials/models/cloudstrifexiii/boards/trickboard.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		speed = 1,
		twist = 1,
		turn = 1,
		jump = 1,
	},
	model = "models/cloudstrifexiii/boards/regularhoverboard.mdl",
	name = "Cloud's Normal Board",
	rotation = 90,
	driver = Vector( 0, 2, 1.5 ),
	files = {
		"materials/models/cloudstrifexiii/boards/normalboard.vmt",
		"materials/models/cloudstrifexiii/boards/normalboard.vtf",
	}
} )

table.insert( HoverboardTypes, {
	bonus = {
		speed = 4
	},
	model = "models/cloudstrifexiii/boards/longhoverboard.mdl",
	name = "Cloud's Longboard",
	rotation = 90,
	driver = Vector( 0, 2, 1 ),
	files = {
		"materials/models/cloudstrifexiii/boards/longboard.vmt",
		"materials/models/cloudstrifexiii/boards/longboard.vtf",
	}
} )

--addons/module_hitregtest/lua/leyhitreg/shared/spreadsystem/bulletspread.lua:
local Vector = Vector
local mathmodf = math.modf
local mathrandomseed = math.randomseed
local mathrandom = math.random
local mathsqrt = math.sqrt
local isnumber = isnumber
local vector_origin = vector_origin

local timefn = function()
    return 1 -- os.date("%S")
end

function LeyHitreg:ApplyBulletSpread(ply, dir, spread)
	if (LeyHitreg.NoSpread) then
		return true, dir, vector_origin
	end

	if (not spread or spread == vector_origin or LeyHitreg.BrokenSpread) then
		return false
	end

	if (isnumber(spread)) then
		spread = Vector(spread, spread, spread)
	end

	local add = (8969 * timefn())

	mathrandomseed(add + CurTime())

	local ang = dir:Angle()

	local appliedSpread, rgt, up = Vector(), ang:Right(), ang:Up()

	local x, y, z

	repeat
		x = mathrandom() + mathrandom() - 1
		y = mathrandom() + mathrandom() - 1

		z = x * x + y * y
	until z <= 1

	for i = 1, 3 do
		appliedSpread[i] = x * spread.x * rgt[i] + y * spread.y * up[i]
	end

	dir = dir + appliedSpread

	return true, dir, appliedSpread
end

--addons/module_hitregtest/lua/leyhitreg/shared/workarounds/swepbases.lua:

function LeyHitreg:ConVarSet(name, val)
    if (GetConVar(name)) then
        RunConsoleCommand(name, val)
    end
end

function LeyHitreg:SWEPConvars()
    self:ConVarSet("arccw_enable_penetration", "0")
    self:ConVarSet("sv_tfa_bullet_penetration", "0")
    self:ConVarSet("sv_tfa_bullet_randomseed", "0")
end

timer.Simple(1, function()
    LeyHitreg:SWEPConvars()
end)
--addons/module_luadev/lua/luadev/socketdev.lua:
if not luadev then
	print"nah"
	return
end

hook.Remove("Think", "LuaDev-Socket") -- upvalues will be lost
if IsValid(SOCKETDEV) then
	SOCKETDEV:Remove()
	SOCKETDEV = nil
end

collectgarbage()
collectgarbage() -- finalizers will be scheduled for execution in the first pass, but will only execute in the second pass

local ok, why
if #file.Find("lua/bin/gmcl_luasocket*.dll", "GAME") > 0 then
	ok, why = pcall(require, "luasocket")
else
	why = "File not found"
end

if not ok then
	print(("\n\n\n\nUnable to load luasocket module (%s), LuaDev socket API will be unavailable\n\n\n\n"):format(tostring(why)))
	return
end

local sock = socket.tcp()
assert(sock:bind("127.0.0.1", 27099))
sock:settimeout(0)
assert(sock:listen(0))

local methods = {
	self = function( sock )
		local who = sock:receive( "*l" )
		luadev.RunOnSelf( sock:receive( "*a" ), who )
		system.FlashWindow()
	end,
	sv = function( sock )
		local who = sock:receive( "*l" )
		luadev.RunOnServer( sock:receive( "*a" ), who )
		system.FlashWindow()
	end,
	sh = function( sock )
		local who = sock:receive( "*l" )
		luadev.RunOnShared( sock:receive( "*a" ), who )
		system.FlashWindow()
	end,
	cl = function( sock )
		local who = sock:receive( "*l" )
		luadev.RunOnClients( sock:receive( "*a" ), who )
		system.FlashWindow()
	end,
	ent = function( sock )
		local who = sock:receive( "*l" )
		local contents = "ENT = {}; local ENT=ENT; "
			.. sock:receive( "*a" )
			.. "; scripted_ents.Register(ENT, '"
			.. who:sub( 0, -5 )
			.. "')"
		luadev.RunOnShared( contents, who )
		system.FlashWindow()
	end,
	client = function( sock )
		local who = sock:receive( "*l" )
		local to = sock:receive( "*l" )
			to = easylua
				and easylua.FindEntity( to )
				or player.GetByID( tonumber( to ) )
			to = { to }
		luadev.RunOnClient( sock:receive( "*a" ), to, who )
		system.FlashWindow()
	end,
	requestPlayers = function( sock )
		local plys = {}
		for _, ply in next, player.GetAll() do
			table.insert( plys, ply:Nick() )
		end

		sock:send( table.concat( plys, "\n" ) )
	end
}

SOCKETDEV = vgui.Create("Panel")
SOCKETDEV:SetMouseInputEnabled(false)
SOCKETDEV:SetKeyBoardInputEnabled(false)
SOCKETDEV:SetSize(0, 0)
SOCKETDEV.Think = function()
	local cl, a, b, c = sock:accept()
	if cl then
		if cl:getpeername() ~= "127.0.0.1" then
			print("Refused", cl:getpeername())
			cl:shutdown()
			return
		end

		cl:settimeout(0)

		local method = cl:receive("*l")

		if method and methods[method] then
			methods[ method ]( cl )
		end
		cl:shutdown()
	end
end

--addons/module_chocolate/lua/autorun/lucid_choc_config.lua:
--
--addons/module_market/lua/market/currencies/points.lua:
wmarket.addCurrency('points', {
    name = 'Рубли',
    description = '',
    decimals = 2,
    formatAmount = function(self, amount)
        return tostring(math.Round(amount, self.decimals or 0))..'₽'
    end,
    canAdd = function(self, ply, amount)
        return true
    end,
    add = function(self, ply, amount)
        ply:PS_GivePoints(amount)
    end,
    canTake = function(self, ply, amount)
        return ply:PS_HasPoints(amount)
    end,
    take = function(self, ply, amount)
        ply:PS_TakePoints(amount)
    end,
    getAmount = function(self, ply)
        return ply:PS_GetPoints()
    end,
})
--addons/module_market/lua/market/vgui/_main.lua:
local PANEL = {}

local mat_circlered = Material('icon72/red_circle.png')
local gradientUp = Material("gui/gradient_up")

function PANEL:Init()
	self.right = vgui.Create('DPanel', self)
	self.right:Dock(RIGHT)
	self.right.Paint = function(s,w,h)
		draw.RoundedBox(0, 0, 0, w, h, f4menu.col.bg)
    	surface.SetMaterial( gradientUp )
    	surface.SetDrawColor( f4menu.col.gradientCol )
    	surface.DrawTexturedRect( 0, 0, w, h )
	end

	self.header = vgui.Create('DPanel', self)
	self.header:Dock(TOP)
	self.header:SetPaintBackground(false)
	self.header:SetTall(34)
	self.header:DockPadding(4, 5, 4, 5)
	self.header.Paint = function(s,w,h)
		draw.RoundedBox(0, 0, 0, w, h, f4menu.col.bg)
	end

	self.curlabel = vgui.Create('DLabel', self.header)
	self.curlabel:Dock(LEFT)
	self.curlabel:DockMargin(4,0,0,0)
	self.curlabel:SetAutoStretchVertical(true)
	self.curlabel:SetFont('wmarket.24')
	self.curlabel:SetText('Валюта для торговли ')
	self.curlabel:SizeToContents()
	self.curlabel:SetTextColor(color_white)

	self.curbox = vgui.Create('DComboBox', self.header)
	self.curbox:Dock(LEFT)
	self.curbox:DockMargin(4,0,0,0)
	self.curbox.OnSelect = function(s, index, val, data)
		self:SetSelectedCurrency(data)
		self:RefreshOrders()
	end

	self.inventory = vgui.Create('DButton', self.header)
	self.inventory:Dock(RIGHT)
	self.inventory:DockMargin(0,0,0,0)
	self.inventory:SetText('Инвентарь')
	self.inventory:SetFont('f4.main')
	self.inventory:SetTextColor( color_white )
	self.inventory:SetWide(90)
	self.inventory.DoClick = function()
		wmarket.openInventory(self)
	end
	self.inventory.Paint = function(s,w,h)
	--	draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 232, 76, 82 ) )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 233, 84, 90 ) )
		
		if s.hover then
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
		end
	end

	self.myorders = vgui.Create('DButton', self.header)
	self.myorders:Dock(RIGHT)
	self.myorders:DockMargin(0,0,4,0)
	self.myorders:SetText('Лоты')
	self.myorders:SetFont('f4.main')
	self.myorders:SetTextColor( color_white )
	self.myorders:SetWide(80)
	self.myorders.DoClick = function()
		wmarket.openMyOrders(self)
	end
	self.myorders.Paint = function(s,w,h)
	--	draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 232, 76, 82 ) )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 233, 84, 90 ) )
		
		if s.hover then
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
		end
	end

	self.storage = vgui.Create('DImageButton', self.header)
	self.storage:Dock(RIGHT)
	self.storage:DockMargin(0,0,8,0)
	self.storage:SetImage('icon72/package.png')
	self.storage:SetWide(26)
	self.storage:SetVisible(#wmarket.storage > 0)
	self.storage.Paint = function(s,w,h)
		surface.SetDrawColor(color_white)
		surface.SetMaterial(mat_circlered)
		surface.DrawTexturedRect(w-6,0,6,6)
	end
	self.storage.DoClick = fp{wmarket.openStorage, self}

	hook.Add('wmarket.storageUpdated', 'updateNotify', function()
		self.storage:SetVisible(#wmarket.storage > 0)
	end)

	self.search = vgui.Create('DTextEntry', self)
	self.search:Dock(TOP)
	self.search:DockMargin(4,2,4,2)
	self.search:SetTall(25)
	self.search:SetPlaceholderText('Поиск')
	self.search:SetUpdateOnType(true)
	self.search.Paint = function(s,w,h)
	   draw.RoundedBox(6,0,0,w,h,f4menu.col.profile)
	   if not s:IsEditing() and s:GetValue() == '' then
	    draw.SimpleText('Поиск..', 'f4.main', 5, 5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	   end
	   s:DrawTextEntryText(color_white, color_black, color_white)
	end
	local filter = wlib.func.debounce(function(text)
		local items = wlib.array.filter(wmarket.items, function(item)
			return utf8.lower(item.name):match(utf8.lower(text))
		end)
		self.filteredItems = items

		self:RefreshOrders(items)
	end, 0.15)
	self.search.OnValueChange = function(s, text)
        filter(text)
    end

	local refreshOrders = wlib.func.debounce(function()
		if not IsValid(self) then return end

		self:RefreshOrders()

		for _, v in ipairs(self.scroll.items) do
			if v.Rebuild then v:Rebuild() end
		end
		if IsValid(self.itempage) then self.itempage:Rebuild() end
	end, 0.1)

	hook.Add('wmarket.summaryUpdated', 'updateOrders', refreshOrders)

	self.scroll = vgui.Create('DScrollPanel', self)
	self.scroll:Dock(FILL)
	self.scroll:DockMargin(4,2,4,2)
	local vbar = self.scroll:GetVBar()
	vbar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	vbar.btnUp.Paint = function( s, w, h ) end
	vbar.btnDown.Paint = function( s, w, h ) end
	vbar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end
	self.scroll.items = {}

	for k, cur in ipairs(wmarket.currencies) do
		if k == 1 then self:SetSelectedCurrency(cur) end
		self.curbox:AddChoice(cur.name, cur, k == 1)
	end

	wmarket.requestSummary()
	wmarket.requestMyStoredItems()
end
wlib.accessor(PANEL, '_selectedItem', 'SelectedItem')
wlib.accessor(PANEL, '_selectedCurrency', 'SelectedCurrency')

function PANEL:Paint(w, h)
	draw.RoundedBox(0,0,0,w,h,f4menu.col.bg)
    surface.SetMaterial( gradientUp )
    surface.SetDrawColor( f4menu.col.gradientCol )
    surface.DrawTexturedRect( 0, 0, w, h )
end

function PANEL:PerformLayout(w, h)
	self.right:SetWide(math.min(w/2, 400))
end

function PANEL:RefreshOrders(items)
	local cur = self:GetSelectedCurrency()
	if not cur then return end

	items = items or self.filteredItems or table.Copy(wmarket.items)
	table.sort(items, function(a, b)
		if a.list_order or b.list_order then return (a.list_order or math.huge) < (b.list_order or math.huge) end
		local asum, bsum = wmarket.getSummary(a.currency or cur.id, a.id), wmarket.getSummary(b.currency or cur.id, b.id)
		asum = asum and asum[MARKET_SELL].total or 0
		bsum = bsum and bsum[MARKET_SELL].total or 0

		if asum == bsum then
			return a.id < b.id
		end

		return asum > bsum
	end)

	self.scroll:Clear()
	for _, item in ipairs(items) do
		if item.visible_currencies and not table.HasValue(item.visible_currencies, cur.id) then continue end
		local sum = wmarket.getSummary(item.currency or cur.id, item.id)
		if not item.list_order and string.Trim(self.search:GetValue()) == '' then
			if not sum or not sum[MARKET_SELL].total or sum[MARKET_SELL].total == 0 then continue end
		end

		local pnl = vgui.Create('wmarket_item', self.scroll)
		pnl:Dock(TOP)
		pnl:DockMargin(0,0,0,2)
		pnl:SetTall(45)
		pnl:SetItem(item)
		pnl:SetCurrency(wmarket.getCurrency(item.currency or cur.id))
		pnl:Rebuild()
		if sum and sum.changed then
			sum.changed = nil
			pnl:Glow()
		end

		pnl.DoClick = function(s)
			wmarket.selectedItem, wmarket.selectedCurrency = item, s:GetCurrency()

			if not IsValid(self.itempage) then
				self.itempage = vgui.Create('wmarket_itempage', self.right)
				self.itempage:Dock(FILL)
			end

			self.itempage:SetItem(item)
			self.itempage:SetCurrency(s:GetCurrency())
			timer.Simple(0, fp{self.itempage.Rebuild, self.itempage})
		end

		table.insert(self.scroll.items, pnl)
	end
end

vgui.Register('wmarket_main', PANEL, 'DPanel')
--addons/module_market/lua/market/vgui/createorder.lua:
local PANEL = {}

local warning = wlib.func.debounce(function(str)
    notification.AddLegacy(str, 1, 3)
    surface.PlaySound('common/warning.wav')
end, 0.05)

function PANEL:Init()
    self.type = MARKET_SELL
    self:DockPadding(6,6,6,6)
    
    self.name = vgui.Create('DLabel', self)
    self.name:Dock(TOP)
    self.name:SetZPos(0)
    self.name:SetAutoStretchVertical(true)
    self.name:SetFont('wmarket.24')
    self.name:SetText('test')
    self.name:SetDark(true)
    
    self.guide_type = vgui.Create('DLabel', self)
    self.guide_type:Dock(TOP)
    self.guide_type:SetZPos(1)
    self.guide_type:DockMargin(0,12,0,0)
    self.guide_type:SetAutoStretchVertical(true)
    self.guide_type:SetText('Тип предложения')
    self.guide_type:SetDark(true)

    self.typeselect = vgui.Create('DComboBox', self)
    self.typeselect:Dock(TOP)
    self.typeselect:SetZPos(2)
    self.typeselect:DockMargin(0,4,0,0)
    self.typeselect:SetSortItems(false)
    self.typeselect:AddChoice('Продажа', MARKET_SELL, true)
    self.typeselect:AddChoice('Покупка', MARKET_BUY)
    self.typeselect.OnSelect = function(s, index, text, data)
        self:_SetType(data)
    end

    self.guide_amount = vgui.Create('DLabel', self)
    self.guide_amount:Dock(TOP)
    self.guide_amount:SetZPos(3)
    self.guide_amount:DockMargin(0,6,0,0)
    self.guide_amount:SetAutoStretchVertical(true)
    self.guide_amount:SetText('Количество')
    self.guide_amount:SetDark(true)

    self.amount = vgui.Create('DNumberWang', self)
    self.amount:Dock(TOP)
    self.amount:SetZPos(4)
    self.amount:DockMargin(0,4,0,0)
    self.amount:SetMinMax(1, 100)
    self.amount:SetText(1)

    self.guide_selfprice = vgui.Create('DLabel', self)
    self.guide_selfprice:Dock(TOP)
    self.guide_selfprice:SetZPos(5)
    self.guide_selfprice:DockMargin(0,18,0,0)
    self.guide_selfprice:SetAutoStretchVertical(true)
    self.guide_selfprice:SetText('Ты получишь (с комиссией)')
    self.guide_selfprice:SetDark(true)

    self.selfprice = vgui.Create('DNumberWang', self)
    self.selfprice:Dock(TOP)
    self.selfprice:SetZPos(6)
    self.selfprice:DockMargin(0,4,0,0)
    self.selfprice:SetMinMax(1, math.huge)
    self.selfprice:SetText(1)

    self.guide_customerprice = vgui.Create('DLabel', self)
    self.guide_customerprice:Dock(TOP)
    self.guide_customerprice:SetZPos(7)
    self.guide_customerprice:DockMargin(0,6,0,0)
    self.guide_customerprice:SetAutoStretchVertical(true)
    self.guide_customerprice:SetText('Покупатель заплатит (за шт.)')
    self.guide_customerprice:SetDark(true)

    self.customerprice = vgui.Create('DNumberWang', self)
    self.customerprice:Dock(TOP)
    self.customerprice:SetZPos(8)
    self.customerprice:DockMargin(0,4,0,0)
    self.customerprice:SetMinMax(1, math.huge)
    self.customerprice:SetText(1)

    self.amount.OnValueChanged = function(s, val)
        if not self.item then return end

        local need = val*self.selfprice:GetValue()
        if self.type == MARKET_BUY and not self.currency:canTake(LocalPlayer(), need) then
            s:SetText(self.prevval or 1)
            warning('У тебя недостаточно валюты для покупки')
            return
        end

        if self.type == MARKET_SELL and not self.item:canTake(LocalPlayer(), val) then
            s:SetText(self.prevval or 1)
            warning('У тебя недостаточно предметов для продажи')
            return
        end
        self.prevval = val
    end

    self.selfprice.OnValueChanged = function(s, val)
        if not self.currency then return end

        local need = val*self.amount:GetValue()
        if self.type == MARKET_BUY and not self.currency:canTake(LocalPlayer(), need) then
            s:SetText(math.Round(self.currency:getAmount(LocalPlayer())/self.amount:GetValue(), self.currency.decimals or 0))
            warning('У тебя недостаточно валюты для покупки', 1, 3)
            return
        end

        local customerprice = math.Round(val/(1-wmarket.config.comission), self.currency.decimals or 0)
        self.customerprice:SetText(customerprice)
    end

    self.customerprice.OnValueChanged = function(s, val)
        if not self.currency then return end
        self.selfprice:SetText(math.Round(val*(1-PS.Config.Comission), self.currency.decimals or 0))
    end

    self.submit = vgui.Create('DButton', self)
    self.submit:Dock(TOP)
    self.submit:SetZPos(9)
    self.submit:DockMargin(0,12,0,0)
    --self.submit:SetTall(25)
    self.submit:SetText('Готово')
    self.submit:SetIcon('icon16/accept.png')
    self.submit.DoClick = fp{self.CreateOrder, self}
end

function PANEL:CreateOrder()
    local type = tonumber(self.typeselect:GetOptionData(self.typeselect:GetSelectedID()))
    local amount = tonumber(self.amount:GetValue())
    local selfprice = tonumber(self.selfprice:GetValue())
    local customerprice = tonumber(self.customerprice:GetValue())

    local str = ('Ты точно хочешь создать лот на %s %sx %q за %s'):format(
        type == MARKET_SELL and 'продажу' or 'покупку',
        amount,
        self.item.name,
        self.currency:formatAmount(type == MARKET_SELL and customerprice or selfprice)
    )
    Derma_Query(str, 'Создание лота', 'Да', function()
        wmarket.createOrder(type, self:GetItem().id, amount, self:GetCurrency().id, type == MARKET_SELL and customerprice or selfprice)
        self:Remove()
    end, 'Нет')
end

function PANEL:PerformLayout(w, h)
    self.name:SetText(wlib.string.wrap(self.item.name, self.name:GetFont(), self.name:GetWide()))
    self.name:SizeToContents()

    self.guide_type:SizeToContents()
    self.guide_amount:SizeToContents()
    self.guide_selfprice:SizeToContents()
    self.guide_customerprice:SizeToContents()
end

function PANEL:_SetType(type)
    self.type = type

    if type == MARKET_SELL then
        self.guide_customerprice:SetVisible(true)
        self.customerprice:SetVisible(true)

        self.guide_selfprice:SetText('Ты получишь (с комиссией)')
        self.guide_customerprice:SetText('Покупатель заплатит (за шт.)')

    else
        self.guide_customerprice:SetVisible(false)
        self.customerprice:SetVisible(false)

        self.guide_selfprice:SetText('Ты готов заплатить (за шт.)')
    end

    self:InvalidateLayout(true)
    self:SizeToChildren(true, true)
end

wlib.accessor(PANEL, 'type', 'Type')
function PANEL:SetType(type)
    self.typeselect:ChooseOptionID(type+1)
    self:_SetType(type)

    return self
end

wlib.accessor(PANEL, 'item', 'Item')
function PANEL:SetItem(item)
    self.item = item
    self.name:SetText(item.name)
    self:InvalidateLayout(true)
    return self
end
wlib.accessor(PANEL, 'currency', 'Currency')

function PANEL:SetAmount(amount)
    self.amount:SetValue(amount)
end

function PANEL:SetSelfPrice(price)
    self.selfprice:SetValue(price)
end

function PANEL:SetCustomerPrice(price)
    self.customerprice:SetValue(price)
end

vgui.Register('wmarket_createorder', PANEL, 'DPanel')
--addons/module_market/lua/market/vgui/inventory.lua:
local PANEL = {}

function PANEL:Init()
    self.search = vgui.Create('DTextEntry', self)
    self.search:Dock(TOP)
    self.search:SetTall(25)
    self.search:SetPlaceholderText('Поиск')
    self.search:SetUpdateOnType(true)
    local filter = wlib.func.debounce(fp{self.Search, self}, 0.15)
    self.search.OnValueChange = function(s, text)
        filter(text)
    end

    self.sheet = vgui.Create('DPropertySheet', self)
    self.sheet:Dock(FILL)

    self.lists = {}

    local scroll = vgui.Create('DScrollPanel')
    local layout = vgui.Create('DIconLayout', scroll)
    layout:Dock(FILL)
    self.sheet:AddSheet('Все', scroll)
    self.lists['_all'] = layout

    --[[
    local scroll = vgui.Create('DScrollPanel')
    self.sheet:AddSheet('Склад (0)', scroll)
    ]]

    for _, item in ipairs(wmarket.items) do
        if not item.category or self.lists[item.category] or item:getAmount(LocalPlayer()) == 0 then continue end
        
        local scroll = vgui.Create('DScrollPanel')
        local layout = vgui.Create('DIconLayout', scroll)
        layout:Dock(FILL)
        
        self.sheet:AddSheet(item.category, scroll)

        self.lists[item.category] = layout
    end

    self:Search('')
end

local function createPanel(data)
    local pnl = vgui.Create('DButton')
    pnl:SetText('')
    pnl:SetWide(140)
    pnl:DockPadding(4,4,4,4)
    
    pnl.image = vgui.Create('DImageButton', pnl)
    pnl.image:Dock(TOP)
    pnl.image:SetTall(pnl:GetWide())
    pnl.image:SetMaterial(data.item.getMaterial and data.item:getMaterial())
    
    pnl.amount = vgui.Create('DLabel', pnl)
    pnl.amount:Dock(RIGHT)
    pnl.amount:DockMargin(0,2,0,0)
    pnl.amount:SetFont('wmarket.20')
    pnl.amount:SetText('x'..math.floor(data.amount))
    pnl.amount:SetContentAlignment(9)
    pnl.amount:SizeToContents()
    pnl.amount:SetDark(true)

    pnl.name = vgui.Create('DLabel', pnl)
    pnl.name:Dock(TOP)
    pnl.name:DockMargin(0,2,0,0)
    pnl.name:SetFont('wmarket.24')
    pnl.name:InvalidateParent(true)
    pnl.name:SetText(wlib.string.wrap(data.item.name, 'wmarket.24', pnl.name:GetWide()))
    pnl.name:SizeToContents()
    pnl.name:SetDark(true)

    pnl:SizeToChildren(false, true)

    pnl.image.DoClick = function()
        pnl:DoClick()
    end

    return pnl
end

function PANEL:Search(text)
    self.categories = {
        _other = {}
    }

    for _, item in ipairs(wmarket.items) do
        if not utf8.lower(item.name):match(utf8.lower(text)) then continue end
        local amount = item:getAmount(LocalPlayer())
        if amount <= 0 then continue end

        local cat = item.category or '_other'
        self.categories[cat] = self.categories[cat] or {}

        table.insert(self.categories[cat], {
            item = item,
            amount = amount,
        })
    end

    self:Refresh()
end

function PANEL:Refresh()
    for cat, list in pairs(self.lists) do
        list:Clear()
    end

    local maxtall = 0
    for cat, v in pairs(self.categories) do
        for _, data in SortedPairsByMemberValue(v, 'amount', true) do
            local btn = createPanel(data)
            btn.DoClick = function()
                wmarket.selectItemPage(data.item)
                self:Remove()
            end
            maxtall = math.max(maxtall, btn:GetTall())

            self.lists['_all']:Add(btn)

            if cat ~= '_other' then
                local btn = createPanel(data)
                btn.DoClick = function()
                    wmarket.selectItemPage(data.item)
                    self:Remove()
                end

                self.lists[cat]:Add(btn)
            end
        end
    end

    for _, list in pairs(self.lists) do
        for _, v in ipairs(list:GetChildren()) do
            v:SetTall(maxtall)
        end
    end
end

function PANEL:UpdateStorage(data)
    local storage = self.sheet:GetItems()[2]
    storage.Tab:SetText('Склад ('..#data..')')

    local scroll = storage.Panel
    scroll:Clear()

    for _, v in ipairs(data) do
        local item = vgui.Create('wmarket_storageitem', scroll)
        item:Dock(TOP)
        item:InvalidateParent(true)
        item:InvalidateLayout(true)

        item:SetData(v)
        timer.Simple(0, fp{item.SizeToContents, item})

        scroll:AddItem(item)
    end
end

vgui.Register('wmarket_inventory', PANEL, 'DPanel')
--addons/ent_moneyclickers/lua/mclickers_config.lua:
------------------------------------------------------------------------
------------------------------------------------------------------------
--  __  __                           ____ _ _      _                  --
-- |  \/  | ___  _ __   ___ _   _   / ___| (_) ___| | _____ _ __ ___  --
-- | |\/| |/ _ \| '_ \ / _ \ | | | | |   | | |/ __| |/ / _ \ '__/ __| --
-- | |  | | (_) | | | |  __/ |_| | | |___| | | (__|   <  __/ |  \__ \ --
-- |_|  |_|\___/|_| |_|\___|\__, |  \____|_|_|\___|_|\_\___|_|  |___/ --
--                          |___/                                     --
--                     ____             __ _                          --
--                    / ___|___  _ __  / _(_) __ _                    --
--                   | |   / _ \| '_ \| |_| |/ _` |                   --
--                   | |__| (_) | | | |  _| | (_| |                   --
--                    \____\___/|_| |_|_| |_|\__, |                   --
--                                           |___/                    --
------------------------------------------------------------------------
------------------------------------------------------------------------

MCLICKERS.clickDelay = 0.1       -- 0.1 seconds delay before being able to click again. This is to prevent auto-clickers.
MCLICKERS.clickRange = 80        -- Range in units that people can click.
MCLICKERS.wireUserEnabled = true -- Can the Wire User be used to withdraw money?
MCLICKERS.antiAutoClick = true   -- After a random amount of clicks, force the user to look away from the clicker.
MCLICKERS.useWorkshop = true    -- Use workshop downloading instead of FastDL for textures
MCLICKERS.stealing = true       -- Enable stealing mechanic, players are required to own (steal) to interact with someone's clicker
MCLICKERS.stealHoldTime = 10     -- How long to hold down in order to steal a clicker

MCLICKERS.SOUND_UI_HOVER = "garrysmod/ui_hover.wav"
MCLICKERS.SOUND_UI_CLICK = "garrysmod/ui_click.wav"
MCLICKERS.SOUND_CLICK    = "buttons/lightswitch2.wav"
MCLICKERS.SOUND_CYCLE    = "garrysmod/content_downloaded.wav"

MCLICKERS.MESSAGE_BREAK = "Один из ваших кликеров сломался!"
MCLICKERS.MESSAGE_UPGRADE_INSUFFICIENT = "Недостаточно средств для обновления"
MCLICKERS.MESSAGE_REPAIR_INSUFFICIENT = "Недостаточно средств для починки"
MCLICKERS.MESSAGE_WITHDRAW = "Ты получил %s."
MCLICKERS.MESSAGE_DEFAULT_UPGRADE_ALLOWED = "Ты не можешь обновить!"
MCLICKERS.MESSAGE_STOLEN = "Ты украл кликер!"
MCLICKERS.MESSAGE_NOT_OWNED = "Этот кликер должен быть ваш!"


MCLICKERS.language = {
    unitAutoClick    = "clicks/s",
    unitClickPower   = "power/click",
    unitCooling      = "heat/0.25s",
    unitStorage      = "storage",

    textWithdraw     = "Снять деньги",
    textRepair       = "Починить",
    textRepairWait   = "Подождите %is",
    textUpgrades     = "Обновления",

    textUpgradeMaxed = "МАКС",
    textPointsAmount = "%i Поинты",
    textMoney        = "Деньги",
    textPoints       = "Поинты",
    textSteal        = "Украсть",
    textStealHold    = "Удерживайте %is чтобы\nукрасть этот кликер",
}

--[[

----------------------------------------
-- How to add your own Money Clickers --
----------------------------------------

To add custom Money Clicker entities, you write the code below in
    darkrpmodification/lua/darkrp_customthings/entities.lua
The code below includes all configuration that is available, some are optional though.
Take a look at the examples further down for 3 tiers of Money Clickers!

To change the colors I recommend going to the following websites
    http://color.adobe.com/
    http://www.materialpalette.com/  -->  http://hex.colorrrs.com/  <--  Need to convert hex to RGB
Make sure the color format looks like this, Color(R, G, B) - example: Color(255, 150, 0) ]]

--[[DarkRP.createEntity("Кликер", { -- The name of the money clicker
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 2500,
    max = 1,
    cmd = "buymoneyclicker1", -- This has to be a unique command for each Money Clicker
    mClickerInfo = {
        pointsPerCycle = 5,     -- How many points you get per cycle
        moneyPerCycle = 15,       -- How much money you get per cycle
        maxPoints = 1000,        -- The base points capacity
        maxMoney = 1500,         -- The base money capacity
        health = 100,            -- How much health it has, a crowbar deals 25 damage
        indestructible = false,  -- Can not be destroyed
        repairHealthCost = 100,  -- Repair health price in points
        maxCycles = 100,         -- Amount of cycles before it breaks, set to 0 to disable
        repairBrokenCost = 300, -- Repair price in money for when the clicker breaks down

        -- The stats the clickers have per upgrade level, each starts at level 1
        -- For example, when you first spawn in a clicker, it will auto click at
        -- a rate of 0 clicks/s which means no auto clicking at all.
        -- With no upgrades to click power, it will increase the progress by 10
        -- each click.
        -- The first entry for the prices is for the second upgrade, as the first
        -- upgrade is the one you have when the clicker is spawned.
        upgrades = {
            autoClick = {
                name = "Авт.Кликер",     -- The display name of the upgrade
                stats = { 0, 1, 2, 3, 4 },       -- Clicks per second, set per upgrade level
                prices = { 450, 550, 650, 750 }, -- Prices for the second upgrade and up (starts with first upgrade)

                -- OPTIONAL: Lua function to check if a player is allowed to purchase the next upgrade
                --           Check examples below for job and group whitelist
                --           Remove if you want all upgrade levels to be available to everyone
                customCheck = function(ply, upgrade, data, current, max)
                    -- Custom check, return true to prevent purchasing upgrade
                    return true, "Optional custom message"
                end,
            },
            clickPower = {
                name = "Сила Клика",         -- The display name of the upgrade
                stats = { 10, 12, 14, 16 },     -- Progress per click, set per upgrade level
                prices = { 430, 560, 730 },     -- Prices for the second upgrade and up (starts with first upgrade)
            },
            cooling = {
                name = "Охлаждение",         -- The display name of the upgrade
                stats = { 1.7, 2.2, 3.5, 5 },   -- Cooling per 0.25 seconds. For reference, max heat is 100
                prices = { 455, 570, 650 },     -- Prices for the second upgrade and up (starts with first upgrade)
            },
            storage = {
                name = "Объем",      -- The display name of the upgrade
                stats = { 1, 2, 3, 4 },         -- Storage modifier, starts at 1x storage
                prices = { 500, 650, 735 },     -- Prices for the second upgrade and up (starts with first upgrade)
            },
        },

        enableHeat = true, -- Make the clicker heat up when clicking it too much, will not blow it up but will disable it for a while
        heatPerClick = 20, -- Max heat is 100

    	colorPrimary = Color(139, 195, 74),  -- The primary color that is used for the entire model
    	colorSecondary = Color(255, 87, 34), -- The secondary color, AKA accent color, used for details
        colorText = Color(255, 255, 255),    -- The color of the text
        colorHealth = Color(255, 100, 100),  -- The color of the health icon
    },
})
]]
--[[You can add however many you want of these if you want different tiers of money clickers.
All of them should use entity "money_clicker"
Want to limit certain upgrades to certain jobs/groups? Check the ScriptFodder description
for some examples (Lua knowledge needed! However there is two examples that does this on the page)]]


--------------------------------
--       Example Setup        --
--------------------------------
-- Bronze, Silver, Gold Tiers --
--------------------------------
--[[
DarkRP.createEntity("Бронзовый Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 5000,
    max = 1,
    cmd = "buymoneyclickerbronze",
    mClickerInfo = {
        pointsPerCycle = 5,
        moneyPerCycle = 45,
        maxPoints = 1000,
        maxMoney = 1500,
        health = 100,
        indestructible = false,
        repairHealthCost = 100,
        maxCycles = 100,
        repairBrokenCost = 450,

        upgrades = {
            autoClick = {
                name = "Авт.Кликер",
                stats = { 0, 1, 2, 3, 4 },
                prices = { 455, 550, 650, 765 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 10, 12, 14, 16 },
                prices = { 440, 520, 650 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 1.7, 2.2, 3.5, 5 },
                prices = { 450, 550, 650 },
            },
            storage = {
                name = "Объем",
                stats = { 1, 2, 3, 4 },
                prices = { 530, 600, 720 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

    	colorPrimary = Color(139, 195, 74),
    	colorSecondary = Color(255, 87, 34),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 100, 100),
    },
})

DarkRP.createEntity("Серебряный Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 10000,
    max = 1,
    cmd = "buymoneyclickersilver",
    mClickerInfo = {
        pointsPerCycle = 5,
        moneyPerCycle = 1000000,
        maxPoints = 2000,
        maxMoney = 3500,
        health = 2000,
        indestructible = false,
        repairHealthCost = 100,
        maxCycles = 100,
        repairBrokenCost = 700,

        upgrades = {
            autoClick = {
                name = "Авт.кликер",
                stats = { 1, 2, 3, 4, 5 },
                prices = { 470, 555, 625, 750 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 15, 17, 19, 21 },
                prices = { 450, 675, 800 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 1.8, 2.3, 3.6, 5.2 },
                prices = { 450, 575, 725 },
            },
            storage = {
                name = "Объем",
                stats = { 1, 2.5, 4, 6 },
                prices = { 450, 575, 625 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

    	colorPrimary = Color(139, 195, 74),
    	colorSecondary = Color(255, 87, 34),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 100, 100),
    },
})

DarkRP.createEntity("Золотой Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 17000,
    max = 1,
    cmd = "buymoneyclickergold",
    mClickerInfo = {
        pointsPerCycle = 7,
        moneyPerCycle = 65,
        maxPoints = 4000,
        maxMoney = 6000,
        health = 100,
        indestructible = true,
        repairHealthCost = 100,
        maxCycles = 100,
        repairBrokenCost = 900,

        upgrades = {
            autoClick = {
                name = "Авт.Кликер",
                stats = { 2, 3, 4, 5, 6 },
                prices = { 450, 565, 755, 870 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 20, 22, 24, 26 },
                prices = { 450, 665, 875 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 2, 2.5, 4, 6 },
                prices = { 460, 625, 875 },
            },
            storage = {
                name = "Объем",
                stats = { 1, 3, 5, 8 },
                prices = { 450, 525, 775 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

    	colorPrimary = Color(139, 195, 74),
    	colorSecondary = Color(255, 87, 34),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 100, 100),
    },
})
]]

--addons/module_outfitter/lua/autorun/outfitter.lua:
--do return end
--[[

BUGS
====================

GOING THROUGH WITHOUT REJECT !outfitter 187243854

OUTFITTER REJECTS
	191146401 -- noattachments
	164449803 -- hip


	[OF ERROR] @  lua/outfitter/cl_util.lua:792: GMAPlayerModels Disagreement C:\Program Files (x86)\Steam\steamapps\workshop\content\4000\2242241647/ena_pm13_2.gma models/player/ena/ch/ena_carm.mdl

	
	Strict mode?

	(partially fixed) 1367741116 ragdoll lags to hell
	(partially fixed) OnDeathRagdollCreated Enforce call lags to hell, but without it ragdoll won't get applied force

Worldmodel vanishing
	is it pac bug or outfitter?

Prevent workshop addon overriding resources to prevent crashes and trolling
	database list of: player - wsaddon - model, etc

Any prop wear from any game instead of a workshop addon

ent:SnatchModelInstance()
"hl2mp_ragdoll"

TODO
====================
	Check for spectators and do nothing for "models/player.mdl" 
	Perfmode only disable downloading, allow enforcing
	
	BodyGroups testing 	471628201
	NSFW test crashes: 2806932615 (huge addon, crashes outside outfitter?)
	list favorited from workshop (playermodels heuristic?)
	Add icons to history list
	PAC part for outfitter
		Multiple ws addons single outfit?
			separate workshop mounter thing
	Hands model from outfits

	Interlock functions so they don't execute at the same time?
		At least prevent more than 2 downloads at once
		LZMA decompress in separate step

	Bodygroups
	skin

	Allow custom skinning from jpg??

	Whitelist mode for competitive servers

	mdl parse further to prevent easy crashing

	[OF ERROR] @lua/outfitter/cl_util.lua:792: GMAPlayerModels Disagreement X:\g\steam\steamapps\workshop\content\4000\2242241647/ena_pm7.gma models/player/ena/ch/ena_carm.mdl

	More sounds / notifications
		npc/vort/claw_swing1.wav

		npc/scanner/scanner_scan1.wav
		npc/scanner/scanner_scan2.wav

		common/warning.wav
		buttons/button2.wav
		BEP BEP BEP ui/system_message_alert.wav

		ui/buttonclick.wav

		items/suitchargeok1.wav

		items/suitchargeno1.wav

		Great scott
		vo/trainyard/kl_morewarn01.wav
	TTT
		Spectators force localplayer hands
		TTTFIX may be crashing people
		PAC may be overriding clientside also, add exp. backoff
		mdls appear valid but become errors after mapchange. OBBMins on player is invalid. 		
]]



local function requireSH(name)
	AddCSLuaFile(("includes/modules/%s.lua"):format(name))
	local ok,err = pcall(require,name)
	if not ok then
		hook.Add("Initialize",Tag..'fail',function()

			timer.Simple(1,function()
				chat.AddText(Color(200,50,10,255),"OUTFITTER LOADING FAILED:",Color(255,255,255,255),err)
			end)

		end)
		return
	end
end

if not util.OnLocalPlayer then
	requireSH 'hookextras'
end


requireSH 'binfuncs'
requireSH 'co'
requireSH 'coext'
requireSH 'fileextras'
requireSH 'gmaparse'
requireSH 'imgparse'
requireSH 'isdormant'
requireSH 'mdlinspect'
requireSH 'netobj'
requireSH 'netqueue'
requireSH 'playerextras'
requireSH 'sqlext'
requireSH 'ubit'
requireSH 'urlimage'


local Tag='outfitter'

--TODO:
 -- !outfitter 187243854
 -- bodygroups
module(Tag,package.seeall)

_M.this = setmetatable({},{__index = function(self,k) return rawget(_M,k) end,__newindex=_M})
this.Tag =Tag
this.NTag = 'OF'

local outfitter_dbg_tosv = SERVER and CreateConVar("outfitter_dbg_tosv","0") or CreateClientConVar("outfitter_dbg_tosv","0",false,false)
local outfitter_dbg = SERVER and CreateConVar("outfitter_dbg","1") or CreateClientConVar("outfitter_dbg","0",true,false)
_M.outfitter_dbg = outfitter_dbg

function isdbg(n)
	return outfitter_dbg:GetInt()>(n or 0)
end

function dbg(...)
	if isdbg() then
		Msg"[Outfitter] "
		if outfitter_dbg_tosv:GetBool() then
			if easylua then
				easylua.Print(...)
			else
				ErrorNoHalt(...)
			end
		else
			print(...)
		end
	end
end

function dbgn(n,...)
	if isdbg(n) then
		return dbg(...)
	end
end

function dbge(...)
	return dbgelvl(2,...)
end

local redcolor = Color(255, 0, 0)
function dbgelvl(lvl,...)
	--if not outfitter_dbg:GetBool() then return end
	local caller = debug.getinfo((lvl or 1)) or {}
	local src = caller.source or "?"
	src=src:gsub(".*/lua/","/")
	local t = {'[OF ERROR]',src..':'..(caller.currentline or -1)..':' }
	for i=1,select('#',...) do
		local v=select(i,...)
		v=tostring(v) or "no value"
		t[#t+1]=v
	end
	local traceback = debug.traceback
	if outfitter_dbg_tosv:GetBool() or OUTFITTER_DEBUG_VERBOSE then
		ErrorNoHalt(traceback(table.concat(t,' '), (lvl or 1))..'\n')
	else
		MsgC(redcolor, traceback(table.concat(t,' '), (lvl or 1))..'\n')
	end
end


local S=SERVER
local C=CLIENT
local function inc(str)
	return function(m)
		local path = Tag..'/'..str..'.lua'

		if S and (m=='sh' or m=='cl') then
			AddCSLuaFile(path)
		end

		if m == 'sh'
			or (S and m=='sv')
			or (C and m=='cl')
		then
			return include(path)
		end
	end
end

_M.json = inc 'json'		'sh'

inc 'cl_util'	'cl'
inc 'gma'		'sh'
inc 'cl_hacks'	'cl'
inc 'sh'		'sh'
inc 'sv'		'sv'
inc 'cows'		'cl'
inc 'cl'		'cl'
inc 'ui'		'cl'
inc 'skin'		'cl'

inc 'gui_about'	'cl'
inc 'gui_ofworkshopicon'	'cl'
inc 'gui_bodygroups'		'cl'
inc 'gui'		'cl'

inc 'net'		'sh'

gma.rebuild_nolua_cache_purge(function(path)
	dbgn(4,"Attempting cleaning cache: "..tostring(path))
end)

--addons/module_outfitter/lua/includes/modules/hookextras.lua:
if SERVER then
	AddCSLuaFile()
end


local functions = { }
local added = false
local function Stop()
	hook.Remove("Think", "NextThinkHelper")
end

local function error_func(line)
	ErrorNoHalt("NextThink: "..debug.traceback(line,2))
end

local function Think()
	local n = #functions
	if n == 0 then
		Stop()
		return
	end

	for i = 1, n do
		local func = table.remove(functions, 1)
		xpcall(func,error_func)
	end

end

local function Start()
	if added then
		return
	end

	hook.Add("Think", "NextThinkHelper", Think)
end

function RunNextThink(func)
	if not isfunction(func) then
		error("Expected function", 2)
	end

	functions[#functions + 1] = func
	Start()
end

NextThink = RunNextThink
util.NextThink = NextThink
util.NextFrame = NextThink

do
	-- OnInitialize

	local functions = { }
	local initialized = false

	local function error_func(line)
		ErrorNoHalt("OnInitialize: " .. debug.traceback(line, 2))
	end

	local function Initialize()
		if initialized then return end
		initialized = true
		-- HACK: Make sure RunOnInit works even inside RunOnInit
		local overflow = true
	
		for i = 1, #functions + 262140 do
			local func = functions[i]
	
			if not func then
				overflow = false
				break
			end
	
			xpcall(func, error_func)
		end
	
		if overflow then
			ErrorNoHalt("[WARN] RunOnInit hook list overflowed? ", #functions, "\n")
		end
	
		functions = nil
		hook.Remove("Initialize", "RunOnInitializeHelper")
	end


	function RunOnInit(func)
		if not isfunction(func) then
			error("Expected function", 2)
		end

		if not functions then
			timer.Simple(0,func)
			return
		end

		functions[#functions + 1] = func
	end
	RunOnInitialize = RunOnInit
	OnInitialize = RunOnInit
	util.OnInitialize = RunOnInit

	hook.Add("Initialize", "RunOnInitializeHelper", Initialize)
	hook.Add("InitPostEntity", "RunOnInitializeHelper", function()
		if initialized then return end
		ErrorNoHalt("[WARN] 'Initialize' hook 'RunOnInitializeHelper' did not run! (bugs in other addons? Possibly adding Initialize hooks while in Initialize hook?)\n")
		Initialize()
	end)
end

if CLIENT then

	-- OnLocalPlayer

	local functions = { }
	local initialized = false

	local function error_func(line)
		ErrorNoHalt("OnLocalPlayer: " .. debug.traceback(line, 2))
	end

	local function OnEntityCreated(ent)

		local me = LocalPlayer()
		if ent~=me then return end
		assert(not initialized)
		initialized = true
		
		for i = 1, #functions do
			local func = functions[i]
			xpcall(func, error_func, me)
		end

		functions = nil
		hook.Remove("OnEntityCreated", "OnLocalPlayer")
		hook.Remove("NetworkEntityCreated", "OnLocalPlayer")
	end


	local function util_OnLocalPlayer(func)
		if not isfunction(func) then
			error("Expected function", 2)
		end
		
		if not functions then
			timer.Simple(0,function() func(LocalPlayer()) end)
			return
		end
		
		functions[#functions + 1] = func
	end

	util.OnLocalPlayer = util_OnLocalPlayer
	if IsValid(LocalPlayer()) then
		OnEntityCreated(LocalPlayer()) 
	else
		hook.Add("OnEntityCreated", "OnLocalPlayer", OnEntityCreated)
		hook.Add("NetworkEntityCreated", "OnLocalPlayer", OnEntityCreated)
		
		timer.Simple(1, function()
			if LocalPlayer():IsValid() and not initialized then
				error_func"OnEntityCreated did not catch LocalPlayer??"
				OnEntityCreated(LocalPlayer())
			end
		end)
	end
	
end

--addons/module_outfitter/lua/includes/modules/co.lua:
--setfenv(1,_G)
local NATIVE = MENU_DLL ==nil and SERVER==nil and CLIENT==nil

if SERVER then AddCSLuaFile() end

local coroutine = coroutine or require'coroutine'

local meta={}
local co=setmetatable({},meta)
local s,look = {},{}
co.stack = s

local function push(thread)
	local n = #s+1
	s[n]=thread
	look[thread]=n
	return n
end

local function pop()
	local n = #s
	local thread = s[n]
	look[thread]=nil
	s[n]=nil
	return thread,n
end

local function peek()
	local n = #s
	return s[n],n
end

local function has(thread)
	return look[thread]
end

if not NATIVE then
	_G.co=co
end

co._SimpleTimer = not NATIVE and timer.Simple or function() error"Please implement co._SimpleTimer" end

-- todo
--	error handler wrapper?
--	select() polling support (epoll() please :c)
--	co.make steal parameters
--	?


local waitticks = {}
local -- Unique identifiers
	SLEEP,
	CO_RET,
	SLEEP_TICK,
	CO_END,
	CALLBACK,
	CALL_OUTSIDE,
	CALL_OUTSIDE_NORET,
	ENDED,
	ABORTED,
	
	RETURN_RESULT,
	
	_
	
	={},{},{},{},{},{},{},{},{},{},{}
	
local extra_state = setmetatable({},{__mode='k'})

local function check_coroutine(thread)
	if thread==nil then
		thread = coroutine.running()
	end
	local curco = peek()
	if curco ~= thread then
		error("Not inside co-style coroutine",2)
	end
	if not thread then
		error("Can not call outside coroutine",2)
	end
end

local function in_co(thread)
	if thread==nil then
		thread = coroutine.running()
	end
	local curco = peek()
	return curco == thread and thread
end

co.running = in_co

local function __re(thread,ok,t,val,...)
	
	pop()
	
	if not ok then
		ErrorNoHalt("[CO] "..debug.traceback(thread,tostring(t))..'\n')
		return
	end
	
	if t==SLEEP then
		--Msg"[CO] Sleep "print(val)
		co._SimpleTimer(val,function()
			co._re(thread,SLEEP)
		end)
		
		return
		
	elseif t==SLEEP_TICK then
		table.insert(waitticks,thread)
	elseif t==CALLBACK or t==nil then -- wait for callback
	--elseif t==CB_ONE then -- wait for any one callback
	elseif t==CALL_OUTSIDE then
		co._re(thread,CALL_OUTSIDE,val(...))
	elseif t==CALL_OUTSIDE_NORET then
		co._re(thread,CALL_OUTSIDE_NORET)
		val(...)
	elseif t==CO_END then
		--Msg"[CO] END "print("OK")
		local t = extra_state[thread]
		if t~=nil and t~=ENDED and t~=ABORTED then
			for _,thread2 in next,t do
				co._re(thread2,true,val,...)
			end
		end
		extra_state[thread]=ENDED
		return val,...
	elseif t==CO_RET then -- return some stuff to the callback, continue coroutine
		--[[local discard,... = ]] co._re(thread,CO_RET)
		return val,...
	else
		ErrorNoHalt("[CO] Unhandled "..tostring(t)..'\n')
	end
	

end

co._re=function(thread,...)
	
	if extra_state[thread] == ABORTED then return end
	
	local status = coroutine.status(thread)
	if status=="running" then
		-- uhoh?
	elseif status=="dead" then
		assert(false, "Cannot resume a dead co thread.\nContact your systems necromancer!")
		-- we can do nothing
		return
	elseif status=="suspended" then
		-- all ok
	else
		assert(false,"Unknown coroutine status!?")
	end

	push(thread)

	return __re(thread,coroutine.resume(thread,...))
	
end

function co.alive(thread)
	if extra_state[thread] == ABORTED then return false,'aborted' end
	if extra_state[thread] == ENDED then return false,'ended' end
	
	local status = coroutine.status(thread)
	if status=="running" then
		return true,"running"
	elseif status=="dead" then
		return false,'dead'
	elseif status=="suspended" then
		return true,'suspended'
	end
	
	assert(false,"Unknown coroutine status!?")
end

function co.finish(...)
	coroutine.yield(CO_END,...)
	assert(false,"co.finish() returned")
end

function co.kill(thread)
	local status = coroutine.status(thread)
	
	--may want to kill dead coroutine so it doesn't error more
	--if status=="dead" then
	--	return
	--end
	
	local t = extra_state[thread]
	extra_state[thread] = ABORTED
	if t~=nil and t~=ENDED and t~=ABORTED then
		for _,thread2 in next,t do
			co._re(thread2,false,'killed')
		end
	end
end

local function Think()
	local count=#waitticks
	for i=count,1,-1 do
		local thread = table.remove(waitticks,i)
		co._re(thread,SLEEP_TICK)
	end
end
co._Think=Think

if not NATIVE then
	hook.Add(MENU_DLL and "Think" or "Tick","colib",co._Think)
end

function meta:__call(func,...)
	
	assert(type(func)=='function',"invalid parameter supplied")
	
	local thread = coroutine.create(function(...)
		func(...)
		return CO_END
	end)
	
	return thread,co._re(thread,...)
end

function co.wrap(func,...)
	
	assert(type(func) == 'function',"invalid parameter supplied")
	
	local thread = coroutine.create(function(...)
		func(...)
		return CO_END
	end)
	
	return function(...)
		return co._re(thread,...)
	end
end


function co.join(thread2)
	local thread = co.running()
	if extra_state[thread2]==ENDED then
		return nil,'ended'
	end
	if extra_state[thread2]==ABORTED then
		return nil,'aborted'
	end
	local t = extra_state[thread2]
	if not t then
		t={}
		extra_state[thread2]=t
	end
	
	t[#t+1] = thread
	return true,coroutine.yield(nil)
end


--- make a thread out of this function
--- If we are already in a thread, reuse it. It has to be a co thread though!
function co.make(...)

	local thread = in_co()
	if thread then return false,thread end
	
	local func = debug.getinfo(2).func
	return true,co(func,...)
end

local function wrap(ok,a,...)
	if ok then
		return ...
	end
end

--[[ -- TODO
function co.cox(...)
	local t={...}
	local tc =#t
	local func = t[tc-1]
	local err = t[tc]
	t[tc]=nil
	t[tc-1]=nil
	
	assert(isfunction(func),"invalid parameter supplied")
	
	local thread = coroutine.create(function(unpack(t))
		xpcall(func,err,...)
	end)
	co._re(thread,...)
	
	return thread
end
--]]

function co.wait(delay)
	
	check_coroutine()
	local ret = coroutine.yield(SLEEP,tonumber(delay) or 0)
	if ret ~= SLEEP then
		error("Invalid return value from yield: "..tostring(ret))
	end
	--Msg"[CO] End wait "print(ret)
end

function co.waittick()
	
	check_coroutine()
	
	local ret = coroutine.yield(SLEEP_TICK)
	if ret ~= SLEEP_TICK then
		error("Invalid return value from yield: "..tostring(ret))
	end
	--Msg"[CO] End wait "print(ret)
end

co.sleep=co.wait

local function wrap(ret,...)
	if ret ~= CALL_OUTSIDE then
		error("Invalid return value from yield: "..tostring(ret))
	end
	
	return ...
	
end

function co.extern(func,...)

	check_coroutine()
	
	return wrap(coroutine.yield(CALL_OUTSIDE,func,...))
	
end
function co.expcall(...)

	return co.extern(xpcall,...)
	
end


local function wrap(ret,...)
	if ret ~= CALL_OUTSIDE_NORET then
		error("Invalid return value from yield: "..tostring(ret))
	end
	
	assert(not (...),"noreturn returned?")
	
	return ...
	
end

function co.extern_noret(func,...)

	check_coroutine()
	
	return wrap(coroutine.yield(CALL_OUTSIDE_NORET,func,...))
	
end

function co.expcall_noret(...)

	return co.extern_noret(xpcall,...)
	
end


-- LEGACY
function co.newcb2(res)
	
	local thread = peek()

	check_coroutine(thread)
	
	
	--TODO: infinite return value support?
	local called,_1,_2,_3,_4,_5,_6,_7
	local CB CB = function(a,...)
		if a == RETURN_RESULT then
			return called,_1,_2,_3,_4,_5,_6,_7
		end
		
		if in_co(thread) then
			called,_1,_2,_3,_4,_5,_6,_7 = true,...
			return res
		end
			
		return co._re(thread,CALLBACK,CB,a,...)
	end
	return CB
end


function co.newcb()
	
	local thread = peek()

	check_coroutine(thread)
	
	--Msg"[CO] Created cb for thread "print(thread)
	local CB CB = function(...)
		--Msg("[CO] Callback called for thread ",thread)print("OK")
		
		return co._re(thread,CALLBACK,CB,...)
	end
	return CB
end

function co.extern_waitcb(func)
	local cb=co.newcb()
	co.extern_noret(func,cb)
	return co.waitcb(cb)
end
function co.extern_waitone(func,...)
	co.extern_noret(func,...)
	return co.waitone()
end

-- Example: print(co(function() co.ret"asd" end))
function co.ret(...)
	local ret = coroutine.yield(CO_RET,...)
	if ret ~= CO_RET then
		error("Invalid return value from yield: "..tostring(ret))
	end
end

function co.yield(...)
	co.yield_prepare()
	--coroutine.yield(nil)
	coroutine.yield(...)
end

function co.yielder_begin(...)
	co.yield_prepare()
	--coroutine.yield(nil)
	while coroutine.yield(...)~=CALLBACK do end
end

function co.yielder_finish(thread)
	return co._re(thread,CALLBACK)
end

function co.yield_prepare()
	coroutine.yield(CALLBACK)
end

local function _waitonewrap(caller,...)
	return ...
end

-- see co.fetch for example
function co.waitcb(cb)

	if cb==nil then
		return _waitonewrap(co.waitone())
	end
	
	check_coroutine()
		
	local function wrap(ret,caller,...)
		if ret ~= CALLBACK then
			error("Invalid return value from yield: "..tostring(ret))
		end
		if caller~=cb then
			error("Wrong callback returned")
		end
		return ...
	end
	
	return wrap(coroutine.yield(CALLBACK))
	
end

local function removeone(_,...) return ... end

function co.waitcb2(cb)

	check_coroutine()
	
	if (cb(RETURN_RESULT)) then
		return removeone( cb(RETURN_RESULT) )
	end
	
	local function wrap(ret,caller,...)
		if ret ~= CALLBACK then
			error("Invalid return value from yield: "..tostring(ret))
		end
		if caller~=cb then
			error("Wrong callback returned")
		end
		return ...
	end
	
	return wrap(coroutine.yield(CALLBACK))
	
end

--same as above but returns the CB too
local function wrap(ret,caller,...)
	if ret ~= CALLBACK then
		error("Invalid return value from yield: "..tostring(ret))
	end
	return caller,...
end

function co.waitone()
	
	check_coroutine()
	
	return wrap(coroutine.yield(CALLBACK))
	
end

local function error_propagator(ok,err,...)
	if not ok then
		error(err)
	end
	
	return err,...
end
	
function co.worker(worker,...)
	local queue = {}
	local started
	local task
	local function work()
		while queue[1] do
			task = queue[1]
			table.remove(queue,1)
			started = false --failsafe?
				task[1](true,worker(unpack(task,2)))
			started = true
			task=nil
		end
	end
		
	local function thread()
		started = true
		
		co.waittick() -- detach thread to preserve order
		
		local ok,err
		while not ok do
			ok,err = xpcall(work,debug.traceback)
			if not ok and err then
				if task then
					task[1](false,err)
				else
					ErrorNoHalt('[Worker] '..err..'\n')
				end
			end
		end
		started = false
	end
	local function resume()
		if started then return end
		started = true
		co(thread)
		
	end
	local function add_task( ... )
		local cb = co.newcb()
		queue[#queue+1] = {cb,...}
		resume()
		return error_propagator(co.waitcb(cb))
	end
	
	return add_task,queue,...
	
end

function co.work_cacher_filter(filter,worker,cache,...)
	local function check_cache(key,ret1,...)
		local cached = cache[key]
		if cached then
			local keep = filter(key,ret1,...)
			if not keep then
				cache[key] = nil
			end
		end
		return ret1,...
	end
	local function filter_processor(key,...)
		return check_cache(key,worker(key,...))
	end
	return filter_processor,cache,...
end


local WEAK = { __index='v' }
function co.work_cacher(worker,weak)
	local cache = weak and setmetatable({},WEAK) or {}
	
	local function cache_this(key,...)
		cache[key]={...}
		return ...
	end
	
	local function cacher(key,...)
		local cached = cache[key]
		if cached then
			return unpack(cached)
		end
		return cache_this(key,worker(key,...))
	end
	return cacher,cache
end


-- Example: co(function() local ret=co.future(co.fetch,'http://metastruct.net/404ohno') print(ret()) end)
function co.future(func,...)
	
	local cb
	local returned
	local function mediator(...)
		returned = true
		--print("future finished",requesting and "using cb" or "returning","RET:",...)
		if cb then
			cb(...)
		end
		
		return ...
	end
	local thread2 = co(function(...)
		co.yield(mediator(func(...)))
		assert(false,"co.future() should not continue")
	end,...)
	
	local function future_wait()
		--print("future",returned and "returned" or "not returned")

		if returned then
			return coroutine.resume(thread2)
		end
		
		cb=co.newcb()
		return co.waitcb(cb)
		
	end
	return future_wait
end




-- testing --



--[[ -- Instantly returning callback handling
local function evil(cb)
	print("returned",cb("hello"))
end
local function good(cb)
	print("Good timer startin")
	timer.Simple(0.1,function()
		evil(cb)
	end)
end


local isevil  = true

co(function()
	local cb = co.newcb()
	local r = co.running()
	
	local good = isevil and evil or good
	
	local ret = co.extern_waitcb(function(cb)
		good(cb)
	end)
	
	co.ret("return value to callback")
	
	print("runcb returned",ret)
	print"end coro"
end)

--]]


--[[

co.wrap(function()
	
	local w = co.extern(function(...) return ... end,"extern")
	
	assert(w=="extern")
	
	local ct = os.clock()
	co.waittick()
	assert(ct~=os.clock())

	
	local ct = os.clock()
	co.sleep(0.2)
	assert(ct~=os.clock())
	
	local ok,dat,a,b,c,d = co.fetch("http://iriz.uk.to/404")

	assert(isstring(dat))
	
end)()

--]]--

-- future test
--[[
local function test(n)
	print("test"..n,'sleep')
	co.sleep(n)
	print("test"..n,'slept')
	return n+0,"bleh"
end

co(function()
	local a =RealTime()
	local f=co.future(test,0.5)
	local f2=co.future(test,2)
	print("FIRST",RealTime()-a,f())
	print("SECOND",RealTime()-a,f2())
end)
]]


return co,co._Think

--addons/module_outfitter/lua/includes/modules/imgparse.lua:

if SERVER then AddCSLuaFile() end


local function unpack_msb_uint32(s)
  local a,b,c,d = s:byte(1,#s)
  local num = (((a*256) + b) * 256 + c) * 256 + d
  return num
end
local function unpack_msb_uint32_r(s)
  local d,c,b,a = s:byte(1,#s)
  local num = (((a*256) + b) * 256 + c) * 256 + d
  return num
end

local function read_msb_uint32(fh)
  return unpack_msb_uint32(fh:Read(4))
end

local function read_byte(fh)
  return fh:Read(1):byte()
end


local function parse_zlib(fh, len)
  local byte1 = read_byte(fh)
  local byte2 = read_byte(fh)

  local compression_method = byte1 % 16
  local compression_info = math.floor(byte1 / 16)

  local fcheck = byte2 % 32
  local fdict = math.floor(byte2 / 32) % 1
  local flevel = math.floor(byte2 / 64)


  fh:Read(len - 6)
  
  local checksum = read_msb_uint32(fh)
  
end

local function parse_IHDR(tbl,fh, len)
  assert(len == 13, 'format error')
  local width = read_msb_uint32(fh)
  local height = read_msb_uint32(fh)
  local bit_depth = read_byte(fh)
  local color_type = read_byte(fh)
  local compression_method = read_byte(fh)
  local filter_method = read_byte(fh)
  local interlace_method = read_byte(fh)

  tbl.width= width
  tbl.height= height
  tbl.bit_depth= bit_depth
  tbl.color_type= color_type
  tbl.compression_method= compression_method
  tbl.filter_method= filter_method
  tbl.interlace_method= interlace_method

  return compression_method
end

local function parse_sRGB(tbl,fh, len)
  assert(len == 1, 'format error')
  local rendering_intent = read_byte(fh)
  tbl.rendering_intent= rendering_intent
end

local function parse_gAMA(tbl,fh, len)
  assert(len == 4, 'format error')
  local rendering_intent = read_msb_uint32(fh)
 tbl.rendering_intent= rendering_intent
end

local function parse_cHRM(tbl,fh, len)
  assert(len == 32, 'format error')

  local white_x = read_msb_uint32(fh)
  local white_y = read_msb_uint32(fh)
  local red_x = read_msb_uint32(fh)
  local red_y = read_msb_uint32(fh)
  local green_x = read_msb_uint32(fh)
  local green_y = read_msb_uint32(fh)
  local blue_x = read_msb_uint32(fh)
  local blue_y = read_msb_uint32(fh)

end

local function parse_IDAT(tbl,fh, len, compression_method)
  if compression_method == 0 then
    -- fh:Read(len)
    parse_zlib(fh, len)
  else
   
  end
end

function file.ParsePNG(fh)
  if isstring(fh) then
  	fh = file.Open(fh,'rb','GAME')
  	
  end
  if not fh then error"Invalid file" end
  
  local tbl = {}
  
  -- parse PNG header
  local bytes = fh:Read(8)
  local expect = "\137\080\078\071\013\010\026\010"
  if bytes ~= expect then
    error 'not a PNG file'
  end

  -- parse chunks
  local compression_method
  while 1 do
    local len = read_msb_uint32(fh)
    local stype = fh:Read(4)
    
    if stype == 'IHDR' then
      compression_method = parse_IHDR(tbl,fh, len)
      break
    elseif stype == 'sRGB' then
      parse_sRGB(tbl,fh, len)
    elseif stype == 'gAMA' then
      parse_gAMA(tbl,fh, len)
    elseif stype == 'cHRM' then
      parse_cHRM(tbl,fh, len)
    elseif stype == 'IDAT' then
      parse_IDAT(tbl,fh, len, compression_method)
    else
      local data = fh:Read(len)
      --print("data=", len == 0 and "(empty)" or "(not displayed)")
    end
	
	local crc = read_msb_uint32(fh)

    if stype == 'IEND' then
      break
    end
  end
  return tbl
end
file.parse_png=file.ParsePNG


function file.ParseJPG(file)
	local dimheader = {  }
	local foundheader = 0
	local endofjpg = file:Tell(file:Seek(file:Size()))
	local width = 0
	local height = 0
	local seek = {  }
	
	file:Seek(0)
	
	dimheader[1] = string.char(255) .. string.char(192)
	dimheader[2] = string.char(255) .. string.char(194)
	validjpg = string.char(255) .. string.char(216)
	if file:Read(2) == validjpg then
		while foundheader == 0 do
			if file:Tell() + 2 < endofjpg then
				readheader = file:Read(2)
			else
				print("Reached end of file", 0)
				foundheader = 1
			end

			if readheader == dimheader[1] or readheader == dimheader[2] then
				if file:Tell() + 3 < endofjpg then
					file:Seek(file:Tell() + 3)
					height = string.byte(file:Read(1)) * 256 + string.byte(file:Read(1))
					width = string.byte(file:Read(1)) * 256 + string.byte(file:Read(1))
					foundheader = 1
				end

			else
				if file:Tell() + 2 < endofjpg then
					seek[1] = string.byte(file:Read(1)) * 256
					seek[2] = string.byte(file:Read(1))
					seek[3] = seek[1] + seek[2] - 2
					if file:Tell() + seek[3] < endofjpg then
						file:Seek(file:Tell() + seek[3])
					else
						error("Reached end of file", 0)
						foundheader = 1
					end

				else
					error("Reached end of file", 0)
					foundheader = 1
				end

			end

		end

	else
		error("Error reading JPG", 0)
	end

	--file:Close()
	return {width=width,height=height}

end

local function IsPowerOfTwo(n)
	return bit.band(n,n-1)==0
end
local function ushort(str)
	return string.byte(str,1)+string.byte(str,2)*256
end
local ID_VTF = "VTF\000"
function file.ParseVTF(file)
	--should we check for vtf?
	if file:Read(4)~=ID_VTF then return nil,'not vtf' end
	local ver1,ver2 = unpack_msb_uint32_r(file:Read(4)),unpack_msb_uint32_r(file:Read(4))
	local headerSize = unpack_msb_uint32_r(file:Read(4))
	if ver1>100 or ver2>900 then return nil,'invalid version' end
	local w,h = ushort(file:Read(2)),ushort(file:Read(2))
	if not (IsPowerOfTwo(w)) or w==0 then return nil,"invalid power" end
	if not (IsPowerOfTwo(h)) or h==0 then return nil,"invalid power" end
	return {width=w,height=h,version = {ver1,ver2},headerSize = headerSize}
end


local ID_JPG = string.char(255) .. string.char(216)
local ID_PNG = "\137\080\078\071\013\010\026\010"


function string.IsPNG(bytes) return bytes:sub(1,8)==ID_PNG end
function string.IsJPG(bytes) return bytes:sub(1,2)==ID_JPG end
function string.IsVTF(bytes) return bytes:sub(1,4)==ID_VTF end



--PrintTable(file.ParseVTF(file.Open("materials/point.vtf",'rb','GAME')))
--addons/module_outfitter/lua/outfitter/cows.lua:
-- coroutine workshop --

local Tag='outfitter'
module(Tag,package.seeall)

function IsUGCFilePath(path)
	if path:find("^.:") or path:find("^[%\\%/]") then
		-- TODO: REMOVE? update removed absolute path
		return true
	end
	if path:find("content[\\/]4000[\\/]") then
		-- TODO: better way to check for UGC?
		return true
	end
	
	return false
end

-- External decompression helper (nerfed by http.Fetch)

local outfitter_disable_decompress_helper = CreateClientConVar("outfitter_disable_decompress_helper",'1',true)
if not outfitter_disable_decompress_helper:GetBool() then
	file.Write("decomp_in_steamworks.dat",'INIT')
end
local has_decompress_helper
function HasDecompressHelper()
	if outfitter_disable_decompress_helper:GetBool() then return false end
	return os.time()-(file.Time("of_dchelper.dat",'DATA') or 0)<120
end
---------------------------------

-- shadowing "dbge" because showing errors to expected behaviors in
-- user targeted code is highly stupid
local function dbge(...)
	Msg("[Outfitter] ")
	print(...)
end

local fetching = {}

local res = {}
local skip_maxsizes = {}
local function SYNC(cbs,...)
	for k,cb in next,cbs do
		cb(...)
		co.waittick()
	end
	return ...
end

local function steamworks_Download_work( fileid )
	local instant
	local path,fd
	local cb
	local done
	
	-- retry
	for i=0,4 do
		if path then break end

		instant,path,fd,cb = nil,nil,nil,nil

		if i~=0 then
			dbg("DownloadUGC","retry attempt ====",i)
			co.sleep(math.random()*3+1)
		end

		cb = co.newcb()
		local function cb2(a,b)
			SafeRunHook("OutfitterDownloadUGCResult",fileid,a,b)
			if done then return end
			
			dbg("DownloadUGC",fileid,instant==false and "" or "instant?","result",a,b)
			if instant==nil then
				path = a
				fd = b
				instant = true
				return
			end
			done = true
			cb(a,b)
		end
		dbgn(2,"DownloadUGC",fileid,"START")
		steamworks.DownloadUGC( fileid, cb2 )
		if instant==nil then
			timer.Simple(60*3,function()
				if done then return end
				dbg("DownloadUGC",fileid,"TIMEOUT (WIP)")
				UIWarnDownloadFailures(wsid)

				--cb2(false,false)
				--done=true
			end)
			instant = false
			path,fd = co.waitcb(cb)
		end
	end

	dbg("DownloadUGC",fileid,"returning",path,fd,instant and "<CACHED>" or "")
	
	return path,fd
end

DownloadUGC = co.worker(steamworks_Download_work)

local lme
local lwsid
function GetLastMountErr(wsid)
	if lwsid and lwsid~=wsid then return end
	return lme
end

local function cantmount(wsid,reason,...)
	fetching[wsid] = false
	res[wsid] = reason or "failed?"
	if reason~='oversize' or outfitter_maxsize:GetInt()==60 then
		dbgn(3,"FetchWS","downloading",wsid,"failed for reason:",reason,...)

		local err_msg = ("FetchWS downloading %s failed for reason: %s"):format(tostring(wsid), reason)
		Msg("[Outfitter] ")
		print(err_msg)

		notification.AddLegacy(err_msg, NOTIFY_ERROR, 5)
	end

	lme= reason or "?"
	lwsid=wsid
	return false,reason
end

do -- steamworks fileinfo worker
	local worker,cache = co.work_cacher_filter(
		function(key,fileinfo)
			return (not key) or fileinfo
		end,

		co.work_cacher(
			function(wsid)
				local cb = co.newcb()
					steamworks.FileInfo(wsid,cb)
				local fileinfo = co.waitcb(cb)

				return fileinfo

			end)
		)
	co_steamworks_FileInfo = co.worker(worker)
end


do
	local worker,cache = co.work_cacher_filter(
		function(key,fileinfo)
			return (not key) or fileinfo
		end,

		co.work_cacher(
			function(wsid)
				local cb = co.newcb()
					steamworks.VoteInfo(wsid,cb)
				local fileinfo = co.waitcb(cb)

				return fileinfo

			end)
		)
	co_steamworks_VoteInfo = co.worker(worker)
end


function coFetchWS(wsid,skip_maxsize)

	if skip_maxsize then
		skip_maxsizes[wsid] = true
	end

	-- fetch cache ("promise/future") (no double-fetching)
	local dat = fetching[wsid]

	if dat then
		if dat==true then
			-- true: already fetched
			return res[wsid] or true
		elseif istable(dat) then
			-- become a waiter
			local cb = co.newcb()
			dat[#dat+1] = cb
			return co.waitcb()
		elseif dat==false then
			-- already failed, retry or cancel if because of size (TODO: retry at most every N seconds?)
			local res = res[wsid]
			local canskip = res=="oversize" and skip_maxsize
			if not canskip then
				return false,res
			end
		end
	end

	local isdbg = isdbg()

	if isdbg then dbg("FetchWS",wsid) end

	dat = {}
	fetching[wsid] = dat

	local fileinfo = co_steamworks_FileInfo(wsid)

	dbg("steamworks.FileInfo",wsid,"->",fileinfo)
	if istable(fileinfo) then
		dbg("","title",fileinfo.title)
		if fileinfo.error then
			dbg("","error",fileinfo.error)
		end
		dbg("","owner",fileinfo.owner)
		dbg("","tags",fileinfo.tags)
		dbg("","size",string.NiceSize(fileinfo.size or 0))
		dbg("","fileid",fileinfo.fileid)
		local created = os.time() - (fileinfo.created or 0)

		dbg("","created ago",string.NiceTime(created))

		--TODO: Check banned
		--TODO: Check popularity before mounting

		local installed = fileinfo.installed
		local disabled = fileinfo.disabled
		
		if fileinfo.banned then
			dbge(wsid,"BANNED!?")
			return SYNC(dat,cantmount(wsid,"banned"))
		end
		
		if next(fileinfo.children or {}) then
			dbg(wsid,"has dependencies, these will not be mounted")
			--return SYNC(dat,cantmount(wsid,"dependencies"))
		end
		
		if created<60*60*24*7 then
			dbg(wsid,"WARNING: ONE WEEK OLD ADDON. NOT ENOUGH TIME FOR WORKSHOP MODERATORS.")
			if IsParanoidMode(1) then
				return SYNC(dat,cantmount(wsid,"new_addon"))
			end
		end
		if disabled then
			dbgn(3,"FileInfo",wsid,"Disabled?")
		end
		if installed then
			dbgn(3,"FileInfo",wsid,"installed? We shouldn't get this far if not disabled")
		end
	end

	if not fileinfo or not fileinfo.title then
		return SYNC(dat,cantmount(wsid,"fileinfo"))
	end
	if IsTitleBlocked(fileinfo.title) then
		return SYNC(dat,cantmount(wsid,"blocked title"))
	end

	if fileinfo.error and fileinfo.error ~="" then
		return SYNC(dat,cantmount(wsid,"fileinfo: "..tostring(fileinfo.error)))
	end
	
	if tonumber(fileinfo.size or 0)==0 or tonumber(fileinfo.size or 0)==0 then
		return SYNC(dat,cantmount(wsid,"undownloadable"))
	end
	
	local maxsz = outfitter_maxsize:GetFloat()
	maxsz = maxsz*1000*1000

	if maxsz>0.1 and ((fileinfo.size or 0)-1024*1024) > maxsz then
		skip_maxsize = skip_maxsize or skip_maxsizes[wsid]

		dbg("FetchWS","MAXSIZE",skip_maxsize and "OVERRIDE" or "",wsid,string.NiceSize(fileinfo.size or 0))

		if not skip_maxsize then
			return SYNC(dat,cantmount(wsid,"oversize"))
		end
	end

	co.wait(.3)

	local decomp_in_steamworks = true --not HasDecompressHelper()

	local TIME = isdbg and SysTime()
	local path,fd = DownloadUGC( wsid )
	if isdbg then dbg("Download",wsid,"to",path or "<ERROR>","took",SysTime()-TIME) end

	assert(path~=true)

	if not path then
		return SYNC(dat,cantmount(wsid,"download"))
	end

	if not IsUGCFilePath(path) and file.Size(path,'MOD')<=512 then
		return SYNC(dat,cantmount(wsid,"file"))
	end

	-- Decompress manually
	if not decomp_in_steamworks then
		local err
		path,err = coDecompress(path)
		if not path then
			return SYNC(dat,cantmount(wsid,'decompress'))
		end

		if not IsUGCFilePath(path) and not file.Exists(path,'MOD') then
			dbg(path,"IsUGCFilePath",IsUGCFilePath(path),"file.Exists",file.Exists(path,'MOD'))
			return SYNC(dat,cantmount(wsid,"file"))
		end
	end

	-- Strip lua files for exploit protection
	-- TODO: decompression
	if ShouldStripLuaFromDownloads() and fd then
		local accu=0
		collectgarbage('step',40000)
		local ok,ret,err,err2 = xpcall(gma.rebuild_nolua,debug.traceback,fd,wsid,false,function(sz)
			if sz==true or sz==false then
				collectgarbage('step',40000)
			end
			accu=accu+(tonumber(sz) or 0)
			if accu>1024*1024 then
				accu=0
				collectgarbage('step',20000)
			end
		end)
		dbg("gma.rebuild_nolua",ok,ret,err,err2)
		if not ok then
			err=ret
			ret=nil
		end
		if isstring(ret) then
			path=ret
		elseif ret==true then
			dbg("coFetchWS","gma.rebuild_nolua","No rebuild necessary or possible")
		else
			dbge("coFetchWS","gma.rebuild_nolua",wsid,err,err2)
			return SYNC(dat,cantmount(wsid,"gmarebuild"))
		end
	end

	local result = path

	-- mark as fetched
	fetching[wsid] = true
	res[wsid] = result

	return SYNC(dat,result)

end

function FetchWS(wsid,cb)
	if co.make(wsid,cb) then return end
	cb(coFetchWS(wsid))
end

function MountWS( path )

	--TODO: Check blacklist
	--[[ TODO: 	think I found a fix
				if something mounts fine once
				it gets whitelisted
		]]

	assert(path,'no file given')
	assert(DidCrash,"Outfitter has not initialized properly??? Contact Python1320")
	local crashed = DidCrash("mountws",path)

	dbg("MountWS",path,crashed and "CRASHED, BAILING OUT")

	if crashed then return nil,"crashed" end

	local TIME = SysTime()
	CRITICAL("mountws",path)
	local ok, files = MountGMA( path )
	CRITICAL(false)
	local took = SysTime() - TIME
	if isdbg() then dbg("MountGMA",path,"took",math.Round(took*1000)..' ms') end

	result = ok or false
	return result,files,took
end

local function _coMountWS(path)
	UIMounting(true)
	co.sleep(.3)
		local res,files,took = MountWS( path )
	UIMounting(false)
	co.sleep(math.Clamp((took or 0)*2.4,.2,2))

	return res,files,took
end
local worker,cache = co.work_cacher_filter(
	function(key,ok)
		return (not key) or ok
	end,
	co.work_cacher(_coMountWS)
)
coMountWS = co.worker(worker)




function _coDecompressExt(path)
	if not HasDecompressHelper() then return nil,'no helper' end
	if not path then return nil,'invalid parameter' end
	dbgn(2,"coDecompressExt",path)

	local ok,data,len,hdr,code = co.post('http://localhost:27099/decompress',{
		file = path
	})

	if not ok or code~=200 then
		has_decompress_helper = false
		dbge("_coDecompressExt",data,code)
		return nil,data
	end


	if code ~= 200 then
		dbge(data)
		return nil,'idk'
	end

	local resultpath = path..'.decompressed'
	local ex = file.Exists(resultpath,'GAME')
	if not ex then dbge("coDecompress","File not found",path,'->',resultpath) return nil,'missing decompress' end
	return resultpath
end

-- TODO rework if even needed anymore
function coDecompress(path)
	if not path then return nil,'invalid parameter' end
	if IsUGCFilePath(path) then return nil,'new workshop file' end

	dbgn(2,"coDecompress",path)

	local ok,ret = _coDecompressExt(path)
	if ok then return ok,ret end

	local safepath = path:gsub("%.cache$",".dat")
	if safepath==path then
		safepath = path..'.d.dat'
	end
	--assert(safepath~=path,"path change failed")
	if not file.Exists(safepath,'DATA') then

		file.CreateDir("cache",'DATA')
		file.CreateDir("cache/workshop",'DATA')

		dbgn(2,'coDecompress','finished collecting 1',coMinimizeGarbage())

		local data = file.Read(path,'GAME')				co.sleep(.3)
		if not data then dbge("coDecompress","File Read",path) return nil,'read' end

		local decomp_in_steamworks,err = util.Decompress(data) data = nil	co.sleep(.3)
		if not decomp_in_steamworks then dbge("coDecompress","LZMA Decompress",path,err or "failed :(") return nil,'decompress' end
		local sz = #decomp_in_steamworks

		file.Write(safepath,decomp_in_steamworks)	decomp_in_steamworks = nil 		co.sleep(.3)

		dbgn(2,'coDecompress','finished collecting 2',coMinimizeGarbage())

		if file.Size('data/'..safepath,'GAME')~=sz then
			dbge("coDecompress","LZMA Decompress SZ",
				file.Size('data/'..safepath,'GAME') or "FILE NO EXIST?",
				sz,path,safepath)
			return nil,'decompress'
		end

		co.sleep(.2)
	end

	return 'data/'..safepath
end

--TODO: own cache
function NeedWS(wsid,pl,mdl)
	assert(tonumber(wsid),"NeedWS invalid wsid: "..tostring(wsid))
	if co.make(wsid,pl,mdl) then return end

	-- already mounted, don't mount again
	if steamworks.IsSubscribed(wsid) and file.Exists(mdl,'GAME') then return true end

	SetUIFetching(wsid,true)

		co.sleep(.1)

		local path,err,err2 = coFetchWS( wsid ) -- also decompresses

		co.sleep(1)

	SetUIFetching(wsid,false,not path and (err and tostring(err) or "FAILED?"))

	if not path then
		if err~='oversize' then
			dbge("NeedWS",wsid,"fail",err,err2)
		end
		return nil,err or "fetchws",err2
	end

	local ok,err = GMABlacklist(path)
	if not ok and err=='notgma' and TestLZMA(path) then
		local newpath,err = coDecompress(path)
		if not newpath then
			dbge("NeedWS",wsid,"fail",err)
			return nil,err or "decompress"
		end
		path = newpath

		-- retry --
		ok,err = GMABlacklist(path)
		-----------
	end

	if not ok then
		dbge("NeedWS","GMABlacklist",wsid,"->",err)
		return
	end

	local mdls,extra,errlist = GMAPlayerModels(path)

	if not mdls then
		dbge("NeedWS","GMAPlayerModels",wsid,"fail",extra)
		return false,"mdlparse",extra
	end

	if not mdls[1] then
		dbge("NeedWS","GMAPlayerModels",wsid,"has no models")
		return false,"nomdls"
	end

	local has = not mdl
	if not has then
		has = extra.playermodels[mdl] or extra.hands[mdl]
		if not has then
			-- TODO: Make enforced
			local bad = extra.potential[mdl] or extra.discards[mdl]
			if bad then
				dbge("NeedWS",wsid,path,"requested mdl was discarded",mdl)
--			elseif GMAHasFile()
			else
				dbge("NeedWS",wsid,path,"missing requested mdl",mdl)
			end

		end
	end

	local ok,err = coMountWS( path )

	if not ok then
		dbg("NeedWS",wsid,"mount fail",err)
		return nil,err or "mount"
	end

	return true

end


function GetQueryUGCChildren(workshopid)
	local ok,ret,len,hdrs,retcode = co.fetch("http://steamcommunity.com/sharedfiles/filedetails/?id="..workshopid)
	if not ok then return nil,ret end
	if retcode==404 then return false end
	if retcode~=200 then return nil,retcode,ret end

	local _,posa = ret:find('id="RequiredItems">',1,true)
	if not posa then
		if ret:find('publishedfileid',1,true) then
			return {} -- probably just no require items
		end
		if ret:find("store.steampowered.com",1,true) then
			return false -- 404
		end
		return nil,"internal error: steam format changed"
	end

	local posb
	for i=0,6 do
		local _,new_posb = ret:find('<div class="requiredItem">',posb or posa,true)
		if not new_posb then break end
		posb = new_posb
	end
	if not posb then return nil,"internal error: format changed" end

	local t = {}
	for id in ret:sub(posa,posb):gmatch'id%=(%d+)' do
		t[#t+1]=id
	end
	return t
end

-- TODO: move


local function http_wrap(ok,err,okerr,...)
	if okerr==ok then
		return true,...
	elseif okerr==err then
		return false,...
	else
		error"Invalid fetch callback called"
	end
end


function co_head(url,data,hdr)
	hdr=hdr or {}
	--hdr["Accept-Encoding"] = hdr["Accept-Encoding"] or "none"

	local ok,err = co.newcb(),co.newcb()
	HTTP({
		method = "HEAD",
		url = url,
		headers = hdr,
		success = function(code, data, headers,...)
			ok(data, #data, headers,code,...)
		end,
		failed = function(...)
			err(...)
		end
	})
	return http_wrap(ok,err,co.waitone())
end

-- TODO: MOVE
-- TODO: cache


local function checkhttp(ok,ret,len,hdrs,retcode)
	if retcode==404 then return nil,'not found' end
	if retcode~=200 then return nil,"http error",retcode end
	local size = hdrs["Content-Length"] and tonumber(hdrs["Content-Length"])
	

	local maxsz = outfitter_maxsize:GetFloat()
	maxsz = maxsz*1000*1000

	if size and maxsz>=1 and size > math.min(maxsz,1024*1024*1024) then
		skip_maxsize = skip_maxsize or skip_maxsizes[wsid]

		dbg("NeedHTTPGMA","MAXSIZE",skip_maxsize and "OVERRIDE" or "",wsid,string.NiceSize(size))

		if not skip_maxsize then
			return nil,"oversize"
		end
	end
	return true
end


function URLFilename(url)
	return url:match( "([^/]+)$" )
end

local http_downloaded={}
function coFetchGMA(download_info,pl,mdl)
	if http_downloaded[download_info] then
		return http_downloaded[download_info]
	end


	local download_info_actual = MakeURLDownloadable(download_info)
	local filename = URLFilename(download_info) or "noname"..util.CRC(download_info)

	-- 1. first try getting header info to see if we are downloading insanity
	local ok,ret,len,hdrs,retcode = co_head(download_info_actual)
	if ok then
		local size = hdrs["Content-Length"] and tonumber(hdrs["Content-Length"])
		local ETag = hdrs["ETag"]
		local can_range = hdrs["Accept-Ranges"] and hdrs["Accept-Ranges"]:find"bytes" and true or false
		dbg("NeedHTTPGMA Header",download_info,"ETag=",ETag,"Size=",size,"can_range=",can_range,table.ToString(hdrs))

		local ok,err,err2 = checkhttp(ok,ret,len,hdrs,retcode)
		if not ok then
			return ok,err,err2
		end
	end

	
	co.sleep(.1)

	-- 2. then actually download the thing
	SetUIFetching(filename,true,nil,true)
	--dbgn(2,'NeedHTTPGMA','minimized garbage for download',coMinimizeGarbage())
	local ok,data,len,hdrs,retcode = co.fetch( download_info_actual )	
	SetUIFetching(filename,false,not ok and ddata or retcode~=200 and "server returned an error" or nil,true)
	if not ok then return nil,data or 'download failed' end

	-- TODO: lower memory usage instantly rather than this?
	--dbgn(2,'NeedHTTPGMA','minimized garbage after download',coMinimizeGarbage())

	-- TODO: cache
	local ETag = hdrs["ETag"]
	local LastModified = hdrs["Last-Modified"]
	local can_range = hdrs["Accept-Ranges"] and hdrs["Accept-Ranges"]:find"bytes" and true or false
	dbg("NeedHTTPGMA Downloaded",download_info,"ETag=",ETag,"LastModified=",LastModified,"Size=",string.NiceSize(len),"can_range=",can_range,table.ToString(hdrs))

	local ok,err,err2 = checkhttp(ok,data,len,hdrs,retcode)
	if not ok then
		return ok,err,err2
	end
	file.CreateDir("cache",'DATA')
	file.CreateDir("cache/httpgma",'DATA')

	local sha1 = util.SHA1(data)
	
	local path_DATA = ("cache/httpgma/%s.dat"):format(sha1)
	file.Write(path_DATA,data)
	data=nil
	dbgn(2,'NeedHTTPGMA','minimized garbage after data discard',coMinimizeGarbage())
	local path="data/"..path_DATA
	
	local ok,err = GMABlacklist(path)
	if not ok and err=='notgma' and TestLZMA(path) then
		local newpath,err = coDecompress(path)
		if not newpath then
			dbge("NeedWS",download_info,"fail",err)
			return nil,err or "decompress"
		end
		path = newpath

		-- retry --
		ok,err = GMABlacklist(path)
		-----------
	end

	if not ok then
		dbge("NeedHTTPGMA","GMABlacklist",download_info,"->",err)
		return
	end

	local mdls,extra,errlist = GMAPlayerModels(path)

	if not mdls then
		dbge("NeedHTTPGMA","GMAPlayerModels",download_info,"fail",extra)
		return false,"mdlparse",extra
	end

	if not mdls[1] then
		dbge("NeedHTTPGMA","GMAPlayerModels",download_info,"has no models")
		return false,"nomdls"
	end

	local has = not mdl
	if not has then
		has = extra.playermodels[mdl] or extra.hands[mdl]
		if not has then
			-- TODO: Make enforced
			local bad = extra.potential[mdl] or extra.discards[mdl]
			if bad then
				dbge("NeedHTTPGMA",download_info,path,"requested mdl was discarded",mdl)
--			elseif GMAHasFile()
			else
				dbge("NeedHTTPGMA",download_info,path,"missing requested mdl",mdl)
			end

		end
	end

	if ShouldStripLuaFromDownloads() then
		local accu=0
		collectgarbage('step',20000)
		local target_id=sha1:sub(1,32)
		local fd = file.Open(path_DATA,'rb','DATA')
		if not fd then
			return false,"no file"
		end
		local ret,err,err2 = gma.rebuild_nolua(fd,target_id,false,function(sz)
			if sz==true or sz==false then
				co.waittick()
				collectgarbage('step',40000)
				co.waittick()
			end
			accu=accu+(tonumber(sz) or 0)
			if accu>1024*1024 then
				accu=0
				collectgarbage('step',20000)
				co.waittick()
			end
		end)
		
		fd:Close()

		dbg("gma.rebuild_nolua",ret,err,err2)
		if isstring(ret) then
			path=ret
		elseif ret==true then
			dbg("gma.rebuild_nolua","No rebuild necessary or possible")
		else
			dbge("gma.rebuild_nolua",err,err2)
			return
		end
	end
	
	if not path or path==true then return path end

	local ret={path=path,sha1=sha1}
	http_downloaded[download_info]=ret
	return ret

end

function NeedHTTPGMA(download_info,pl,mdl)
	if co.make(download_info,pl,mdl) then return end
	
	local data,err,err2,ok = coFetchGMA(download_info,pl,mdl)
	
	if not data then return data,err,err2 end
	if not data.path then return nil,'nopath' end

	ok,err = coMountWS( data.path )

	if not ok then
		dbg("NeedHTTPGMA",download_info,"mount fail",err)
		return nil,err or "mount"
	end

	return true

end

--[[
co(function()
	Msg"no children:"
	PrintTable(GetQueryUGCChildren '1100368137')
	Msg"1 children:"
	PrintTable(GetQueryUGCChildren '848953556')
	Msg"2 children:"
	PrintTable(GetQueryUGCChildren '918084741')
	Msg"no exist:"
	PrintTable(GetQueryUGCChildren '123')
end)

no children:{
}
1 children:{
	[1] = "757604550",
}
2 children:{
	[1] = "757604550",
	[2] = "775573383",
}
no exist:false
]]

--addons/module_outfitter/lua/outfitter/gui_ofworkshopicon.lua:
local Tag='outfitter'

module(Tag,package.seeall)


local PANEL = {}

function PANEL:Init()
	self:SetTall( 128 )
	self:SetWide( 128 )
end

-- Adapted from https://github.com/robotboy655/gmod-lua-menu/blob/master/lua/menu/custom/addons.lua
-- TODO: Use coroutines, cache results

local gDataTable = gDataTable or {}
function PANEL:SetAddon( data )
	self.Addon = data
	if ( gDataTable[ data.wsid ] ) then self.AdditionalData = gDataTable[ data.wsid ] return end

	steamworks.FileInfo( data.wsid, function( result )
		if not result then return end

		gDataTable[ data.wsid ] = result

		if ( !file.Exists( 'cache/workshop/' .. result.previewid .. '.cache',"GAME" ) ) then
			steamworks.Download( result.previewid, false, function( name ) end )
		end

		if ( !IsValid( self ) ) then return end

		self.AdditionalData = result

	end )
end

local missingMat = Material( "../html/img/addonpreview.png", "nocull smooth" )
local lastBuild = 0
local imageCache = {}
function PANEL:Paint( w, h )

	if ( self.AdditionalData && imageCache[ self.AdditionalData.previewid ] ) then
		self.Image = imageCache[ self.AdditionalData.previewid ]

	end

	if ( !self.Image && self.AdditionalData && file.Exists( "cache/workshop/" .. self.AdditionalData.previewid .. ".cache", "GAME" ) && CurTime() - lastBuild > 0.1 ) then
		self.Image = AddonMaterial( "cache/workshop/" .. self.AdditionalData.previewid .. ".cache" )
		imageCache[ self.AdditionalData.previewid ] = self.Image
		lastBuild = CurTime()
		self.errcheck = false
		self.errored = false
	end


	draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 0, 0, 255 ) )
	
	if not self.errcheck then
		self.errcheck = true
		if self.Image and self.Image:IsError() then
			self.errored = true
		end
	end
	
	if self.Image and not self.errored then
		surface.SetMaterial( self.Image )
	else
		surface.SetMaterial( missingMat )
	end
	local imageSize = self:GetTall() - 10
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRect( 5, 5, imageSize, imageSize )

	if ( self.Addon && self.Hovered ) then
		draw.RoundedBox( 0, 5, h - 25, w - 10, 15, Color( 0, 0, 0, 180 ) )
		draw.SimpleText( self.Addon.title, "Default", 8, h - 24, Color( 255, 255, 255 ) )
	end

end

vgui.Register( "DOWorkshopIcon", PANEL, "Panel" )
--addons/module_logs/lua/autorun/plogs_init.lua:
local include_sv = (SERVER) and include or wlib.func.blank
local include_cl = (SERVER) and AddCSLuaFile or include
local include_sh = function(path) include_sv(path) include_cl(path) end

plogs		= plogs			or {}
plogs.cfg 	= plogs.cfg 	or {}
plogs.types	= plogs.types	or {}
plogs.data	= plogs.data	or {}

plogs.Version = '2.7.1'

function plogs.Error(str)
	return ErrorNoHalt('[pLogs] ' .. str)
end

-- Lib modules from: https://github.com/SuperiorServers/plib_v2
include_sh 'plogs/lib/pon1.lua'
include_cl 'plogs/lib/pdraw.lua'
include_sv 'plogs/lib/table.lua'

include_sh 'plogs_cfg.lua' 
include_sh 'plogs/workarounds/sanity_checker.lua'

if (SERVER) and plogs.cfg.EnableMySQL then
	include_sv 'plogs_mysql_cfg.lua'
	if (system.IsWindows() and file.Exists('lua/bin/gmsv_tmysql4_win32.dll', 'MOD')) or (system.IsLinux() and file.Exists('lua/bin/gmsv_tmysql4_linux.dll', 'MOD')) then
		include_sv 'plogs/lib/ptmysql.lua'
		plogs.sql = ptmysql
	elseif (system.IsWindows() and file.Exists('lua/bin/gmsv_mysqloo_win32.dll', 'MOD')) or (system.IsLinux() and file.Exists('lua/bin/gmsv_mysqloo_linux.dll', 'MOD')) then
		include_sv 'plogs/lib/pmysqloo.lua'
		plogs.sql = pmysqloo
	end

	if (plogs.sql == nil) then
		plogs.Error('MySQL is enabled but pLogs could not find the tmysql or mysqloo module installed!') -- reduce support tickets by 50%
		plogs.cfg.EnableMySQL = false
	else
		include_sv 'plogs/mysql.lua'
	end
end

include_sh 'plogs/core_sh.lua'
include_sv 'plogs/core_sv.lua'
include_sh 'plogs/console.lua'

include_cl 'plogs/vgui/skin.lua'
include_cl 'plogs/vgui/frame.lua'
include_cl 'plogs/vgui/tablist.lua'

include_cl 'plogs/menu.lua'

if (not file.IsDir('plogs/saves', 'data')) then
	file.CreateDir('plogs/saves')
end

hook.Add('Initialize', 'plogs.Loghooks.Initialize', function()
	local files, _ = file.Find('plogs_hooks' .. '/*.lua', 'LUA')
	for _, f in ipairs(files) do
	    if plogs.cfg.LogTypes[f:sub(1, f:len() - 4):lower()] then continue end
	    if f:sub(1, 3) == 'sv_' then include_sv('plogs_hooks/' .. f) continue end
	    include_sh('plogs_hooks/' .. f)
	end
end)

local msg = {
	'\n\n',
	[[         __                  ]],
	[[ _ __   / /  ___   __ _ ___  ]],
	[[| '_ \ / /  / _ \ / _` / __| ]],
	[[| |_) / /__| (_) | (_| \__ \ ]],
	[[| .__/\____/\___/ \__, |___/ ]],
	[[|_|               |___/      ]],
	'\n',
	[[Version ]] .. plogs.Version .. [[ by aStonedPenguin]],
	'\n\n',
}

for k, v in ipairs(msg) do 
	MsgC(Color(250,0,0), v .. '\n')
end
--addons/module_logs/lua/plogs/lib/pon1.lua:
--[[ 

DEVELOPMENTAL VERSION;

VERSION 1.2.1
Copyright thelastpenguin™ 

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.
	
	If you modify the code for any purpose, the above still applies to the modified code.
	
	The author is not held responsible for any damages incured from the use of pon1, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v
 
CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon1
V 1.2.0
 - Added custom handling for k,v tables without any array compon1ent.
V 1.2.1
 - fixed deserialization bug.
 
THANKS TO...
 - VERCAS for the inspiration.
]]


local pon1 = {};
_G.pon1 = pon1;

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};
	
	local tryCache ;
	
	local cacheSize = 0;
	
	encode['table'] = function( self, tbl, output, cache )
		
		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end
		-- CALCULATE COMPONENT SIZES
		local nSize = #tbl;
		local kvSize = count( tbl ) - nSize;
		
		if( nSize == 0 and kvSize > 0 )then
			output[ #output + 1 ] = '[';
		else
			output[ #output + 1 ] = '{';
			
			if nSize > 0 then
				for i = 1, nSize do
					local v = tbl[ i ];
					if not v then continue end
					local tv = type( v );
					-- HANDLE POINTERS
					if( tv == 'string' )then
						local pid = cache[ v ];
						if( pid )then
							output[ #output + 1 ] = format('(%x)',  pid );
						else
							cacheSize = cacheSize + 1;
							cache[ v ] = cacheSize;
							
							self.string( self, v, output, cache );
						end
					else
						self[ tv ]( self, v, output, cache );
					end
				end
			end
		end
			
		if( kvSize > 0 )then
			if( nSize > 0 )then
				output[ #output + 1 ] = '~';
			end
			for k,v in next, tbl do
				if( type( k ) ~= 'number' or k < 1 or k > nSize )then
					local tk, tv = type( k ), type( v );
					
					-- THE KEY
					if( tk == 'string' )then
						local pid = cache[ k ];
						if( pid )then
							output[ #output + 1 ] = format('(%x)',  pid );
						else
							cacheSize = cacheSize + 1;
							cache[ k ] = cacheSize;
							
							self.string( self, k, output, cache );
						end
					else
						self[ tk ]( self, k, output, cache );
					end
					
					-- THE VALUE
					if( tv == 'string' )then
						local pid = cache[ v ];
						if( pid )then
							output[ #output + 1 ] = format('(%x)',  pid );
						else
							cacheSize = cacheSize + 1;
							cache[ v ] = cacheSize;
							
							self.string( self, v, output, cache );
						end
					else
						self[ tv ]( self, v, output, cache );
					end
					
				end
			end
		end
		output[ #output + 1 ] = '}';
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	
	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end
	
	do
		local empty, concat = table.Empty, table.concat ;
		function pon1.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );
			
			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;
	
	local decode = {};
	decode['{'] = function( self, index, str, cache )
		
		local cur = {};
		cache[ #cache + 1 ] = cur;
		
		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end
			
			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;
			
			k = k + 1;
		end
		
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end
			
			-- READ THE KEY
			
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			
			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			
			cur[ k ] = v;
		end
		
		return index, cur;
	end
	decode['['] = function( self, index, str, cache )
		
		local cur = {};
		cache[ #cache + 1 ] = cur;
		
		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end
			
			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end
			
			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );
			
			cur[ k ] = v;
		end
		
		return index, cur;
	end
	
	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;
		
		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;
		
		cache[ #cache + 1 ] = res;
		return index, res;
	end
	
	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	
	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end
	
	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end
	
	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER 
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end

	
	function pon1.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end
--addons/module_logs/lua/plogs/lib/pdraw.lua:
plogs.draw = {} -- Plop it in the plogs table otherwise this creates conflicts

local surface 	= surface
local render 	= render

local surface_SetDrawColor = surface.SetDrawColor
local surface_DrawRect = surface.DrawRect
local function surface_DrawRectBold(x, y, w, h, t)
	if not t then t = 1 end
	surface_DrawRect(x, y, w, t)
	surface_DrawRect(x, y + (h - t), w, t)
	surface_DrawRect(x, y, t, h)
	surface_DrawRect(x + (w - t), y, t, h)
end

function plogs.draw.Box(x, y, w, h, col)
	surface_SetDrawColor(col)
	surface_DrawRect(x, y, w, h)
end

function plogs.draw.Outline(x, y, w, h, col, thickness)
	surface_SetDrawColor(col)
	surface_DrawRectBold(x, y, w, h, thickness)
end

function plogs.draw.OutlinedBox(x, y, w, h, col, bordercol, thickness)
	surface_SetDrawColor(col)
	surface_DrawRect(x + 1, y + 1, w - 2, h - 2)

	surface_SetDrawColor(bordercol)
	surface_DrawRectBold(x, y, w, h, thickness)
end

local blur = Material('pp/blurscreen')
function plogs.draw.Blur(panel, amount) -- Thanks nutscript
	local x, y = panel:LocalToScreen(0, 0)
	local scrW, scrH = ScrW(), ScrH()
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat('$blur', (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
	end
end
--addons/module_logs/lua/plogs/vgui/skin.lua:
local surface 				= surface
local draw 					= draw

local SKIN 		= {}

SKIN.PrintName 	= 'pLogs'
SKIN.Author 	= 'aStonedPenguin'
    -- white

SKIN.Background 			= Color(245,245,235,170)
SKIN.Header 				= Color(230,230,220,225)
SKIN.Outline 				= Color(170,170,170)

SKIN.Panel 					= Color(245,245,235,100)

SKIN.Button 				= Color(230,230,220)
SKIN.ButtonHovered			= Color(200,200,190)

SKIN.Close 					= Color(0,0,0)
SKIN.CloseHovered 			= Color(255,0,0)

SKIN.TabButton 				= SKIN.Header

SKIN.TextEntry 				= SKIN.Button
SKIN.TextEntryOutline 		= SKIN.Outline
SKIN.TextEntryText 			= Color(0,0,0)
SKIN.TextEntryHighlight 	= SKIN.ButtonHovered

SKIN.ListBackground			= SKIN.TextEntry
SKIN.ListViewLine 			= SKIN.Button
SKIN.ListViewLineAlt 		= SKIN.ButtonHovered
SKIN.ListViewLineHighlight 	= Color(200,0,0,200)
SKIN.ListViewText			= SKIN.ButtonText
SKIN.ProgressBar 			= Color(225,0,0)


plogs.ui					= SKIN

----------------------------------------------------------------
-- Frames
----------------------------------------------------------------
function SKIN:PaintFrame(self, w, h)
	plogs.draw.Blur(self)
	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Background, SKIN.Outline)
	plogs.draw.OutlinedBox(0, 0, w, 30, SKIN.Header, SKIN.Outline)
end

function SKIN:PaintPanel(self, w, h)
	if not (self.m_bBackground) then return end

	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Panel, SKIN.Outline)
end

function SKIN:PaintShadow() end

----------------------------------------------------------------
-- Buttons                                                     
----------------------------------------------------------------
function SKIN:PaintButton(self, w, h)
	if not (self.m_bBackground) then return end 

	plogs.draw.OutlinedBox(0, 0, w, h, self.Hovered and SKIN.ButtonHovered or SKIN.Button, SKIN.Outline)

	if not self.fontset then
		self:SetTextColor(SKIN.Close)
		self:SetFont('plogs.ui.20')
		self.fontset = true
	end
end

----------------------------------------------------------------
-- Close Button
----------------------------------------------------------------
function SKIN:PaintWindowCloseButton(panel, w, h)
	if not (panel.m_bBackground) then return end

	draw.SimpleText('x', 'plogs.ui.26', 11, 0, (self.Hovered and SKIN.CloseHovered or SKIN.Close), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP) 
end

----------------------------------------------------------------
-- Text Entry                                                 
----------------------------------------------------------------
function SKIN:PaintTextEntry(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.TextEntry, SKIN.TextEntryOutline)
	
	self:DrawTextEntryText(SKIN.TextEntryText, SKIN.TextEntryHighlight, SKIN.TextEntryText)
end

----------------------------------------------------------------
-- List View                                                 
----------------------------------------------------------------
function SKIN:PaintListView(self, w, h)
	--plogs.draw.Box(0, 0, w, h, SKIN.ListBackground)
end

function SKIN:PaintListViewLine(self, w, h)
	local col = ((self:IsSelected() or self:IsHovered()) and SKIN.ListViewLineHighlight or SKIN.ListViewLine)

	plogs.draw.Box(0, 0, w, h, ((self.m_bAlt and not (self:IsSelected() or self:IsHovered())) and SKIN.ListViewLineAlt or col))

	for k, v in ipairs(self.Columns) do
		if (self:IsSelected() or self:IsHovered()) then
			
			v:SetFont('plogs.ui.18')
			v:SetTextColor(SKIN.ListViewTextHighlight)
		else
			v:SetFont('plogs.ui.16')
			v:SetTextColor(SKIN.ListViewText)
		end	
	end
end


----------------------------------------------------------------
-- Scrollbar                                                  --
----------------------------------------------------------------
function SKIN:PaintScrollBarGrip(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, self.Hovered and SKIN.ButtonHovered or SKIN.Button, SKIN.Outline)
end
SKIN.PaintButtonDown 	= SKIN.PaintScrollBarGrip
SKIN.PaintButtonUp 		= SKIN.PaintScrollBarGrip

function SKIN:PaintScrollPanel(self, w, h) end
function SKIN:PaintVScrollBar(self, w, h) end

----------------------------------------------------------------
-- Tabs                                                 
----------------------------------------------------------------
/*
function SKIN:PaintTabListPanel(self, w, h)
	surface.SetDrawColor(SKIN.Outline)
	surface.DrawOutlinedRect(0, 0, w, h)
end

SKIN.PaintTabPanel = SKIN.PaintTabListPanel
*/
function SKIN:PaintTabListButton(self, w, h)
	if (self.Active or self.Hovered) then
		plogs.draw.OutlinedBox(0, 0, w, h, SKIN.TabButton, SKIN.Outline)
		if self.Hovered then
			plogs.draw.Box(1, 1, 6, h - 2, SKIN.ProgressBar)
		else
			plogs.draw.Box(1, 1, 3, h - 2, SKIN.ProgressBar)
		end
	else
		plogs.draw.Outline(0, 0, w, h, SKIN.Outline)
	end
	self:SetTextColor(SKIN.Close)
end

----------------------------------------------------------------
-- ComboBox                                                 
----------------------------------------------------------------
function SKIN:PaintComboBox(self, w, h)
	if IsValid(self.Menu) and not self.Menu.SkinSet then
		self.Menu:SetSkin('pLogs')
		self.Menu.SkinSet = true
	end

	plogs.draw.OutlinedBox(0, 0, w, h, ((self.Hovered or self.Depressed or self:IsMenuOpen()) and SKIN.ButtonHovered or SKIN.Button), SKIN.Outline)
end

function SKIN:PaintComboDownArrow(self, w, h)
	surface.SetDrawColor(SKIN.ListViewLineHighlight)
	draw.NoTexture()
	surface.DrawPoly({
		{x = 0, y = w * .5},
		{x = h, y = 0},
		{x = h, y = w}
	})

end

----------------------------------------------------------------
-- DMenu                                                 
----------------------------------------------------------------
function SKIN:PaintMenu(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Button, SKIN.Outline)
end

function SKIN:PaintMenuOption(self, w, h)
	if not self.FontSet then
		self:SetFont('plogs.ui.20')
		self:SetTextInset(5, 0)
		self.FontSet = true
	end
	
	self:SetTextColor(SKIN.Close)

	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Button, SKIN.Outline)
	
	if self.m_bBackground and  (self.Hovered or self.Highlight) then
		plogs.draw.OutlinedBox(0, 0, w, h, SKIN.ButtonHovered , SKIN.Outline)
	end
end

derma.DefineSkin('pLogs', 'pLogs\'s derma skin', SKIN)

local surface 				= surface
local draw 					= draw

local BLACK 		= {}

BLACK.PrintName 	= 'pLogsBlack'
BLACK.Author 	= 'aStonedPenguin'

	-- black
BLACK.Background 			= Color(10,10,10,200)
BLACK.Header 				= Color(25,25,25,225)
BLACK.Outline 				= Color(0,0,0)

BLACK.Panel 					= Color(10,10,10,100)

BLACK.Button 				= Color(10,10,10,175)
BLACK.ButtonHovered			= Color(50,50,50,170)
BLACK.ButtonText				= Color(245,245,245)

BLACK.Close 					= Color(255,255,255)
BLACK.CloseHovered 			= Color(236, 113, 73)

BLACK.TabButton 				= BLACK.Header

BLACK.TextEntry 				= BLACK.Button
BLACK.TextEntryOutline 		= BLACK.Outline
BLACK.TextEntryText 			= BLACK.ButtonText
BLACK.TextEntryHighlight 	= Color(51,128,255,200)

BLACK.ListBackground			= BLACK.TextEntry
BLACK.ListViewLine 			= BLACK.Button
BLACK.ListViewLineAlt 		= BLACK.ButtonHovered
BLACK.ListViewLineHighlight 	= BLACK.TextEntryHighlight
BLACK.ListViewText			= BLACK.ButtonText
BLACK.ProgressBar 			= Color(236, 113, 73)


plogs.ui					= BLACK

----------------------------------------------------------------
-- Frames
----------------------------------------------------------------
function BLACK:PaintFrame(self, w, h)
	plogs.draw.Blur(self)
	plogs.draw.OutlinedBox(0, 0, w, h, BLACK.Background, BLACK.Outline)
	plogs.draw.OutlinedBox(0, 0, w, 30, BLACK.Header, BLACK.Outline)
end

function BLACK:PaintPanel(self, w, h)
	if not (self.m_bBackground) then return end

	plogs.draw.OutlinedBox(0, 0, w, h, BLACK.Panel, BLACK.Outline)
end

function BLACK:PaintShadow() end

----------------------------------------------------------------
-- Buttons                                                     
----------------------------------------------------------------
function BLACK:PaintButton(self, w, h)
	if not (self.m_bBackground) then return end 

	plogs.draw.OutlinedBox(0, 0, w, h, self.Hovered and BLACK.ButtonHovered or BLACK.Button, BLACK.Outline)

	if not self.fontset then
		self:SetTextColor(BLACK.Close)
		self:SetFont('plogs.ui.20')
		self.fontset = true
	end
end

----------------------------------------------------------------
-- Close Button
----------------------------------------------------------------
function BLACK:PaintWindowCloseButton(panel, w, h)
	if not (panel.m_bBackground) then return end

	draw.SimpleText('x', 'plogs.ui.26', 11, 0, (self.Hovered and BLACK.CloseHovered or BLACK.Close), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP) 
end

----------------------------------------------------------------
-- Text Entry                                                 
----------------------------------------------------------------
function BLACK:PaintTextEntry(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, BLACK.TextEntry, BLACK.TextEntryOutline)
	
	self:DrawTextEntryText(BLACK.TextEntryText, BLACK.TextEntryHighlight, BLACK.TextEntryText)
end

----------------------------------------------------------------
-- List View                                                 
----------------------------------------------------------------
function BLACK:PaintListView(self, w, h)
	--plogs.draw.Box(0, 0, w, h, BLACK.ListBackground)
end

function BLACK:PaintListViewLine(self, w, h)
	local col = ((self:IsSelected() or self:IsHovered()) and BLACK.ListViewLineHighlight or BLACK.ListViewLine)

	plogs.draw.Box(0, 0, w, h, ((self.m_bAlt and not (self:IsSelected() or self:IsHovered())) and BLACK.ListViewLineAlt or col))

	for k, v in ipairs(self.Columns) do
		if (self:IsSelected() or self:IsHovered()) then
			
			v:SetFont('plogs.ui.18')
			v:SetTextColor(BLACK.ListViewTextHighlight)
		else
			v:SetFont('plogs.ui.16')
			v:SetTextColor(BLACK.ListViewText)
		end	
	end
end


----------------------------------------------------------------
-- Scrollbar                                                  --
----------------------------------------------------------------
function BLACK:PaintScrollBarGrip(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, self.Hovered and BLACK.ButtonHovered or BLACK.Button, BLACK.Outline)
end
BLACK.PaintButtonDown 	= BLACK.PaintScrollBarGrip
BLACK.PaintButtonUp 		= BLACK.PaintScrollBarGrip

function BLACK:PaintScrollPanel(self, w, h) end
function BLACK:PaintVScrollBar(self, w, h) end

----------------------------------------------------------------
-- Tabs                                                 
----------------------------------------------------------------
/*
function BLACK:PaintTabListPanel(self, w, h)
	surface.SetDrawColor(BLACK.Outline)
	surface.DrawOutlinedRect(0, 0, w, h)
end

BLACK.PaintTabPanel = BLACK.PaintTabListPanel
*/
function BLACK:PaintTabListButton(self, w, h)
	if (self.Active or self.Hovered) then
		plogs.draw.OutlinedBox(0, 0, w, h, BLACK.TabButton, BLACK.Outline)
		if self.Hovered then
			plogs.draw.Box(1, 1, 6, h - 2, BLACK.ProgressBar)
		else
			plogs.draw.Box(1, 1, 3, h - 2, BLACK.ProgressBar)
		end
	else
		plogs.draw.Outline(0, 0, w, h, BLACK.Outline)
	end
	self:SetTextColor(BLACK.Close)
end

----------------------------------------------------------------
-- ComboBox                                                 
----------------------------------------------------------------
function BLACK:PaintComboBox(self, w, h)
	if IsValid(self.Menu) and not self.Menu.SkinSet then
		self.Menu:SetSkin('pLogsBlack')
		self.Menu.SkinSet = true
	end

	plogs.draw.OutlinedBox(0, 0, w, h, ((self.Hovered or self.Depressed or self:IsMenuOpen()) and BLACK.ButtonHovered or BLACK.Button), BLACK.Outline)
end

function BLACK:PaintComboDownArrow(self, w, h)
	surface.SetDrawColor(BLACK.ListViewLineHighlight)
	draw.NoTexture()
	surface.DrawPoly({
		{x = 0, y = w * .5},
		{x = h, y = 0},
		{x = h, y = w}
	})

end

----------------------------------------------------------------
-- DMenu                                                 
----------------------------------------------------------------
function BLACK:PaintMenu(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, BLACK.Button, BLACK.Outline)
end

function BLACK:PaintMenuOption(self, w, h)
	if not self.FontSet then
		self:SetFont('plogs.ui.20')
		self:SetTextInset(5, 0)
		self.FontSet = true
	end
	
	self:SetTextColor(BLACK.Close)

	plogs.draw.OutlinedBox(0, 0, w, h, BLACK.Button, BLACK.Outline)
	
	if self.m_bBackground and  (self.Hovered or self.Highlight) then
		plogs.draw.OutlinedBox(0, 0, w, h, BLACK.ButtonHovered , BLACK.Outline)
	end
end

derma.DefineSkin('pLogsBlack', 'pLogs\'s derma skin', BLACK)
--addons/module_logs/lua/plogs/vgui/frame.lua:
local PANEL = {}

function PANEL:Init()
    local cvar = GetConVar('wayskin_enable')
    
	self.btnMaxim:Remove()
	self.btnMinim:Remove()
	
	if cvar:GetInt() == 0 then
	self:SetSkin('pLogs')
    else
    self:SetSkin('pLogsBlack')
    end
	
	self.lblTitle:SetText('pLogs')
	self.lblTitle:SetColor(plogs.ui.Close)
	self.lblTitle:SetFont('plogs.ui.22')

	self:SetDraggable(true)
	self:MakePopup()

	self:SetAlpha(0)
	self:FadeIn(0.2)

	hook.Add('Think', self, function()
		if (self.animation) then
			self.animation:Run()
		end
	end)
end

function PANEL:FadeIn(speed, cback)
	self.animation = Derma_Anim('Fade Panel', self, function(panel, animation, delta, data)
		panel:SetAlpha(delta * 255)
		if (animation.Finished) then
			self.animation = nil
			if cback then cback() end
		end
	end)
	if (self.animation) then
		self.animation:Start(speed)
	end
end

function PANEL:FadeOut(speed, cback)
	self.animation = Derma_Anim('Fade Panel', self, function(panel, animation, delta, data)
		panel:SetAlpha(255 - (delta * 255))
		if (animation.Finished) then
			self.animation = nil
			if cback then cback() end
		end
	end)
	if (self.animation) then
		self.animation:Start(speed)
	end
end

function PANEL:PerformLayout()
	self.lblTitle:SizeToContents()
	self.lblTitle:SetPos(5, 3)

	self.btnClose:SetPos(self:GetWide() - 30, 0)
	self.btnClose:SetSize(30, 30)
end

function PANEL:Close(cback)
	self.Think = wlib.func.blank
	self:FadeOut(0.2, function()
		self:Remove()
		if cback then cback() end
	end)
end

vgui.Register('plogs_frame', PANEL, 'DFrame')
--addons/module_logs/lua/plogs/vgui/tablist.lua:
local PANEL = {}

function PANEL:Init()
    local cvar = GetConVar('wayskin_enable')
	self.num = 0
	if cvar:GetInt() == 0 then
	self:SetSkin('pLogs')
    else
    self:SetSkin('pLogsBlack')
    end
	self.tablist = vgui.Create('DScrollPanel', self)

	self.Tabs = {}

	self:AddButton('Настройки', function()
		local frame = vgui.Create('DFrame')
		frame:SetTitle('Настройки')
		frame:SetSize(math.min(ScrW(), 300), math.min(ScrH(), 400))
		frame:MakePopup()
		frame:Center()

		local scroll = vgui.Create('DScrollPanel', frame)
		scroll:Dock(FILL)
		--scroll:DockPadding(2,4,2,4)

		local text = vgui.Create('DLabel', scroll)
		text:DockMargin(2,4,2,4)
		text:SetText('Выбери те категории логов, которые будут отображаться в консоли')
		text:Dock(TOP)
		text:SetWrap(true)
		text:SetAutoStretchVertical(true)
		text:SetFont('plogs.ui.16')
		scroll:AddItem(text)

		local d = util.JSONToTable(cookie.GetString('wrp.logs.settings') or '[]')
		d.preventNetwork = d.preventNetwork or {}

		for k, v in pairs(plogs.types or {}) do
			if not v.Network then continue end

			local check = vgui.Create('DCheckBoxLabel', scroll)
			check:DockMargin(2,4,2,0)
			check:Dock(TOP)
			check:SetText(k)
			check:SetChecked(not table.HasValue(d.preventNetwork, k))
			function check:OnChange(val)
				if val then
					table.RemoveByValue(d.preventNetwork, k)
					v.preventNetwork = false
				else
					table.insert(d.preventNetwork, k)
					v.preventNetwork = true
				end
				cookie.Set('wrp.logs.settings', util.TableToJSON(d))
			end
		end
	end)
end

function PANEL:AddTab(title, tab, active)
    local cvar = GetConVar('wayskin_enable')
	if active then 
		self.CurrentTab = tab 
	else
		tab:SetVisible(false)
	end

	if (tab:GetParent() ~= self) then
		tab:SetParent(self)
		tab:SetSkin(self:GetSkin())
	end

	tab:SetPos(149, 0)
	tab:SetSize(self:GetWide() - 149, self:GetTall())

	local button = vgui.Create('DButton')
	button:SetSize(150, 30)
	button:SetPos(0, 29 * self.num)
	button:SetText(title)
	if cvar:GetInt() == 0 then
	button:SetSkin('pLogs')
    else
    button:SetSkin('pLogsBlack')
    end
	button:SetFont('plogs.ui.24')
	button.DoClick = function()
		self.CurrentButton.Active = false
		self.CurrentTab:SetVisible(false)
		tab:SetVisible(true)

		self.CurrentTab = tab
		self.CurrentButton = button
		button.Active = true

		net.Start('plogs.GetData')
		net.WriteString(self.Tabs[tab.id].title)
		net.SendToServer()
	end

	if active then
		self.CurrentButton = button
		button.Active = true
		self.CurrentTab = tab
	end

	button.Paint = function(button, w, h)
		derma.SkinHook('Paint', 'TabListButton', button, w, h)
	end

	self.tablist:AddItem(button)

	self.num = self.num + 1
	
	tab.id = table.insert(self.Tabs, {
		title = title,
		tab = tab,
		button = button,
	})
	return id
end

function PANEL:AddButton(title, func)
    local cvar = GetConVar('wayskin_enable')
	local button = vgui.Create('DButton')
	button:SetSize(150, 30)
	button:SetPos(0, 29 * self.num)
	button:SetText(title)
	if cvar:GetInt() == 0 then
	button:SetSkin('pLogs')
    else
	button:SetSkin('pLogsBlack')
	end
	button:SetFont('plogs.ui.24')
	button.DoClick = function(self)
		func(self)
	end
	button.Paint = function(button, w, h)
		derma.SkinHook('Paint', 'TabListButton', button, w, h)
	end

	self.tablist:AddItem(button)

	self.num = self.num + 1
end

function PANEL:PerformLayout()
	self.tablist:SetSize(150, self:GetTall())
	self.tablist:SetPos(0, 0)
end

vgui.Register('plogs_tablist', PANEL, 'Panel')
--addons/module_donate/lua/pointshop/vgui/dpointshopitem.lua:
local PANEL = {}

local adminicon = Material("icon72/shield.png")
local equippedicon = Material("icon72/large_blue_diamond.png")
local groupicon = Material("icon72/french_bread.png")
local haveicon = Material( "icon72/label.png" )

local canbuycolor = Color(0, 0, 0)
local cantbuycolor = Color(150, 150, 150)
local ownedcolor = Color(0, 0, 0)

surface.CreateFont( "PS_ItemName", {
	font = "Arial",
	extended = true,
	size = 18,
	weight = 800,
})

surface.CreateFont( "PS_ItemPrice", {
	font = "Arial",
	extended = true,
	size = 36,
	weight = 800,
})

surface.CreateFont( "PS_OldItemPrice", {
	font = "Arial",
	extended = true,
	size = 28,
	weight = 800,
})

surface.CreateFont( "PS_ItemFor", {
	font = "Roboto",
	extended = true,
	size = 14,
	weight = system.IsWindows() and 300 or 500,
	antialias = true,
})

function PANEL:Init()
	self.Info = ""
	self.InfoHeight = 14
end

function PANEL:OnMousePressed( mousecode )

	self:MouseCapture( true )
	self.Depressed = true
	self:InvalidateLayout( true )

end

function PANEL:OnMouseReleased( mousecode )

	self:MouseCapture( false )

	if ( !self.Depressed ) then return end

	self.Depressed = nil
	self:InvalidateLayout( true )

	if ( !self.Hovered ) then return end

	if ( mousecode == MOUSE_LEFT ) then
		self:DoClick()
	end

	self.Depressed = nil

end

function PANEL:DoClick()
	--[[
	local points = PS.Config.CalculateBuyPrice(LocalPlayer(), self.Data)

	if not LocalPlayer():PS_HasItem(self.Data.ID) and not LocalPlayer():PS_HasPoints(points) then
		notification.AddLegacy("У тебя не хватает "..PS.Config.PointsName.." для этого!", NOTIFY_GENERIC, 5)
	end
	]]

	local menu = DermaMenu(self)

	if not self.Data.Hidden then
		menu:AddOption('Купить', function()
			Derma_Query('Ты уверен, что хочешь купить ' .. self.Data.Name .. '?', 'Купить предмет',
				'Да', function() LocalPlayer():PS_BuyItem(self.Data.ID) end,
				'Нет', wlib.func.blank
			)
		end)
	end

	local item = wmarket.getItem('ps_'..self.Data.ID)
	if item then
		menu:AddOption('Найти на рынке', function()
			PS:ToggleMenu()
			f4menu:open()
			f4menu:selectTab('market')
			wmarket.selectItemPage(item, 'points')
		end)
	end
	
	if LocalPlayer():PS_HasItem(self.Data.ID) then
		menu:AddSpacer()

		if LocalPlayer():PS_HasItemEquipped(self.Data.ID) then
			menu:AddOption('Снять', function()
				LocalPlayer():PS_HolsterItem(self.Data.ID)
			end)
		else
			menu:AddOption('Надеть', function()
				LocalPlayer():PS_EquipItem(self.Data.ID)
			end)
		end

		if LocalPlayer():PS_HasItemEquipped(self.Data.ID) and self.Data.Modify then
			menu:AddSpacer()

			menu:AddOption('Изменить...', function()
				PS.Items[self.Data.ID]:Modify(LocalPlayer().PS_Items[self.Data.ID].Modifiers)
			end)
		end
	end

	menu:Open()
end

function PANEL:SetModel(mdl)
	local DModelPanel = self.ModelPanel
	if not IsValid(DModelPanel) then
		DModelPanel = vgui.Create('DModelPanel', self)
		DModelPanel:Dock(TOP)
		DModelPanel:SetTall(self:GetWide())
		self.ModelPanel = DModelPanel
	end

	DModelPanel:SetModel(mdl)

	return DModelPanel
end

local color_image_back = Color(200,216,222)

function PANEL:SetImage(img)
	local DImageButton = self.Image
	if not IsValid(DImageButton) then
		DImageButton = vgui.Create('DImageButton', self)
		DImageButton:Dock(TOP)
		DImageButton:SetTall(self:GetWide())
		self.Image = DImageButton
	end

	DImageButton.m_Image.FrameTime = 0
	DImageButton:SetMaterial(img)

	function DImageButton:DoClick()
		self:GetParent():DoClick()
	end

	function DImageButton:OnCursorEntered()
		self:GetParent():OnCursorEntered()
	end

	function DImageButton:OnCursorExited()
		self:GetParent():OnCursorExited()
	end

	function DImageButton.m_Image:Paint(w, h)
		draw.RoundedBox( 0, 0, 0, w, h, color_image_back)

		local noscroll = self:GetParent():GetParent().Data and self:GetParent():GetParent().Data.NoScroll
		if not noscroll and self:GetParent():GetParent().Hovered then
			self.FrameTime = self.FrameTime + 1
		end

		self:PaintAt( 0, self.FrameTime % self:GetTall() - self:GetTall() , self:GetWide(), self:GetTall() )
		self:PaintAt( 0, self.FrameTime % self:GetTall(), 					self:GetWide(), self:GetTall() )

		for i=1,8 do
			draw.RoundedBox( 0, 0, h-(8-i)*2, w, 2, Color(0,33,46,i*i*2) )
		end
	end

	return DImageButton
end

function PANEL:SetData(data)
	self.Data = data
	self.Info = data.Name
	self.Price = data.Price
	self.PriceText = data.Price .. PS.Config.PointsName
	self.For = data.For

	if data.OldPrice or data.Discount then
		local oldprice = data.OldPrice or (data.Discount and math.Round(data.Price/(1-data.Discount)))

		self.OldPrice = oldprice .. PS.Config.PointsName
		self.Discount = '-' .. math.Round(data.Discount and data.Discount*100 or (1-(data.Price/oldprice))*100) .. '%'
	end

	if data.Material then
		local DImageButton = vgui.Create('DImageButton', self)
		
		if not data.Material:IsError() then
			self:SetImage(data.Material)
		else
			local CATEGORY = PS:FindCategoryByName( PS.Items[data.ID].Category )
			self:SetImage(Material("icon72/"..CATEGORY.Icon..".png"))
		end
	elseif data.Model then
		local DModelPanel = self:SetModel(data.Model)

		if data.Skin then
			DModelPanel.Entity:SetSkin(data.Skin)
		end
	
		local PrevMins, PrevMaxs = DModelPanel.Entity:GetRenderBounds()
		PrevMaxs.z = PrevMins.z
		local campos = PrevMins:Distance(PrevMaxs) * Vector(2, 2, 2)
		campos.z = campos.z * 0.5
		local CATEGORY = PS:FindCategoryByName( PS.Items[data.ID].Category )
		DModelPanel:SetCamPos(campos)
		local lookAt = (PrevMaxs + PrevMins) / 2
		lookAt.z = lookAt.z * 0.5
		if CATEGORY.CamLookOffset then lookAt = lookAt + CATEGORY.CamLookOffset end
		DModelPanel:SetLookAt(lookAt)
		DModelPanel:SetFOV( CATEGORY.CamFOV or 30 )
	
		local ang = CATEGORY.ItemAngle or Angle()
		function DModelPanel:LayoutEntity(ent)
			if self:GetParent().Hovered then
				ent:SetAngles(Angle(0, ent:GetAngles().y + 60 * FrameTime(), 0))
			else
				ent:SetAngles(ang)
			end
	
			local ITEM = PS.Items[data.ID]
	
			ITEM:ModifyClientsideModel(LocalPlayer(), ent, Vector(), Angle())
		end
	
		function DModelPanel:DoClick()
			self:GetParent():DoClick()
		end
	
		function DModelPanel:OnCursorEntered()
			self:GetParent():OnCursorEntered()
		end
	
		function DModelPanel:OnCursorExited()
			self:GetParent():OnCursorExited()
		end
	
		local oldDraw = DModelPanel.Paint
		function DModelPanel:Paint( w, h )
			draw.RoundedBox( 0, 0, 0, w, h, Color(200,216,222) )
			for i=1,8 do
				draw.RoundedBox( 0, 0, h-(8-i)*2, w, 2, Color(0,33,46,i*i*2) )
			end
			oldDraw( self, w, h )
		end
	else
		local CATEGORY = PS:FindCategoryByName( PS.Items[data.ID].Category )
		self:SetImage(Material("icon72/"..CATEGORY.Icon..".png"))
	end

	if data.Description then
		self:SetTooltip(data.Description)
	end

	self:UpdateIcons()
end

function PANEL:UpdateIcons()
	self.Icons = {}
	local i = 1

	if self.Market then
		self.Icons[i] = {
			name = "Товар с рынка",
			color = Color(62,192,36),
		}
		i = i + 1
	end
end

local bg_def = Color(235,235,235)

function PANEL:Paint( w, h )
	draw.RoundedBox( 0, 0, 0, w, h, bg_def)
end

local color_discount = Color(250,25,25,200)
local color_oldprice = Color(150,150,150)
local color_have     = Color(25,160,255,50)
local color_equip    = Color(25,160,25,50)
function PANEL:PaintOver(w, h)
	local iconOffset = self.Discount and 60 or 0

	if self.Discount and not self.Market then
		--draw.RoundedBox(8, self:GetWide() - 64, 4, 60, 30, Color(250,50,50,200))
		draw.NoTexture()
		surface.SetDrawColor(color_discount)
		surface.DrawPoly({
			{x = self:GetWide() - 100, y = 0},
			{x = self:GetWide(), y = 0},
			{x = self:GetWide(), y = 60},
		})

		draw.SimpleText(self.Discount, "PS_OldItemPrice", self:GetWide()-4, 15, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
	
		if self.Data.DiscountEnd and self.Data.DiscountEnd > os.time() then
			local tbl = string.FormattedTime(self.Data.DiscountEnd - os.time())
			local days = math.floor((tbl.h - (tbl.h % 24))/24)
			if days > 0 then
				draw.RoundedBox(0, 0, w-20, 120, 20, color_discount)
				draw.SimpleText(('Осталось %s д.'):format(days), 'PS_ItemName', 8, w-10, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			else
				draw.RoundedBox(0, 0, w-20, 70, 20, color_discount)
				draw.SimpleText(('%02i:%02i:%02i'):format(tbl.h, tbl.m, tbl.s), 'PS_ItemName', 8, w-10, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end
		end
	end

	local iconsOffset = 0

	if self.Data.X2 then
		iconsOffset = 30

		draw.RoundedBox(0, 0, 0, self:GetWide(), 20, color_discount)
        draw.SimpleText('Пополни 1 рубль, получи 2', "PS_ItemName", self:GetWide()-4, 10, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

		if self.Data.DiscountEnd and self.Data.DiscountEnd > os.time() and not self.Market then
			local tbl = string.FormattedTime(self.Data.DiscountEnd - os.time())
			local days = math.floor((tbl.h - (tbl.h % 24))/24)
			if days > 0 then
				draw.RoundedBox(0, 0, w-20, 120, 20, color_discount)
				draw.SimpleText(('Осталось %s д.'):format(days), 'PS_ItemName', 4, w-10, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			else
				draw.RoundedBox(0, 0, w-20, 70, 20, color_discount)
				draw.SimpleText(('%02i:%02i:%02i'):format(tbl.h, tbl.m, tbl.s), 'PS_ItemName', 4, w-10, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end
		end
	end

	if not self.NotDrawIcons then
		for i=1, #self.Icons do
			local d = self.Icons[i]

			surface.SetFont('PS_ItemName')
			local tw, th = surface.GetTextSize(d.name)

			draw.RoundedBox(0, 0, iconsOffset, tw + 8, th + 4, d.color)
			draw.SimpleText(d.name, 'PS_ItemName', 4, iconsOffset + (th + 4)/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		
			iconsOffset = iconsOffset + th + 4
		end
	end

	local points = self.Market and self.Price or PS.Config.CalculateBuyPrice(LocalPlayer(), self.Data)

	if LocalPlayer():PS_HasPoints(points) or self.PreventColorChange then
		self.BarColor = canbuycolor
	else
		self.BarColor = cantbuycolor
	end

	local tcol = Color( self.BarColor.r, self.BarColor.g, self.BarColor.b, 255 )
	--[[
	if self:IsHovered() or self:IsChildHovered() then
		tcol.a = 255
	end
	]]

	draw.SimpleText(self.Info, "PS_ItemName", 10, w+15, tcol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

	surface.SetFont("PS_ItemPrice")
	local priceW, priceH = surface.GetTextSize(self.PriceText)

	draw.SimpleText(self.PriceText, "PS_ItemPrice", 10, w+62, tcol, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)

	if self.OldPrice and not self.Market then
		surface.SetFont("PS_OldItemPrice")
		local oldPriceW = surface.GetTextSize(self.OldPrice)
		
		draw.SimpleText(self.OldPrice, "PS_OldItemPrice", 15 + priceW, w+60, color_oldprice, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
		
		surface.SetDrawColor(tcol)
		surface.DrawRect(15+priceW, w+44, oldPriceW, 3)
	end

	if LocalPlayer().PS_Items and LocalPlayer().PS_Items[self.Data.ID] and LocalPlayer().PS_Items[self.Data.ID].Modifiers and LocalPlayer().PS_Items[self.Data.ID].Modifiers.color then
		surface.SetDrawColor(LocalPlayer().PS_Items[self.Data.ID].Modifiers.color)
		surface.DrawRect(self:GetWide() - 5 - 16, iconOffset + 26, 16, 16)
	end
end

local function IsAvailableItem(item, ply)
	item = PS.Items[item]
	if item and item.Slots then
		for k,v in pairs(item.Slots) do
			for slot, id in pairs(ply.PS_Slots) do
				if v == slot then
					if id == "_job" then return false end
				end
			end
		end
	end
	return true
end

function PANEL:OnCursorEntered()
	self.Hovered = true

	-- if LocalPlayer():PS_HasItem(self.Data.ID) then
	-- 	self.Price = '+' .. PS.Config.CalculateSellPrice(LocalPlayer(), self.Data)
	-- else
	-- 	self.Price = '-' .. PS.Config.CalculateBuyPrice(LocalPlayer(), self.Data)
	-- end
	self.For = nil

	if IsAvailableItem(self.Data.ID, LocalPlayer()) then
		PS:SetHoverItem(self.Data.ID)
	end
	if self.Data.PanelPreview then
		local pnl = self.Data:PanelPreview()
		wlib.panels.tooltip(self, pnl)
	end
end

function PANEL:OnCursorExited()
	self.Hovered = false
	-- self.Price = self.Data.Price
	self.For = self.Data.For

	PS:RemoveHoverItem()
	wlib.panels.removeTooltip()
end

vgui.Register('DPointShopItem', PANEL, 'DPanel')
--addons/module_donate/lua/pointshop/vgui/dpointshopcolorchooser.lua:
local PANEL = {}

function PANEL:Init()
	self:SetTitle("Выбор цвета")
	self:SetSize(300, 300)

	self:SetBackgroundBlur(true)
	self:SetDrawOnTop(true)

	self.colorpicker = vgui.Create('DColorMixer', self)
	--colorpicker:DockMargin(0, 0, 0, 60)
	self.colorpicker:Dock(FILL)

	local done = vgui.Create('DButton', self)
	done:DockMargin(0, 5, 0, 0)
	done:Dock(BOTTOM)

	done:SetText('Готово')

	done.DoClick = function()
		self.OnChoose(self.colorpicker:GetColor())
		self:Close()
	end

	self:Center()
	self:Show()
end

function PANEL:OnChoose(color)
	-- nothing, gets over-ridden
end

function PANEL:SetColor(color)
	self.colorpicker:SetColor(color or Color(255, 255, 255, 255))
end

vgui.Register('DPointShopColorChooser', PANEL, 'DFrame')

--addons/module_donate/lua/pointshop/items/cases/case_free.lua:
ITEM.Name = 'Ежедневный кейс'
ITEM.Price = 59
ITEM.Description = "Что можно выбить?\n- 1000$\n- 10.000$\n- 25.000$\n-50.000$\n- 100.000$\n- 150.000$\n- 300.000$\n- 500.000$\n- 1.000.000$\n- 15 донат рублей"
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_free.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот кейс можно получить только из F4 - Бонусы"
end

function ITEM:OnUse(ply)
	ply:OpenCrate('case_free')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_gzt.lua:
ITEM.Name = 'Откалиброванный кейс'
ITEM.Description = [[
Что можно выбить?

Curator на 3 месяц x3
DSAdmin на 3 месяца x3
DSAdmin на месяц x3
DAdmin на 3 месяца x3
DModerator на 3 месяца x5
DModerator на месяц x5
VIP навсегда x3
VIP на 3 месяца x50
VIP на месяц x100
VIP на 15 дней x150
Двойной прыжок на месяц x30
Спавн Entity через Q меню на месяц x25
Спавн оружия через Q меню на месяц x25
Магнум навсегда x30
HL2 Станстик навсегда x30
Smart Pistol на месяц x10
CYBER PACK на месяц x10
Говорилка на месяц x30
Вовозелка на месяц x10
Своя модель на месяц x15]]

ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_gzt.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end

function ITEM:OnUse(ply)
	ply:OpenCrate('case_gzt')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/gman.lua:
ITEM.Name = 'GMan'
ITEM.Price = 199
ITEM.Model = 'models/maxofs2d/balloon_gman.mdl'
--ITEM.Material = Material( "data/wimages/gman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/gman.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/plasm.lua:
ITEM.Name = 'Плазмоган'
ITEM.Price = 499
ITEM.Model = 'models/gibs/gunship_gibs_nosegun.mdl'
--ITEM.Material = Material( "data/wimages/mossman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/plasm.jpg'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-10, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8 + 20), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/cover_flowers.lua:
ITEM.Name = 'Цветущие луга'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_flowers.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_flowers.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_rose.lua:
ITEM.Name = 'Дворец роз'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_rose.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_rose.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/moneypacks/1kk.lua:
ITEM.Name = '1,000,000 $'
ITEM.Price = 39
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 1000000 )
end

--addons/module_donate/lua/pointshop/items/other/addprops.lua:
ITEM.Name = '+200 к лимиту пропов'
ITEM.Description = 'Позволяет спавнить 300 пропов, прибавляя к стандартному лимиту еще 200'
ITEM.Price = 1490
--ITEM.Material =  Material( "data/wimages/props.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/props.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
--addons/module_donate/lua/pointshop/items/other/outfit_shoes_primary.lua:
ITEM.Name = 'Кроссовки Nike'
ITEM.Price = 999
ITEM.Description = '*'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/shoes.png'
ITEM.Model = 'models/denom/amongusdrip/amongusleftshoe.mdl'
ITEM.Bone = 'ValveBiped.Bip01_L_Foot'
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    ply:PS_AddClientsideModel(self.ID)
    ply:PS_GiveItem("outfit_shoes_secondary")
    ply:PS_AddClientsideModel("outfit_shoes_secondary")
    
    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end
end

function ITEM:OnHolster(ply)
    ply:PS_RemoveClientsideModel(self.ID)
    ply:PS_RemoveClientsideModel("outfit_shoes_secondary")
    ply:PS_TakeItem("outfit_shoes_secondary")

    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
    pos = pos + (ang:Forward() * 4) + (ang:Right() * -3) + (ang:Up() * -3) -- vpered, vniz/vverx, vlevo vpravo
   ang:RotateAroundAxis(ang:Forward(), 90)
   ang:RotateAroundAxis(ang:Right(), 30)
   model:SetModelScale(2, 0)

    return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/skinworkshop.lua:
ITEM.Name = 'Своя модель на месяц'
ITEM.Description = 'Позволяет выбрать любую модель из Workshop\nи использовать ее в игре в течение месяца.\nМодель можно изменять раз в день'
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/model_schav.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/model_schav.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_donate/lua/pointshop/items/ranks/curator_navsegda.lua:
ITEM.Name = 'Curator навсегда'
ITEM.Description = "- Имеет все привилегии VIP\n- Имеет все привилегии DModerator\n- Имеет все привилегии DAdmin\n- Имеет все привилегии DSAdmin\n-Имеет доступ к наборной системе жалоб\n- Иммунитет от хелперов\n- Имеет доступ к админ меню наборной администрации\n- Может установить себе размер\n- Может установить себе модель любого предмета\n- Имеет доступ к ивент меню \n- Может скринить экраны игроков \n- При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 4990
--ITEM.Material = Material( "data/wimages/curator_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/curator_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Curator"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dadmin_navsegda.lua:
ITEM.Name = 'DAdmin навсегда'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования \n - Может заморозить игрока \n - Может выдавать оружие \n - Может поджечь игрока \n - Может дать регдолл игроку"
ITEM.Price = 1490
--ITEM.Material = Material( "data/wimages/admin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/admin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DAdmin"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/patron_navsegda.lua:
ITEM.Name = 'Patron навсегда'
ITEM.Description = "*Особая привилегия*\n**Возможна выдача роли в Discord сервере**\n\n- Весь функционал наборного администратора\n- Весь функционал донатных администраторов\n- Увеличенный инвентарь до размера хранилища\n- Переливающийся ник над головой\n- Переливающийся разноцветный скин\n - Переливающийся physgun\n- Наборная модель администратора за профессию Администратор\n- Неограниченая возможность изменения личной модели из Workshop\n- Доступ ко всему запрещенному/крафтовому оружию, включая RPG и все остальное\n- Все вопросы касаемо нарушений рассматриваются высшей администрацией"
ITEM.Price = 29990
--ITEM.Material = Material( "data/wimages/patron_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/patron_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Patron"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_1m.lua:
ITEM.Name = 'VIP на месяц'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 24
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_3m.lua:
ITEM.Name = 'VIP на 3 месяца'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 64
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/crimson.lua:
ITEM.Name = 'Crimson'
ITEM.Description = 'Fight like a beast, yet move like a ghost.'
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/crimson.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_crimson"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/mosin_weapon.lua:
ITEM.Name = 'Винтовка мосин навсегда'
ITEM.Description = 'Старенькая винтовка мосин, с отличной пробиваемостью. Доступна для ношения мэру.'
ITEM.Price = 999
--ITEM.Material =  Material( "data/wimages/smartpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/mosin_weapon.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_mosin"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/outbreak.lua:
ITEM.Name = 'OUTBREAK PERFECTED'
ITEM.Description = '~directive = KILL while enemies = PRESENT: execute(directive)~'
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/outbreak.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_outbreak"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/wayvape.lua:
ITEM.Name = 'WayZer Vape навсегда'
ITEM.Description = "Вейп с жижкой из логотипов сервера, ускоренно восстанавливает HP и Броню"
ITEM.Price = 149
--ITEM.Material = Material( "data/wimages/vape.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vape.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_vape_wayzer"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/wep_palka.lua:
ITEM.Name = 'HL2 Станстик навсегда'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам."
ITEM.Price = 24
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_stunstick"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_spawnguard/lua/autorun/r_spawnprotection.lua:
if ( SERVER ) then
	include( "rsp/sv_init.lua")
	
	include( "rsp/shared.lua" )
	AddCSLuaFile( "rsp/shared.lua" )
else
	include( "rsp/shared.lua" )
end
--addons/ent_top/lua/scoresheet/sheets/money/shared.lua:
local SHEET = {}

SHEET.UniqueID = "top_10_moneys"

SHEET.Name = scoresheet.money_header_text
SHEET.EntName = "score_money"
SHEET.HeaderColor = scoresheet.money_header_text_color

SHEET.Fetch = function(callback)
	MySQLite.query('SELECT * FROM darkrp_player ORDER BY wallet DESC LIMIT '..scoresheet.time_max_count*2, function(d)
        local data = {}
        local usedPlayers = {}
        for _, v in pairs(d) do
        	if not v.rpname then continue end
            if usedPlayers[v.rpname] then continue end

            table.insert(data, v)
            usedPlayers[v.rpname] = true
        end
        callback(data)
    end)
end

SHEET.Draw = function( ent, data )
    local ply = LocalPlayer()
    local distSqr = 1000000
    
    if ply:GetPos():DistToSqr( ent:GetPos() ) > distSqr then return end
	
	local y_pos = 20
	
	local x_pos = 0
	local cnt = 0
	
	for place, row in pairs( data ) do
		local row_header = "#"..place.." - "..row.rpname
		local row_text = DarkRP.formatMoney( tonumber( row.wallet ) )
		
		if ( place == 1 ) then
			surface.SetFont( scoresheet.money_font_header )
			local textW = surface.GetTextSize( row_header )
			
			surface.SetDrawColor( color_white )
			surface.SetMaterial( scoresheet.money_first_place_icon )
			surface.DrawTexturedRect( x_pos + textW + 5, y_pos, 16, 16 )
		end
		
		draw.SimpleText( row_header, scoresheet.money_font_header, x_pos, y_pos, color_white )
		y_pos = y_pos + 20
		
		draw.SimpleText( row_text, scoresheet.money_font_text, x_pos, y_pos, color_white )
		y_pos = y_pos + 25
		
		cnt = cnt + 1
		
		if ( cnt >= scoresheet.money_cut_at_row_count ) then
			x_pos = 250
			y_pos = 20
			cnt = 0
		end
	end
end 

scoresheet:register( SHEET )
--addons/ent_top/lua/scoresheet/sheets/timeplay/shared.lua:
local SHEET = {}

SHEET.UniqueID = "top_timeplay"

SHEET.Name = scoresheet.time_header_text
SHEET.EntName = "score_timeplay"
SHEET.HeaderColor = scoresheet.time_header_text_color

SHEET.Fetch = function(cb)
    local data = {}
	MySQLite.query("SELECT * FROM utime ORDER BY totaltime DESC LIMIT "..scoresheet.time_max_count, function(d)
        for count, v in pairs(d or {}) do
            -- Получаем рп имена
            DarkRP.offlinePlayerData(v.player, function(pd)
                pd = pd and pd[1]
                if not pd then return end

                table.insert(data, {
                    name = pd.rpname or 'Unknown',
                    online = v.totaltime
                })

                -- Вызываем callback потому что ебучая асинхронность
                if count >= #d then
                    cb(data)
                end
            end)
        end
    end)
end

local function niceTime( seconds )
	seconds = tonumber( seconds )

	local days = math.floor( seconds / 86400 )
	local str = ""
	
	if ( days > 0 ) then
		seconds = seconds - ( days * 86400 )
		str = str..days.." дней, "
	end
	
	local hours = math.floor( seconds / 3600 )
	
	if ( hours > 0 ) then
		seconds = seconds - ( hours * 3600 )
		str = str..hours.." часа, "
	end
	
	local minutes = math.floor( seconds / 60 )
	
	if ( minutes > 0 ) then
		seconds = seconds - ( minutes * 60 )
		str = str..minutes.." минут"
	end
	
	if ( str == "" ) then
		str = seconds.." секунд"
	end
	
	return str
end

SHEET.Draw = function( ent, data )
    local ply = LocalPlayer()
    local distSqr = 1000000
    
    if ply:GetPos():DistToSqr( ent:GetPos() ) > distSqr then return end

	local y_pos = 20
	
	local x_pos = 0
	local cnt = 0
	
	for place, row in pairs( data ) do
		local row_header = "#"..place.." - "..row.name
		local row_text = niceTime( row.online )
		
		if ( place == 1 ) then
			surface.SetFont( scoresheet.time_font_header )
			local textW = surface.GetTextSize( row_header )
			
			surface.SetDrawColor( color_white )
			surface.SetMaterial( scoresheet.time_first_place_icon )
			surface.DrawTexturedRect( x_pos + textW + 5, y_pos, 16, 16 )
		end
		
		draw.SimpleText( row_header, scoresheet.time_font_header, x_pos, y_pos, color_white )
		y_pos = y_pos + 20
		
		draw.SimpleText( row_text, scoresheet.time_font_text, x_pos, y_pos, color_white )
		y_pos = y_pos + 25
		
		cnt = cnt + 1
		
		if ( cnt >= scoresheet.time_cut_at_row_count ) then
			x_pos = 250
			y_pos = 20
			cnt = 0
		end
	end
end 

scoresheet:register( SHEET )
--addons/module_rewards/lua/autorun/rewards_init.lua:
rewards = {}

if SERVER then
    AddCSLuaFile('rewards/sh_init.lua')
    include('rewards/sh_init.lua')

    AddCSLuaFile('rewards/cl_core.lua')
    include('rewards/sv_core.lua')

    rewards.methods = {}

    local _, dirs = file.Find('rewards/methods/*', 'LUA')
    for _, dir in pairs(dirs) do
        rewards.methods[dir] = {}
        for _, fileName in pairs(file.Find('rewards/methods/'..dir..'/*.lua', 'LUA')) do
            if fileName:sub(1, 3) == 'cl_' or fileName == 'client.lua' then
                AddCSLuaFile('rewards/methods/'..dir..'/'..fileName)
            end

            if fileName:sub(1, 3) == 'sh_' or fileName == 'shared.lua' then
                AddCSLuaFile('rewards/methods/'..dir..'/'..fileName)
                include('rewards/methods/'..dir..'/'..fileName)
            end

            if fileName:sub(1, 3) == 'sv_' or fileName == 'server.lua' then
                include('rewards/methods/'..dir..'/'..fileName)
            end
        end
    end
else
    include('rewards/sh_init.lua')
    include('rewards/cl_core.lua')

    rewards.methods = {}

    local _, dirs = file.Find('rewards/methods/*', 'LUA')
    for _, dir in pairs(dirs) do
        rewards.methods[dir] = {}
        for _, fileName in pairs(file.Find('rewards/methods/'..dir..'/*.lua', 'LUA')) do
            if fileName:sub(1, 3) == 'cl_' or fileName == 'client.lua' then
                include('rewards/methods/'..dir..'/'..fileName)
            end

            if fileName:sub(1, 3) == 'sh_' or fileName == 'shared.lua' then
                include('rewards/methods/'..dir..'/'..fileName)
            end
        end
    end
end
--addons/module_disguise/lua/autorun/client/frame.lua:
local color_dark = Color(47,49,54,255)
local color_bright = Color(54,57,62,255)
local color_other = Color(51, 54, 60, 255)

net.Receive("DisguiseKitOpen", function()
	local data = net.ReadTable()
	local disguisetbl = data.disguises
	local sidecount = table.Count(disguisetbl)
	local upcount = math.ceil(sidecount / 8)
	local ply = LocalPlayer()
	
	if sidecount > 8 then
		sidecount = 8
	end
---	
	local frame = vgui.Create("DFrame")
	frame:SetSize(79 * 8 + 35, upcount * 79 + 95)
	frame:Center()
	frame:SetTitle("Маскировка")
	frame:SetDeleteOnClose(true)
	frame:MakePopup()
	frame.Paint = function()
		draw.RoundedBox(0, 0, 0, frame:GetWide(), frame:GetTall(), color_bright)
	end

	local itemspanel = vgui.Create("DPanel", frame)
	itemspanel:SetPos(10, 30)
	itemspanel:SetSize(79 * 8 + 15, upcount * 79 + 55)
	itemspanel.Paint = function()
		draw.RoundedBox(0, 0, 0, itemspanel:GetWide(), itemspanel:GetTall(), color_dark)
	end

	local itemspanel2 = vgui.Create("DPanel", itemspanel)
	itemspanel2:SetPos(5, 5)
	itemspanel2:SetSize(79 * 8 + 5, upcount * 79 + 45)
	itemspanel2.Paint = function()
		draw.RoundedBox(0, 0, 0, itemspanel2:GetWide(), itemspanel2:GetTall(), color_dark)
	end
	
	local chargepanel = vgui.Create("DPanel", itemspanel2) 
	chargepanel:SetPos(400, 5)
	chargepanel:SetSize(232, 35) 
	chargepanel.Paint = function()
		draw.RoundedBox(0, 0, 0, chargepanel:GetWide(), chargepanel:GetTall(), color_bright)
	end
	
	local progress = data.timeleft / DISGUISE_KIT_COOLDOWN
	local status = "Перезарядка"
	
	if progress >= 1 then
		progress = 1
		status = "Готово"
	end
	
	local chargeprogress = vgui.Create("DPanel", chargepanel)
	chargeprogress:SetPos(3, 3)
	chargeprogress:SetSize(progress * 226, 29) 
	chargeprogress.Paint = function()
		draw.RoundedBox(0, 0, 0, chargeprogress:GetWide(), chargeprogress:GetTall(), color_other)
	end
	
	local chargestatus = vgui.Create("DLabel", chargepanel)
	chargestatus:Dock(FILL)
	chargestatus:DockMargin(50,0,0,0)
	chargestatus:SetFont("Trebuchet24")
	chargestatus:SetText(status)
	chargestatus:SetTextColor(color_white)
		
	local title = vgui.Create("DLabel", itemspanel2)
	title:SetPos(5, 5)
	title:SetSize(200, 30)
	title:SetFont("HUDNumber5")
	title:SetText("Маскировка")
	title:SetTextColor(color_white)
		
		
local i = 0
local rows = upcount
local row = upcount - rows

for k, v in pairs(disguisetbl) do
        local panel = vgui.Create("DPanel", itemspanel2)
        panel:SetPos(i * 79 + 5, row * 79 + 45)
        panel:SetSize(74, 74) 
        panel:SetBackgroundColor( color_dark)
		
		local icon = vgui.Create("SpawnIcon", panel)
		icon:SetPos(5, 5)
		icon:SetSize(64, 64)
		icon:SetModel(v.icon)
		icon:SetToolTip(v.name)
		icon.DoClick = function()
			net.Start("disguise")
				net.WriteInt(v.team, 32)
			net.SendToServer()
			frame:Close()
		end
		
		i = i + 1
		
		if i >= 8 then
			i = 0
			row = row + 1
		end
	end
end)


hook.Add('FAdmin_PlayerRowColour', 'disguise', function(ply)
    if not ply:GetNetVar('disguised') then return end
	if LocalPlayer():Team() == TEAM_ADMIN then return end

    return (LocalPlayer():isCP() and ply:isCP()) and team.GetColor(ply:Team()) or team.GetColor(ply:GetNetVar('disguise_team'))
end)

hook.Add('GetTeamColor', 'disguiseKitChatFix', function(ply)
	if ply:GetNetVar('disguised') then return GAMEMODE:GetTeamNumColor(ply:GetNetVar('disguise_team')) end
end)
--addons/_smallscripts/lua/autorun/sh_advert.lua:
--[[-------------------------------------------------------------------------
You are free to use, distribute and change this module, as long as you keep
this text here - and/or credit me:

Made by Fillipuster :D
---------------------------------------------------------------------------]]

CLASSICADVERT = CLASSICADVERT or {}

--[[-------------------------------------------------------------------------
					CLASSIC ADVERT CONFIG
---------------------------------------------------------------------------]]

-- The prefix before the adverted text (but after the sending player's name).
CLASSICADVERT.chatPrefix = "[Объявление]"

-- The color of the text in the advert (Originally yellow).
CLASSICADVERT.advertTextColor = Color( 255, 255, 0, 255 )

-- The failure message id the players fails to provide text for the advert.
CLASSICADVERT.failMessage = "You need to provide text for your advert."

-- The chat command for adverts. (A "/" is added at the front automatically.)
CLASSICADVERT.chatCommand = "advert" -- Please, do not use "/advert" as it is used for the new advert system in DarkRP.

-- The F1 (help menu) description of the advert command.
CLASSICADVERT.commandDescription = "Message all players on the server."

-- The delay (in seconds) between players being able to advert.
CLASSICADVERT.commandDelay = 3

--[[-------------------------------------------------------------------------
					END OF CONFIG
---------------------------------------------------------------------------]]
hook.Add("DarkRPFinishedLoading", 'override_advert', function()
    timer.Simple(1, function()
        DarkRP.declareChatCommand{
            command = CLASSICADVERT.chatCommand,
            description = CLASSICADVERT.commandDescription,
            delay = CLASSICADVERT.commandDelay
        }

        DarkRP.declareChatCommand{
            command = "anon",
            description = "anon message all server",
            delay = 3
        }
    end)
end)

--addons/module_bitminers2_extras/lua/autorun/sh_bitminers2_extras.lua:
BITMINERS_2_EXTRAS_DLC = true
--addons/module_donate/lua/pointshop/items/cases/case_gift.lua:
ITEM.Name = 'Новогодний подарок'
ITEM.Description = [[
Что можно выбить?

1 рубль
3 рубля
5 рублей
10 рублей
15 рублей
25 рублей
35 рублей
45 рублей
50 рублей
100 рублей]]

ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_free.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Найди этот кейс под елкой"
end

function ITEM:OnUse(ply)
	ply:OpenCrate('case_gift')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_steel.lua:
ITEM.Name = 'Стальной Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Винтовка мосин навсегда"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_steel.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_steel')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_usergroup.lua:
ITEM.Name = 'Кейс с привилегиями'
ITEM.Price = 179
ITEM.Description = "Что можно выбить?\n- VIP на любой срок\n- DModerator на любой срок\n- DAdmin на любой срок\n-DSAdmin на любой срок\n- Curator на любой срок\n- Patron навсегда"
--ITEM.Material =  Material( "data/wimages/case_usergroup.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_usergroup.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_usergroup')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/__category.lua:
CATEGORY.Name = 'Компаньоны'
CATEGORY.Icon = 'ghost'
CATEGORY.AllowedEquipped = 1
CATEGORY.Order = 11
--addons/module_donate/lua/pointshop/items/companions/dog.lua:
ITEM.Name = 'Собака'
ITEM.Price = 299
ITEM.Model = 'models/balloons/balloon_dog.mdl'
--ITEM.Material = Material( "data/wimages/dog.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dog.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/dragon.lua:
ITEM.Name = 'Дракон'
ITEM.Price = 349
ITEM.Model = 'models/roblox/a_very_special_monster.mdl'
--ITEM.Material = Material( "data/wimages/skull.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dragon.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.z = plyAng.z + -90
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end


--addons/module_donate/lua/pointshop/items/companions/snowhead.lua:
ITEM.Name = 'Снеговик ( Новый Год )'
ITEM.Price = 349
ITEM.Model = 'models/props/cs_office/snowman_face.mdl'
--ITEM.Material = Material( "data/wimages/snowman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/snowman.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/cover_cat.lua:
ITEM.Name = 'Пушистое облако'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_cat.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_cat.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_homelander.lua:
ITEM.Name = 'Гнев твердыни'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_homelander.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_homelander.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_visage.lua:
ITEM.Name = 'Искаженный лик'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_visage.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_visage.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/moneypacks/1kk.lua:
ITEM.Name = '1,000,000 $'
ITEM.Price = 39
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 1000000 )
end

--addons/module_donate/lua/pointshop/items/moneypacks/500k.lua:
ITEM.Name = '500,000 $'
ITEM.Price = 19
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 500000 )
end

--addons/module_donate/lua/pointshop/items/moneypacks/5kk.lua:
ITEM.Name = '5,000,000 $'
ITEM.Price = 199
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 5000000 )
end

--addons/module_donate/lua/pointshop/items/other/2d.lua:
ITEM.Name = '2D модельки на 5 минут'
ITEM.Description = 'Делает всех игроков на сервере плоскими'
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/props.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/props.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse( ply )
	net.Start('Set2DPlayer')
	net.Broadcast()
  	DarkRP.notifyAll(0, 10, ply:Name().." сделал всех 2D на 5 минут")
end
--addons/module_donate/lua/pointshop/items/other/addprops.lua:
ITEM.Name = '+200 к лимиту пропов'
ITEM.Description = 'Позволяет спавнить 300 пропов, прибавляя к стандартному лимиту еще 200'
ITEM.Price = 1490
--ITEM.Material =  Material( "data/wimages/props.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/props.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
--addons/module_donate/lua/pointshop/items/other/outfit_bear.lua:
ITEM.Name = 'Медведь за спиной'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Model = 'models/roblox_assets/polar_bear_shoulder_friend.mdl'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.Hidden = true
ITEM.NoScroll = true
--ITEM.Job = {['citizen'] = true, ['chocmaker'] = true, ['miners'] = true, ['samogon'] = true, ['bar'] = true, ['gundealer'] = true}
--ITEM.NoDrawDisguise = false

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 5)
	ang:RotateAroundAxis(ang:Up(), -90)
	ang:RotateAroundAxis(ang:Forward(), -90)
	
	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/outfit_guitar.lua:
ITEM.Name = 'Гитара на спине'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.Model = 'models/props_phx/misc/fender.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.NoScroll = true
ITEM.Hidden = true
--ITEM.Job = {['maniak'] = true}
--ITEM.NoDrawDisguise = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 3) + (ang:Up() * 1) + (ang:Forward() * 1)
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Up(), 160)

	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/outfit_knife.lua:
-- должно показыватся только с ножом в руках ( все профессии )

ITEM.Name = 'Нож в левую руку'
ITEM.Price = 999
ITEM.Model = 'models/weapons/w_knife_ct.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_L_Hand'
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 1.5) + (ang:Up() * 2) 
	
	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/outfit_shoes_primary.lua:
ITEM.Name = 'Кроссовки Nike'
ITEM.Price = 999
ITEM.Description = '*'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/shoes.png'
ITEM.Model = 'models/denom/amongusdrip/amongusleftshoe.mdl'
ITEM.Bone = 'ValveBiped.Bip01_L_Foot'
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    ply:PS_AddClientsideModel(self.ID)
    ply:PS_GiveItem("outfit_shoes_secondary")
    ply:PS_AddClientsideModel("outfit_shoes_secondary")
    
    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(0.01, 0.01, 0.01))
    end
end

function ITEM:OnHolster(ply)
    ply:PS_RemoveClientsideModel(self.ID)
    ply:PS_RemoveClientsideModel("outfit_shoes_secondary")
    ply:PS_TakeItem("outfit_shoes_secondary")

    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_L_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Foot")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end

    local boneID = ply:LookupBone("ValveBiped.Bip01_R_Toe0")

    if boneID then
        ply:ManipulateBoneScale(boneID, Vector(1, 1, 1))
    end
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
    pos = pos + (ang:Forward() * 4) + (ang:Right() * -3) + (ang:Up() * -3) -- vpered, vniz/vverx, vlevo vpravo
   ang:RotateAroundAxis(ang:Forward(), 90)
   ang:RotateAroundAxis(ang:Right(), 30)
   model:SetModelScale(2, 0)

    return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/unban.lua:
ITEM.Name = 'Разбан'
ITEM.Description = 'Снимает активный бан'
ITEM.Price = 149
--ITEM.Material = Material( "data/wimages/cross.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cross.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse( ply )
	FAdmin.UnBan( Entity(0), "", {ply:SteamID()} )
end

function ITEM:CanPlayerUse( ply )
	return ply:GetNetVar( "IsBanned" ), "Ты и так без бана, дружище"
end

--addons/module_donate/lua/pointshop/items/ranks/dadmin_1m.lua:
ITEM.Name = 'DAdmin на месяц'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования \n - Может заморозить игрока \n - Может выдавать оружие \n - Может поджечь игрока \n - Может дать регдолл игроку"
ITEM.Price = 199
--ITEM.Material = Material( "data/wimages/admin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/admin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DAdmin"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dmoderator_navsegda.lua:
ITEM.Name = 'DModerator навсегда'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования"
ITEM.Price = 990
--ITEM.Material = Material( "data/wimages/moder_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moder_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DModerator"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_3m.lua:
ITEM.Name = 'VIP на 3 месяца'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 64
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/bowie_knife.lua:
ITEM.Name = 'Нож Bowie'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_bowie"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/falchion_knife.lua:
ITEM.Name = 'Нож Falchion'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_falchion"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/hpvape.lua:
ITEM.Name = 'HP Vape навсегда'
ITEM.Description = "Вейп с жижкой, восстанавливает ХП до 110, обходя лимит"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/vape.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vape.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_vape_hp"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/karambit_knife.lua:
ITEM.Name = 'Нож Karambit'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_karambit"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/khvostov.lua:
ITEM.Name = 'Khvostov 7G-0X'
ITEM.Description = ''
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/khvostov.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_khvostov"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/smartpistol_navsegda.lua:
ITEM.Name = 'Smart Pistol навсегда'
ITEM.Description = 'Пистолет из игры Titanfall с автоматическим прицеливанием и высокой скорострельностью'
ITEM.Price = 999
--ITEM.Material =  Material( "data/wimages/smartpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/smartpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "mp_weapon_smart_pistol"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_phone/lua/autorun/sh_hax_config.lua:
Krede_WD_HaxList = {}

Krede_WD_HaxList["gmod_cameraprop"] = {
	name = "Камера",
	cost = 2,
	offset = Vector(0,0,2),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
		ply:SetViewEntity( ent )
		ply:GetActiveWeapon():SetWCamera(true)
	end,
}
Krede_WD_HaxList["gmod_button"] = {
	name = "Кнопка",
	cost = 2,
	offset = Vector(0,0,5),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
		ent:Toggle( !ent:GetOn(), ply )
	end,
}
Krede_WD_HaxList["gmod_light"] = {
	name = "Свет",
	cost = 2,
	offset = Vector(0,0,0),
	show = function(ent, ply)
		return false
	end,
	use = function(ent, ply, box)
		if box then
			ent:Toggle()
		end
	end,
}
Krede_WD_HaxList["func_button"] = {
	name = "Кнопка",
	cost = 2,
	offset = Vector(0,0,5),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
		ent:Input("Press",ply,ply)
	end,
}
Krede_WD_HaxList["prop_door"] = {
	name = "Дверь",
	cost = 2,
	offset = Vector(0,0,10),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
		if ent:GetSaveTable( ).m_bLocked then
			ent:Fire("Unlock")
			ent:Fire("Open")
		else
			ent:Fire("Lock")
			ent:Fire("Close")
		end
	end,
}
Krede_WD_HaxList["prop_door_rotating"] = {
	name = "Дверь",
	cost = 2,
	offset = Vector(0,0,10),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
		if ent:GetSaveTable( ).m_bLocked then
			ent:Fire("Unlock")
			ent:Fire("Open")
		else
			ent:Fire("Lock")
			ent:Fire("Close")
		end
	end,
}

Krede_WD_HaxList["keypad_pattern"] = {
	name = "Кейпад",
	cost = 3,
	offset = Vector(0,0,10),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
		ent:Process(true)
	end,
}

Krede_WD_HaxList["itemstore_bank"] = {
	name = "Удар током",
	cost = 4,
	offset = Vector(0,0,70),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
	    for k,v in ipairs(player.GetAll()) do
		    if v:GetPos():DistToSqr(ent:GetPos()) < 90000 then
          		local getpos = v:GetPos()
          		local data = EffectData()
          		data:SetOrigin(getpos + Vector(0, 0, 60))
          		data:SetScale(5)
          		ent:EmitSound('ambient/energy/zap'..math.random(1,9)..'.wav')
          		util.BlastDamage(v,ply,getpos,100,10)
            	util.Effect("Sparks", data)
    	    end
	    end
	end,
}

Krede_WD_HaxList["ent_timebomb"] = {
	name = "Удар током",
	cost = 4,
	offset = Vector(0,0,70),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
	    for k,v in ipairs(player.GetAll()) do
		    if v:GetPos():DistToSqr(ent:GetPos()) < 90000 then
          		local getpos = v:GetPos()
          		local data = EffectData()
          		data:SetOrigin(getpos + Vector(0, 0, 60))
          		data:SetScale(5)
          		ent:EmitSound('ambient/energy/zap'..math.random(1,9)..'.wav')
          		util.BlastDamage(v,ply,getpos,100,10)
            	util.Effect("Sparks", data)
    	    end
	    end
	end,
}

Krede_WD_HaxList["money_clicker"] = {
	name = "Вызать перегрев кликера",
	cost = 2,
	offset = Vector(0,0,70),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
	    ent:SetHeat(100)
	end,
}

Krede_WD_HaxList["ddv_poop"] = {
	name = "Взломать какашку",
	cost = 2,
	offset = Vector(0,0,70),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
	    --local index = ent:EntIndex()
	    --if timer.Exists(index..'_poop_hack') then return end
	    ent:SetMaterial('models/antlion/antlion_innards')
	    --timer.Create(index..'_poop_hack', 1, 0, function()
	    --	if not IsValid(ent) then return timer.Destroy(index..'_poop_hack') end
          	local getpos = ent:GetPos()
          	local data = EffectData()
          	data:SetOrigin(getpos + Vector(0, 0, 60))
          	data:SetScale(5)
	    	util.Effect('HunterDamage', data)

	    	for k,v in ipairs(ents.FindInSphere(ent:GetPos(), 300)) do
	    		if not v:IsPlayer() then continue end
	    		--v:ConCommand('poop')
	    		v:ConCommand('piss')
	    	end
	    --end)
	end,
}

Krede_WD_HaxList["bank_vault"] = {
	name = "Активировать сирену",
	cost = 2,
	offset = Vector(0,0,70),
	show = function(ent, ply)
		return true
	end,
	use = function(ent, ply)
	    local index = ent:EntIndex()
	    if timer.Exists(index..'_bank_alarm') then return end
	    timer.Create(index..'_bank_alarm', 1, 15, function()
	    	if not IsValid(ent) then return timer.Destroy(index..'_bank_alarm') end
          	ent:EmitSound('ambient/alarms/klaxon1.wav')
	    end)
	end,
}

local reasons = {
	[1] = "Убийство",
	[2] = "Кража",
	[3] = "Нелегальное оружие",
	[4] = "ERROR",
	[5] = "&SERROR*#"
}

Krede_WD_HaxList["player"] = {
	name = "Житель",
	cost = 4,
	offset = Vector(0,0,70),
	show = function(ent, ply)
		if ent:Alive() and ent != ply then
			return true
		end
	end,
	use = function(ent, ply)
		if ent:Alive() then
			if ent:isWanted() then
				ent:unWanted(ply)
			else
				ent:wanted(ply, reasons[math.random(1,5)], 120)
			end
		end
	end,
}
--addons/module_cmenu/lua/autorun/sh_properties.lua:
/* #NoSimplerr# */

// position of the menu

C_LANGUAGE_PHONE_TOGGLE_ON = 'Включить телефон'

C_LANGUAGE_PHONE_TOGGLE_OFF = 'Выключить телефон'

C_LANGUAGE_PHONE = 'Позвонить'

C_LANGUAGE_PHONE_SOUND = 'Выбрать мелодию звонка'

C_CONFIG_POSITION = "left"

C_LANGUAGE_MONEY = "Дать денег игроку напротив"
C_LANGUAGE_MONEY_DESCRIPTION = "Сколько вы хотите дать ему денег?"

C_LANGUAGE_DEMOTE = "Уволить"
C_LANGUAGE_DEMOTE_DESCRIPTION = "Почему вы хотите уволить игрока?"

C_LANGUAGE_WANTED = "Подать в розыск"
C_LANGUAGE_WANTED_DESCRIPTION = "Почему вы хотите подать этого человека в розыск?"

C_LANGUAGE_UNWANTED = "Убрать из розыска"

C_LANGUAGE_WARRANT = "Запрос на обыск"
C_LANGUAGE_WARRANT_DESCRIPTION = "По какой причине вы хотите обыскать этого человека?"

C_LANGUAGE_WARRANT_PROP = "Запрос на обыск"

C_LANGUAGE_GIVE_LICENSE = "Дать лицензию"

C_LANGUAGE_MONEY_DROP = "Выкинуть деньги"
C_LANGUAGE_MONEY_DROP_DESCRIPTION = "Сколько вы хотите выкинуть денег?"

C_LANGUAGE_MONEY_GIVE = "Передать деньги"
C_LANGUAGE_MONEY_GIVE_DESCRIPTION = "Сколько вы хотите дать ему денег? ( Ты должен смотреть на игрока )"

C_LANGUAGE_DROP = "Выкинуть оружие"

C_LANGUAGE_LOTTERY = "Лотерея"
C_LANGUAGE_LOTTERY_AMOUNT = "Введите сумму лотереи | От $30 до $50.000 |"


C_LANGUAGE_points = "PointShop"
C_LANGUAGE_orgm = "Меню организации"

C_LANGUAGE_UNOWN_ALL = "Продать все двери"
C_LANGUAGE_UNOWN_AAA = "Донат"

C_LANGUAGE_DONATE = "Донат"

C_LANGUAGE_NAME = "Изменить имя"

C_KAMENON = "Включить ком.час"

C_KAMEN = "Отключить ком.час"

START_LOCKDOWN = "Комчас"
REASON = "Укажите причину"
C_LANGUAGE_LOCKDOWN = "Комендантский час"
C_LANGUAGE_UNLOCKDOWN = "Убрать комендантский час"

C_LANGUAGE_AGENDA = "Set agenda"
C_LANGUAGE_AGENDA_DESCRIPTION = "Enter new agenda"

C_LANGUAGE_CUSTOM_JOB = "Set custom job"
C_LANGUAGE_CUSTOM_JOB_DESCRIPTION = "Enter new custom job"

C_LANGUAGE_RPNAME = "Поменять имя"
C_LANGUAGE_RPNAME_DESCRIPTION = "Введите имя"
CALL_ADMIN = "Открыть pLogs"

properties.Add("givemoney", {
	MenuLabel = "Передать деньги",
	Order = 2,
	MenuIcon = "icon16/money.png",

	Filter = function( self, ent, ply )
		if not IsValid( ent ) or not ent:IsPlayer() then return false end
		if ply:GetPos():DistToSqr(ent:GetPos()) > 40000 then return false end
		if hook.Run('CanUseMoney', ply, 'give', nil, ent) == false then return false end

		return true
	end,
	Action = function( self, ent )
		Derma_StringRequest(C_LANGUAGE_MONEY, C_LANGUAGE_MONEY_DESCRIPTION, nil, function(a)
			if !tonumber(a) then return end
			self:MsgStart()
				net.WriteEntity(ent)
				net.WriteFloat(tonumber(a))
			self:MsgEnd()
		end)
	end,
	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		local amount = net.ReadFloat()
		
        ply.givemtimer = ply.givemtimer or 0
        
    	if CurTime() < ply.givemtimer then
    		DarkRP.notify( ply, NOTIFY_ERROR, 3, "Подожди немного..." )
    		return
    	end

		if !(self:Filter(ent, ply) && amount) then return end

		if not ply:canAfford(amount) then
			DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("cant_afford", ""))

			return ""
		end
		
	    ply.givemtimer = CurTime() + 10

		ply:addMoney(-amount)
		ent:addMoney(amount)
		
		ply:DoAnimationEvent(ACT_GMOD_GESTURE_ITEM_GIVE)

		DarkRP.notify(ent, 0, 4, DarkRP.getPhrase("has_given", ply:DisplayName(), DarkRP.formatMoney(amount)))
		DarkRP.notify(ply, 0, 4, DarkRP.getPhrase("you_gave", ent:DisplayName(), DarkRP.formatMoney(amount)))
	end
})

properties.Add("steamid", {
	MenuLabel = "Скопировать SteamID",
	Order = 10,
	MenuIcon = "icon72/floppy_disk.png",

	Filter = function( self, ent, ply )
		return IsValid( ent ) && ent:IsPlayer() and ply:Team() == TEAM_ADMIN
	end,
	Action = function( self, ent )
		SetClipboardText( ent:SteamID() )
	end
})

properties.Add("wanted", {
	MenuLabel = C_LANGUAGE_WANTED,
	Order = 3,
	MenuIcon = "icon16/flag_red.png",

	Filter = function( self, ent, ply )
		return IsValid( ent ) && ent:IsPlayer() && !ent:isWanted() && GAMEMODE.CivilProtection[ply:Team()]
	end,
	Action = function( self, ent )
		Derma_StringRequest(C_LANGUAGE_WANTED, C_LANGUAGE_WANTED_DESCRIPTION, nil, function(a)
			RunConsoleCommand("darkrp", "wanted", ent:UserID(), a)
		end)
	end
})

properties.Add("unwanted", {
	MenuLabel = C_LANGUAGE_UNWANTED,
	Order = 4,
	MenuIcon = "icon16/flag_green.png",

	Filter = function( self, ent, ply )
		return IsValid( ent ) && ent:IsPlayer() && ent:isWanted() && ply:isCP()
	end,
	Action = function( self, ent )
		RunConsoleCommand("darkrp", "unwanted", ent:UserID())
	end
})

properties.Add("warrant", {
	MenuLabel = C_LANGUAGE_WARRANT,
	Order = 5,
	MenuIcon = "icon16/door_in.png",

	Filter = function( self, ent, ply )
		return IsValid( ent ) && ent:IsPlayer() && ply:isCP()
	end,
	Action = function( self, ent )
		Derma_StringRequest(C_LANGUAGE_WARRANT, C_LANGUAGE_WARRANT_DESCRIPTION, nil, function(a)
			RunConsoleCommand("darkrp", "warrant", ent:UserID(), a)
		end)
	end
})

properties.Add("givelicense", {
	MenuLabel = C_LANGUAGE_GIVE_LICENSE,
	Order = 6,
	MenuIcon = "icon16/page_add.png",

	Filter = function( self, ent, ply )
		if not IsValid(ent) or not ent:IsPlayer() then return false end
		if ply:GetPos():DistToSqr(ent:GetPos()) >= 500*500 then return false end

		local noMayorExists = fn.Compose{fn.Null, fn.Curry(fn.Filter, 2)(ply.isMayor), player.GetAll}
		local noChiefExists = fn.Compose{fn.Null, fn.Curry(fn.Filter, 2)(ply.isChief), player.GetAll}

		local canGiveLicense = fn.FOr{
			ply.isMayor, -- Mayors can hand out licenses
			fn.FAnd{ply.isChief, noMayorExists}, -- Chiefs can if there is no mayor
			fn.FAnd{ply.isCP, noChiefExists, noMayorExists} -- CP's can if there are no chiefs nor mayors
		}

		if not canGiveLicense(ply) then
			return false
		end

		return not ent:HasLicense()
	end,
	Action = function( self, ent )
		Derma_StringRequest('Выдача лицензии', 'Введи ниже тип лицензии', 'Лицензия', function(text)
			self:MsgStart()
				net.WriteEntity(ent)
				net.WriteString(text)
			self:MsgEnd()
		end)
	end,
	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		local term = net.ReadString()

		if term and term ~= '' and utf8.len(term) > 3 then
			term = utf8.sub(term, 1, 60)
		else
			term = 'Лицензия'
		end

		if not self:Filter(ent, ply) then return end

		ent:GiveLicense(term, ply)

		DarkRP.notify(ply, 0, 4, 'Ты успешно выдал '..ent:Name().. ' лицензию')
		DarkRP.notify(ent, 0, 4, ply:Name()..' выдал тебе лицензию')
	end
})

properties.Add('revokelicense', {
	MenuLabel = 'Отозвать лицензию',
	Order = 6,
	MenuIcon = 'icon16/page_remove.png',

	Filter = function( self, ent, ply )
		if not IsValid(ent) or not ent:IsPlayer() then return false end
		if ply:GetPos():DistToSqr(ent:GetPos()) >= 500*500 then return false end

		local license = ent:GetLicense()
		if not license then return false end

		if license.fake or ent:getJobTable().hasLicense then return false end

		return ply:isMayor()
	end,
	Action = function( self, ent )
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	Receive = function( self, length, ply )
		local ent = net.ReadEntity()

		if not self:Filter(ent, ply) then return end

		ent:RevokeLicense()

		DarkRP.notify(ply, 0, 4, 'Ты успешно отозвал лицензию '..ent:Name())
		DarkRP.notify(ent, 0, 4, ply:Name()..' отозвал твою лицензию')
	end
})

properties.Add("warrantbyprop", {
	MenuLabel = C_LANGUAGE_WARRANT_PROP,
	Order = 5,
	MenuIcon = "icon16/door_in.png",

	Filter = function( self, ent, ply )
		if not ply:isCP() then return false end
		if not IsValid(ent) then return false end
		if IsValid(ent:DoorGetOwner()) then return true end
		if IsValid(ent:CPPIGetOwner()) and ent:CPPIGetOwner():IsPlayer() then return true end

		return false
	end,
	Action = function( self, ent )
		local ply = ent:DoorGetOwner() or ent:CPPIGetOwner()
		Derma_StringRequest(C_LANGUAGE_WARRANT, C_LANGUAGE_WARRANT_DESCRIPTION, nil, function(a)
			RunConsoleCommand("darkrp", "warrant", ply:UserID(), a)
		end)
	end
})

properties.Add("pushplayer", {
	MenuLabel = "Толкнуть",
	Order = 1,
	MenuIcon = "icon16/arrow_out.png",

	Filter = function( self, ent, ply )
		if not IsValid(ent) or not ent:IsPlayer() then return false end
		if InSpawn(ent) or InSpawn(ply) then return false end
		if not ply:Alive() then return false end
		if ply:IsBanned() or ent:IsBanned() then return false end
		return ply:GetPos():DistToSqr(ent:GetPos()) < 40000 && ent ~= ply
	end,
	Action = function( self, ent )
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
        ent.PushTimer = ent.PushTimer or 0
		if !(self:Filter(ent, ply)) then return end
        if CurTime() < ent.PushTimer then return end
		ply:EmitSound( "physics/body/body_medium_impact_soft"..math.random(1,7)..".wav", 50, 100 )
		ply:DoAnimationEvent(ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM)
		
		local velAng = ply:EyeAngles():Forward()
		velAng.z = 0.3
		ent:SetVelocity( velAng * 500 )
		ent:ViewPunch( Angle( math.random( -5, 5 ), math.random( -5, 5 ), 0 ) )
		ent.PushTimer = CurTime() + 3
	end
})

properties.Add("cuffbroadcast", {
    MenuLabel = "Передать наручники",
    Order = 7,
    MenuIcon = "icon16/bullet_go.png",
    Filter = function(self, ent, ply)
        if (not IsValid(ply)) or ply:IsHandcuffed() then return end
        local DraggedCuffs = {}

        for _, c in pairs(ents.FindByClass("weapon_handcuffed")) do
            if c:GetRopeLength() > 0 and c:GetKidnapper() == ply then
                table.insert(DraggedCuffs, c)
            end
        end

        if #DraggedCuffs <= 0 then return end

        local tr = util.TraceLine({
            start = ply:EyePos(),
            endpos = ply:EyePos() + (ply:GetAimVector() * 100),
            filter = ply
        })

        if not tr.Hit then return end

        if IsValid(tr.Entity) then
            if tr.Entity:IsPlayer() then
                for i = 1, #DraggedCuffs do
                    if DraggedCuffs[i].Owner == tr.Entity then
                        continue
                    else
                        return true
                    end
                end

                return
            end
        end

        return false
    end,
    Action = function(self, ent)
        net.Start("Cuffs_TiePlayers")
        net.SendToServer()
    end
})

properties.Add("handcuff_tie", {
    MenuLabel = "Связать",
    Order = 8,
    MenuIcon = "icon72/chains.png",
    Filter = function(self, ent, ply)
		if not IsValid(ent) or not ent:IsPlayer() then return false end
		if ply:IsHandcuffed() or ent:IsHandcuffed() then return false end
		if ply:GetUseEntity() ~= ent then return false end

		local wep = wlib.array.find(ply:GetWeapons(), function(wep) return wep.Base == 'weapon_cuff_base' end)
		if not IsValid(wep) or wep:GetCuffTime() > CurTime() then return false end

		return wep
	end,
    Action = function(self, ent)
        self:MsgStart()
		self:MsgEnd()
    end,
	Receive = function(self, len, ply)
		local ent = ply:GetUseEntity()
		local wep = self:Filter(ent, ply)
		if not IsValid(wep) then return end

		ply:StartDelay('handcuffs_cuff', 'Связывание', wep.CuffTime, function(s, ply)
			wep:SetIsCuffing( false )
			wep:SetCuffTime( CurTime() + wep.CuffRecharge )
			wep:DoHandcuff( wep:GetCuffing() )
		end, function(s, ply)
			if not IsValid(wep) then return false end
			local tr = wep:TargetTrace()
			if (not tr) or tr.Entity~=wep:GetCuffing() then return false end
		end, function(s, ply)
			wep:SetIsCuffing(false)
			wep:SetCuffTime( 0 )
		end)
	
		wep:SetCuffTime( CurTime() + wep.CuffTime )
		wep:SetIsCuffing( true )
		wep:SetCuffing( ent )
	end,
})
if PS.Config.CanPlayersGivePoints then
	properties.Add("trade", {
		MenuLabel = "Предложить обмен",
		Order = 9,
		MenuIcon = "icon16/box.png",

		Filter = function( self, ent, ply )
			return IsValid( ent ) && ent:IsPlayer()
		end,
		Action = function( self, ent )
			self:MsgStart()
				net.WriteEntity(ent)
			self:MsgEnd()
		end,
		Receive = function( self, length, ply )
			local target = net.ReadEntity()

			if not ply:CanUseInventory() then
				ply:ChatPrint( itemstore.Translate( "cant_access_inventory" ) )
				return
			end

			if not itemstore.config.TradingEnabled then
				return
			end

			if ply.TradingCooldown and ply.TradingCooldown > CurTime() then
				ply:ChatPrint( itemstore.Translate( "trading_cooldown" ) )
				return
			end

			if not target:CanUseInventory() then
				ply:ChatPrint( itemstore.Translate( "partner_cant_access_inventory" ) )
				return
			end

			if ply.Trade then
				ply:ChatPrint( itemstore.Translate( "already_in_trade" ) )
				return
			end

			if target.Trade then
				ply:ChatPrint( itemstore.Translate( "partner_is_in_trade" ) )
				return
			end

			if itemstore.config.TradeDistance ~= 0 and ply:GetPos():Distance( target:GetPos() ) > itemstore.config.TradeDistance then
				ply:ChatPrint( itemstore.Translate( "too_far_away" ) )
				return
			end

			itemstore.Trade( ply, target )

			ply.TradingCooldown = CurTime() + itemstore.config.TradeCooldown
		end
	})
end

properties.Add("showlicense", {
	MenuLabel = "Показать лицензию",
	Order = 10,
	MenuIcon = "icon16/page.png",

	Filter = function( self, ent, ply )
		if not IsValid(ent) or not ent:IsPlayer() then return false end
		if ply:GetPos():DistToSqr(ent:GetPos()) >= 500*500 then return false end

		return ply:HasLicense()
	end,
	Action = function( self, ent )
		RunConsoleCommand('darkrp', 'showlicense')
	end,
})
--addons/_smallscripts/lua/autorun/sh_taunts.lua:
hook.Add('Think', 'taunts_start', function()
hook.Remove('Think', 'taunts_start')
if SERVER then
	hook.Add('PlayerShouldTaunt', 'default_taunts', function(ply, actid)
    	return true
	end)
end

if CLIENT then
	local anims = {
		['Жесты'] = {
			['agree'] = { 
				name ='Одобряю',
				icon = 'icon72/thumbsup.png', 
			},
			['disagree'] = { 
				name ='Не одобряю',
				icon = 'icon72/thumbsdown.png', 
			},
			['wave'] = { 
				name ='Помахать рукой',
				icon = 'icon72/wave.png', 
			},
			['bow'] = { 
				name ='Покланиться',
				icon = 'icon72/person_bowing.png', 
			},
		},
		['Эмоции'] = {
			['cheer'] = { 
				name = 'Восхищаться', 
				icon = 'icon72/astonished.png'
			},
			['zombie'] = { 
				name = 'Напугать', 
				icon = 'icon72/scream.png'
			},
			['laugh'] = { 
				name = 'Смеяться', 
				icon = 'icon72/joy.png'
			},
		},
		['Тактическое'] = {
			['becon'] =  { 
				name = 'За мной', 
				icon = 'icon72/not_renamed/1f90c.png'
			},
			['forward'] = { 
				name = 'Вперед!', 
				icon = 'icon72/point_up.png'
			},
			['group'] = { 
				name = 'Сгрупироваться', 
				icon = 'icon72/vulcan.png'
			},
			['halt'] = { 
				name = 'Стоять здесь', 
				icon = 'icon72/hand_splayed.png'
			},
			['salute'] = { 
				name = 'Отдать честь', 
				icon = 'icon72/not_renamed/1fae1.png'
			},
		},
		['Танцы'] = {
			['dance'] = { 
				name = 'Танцевать', 
				icon = 'icon72/man_dancing.png'
			},
			['muscle'] = { 
				name = 'Позировать', 
				icon = 'icon72/person_tipping_hand.png'
			},
			['pers'] = { 
				name = 'Встать на ногу', 
				icon = 'icon72/person_kneeling.png'
			},
			['robot'] = { 
				name = 'Робот', 
				icon = 'icon72/robot.png'
			},
		},
	}

	local categoryicons = {
		['Жесты'] = 'icon72/thumbsup.png',
		['Эмоции'] = 'icon72/astonished.png',
		['Тактическое'] = 'icon72/shield.png',
		['Танцы'] = 'icon72/man_dancing.png',
	}

	concommand.Add('_DarkRP_AnimationMenu', function()
		if not RadialMenu then return end
		local menu = RadialMenu()

		for cat, v in pairs(anims) do
			menu:AddOption(cat, function()
				local newMenu = RadialMenu()
				for act, v in pairs(v) do
					local opt = newMenu:AddOption(v.name, function()
						RunConsoleCommand('act', act)
					end)

					if v.icon ~= nil then opt:SetIcon(v.icon) end
				end
				newMenu:Open()

				return true
			end):SetIcon(categoryicons[cat])
		end

		menu:Open()
	end)
end

end)

--addons/module_siting/lua/simp_sit/core/cl_core.lua:
hook.Add("PlayerButtonDown", "SIMPSit:KeyPress", function(ply, button)
	if (not game.SinglePlayer()) and (not IsFirstTimePredicted()) then return end
	-- They're already in some kind of vehicle.
	if IsValid(LocalPlayer():GetVehicle()) then return end
	-- Check the button they're pressing is atleast 1 of the buttons we're looking for
	if not table.HasValue(SIMPSit.Config.ButtonsToSit, button) then return end

	-- Confirm they're pressing all the buttons we're looking for
	-- Because this is client side we could in theory allow it to be user configured? Maybe something for future me to do.
	for k, v in ipairs(SIMPSit.Config.ButtonsToSit) do
		if not input.IsButtonDown(v) then return end

		if SIMPSit.Config.Debug then
			print("[SIMPSIT]", v, "is currently pressed")
		end
	end

	-- Tell the server we want to sit
	RunConsoleCommand("sit")
end)


hook.Add("CalcMainActivity", "SitOnGround", function(ply, vel)
	if not ply:GetNetVar("SitOnGround") then return end
	local seq = ply:LookupSequence("pose_ducking_02")
	
	return ACT_MP_SWIM, seq
end)
--addons/module_siting/lua/simp_sit/config/sh_config.lua:
-- Enable debug info.
-- This includes a bunch of trace lines when 'developer 1' is enabled, some prints for both server and client, and the seat not getting set invisible.
SIMPSit.Config.Debug = false

-- The max distance someone can be from the point they want to sit
SIMPSit.Config.MaxDistance = 10000

-- The max pitch (slant) angle you can sit on.
SIMPSit.Config.MaxPitch = 10

-- The buffer around the position to build the circle to calculate the facing angle
SIMPSit.Config.CircleBuffer = 15

-- How far away from the ideal leave location before it becomes invalid
SIMPSit.Config.MaxIdealLeaveDistance = 50000

-- The keys that need to be pressed in order to trigger a sit attempt: https://wiki.facepunch.com/gmod/Enums/KEY
SIMPSit.Config.ButtonsToSit = {
	KEY_LSHIFT,
	KEY_E
}
--addons/_smallscripts/lua/smallscripts/death/shared.lua:
waydeath = waydeath or {}

nw.Register('DeathRagdoll')
    :Write(net.WriteEntity)
    :Read(net.ReadEntity)
    :SetPlayer()

nw.Register('RespawningPlayer')
    :Write(net.WriteEntity)
    :Read(net.ReadEntity)
    :SetPlayer()

nw.Register('RagdollInfo')
    :Write(function(d)
        net.WriteEntity(d.owner or NULL)
        net.WriteEntity(d.killer or NULL)
        net.WriteUInt(d.time or CurTime(), 17)
        net.WriteBool(d.respawnable)
    end)
    :Read(function(d)
        return {
            owner = net.ReadEntity(),
            killer = net.ReadEntity(),
            time = net.ReadUInt(17),
            respawnable = net.ReadBool(),
        }
    end)

RAGDOLL_RESPAWN = 0
RAGDOLL_GRAB = 1
RAGDOLL_SEARCH = 2
RAGDOLL_GETKILLER = 3
RAGDOLL_EAT = 4

waydeath.actions = {
    [RAGDOLL_RESPAWN] = {
        name = 'Возродить',
        icon = 'icon72/heartbeat.png',
        check = function(self, ply, dead, ragdoll, info)
            if not IsValid(ragdoll) then return false end
            if not info.respawnable or
                not IsValid(dead) or
                dead:Alive() or
                (IsValid(dead:GetNetVar('RespawningPlayer')) and dead:GetNetVar('RespawningPlayer') ~= ply) or
                ragdoll:GetModel() == 'models/player/skeleton.mdl' then return false end

            if SERVER then
                if dead:GetNetVar('DeathRagdoll') ~= ragdoll or dead.DeathTeam ~= dead:Team() then
                    ply:Notify(1, 5, 'Ему уже нельзя помочь')
                    return false
                end
            end

            if not ply:getJobTable().medic then
                local inv = CLIENT and itemstore.containers.Get(ply.InventoryID) or ply.Inventory
                if not inv:HasItem('item_healthkit') then return false end
            end

            return true
        end,
    },
    [RAGDOLL_GRAB] = {
        name = 'Поднять',
        icon = 'icon72/not_renamed/1faf4.png',
        check = function(self, ply, dead, ragdoll, info)
            if not IsValid(ragdoll) then return false end
            if SERVER and ragdoll:IsPlayerHolding() then return false end

            if IsValid(dead) and
                dead:GetNetVar('DeathRagdoll') == ragdoll and
                IsValid(dead:GetNetVar('RespawningPlayer')) then return false end

            return true
        end,
    },
    [RAGDOLL_SEARCH] = {
        name = 'Обыскать',
        icon = 'icon72/mag.png',
        check = function(self, ply, dead, ragdoll, info)
            if not IsValid(ragdoll) then return false end
            if ply:isCP() or ragdoll:GetModel() == 'models/player/skeleton.mdl' then return false end
            if IsValid(dead) and
                dead:GetNetVar('DeathRagdoll') == ragdoll and
                IsValid(dead:GetNetVar('RespawningPlayer')) then return false end

            return true
        end,
    },
    [RAGDOLL_GETKILLER] = {
        name = 'Найти убийцу',
        icon = 'icon72/mag.png',
        check = function(self, ply, dead, ragdoll, info)
            if not IsValid(ragdoll) then return false end
            if ply:Team() ~= TEAM_DETECTIVE or
                ragdoll:GetModel() == 'models/player/skeleton.mdl' then return false end

            return true
        end,
    },
    [RAGDOLL_EAT] = {
        name = 'Съесть',
        icon = 'icon72/fork_and_knife.png',
        check = function(self, ply, dead, ragdoll, info)
            if not IsValid(ragdoll) then return false end
            if ply:Team() ~= TEAM_MANUAK or
                ragdoll:GetModel() == 'models/player/skeleton.mdl' then return false end

            return true
        end,
    },
}
--addons/_smallscripts/lua/smallscripts/_client/cl_thirdperson.lua:
wlib.thirdperson = {}

local enabled = CreateClientConVar('wrp_thirdperson', '0')
waySettings.registerVar('wrp_thirdperson', 'Включить 3-е лицо', '3-е лицо', 'bool'):SetConVar('wrp_thirdperson', TYPE_BOOL)
local freecam_enabled = CreateClientConVar('wrp_thirdperson_enable_freecam', '1')
waySettings.registerVar('wrp_thirdperson_enable_freecam', 'Включить свободный обзор на Alt', '3-е лицо', 'bool'):SetConVar('wrp_thirdperson_enable_freecam', TYPE_BOOL)

local x = CreateClientConVar('wrp_thirdperson_x', '0')
local y = CreateClientConVar('wrp_thirdperson_y', '120')
local z = CreateClientConVar('wrp_thirdperson_z', '15')

function wlib.thirdperson.isEnabled()
	return enabled:GetBool()
end

function wlib.thirdperson.toggle(state)
	enabled:SetBool(state == nil and not enabled:GetBool() or state)
end

local xmin, xmax = -40, 40
local ymin, ymax = 40, 120
local zmin, zmax = -15, 15

waySettings.registerVar('wrp_thirdperson_x', 'Положение камеры (влево-вправо)', '3-е лицо', 'numslider', nil, xmin, xmax, 0):SetConVar('wrp_thirdperson_x', TYPE_NUMBER)
waySettings.registerVar('wrp_thirdperson_y', 'Положение камеры (вперед-назад)', '3-е лицо', 'numslider', nil, ymin, ymax, 0):SetConVar('wrp_thirdperson_y', TYPE_NUMBER)
waySettings.registerVar('wrp_thirdperson_z', 'Положение камеры (вверх-вниз)', '3-е лицо', 'numslider', nil, zmin, zmax, 0):SetConVar('wrp_thirdperson_z', TYPE_NUMBER)

local fov = 90
local dist = 0

local disabled_weps = {
	['gmod_camera'] = true,
	['gmod_tool'] = true,
	['weapon_physgun'] = true,
	['weapon_physcannon'] = true,
	['stungun'] = true,
	['ls_sniper'] = true,
	-- ['laserjetpack'] = true,
}

function wlib.thirdperson.AllowThirdperson()
	local ply = LocalPlayer()
	if not ply:Alive() then return false end

	if not wlib.thirdperson.isEnabled() then return false end

	if IsValid(ply:GetViewEntity()) and ply:GetViewEntity():GetClass() == 'gmod_cameraprop' then return false end
	if IsValid(ply:GetActiveWeapon()) and disabled_weps[ply:GetActiveWeapon():GetClass()] then return false end

	if ply:InVehicle() then return false end
	if IsValid(ply:GetNWEntity('ScriptedVehicle')) then return false end
	if ply:GetObserverMode() ~= OBS_MODE_NONE then return false end

	local wep = ply:GetActiveWeapon()
	local issafe = IsValid(wep) and wep.Base == 'swb_base' and wep.FireMode == 'safe'
	if ply:IsHoldingGun() and not issafe then return false end
	if ply:InPVP() then return false end

	if FSpectate and FSpectate.isSpectating then return false end

	if ply:IsPlayingTaunt() then return false end

	return true
end

local view = {}
local freecam_ang
local lastAim = nil
local htfilter = function(ent)
	return !(ent:GetParent() == LocalPlayer() or ent:IsPlayer())
end

function wlib.thirdperson.CalcView(pl, pos, angles)
	local tp = hook.Call('AllowThirdperson', wlib.thirdperson)
	if ((tp or dist > 0) and pl.camera_ang) then
		if (tp) then
			dist = math.min(dist + (1 - dist) * FrameTime() * 9, 1)
			if (dist > .99) then dist = 1 end
		else
			dist = math.max(dist - dist * FrameTime() * 9, 0)
			if (dist < .01) then dist = 0 end
		end

		local freecam = pl:KeyDown(IN_WALK) and freecam_enabled:GetBool()
		if (freecam_ang and not freecam) then
			pl.camera_ang = Angle(freecam_ang.p, freecam_ang.y, freecam_ang.r)
			freecam_ang = nil
		elseif (!freecam_ang and freecam) then
			freecam_ang = Angle(pl.camera_ang.p, pl.camera_ang.y, pl.camera_ang.r)
		end

		pos = pos + (pl.camera_ang:Forward() * dist * (-math.Clamp(y:GetInt(), ymin, ymax))) + (pl.camera_ang:Right() * dist * (math.Clamp(x:GetInt(), xmin, xmax))) + (pl.camera_ang:Up() * dist * (math.Clamp(z:GetInt(), zmin, zmax)))

		local hulltr = util.TraceHull({
			start = pl:GetShootPos(),
			endpos = pos,
			filter = htfilter,
			mask = MASK_SHOT_HULL,
			mins = Vector(-8, -8, -8),
			maxs = Vector(8, 8, 8)
		})

		if (hulltr.Hit) then
			pos = hulltr.HitPos + (pl:GetShootPos() - hulltr.HitPos):GetNormal() * 10
		end

		local aimtr = util.TraceLine({
			start = pl:EyePos(),--pos + (pl.camera_ang:Forward() * (-z:GetInt() + 45)),
			endpos = pos + (pl.camera_ang:Forward() * 100000),
			filter = htfilter
		})

		view.origin = pos
		view.fov = fov
		view.angles = pl.camera_ang
		view.drawviewer = true

		if (tp and pl:GetMoveType() == MOVETYPE_NOCLIP) then
			pl:SetEyeAngles(freecam_ang or pl.camera_ang)
		elseif (tp and not freecam) then
			local newAng = (aimtr.HitPos - pl:EyePos()):Angle()
			sp = aimtr.HitPos
			pl:SetEyeAngles(newAng)
		end

		return view
	else
		if (view and view.drawviewer) then
			view.drawviewer = false
			return view
		end
	end
end

hook.Add('CalcView', 'wrp_thirdperson', wlib.thirdperson.CalcView)

function wlib.thirdperson.CreateMove(cmd)
	local pl = LocalPlayer()

	if hook.Call('AllowThirdperson', wlib.thirdperson) and pl.camera_ang and pl:GetMoveType() != MOVETYPE_NOCLIP then
		local realAng = freecam_ang or pl.camera_ang
		local plAng = pl:GetAimVector():Angle()

		local curVec = Vector(cmd:GetForwardMove(), cmd:GetSideMove(), cmd:GetUpMove())
		curVec:Rotate(plAng - realAng)

		cmd:SetForwardMove(curVec.x)
		cmd:SetSideMove(curVec.y)
		cmd:SetUpMove(curVec.z)
	end
end

hook.Add('CreateMove', 'wrp_thirdperson', wlib.thirdperson.CreateMove)

function wlib.thirdperson.InputMouseApply(cmd, x, y, ang)
	local pl = LocalPlayer()

	if hook.Call('AllowThirdperson', wlib.thirdperson) then
		if (!pl.camera_ang) then
			pl.camera_ang = pl:EyeAngles()
		end

		pl.camera_ang.p = math.Clamp(math.NormalizeAngle(pl.camera_ang.p + y / 50), -90, 90)
		pl.camera_ang.y = math.NormalizeAngle(pl.camera_ang.y - x / 50)

		return true
	else
		pl.camera_ang = pl:EyeAngles()
	end
end

hook.Add('InputMouseApply', 'wrp_thirdperson', wlib.thirdperson.InputMouseApply)

hook.Add('ShouldDrawLocalPlayer', 'wrp_thirdperson', function(ply)
    if hook.Call('AllowThirdperson', wlib.thirdperson) then return true end
end)

local bind = CreateClientConVar('wrp_thirdperson_bind', KEY_F2)
waySettings.registerVar('wrp_thirdperson_bind', 'Включить/выключить 3-е лицо', '3-е лицо', 'binder'):SetConVar('wrp_thirdperson_bind', TYPE_NUMBER)
hook.Add('PlayerButtonDown', 'wrp_thirdperson', function(pl, key)
	if not IsFirstTimePredicted() then return end

	if key == bind:GetInt() then
		wlib.thirdperson.toggle()
		if wlib.thirdperson.isEnabled() and hook.Call('AllowThirdperson', wlib.thirdperson) == false then
			notification.AddLegacy('3-е лицо не будет работать, пока ты держишь в руках оружие или находишься в ПВП', 1, 3)
		end
	end
end)
--addons/_smallscripts/lua/smallscripts/_client/weaponorder.lua:
local f
function openWeaponOrderMenu(var)
    if IsValid(f) then f:Close() end
    
    local settings = var:GetValue({})

    local slots = {}
    for class, v in pairs(settings) do
        slots[v.slot] = slots[v.slot] or {}
        table.insert(slots[v.slot], {
            class = class,
            slotpos = v.slotpos,
        })
    end
    for slot, _ in pairs(slots) do
        table.sort(slots[slot], function(a, b) return a.slotpos < b.slotpos end)
    end

    f = vgui.Create('DFrame')
    f:SetSize(math.Clamp(ScrW()-100, 500, 800), math.Clamp(ScrH()-100, 400, 600))
    f:MakePopup()
    f:Center()
    f:SetTitle('Порядок оружия')
    
    local left = vgui.Create('DPropertySheet', f)
    left:Dock(LEFT)
    left:SetWide(200)
    
    btns = {}
    for i=1, 6 do
        local pnl = vgui.Create('DListLayout')
        pnl:MakeDroppable('weaponorder_'..i)
        for _, v in ipairs(slots[i-1] or {}) do
            local wep = weapons.Get(v.class)
            if not wep then continue end

            local btn = vgui.Create('DButton')
            btn:SetText(wep.PrintName)
            btn:SetTall(30)
            btn:SetFont('chelog-ib.small')
            btn.weapon = wep
            btn.DoRightClick = function(s)
                settings[s.weapon.ClassName] = nil
                s:Remove()
            end

            pnl:Add(btn)
            btns[wep.ClassName] = btn
        end
        left:AddSheet(i, pnl)
    end

    local right = vgui.Create('DPanel', f)
    right:Dock(FILL)
    right:SetWide(f:GetWide()-left:GetWide())

    local guide = vgui.Create('DLabel', right)
    guide:Dock(TOP)
    guide:DockMargin(4,4,4,0)
    guide:SetText(wlib.string.wrap('Зажми ЛКМ и перемещай оружие в категории чтобы изменить его порядок\nНажми ПКМ по оружию в категории чтобы убрать его\nОружие с настроенным порядком будет отображаться в самом верху списка', guide:GetFont(), right:GetWide()-10))
    guide:SizeToContents()

    local find = vgui.Create('DTextEntry', right)
    find:Dock(TOP)
    find:DockMargin(4,8,4,0)
    find:SetTall(25)
    find:SetPlaceholderText('Поиск')
    find:SetUpdateOnType(true)
    local searchFunc
    find.OnValueChange = function(s, text)
        searchFunc(text)
    end

    local wepsScroll = vgui.Create('DScrollPanel', right)
    wepsScroll:Dock(FILL)
    wepsScroll:DockMargin(0,4,0,0)

    local weps = vgui.Create('DIconLayout', wepsScroll)
    weps:Dock(TOP)

    searchFunc = wlib.func.debounce(function(text)
        weps:Clear()

        local found = wlib.array.filter(weapons.GetList(), function(wep)
            return wep.PrintName and utf8.lower(wep.PrintName):find(utf8.lower(text))
        end)
        
        for i=1, math.min(#found, 25) do
            local wep = found[i]

            local icon = vgui.Create('ContentIcon')
            --icon:SetSize(128, 128)
            icon:SetName(wep.PrintName or wep.ClassName)
            icon:SetMaterial(wep.IconOverride or 'entities/'..wep.ClassName..'.png')
            icon.DoClick = function()
                local tab = left:GetActiveTab()
                local scroll = tab:GetPanel()

                local btn = btns[wep.ClassName]
                if IsValid(btn) then btn:Remove() end

                btn = vgui.Create('DButton')
                btn:SetText(wep.PrintName)
                btn:SetTall(30)
                btn:SetFont('chelog-ib.small')
                btn.weapon = wep
                btn.DoRightClick = function(s)
                    settings[s.weapon.ClassName] = nil
                    s:Remove()
                end

                scroll:Add(btn)
                btns[wep.ClassName] = btn
            end

            weps:Add(icon)
        end
    end, 0.15)

    f.OnClose = function()
        for i, v in ipairs(left:GetItems()) do
            for k, btn in ipairs(v.Panel:GetChildren()) do
                local class = btn.weapon.ClassName
                settings[class] = {
                    slot = i-1,
                    slotpos = k-1
                }
            end
        end

        var:SetValue(settings)
    end
end

waySettings.registerVar('weaponOrder', 'Порядок списка выбора оружия', 'Оружие', 'button', {}, 'Настроить', openWeaponOrderMenu)
--addons/module_wmap/lua/waymap/cl_core.lua:
wmap = wmap or {}
wmap.minimapEnabled = false

wmap.config = {
    ['rp_bangclaw'] = {
        material = Material('wmap/rp_bangclaw.png'),
        scaleX = 1.92, scaleY = 1.91,
        offsetX = 1743, offsetY = 4527,
        nullX = 907.8, nullY = 1406.8,
        width = 6507, height = 3764,
        markers = {
            {
                name = 'Мэрия',
                pos = Vector(1121, 2376, 208),
                icon = 'icon72/office.png',
            },
            {
                name = 'Полицейский участок',
                pos = Vector(4187, -767, 136),
                icon = 'icon72/oncoming_police_car.png',
            },
            {
                name = 'Торговый центр',
                pos = Vector(2546, -544, 144),
                icon = 'icon72/convenience_store.png',
            },
            {
                name = 'База ЧВК',
                pos = Vector(8901, -3062, 204),
                icon = 'icon72/camping.png',
            },
            {
                name = 'Банк',
                pos = Vector(4038, -3788, 72),
                icon = 'icon72/bank.png',
            },
            {
                name = 'Хранилище',
                icon = 'icon72/package.png',
                pos = {
                    Vector(-1271, -597, 107),
                    Vector(3993, -1127, 107),
                    Vector(2167, -1604, 107),
                    Vector(537, -1772, 107),
                    Vector(1227, 2662, 211),
                    Vector(9527, -2519, 115),
                },
            },
            {
                name = 'Боеприпасы',
                icon = 'icon72/firecracker.png',
                pos = {
                    Vector(9470, -2512, 96),
                    Vector(3936, -1054, 88),
                },
            },
            {
                name = 'Скупщик',
                icon = 'icon72/shopping_cart.png',
                pos = Vector(-673, -973, 72),
            },
            {
                name = 'Мусорный ящик',
                icon = 'icon72/recycle.png',
                pos = {
                    Vector(27, 1282, 97),
                    Vector(796, -1563, 97),
                    Vector(4118, -3110, 97),
                    Vector(-1177, -539, 97),
                    --Vector(85, 572, -359),
                    Vector(-235, -2507, 89),
                    Vector(2698, -4134, -207),
                    Vector(4220, -3110, 97),
                    Vector(5541, -1705, 97),
                    Vector(5759, -1254, 97),
                },
            },
        },
    }
}

local cfg = wmap.config[game.GetMap()]

-- -1743 2687
-- 10751 -4527

function wmap.localToWorld(x, y)
    return x * cfg.scaleX - cfg.offsetX, y * cfg.scaleY - cfg.offsetY
end

function wmap.worldToLocal(x, y)
    return (x + cfg.offsetX) / cfg.scaleX, cfg.height - (y + cfg.offsetY) / cfg.scaleY
end

function wmap.getRelativePos(x, y, umin, vmin, w, h)
    local mx, my = umin * cfg.width, vmin * cfg.height

    return x - mx, y - my
end

function wmap.markerShouldThink()
    return wmap.minimapEnabled
end

local function polyRotate(poly, ang)
    if ang == 0 then return poly end

	local deg = math.rad(ang)
	local sin, cos = math.sin(deg), math.cos(deg)

	for _, vert in ipairs(poly) do
		local x, y = vert.x, vert.y

		local xn = x * cos - y * sin
		local yn = x * sin + y * cos

		vert.x, vert.y = xn, yn
	end

	return poly
end

local function polyTranslate(poly, dx, dy)
	for _, vert in ipairs(poly) do
		vert.x, vert.y = vert.x + dx, vert.y + dy
	end
end

hook.Add('Think', 'wmap.createMarkers', function()
    hook.Remove('Think', 'wmap.createMarkers')
    if not cfg then return end
    
    local k = 1
    for _, v in ipairs(cfg.markers) do
        local pos = isvector(v.pos) and {v.pos} or v.pos
        for _, vec in ipairs(pos) do
            wmap.createMarker('map_'..k)
                :SetName(v.name)
                :SetMaterial(v.icon)
                :SetSize(v.size or 16)
                :SetPos(vec)
                :SetOrder(v.order or 0)
            
            k = k + 1
        end
    end

    local lp = LocalPlayer()
    wmap.createMarker('lp')
        :SetName('Ты')
        :SetMaterial('icon72/black_circle.png')
        :SetSize(12)
        :SetEntity(lp)
        :SetOrder(math.huge)
        .Paint = function(self, x, y)
            local p = {
                { x = 0, y = 0 },
                { x = 30, y = -15 },
                { x = 30, y = 15 },
            }
    
            polyRotate(p, -lp:GetAngles().y)
            polyTranslate(p, x, y)

            draw.NoTexture()
            surface.SetDrawColor(0,0,0,50)
            surface.DrawPoly(p)

            wmap.markerMeta.Paint(self, x, y)
        end
end)

hook.Add('Think', 'wmap.markersThink', function()
    for _, m in ipairs(wmap.markers) do
        if not m.Think or hook.Call('markerShouldThink', wmap, m) == false then continue end
        m:Think()
    end
end)

function wmap.drawMap(x, y, origin, zoom, w, h)
    if not cfg then return end

    local centerx, centery = wmap.worldToLocal(origin.x, origin.y)

    local ar = w/h
    local offsetY = cfg.height / zoom / 2
    local offsetX = offsetY * ar

    local umin, umax = (centerx-offsetX) / cfg.width, (centerx+offsetX) / cfg.width
    local vmin, vmax = (centery-offsetY) / cfg.height, (centery+offsetY) / cfg.height

    if umin <= 0 then
        umax = umax - umin
        umin = 0
    elseif umax >= 1 then
        umin = umin - umax + 1
        umax = 1 
    end

    if vmin <= 0 then
        vmax = vmax - vmin
        vmin = 0
    elseif vmax >= 1 then
        vmin = vmin - vmax + 1
        vmax = 1 
    end
    
    render.SetScissorRect(x, y, x + w, y + h, true)

    surface.SetMaterial(cfg.material)
    surface.SetDrawColor(color_white)
    surface.DrawTexturedRectUV(x, y, w, h, umin, vmin, umax, vmax)

    for _, v in ipairs(wmap.markers) do
        local markerx, markery = v:GetMapPos()
        local mx, my = markerx - umin*cfg.width, markery - vmin*cfg.height

        if mx < 0 or
            my < 0 or
            mx > offsetX*2 or
            my > offsetY*2
        then continue end
        
        v:Paint(x + mx * (w / (offsetX * 2)), y + my * (h / (offsetY * 2)))
    end

    render.SetScissorRect(0, 0, 0, 0, false)
end

local hudscale = CreateClientConVar('wayhud_scale', 0.75, true)
local bind = CreateClientConVar('waymap_bind', KEY_M, true, false)

hook.Add('PlayerButtonUp', 'wayMap.bind', function(ply, btn)
    if not IsFirstTimePredicted() then return end
    if ply ~= LocalPlayer() then return end
    if ply:IsTyping() then return end

    if btn == bind:GetInt() then
        wmap.minimapEnabled = not wmap.minimapEnabled

        g_VoicePanelList:SetTall(ScrH() - (wmap.minimapEnabled and 455*hudscale:GetFloat() or 200))
    end
end)

local dmid = 1
hook.Add('dMarkers.created', 'wmap.marker', function(id, d)
    local marker = wmap.createMarker('dMarkers_'..dmid)
    marker:SetName(d.title)
    marker:SetMaterial(d.icon)
    marker:SetSize(16)
    marker:SetPos(d.pos)
    marker:SetStatic(true)
    marker:SetEntity(d.target)

    dMarkers.markers[id].wmapMarker = marker

    dmid = dmid + 1
end)

hook.Add('dMarkers.removed', 'wmap.removeMarker', function(id)
    local marker = dMarkers.markers[id]
    if not marker.wmapMarker then return end
    marker.wmapMarker:Remove()
end)
--addons/module_battlepass/lua/waypass/objects/challenge.lua:
waypass.challenges = waypass.challenges or {}
waypass.challenges.list = waypass.challenges.list or {}

local CHALLENGE = {}
CHALLENGE.__index = CHALLENGE

function waypass.challenges.Create(id, name, desc, icon, progress, goal)
    local challenge = setmetatable({
        name = name,
        desc = desc,
        icon = icon,
        id = id,
        progress = progress or 0,
        goal = goal,
        hooks = {},
        timers = {},
        tracking = false,
    }, CHALLENGE)
    if IsValid(player) then
        challenge.pid = player:SteamID64()
    end

    return challenge
end

wlib.accessor(CHALLENGE, 'name', 'Name')
wlib.accessor(CHALLENGE, 'desc', 'Desc')
wlib.accessor(CHALLENGE, 'icon', 'Icon')
wlib.accessor(CHALLENGE, 'id', 'ID')
wlib.accessor(CHALLENGE, 'uid', 'UID')
wlib.accessor(CHALLENGE, 'bpId', 'BPID')
wlib.accessor(CHALLENGE, 'goal', 'Goal')
wlib.accessor(CHALLENGE, 'progress', 'Progress')
wlib.accessor(CHALLENGE, 'reward', 'Reward')
wlib.accessor(CHALLENGE, 'player', 'Player')
wlib.accessor(CHALLENGE, 'pid', 'PlayerID')
wlib.accessor(CHALLENGE, 'timestamp', 'Timestamp')
wlib.accessor(CHALLENGE, 'Callback', 'Callback')
wlib.accessor(CHALLENGE, 'OnRemove', 'OnRemove')
wlib.accessor(CHALLENGE, 'tracking', 'Tracking')
wlib.accessor(CHALLENGE, 'premium', 'Premium')
wlib.accessor(CHALLENGE, 'endTime', 'EndTime')

function CHALLENGE:SetBP(bp)
    self:SetBPID(bp:GetID())
end

function CHALLENGE:GetBP()
    return waypass.passes.Get(self:GetBPID())
end

function CHALLENGE:IsActive()
    return self:GetEndTime() and self:GetEndTime() > os.time()
end

function CHALLENGE:SetPlayer(ply)
    self.player = ply
    self.pid = ply:SteamID64()

    return self
end

function CHALLENGE:Save(cb)
    local ply = self:GetPlayer()

    timer.Create('waypass_debounce_savechallenge'..self:GetUID()..'_'..self:GetPlayerID(), .3, 1, function()
        if not IsValid(ply) then return waypass.db:SaveChallenge(util.SteamIDFrom64(self:GetPlayerID()), self:GetBP():GetID(), self:GetUID(), self:GetProgress(), cb) end

        waypass.ChallengeNotify(ply, self:GetBPID(), self:GetUID(), self:GetProgress())
        waypass.db:SaveChallenge(ply:SteamID(), self:GetBP():GetID(), self:GetUID(), self:GetProgress(), cb)
        waypass.UpdatePlayerChallenge(ply, self)
    end)
end

function CHALLENGE:IsCompleted()
    return self:GetProgress() >= self:GetGoal()
end

function CHALLENGE:AddProgress(amount, notSave, cb)
    if not self:IsActive() then return end
    
    local cur = self:GetProgress()

    self:SetProgress(math.Clamp(cur+amount, 0, self:GetGoal()))

    if self:GetProgress() >= self:GetGoal() and self.Callback then
        self:Callback()
        self:StopTracking()
    end

    if not notSave then
        self:Save(cb)
    end
end

function CHALLENGE:AddHook(name, callback)
    self.hooks[name] = callback
    
    if self:GetTracking() then
        self:StartTracking()
    end

    return self
end

function CHALLENGE:AddTimer(name, delay, repetitions, callback)
    table.insert(self.timers, {
        name = name,
        delay = delay,
        repetitions = repetitions,
        callback = callback,
    })
    
    if self:GetTracking() then
        self:StartTracking()
    end

    return self
end

function CHALLENGE:StartTracking()
    local ply = self:GetPlayer()
    if not self:IsActive() then return end
    for name, cb in pairs(self.hooks) do
        hook.Add(name, 'waypass_'..self:GetUID()..'_'..self:GetPlayerID(), function(...)
            if not IsValid(ply) then return self:Remove() end
            if not self:IsActive() then return self:Remove() end
            if self:GetUID() ~= ply:GetBPFirstChallenge(self:GetBP():GetID(), self:GetID()):GetUID() then return end
            cb(self, ply, ...)
        end)
    end
    for id, d in ipairs(self.timers) do
        timer.Create('waypass_'..(d.name or id)..'_'..self:GetUID()..'_'..self:GetPlayerID(), d.delay, d.repetitions, function(...)
            if not IsValid(ply) then return self:Remove() end
            if not self:IsActive() then return self:Remove() end
            if self:GetUID() ~= ply:GetBPFirstChallenge(self:GetBP():GetID(), self:GetID()):GetUID() then return end
            d.callback(self, ply, ...)
        end)
    end

    self:SetTracking(true)
end

function CHALLENGE:StopTracking()
    for name, _ in pairs(self.hooks) do
        hook.Remove(name, 'waypass_'..self:GetUID()..'_'..self:GetPlayerID())
    end
    for id, d in ipairs(self.timers) do
        timer.Remove('waypass_'..(d.name or id)..'_'..self:GetUID()..'_'..self:GetPlayerID())
    end

    self:SetTracking(false)
end

function CHALLENGE:Remove(...)
    self:StopTracking()

    if self.OnRemove then
        self:OnRemove(...)
    end
end

function CHALLENGE:Register()
    waypass.challenges.Register(self)
end

function waypass.challenges.Register(challenge)
    waypass.challenges.list[challenge:GetID()] = challenge
end

function waypass.challenges.CreateFromID(id)
    if not waypass.challenges.list[id] then return end
    return table.Copy(waypass.challenges.list[id])
end

function waypass.challenges.GetActive(ply)
    return ply:GetNetVar('waypass.challenges') or {}
end
--addons/module_battlepass/lua/waypass/challenges/bankrobbery.lua:
waypass.challenges.Create('bankrobbery')
    :SetName('PAYDAY')
    :SetDesc('Прими участие в ограблении банка {goal} раз (отнеси как минимум одну сумку)')
    :AddHook('OnPlayerRobberyBank', function(self, owner, ply, reward)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/hit.lua:
waypass.challenges.Create('hit')
    :SetName('Агент 47')
    :SetDesc('Заверши заказ на убийство {goal} раз')
    :AddHook('CompleteHit', function(self, owner, hitman, dead)
        if hitman ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/manuak.lua:
waypass.challenges.Create('manuak')
    :SetName('Каннибал')
    :SetDesc('Скушай трупы {goal} раз')
    :AddHook('RagdollEat', function(self, ply, owner, tryp)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/nalog.lua:
waypass.challenges.Create('nalog')
    :SetName('Народный любимчик')
    :SetDesc('Собери налоги {goal} раз')
    :AddHook('BPNalog', function(self, ply, owner, criminal)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/online.lua:
waypass.challenges.Create('online')
    :SetName('Ноулайф')
    :SetDesc('Проведи в игре {goal} минут')
    :AddTimer('online', 60, 0, function(self, ply)
        self:AddProgress(1)
    end)
:Register()

waypass.challenges.Create('online_session')
    :SetName('Марафон')
    :SetDesc('Проведи в игре {goal} минут за раз')
    :AddTimer('online', 60, 0, function(self, ply)
        self:AddProgress(1)
    end)
    :SetOnRemove(function(self)
        if not self:IsCompleted() then
            self:SetProgress(0)
            self:Save()
        end
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/salary.lua:
waypass.challenges.Create('salary')
    :SetName('C получкой!')
    :SetDesc('Получи зарплату {goal} раз')
    :AddHook('playerGetSalary', function(self, owner, ply, amount)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/taser.lua:
waypass.challenges.Create('taser')
    :SetName('Зоркий глаз')
    :SetDesc('Попади тайзером по игроку {goal} раз')
    :AddHook('PlayerTazed', function(self, owner, ent, police)
        if police ~= owner then return end
        if not ent:IsPlayer() then return end

        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/rewards/darkrp_money.lua:
local REWARD = {}
REWARD.Name = 'Деньги'
REWARD.Material = 'data/wimages/moneybox.png'
http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/moneybox.png', 'moneybox.png')

AccessorFunc(REWARD, 'Name', 'Name')
AccessorFunc(REWARD, 'Material', 'Material')

function REWARD:Give(ply, amount)
    ply:addMoney(amount)
end

function REWARD:GetCount(amount)
    return DarkRP.formatMoney(amount)
end

function REWARD:Preview(amount, mpanel)
    if IsValid(mpanel.previewpanel) then mpanel.previewpanel:Remove() end
    
    mpanel:SetShouldDrawModels(false)
    local mat = Material(self:GetMaterial(amount))

    local scaleW, scaleH = ScrW()/1920, ScrH()/1080
    local pos = mpanel:GetCamPos()+Vector(-6*scaleW, -15*scaleW, 3.5*scaleH)
    
    mpanel.PreDrawModel = function(ent)
        --cam.Start3D2D(Vector(23*scale,15*scale,43+math.sin(CurTime())/2), Angle(180,-80,-90), .01)
        --cam.Start3D2D(Vector(24*scale,15*scale,43+math.sin(CurTime())/2), Angle(180,-70,-90), .01)
        cam.Start3D2D(Vector(pos.x, pos.y, pos.z+math.sin(CurTime())/3), Angle(180,-70,-90), 0.01)
            surface.SetDrawColor(color_white)
            surface.SetMaterial(mat)
            surface.DrawTexturedRect(0,0,550,530)
        cam.End3D2D()

        return false
    end
end

function REWARD:UnPreview(amount, mpanel)
    mpanel:SetShouldDrawModels(true)
    mpanel.PreDrawModel = wlib.func.blank
end

waypass.RegisterReward('darkrp_money', REWARD)
--addons/module_battlepass/lua/waypass/rewards/pointshop_item.lua:
local REWARD = {}

function REWARD:Give(ply, id)
    ply:PS_AddToInventory(id)
end

function REWARD:GetName(id)
    return PS.Items[id].Name
end

local mat_error = Material('error')
function REWARD:GetMaterial(id)
    if PS.Items[id].Material then return PS.Items[id].Material end
    return mat_error
end

function REWARD:Preview(id, mpanel)
    if IsValid(mpanel.previewpanel) then mpanel.previewpanel:Remove() end

    local item = PS.Items[id]
    PS:SetHoverItem(id)
    
    if item.PanelPreview then
        mpanel:SetShouldDrawModels(false)
        mpanel.PreDrawModel = wlib.func.no

        mpanel.previewpanel = item:PanelPreview()
        mpanel.previewpanel:SetParent(mpanel)
        mpanel.previewpanel:Center()
    elseif item.NoPreview then
        mpanel:SetShouldDrawModels(false)
        local mat = self:GetMaterial(id)

        local scaleW, scaleH = ScrW()/1920, ScrH()/1080
        local pos = mpanel:GetCamPos()+Vector(-6*scaleW, -15*scaleW, 3.5*scaleH)

        mpanel.PreDrawModel = function(ent)
            --cam.Start3D2D(Vector(23*scale,15*scale,43+math.sin(CurTime())/2), Angle(180,-80,-90), .01)
            --cam.Start3D2D(Vector(24*scale,15*scale,43+math.sin(CurTime())/2), Angle(180,-70,-90), .01)
            cam.Start3D2D(Vector(pos.x, pos.y, pos.z+math.sin(CurTime())/3), Angle(180,-70,-90), 0.01)
                surface.SetDrawColor(color_white)
                surface.SetMaterial(mat)
                surface.DrawTexturedRect(0,0,550,530)
            cam.End3D2D()

            return false
        end
    else
        mpanel:SetShouldDrawModels(true)
        mpanel.PreDrawModel = wlib.func.blank
    end
end

function REWARD:UnPreview(id, mpanel)
    PS:RemoveHoverItem()
    mpanel:SetShouldDrawModels(true)
    mpanel.PreDrawModel = wlib.func.blank
    if IsValid(mpanel.previewpanel) then mpanel.previewpanel:Remove() end
end

waypass.RegisterReward('pointshop_item', REWARD)
--addons/module_battlepass/lua/waypass/rewards/weapon.lua:
local REWARD = {}

function REWARD:Give(ply, class)
    ply:Give(class)
end

function REWARD:GetName(class)
    return weapons.Get(class) and weapons.Get(class)['PrintName'] or class
end

function REWARD:GetMaterial(class)
    return weapons.Get(class)['IconOverride'] or 'entities/'..class..'.png'
end

function REWARD:CanClaim(ply, amount)
    return not ply:HasWeapon(amount), 'У тебя уже есть это оружие'
end

waypass.RegisterReward('weapon', REWARD)
--addons/module_battlepass/lua/waypass/vgui/btn.lua:
local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self.text = 'Label'
    self.font = 'dorgs.18'
    self.outlineColor = waypass.skin.COLOR_OUTLINE
    self.color = waypass.skin.COLOR_PRIMARY
end

function PANEL:Paint(w,h)
    draw.RoundedBox(4, 0, 0, w, h, self.outlineColor)
    draw.RoundedBox(4, 2, 2, w-4, h-4, self.color)

    local offset = 0
    if self.icon then
        local size = h-8
        surface.SetMaterial(self.icon)
        surface.SetDrawColor(color_white)
        surface.DrawTexturedRect(6, h/2-size/2, size, size)
        offset = offset+size
    end

    draw.SimpleText(self:GetButtonText(), self.font, offset+(w-offset)/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

AccessorFunc(PANEL, 'text', 'ButtonText')
AccessorFunc(PANEL, 'font', 'Font')
AccessorFunc(PANEL, 'outlineColor', 'OutlineColor')
AccessorFunc(PANEL, 'color', 'Color')

function PANEL:SetIcon(m)
    self.icon = isstring(m) and Material(m) or m
end

function PANEL:SizeToContents()
    surface.SetFont(self:GetFont())
    local tw, th = surface.GetTextSize(self:GetButtonText())

    self:SetTall(math.max(self:GetTall(), th+4))
    self:SetWide((self.icon and 6+self:GetTall() or 0) + 6 + tw + 6)
end

vgui.Register('waypass_button', PANEL, 'DButton')
--addons/module_battlepass/lua/waypass/vgui/buylevels.lua:
local blframe
function waypass.OpenBuyLevelsMenu(bpId)
    if IsValid(blframe) then blframe:Remove() end

    local bal = LocalPlayer():PS_GetPoints()

    blframe = vgui.Create('DFrame')
    blframe:SetSize(300, 400)
    blframe:Center()
    blframe:MakePopup()
    blframe:SetBackgroundBlur(true)
    blframe:SetTitle('Баланс: '..bal..'₽')
    blframe:SetDraggable(false)

    local scroll = vgui.Create('DScrollPanel', blframe)
    scroll:Dock(TOP)
    scroll.Paint = function(_,w,h)
        draw.RoundedBox(0,0,0,w,h,waypass.skin.COLOR_SECONDARY)
    end
    --scroll:SetTall(40*table.Count(waypass.donateLevels))

    for count, price in pairs(waypass.donateLevels) do
        local p = vgui.Create('DPanel', scroll)
        p:SetTall(40)
        p:Dock(TOP)
        local text = ('+%s (%s₽)'):format(waypass.FormatPlural({'уровень', 'уровня', 'уровней'}, count), price)
        p.Paint = function(_,w,h)
            surface.SetDrawColor(waypass.skin.COLOR_OUTLINE)
            surface.DrawLine(0, 0, w, 0)
            surface.DrawLine(0, h-1, w, h-1)

            draw.SimpleText(text, 'dorgs.24', 6, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        local buy = vgui.Create('waypass_button', p)
        buy:Dock(RIGHT)
        buy:DockMargin(0,5,6,5)
        buy:SetWide(60)
        if bal >= price then
            buy:SetButtonText('Купить')
            buy.DoClick = function()
                waypass.BuyLevels(bpId, count)
                blframe:Close()
            end
        else
            buy:SetButtonText('Недоступно')
        end
    end

    scroll:GetCanvas():InvalidateLayout(true)
    scroll:GetCanvas():SizeToChildren(false, true)
    scroll:SizeToChildren(false, true)

    blframe:InvalidateLayout(true)
    blframe:SizeToChildren(false, true)
    blframe:Center()
end
--addons/module_battlepass/lua/waypass/cl_core.lua:
function waypass.ClaimRewards(id, lvl, premium)
    if not id then return end
    
    net.Start('waypass.ClaimRewards')
    net.WriteString(id)
    net.WriteUInt(lvl, 12)
    net.WriteBool(premium)
    net.SendToServer()
end

function waypass.BuyLevels(bpId, count)
    net.Start('waypass.BuyLevels')
    net.WriteString(bpId)
    net.WriteUInt(count, 12)
    net.SendToServer()
end

function waypass.BuyBP(bpId)
    net.Start('waypass.BuyBP')
    net.WriteString(bpId)
    net.SendToServer()
end
--MediaLib_DynFile_mp4.lua:
local a=medialib.load("oop")local b=a.class("Mp4Service","HTMLService")b.identifier="mp4"local c={"^https?://.*%.mp4"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h="https://wyozi.github.io/gmod-medialib/mp4.html?id=%s"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;function b:directQuery(d,i)i(nil,{title=d:match("([^/]+)$")})end;function b:hasReliablePlaybackEvents()return true end;return b
--MediaLib_DynFile_webaudio.lua:
local a=medialib.load("oop")local b=a.class("WebAudioService","BASSService")b.identifier="webaudio"local c={"^https?://(.*)%.mp3","^https?://(.*)%.ogg"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;function b:resolveUrl(d,h)h(d,{})end;function b:directQuery(d,h)h(nil,{title=d:match("([^/]+)$")})end;return b
--addons/module_scoreboard/lua/autorun/wayscore_init.lua:
wayscore = wayscore or {}

if SERVER then
    for _, v in ipairs(file.Find('wayscore/vgui/*', 'LUA') or {}) do
        AddCSLuaFile('wayscore/vgui/'..v)
    end

    AddCSLuaFile('wayscore/core.lua')
    AddCSLuaFile('wayscore/util.lua')
else
    include('wayscore/core.lua')
    include('wayscore/util.lua')
    
    for _, v in ipairs(file.Find('wayscore/vgui/*', 'LUA') or {}) do
        include('wayscore/vgui/'..v)
    end

    surface.CreateFont("wayscore", {
        font = "Roboto Bold",
        size = 48,
        weight = 500,
        extended = true,
    })
    
    surface.CreateFont("wayscore-shadow", {
        font = "Roboto Bold",
        size = 48,
        weight = 500,
        extended = true,
        blursize = 7,
    })
    
    surface.CreateFont("wayscore.small", {
        font = "Roboto",
        size = 22,
        weight = 500,
        extended = true,
    })
end
--addons/module_skins/lua/weaponskins/shared.lua:
weaponSkins.config = {
    blacklist = {
        ['weapon_vape_hallucinogenic'] = true,
        ['weapon_vape_medicinal'] = true,
        ['weapon_vape_cigarette'] = true,
        ['weapon_vape_wayzer'] = true,
        ['weapon_vape_armor'] = true,
        ['weapon_vape_juicy'] = true,
        ['weapon_vape_hp'] = true,
        ['weapon_vape'] = true,
        ['guitar'] = true,
        ['laserjetpack'] = true,
        ['unarrest_stick'] = true,
        ['stunstick'] = true,
        ['arrest_stick'] = true,
        ['door_ram'] = true,
        ['weapon_svechenik'] = true,
        ['weapon_cuff_police'] = true,
        ['krede_wd_phone'] = true,
        ['weapon_cuff_rope'] = true,
        ['swat_shield'] = true,
        ['ultimate_disguise_kit'] = true,
        ['rchainsaw'] = true,
        ['vacban'] = true,
        ['lockpick'] = true,
        ['stungun'] = true,
        ['weapon_army'] = true,
        ['itemstore_checker'] = true,
        ['weapon_nalog'] = true,
        ['spidermans_swep'] = true,
        ['sent_messure'] = true,
        ['sent_tablet'] = true,
        ['wrp_weapon_outbreak'] = true,
        ['wrp_weapon_khvostov'] = true,
    },
    skins = {
        ['models/props/CS_militia/roofbeams01'] = 5000000, -- деревяшка
        ['models/props_c17/paper01'] = 10000000, -- газета
        ['models/props_animated_breakable/smokestack/brickwall002a'] = 15000000, -- кирпич
        ['phoenix_storms/checkers_map'] = 20000000, -- шахматы
        ['models/player/player_chrome1'] = 25000000, -- чернобелый снимок какой то
        ['models/props_lab/xencrystal_sheet'] = 30000000, -- стеклянный и золотой скин
        ['phoenix_storms/smallwheel'] = 35000000, -- красное месиво
        ['hunter/myplastic'] = 39000000, -- пропы
        ['models/props_interiors/metalfence007a'] = 40000000, -- металическая сеточка
        ['phoenix_storms/stripes'] = 45000000, -- полицейская лента/гидравлический пресс
        ['models/wireframe'] = 48650000, -- белые линии
        ['phoenix_storms/white_fps'] = 50000000, -- facepunch
        ['phoenix_storms/t_light'] = 54500000, -- светофор
        ['models/items/boxsniperrounds'] = 55000000, -- хакермен
        ['models/items/cs_gift'] = 57000000, -- подарок кс
        ['models/flesh'] = 60000000, -- кровь
        ['phoenix_storms/wire/pcb_blue'] = 61000000, -- синий рисунок фигуры
        ['phoenix_storms/wire/pcb_green'] = 62000000, -- зеленый рисунок фигуры
        ['phoenix_storms/wire/pcb_red'] = 63000000, -- красный рисунок
        ['phoenix_storms/blue_steel'] = 65000000, -- фиолетовый человечек из фнаф
        ['models/props/cs_assault/moneytop'] = 70000000, -- бабки
        ['phoenix_storms/cube'] = 75000000, -- жесткий метал
        ['models/cs_italy/light_orange'] = 80000000, -- солнце
        ['phoenix_storms/metalfloor_2-3'] = 90000000, -- металическая штука с круглешками
        ['models/XQM//SquaredMat'] = 100000000, -- зимний скин
        ['phoenix_storms/metalset_1-2'] = 135000000, -- лютый метал
        ['models/XQM/CellShadedCamo_diffuse'] = 150000000, -- армейский скин
        ['models/XQM//LightLinesGB'] = 200000000, -- зимний черный скин
        ['phoenix_storms/top'] = 235000000, -- красная какая то доска или чо бля
        ['models/props_lab/Tank_Glass001'] = 250000000, -- желе с водой orange
        ['models/props_combine/stasisfield_beam'] = 265000000, -- электрическая хуйня течет слева
        ['Models/effects/comball_sphere'] = 270000000, -- лютая энергия хуячит
        ['models/props/cs_office/clouds'] = 300000000, -- облака
        ['models/props_combine/combine_interface_disp'] = 350000000, -- экран
        ['models/alyx/emptool_glow'] = 400000000, -- электричество вспышки
        ['models/props_combine/com_shield001a'] = 435000000, -- плывет чото
        ['models/effects/splode1_sheet'] = 450000000, -- взрыв
        ['models/props_combine/prtl_sky_sheet'] = 500000000, -- космос
        ['patterns/texture1'] = 505000000, -- патерны
        ['patterns/texture2'] = 510000000,
        ['patterns/texture3'] = 515000000,
        ['patterns/texture4'] = 520000000,
        ['patterns/texture5'] = 525000000,
        ['patterns/texture6'] = 530000000,
        ['patterns/texture7'] = 535000000,
        ['patterns/texture8'] = 540000000,
        ['patterns/texture9'] = 545000000,
        ['models/props_lab/warp_sheet'] = 550000000, -- анимированный космос
        ['patterns/texture10'] = 551000000,
        ['patterns/texture11'] = 555000000,
        ['patterns/texture12'] = 560000000,
        ['patterns/texture13'] = 565000000,
        ['patterns/texture14'] = 570000000,
        ['patterns/texture15'] = 575000000,
        ['patterns/texture16'] = 580000000,
        ['patterns/texture17'] = 585000000,
        ['patterns/texture18'] = 590000000,
        ['patterns/texture19'] = 595000000,
        ['patterns/texture20'] = 600000000,
        ['patterns/texture21'] = 605000000,
        ['patterns/texture22'] = 610000000,
        ['patterns/texture23'] = 615000000,
        ['patterns/texture24'] = 620000000,
        ['models/props_lab/security_screens'] = 650000000, -- камеры города
        ['models/props_lab/cornerunit_cloud'] = 750000000, -- переливаются/облака с желтой хуйней
        ['models/XQM//LightLinesRed'] = 950000000, -- черная переливающаяся красной штукой хуйня
        ['models/shadertest/shader3'] = 1500000000, -- вода камуфляжная не видно кста
    },
    submaterials = {
        ['ptp_cs_awp'] = 1,
        ['ptp_cs_g3sg1'] = 1,
        ['ptp_cs_scout'] = 1,
        ['ptp_cs_sg550'] = 1,
        ['ptp_cs_sg552'] = 1,
        ['mp_weapon_smart_pistol'] = 1,
        ['ptp_cs_aug'] = 1,
        ['wrp_weapon_mosin'] = 1,
        ['wrp_weapon_grizzly'] = {2,3},
        ['wrp_weapon_mp7'] = 1,
        ['weapon_hl2katana'] = 1,
        ['wrp_weapon_csg'] = 1,
        ['wrp_weapon_crimson'] = 1,
        ['wrp_weapon_hk21'] = {1,2,3},
        ['wrp_weapon_huckleberry'] = {2,3,4,5,6,7,8,9},
    },
}

nw.Register('weaponSkin')
    :Write(net.WriteString)
    :Read(net.ReadString)
    :SetPlayer()
    :SetHook('weaponSkin.selectedUpdate')

nw.Register('weaponSkin.list')
    :Write(function(d)
        net.WriteUInt(table.Count(d), 8)
        for mat, _ in pairs(d) do
            net.WriteString(mat)
        end
    end)
    :Read(function()
        local res = {}
        for i=1, net.ReadUInt(8) do
            res[net.ReadString()] = true
        end
        return res
    end)
    :SetLocalPlayer()
    :SetHook('weaponSkin.listUpdate')

function weaponSkins.getPrice(mat)
    return weaponSkins.config.skins[mat]
end

function weaponSkins.isBlacklisted(wep)
    return weaponSkins.config.blacklist[wep:GetClass()]
end
--addons/_wlib/lua/wlib/init.lua:
wlib = wlib or {}
wlib.debug = false

function wlib.msg(...)
	MsgC('[WRP] ' .. os.date('%H:%M:%S - ', os.time()), ..., '\n')
end

local color_red = Color(255,0,0)
function wlib.dbg(...)
	if not wlib.debug then return end
	MsgC(color_red, '[WRP] ', color_white, os.date('%H:%M:%S - ', os.time()), ..., '\n')
end

if SERVER then
    AddCSLuaFile('wlib/modules/include.lua')
    include('wlib/modules/include.lua')
else
    include('wlib/modules/include.lua')
end

wlib.include.shared('wlib/modules', {'cfg'})

wlib.include.shared('wlib/libraries')
wlib.include.server('wlib/libraries/_server')
wlib.include.client('wlib/libraries/_client')

wlib.include.modules('wlib/modules', {
	'!include',
	'!_server',
	'!_client',
	'!cfg',
	'oop',
	'settings',
	'*',
})
wlib.include.server('wlib/modules/_server')
wlib.include.client('wlib/modules/_client')

wlib.include.client('wlib/vgui')

hook.Run('wlib.loaded')

-- Важные аддоны для использования функуций без хука Think и прочих костылей
wlib.include.shared('autorun', {
	'wayscore_init',
})
--addons/_cfg/lua/config/sh_wlib.lua:
CFG.dev = false

-- Потом перенести
CFG.afkDemoteTime = 300
--addons/_wlib/lua/wlib/libraries/utf8.lua:
-- $Id: utf8.lua 179 2009-04-03 18:10:03Z pasta $
--
-- Provides UTF-8 aware string functions implemented in pure lua:
-- * utf8len(s)
-- * utf8sub(s, i, j)
-- * utf8reverse(s)
-- * utf8char(unicode)
-- * utf8unicode(s, i, j)
-- * utf8gensub(s, sub_len)
-- * utf8find(str, regex, init, plain)
-- * utf8match(str, regex, init)
-- * utf8gmatch(str, regex, all)
-- * utf8gsub(str, regex, repl, limit)
--
-- If utf8data.lua (containing the lower<->upper case mappings) is loaded, these
-- additional functions are available:
-- * utf8upper(s)
-- * utf8lower(s)
--
-- All functions behave as their non UTF-8 aware counterparts with the exception
-- that UTF-8 characters are used instead of bytes for all units.

--[[
Copyright (c) 2006-2007, Kyle Smith
All rights reserved.
Contributors:
	Alimov Stepan
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
	* Redistributions of source code must retain the above copyright notice,
	  this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright
	  notice, this list of conditions and the following disclaimer in the
	  documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of its contributors may be
	  used to endorse or promote products derived from this software without
	  specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--]]

-- ABNF from RFC 3629
--
-- UTF8-octets = *( UTF8-char )
-- UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
-- UTF8-1	  = %x00-7F
-- UTF8-2	  = %xC2-DF UTF8-tail
-- UTF8-3	  = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /
--			   %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )
-- UTF8-4	  = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /
--			   %xF4 %x80-8F 2( UTF8-tail )
-- UTF8-tail   = %x80-BF
--

local byte	= string.byte
local char	= string.char
local dump	= string.dump
local find	= string.find
local format  = string.format
local gmatch  = string.gmatch
local gsub	= string.gsub
local len	 = string.len
local lower   = string.lower
local match   = string.match
local rep	 = string.rep
local reverse = string.reverse
local sub	 = string.sub
local upper   = string.upper

-- returns the number of bytes used by the UTF-8 character at byte i in s
-- also doubles as a UTF-8 character validator
local function utf8charbytes (s, i)
	-- argument defaults
	i = i or 1

	-- argument checking
	if type(s) ~= "string" then
		error("bad argument #1 to 'utf8charbytes' (string expected, got ".. type(s).. ")")
	end
	if type(i) ~= "number" then
		error("bad argument #2 to 'utf8charbytes' (number expected, got ".. type(i).. ")")
	end

	local c = byte(s, i)

	-- determine bytes needed for character, based on RFC 3629
	-- validate byte 1
	if c > 0 and c <= 127 then
		-- UTF8-1
		return 1

	elseif c >= 194 and c <= 223 then
		-- UTF8-2
		local c2 = byte(s, i + 1)

		if not c2 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		return 2

	elseif c >= 224 and c <= 239 then
		-- UTF8-3
		local c2 = byte(s, i + 1)
		local c3 = byte(s, i + 2)

		if not c2 or not c3 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 224 and (c2 < 160 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 237 and (c2 < 128 or c2 > 159) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		return 3

	elseif c >= 240 and c <= 244 then
		-- UTF8-4
		local c2 = byte(s, i + 1)
		local c3 = byte(s, i + 2)
		local c4 = byte(s, i + 3)

		if not c2 or not c3 or not c4 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 240 and (c2 < 144 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 244 and (c2 < 128 or c2 > 143) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 4
		if c4 < 128 or c4 > 191 then
			error("Invalid UTF-8 character")
		end

		return 4

	else
		error("Invalid UTF-8 character")
	end
end

-- returns the number of characters in a UTF-8 string
local function utf8len (s)
	-- argument checking
	if type(s) ~= "string" then
		for k,v in pairs(s) do print('"',tostring(k),'"',tostring(v),'"') end
		error("bad argument #1 to 'utf8len' (string expected, got ".. type(s).. ")")
	end

	local pos = 1
	local bytes = len(s)
	local len = 0

	while pos <= bytes do
		len = len + 1
		pos = pos + utf8charbytes(s, pos)
	end

	return len
end

-- functions identically to string.sub except that i and j are UTF-8 characters
-- instead of bytes
local function utf8sub (s, i, j)
	-- argument defaults
	j = j or -1

	local pos = 1
	local bytes = len(s)
	local len = 0

	-- only set l if i or j is negative
	local l = (i >= 0 and j >= 0) or utf8len(s)
	local startChar = (i >= 0) and i or l + i + 1
	local endChar   = (j >= 0) and j or l + j + 1

	-- can't have start before end!
	if startChar > endChar then
		return ""
	end

	-- byte offsets to pass to string.sub
	local startByte,endByte = 1,bytes

	while pos <= bytes do
		len = len + 1

		if len == startChar then
			startByte = pos
		end

		pos = pos + utf8charbytes(s, pos)

		if len == endChar then
			endByte = pos - 1
			break
		end
	end

	if startChar > len then startByte = bytes+1   end
	if endChar   < 1   then endByte   = 0		 end

	return sub(s, startByte, endByte)
end


-- replace UTF-8 characters based on a mapping table
local function utf8replace (s, mapping)
	-- argument checking
	if type(s) ~= "string" then
		error("bad argument #1 to 'utf8replace' (string expected, got ".. type(s).. ")")
	end
	if type(mapping) ~= "table" then
		error("bad argument #2 to 'utf8replace' (table expected, got ".. type(mapping).. ")")
	end

	local pos = 1
	local bytes = len(s)
	local charbytes
	local newstr = ""

	while pos <= bytes do
		charbytes = utf8charbytes(s, pos)
		local c = sub(s, pos, pos + charbytes - 1)

		newstr = newstr .. (mapping[c] or c)

		pos = pos + charbytes
	end

	return newstr
end


-- identical to string.upper except it knows about unicode simple case conversions
local function utf8upper (s)
	return utf8replace(s, utf8_lc_uc)
end

-- identical to string.lower except it knows about unicode simple case conversions
local function utf8lower (s)
	return utf8replace(s, utf8_uc_lc)
end

-- identical to string.reverse except that it supports UTF-8
local function utf8reverse (s)
	-- argument checking
	if type(s) ~= "string" then
		error("bad argument #1 to 'utf8reverse' (string expected, got ".. type(s).. ")")
	end

	local bytes = len(s)
	local pos = bytes
	local charbytes
	local newstr = ""

	while pos > 0 do
		c = byte(s, pos)
		while c >= 128 and c <= 191 do
			pos = pos - 1
			c = byte(s, pos)
		end

		charbytes = utf8charbytes(s, pos)

		newstr = newstr .. sub(s, pos, pos + charbytes - 1)

		pos = pos - 1
	end

	return newstr
end

-- http://en.wikipedia.org/wiki/Utf8
-- http://developer.coronalabs.com/code/utf-8-conversion-utility
local function utf8char(unicode)
	if unicode <= 0x7F then return char(unicode) end

	if (unicode <= 0x7FF) then
		local Byte0 = 0xC0 + math.floor(unicode / 0x40);
		local Byte1 = 0x80 + (unicode % 0x40);
		return char(Byte0, Byte1);
	end;

	if (unicode <= 0xFFFF) then
		local Byte0 = 0xE0 +  math.floor(unicode / 0x1000);
		local Byte1 = 0x80 + (math.floor(unicode / 0x40) % 0x40);
		local Byte2 = 0x80 + (unicode % 0x40);
		return char(Byte0, Byte1, Byte2);
	end;

	if (unicode <= 0x10FFFF) then
		local code = unicode
		local Byte3= 0x80 + (code % 0x40);
		code	   = math.floor(code / 0x40)
		local Byte2= 0x80 + (code % 0x40);
		code	   = math.floor(code / 0x40)
		local Byte1= 0x80 + (code % 0x40);
		code	   = math.floor(code / 0x40)
		local Byte0= 0xF0 + code;

		return char(Byte0, Byte1, Byte2, Byte3);
	end;

	error 'Unicode cannot be greater than U+10FFFF!'
end

local shift_6  = 2^6
local shift_12 = 2^12
local shift_18 = 2^18

local utf8unicode
utf8unicode = function(str, i, j, byte_pos)
	i = i or 1
	j = j or i

	if i > j then return end

	local char,bytes

	if byte_pos then
		bytes = utf8charbytes(str,byte_pos)
		char  = sub(str,byte_pos,byte_pos-1+bytes)
	else
		char,byte_pos = utf8sub(str,i,i), 0
		bytes		 = #char
	end

	local unicode

	if bytes == 1 then unicode = byte(char) end
	if bytes == 2 then
		local byte0,byte1 = byte(char,1,2)
		local code0,code1 = byte0-0xC0,byte1-0x80
		unicode = code0*shift_6 + code1
	end
	if bytes == 3 then
		local byte0,byte1,byte2 = byte(char,1,3)
		local code0,code1,code2 = byte0-0xE0,byte1-0x80,byte2-0x80
		unicode = code0*shift_12 + code1*shift_6 + code2
	end
	if bytes == 4 then
		local byte0,byte1,byte2,byte3 = byte(char,1,4)
		local code0,code1,code2,code3 = byte0-0xF0,byte1-0x80,byte2-0x80,byte3-0x80
		unicode = code0*shift_18 + code1*shift_12 + code2*shift_6 + code3
	end

	return unicode,utf8unicode(str, i+1, j, byte_pos+bytes)
end

-- Returns an iterator which returns the next substring and its byte interval
local function utf8gensub(str, sub_len)
	sub_len		= sub_len or 1
	local byte_pos = 1
	local len	  = #str
	return function(skip)
		if skip then byte_pos = byte_pos + skip end
		local char_count = 0
		local start	  = byte_pos
		repeat
			if byte_pos > len then return end
			char_count  = char_count + 1
			local bytes = utf8charbytes(str,byte_pos)
			byte_pos	= byte_pos+bytes

		until char_count == sub_len

		local last  = byte_pos-1
		local sub   = sub(str,start,last)
		return sub, start, last
	end
end

local function binsearch(sortedTable, item, comp)
	local head, tail = 1, #sortedTable
	local mid = math.floor((head + tail)/2)
	if not comp then
		while (tail - head) > 1 do
			if sortedTable[tonumber(mid)] > item then
				tail = mid
			else
				head = mid
			end
			mid = math.floor((head + tail)/2)
		end
	else
	end
	if sortedTable[tonumber(head)] == item then
		return true, tonumber(head)
	elseif sortedTable[tonumber(tail)] == item then
		return true, tonumber(tail)
	else
		return false
	end
end
local function classMatchGenerator(class, plain)
	local codes = {}
	local ranges = {}
	local ignore = false
	local range = false
	local firstletter = true
	local unmatch = false

	local it = utf8gensub(class)

	local skip
	for c,bs,be in it do
		skip = be
		if not ignore and not plain then
			if c == "%" then
				ignore = true
			elseif c == "-" then
				table.insert(codes, utf8unicode(c))
				range = true
			elseif c == "^" then
				if not firstletter then
					error('!!!')
				else
					unmatch = true
				end
			elseif c == ']' then
				break
			else
				if not range then
					table.insert(codes, utf8unicode(c))
				else
					table.remove(codes) -- removing '-'
					table.insert(ranges, {table.remove(codes), utf8unicode(c)})
					range = false
				end
			end
		elseif ignore and not plain then
			if c == 'a' then -- %a: represents all letters. (ONLY ASCII)
				table.insert(ranges, {65, 90}) -- A - Z
				table.insert(ranges, {97, 122}) -- a - z
			elseif c == 'c' then -- %c: represents all control characters.
				table.insert(ranges, {0, 31})
				table.insert(codes, 127)
			elseif c == 'd' then -- %d: represents all digits.
				table.insert(ranges, {48, 57}) -- 0 - 9
			elseif c == 'g' then -- %g: represents all printable characters except space.
				table.insert(ranges, {1, 8})
				table.insert(ranges, {14, 31})
				table.insert(ranges, {33, 132})
				table.insert(ranges, {134, 159})
				table.insert(ranges, {161, 5759})
				table.insert(ranges, {5761, 8191})
				table.insert(ranges, {8203, 8231})
				table.insert(ranges, {8234, 8238})
				table.insert(ranges, {8240, 8286})
				table.insert(ranges, {8288, 12287})
			elseif c == 'l' then -- %l: represents all lowercase letters. (ONLY ASCII)
				table.insert(ranges, {97, 122}) -- a - z
			elseif c == 'p' then -- %p: represents all punctuation characters. (ONLY ASCII)
				table.insert(ranges, {33, 47})
				table.insert(ranges, {58, 64})
				table.insert(ranges, {91, 96})
				table.insert(ranges, {123, 126})
			elseif c == 's' then -- %s: represents all space characters.
				table.insert(ranges, {9, 13})
				table.insert(codes, 32)
				table.insert(codes, 133)
				table.insert(codes, 160)
				table.insert(codes, 5760)
				table.insert(ranges, {8192, 8202})
				table.insert(codes, 8232)
				table.insert(codes, 8233)
				table.insert(codes, 8239)
				table.insert(codes, 8287)
				table.insert(codes, 12288)
			elseif c == 'u' then -- %u: represents all uppercase letters. (ONLY ASCII)
				table.insert(ranges, {65, 90}) -- A - Z
			elseif c == 'w' then -- %w: represents all alphanumeric characters. (ONLY ASCII)
				table.insert(ranges, {48, 57}) -- 0 - 9
				table.insert(ranges, {65, 90}) -- A - Z
				table.insert(ranges, {97, 122}) -- a - z
			elseif c == 'x' then -- %x: represents all hexadecimal digits.
				table.insert(ranges, {48, 57}) -- 0 - 9
				table.insert(ranges, {65, 70}) -- A - F
				table.insert(ranges, {97, 102}) -- a - f
			else
				if not range then
					table.insert(codes, utf8unicode(c))
				else
					table.remove(codes) -- removing '-'
					table.insert(ranges, {table.remove(codes), utf8unicode(c)})
					range = false
				end
			end
			ignore = false
		else
			if not range then
				table.insert(codes, utf8unicode(c))
			else
				table.remove(codes) -- removing '-'
				table.insert(ranges, {table.remove(codes), utf8unicode(c)})
				range = false
			end
			ignore = false
		end

		firstletter = false
	end

	table.sort(codes)

	local function inRanges(charCode)
		for _,r in ipairs(ranges) do
			if r[1] <= charCode and charCode <= r[2] then
				return true
			end
		end
		return false
	end
	if not unmatch then
		return function(charCode)
			return binsearch(codes, charCode) or inRanges(charCode)
		end, skip
	else
		return function(charCode)
			return charCode ~= -1 and not (binsearch(codes, charCode) or inRanges(charCode))
		end, skip
	end
end

-- utf8sub with extra argument, and extra result value
local function utf8subWithBytes (s, i, j, sb)
	-- argument defaults
	j = j or -1

	local pos = sb or 1
	local bytes = len(s)
	local len = 0

	-- only set l if i or j is negative
	local l = (i >= 0 and j >= 0) or utf8len(s)
	local startChar = (i >= 0) and i or l + i + 1
	local endChar   = (j >= 0) and j or l + j + 1

	-- can't have start before end!
	if startChar > endChar then
		return ""
	end

	-- byte offsets to pass to string.sub
	local startByte,endByte = 1,bytes

	while pos <= bytes do
		len = len + 1

		if len == startChar then
			startByte = pos
		end

		pos = pos + utf8charbytes(s, pos)

		if len == endChar then
			endByte = pos - 1
			break
		end
	end

	if startChar > len then startByte = bytes+1   end
	if endChar   < 1   then endByte   = 0		 end

	return sub(s, startByte, endByte), endByte + 1
end

local cache = setmetatable({},{
	__mode = 'kv'
})
local cachePlain = setmetatable({},{
	__mode = 'kv'
})
local function matcherGenerator(regex, plain)
	local matcher = {
		functions = {},
		captures = {}
	}
	if not plain then
		cache[regex] =  matcher
	else
		cachePlain[regex] = matcher
	end
	local function simple(func)
		return function(cC)
			if func(cC) then
				matcher:nextFunc()
				matcher:nextStr()
			else
				matcher:reset()
			end
		end
	end
	local function star(func)
		return function(cC)
			if func(cC) then
				matcher:fullResetOnNextFunc()
				matcher:nextStr()
			else
				matcher:nextFunc()
			end
		end
	end
	local function minus(func)
		return function(cC)
			if func(cC) then
				matcher:fullResetOnNextStr()
			end
			matcher:nextFunc()
		end
	end
	local function question(func)
		return function(cC)
			if func(cC) then
				matcher:fullResetOnNextFunc()
				matcher:nextStr()
			end
			matcher:nextFunc()
		end
	end

	local function capture(id)
		return function(cC)
			local l = matcher.captures[id][2] - matcher.captures[id][1]
			local captured = utf8sub(matcher.string, matcher.captures[id][1], matcher.captures[id][2])
			local check = utf8sub(matcher.string, matcher.str, matcher.str + l)
			if captured == check then
				for i = 0, l do
					matcher:nextStr()
				end
				matcher:nextFunc()
			else
				matcher:reset()
			end
		end
	end
	local function captureStart(id)
		return function(cC)
			matcher.captures[id][1] = matcher.str
			matcher:nextFunc()
		end
	end
	local function captureStop(id)
		return function(cC)
			matcher.captures[id][2] = matcher.str - 1
			matcher:nextFunc()
		end
	end

	local function balancer(str)
		local sum = 0
		local bc, ec = utf8sub(str, 1, 1), utf8sub(str, 2, 2)
		local skip = len(bc) + len(ec)
		bc, ec = utf8unicode(bc), utf8unicode(ec)
		return function(cC)
			if cC == ec and sum > 0 then
				sum = sum - 1
				if sum == 0 then
					matcher:nextFunc()
				end
				matcher:nextStr()
			elseif cC == bc then
				sum = sum + 1
				matcher:nextStr()
			else
				if sum == 0 or cC == -1 then
					sum = 0
					matcher:reset()
				else
					matcher:nextStr()
				end
			end
		end, skip
	end

	matcher.functions[1] = function(cC)
		matcher:fullResetOnNextStr()
		matcher.seqStart = matcher.str
		matcher:nextFunc()
		if (matcher.str > matcher.startStr and matcher.fromStart) or matcher.str >= matcher.stringLen then
			matcher.stop = true
			matcher.seqStart = nil
		end
	end

	local lastFunc
	local ignore = false
	local skip = nil
	local it = (function()
		local gen = utf8gensub(regex)
		return function()
			return gen(skip)
		end
	end)()
	local cs = {}
	for c, bs, be in it do
		skip = nil
		if plain then
			table.insert(matcher.functions, simple(classMatchGenerator(c, plain)))
		else
			if ignore then
				if find('123456789', c, 1, true) then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					table.insert(matcher.functions, capture(tonumber(c)))
				elseif c == 'b' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					local b
					b, skip = balancer(sub(regex, be + 1, be + 9))
					table.insert(matcher.functions, b)
				else
					lastFunc = classMatchGenerator('%' .. c)
				end
				ignore = false
			else
				if c == '*' then
					if lastFunc then
						table.insert(matcher.functions, star(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '+' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						table.insert(matcher.functions, star(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '-' then
					if lastFunc then
						table.insert(matcher.functions, minus(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '?' then
					if lastFunc then
						table.insert(matcher.functions, question(lastFunc))
						lastFunc = nil
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '^' then
					if bs == 1 then
						matcher.fromStart = true
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '$' then
					if be == len(regex) then
						matcher.toEnd = true
					else
						error('invalid regex after ' .. sub(regex, 1, bs))
					end
				elseif c == '[' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
					end
					lastFunc, skip = classMatchGenerator(sub(regex, be + 1))
				elseif c == '(' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					table.insert(matcher.captures, {})
					table.insert(cs, #matcher.captures)
					table.insert(matcher.functions, captureStart(cs[#cs]))
					if sub(regex, be + 1, be + 1) == ')' then matcher.captures[#matcher.captures].empty = true end
				elseif c == ')' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
						lastFunc = nil
					end
					local cap = table.remove(cs)
					if not cap then
						error('invalid capture: "(" missing')
					end
					table.insert(matcher.functions, captureStop(cap))
				elseif c == '.' then
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
					end
					lastFunc = function(cC) return cC ~= -1 end
				elseif c == '%' then
					ignore = true
				else
					if lastFunc then
						table.insert(matcher.functions, simple(lastFunc))
					end
					lastFunc = classMatchGenerator(c)
				end
			end
		end
	end
	if #cs > 0 then
		error('invalid capture: ")" missing')
	end
	if lastFunc then
		table.insert(matcher.functions, simple(lastFunc))
	end
	lastFunc = nil
	ignore = nil

	table.insert(matcher.functions, function()
		if matcher.toEnd and matcher.str ~= matcher.stringLen then
			matcher:reset()
		else
			matcher.stop = true
		end
	end)

	matcher.nextFunc = function(self)
		self.func = self.func + 1
	end
	matcher.nextStr = function(self)
		self.str = self.str + 1
	end
	matcher.strReset = function(self)
		local oldReset = self.reset
		local str = self.str
		self.reset = function(s)
			s.str = str
			s.reset = oldReset
		end
	end
	matcher.fullResetOnNextFunc = function(self)
		local oldReset = self.reset
		local func = self.func +1
		local str = self.str
		self.reset = function(s)
			s.func = func
			s.str = str
			s.reset = oldReset
		end
	end
	matcher.fullResetOnNextStr = function(self)
		local oldReset = self.reset
		local str = self.str + 1
		local func = self.func
		self.reset = function(s)
			s.func = func
			s.str = str
			s.reset = oldReset
		end
	end

	matcher.process = function(self, str, start)

		self.func = 1
		start = start or 1
		self.startStr = (start >= 0) and start or utf8len(str) + start + 1
		self.seqStart = self.startStr
		self.str = self.startStr
		self.stringLen = utf8len(str) + 1
		self.string = str
		self.stop = false

		self.reset = function(s)
			s.func = 1
		end

		local lastPos = self.str
		local lastByte
		local char
		while not self.stop do
			if self.str < self.stringLen then
				--[[ if lastPos < self.str then
					print('last byte', lastByte)
					char, lastByte = utf8subWithBytes(str, 1, self.str - lastPos - 1, lastByte)
					char, lastByte = utf8subWithBytes(str, 1, 1, lastByte)
					lastByte = lastByte - 1
				else
					char, lastByte = utf8subWithBytes(str, self.str, self.str)
				end
				lastPos = self.str ]]
				char = utf8sub(str, self.str,self.str)
				--print('char', char, utf8unicode(char))
				self.functions[self.func](utf8unicode(char))
			else
				self.functions[self.func](-1)
			end
		end

		if self.seqStart then
			local captures = {}
			for _,pair in pairs(self.captures) do
				if pair.empty then
					table.insert(captures, pair[1])
				else
					table.insert(captures, utf8sub(str, pair[1], pair[2]))
				end
			end
			return self.seqStart, self.str - 1, unpack(captures)
		end
	end

	return matcher
end

-- string.find
local function utf8find(str, regex, init, plain)
	local matcher = cache[regex] or matcherGenerator(regex, plain)
	return matcher:process(str, init)
end

-- string.match
local function utf8match(str, regex, init)
	init = init or 1
	local found = {utf8find(str, regex, init)}
	if found[1] then
		if found[3] then
			return unpack(found, 3)
		end
		return utf8sub(str, found[1], found[2])
	end
end

-- string.gmatch
local function utf8gmatch(str, regex, all)
	regex = (utf8sub(regex,1,1) ~= '^') and regex or '%' .. regex
	local lastChar = 1
	return function()
		local found = {utf8find(str, regex, lastChar)}
		if found[1] then
			lastChar = found[2] + 1
			if found[all and 1 or 3] then
				return unpack(found, all and 1 or 3)
			end
			return utf8sub(str, found[1], found[2])
		end
	end
end

local function replace(repl, args)
	local ret = ''
	if type(repl) == 'string' then
		local ignore = false
		local num = 0
		for c in utf8gensub(repl) do
			if not ignore then
				if c == '%' then
					ignore = true
				else
					ret = ret .. c
				end
			else
				num = tonumber(c)
				if num then
					ret = ret .. args[num]
				else
					ret = ret .. c
				end
				ignore = false
			end
		end
	elseif type(repl) == 'table' then
		ret = repl[args[1] or args[0]] or ''
	elseif type(repl) == 'function' then
		if #args > 0 then
			ret = repl(unpack(args, 1)) or ''
		else
			ret = repl(args[0]) or ''
		end
	end
	return ret
end
-- string.gsub
local function utf8gsub(str, regex, repl, limit)
	limit = limit or -1
	local ret = ''
	local prevEnd = 1
	local it = utf8gmatch(str, regex, true)
	local found = {it()}
	local n = 0
	while #found > 0 and limit ~= n do
		local args = {[0] = utf8sub(str, found[1], found[2]), unpack(found, 3)}
		ret = ret .. utf8sub(str, prevEnd, found[1] - 1)
		.. replace(repl, args)
		prevEnd = found[2] + 1
		n = n + 1
		found = {it()}
	end
	return ret .. utf8sub(str, prevEnd), n
end

utf8.len = utf8len
utf8.sub = utf8sub
utf8.reverse = utf8reverse
utf8.char = utf8char
utf8.unicode = utf8unicode
utf8.gensub = utf8gensub
utf8.byte = utf8unicode
utf8.find	= utf8find
utf8.match   = utf8match
utf8.gmatch  = utf8gmatch
utf8.gsub	= utf8gsub
utf8.dump	= dump
utf8.format = format
utf8.lower = utf8lower
utf8.upper = utf8upper
utf8.rep	 = rep

-- char mapping tables from https://github.com/artemshein/luv/blob/master/utf8data.lua
utf8_lc_uc={["a"]="A",["b"]="B",["c"]="C",["d"]="D",["e"]="E",["f"]="F",["g"]="G",["h"]="H",["i"]="I",["j"]="J",["k"]="K",["l"]="L",["m"]="M",["n"]="N",["o"]="O",["p"]="P",["q"]="Q",["r"]="R",["s"]="S",["t"]="T",["u"]="U",["v"]="V",["w"]="W",["x"]="X",["y"]="Y",["z"]="Z",["µ"]="Μ",["à"]="À",["á"]="Á",["â"]="Â",["ã"]="Ã",["ä"]="Ä",["å"]="Å",["æ"]="Æ",["ç"]="Ç",["è"]="È",["é"]="É",["ê"]="Ê",["ë"]="Ë",["ì"]="Ì",["í"]="Í",["î"]="Î",["ï"]="Ï",["ð"]="Ð",["ñ"]="Ñ",["ò"]="Ò",["ó"]="Ó",["ô"]="Ô",["õ"]="Õ",["ö"]="Ö",["ø"]="Ø",["ù"]="Ù",["ú"]="Ú",["û"]="Û",["ü"]="Ü",["ý"]="Ý",["þ"]="Þ",["ÿ"]="Ÿ",["ā"]="Ā",["ă"]="Ă",["ą"]="Ą",["ć"]="Ć",["ĉ"]="Ĉ",["ċ"]="Ċ",["č"]="Č",["ď"]="Ď",["đ"]="Đ",["ē"]="Ē",["ĕ"]="Ĕ",["ė"]="Ė",["ę"]="Ę",["ě"]="Ě",["ĝ"]="Ĝ",["ğ"]="Ğ",["ġ"]="Ġ",["ģ"]="Ģ",["ĥ"]="Ĥ",["ħ"]="Ħ",["ĩ"]="Ĩ",["ī"]="Ī",["ĭ"]="Ĭ",["į"]="Į",["ı"]="I",["ĳ"]="Ĳ",["ĵ"]="Ĵ",["ķ"]="Ķ",["ĺ"]="Ĺ",["ļ"]="Ļ",["ľ"]="Ľ",["ŀ"]="Ŀ",["ł"]="Ł",["ń"]="Ń",["ņ"]="Ņ",["ň"]="Ň",["ŋ"]="Ŋ",["ō"]="Ō",["ŏ"]="Ŏ",["ő"]="Ő",["œ"]="Œ",["ŕ"]="Ŕ",["ŗ"]="Ŗ",["ř"]="Ř",["ś"]="Ś",["ŝ"]="Ŝ",["ş"]="Ş",["š"]="Š",["ţ"]="Ţ",["ť"]="Ť",["ŧ"]="Ŧ",["ũ"]="Ũ",["ū"]="Ū",["ŭ"]="Ŭ",["ů"]="Ů",["ű"]="Ű",["ų"]="Ų",["ŵ"]="Ŵ",["ŷ"]="Ŷ",["ź"]="Ź",["ż"]="Ż",["ž"]="Ž",["ſ"]="S",["ƀ"]="Ƀ",["ƃ"]="Ƃ",["ƅ"]="Ƅ",["ƈ"]="Ƈ",["ƌ"]="Ƌ",["ƒ"]="Ƒ",["ƕ"]="Ƕ",["ƙ"]="Ƙ",["ƚ"]="Ƚ",["ƞ"]="Ƞ",["ơ"]="Ơ",["ƣ"]="Ƣ",["ƥ"]="Ƥ",["ƨ"]="Ƨ",["ƭ"]="Ƭ",["ư"]="Ư",["ƴ"]="Ƴ",["ƶ"]="Ƶ",["ƹ"]="Ƹ",["ƽ"]="Ƽ",["ƿ"]="Ƿ",["ǅ"]="Ǆ",["ǆ"]="Ǆ",["ǈ"]="Ǉ",["ǉ"]="Ǉ",["ǋ"]="Ǌ",["ǌ"]="Ǌ",["ǎ"]="Ǎ",["ǐ"]="Ǐ",["ǒ"]="Ǒ",["ǔ"]="Ǔ",["ǖ"]="Ǖ",["ǘ"]="Ǘ",["ǚ"]="Ǚ",["ǜ"]="Ǜ",["ǝ"]="Ǝ",["ǟ"]="Ǟ",["ǡ"]="Ǡ",["ǣ"]="Ǣ",["ǥ"]="Ǥ",["ǧ"]="Ǧ",["ǩ"]="Ǩ",["ǫ"]="Ǫ",["ǭ"]="Ǭ",["ǯ"]="Ǯ",["ǲ"]="Ǳ",["ǳ"]="Ǳ",["ǵ"]="Ǵ",["ǹ"]="Ǹ",["ǻ"]="Ǻ",["ǽ"]="Ǽ",["ǿ"]="Ǿ",["ȁ"]="Ȁ",["ȃ"]="Ȃ",["ȅ"]="Ȅ",["ȇ"]="Ȇ",["ȉ"]="Ȉ",["ȋ"]="Ȋ",["ȍ"]="Ȍ",["ȏ"]="Ȏ",["ȑ"]="Ȑ",["ȓ"]="Ȓ",["ȕ"]="Ȕ",["ȗ"]="Ȗ",["ș"]="Ș",["ț"]="Ț",["ȝ"]="Ȝ",["ȟ"]="Ȟ",["ȣ"]="Ȣ",["ȥ"]="Ȥ",["ȧ"]="Ȧ",["ȩ"]="Ȩ",["ȫ"]="Ȫ",["ȭ"]="Ȭ",["ȯ"]="Ȯ",["ȱ"]="Ȱ",["ȳ"]="Ȳ",["ȼ"]="Ȼ",["ɂ"]="Ɂ",["ɇ"]="Ɇ",["ɉ"]="Ɉ",["ɋ"]="Ɋ",["ɍ"]="Ɍ",["ɏ"]="Ɏ",["ɓ"]="Ɓ",["ɔ"]="Ɔ",["ɖ"]="Ɖ",["ɗ"]="Ɗ",["ə"]="Ə",["ɛ"]="Ɛ",["ɠ"]="Ɠ",["ɣ"]="Ɣ",["ɨ"]="Ɨ",["ɩ"]="Ɩ",["ɫ"]="Ɫ",["ɯ"]="Ɯ",["ɲ"]="Ɲ",["ɵ"]="Ɵ",["ɽ"]="Ɽ",["ʀ"]="Ʀ",["ʃ"]="Ʃ",["ʈ"]="Ʈ",["ʉ"]="Ʉ",["ʊ"]="Ʊ",["ʋ"]="Ʋ",["ʌ"]="Ʌ",["ʒ"]="Ʒ",["ͅ"]="Ι",["ͻ"]="Ͻ",["ͼ"]="Ͼ",["ͽ"]="Ͽ",["ά"]="Ά",["έ"]="Έ",["ή"]="Ή",["ί"]="Ί",["α"]="Α",["β"]="Β",["γ"]="Γ",["δ"]="Δ",["ε"]="Ε",["ζ"]="Ζ",["η"]="Η",["θ"]="Θ",["ι"]="Ι",["κ"]="Κ",["λ"]="Λ",["μ"]="Μ",["ν"]="Ν",["ξ"]="Ξ",["ο"]="Ο",["π"]="Π",["ρ"]="Ρ",["ς"]="Σ",["σ"]="Σ",["τ"]="Τ",["υ"]="Υ",["φ"]="Φ",["χ"]="Χ",["ψ"]="Ψ",["ω"]="Ω",["ϊ"]="Ϊ",["ϋ"]="Ϋ",["ό"]="Ό",["ύ"]="Ύ",["ώ"]="Ώ",["ϐ"]="Β",["ϑ"]="Θ",["ϕ"]="Φ",["ϖ"]="Π",["ϙ"]="Ϙ",["ϛ"]="Ϛ",["ϝ"]="Ϝ",["ϟ"]="Ϟ",["ϡ"]="Ϡ",["ϣ"]="Ϣ",["ϥ"]="Ϥ",["ϧ"]="Ϧ",["ϩ"]="Ϩ",["ϫ"]="Ϫ",["ϭ"]="Ϭ",["ϯ"]="Ϯ",["ϰ"]="Κ",["ϱ"]="Ρ",["ϲ"]="Ϲ",["ϵ"]="Ε",["ϸ"]="Ϸ",["ϻ"]="Ϻ",["а"]="А",["б"]="Б",["в"]="В",["г"]="Г",["д"]="Д",["е"]="Е",["ж"]="Ж",["з"]="З",["и"]="И",["й"]="Й",["к"]="К",["л"]="Л",["м"]="М",["н"]="Н",["о"]="О",["п"]="П",["р"]="Р",["с"]="С",["т"]="Т",["у"]="У",["ф"]="Ф",["х"]="Х",["ц"]="Ц",["ч"]="Ч",["ш"]="Ш",["щ"]="Щ",["ъ"]="Ъ",["ы"]="Ы",["ь"]="Ь",["э"]="Э",["ю"]="Ю",["я"]="Я",["ѐ"]="Ѐ",["ё"]="Ё",["ђ"]="Ђ",["ѓ"]="Ѓ",["є"]="Є",["ѕ"]="Ѕ",["і"]="І",["ї"]="Ї",["ј"]="Ј",["љ"]="Љ",["њ"]="Њ",["ћ"]="Ћ",["ќ"]="Ќ",["ѝ"]="Ѝ",["ў"]="Ў",["џ"]="Џ",["ѡ"]="Ѡ",["ѣ"]="Ѣ",["ѥ"]="Ѥ",["ѧ"]="Ѧ",["ѩ"]="Ѩ",["ѫ"]="Ѫ",["ѭ"]="Ѭ",["ѯ"]="Ѯ",["ѱ"]="Ѱ",["ѳ"]="Ѳ",["ѵ"]="Ѵ",["ѷ"]="Ѷ",["ѹ"]="Ѹ",["ѻ"]="Ѻ",["ѽ"]="Ѽ",["ѿ"]="Ѿ",["ҁ"]="Ҁ",["ҋ"]="Ҋ",["ҍ"]="Ҍ",["ҏ"]="Ҏ",["ґ"]="Ґ",["ғ"]="Ғ",["ҕ"]="Ҕ",["җ"]="Җ",["ҙ"]="Ҙ",["қ"]="Қ",["ҝ"]="Ҝ",["ҟ"]="Ҟ",["ҡ"]="Ҡ",["ң"]="Ң",["ҥ"]="Ҥ",["ҧ"]="Ҧ",["ҩ"]="Ҩ",["ҫ"]="Ҫ",["ҭ"]="Ҭ",["ү"]="Ү",["ұ"]="Ұ",["ҳ"]="Ҳ",["ҵ"]="Ҵ",["ҷ"]="Ҷ",["ҹ"]="Ҹ",["һ"]="Һ",["ҽ"]="Ҽ",["ҿ"]="Ҿ",["ӂ"]="Ӂ",["ӄ"]="Ӄ",["ӆ"]="Ӆ",["ӈ"]="Ӈ",["ӊ"]="Ӊ",["ӌ"]="Ӌ",["ӎ"]="Ӎ",["ӏ"]="Ӏ",["ӑ"]="Ӑ",["ӓ"]="Ӓ",["ӕ"]="Ӕ",["ӗ"]="Ӗ",["ә"]="Ә",["ӛ"]="Ӛ",["ӝ"]="Ӝ",["ӟ"]="Ӟ",["ӡ"]="Ӡ",["ӣ"]="Ӣ",["ӥ"]="Ӥ",["ӧ"]="Ӧ",["ө"]="Ө",["ӫ"]="Ӫ",["ӭ"]="Ӭ",["ӯ"]="Ӯ",["ӱ"]="Ӱ",["ӳ"]="Ӳ",["ӵ"]="Ӵ",["ӷ"]="Ӷ",["ӹ"]="Ӹ",["ӻ"]="Ӻ",["ӽ"]="Ӽ",["ӿ"]="Ӿ",["ԁ"]="Ԁ",["ԃ"]="Ԃ",["ԅ"]="Ԅ",["ԇ"]="Ԇ",["ԉ"]="Ԉ",["ԋ"]="Ԋ",["ԍ"]="Ԍ",["ԏ"]="Ԏ",["ԑ"]="Ԑ",["ԓ"]="Ԓ",["ա"]="Ա",["բ"]="Բ",["գ"]="Գ",["դ"]="Դ",["ե"]="Ե",["զ"]="Զ",["է"]="Է",["ը"]="Ը",["թ"]="Թ",["ժ"]="Ժ",["ի"]="Ի",["լ"]="Լ",["խ"]="Խ",["ծ"]="Ծ",["կ"]="Կ",["հ"]="Հ",["ձ"]="Ձ",["ղ"]="Ղ",["ճ"]="Ճ",["մ"]="Մ",["յ"]="Յ",["ն"]="Ն",["շ"]="Շ",["ո"]="Ո",["չ"]="Չ",["պ"]="Պ",["ջ"]="Ջ",["ռ"]="Ռ",["ս"]="Ս",["վ"]="Վ",["տ"]="Տ",["ր"]="Ր",["ց"]="Ց",["ւ"]="Ւ",["փ"]="Փ",["ք"]="Ք",["օ"]="Օ",["ֆ"]="Ֆ",["ᵽ"]="Ᵽ",["ḁ"]="Ḁ",["ḃ"]="Ḃ",["ḅ"]="Ḅ",["ḇ"]="Ḇ",["ḉ"]="Ḉ",["ḋ"]="Ḋ",["ḍ"]="Ḍ",["ḏ"]="Ḏ",["ḑ"]="Ḑ",["ḓ"]="Ḓ",["ḕ"]="Ḕ",["ḗ"]="Ḗ",["ḙ"]="Ḙ",["ḛ"]="Ḛ",["ḝ"]="Ḝ",["ḟ"]="Ḟ",["ḡ"]="Ḡ",["ḣ"]="Ḣ",["ḥ"]="Ḥ",["ḧ"]="Ḧ",["ḩ"]="Ḩ",["ḫ"]="Ḫ",["ḭ"]="Ḭ",["ḯ"]="Ḯ",["ḱ"]="Ḱ",["ḳ"]="Ḳ",["ḵ"]="Ḵ",["ḷ"]="Ḷ",["ḹ"]="Ḹ",["ḻ"]="Ḻ",["ḽ"]="Ḽ",["ḿ"]="Ḿ",["ṁ"]="Ṁ",["ṃ"]="Ṃ",["ṅ"]="Ṅ",["ṇ"]="Ṇ",["ṉ"]="Ṉ",["ṋ"]="Ṋ",["ṍ"]="Ṍ",["ṏ"]="Ṏ",["ṑ"]="Ṑ",["ṓ"]="Ṓ",["ṕ"]="Ṕ",["ṗ"]="Ṗ",["ṙ"]="Ṙ",["ṛ"]="Ṛ",["ṝ"]="Ṝ",["ṟ"]="Ṟ",["ṡ"]="Ṡ",["ṣ"]="Ṣ",["ṥ"]="Ṥ",["ṧ"]="Ṧ",["ṩ"]="Ṩ",["ṫ"]="Ṫ",["ṭ"]="Ṭ",["ṯ"]="Ṯ",["ṱ"]="Ṱ",["ṳ"]="Ṳ",["ṵ"]="Ṵ",["ṷ"]="Ṷ",["ṹ"]="Ṹ",["ṻ"]="Ṻ",["ṽ"]="Ṽ",["ṿ"]="Ṿ",["ẁ"]="Ẁ",["ẃ"]="Ẃ",["ẅ"]="Ẅ",["ẇ"]="Ẇ",["ẉ"]="Ẉ",["ẋ"]="Ẋ",["ẍ"]="Ẍ",["ẏ"]="Ẏ",["ẑ"]="Ẑ",["ẓ"]="Ẓ",["ẕ"]="Ẕ",["ẛ"]="Ṡ",["ạ"]="Ạ",["ả"]="Ả",["ấ"]="Ấ",["ầ"]="Ầ",["ẩ"]="Ẩ",["ẫ"]="Ẫ",["ậ"]="Ậ",["ắ"]="Ắ",["ằ"]="Ằ",["ẳ"]="Ẳ",["ẵ"]="Ẵ",["ặ"]="Ặ",["ẹ"]="Ẹ",["ẻ"]="Ẻ",["ẽ"]="Ẽ",["ế"]="Ế",["ề"]="Ề",["ể"]="Ể",["ễ"]="Ễ",["ệ"]="Ệ",["ỉ"]="Ỉ",["ị"]="Ị",["ọ"]="Ọ",["ỏ"]="Ỏ",["ố"]="Ố",["ồ"]="Ồ",["ổ"]="Ổ",["ỗ"]="Ỗ",["ộ"]="Ộ",["ớ"]="Ớ",["ờ"]="Ờ",["ở"]="Ở",["ỡ"]="Ỡ",["ợ"]="Ợ",["ụ"]="Ụ",["ủ"]="Ủ",["ứ"]="Ứ",["ừ"]="Ừ",["ử"]="Ử",["ữ"]="Ữ",["ự"]="Ự",["ỳ"]="Ỳ",["ỵ"]="Ỵ",["ỷ"]="Ỷ",["ỹ"]="Ỹ",["ἀ"]="Ἀ",["ἁ"]="Ἁ",["ἂ"]="Ἂ",["ἃ"]="Ἃ",["ἄ"]="Ἄ",["ἅ"]="Ἅ",["ἆ"]="Ἆ",["ἇ"]="Ἇ",["ἐ"]="Ἐ",["ἑ"]="Ἑ",["ἒ"]="Ἒ",["ἓ"]="Ἓ",["ἔ"]="Ἔ",["ἕ"]="Ἕ",["ἠ"]="Ἠ",["ἡ"]="Ἡ",["ἢ"]="Ἢ",["ἣ"]="Ἣ",["ἤ"]="Ἤ",["ἥ"]="Ἥ",["ἦ"]="Ἦ",["ἧ"]="Ἧ",["ἰ"]="Ἰ",["ἱ"]="Ἱ",["ἲ"]="Ἲ",["ἳ"]="Ἳ",["ἴ"]="Ἴ",["ἵ"]="Ἵ",["ἶ"]="Ἶ",["ἷ"]="Ἷ",["ὀ"]="Ὀ",["ὁ"]="Ὁ",["ὂ"]="Ὂ",["ὃ"]="Ὃ",["ὄ"]="Ὄ",["ὅ"]="Ὅ",["ὑ"]="Ὑ",["ὓ"]="Ὓ",["ὕ"]="Ὕ",["ὗ"]="Ὗ",["ὠ"]="Ὠ",["ὡ"]="Ὡ",["ὢ"]="Ὢ",["ὣ"]="Ὣ",["ὤ"]="Ὤ",["ὥ"]="Ὥ",["ὦ"]="Ὦ",["ὧ"]="Ὧ",["ὰ"]="Ὰ",["ά"]="Ά",["ὲ"]="Ὲ",["έ"]="Έ",["ὴ"]="Ὴ",["ή"]="Ή",["ὶ"]="Ὶ",["ί"]="Ί",["ὸ"]="Ὸ",["ό"]="Ό",["ὺ"]="Ὺ",["ύ"]="Ύ",["ὼ"]="Ὼ",["ώ"]="Ώ",["ᾀ"]="ᾈ",["ᾁ"]="ᾉ",["ᾂ"]="ᾊ",["ᾃ"]="ᾋ",["ᾄ"]="ᾌ",["ᾅ"]="ᾍ",["ᾆ"]="ᾎ",["ᾇ"]="ᾏ",["ᾐ"]="ᾘ",["ᾑ"]="ᾙ",["ᾒ"]="ᾚ",["ᾓ"]="ᾛ",["ᾔ"]="ᾜ",["ᾕ"]="ᾝ",["ᾖ"]="ᾞ",["ᾗ"]="ᾟ",["ᾠ"]="ᾨ",["ᾡ"]="ᾩ",["ᾢ"]="ᾪ",["ᾣ"]="ᾫ",["ᾤ"]="ᾬ",["ᾥ"]="ᾭ",["ᾦ"]="ᾮ",["ᾧ"]="ᾯ",["ᾰ"]="Ᾰ",["ᾱ"]="Ᾱ",["ᾳ"]="ᾼ",["ι"]="Ι",["ῃ"]="ῌ",["ῐ"]="Ῐ",["ῑ"]="Ῑ",["ῠ"]="Ῠ",["ῡ"]="Ῡ",["ῥ"]="Ῥ",["ῳ"]="ῼ",["ⅎ"]="Ⅎ",["ⅰ"]="Ⅰ",["ⅱ"]="Ⅱ",["ⅲ"]="Ⅲ",["ⅳ"]="Ⅳ",["ⅴ"]="Ⅴ",["ⅵ"]="Ⅵ",["ⅶ"]="Ⅶ",["ⅷ"]="Ⅷ",["ⅸ"]="Ⅸ",["ⅹ"]="Ⅹ",["ⅺ"]="Ⅺ",["ⅻ"]="Ⅻ",["ⅼ"]="Ⅼ",["ⅽ"]="Ⅽ",["ⅾ"]="Ⅾ",["ⅿ"]="Ⅿ",["ↄ"]="Ↄ",["ⓐ"]="Ⓐ",["ⓑ"]="Ⓑ",["ⓒ"]="Ⓒ",["ⓓ"]="Ⓓ",["ⓔ"]="Ⓔ",["ⓕ"]="Ⓕ",["ⓖ"]="Ⓖ",["ⓗ"]="Ⓗ",["ⓘ"]="Ⓘ",["ⓙ"]="Ⓙ",["ⓚ"]="Ⓚ",["ⓛ"]="Ⓛ",["ⓜ"]="Ⓜ",["ⓝ"]="Ⓝ",["ⓞ"]="Ⓞ",["ⓟ"]="Ⓟ",["ⓠ"]="Ⓠ",["ⓡ"]="Ⓡ",["ⓢ"]="Ⓢ",["ⓣ"]="Ⓣ",["ⓤ"]="Ⓤ",["ⓥ"]="Ⓥ",["ⓦ"]="Ⓦ",["ⓧ"]="Ⓧ",["ⓨ"]="Ⓨ",["ⓩ"]="Ⓩ",["ⰰ"]="Ⰰ",["ⰱ"]="Ⰱ",["ⰲ"]="Ⰲ",["ⰳ"]="Ⰳ",["ⰴ"]="Ⰴ",["ⰵ"]="Ⰵ",["ⰶ"]="Ⰶ",["ⰷ"]="Ⰷ",["ⰸ"]="Ⰸ",["ⰹ"]="Ⰹ",["ⰺ"]="Ⰺ",["ⰻ"]="Ⰻ",["ⰼ"]="Ⰼ",["ⰽ"]="Ⰽ",["ⰾ"]="Ⰾ",["ⰿ"]="Ⰿ",["ⱀ"]="Ⱀ",["ⱁ"]="Ⱁ",["ⱂ"]="Ⱂ",["ⱃ"]="Ⱃ",["ⱄ"]="Ⱄ",["ⱅ"]="Ⱅ",["ⱆ"]="Ⱆ",["ⱇ"]="Ⱇ",["ⱈ"]="Ⱈ",["ⱉ"]="Ⱉ",["ⱊ"]="Ⱊ",["ⱋ"]="Ⱋ",["ⱌ"]="Ⱌ",["ⱍ"]="Ⱍ",["ⱎ"]="Ⱎ",["ⱏ"]="Ⱏ",["ⱐ"]="Ⱐ",["ⱑ"]="Ⱑ",["ⱒ"]="Ⱒ",["ⱓ"]="Ⱓ",["ⱔ"]="Ⱔ",["ⱕ"]="Ⱕ",["ⱖ"]="Ⱖ",["ⱗ"]="Ⱗ",["ⱘ"]="Ⱘ",["ⱙ"]="Ⱙ",["ⱚ"]="Ⱚ",["ⱛ"]="Ⱛ",["ⱜ"]="Ⱜ",["ⱝ"]="Ⱝ",["ⱞ"]="Ⱞ",["ⱡ"]="Ⱡ",["ⱥ"]="Ⱥ",["ⱦ"]="Ⱦ",["ⱨ"]="Ⱨ",["ⱪ"]="Ⱪ",["ⱬ"]="Ⱬ",["ⱶ"]="Ⱶ",["ⲁ"]="Ⲁ",["ⲃ"]="Ⲃ",["ⲅ"]="Ⲅ",["ⲇ"]="Ⲇ",["ⲉ"]="Ⲉ",["ⲋ"]="Ⲋ",["ⲍ"]="Ⲍ",["ⲏ"]="Ⲏ",["ⲑ"]="Ⲑ",["ⲓ"]="Ⲓ",["ⲕ"]="Ⲕ",["ⲗ"]="Ⲗ",["ⲙ"]="Ⲙ",["ⲛ"]="Ⲛ",["ⲝ"]="Ⲝ",["ⲟ"]="Ⲟ",["ⲡ"]="Ⲡ",["ⲣ"]="Ⲣ",["ⲥ"]="Ⲥ",["ⲧ"]="Ⲧ",["ⲩ"]="Ⲩ",["ⲫ"]="Ⲫ",["ⲭ"]="Ⲭ",["ⲯ"]="Ⲯ",["ⲱ"]="Ⲱ",["ⲳ"]="Ⲳ",["ⲵ"]="Ⲵ",["ⲷ"]="Ⲷ",["ⲹ"]="Ⲹ",["ⲻ"]="Ⲻ",["ⲽ"]="Ⲽ",["ⲿ"]="Ⲿ",["ⳁ"]="Ⳁ",["ⳃ"]="Ⳃ",["ⳅ"]="Ⳅ",["ⳇ"]="Ⳇ",["ⳉ"]="Ⳉ",["ⳋ"]="Ⳋ",["ⳍ"]="Ⳍ",["ⳏ"]="Ⳏ",["ⳑ"]="Ⳑ",["ⳓ"]="Ⳓ",["ⳕ"]="Ⳕ",["ⳗ"]="Ⳗ",["ⳙ"]="Ⳙ",["ⳛ"]="Ⳛ",["ⳝ"]="Ⳝ",["ⳟ"]="Ⳟ",["ⳡ"]="Ⳡ",["ⳣ"]="Ⳣ",["ⴀ"]="Ⴀ",["ⴁ"]="Ⴁ",["ⴂ"]="Ⴂ",["ⴃ"]="Ⴃ",["ⴄ"]="Ⴄ",["ⴅ"]="Ⴅ",["ⴆ"]="Ⴆ",["ⴇ"]="Ⴇ",["ⴈ"]="Ⴈ",["ⴉ"]="Ⴉ",["ⴊ"]="Ⴊ",["ⴋ"]="Ⴋ",["ⴌ"]="Ⴌ",["ⴍ"]="Ⴍ",["ⴎ"]="Ⴎ",["ⴏ"]="Ⴏ",["ⴐ"]="Ⴐ",["ⴑ"]="Ⴑ",["ⴒ"]="Ⴒ",["ⴓ"]="Ⴓ",["ⴔ"]="Ⴔ",["ⴕ"]="Ⴕ",["ⴖ"]="Ⴖ",["ⴗ"]="Ⴗ",["ⴘ"]="Ⴘ",["ⴙ"]="Ⴙ",["ⴚ"]="Ⴚ",["ⴛ"]="Ⴛ",["ⴜ"]="Ⴜ",["ⴝ"]="Ⴝ",["ⴞ"]="Ⴞ",["ⴟ"]="Ⴟ",["ⴠ"]="Ⴠ",["ⴡ"]="Ⴡ",["ⴢ"]="Ⴢ",["ⴣ"]="Ⴣ",["ⴤ"]="Ⴤ",["ⴥ"]="Ⴥ",["ａ"]="Ａ",["ｂ"]="Ｂ",["ｃ"]="Ｃ",["ｄ"]="Ｄ",["ｅ"]="Ｅ",["ｆ"]="Ｆ",["ｇ"]="Ｇ",["ｈ"]="Ｈ",["ｉ"]="Ｉ",["ｊ"]="Ｊ",["ｋ"]="Ｋ",["ｌ"]="Ｌ",["ｍ"]="Ｍ",["ｎ"]="Ｎ",["ｏ"]="Ｏ",["ｐ"]="Ｐ",["ｑ"]="Ｑ",["ｒ"]="Ｒ",["ｓ"]="Ｓ",["ｔ"]="Ｔ",["ｕ"]="Ｕ",["ｖ"]="Ｖ",["ｗ"]="Ｗ",["ｘ"]="Ｘ",["ｙ"]="Ｙ",["ｚ"]="Ｚ",["𐐨"]="𐐀",["𐐩"]="𐐁",["𐐪"]="𐐂",["𐐫"]="𐐃",["𐐬"]="𐐄",["𐐭"]="𐐅",["𐐮"]="𐐆",["𐐯"]="𐐇",["𐐰"]="𐐈",["𐐱"]="𐐉",["𐐲"]="𐐊",["𐐳"]="𐐋",["𐐴"]="𐐌",["𐐵"]="𐐍",["𐐶"]="𐐎",["𐐷"]="𐐏",["𐐸"]="𐐐",["𐐹"]="𐐑",["𐐺"]="𐐒",["𐐻"]="𐐓",["𐐼"]="𐐔",["𐐽"]="𐐕",["𐐾"]="𐐖",["𐐿"]="𐐗",["𐑀"]="𐐘",["𐑁"]="𐐙",["𐑂"]="𐐚",["𐑃"]="𐐛",["𐑄"]="𐐜",["𐑅"]="𐐝",["𐑆"]="𐐞",["𐑇"]="𐐟",["𐑈"]="𐐠",["𐑉"]="𐐡",["𐑊"]="𐐢",["𐑋"]="𐐣",["𐑌"]="𐐤",["𐑍"]="𐐥",["𐑎"]="𐐦",["𐑏"]="𐐧",}
utf8_uc_lc={["A"]="a",["B"]="b",["C"]="c",["D"]="d",["E"]="e",["F"]="f",["G"]="g",["H"]="h",["I"]="i",["J"]="j",["K"]="k",["L"]="l",["M"]="m",["N"]="n",["O"]="o",["P"]="p",["Q"]="q",["R"]="r",["S"]="s",["T"]="t",["U"]="u",["V"]="v",["W"]="w",["X"]="x",["Y"]="y",["Z"]="z",["À"]="à",["Á"]="á",["Â"]="â",["Ã"]="ã",["Ä"]="ä",["Å"]="å",["Æ"]="æ",["Ç"]="ç",["È"]="è",["É"]="é",["Ê"]="ê",["Ë"]="ë",["Ì"]="ì",["Í"]="í",["Î"]="î",["Ï"]="ï",["Ð"]="ð",["Ñ"]="ñ",["Ò"]="ò",["Ó"]="ó",["Ô"]="ô",["Õ"]="õ",["Ö"]="ö",["Ø"]="ø",["Ù"]="ù",["Ú"]="ú",["Û"]="û",["Ü"]="ü",["Ý"]="ý",["Þ"]="þ",["Ā"]="ā",["Ă"]="ă",["Ą"]="ą",["Ć"]="ć",["Ĉ"]="ĉ",["Ċ"]="ċ",["Č"]="č",["Ď"]="ď",["Đ"]="đ",["Ē"]="ē",["Ĕ"]="ĕ",["Ė"]="ė",["Ę"]="ę",["Ě"]="ě",["Ĝ"]="ĝ",["Ğ"]="ğ",["Ġ"]="ġ",["Ģ"]="ģ",["Ĥ"]="ĥ",["Ħ"]="ħ",["Ĩ"]="ĩ",["Ī"]="ī",["Ĭ"]="ĭ",["Į"]="į",["İ"]="i",["Ĳ"]="ĳ",["Ĵ"]="ĵ",["Ķ"]="ķ",["Ĺ"]="ĺ",["Ļ"]="ļ",["Ľ"]="ľ",["Ŀ"]="ŀ",["Ł"]="ł",["Ń"]="ń",["Ņ"]="ņ",["Ň"]="ň",["Ŋ"]="ŋ",["Ō"]="ō",["Ŏ"]="ŏ",["Ő"]="ő",["Œ"]="œ",["Ŕ"]="ŕ",["Ŗ"]="ŗ",["Ř"]="ř",["Ś"]="ś",["Ŝ"]="ŝ",["Ş"]="ş",["Š"]="š",["Ţ"]="ţ",["Ť"]="ť",["Ŧ"]="ŧ",["Ũ"]="ũ",["Ū"]="ū",["Ŭ"]="ŭ",["Ů"]="ů",["Ű"]="ű",["Ų"]="ų",["Ŵ"]="ŵ",["Ŷ"]="ŷ",["Ÿ"]="ÿ",["Ź"]="ź",["Ż"]="ż",["Ž"]="ž",["Ɓ"]="ɓ",["Ƃ"]="ƃ",["Ƅ"]="ƅ",["Ɔ"]="ɔ",["Ƈ"]="ƈ",["Ɖ"]="ɖ",["Ɗ"]="ɗ",["Ƌ"]="ƌ",["Ǝ"]="ǝ",["Ə"]="ə",["Ɛ"]="ɛ",["Ƒ"]="ƒ",["Ɠ"]="ɠ",["Ɣ"]="ɣ",["Ɩ"]="ɩ",["Ɨ"]="ɨ",["Ƙ"]="ƙ",["Ɯ"]="ɯ",["Ɲ"]="ɲ",["Ɵ"]="ɵ",["Ơ"]="ơ",["Ƣ"]="ƣ",["Ƥ"]="ƥ",["Ʀ"]="ʀ",["Ƨ"]="ƨ",["Ʃ"]="ʃ",["Ƭ"]="ƭ",["Ʈ"]="ʈ",["Ư"]="ư",["Ʊ"]="ʊ",["Ʋ"]="ʋ",["Ƴ"]="ƴ",["Ƶ"]="ƶ",["Ʒ"]="ʒ",["Ƹ"]="ƹ",["Ƽ"]="ƽ",["Ǆ"]="ǆ",["ǅ"]="ǆ",["Ǉ"]="ǉ",["ǈ"]="ǉ",["Ǌ"]="ǌ",["ǋ"]="ǌ",["Ǎ"]="ǎ",["Ǐ"]="ǐ",["Ǒ"]="ǒ",["Ǔ"]="ǔ",["Ǖ"]="ǖ",["Ǘ"]="ǘ",["Ǚ"]="ǚ",["Ǜ"]="ǜ",["Ǟ"]="ǟ",["Ǡ"]="ǡ",["Ǣ"]="ǣ",["Ǥ"]="ǥ",["Ǧ"]="ǧ",["Ǩ"]="ǩ",["Ǫ"]="ǫ",["Ǭ"]="ǭ",["Ǯ"]="ǯ",["Ǳ"]="ǳ",["ǲ"]="ǳ",["Ǵ"]="ǵ",["Ƕ"]="ƕ",["Ƿ"]="ƿ",["Ǹ"]="ǹ",["Ǻ"]="ǻ",["Ǽ"]="ǽ",["Ǿ"]="ǿ",["Ȁ"]="ȁ",["Ȃ"]="ȃ",["Ȅ"]="ȅ",["Ȇ"]="ȇ",["Ȉ"]="ȉ",["Ȋ"]="ȋ",["Ȍ"]="ȍ",["Ȏ"]="ȏ",["Ȑ"]="ȑ",["Ȓ"]="ȓ",["Ȕ"]="ȕ",["Ȗ"]="ȗ",["Ș"]="ș",["Ț"]="ț",["Ȝ"]="ȝ",["Ȟ"]="ȟ",["Ƞ"]="ƞ",["Ȣ"]="ȣ",["Ȥ"]="ȥ",["Ȧ"]="ȧ",["Ȩ"]="ȩ",["Ȫ"]="ȫ",["Ȭ"]="ȭ",["Ȯ"]="ȯ",["Ȱ"]="ȱ",["Ȳ"]="ȳ",["Ⱥ"]="ⱥ",["Ȼ"]="ȼ",["Ƚ"]="ƚ",["Ⱦ"]="ⱦ",["Ɂ"]="ɂ",["Ƀ"]="ƀ",["Ʉ"]="ʉ",["Ʌ"]="ʌ",["Ɇ"]="ɇ",["Ɉ"]="ɉ",["Ɋ"]="ɋ",["Ɍ"]="ɍ",["Ɏ"]="ɏ",["Ά"]="ά",["Έ"]="έ",["Ή"]="ή",["Ί"]="ί",["Ό"]="ό",["Ύ"]="ύ",["Ώ"]="ώ",["Α"]="α",["Β"]="β",["Γ"]="γ",["Δ"]="δ",["Ε"]="ε",["Ζ"]="ζ",["Η"]="η",["Θ"]="θ",["Ι"]="ι",["Κ"]="κ",["Λ"]="λ",["Μ"]="μ",["Ν"]="ν",["Ξ"]="ξ",["Ο"]="ο",["Π"]="π",["Ρ"]="ρ",["Σ"]="σ",["Τ"]="τ",["Υ"]="υ",["Φ"]="φ",["Χ"]="χ",["Ψ"]="ψ",["Ω"]="ω",["Ϊ"]="ϊ",["Ϋ"]="ϋ",["Ϙ"]="ϙ",["Ϛ"]="ϛ",["Ϝ"]="ϝ",["Ϟ"]="ϟ",["Ϡ"]="ϡ",["Ϣ"]="ϣ",["Ϥ"]="ϥ",["Ϧ"]="ϧ",["Ϩ"]="ϩ",["Ϫ"]="ϫ",["Ϭ"]="ϭ",["Ϯ"]="ϯ",["ϴ"]="θ",["Ϸ"]="ϸ",["Ϲ"]="ϲ",["Ϻ"]="ϻ",["Ͻ"]="ͻ",["Ͼ"]="ͼ",["Ͽ"]="ͽ",["Ѐ"]="ѐ",["Ё"]="ё",["Ђ"]="ђ",["Ѓ"]="ѓ",["Є"]="є",["Ѕ"]="ѕ",["І"]="і",["Ї"]="ї",["Ј"]="ј",["Љ"]="љ",["Њ"]="њ",["Ћ"]="ћ",["Ќ"]="ќ",["Ѝ"]="ѝ",["Ў"]="ў",["Џ"]="џ",["А"]="а",["Б"]="б",["В"]="в",["Г"]="г",["Д"]="д",["Е"]="е",["Ж"]="ж",["З"]="з",["И"]="и",["Й"]="й",["К"]="к",["Л"]="л",["М"]="м",["Н"]="н",["О"]="о",["П"]="п",["Р"]="р",["С"]="с",["Т"]="т",["У"]="у",["Ф"]="ф",["Х"]="х",["Ц"]="ц",["Ч"]="ч",["Ш"]="ш",["Щ"]="щ",["Ъ"]="ъ",["Ы"]="ы",["Ь"]="ь",["Э"]="э",["Ю"]="ю",["Я"]="я",["Ѡ"]="ѡ",["Ѣ"]="ѣ",["Ѥ"]="ѥ",["Ѧ"]="ѧ",["Ѩ"]="ѩ",["Ѫ"]="ѫ",["Ѭ"]="ѭ",["Ѯ"]="ѯ",["Ѱ"]="ѱ",["Ѳ"]="ѳ",["Ѵ"]="ѵ",["Ѷ"]="ѷ",["Ѹ"]="ѹ",["Ѻ"]="ѻ",["Ѽ"]="ѽ",["Ѿ"]="ѿ",["Ҁ"]="ҁ",["Ҋ"]="ҋ",["Ҍ"]="ҍ",["Ҏ"]="ҏ",["Ґ"]="ґ",["Ғ"]="ғ",["Ҕ"]="ҕ",["Җ"]="җ",["Ҙ"]="ҙ",["Қ"]="қ",["Ҝ"]="ҝ",["Ҟ"]="ҟ",["Ҡ"]="ҡ",["Ң"]="ң",["Ҥ"]="ҥ",["Ҧ"]="ҧ",["Ҩ"]="ҩ",["Ҫ"]="ҫ",["Ҭ"]="ҭ",["Ү"]="ү",["Ұ"]="ұ",["Ҳ"]="ҳ",["Ҵ"]="ҵ",["Ҷ"]="ҷ",["Ҹ"]="ҹ",["Һ"]="һ",["Ҽ"]="ҽ",["Ҿ"]="ҿ",["Ӏ"]="ӏ",["Ӂ"]="ӂ",["Ӄ"]="ӄ",["Ӆ"]="ӆ",["Ӈ"]="ӈ",["Ӊ"]="ӊ",["Ӌ"]="ӌ",["Ӎ"]="ӎ",["Ӑ"]="ӑ",["Ӓ"]="ӓ",["Ӕ"]="ӕ",["Ӗ"]="ӗ",["Ә"]="ә",["Ӛ"]="ӛ",["Ӝ"]="ӝ",["Ӟ"]="ӟ",["Ӡ"]="ӡ",["Ӣ"]="ӣ",["Ӥ"]="ӥ",["Ӧ"]="ӧ",["Ө"]="ө",["Ӫ"]="ӫ",["Ӭ"]="ӭ",["Ӯ"]="ӯ",["Ӱ"]="ӱ",["Ӳ"]="ӳ",["Ӵ"]="ӵ",["Ӷ"]="ӷ",["Ӹ"]="ӹ",["Ӻ"]="ӻ",["Ӽ"]="ӽ",["Ӿ"]="ӿ",["Ԁ"]="ԁ",["Ԃ"]="ԃ",["Ԅ"]="ԅ",["Ԇ"]="ԇ",["Ԉ"]="ԉ",["Ԋ"]="ԋ",["Ԍ"]="ԍ",["Ԏ"]="ԏ",["Ԑ"]="ԑ",["Ԓ"]="ԓ",["Ա"]="ա",["Բ"]="բ",["Գ"]="գ",["Դ"]="դ",["Ե"]="ե",["Զ"]="զ",["Է"]="է",["Ը"]="ը",["Թ"]="թ",["Ժ"]="ժ",["Ի"]="ի",["Լ"]="լ",["Խ"]="խ",["Ծ"]="ծ",["Կ"]="կ",["Հ"]="հ",["Ձ"]="ձ",["Ղ"]="ղ",["Ճ"]="ճ",["Մ"]="մ",["Յ"]="յ",["Ն"]="ն",["Շ"]="շ",["Ո"]="ո",["Չ"]="չ",["Պ"]="պ",["Ջ"]="ջ",["Ռ"]="ռ",["Ս"]="ս",["Վ"]="վ",["Տ"]="տ",["Ր"]="ր",["Ց"]="ց",["Ւ"]="ւ",["Փ"]="փ",["Ք"]="ք",["Օ"]="օ",["Ֆ"]="ֆ",["Ⴀ"]="ⴀ",["Ⴁ"]="ⴁ",["Ⴂ"]="ⴂ",["Ⴃ"]="ⴃ",["Ⴄ"]="ⴄ",["Ⴅ"]="ⴅ",["Ⴆ"]="ⴆ",["Ⴇ"]="ⴇ",["Ⴈ"]="ⴈ",["Ⴉ"]="ⴉ",["Ⴊ"]="ⴊ",["Ⴋ"]="ⴋ",["Ⴌ"]="ⴌ",["Ⴍ"]="ⴍ",["Ⴎ"]="ⴎ",["Ⴏ"]="ⴏ",["Ⴐ"]="ⴐ",["Ⴑ"]="ⴑ",["Ⴒ"]="ⴒ",["Ⴓ"]="ⴓ",["Ⴔ"]="ⴔ",["Ⴕ"]="ⴕ",["Ⴖ"]="ⴖ",["Ⴗ"]="ⴗ",["Ⴘ"]="ⴘ",["Ⴙ"]="ⴙ",["Ⴚ"]="ⴚ",["Ⴛ"]="ⴛ",["Ⴜ"]="ⴜ",["Ⴝ"]="ⴝ",["Ⴞ"]="ⴞ",["Ⴟ"]="ⴟ",["Ⴠ"]="ⴠ",["Ⴡ"]="ⴡ",["Ⴢ"]="ⴢ",["Ⴣ"]="ⴣ",["Ⴤ"]="ⴤ",["Ⴥ"]="ⴥ",["Ḁ"]="ḁ",["Ḃ"]="ḃ",["Ḅ"]="ḅ",["Ḇ"]="ḇ",["Ḉ"]="ḉ",["Ḋ"]="ḋ",["Ḍ"]="ḍ",["Ḏ"]="ḏ",["Ḑ"]="ḑ",["Ḓ"]="ḓ",["Ḕ"]="ḕ",["Ḗ"]="ḗ",["Ḙ"]="ḙ",["Ḛ"]="ḛ",["Ḝ"]="ḝ",["Ḟ"]="ḟ",["Ḡ"]="ḡ",["Ḣ"]="ḣ",["Ḥ"]="ḥ",["Ḧ"]="ḧ",["Ḩ"]="ḩ",["Ḫ"]="ḫ",["Ḭ"]="ḭ",["Ḯ"]="ḯ",["Ḱ"]="ḱ",["Ḳ"]="ḳ",["Ḵ"]="ḵ",["Ḷ"]="ḷ",["Ḹ"]="ḹ",["Ḻ"]="ḻ",["Ḽ"]="ḽ",["Ḿ"]="ḿ",["Ṁ"]="ṁ",["Ṃ"]="ṃ",["Ṅ"]="ṅ",["Ṇ"]="ṇ",["Ṉ"]="ṉ",["Ṋ"]="ṋ",["Ṍ"]="ṍ",["Ṏ"]="ṏ",["Ṑ"]="ṑ",["Ṓ"]="ṓ",["Ṕ"]="ṕ",["Ṗ"]="ṗ",["Ṙ"]="ṙ",["Ṛ"]="ṛ",["Ṝ"]="ṝ",["Ṟ"]="ṟ",["Ṡ"]="ṡ",["Ṣ"]="ṣ",["Ṥ"]="ṥ",["Ṧ"]="ṧ",["Ṩ"]="ṩ",["Ṫ"]="ṫ",["Ṭ"]="ṭ",["Ṯ"]="ṯ",["Ṱ"]="ṱ",["Ṳ"]="ṳ",["Ṵ"]="ṵ",["Ṷ"]="ṷ",["Ṹ"]="ṹ",["Ṻ"]="ṻ",["Ṽ"]="ṽ",["Ṿ"]="ṿ",["Ẁ"]="ẁ",["Ẃ"]="ẃ",["Ẅ"]="ẅ",["Ẇ"]="ẇ",["Ẉ"]="ẉ",["Ẋ"]="ẋ",["Ẍ"]="ẍ",["Ẏ"]="ẏ",["Ẑ"]="ẑ",["Ẓ"]="ẓ",["Ẕ"]="ẕ",["Ạ"]="ạ",["Ả"]="ả",["Ấ"]="ấ",["Ầ"]="ầ",["Ẩ"]="ẩ",["Ẫ"]="ẫ",["Ậ"]="ậ",["Ắ"]="ắ",["Ằ"]="ằ",["Ẳ"]="ẳ",["Ẵ"]="ẵ",["Ặ"]="ặ",["Ẹ"]="ẹ",["Ẻ"]="ẻ",["Ẽ"]="ẽ",["Ế"]="ế",["Ề"]="ề",["Ể"]="ể",["Ễ"]="ễ",["Ệ"]="ệ",["Ỉ"]="ỉ",["Ị"]="ị",["Ọ"]="ọ",["Ỏ"]="ỏ",["Ố"]="ố",["Ồ"]="ồ",["Ổ"]="ổ",["Ỗ"]="ỗ",["Ộ"]="ộ",["Ớ"]="ớ",["Ờ"]="ờ",["Ở"]="ở",["Ỡ"]="ỡ",["Ợ"]="ợ",["Ụ"]="ụ",["Ủ"]="ủ",["Ứ"]="ứ",["Ừ"]="ừ",["Ử"]="ử",["Ữ"]="ữ",["Ự"]="ự",["Ỳ"]="ỳ",["Ỵ"]="ỵ",["Ỷ"]="ỷ",["Ỹ"]="ỹ",["Ἀ"]="ἀ",["Ἁ"]="ἁ",["Ἂ"]="ἂ",["Ἃ"]="ἃ",["Ἄ"]="ἄ",["Ἅ"]="ἅ",["Ἆ"]="ἆ",["Ἇ"]="ἇ",["Ἐ"]="ἐ",["Ἑ"]="ἑ",["Ἒ"]="ἒ",["Ἓ"]="ἓ",["Ἔ"]="ἔ",["Ἕ"]="ἕ",["Ἠ"]="ἠ",["Ἡ"]="ἡ",["Ἢ"]="ἢ",["Ἣ"]="ἣ",["Ἤ"]="ἤ",["Ἥ"]="ἥ",["Ἦ"]="ἦ",["Ἧ"]="ἧ",["Ἰ"]="ἰ",["Ἱ"]="ἱ",["Ἲ"]="ἲ",["Ἳ"]="ἳ",["Ἴ"]="ἴ",["Ἵ"]="ἵ",["Ἶ"]="ἶ",["Ἷ"]="ἷ",["Ὀ"]="ὀ",["Ὁ"]="ὁ",["Ὂ"]="ὂ",["Ὃ"]="ὃ",["Ὄ"]="ὄ",["Ὅ"]="ὅ",["Ὑ"]="ὑ",["Ὓ"]="ὓ",["Ὕ"]="ὕ",["Ὗ"]="ὗ",["Ὠ"]="ὠ",["Ὡ"]="ὡ",["Ὢ"]="ὢ",["Ὣ"]="ὣ",["Ὤ"]="ὤ",["Ὥ"]="ὥ",["Ὦ"]="ὦ",["Ὧ"]="ὧ",["ᾈ"]="ᾀ",["ᾉ"]="ᾁ",["ᾊ"]="ᾂ",["ᾋ"]="ᾃ",["ᾌ"]="ᾄ",["ᾍ"]="ᾅ",["ᾎ"]="ᾆ",["ᾏ"]="ᾇ",["ᾘ"]="ᾐ",["ᾙ"]="ᾑ",["ᾚ"]="ᾒ",["ᾛ"]="ᾓ",["ᾜ"]="ᾔ",["ᾝ"]="ᾕ",["ᾞ"]="ᾖ",["ᾟ"]="ᾗ",["ᾨ"]="ᾠ",["ᾩ"]="ᾡ",["ᾪ"]="ᾢ",["ᾫ"]="ᾣ",["ᾬ"]="ᾤ",["ᾭ"]="ᾥ",["ᾮ"]="ᾦ",["ᾯ"]="ᾧ",["Ᾰ"]="ᾰ",["Ᾱ"]="ᾱ",["Ὰ"]="ὰ",["Ά"]="ά",["ᾼ"]="ᾳ",["Ὲ"]="ὲ",["Έ"]="έ",["Ὴ"]="ὴ",["Ή"]="ή",["ῌ"]="ῃ",["Ῐ"]="ῐ",["Ῑ"]="ῑ",["Ὶ"]="ὶ",["Ί"]="ί",["Ῠ"]="ῠ",["Ῡ"]="ῡ",["Ὺ"]="ὺ",["Ύ"]="ύ",["Ῥ"]="ῥ",["Ὸ"]="ὸ",["Ό"]="ό",["Ὼ"]="ὼ",["Ώ"]="ώ",["ῼ"]="ῳ",["Ω"]="ω",["K"]="k",["Å"]="å",["Ⅎ"]="ⅎ",["Ⅰ"]="ⅰ",["Ⅱ"]="ⅱ",["Ⅲ"]="ⅲ",["Ⅳ"]="ⅳ",["Ⅴ"]="ⅴ",["Ⅵ"]="ⅵ",["Ⅶ"]="ⅶ",["Ⅷ"]="ⅷ",["Ⅸ"]="ⅸ",["Ⅹ"]="ⅹ",["Ⅺ"]="ⅺ",["Ⅻ"]="ⅻ",["Ⅼ"]="ⅼ",["Ⅽ"]="ⅽ",["Ⅾ"]="ⅾ",["Ⅿ"]="ⅿ",["Ↄ"]="ↄ",["Ⓐ"]="ⓐ",["Ⓑ"]="ⓑ",["Ⓒ"]="ⓒ",["Ⓓ"]="ⓓ",["Ⓔ"]="ⓔ",["Ⓕ"]="ⓕ",["Ⓖ"]="ⓖ",["Ⓗ"]="ⓗ",["Ⓘ"]="ⓘ",["Ⓙ"]="ⓙ",["Ⓚ"]="ⓚ",["Ⓛ"]="ⓛ",["Ⓜ"]="ⓜ",["Ⓝ"]="ⓝ",["Ⓞ"]="ⓞ",["Ⓟ"]="ⓟ",["Ⓠ"]="ⓠ",["Ⓡ"]="ⓡ",["Ⓢ"]="ⓢ",["Ⓣ"]="ⓣ",["Ⓤ"]="ⓤ",["Ⓥ"]="ⓥ",["Ⓦ"]="ⓦ",["Ⓧ"]="ⓧ",["Ⓨ"]="ⓨ",["Ⓩ"]="ⓩ",["Ⰰ"]="ⰰ",["Ⰱ"]="ⰱ",["Ⰲ"]="ⰲ",["Ⰳ"]="ⰳ",["Ⰴ"]="ⰴ",["Ⰵ"]="ⰵ",["Ⰶ"]="ⰶ",["Ⰷ"]="ⰷ",["Ⰸ"]="ⰸ",["Ⰹ"]="ⰹ",["Ⰺ"]="ⰺ",["Ⰻ"]="ⰻ",["Ⰼ"]="ⰼ",["Ⰽ"]="ⰽ",["Ⰾ"]="ⰾ",["Ⰿ"]="ⰿ",["Ⱀ"]="ⱀ",["Ⱁ"]="ⱁ",["Ⱂ"]="ⱂ",["Ⱃ"]="ⱃ",["Ⱄ"]="ⱄ",["Ⱅ"]="ⱅ",["Ⱆ"]="ⱆ",["Ⱇ"]="ⱇ",["Ⱈ"]="ⱈ",["Ⱉ"]="ⱉ",["Ⱊ"]="ⱊ",["Ⱋ"]="ⱋ",["Ⱌ"]="ⱌ",["Ⱍ"]="ⱍ",["Ⱎ"]="ⱎ",["Ⱏ"]="ⱏ",["Ⱐ"]="ⱐ",["Ⱑ"]="ⱑ",["Ⱒ"]="ⱒ",["Ⱓ"]="ⱓ",["Ⱔ"]="ⱔ",["Ⱕ"]="ⱕ",["Ⱖ"]="ⱖ",["Ⱗ"]="ⱗ",["Ⱘ"]="ⱘ",["Ⱙ"]="ⱙ",["Ⱚ"]="ⱚ",["Ⱛ"]="ⱛ",["Ⱜ"]="ⱜ",["Ⱝ"]="ⱝ",["Ⱞ"]="ⱞ",["Ⱡ"]="ⱡ",["Ɫ"]="ɫ",["Ᵽ"]="ᵽ",["Ɽ"]="ɽ",["Ⱨ"]="ⱨ",["Ⱪ"]="ⱪ",["Ⱬ"]="ⱬ",["Ⱶ"]="ⱶ",["Ⲁ"]="ⲁ",["Ⲃ"]="ⲃ",["Ⲅ"]="ⲅ",["Ⲇ"]="ⲇ",["Ⲉ"]="ⲉ",["Ⲋ"]="ⲋ",["Ⲍ"]="ⲍ",["Ⲏ"]="ⲏ",["Ⲑ"]="ⲑ",["Ⲓ"]="ⲓ",["Ⲕ"]="ⲕ",["Ⲗ"]="ⲗ",["Ⲙ"]="ⲙ",["Ⲛ"]="ⲛ",["Ⲝ"]="ⲝ",["Ⲟ"]="ⲟ",["Ⲡ"]="ⲡ",["Ⲣ"]="ⲣ",["Ⲥ"]="ⲥ",["Ⲧ"]="ⲧ",["Ⲩ"]="ⲩ",["Ⲫ"]="ⲫ",["Ⲭ"]="ⲭ",["Ⲯ"]="ⲯ",["Ⲱ"]="ⲱ",["Ⲳ"]="ⲳ",["Ⲵ"]="ⲵ",["Ⲷ"]="ⲷ",["Ⲹ"]="ⲹ",["Ⲻ"]="ⲻ",["Ⲽ"]="ⲽ",["Ⲿ"]="ⲿ",["Ⳁ"]="ⳁ",["Ⳃ"]="ⳃ",["Ⳅ"]="ⳅ",["Ⳇ"]="ⳇ",["Ⳉ"]="ⳉ",["Ⳋ"]="ⳋ",["Ⳍ"]="ⳍ",["Ⳏ"]="ⳏ",["Ⳑ"]="ⳑ",["Ⳓ"]="ⳓ",["Ⳕ"]="ⳕ",["Ⳗ"]="ⳗ",["Ⳙ"]="ⳙ",["Ⳛ"]="ⳛ",["Ⳝ"]="ⳝ",["Ⳟ"]="ⳟ",["Ⳡ"]="ⳡ",["Ⳣ"]="ⳣ",["Ａ"]="ａ",["Ｂ"]="ｂ",["Ｃ"]="ｃ",["Ｄ"]="ｄ",["Ｅ"]="ｅ",["Ｆ"]="ｆ",["Ｇ"]="ｇ",["Ｈ"]="ｈ",["Ｉ"]="ｉ",["Ｊ"]="ｊ",["Ｋ"]="ｋ",["Ｌ"]="ｌ",["Ｍ"]="ｍ",["Ｎ"]="ｎ",["Ｏ"]="ｏ",["Ｐ"]="ｐ",["Ｑ"]="ｑ",["Ｒ"]="ｒ",["Ｓ"]="ｓ",["Ｔ"]="ｔ",["Ｕ"]="ｕ",["Ｖ"]="ｖ",["Ｗ"]="ｗ",["Ｘ"]="ｘ",["Ｙ"]="ｙ",["Ｚ"]="ｚ",["𐐀"]="𐐨",["𐐁"]="𐐩",["𐐂"]="𐐪",["𐐃"]="𐐫",["𐐄"]="𐐬",["𐐅"]="𐐭",["𐐆"]="𐐮",["𐐇"]="𐐯",["𐐈"]="𐐰",["𐐉"]="𐐱",["𐐊"]="𐐲",["𐐋"]="𐐳",["𐐌"]="𐐴",["𐐍"]="𐐵",["𐐎"]="𐐶",["𐐏"]="𐐷",["𐐐"]="𐐸",["𐐑"]="𐐹",["𐐒"]="𐐺",["𐐓"]="𐐻",["𐐔"]="𐐼",["𐐕"]="𐐽",["𐐖"]="𐐾",["𐐗"]="𐐿",["𐐘"]="𐑀",["𐐙"]="𐑁",["𐐚"]="𐑂",["𐐛"]="𐑃",["𐐜"]="𐑄",["𐐝"]="𐑅",["𐐞"]="𐑆",["𐐟"]="𐑇",["𐐠"]="𐑈",["𐐡"]="𐑉",["𐐢"]="𐑊",["𐐣"]="𐑋",["𐐤"]="𐑌",["𐐥"]="𐑍",["𐐦"]="𐑎",["𐐧"]="𐑏",}
--addons/_wlib/lua/wlib/modules/settings/cl_vars.lua:
waySettings = waySettings or {
    vars = {},
    data = {},
    VGUIElements = {},
}

local VAR = {}

wlib.accessor(VAR, 'id', 'ID')
wlib.accessor(VAR, 'name', 'Name')
wlib.accessor(VAR, 'category', 'Category')
wlib.accessor(VAR, 'elemId', 'ElementID')
wlib.accessor(VAR, 'convar', 'ConVar')
wlib.accessor(VAR, 'type', 'Type')
wlib.accessor(VAR, 'Check', 'Check')
wlib.accessor(VAR, 'OnChange', 'OnChange')

function VAR:SetConVar(convar, type)
    self.convar = convar
    self.type = type

    return self
end

function VAR:GetValue(fallback)
    if self.convar then
        local cvar = GetConVar(self.convar)
        if not cvar then return end

        if self:GetType() == TYPE_BOOL then
            return cvar:GetBool()
        elseif self:GetType() == TYPE_NUMBER then
            return cvar:GetFloat()
        else
            return cvar:GetString()
        end
    else
        return waySettings.data[self:GetID()] or fallback
    end
end

function VAR:SetValue(val, noSave)
    if not istable(val) and self:GetValue() == val then return end
    if self.OnChange then self:OnChange(self:GetValue(), val) end

    if self.convar then
        local cvar = GetConVar(self.convar)
        if not cvar then return end

        if isbool(val) then
            cvar:SetBool(val)
        elseif isnumber(val) then
            if val%1 == 0 then
                cvar:SetInt(val)
            else
                cvar:SetFloat(val)
            end
        else
            cvar:SetString(tostring(val))
        end
    else
        waySettings.data[self:GetID()] = val
        if not noSave then waySettings.save() end
    end
end

function VAR:GetVGUIElement()
    local preset = waySettings.VGUIElements[self:GetElementID()]
    if not preset then return end

    return preset(self, unpack(self.vguiData or {}))
end

VAR.__index = VAR

function waySettings.registerVar(id, name, category, elemId, default, ...)
    local new = setmetatable({
        id = id,
        name = name,
        category = category,
        elemId = elemId,
        vguiData = {...},
    }, VAR)

    waySettings.vars[id] = new

    if default and new:GetValue() == nil then new:SetValue(default) end

    return new
end

function waySettings.getVar(id)
    return waySettings.vars[id]
end

function waySettings.getValue(id, fallback)
    local var = waySettings.getVar(id)
    if not var then return fallback end
    return var:GetValue(fallback)
end

function waySettings.setValue(id, value)
    local var = waySettings.getVar(id)
    return var:SetValue(value)
end

function waySettings.save()
    file.Write('waysettings_vars.dat', util.TableToJSON(waySettings.data))
end
function waySettings.load()
    if not file.Exists('waysettings_vars.dat', 'DATA') then return end
    local d = util.JSONToTable(file.Read('waysettings_vars.dat', 'DATA'))
    table.Merge(waySettings.data, d)
    for id, val in pairs(d) do
        local var = waySettings.getVar(id)
        if var and var.OnChange then var:OnChange(val, val) end
    end
end

-- CUSTOM VARS

waySettings.registerVar('wayskin_enable', 'Темная тема', 'Интерфейс', 'bool'):SetConVar('wayskin_enable', TYPE_BOOL)
waySettings.registerVar('gmod_drawhelp', 'Отображать подсказки для инструментов в Tool Gun', 'Интерфейс', 'bool'):SetConVar('gmod_drawhelp', TYPE_BOOL)
waySettings.registerVar('wrp_nlr_enabled', 'Отображать NLR-метки при смерти', 'Интерфейс', 'bool'):SetConVar('wrp_nlr_enabled', TYPE_BOOL)
waySettings.registerVar('hud_weapon', 'Отображать меню выбора оружия', 'Интерфейс', 'bool'):SetConVar('hud_weapon', TYPE_BOOL)
waySettings.registerVar('wrp_notifies_enabled', 'Отображать уведомления', 'Интерфейс', 'bool'):SetConVar('wrp_notifies_enabled', TYPE_BOOL)
waySettings.registerVar('pointshop_notify_enable', 'Отображать уведомления о покупках в донате', 'Интерфейс', 'bool'):SetConVar('pointshop_notify_enable', TYPE_BOOL)
waySettings.registerVar('hide_ooc', 'Скрыть OOC-чат', 'Интерфейс', 'bool')
waySettings.registerVar('wrp_afk_blur', 'Включить размытие игры в AFK', 'Интерфейс', 'bool'):SetConVar('wrp_afk_blur', TYPE_BOOL)
waySettings.registerVar('wayscore_opacity', 'Непрозрачность таблицы игроков', 'Интерфейс', 'numslider', nil, 0, 1, 2):SetConVar('wayscore_opacity', TYPE_NUMBER)
waySettings.registerVar('wayhud_scale', 'Размер интерфейса', 'Интерфейс', 'numslider', nil, 0.5, 1.5, 2):SetConVar('wayhud_scale', TYPE_NUMBER)
waySettings.registerVar('waypass_show_challenge_progress', 'Отображать прогресс заданий боевого пропуска', 'Интерфейс', 'bool'):SetConVar('waypass_show_challenge_progress', TYPE_BOOL)
waySettings.registerVar('wayhud_controls_enable', 'Отображать подсказки для оружия', 'Интерфейс', 'bool'):SetConVar('wayhud_controls_enable', TYPE_BOOL)
--[[
waySettings.registerVar('wrp_notifies_align', 'Положение уведомлений', 'Интерфейс', 'combobox', nil, {
    {name = 'Снизу посередине', data = 2},
    {name = 'Снизу справа', data = 3},
    {name = 'Сверху справа', data = 9},
}):SetConVar('wrp_notifies_align', TYPE_NUMBER)
]]

waySettings.registerVar('wowozela_volume', 'Громкость Вовозелки', 'Игра', 'numslider', nil, 0, 1, 2):SetConVar('wowozela_volume', TYPE_NUMBER)
waySettings.registerVar('outfitter_enabled', 'Пользовательские скины', 'Игра', 'bool'):SetConVar('outfitter_enabled', TYPE_BOOL)
waySettings.registerVar('urlpaint_enabled', 'URL-картины', 'Игра', 'bool'):SetConVar('urlpaint_enabled', TYPE_BOOL)
waySettings.registerVar('wayfog_distance', 'Дальность прорисовки', 'Игра', 'numslider', nil, 1000, 8000):SetConVar('wayfog_distance', TYPE_NUMBER)
waySettings.registerVar('wayvape_particles', 'Частицы от вейпов', 'Игра', 'bool'):SetConVar('wayvape_particles', TYPE_BOOL)
waySettings.registerVar('wayradio_volume', 'Громкость радио/TV', 'Игра', 'numslider', nil, 0, 1, 2):SetConVar('wayradio_volume', TYPE_NUMBER)
waySettings.registerVar('wayskybox', 'Цвет неба', 'Игра', 'combobox', nil, {
    {name = 'Стандартный', data = ''},
    'sky_borealis01', 'sky_day01_01', 'sky_day01_05', 'sky_day01_06',
    'sky_day01_08', 'sky_day01_09', 'sky_day02_01', 'sky_day02_07',
    'sky_day03_02', 'sky_day03_05', 'sky_day03_06', 'sky_wasteland02',
    'italy', 'jungle', 'militia_hdr',
}):SetConVar('wayskybox', TYPE_STRING)
waySettings.registerVar('wrp_govorilka_lowquality', 'Пониженное качество говорилки (для плохого интернета)', 'Игра', 'bool'):SetConVar('wrp_govorilka_lowquality', TYPE_BOOL)

waySettings.registerVar('swb_enable_shells', 'Отображать гильзы от оружия', 'Оружие', 'bool'):SetConVar('swb_enable_shells', TYPE_BOOL)
waySettings.registerVar('swb_enable_crosshair', 'Отображать прицел оружия', 'Оружие', 'bool'):SetConVar('swb_enable_crosshair', TYPE_BOOL)
waySettings.registerVar('swb_viewmodel_addfov', 'Отдаление рук с оружием в руках', 'Оружие', 'numslider', nil, 0, 45, 0):SetConVar('swb_viewmodel_addfov', TYPE_NUMBER)
waySettings.registerVar('swb_viewmodel_offset_x', 'Положение рук с оружием (влево-вправо)', 'Оружие', 'numslider', nil, -2, 2, 1):SetConVar('swb_viewmodel_offset_x', TYPE_NUMBER)
waySettings.registerVar('swb_viewmodel_offset_y', 'Положение рук с оружием (вперед-назад)', 'Оружие', 'numslider', nil, -2, 2, 1):SetConVar('swb_viewmodel_offset_y', TYPE_NUMBER)
waySettings.registerVar('swb_viewmodel_offset_z', 'Положение рук с оружием (вверх-вниз)', 'Оружие', 'numslider', nil, -2, 2, 1):SetConVar('swb_viewmodel_offset_z', TYPE_NUMBER)
local cvar_righthand = CreateClientConVar('wrp_righthand', 1, true)
cvars.AddChangeCallback('wrp_righthand', function()
    for _, v in ipairs(weapons.GetList()) do
        v.ViewModelFlip = not v.ViewModelFlip
    end
    for _, v in ipairs(LocalPlayer():GetWeapons()) do
        v.ViewModelFlip = not v.ViewModelFlip
    end
end, 'weapons')
hook.Add('Think', 'wrp_righthand', function()
    hook.Remove('Think', 'wrp_righthand')
    if not cvar_righthand:GetBool() then
        for _, v in ipairs(weapons.GetList()) do
            v.ViewModelFlip = not v.ViewModelFlip
        end
        for _, v in ipairs(LocalPlayer():GetWeapons()) do
            v.ViewModelFlip = not v.ViewModelFlip
        end
    end
end)
waySettings.registerVar('wrp_righthand', 'Оружие в правой руке', 'Оружие', 'bool'):SetConVar('wrp_righthand', TYPE_BOOL)

waySettings.registerVar('dradio_bind_key', 'Голосовой чат в рации', 'Бинды', 'binder'):SetConVar('dradio_bind_key', TYPE_NUMBER)
waySettings.registerVar('waymap_bind', 'Открыть карту', 'Бинды', 'binder'):SetConVar('waymap_bind', TYPE_NUMBER)
waySettings.registerVar('dorgs_marker_bind', 'Создать метку на экране соклановцев', 'Бинды', 'binder'):SetConVar('dorgs_marker_bind', TYPE_NUMBER)
waySettings.registerVar('swb_bind_zoomout', 'Отдалить снайперский прицел', 'Бинды', 'binder'):SetConVar('swb_bind_zoomout', TYPE_NUMBER)
waySettings.registerVar('swb_bind_zoomin', 'Приблизить снайперский прицел', 'Бинды', 'binder'):SetConVar('swb_bind_zoomin', TYPE_NUMBER)

local function isadmin()
    local lp = LocalPlayer()
    return lp:GetUserGroup() ~= 'user' and lp:GetUserGroup() ~= 'VIP' -- ЕБАЛ
end
waySettings.registerVar('FPP_PrivateSettings_OtherPlayerProps', 'Отключить перемещение чужих пропов', 'Админ-настройки', 'bool')
    :SetCheck(isadmin)
    :SetConVar('FPP_PrivateSettings_OtherPlayerProps', TYPE_BOOL)
waySettings.registerVar('cl_pickupplayers', 'Включить подъем игроков', 'Админ-настройки', 'bool')
    :SetCheck(isadmin)
    :SetConVar('cl_pickupplayers', TYPE_BOOL)

--

waySettings.load()
hook.Run('waySettings.loaded')
--addons/_wlib/lua/wlib/modules/settings/cl_vgui.lua:
waySettings = waySettings or {
    vars = {},
    data = {},
    VGUIElements = {},
}

waySettings.VGUIElements['bool'] = function(var)
    local check = vgui.Create('DCheckBoxLabel')
    check:SetText(var:GetName())
    check:SetChecked(var:GetValue())
    check.OnChange = function(self, val)
        var:SetValue(val)
    end
    if var:GetValue() then check:SetValue(var:GetValue()) end

    return check
end

waySettings.VGUIElements['numslider'] = function(var, min, max, decimals)
    local slider = vgui.Create('DNumSlider')
    slider:SetText(var:GetName())
    slider:SetMinMax(min, max)
    slider:SetDecimals(decimals or 0)
    --slider.Label:SetFont('chelog-ib.small')
    slider.OnValueChanged = function(self, val)
        var:SetValue(val)
    end
    if var:GetValue() then slider:SetValue(var:GetValue()) end

    return slider
end

waySettings.VGUIElements['binder'] = function(var)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local binder = vgui.Create('DBinder', pnl)
    binder:Dock(RIGHT)
    binder:SetWide(80)
    binder.OnChange = function(self, val)
        var:SetValue(val)
    end
    if var:GetValue() then binder:SetValue(var:GetValue()) end

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    --label:SetFont('chelog-ib.small')
    label:SetText(var:GetName())

    return pnl
end

waySettings.VGUIElements['combobox'] = function(var, options)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local combo = vgui.Create('DComboBox', pnl)
    combo:Dock(RIGHT)
    combo:SetWide(140)
    combo:SetSortItems(false)

    for _, v in pairs(options) do
        if istable(v) then
            combo:AddChoice(v.name, v.data, var:GetValue() == v.data, v.icon)
        else
            combo:AddChoice(v, v, var:GetValue() == v)
        end
    end
    combo.OnSelect = function(self, id, name, data)
        var:SetValue(data)
    end

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    label:SetText(var:GetName())

    return pnl
end

waySettings.VGUIElements['textentry'] = function(var, placeholder)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local entry = vgui.Create('DTextEntry', pnl)
    entry:Dock(RIGHT)
    entry:SetWide(210)
    entry:SetPlaceholderText(placeholder or '')
    entry.OnLoseFocus = function(self)
        var:SetValue(self:GetValue() == '' and nil or self:GetValue())
    end
    entry.OnEnter = function(self)
        var:SetValue(self:GetValue() == '' and nil or self:GetValue())
    end

    if var:GetValue() then entry:SetValue(var:GetValue()) end

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    label:SetText(var:GetName())

    return pnl
end

waySettings.VGUIElements['button'] = function(var, text, cb)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local btn = vgui.Create('DButton', pnl)
    btn:Dock(RIGHT)
    btn:SetText(text or 'Настроить')
    btn:SizeToContents()
    btn:SetTall(22)
    btn.DoClick = fp{cb, var}

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    label:SetText(var:GetName())

    return pnl
end

--

local frame
function waySettings.openFrame()
    if IsValid(frame) then frame:Close() end

    frame = vgui.Create('DFrame')
    frame:SetSize(550, ScrH() * 0.5)
    frame:SetTitle('Настройки')
    frame:SetIcon('icon16/cog.png')
    frame:Center()
    frame:SetSkin('WayZer')
    frame:MakePopup()

    local tabs = vgui.Create('DPropertySheet', frame)
    tabs:Dock(FILL)
    tabs.Tabs = {}

    for id, var in SortedPairsByMemberValue(waySettings.vars, 'elemId') do
        if var.Check and var:Check() == false then continue end

        local el = var:GetVGUIElement()
        if not IsValid(el) then continue end

        local scroll = tabs.Tabs[var:GetCategory()]
        if not scroll then
            scroll = vgui.Create('DScrollPanel', tabs)
            scroll:Dock(FILL)
            tabs.Tabs[var:GetCategory()] = scroll
        end

        el:SetParent(scroll)
        el:Dock(TOP)
        el:DockMargin(8,2,8,4)
    end

    for cat, tab in pairs(tabs.Tabs) do
        tabs:AddSheet(cat, tab)
    end

    return frame
end
--addons/_wlib/lua/wlib/modules/array.lua:
wlib.array = wlib.array or {}

function wlib.array.filter(tbl, func)
    local a = {}
    for k, v in ipairs(tbl) do
        if func(v, k, tbl) then a[#a+1] = v end
    end
    return a
end

function wlib.array.map(tbl, func)
    local a = {}
    local i = 1
    for k, v in ipairs(tbl) do
        a[i] = func(v, k, tbl)
        i = i + 1
    end
    return a
end

function wlib.array.find(tbl, func, start)
    start = start or 1
    for i=start, #tbl do
        if func(tbl[i], i, tbl) then return tbl[i], i end
    end
end

function wlib.array.toKeys(tbl, val)
    if val == nil then val = true end

    local a = {}
    for _, v in ipairs(tbl) do
        a[v] = val
    end
    return a
end
--addons/_wlib/lua/wlib/modules/delays/client.lua:
hook.Add('DelaysUpdated', 'delays', function(ply, val)
    ply.delayIDs = {}
    for k, v in ipairs(val) do
        if not ply.delayIDs then return end
        ply.delayIDs[v.id] = k
    end
end)

local PLAYER = FindMetaTable('Player')
function PLAYER:GetDelay(id)
    return self:GetNetVar('Delays') and self:GetNetVar('Delays')[self.delayIDs[id] or -1]
end

--

local font = 'chelog-ib.small'
local radius = 60
local color_dark = Color(43,49,54, 245)
local color_bright = Color(236,113,71)

local blur = wlib.Circles.New(CIRCLE_FILLED, radius, ScrW()/2, ScrH()/2, 3, 10)
blur:SetMaterial(true)
blur:SetColor(color_dark)

local progress = wlib.Circles.New(CIRCLE_FILLED, radius, ScrW()/2, ScrH()/2)
progress:SetMaterial(true)
progress:SetColor(color_bright)
progress:SetStartAngle(-90)

hook.Add('HUDPaint', 'drawdelay', function()
    local delays = LocalPlayer():GetNetVar('Delays')
    if not delays or #delays == 0 then return end

    local d
    local elapsed
    for i = #delays, 1, -1 do
        d = delays[i]
        elapsed = d.duration * d.startProgress + (CurTime() - d.start)
        if elapsed > d.duration then
            delays[i] = nil
            d = nil
            return
        end

        break
    end

    local text = d.text
    for i=1, math.floor((CurTime()-delays[1].start)/0.5%3)+1 do
        text = text..'.'
    end

    surface.SetFont(font)
    local w, h = surface.GetTextSize(text)
    local allh = radius+h

    local y = ScrH()/2 - allh/2

    blur:SetY(y)
    blur()

    progress:SetY(y)
    progress:SetEndAngle(360*(elapsed/d.duration) - 90)
    progress()

	surface.SetTextColor(color_white)
    surface.SetTextPos(ScrW()/2 - w/2, ScrH()/2 + allh/2 - h/2)
    surface.DrawText(text)
end)
--addons/_wlib/lua/wlib/modules/incognito/shared.lua:
local pmeta = FindMetaTable('Player')
local blank = wlib.func.blank

hook.Add('Think', 'wlib.incognito.sh', function()
    hook.Remove('Think', 'wlib.incognito.sh')

    pmeta.RealName = pmeta.RealName or pmeta.Name or blank
    function pmeta:DisplayName()
        local d = self:GetNetVar('Incognito')
        if d and d.name then return d.name end

        return self:RealName()
    end

    pmeta.RealSteamName = pmeta.RealSteamName or pmeta.SteamName or blank
    function pmeta:DisplaySteamName()
        local d = self:GetNetVar('Incognito')
        if d and d.steamname then return d.steamname end

        return self:RealSteamName()
    end

    pmeta.GetRealUserGroup = pmeta.GetRealUserGroup or pmeta.GetUserGroup or blank
    function pmeta:GetDisplayUserGroup()
        local d = self:GetNetVar('Incognito')
        if d and d.usergroup then return d.usergroup end

        return self:GetRealUserGroup()
    end

    pmeta.RealSteamID = pmeta.RealSteamID or pmeta.SteamID or blank
    function pmeta:DisplaySteamID()
        local d = self:GetNetVar('Incognito')
        if d and d.steamid then return d.steamid end

        return self:RealSteamID()
    end

    pmeta.RealSteamID64 = pmeta.RealSteamID64 or pmeta.SteamID64 or blank
    function pmeta:DisplaySteamID64()
        local d = self:GetNetVar('Incognito')
        if d and d.steamid64 then return d.steamid64 end

        return self:RealSteamID64()
    end

    pmeta.GetRealUTime = pmeta.GetRealUTime or pmeta.GetUTime or blank
    function pmeta:GetDisplayUTime()
        local d = self:GetNetVar('Incognito')
        if d and d.utimetotal then return d.utimetotal end

        return self:GetRealUTime()
    end

    pmeta.GetRealUTimeStart = pmeta.GetRealUTimeStart or pmeta.GetUTimeStart or blank
    function pmeta:GetDisplayUTimeStart()
        local d = self:GetNetVar('Incognito')
        if d and d.utimestart then return d.utimestart end

        return self:GetRealUTimeStart()
    end

    pmeta.GetRealUTimeSessionTime = pmeta.GetRealUTimeSessionTime or pmeta.GetUTimeSessionTime or blank
    function pmeta:GetDisplayUTimeSessionTime()
        return CurTime() - self:GetDisplayUTimeStart()
    end
    
    pmeta.GetRealUTimeTotalTime = pmeta.GetRealUTimeTotalTime or pmeta.GetUTimeTotalTime or blank
    function pmeta:GetDisplayUTimeTotalTime()
        return self:GetDisplayUTime() + self:GetDisplayUTimeSessionTime()
    end

    pmeta.GetRealMainOrgID = pmeta.GetRealMainOrgID or pmeta.GetMainOrgID or blank
    function pmeta:GetDisplayMainOrgID()
        local d = self:GetNetVar('Incognito')
        if d and d.hideclan then return nil end

        return self:GetRealMainOrgID()
    end
end)

nw.Register('Incognito')
    :Read(net.ReadTable)
    :Write(net.WriteTable)
    :SetPlayer()
--addons/_wlib/lua/wlib/modules/longpoll.lua:
wlib.longpoll = wlib.longpoll or {
    connections = {}
}

for _, v in ipairs(wlib.longpoll.connections) do
    v:stop()
end

local longpoll_class = {}
function longpoll_class:start()
    self.running = true
    self.id = table.insert(wlib.longpoll.connections, self)
    self.ts = 0
    
    self:fetch()
end

function longpoll_class:fetch()
    http.Fetch(self.url:format(self.ts), function(body)
        if not self.running then return end
        local t = util.JSONToTable(body)
        self:callback(t or false)

        self:fetch()
    end, self.failback or function()
        self:callback(false)

        self:fetch()
    end)
end

function longpoll_class:stop()
    self.running = false
    table.RemoveByValue(wlib.longpoll.connections, self)
end

function wlib.longpoll.create(url, cb, fail)
    local poll = {}
    setmetatable(poll, {__index = longpoll_class})

    poll.url = url
    poll.callback = cb
    poll.failback = fail

    return poll
end
--addons/_wlib/lua/wlib/modules/players/client.lua:
local PLAYER = FindMetaTable('Player')

function PLAYER:GetAvatar()
    return self.steamavatar
end

hook.Add('SteamAvatarUpdated', 'avatar', function(ply)
    timer.Simple(0, function()
        if not IsValid(ply) then return end
        http.DownloadMaterial(ply:GetAvatarURL('full'), nil, function(mat)
            if IsValid(ply) then
                ply.steamavatar = mat and not mat:IsError() and mat
            end
        end)
    end)
end)
--addons/_wlib/lua/wlib/modules/servers/shared.lua:
wlib.servers = wlib.servers or {}
wlib.servers.list = {
    {
        name = 'Riverton',
        ip = '46.174.54.203',
        port = '27015',
    },
    {
        name = 'Minton',
        ip = '46.174.54.52',
        port = '27015',
    },
    {
        name = 'Carlin',
        ip = '37.230.228.180',
        port = '27015',
    },
    {
        name = 'Brooks',
        ip = '62.122.213.48',
        port = '27015',
    },
    {
        name = 'Rockford',
        ip = '37.230.162.208',
        port = '27015',
    },
}

function wlib.servers.get(ip)
    return wlib.array.find(wlib.servers.list, function(s)
        return s.ip == ip or s.ip..':'..s.port == ip
    end)
end

function wlib.servers.nameFromIP(ip)
    local s = wlib.servers.get(ip)
    return s and s.name or ip
end


local current
function wlib.servers.getCurrent()
    if not current then
        current = wlib.servers.get(game.GetIPAddress())
    end
    return current
end

function wlib.servers.getCurrentID()
    return wlib.servers.getCurrent() and wlib.servers.getCurrent().ip
end
--addons/_wlib/lua/wlib/modules/_client/draw.lua:
local surface_SetDrawColor = surface.SetDrawColor
local math_floor = math.floor
local surface_DrawLine = surface.DrawLine

function draw.Grid(x, y, w, h, gw, gh, color)
    surface_SetDrawColor(color)
    
    local wcount, hcount = math_floor(w/gw), math_floor(h/gh)

    for i=0, wcount do
        surface_DrawLine(x+i*gw, y, x+i*gw, y+h)
    end
    for i=0, hcount do
        surface_DrawLine(x, y+i*gh, x+w, y+i*gh)
    end
end
--addons/module_scoreboard/lua/autorun/wayscore_init.lua:
wayscore = wayscore or {}

if SERVER then
    for _, v in ipairs(file.Find('wayscore/vgui/*', 'LUA') or {}) do
        AddCSLuaFile('wayscore/vgui/'..v)
    end

    AddCSLuaFile('wayscore/core.lua')
    AddCSLuaFile('wayscore/util.lua')
else
    include('wayscore/core.lua')
    include('wayscore/util.lua')
    
    for _, v in ipairs(file.Find('wayscore/vgui/*', 'LUA') or {}) do
        include('wayscore/vgui/'..v)
    end

    surface.CreateFont("wayscore", {
        font = "Roboto Bold",
        size = 48,
        weight = 500,
        extended = true,
    })
    
    surface.CreateFont("wayscore-shadow", {
        font = "Roboto Bold",
        size = 48,
        weight = 500,
        extended = true,
        blursize = 7,
    })
    
    surface.CreateFont("wayscore.small", {
        font = "Roboto",
        size = 22,
        weight = 500,
        extended = true,
    })
end
--addons/module_scoreboard/lua/wayscore/vgui/playerlist.lua:
local PANEL = {}
local color_scroll = Color(38, 42, 46, 255)

function PANEL:Init()
    self:Dock(FILL)
    self.SortBox = vgui.Create('Panel', self)
    self.SortBox:Dock(TOP)
    self.SortBox:DockMargin(10, 6, 0, 0)
    self.SortBox:SetTall(30)

    self.Search = vgui.Create('DImageButton', self.SortBox)
    self.Search:SetImage('icon72/mag.png')
    self.Search:SetTooltip('Поиск по игрокам')
    self.Search.DoClick = function()
        if self.SearchEntry:IsVisible() then
            self.SearchEntry:Hide()
        else
            self.SearchEntry:Show()
        end
    end

    self.Sorts = {}


    for k, v in ipairs(wayscore.info or {}) do
        if v.check and not v.check() then continue end

        local check = vgui.Create('DImageButton', self.SortBox)
        check.info = table.Copy(v)
        check:SetImage(v.icon)
        check:SetTooltip(v.name)
        check:SetSize(30, 30)
        local id = table.insert(self.Sorts, check)
        check.id = id
        check.DoClick = function(s, val)
            self:Sort(id, val)
        end
    end

    self.LocalPlayer = vgui.Create('wayscore_player', self)
    self.LocalPlayer:Dock(TOP)
    self.LocalPlayer:DockMargin(0, 6, 0, 0)
    self.LocalPlayer:InvalidateLayout()
    self.LocalPlayer:SetPlayer(LocalPlayer())

    self.PlayerList = vgui.Create('DScrollPanel', self)
    self.PlayerList:Dock(FILL)

    local vbar = self.PlayerList:GetVBar()
    vbar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h - 20, Color(60,60,60))
    end
    vbar.btnUp.Paint = function( s, w, h ) end
    vbar.btnDown.Paint = function( s, w, h ) end
    vbar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h, color_scroll)
    end
    
    --self.PlayerList:DockMargin(0, 6, 0, 0)

    self.Players = player.GetAll()
    self:Sort()

    --[[
    timer.Create('wayscore_addplayers', .5, 0, function()
        if not IsValid(self) then return timer.Remove('wayscore_fetchplayers') end
        self.Players = player.GetAll()
        self:Sort()
    end)
    ]]

    self.SearchEntry = vgui.Create('DTextEntry', self)
    self.SearchEntry:SetSize(180, 25)
    self.SearchEntry:SetVisible(false)
    self.SearchEntry:SetUpdateOnType(true)
    self.SearchEntry:SetFont('chelog-ib.small')
    self.SearchEntry:AllowInput(true)
    self.SearchEntry:MakePopup()

    self.SearchEntry.Hover = Color(170, 78, 48)
    self.SearchEntry.Selected = Color(236, 113, 73)
    self.SearchEntry.idle = Color(0, 0, 0)
    self.SearchEntry.Color = self.SearchEntry.idle
    self.SearchEntry.Showing = 0
    self.SearchEntry.Showing2 = 150

    function self.SearchEntry:Paint(w,h)
        self.Last = self.Color

        if self:IsEditing() then
            self.Color = self.Selected
        elseif self:IsHovered() then
            self.Color = self.Hover
        else
            self.Color = self.idle
        end

        if self.Last ~= self.Color then
            self.Showing = 0
            self.Showing2 = 150
        end

        if self.Showing <= 150 then
            self.Showing = Lerp(FrameTime() * 3, self.Showing, 150)
        end

        if self.Showing2 ~= 0 then
            self.Showing2 = Lerp(FrameTime() * 3, self.Showing2, 0)
        end

        draw.RoundedBox(0, w / 2 - 1, h - h / 10, self.Showing, h / 10, self.Color)
        draw.RoundedBox(0, self.Showing2 + 1, h - h / 10, (w / 2) - self.Showing2, h / 10, self.Color)
        self:DrawTextEntryText(Color(255, 255, 255), Color(0, 0, 0), Color(255, 255, 255))
    end

    self.SearchEntry.Show = function()
        self.SearchEntry:SetVisible(true)
        wayscore.fixed = true

        self.SearchEntry:SetValue('')
        self:Filter()

        hook.Add('ShouldOpenEscapeMenu', 'wayscore', function()
            if IsValid(self.SearchEntry) and self.SearchEntry:HasFocus() then return false end
        end)
    end
    self.SearchEntry.Hide = function()
        self.SearchEntry:SetVisible(false)
        wayscore.fixed = false

        self.SearchEntry:SetValue('')
        self:Filter()
    end

    self.SearchEntry.OnValueChange = function(s, val)
        self:Filter(val)
    end
    self.SearchEntry.OnKeyCode = function(s, key)
        if key == KEY_ESCAPE then
            self.SearchEntry:Hide()
            gui.HideGameUI()
        end
    end
end

local function getx(offset, tw, wide, align)
    if align == TEXT_ALIGN_CENTER then
        return offset+tw/2-wide/2
    elseif align == TEXT_ALIGN_LEFT then
        return offset
    elseif align == TEXT_ALIGN_RIGHT then
        return offset+tw-wide
    end
end

function PANEL:PerformLayout(w, h)
    self.Search:SetSize(self.SortBox:GetTall()-4, self.SortBox:GetTall()-4)
    self.Search:SetPos(2, 2)

    --self.SearchEntry:SetX(self:LocalToScreen(self:GetWide()/2 - self.SearchEntry:GetWide()/2))
    --self.SearchEntry:SetY(self:LocalToScreen(self:GetTall()-self.SearchEntry:GetTall()))

    self.SearchEntry:SetX(ScrW()/2 - self.SearchEntry:GetWide()/2)
    self.SearchEntry:SetY(ScrH()/2 + self:GetTall()/2 - self.SearchEntry:GetTall() - 10)

    local canvas = self.PlayerList:GetCanvas()

    local offset = 64-8
    for k, v in ipairs(self.Sorts) do
        local piece = math.floor((canvas:GetWide()-64-8)*v.info.size)

        local x = v.info.center and (w-68)/2 or getx(offset, piece, v:GetWide(), v.info.align)
        v:SetPos(x, self.SortBox:GetTall()/2-v:GetTall()/2)
        
        offset = offset+piece
    end

    self.LocalPlayer:DockMargin(4, 6, self.PlayerList.VBar:IsVisible() and self.PlayerList.VBar:GetWide()+4 or 4, 7)
end

local cvar_sort = GetConVar('wayscore_sort')
local cvar_desc = GetConVar('wayscore_sort_desc')

function PANEL:Sort(id, desc)
    id = id == nil and cvar_sort:GetInt() or id
    desc = desc == nil and cvar_desc:GetBool() or desc
    local sort = self.Sorts[id]
    if not sort then return end

    cvar_sort:SetInt(id)
    cvar_desc:SetBool(desc)

    local pls = table.Copy(self.Players)
    table.sort(pls, function(a, b)
        if not IsValid(a) or not IsValid(b) then return true end
        local ares, bres = sort.info.get(a), sort.info.get(b)
        if not ares then return true end
        if not bres then return false end
        
        if desc then
            return ares > bres
        else
            return ares < bres
        end
    end)
    self:Clear()

    local lp = LocalPlayer()
    for _, v in ipairs(pls) do
        if v == lp then continue end
        self:AddPlayer(v)
    end
end

function PANEL:Filter(val)
    local a = {}
    for _, v in player.Iterator() do
        if not val or v:SteamID() == val or wayscore.lower(v:Name()):match(wayscore.lower(val)) then
            table.insert(a, v)
        end
    end
    self.Players = a
    self:Sort()
end

function PANEL:AddPlayer(ply)
    local row = self.PlayerList:Add('wayscore_player')
    row:InvalidateLayout()
    row:SetPlayer(ply)
    self.Players[#self.Players+1] = ply
end

function PANEL:Clear()
    self.PlayerList:Clear()
    self.Players = {}
end

function PANEL:Select()
    self.Players = player.GetAll()
    self:Sort()
end

vgui.Register('wayscore_playerlist', PANEL, 'Panel')
--addons/module_scoreboard/lua/wayscore/vgui/playerrow.lua:
local usergroups = {
    ['superadmin'] = 'icon72/wrench.png',
    ['WayZer Team'] = 'icon72/scales.png',
    ['Trusted'] = 'icon72/eagle.png',
    ['admin'] = 'icon72/shield.png',
    ['moder'] = 'icon72/military_medal.png',
    ['+Helper'] = 'icon72/briefcase.png',
    ['Helper'] = 'icon72/briefcase.png',
    ['+Eventer'] = 'icon72/beginner.png',
    ['Eventer'] = 'icon72/game_die.png',
    ['Patron'] = 'icon72/crown.png',
    ['Curator'] = 'icon72/gem.png',
    ['DSAdmin'] = 'icon72/fleur_de_lis.png',
    ['DAdmin'] = 'icon72/diamond_shape_with_a_dot_inside.png',
    ['DModerator'] = 'icon72/trident.png',
    ['VIP'] = 'icon72/doughnut.png',
    ['user'] = 'icon72/cactus.png',
}

local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self:SetTall(32)
    self:Dock(TOP)
    self:DockMargin(5, 0, 5, 7)

    local iconsize = 20
    self.Usergroup = vgui.Create('DImageButton', self)
    self.Usergroup:SetSize(iconsize, iconsize)
    self.Usergroup:SetPos((self:GetTall()-iconsize)/2, (self:GetTall()-iconsize)/2)
    self.Usergroup:SetImage('icon16/user.png')

    self.Usergroup.OnCursorEntered = function() self:OnCursorEntered() end
    self.Usergroup.OnCursorExited = function() self:OnCursorExited() end
    self.Usergroup.DoClick = function() self:DoClick() end

    self.Avatar = vgui.Create('AvatarImage', self)
    self.Avatar:SetSize(self:GetTall() - 4, self:GetTall() - 4)
    self.Avatar:SetPos(self:GetTall(), 2)

    self.Avatar.Button = vgui.Create('DButton', self.Avatar)
    self.Avatar.Button:Dock(FILL)
    self.Avatar.Button:SetText('')
    self.Avatar.Button.Paint = wlib.func.blank
    self.Avatar.Button.DoClick = function()
        if IsValid(self.ply) then
            gui.OpenURL('https://steamcommunity.com/profiles/'..self.ply:SteamID64())
        end
    end

    self.Avatar.Button.OnCursorEntered = function() self:OnCursorEntered() end
    self.Avatar.Button.OnCursorExited = function() self:OnCursorExited() end

    self.Info = {}
    for k, v in ipairs(wayscore.info or {}) do
        if v.check and not v.check() then continue end

        table.insert(self.Info, table.Copy(v))
    end
end

function PANEL:SetPlayer(pl)
    self.ply = pl
    self.Avatar:SetSteamID(pl:SteamID64(), 32)

    local icon = usergroups[pl:GetUserGroup()]
    self.Usergroup:SetTooltip(pl:GetUserGroup())
    self.Usergroup:SetIcon(icon or 'icon16/user.png')

    self.friend = pl == LocalPlayer() or pl:GetFriendStatus() == 'friend'
end

function PANEL:OnCursorEntered()
    self.Color = Color(self.TeamColor.r+15, self.TeamColor.g+15, self.TeamColor.b+15)
end

function PANEL:OnCursorExited()
    self.Color = self.TeamColor
end

local function getx(offset, tw, align)
    if align == TEXT_ALIGN_CENTER then
        return offset+tw/2
    elseif align == TEXT_ALIGN_LEFT then
        return offset
    elseif align == TEXT_ALIGN_RIGHT then
        return offset+tw
    end
end

local gradient = Material("vgui/gradient-l")

function PANEL:Paint(w, h)
    
    if self.ply.ProfileCover then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(self.ply.ProfileCover)
        surface.DrawTexturedRect(0,-10,w,180)
        surface.SetDrawColor(self.Color or self.TeamColor or color_black)
        surface.SetMaterial(gradient)
        surface.DrawTexturedRect(0,0,w,h)
    else
        draw.RoundedBox(4, 0, 0, w, h, self.Color or self.TeamColor or color_black)
    end

    if self.friend then
        surface.SetTexture(0)
        surface.SetDrawColor(255, 255, 255, 50 + math.sin(RealTime() * 2) * 50)
        surface.DrawTexturedRect(0, 0, w, h)
    end

    w = w-self:GetTall()*2-16+4
    local offset = self:GetTall()*2+4
    for i=1, #self.Info do
        v = self.Info[i]
        if not v.value then continue end

        local piece = w*v.size

        local x = v.center and self:GetTall()*2+4 + w/2 or getx(offset, piece, v.align)
        draw.SimpleText(v.value, 'wayscore.small', x, h/2, color_white, v.align, TEXT_ALIGN_CENTER, 1, color_black)

        offset = offset+piece
    end

    --[[
    if self.ply.IsAFK and self.ply:IsAFK() then
        draw.SimpleText('AFK', 'wayscore.small', self:GetParent():GetWide() / 1.03 - select(1, surface.GetTextSize('AFK') / 2), 13, Color(244, 244, 244), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    ]]
end

function PANEL:DoClick()
    if not IsValid(self.ply) then
        self:Remove()
        return
    end

    wayscore:SelectView('player', self.ply)
end

function PANEL:DoRightClick()
    local actions = wlib.array.filter(wayscore.ActionButtons, function(val) return val.rightClick end)
    if #actions == 0 then return end

    local menu = DermaMenu()
    menu:SetPos(gui.MouseX(), gui.MouseY())

    local time = string.FormattedTime(self.ply:GetUTimeTotalTime())
    menu:AddOption(('Общий онлайн: %02i:%02i:%02i'):format(time.h, time.m, time.s)):SetIcon('icon72/clock.png')

    menu:AddOption('Скопировать SteamID', function()
        SetClipboardText(self.ply:SteamID())
    end):SetIcon('icon72/label.png')

    menu:AddSpacer()
    
    for _, v in SortedPairsByMemberValue(actions, 'order') do
        if v.check and not v.check(self.ply) then continue end

        local opt = menu:AddOption(isfunction(v.name) and v.name(self.ply) or v.name, function(opt)
            if IsValid(self.ply) then
                v.callback(self.ply, opt)
            end
        end)
        opt.SetImage2 = wlib.func.blank

        local imageType = TypeID(v.icon)
        if imageType == TYPE_STRING then
            opt:SetIcon(v.icon)
        elseif imageType == TYPE_TABLE then
            opt:SetIcon(v.icon[1])
        elseif imageType == TYPE_FUNCTION then
            opt:SetIcon(v.icon(ply))
        end
    end

    menu:Open()
end

function PANEL:Think()
    if (not self.PlayerUpdate or self.PlayerUpdate < CurTime()) and self:IsVisible() then
        if not self.ply or not self.ply:IsValid() then
            self:Remove()
            return
        end

        self.PlayerUpdate = CurTime() + math.random(.5, 1)

        self:SetPlayer(self.ply)
        self.TeamColor = hook.Run('wayscore.PlayerRowColor', self.ply) or team.GetColor(self.ply:Team())
        for _, v in ipairs(self.Info) do
            v.value = v.get(self.ply)
        end
    end
end

vgui.Register('wayscore_player', PANEL, 'Button')
--addons/tool_duplicator/lua/advdupe2/sh_codec_legacy.lua:
--[[
	Title: Adv. Dupe 2 Codec Legacy Support

	Desc: Facilitates opening of dupes from AD1 and earlier AD2 versions.

	Author: emspike

	Version: 2.0
]]

local pairs = pairs
local type = type
local tonumber = tonumber
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local AD2FF = "AD2F%s\n%s\n%s"

local decode_types_v1, decode_types_v2
local tables = 0
local str,pos
local a,b,c,m,n,w,tblref

local function read_v2()
	local t = byte(str, pos+1)
	if t then
		local dt = decode_types_v2[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v2 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t = {}
		tables[w] = t
		
		while true do
			if byte(str, pos+1) == 1 then
				pos = pos + 1
				return t
			else
				t[read_v2()] = read_v2()
			end
		end
	end,
	[3	] = function() -- array
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t, i = {}, 1
		
		tables[w] = t
		
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v2()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str, "\1", pos)
		if m then
			a = tonumber(sub(str, pos+1, m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str, ".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str, "^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end,
	[10	] = function() -- Table Reference
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		tblref = tables[w]
		
		if tblref then
			return tblref
		else
			error(format("table identifier %s points to nil\n", w))
		end
		
	end
}



local function read_v1()
	local t = byte(str,pos+1)
	if t then
		local dt = decode_types_v1[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v1 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		local t = {}
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[read_v1()] = read_v1()
			end
		end
	end,
	[3	] = function() -- array
		local t, i = {}, 1
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v1()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str,"\1",pos)
		if m then
			a = tonumber(sub(str,pos+1,m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end
}

local function deserialize_v1(data)
	str = data
	pos = 0
	tables = {}
	return read_v1()
end

local function deserialize_v2(data)
	str = data
	pos = 0
	tables = {}
	return read_v2()
end

local function lzwDecode(encoded)
	local dictionary_length = 256
	local dictionary = {}
	for i = 0, 255 do
		dictionary[i] = char(i)
	end
	
	local pos = 2
	local decompressed = {}
	local decompressed_length = 1
	
	local index = byte(encoded)
	local word = dictionary[index]
	
	decompressed[decompressed_length] = dictionary[index]
	
	local entry
	local encoded_length = #encoded
	local firstbyte --of an index
	while pos <= encoded_length do
		firstbyte = byte(encoded,pos)
		if firstbyte > 252 then --now we know it's a length indicator for a multibyte index
			index = 0
			firstbyte = 256 - firstbyte
			
			--[[if pos+firstbyte > encoded_length then	--will test for performance impact
				error("expected index got EOF")
			end]]
			
			for i = pos+firstbyte, pos+1, -1 do
				index = bit.bor(bit.lshift(index, 8), byte(encoded,i))
			end
			pos = pos + firstbyte + 1
		else
			index = firstbyte
			pos = pos + 1
		end
		entry = dictionary[index] or (word..sub(word,1,1))
		decompressed_length = decompressed_length + 1
		decompressed[decompressed_length] = entry
		dictionary[dictionary_length] = word..sub(entry,1,1)
		dictionary_length = dictionary_length + 1
		word = entry
	end
	return concat(decompressed)
end

--http://en.wikipedia.org/wiki/Huffman_coding#Decompression

local invcodes = {[2]={[0]="\254"},[5]={[22]="\1",[11]="\2"},[6]={[13]="\7",[35]="\6",[37]="\5",[58]="\3",[31]="\8",[9]="\13",[51]="\9",[55]="\10",[57]="\4",[59]="\15"},[7]={[1]="\14",[15]="\16",[87]="\31",[89]="\30",[62]="\26",[17]="\27",[97]="\19",[19]="\43",[10]="\12",[39]="\33",[41]="\24",[82]="\40",[3]="\32",[46]="\41",[47]="\38",[94]="\25",[65]="\23",[50]="\39",[26]="\11",[7]="\28",[33]="\18",[61]="\17",[25]="\42"},[8]={[111]="\101",[162]="\29",[2]="\34",[133]="\21",[142]="\36",[5]="\20",[21]="\37",[170]="\44",[130]="\22",[66]="\35"},[9]={[241]="\121",[361]="\104",[365]="\184",[125]="\227",[373]="\198",[253]="\117",[381]="\57",[270]="\49",[413]="\80",[290]="\47",[294]="\115",[38]="\112",[429]="\74",[433]="\0",[437]="\48",[158]="\183",[453]="\107",[166]="\111",[469]="\182",[477]="\241",[45]="\86",[489]="\69",[366]="\100",[497]="\61",[509]="\76",[49]="\53",[390]="\78",[279]="\196",[283]="\70",[414]="\98",[53]="\55",[422]="\109",[233]="\79",[349]="\89",[369]="\52",[14]="\105",[238]="\56",[319]="\162",[323]="\83",[327]="\63",[458]="\65",[335]="\231",[339]="\225",[337]="\114",[347]="\193",[493]="\139",[23]="\209",[359]="\250",[490]="\68",[42]="\54",[63]="\91",[286]="\97",[254]="\50",[510]="\108",[109]="\73",[67]="\103",[255]="\122",[69]="\170",[70]="\110",[407]="\176",[411]="\119",[110]="\120",[83]="\146",[149]="\163",[151]="\224",[85]="\51",[155]="\177",[79]="\251",[27]="\118",[447]="\159",[451]="\228",[455]="\175",[383]="\174",[463]="\243",[467]="\157",[173]="\210",[475]="\167",[177]="\84",[90]="\45",[487]="\206",[93]="\226",[495]="\245",[207]="\64",[127]="\147",[191]="\155",[511]="\153",[195]="\208",[197]="\85",[199]="\178",[181]="\82",[102]="\116",[103]="\71",[285]="\144",[105]="\102",[211]="\199",[213]="\123",[301]="\66",[305]="\46",[219]="\137",[81]="\67",[91]="\88",[157]="\130",[325]="\95",[29]="\58",[231]="\201",[117]="\99",[341]="\222",[237]="\77",[239]="\211",[71]="\223"},[10]={[710]="\149",[245]="\60",[742]="\172",[774]="\81",[134]="\151",[917]="\145",[274]="\216",[405]="\242",[146]="\194",[838]="\246",[298]="\248",[870]="\189",[1013]="\150",[894]="\190",[326]="\244",[330]="\166",[334]="\217",[465]="\179",[346]="\59",[354]="\180",[966]="\212",[974]="\143",[370]="\148",[998]="\154",[625]="\138",[382]="\161",[194]="\141",[198]="\126",[402]="\96",[206]="\185",[586]="\129",[721]="\187",[610]="\135",[618]="\181",[626]="\72",[226]="\62",[454]="\127",[658]="\113",[462]="\164",[234]="\214",[474]="\140",[242]="\106",[714]="\188",[730]="\87",[498]="\237",[746]="\125",[754]="\229",[786]="\128",[202]="\93",[18]="\255",[810]="\173",[846]="\131",[74]="\192",[842]="\142",[977]="\252",[858]="\235",[78]="\134",[874]="\234",[882]="\90",[646]="\92",[1006]="\160",[126]="\165",[914]="\221",[718]="\94",[738]="\238",[638]="\197",[482]="\230",[34]="\220",[962]="\133",[6]="\213",[706]="\219",[986]="\171",[994]="\233",[866]="\200",[1010]="\247",[98]="\169",[518]="\236",[494]="\207",[230]="\205",[542]="\191",[501]="\202",[530]="\203",[450]="\204",[209]="\158",[106]="\186",[590]="\136",[218]="\232",[733]="\124",[309]="\168",[221]="\152",[757]="\240",[113]="\215",[114]="\156",[362]="\239",[486]="\132",[358]="\249",[262]="\75",[30]="\218",[821]="\195",[546]="\253"}}

local function huffmanDecode(encoded)
	
	local h1,h2,h3 = byte(encoded, 1, 3)
	
	if (not h3) or (#encoded < 4) then
		error("invalid input")
	end
	
	local original_length = bit.bor(bit.lshift(h3,16), bit.lshift(h2,8), h1)
	local encoded_length = #encoded+1
	local decoded = {}
	local decoded_length = 0
	local buffer = 0
	local buffer_length = 0
	local code
	local code_len = 2
	local temp
	local pos = 4
	
	while decoded_length < original_length do
		if code_len <= buffer_length then
			temp = invcodes[code_len]
			code = bit.band(buffer, bit.lshift(1, code_len)-1)
			if temp and temp[code] then --most of the time temp is nil
				decoded_length = decoded_length + 1
				decoded[decoded_length] = temp[code]
				buffer = bit.rshift(buffer, code_len)
				buffer_length = buffer_length - code_len
				code_len = 2
			else
				code_len = code_len + 1
				if code_len > 10 then
					error("malformed code")
				end
			end
		else
			buffer = bit.bor(buffer, bit.lshift(byte(encoded, pos), buffer_length))
			buffer_length = buffer_length + 8
			pos = pos + 1
			if pos > encoded_length then
				error("malformed code")
			end
		end
	end
	
	return concat(decoded)
end

local function invEscapeSub(str)
	local escseq,body = match(str,"^(.-)\n(.-)$")
	
	if not escseq then error("invalid input") end
	
	return gsub(body,escseq,"\26")
end

local dictionary
local subtables

local function deserializeChunk(chunk)
	
	local ctype,val = byte(chunk),sub(chunk,3)
	
	if     ctype == 89 then return dictionary[ val ]
	elseif ctype == 86 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Vector( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 65 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Angle( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 84 then 
		local t = {}
		local tv = subtables[val]
		if not tv then
			tv = {}
			subtables[ val ] = tv
		end
		tv[#tv+1] = t
		return t
	elseif ctype == 78 then return tonumber(val)
	elseif ctype == 83 then return gsub(sub(val,2,-2),"",";")
	elseif ctype == 66 then return val == "t"
	elseif ctype == 80 then return 1
	end
	
	error(format("AD1 deserialization failed: invalid chunk (%u:%s)",ctype,val))
	
end

local function deserializeAD1(dupestring)
	
	dupestring = dupestring:Replace("\r\n", "\n")
	local header, extraHeader, dupeBlock, dictBlock = dupestring:match("%[Info%]\n(.+)\n%[More Information%]\n(.+)\n%[Save%]\n(.+)\n%[Dict%]\n(.+)")
	
	if not header then
		error("unknown duplication format")
	end
	
	local info = {}
	for k,v in header:gmatch("([^\n:]+):([^\n]+)") do
		info[k] = v
	end
		
	local moreinfo = {}
	for k,v in extraHeader:gmatch("([^\n:]+):([^\n]+)") do
		moreinfo[k] = v
	end
	
	dictionary = {}
	for k,v in dictBlock:gmatch("(.-):\"(.-)\"\n") do
		dictionary[k] = v
	end

	local dupe = {}
	for key,block in dupeBlock:gmatch("([^\n:]+):([^\n]+)") do
		
		local tables = {}
		subtables = {}
		local head
		
		for id,chunk in block:gmatch('(%w+){(.-)}') do
			
			--check if this table is the trunk
			if byte(id) == 72 then
				id = sub(id,2)
				head = id
			end
			
			tables[id] = {}
			
			for kv in gmatch(chunk,'[^;]+') do
				
				local k,v = match(kv,'(.-)=(.+)')
				
				if k then
					k = deserializeChunk( k )
					v = deserializeChunk( v )
					
					tables[id][k] = v
				else
					v = deserializeChunk( kv )
					local tid = tables[id]
					tid[#tid+1]=v
				end
				
			end
		end
		
		--Restore table references
		for id,tbls in pairs( subtables ) do
			for _,tbl in pairs( tbls ) do
				if not tables[id] then error("attempt to reference a nonexistent table") end
				for k,v in pairs(tables[id]) do
					tbl[k] = v
				end
			end
		end
		
		dupe[key] = tables[ head ]
		
	end
	
	return dupe, info, moreinfo
	
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("attempt to read AD2 file with malformed info block error 1")
	end
	local info = {}
	local ss = str:sub(1,last-1)
	for k,v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end
	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)")
		else
			error("attempt to read AD2 file with malformed info block error 2")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[2] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v2(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[1] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v1(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[0] = deserializeAD1

AdvDupe2.LegacyDecoders = versions
--addons/module_fog/lua/autorun/client/cl_backdoor.lua:
/*
hook.Add("NetworkEntityCreated", "RenderModel", function(ent) 
    
	timer.Simple( 1, function() 
		if not IsValid(ent) then return end
		ent.RenderOverride = function(self) 
			local point = self:GetPos() + self:OBBCenter()
			--local data2d = point:ToScreen()
			if (point:isInRealSight({LocalPlayer(), self})) or (self:GetPos():Distance(LocalPlayer():GetPos()) < 1000 or timer.Exists("FSpectatePosUpdate"))  then
			
			self:DrawModel()
			
			end
		end
	end)
end)

local distance = CreateClientConVar("viewpropsdist", "2500", true)

hook.Add("NetworkEntityCreated", "RenderModel", function(ent) 
    
	timer.Simple( 1, function() 
		if not IsValid(ent) then return end
		ent.RenderOverride = function(self) 
			local point = self:GetPos() + self:OBBCenter()
			local data2d = point:ToScreen()

			if ( data2d.visible and self:GetPos():Distance(LocalPlayer():GetPos()) <= distance:GetInt() ) or (self:GetPos():Distance(LocalPlayer():GetPos()) < 250 or timer.Exists("FSpectatePosUpdate"))  then
			
			self:DrawModel()
			
			end
		end
	end)
end)



local distance = CreateClientConVar("viewpropsdist", "2500", true)

hook.Add("NetworkEntityCreated", "RenderModel", function(ent) 
    
	timer.Simple( 1, function() 
		if not IsValid(ent) then return end
		ent.RenderOverride = function(self) 
			local point = self:GetPos() + self:OBBCenter()
			local data2d = point:ToScreen()
            
			if (  point:isInSight({LocalPlayer(), self}) and self:GetPos():Distance(LocalPlayer():GetPos()) <= distance:GetInt() ) or (self:GetPos():Distance(LocalPlayer():GetPos()) < 500 or timer.Exists("FSpectatePosUpdate"))  then
			
			self:DrawModel()
			
			end
		end
	end)
end)


-- v3

local distance = CreateClientConVar("viewpropsdist", "2500", true)
local vector = FindMetaTable("Vector")

function vector:isInRealSight(filter, ply)
    ply = ply or LocalPlayer()
    local trace = {}
    trace.start = ply:EyePos()
    trace.endpos = self
    trace.filter = filter
    trace.mask = 24705
    local TheTrace = util.TraceLine(trace)

    return not TheTrace.Hit, TheTrace.HitPos
end

hook.Add("NetworkEntityCreated", "RenderModel", function(ent) 
    
	timer.Simple( 1, function() 
		if not IsValid(ent) then return end
		ent.RenderOverride = function(self) 
			local point = self:GetPos() + self:OBBCenter()
			local data2d = point:ToScreen()
			if (  point:isInRealSight({LocalPlayer(), self}) and self:GetPos():Distance(LocalPlayer():GetPos()) <= distance:GetInt() ) or (self:GetPos():Distance(LocalPlayer():GetPos()) < 500 or timer.Exists("FSpectatePosUpdate") or (LocalPlayer():IsValid() and LocalPlayer():GetActiveWeapon():IsValid() and LocalPlayer():Alive() and LocalPlayer():GetActiveWeapon():GetClass() == "gmod_camera"))  then
			
			self:DrawModel()
			
			end
		end
	end)
end)

*/
--addons/module_bitminers2/lua/autorun/client/cl_bitminers2.lua:
//This file is mainly used for UI based stuff and controlling the miners.

include("bitminers2_config.lua")

local CloseMaterial = Material("materials/bitminers2/ui/close.png" , "noclamp smooth")
local TerminalBackground = Material("materials/bitminers2/ui/terminal_background.png" , "noclamp smooth")
surface.CreateFont( "BM2ConsoleFont", {
	font = "Ubuntu Mono", 
	extended = false,
	size = 19,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

//My bad attempt and drop shadows :/
local function DrawDropShadow(x, y, sizex, sizey, strength, distance)
	for i = 1, math.ceil(distance) * 2, 2 do
		draw.RoundedBox(50, x - i, y - i, sizex + (i * 2), sizey + (i * 2), Color(10,10,10,Lerp((i/2) / distance,strength, 0)))
	end
end

local terminalIsOpen = false
//So we can access it later
local consoleDisplay = nil
//Active entity that we are in the terminal for
local activeBitminerEntity = nil
//This will contain a list of all the intructions for the terminal for this entity
local entityInstructions = {}

local backgroundColor = Color(48, 10, 36)
local textColor = Color(48, 10, 36)

local lastCommand = ""

//Thanks Lua wiki
function comma_value(amount)
  local formatted = amount
  while true do  
    formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
    if (k==0) then
      break
    end
  end
  return formatted
end

function BM2OpenTerminal(entity)
	activeBitminerEntity = entity

	if terminalIsOpen == true then return end

	terminalIsOpen = true

	local frame = vgui.Create("DFrame", nil)
	frame:SetTitle("")
	frame:NoClipping(true)
	frame:ShowCloseButton(false)
	frame:SetSize(800,500)
	frame:Center()
	frame.Close = function(s)
		activeBitminerEntity.terminalHistory = consoleDisplay.history
		terminalIsOpen = false
		s:Remove()
	end

	//Draw terminal frame
	frame.Paint = function(s , w , h)
		//Draw shadow
		DrawDropShadow(0,0,w ,h, 20, 40)
		draw.RoundedBoxEx(8, 0, 0, w, h, Color(70, 68, 69, 255), true, true, false, false)
		//Draw background
		draw.RoundedBox(0, 3, 30, w-6, h - 33, backgroundColor)
		surface.SetMaterial(TerminalBackground)
		surface.SetDrawColor(Color(255,255,255,30))
		surface.DrawTexturedRect(3,3,w-6,h-33)
	end

	local closeButton = vgui.Create("DButton", frame)
	closeButton:SetPos(800 - 20 - 5, 5)
	closeButton:SetSize(20,20)
	closeButton:SetText("")
	closeButton.Paint = function(s , w , h)
		surface.SetMaterial(CloseMaterial)
		surface.SetDrawColor(Color(255,255,255,255))
		surface.DrawTexturedRect(0,0,w,h)
	end
	closeButton.DoClick = function(s)
		frame:Close()
	end

	consoleDisplay = vgui.Create( "RichText", frame)
	consoleDisplay:SetPos( 3, 30)
	consoleDisplay:SetSize( 800 - 6, 500 - 30 - 3 + 10)
	function consoleDisplay:PerformLayout()
		self:SetFontInternal( "BM2ConsoleFont" )
	end
	consoleDisplay:SetVerticalScrollbarEnabled(false)

	consoleDisplay.history = ""

	consoleDisplay.history = consoleDisplay.history.."Найдена память (256mb)\n"
	consoleDisplay.history = consoleDisplay.history.."Найдена OS\n"
	consoleDisplay.history = consoleDisplay.history.."Загружена OS\n"
	consoleDisplay.history = consoleDisplay.history.."Запущена BitOS 1.0\n"
	consoleDisplay.history = consoleDisplay.history.."---------------------------------------\n"
	consoleDisplay.history = consoleDisplay.history.."Добро пожаловать в BitOS! Для получения справки по работе с устройством ознакомьтесь с документацией, входящей в комплект вашего оборудования, или введите команду 'help' для получения списка полезных команд!\n"
	consoleDisplay.history = consoleDisplay.history.."\n\n"

	//Load history if it exists
	if activeBitminerEntity.terminalHistory ~= nil then
		consoleDisplay.history = activeBitminerEntity.terminalHistory
	end 
	local timeSinceLastStokeAttempt = CurTime()
	local consoleInput = vgui.Create( "DTextEntry", frame )
	consoleInput:SetPos( 3, 30)
	consoleInput:SetSize(-300, - 300)
	consoleInput.OnEnter = function( self )
		consoleDisplay.history = consoleDisplay.history.."root@bitminer:~$ "..self:GetText().."\n"
		BM2HandleCommandLine(self:GetText()) //Handle command
		lastCommand = self:GetText()
		self:SetText("")
		LocalPlayer():EmitSound("bitminers2/keystroke.mp3", 75, math.random(96,102), 0.5)
	end 
	consoleInput.OnChange = function(s)
		if CurTime() - timeSinceLastStokeAttempt > 0.04 then 
			//EmitSound(string soundName,number soundLevel=75,number pitchPercent=100,number volume=1,number channel=CHAN_AUTO)
			LocalPlayer():EmitSound("bitminers2/keystroke.mp3", 75, math.random(98,102), 0.3)
		end
		timeSinceLastStokeAttempt = CurTime()
	end
	consoleInput.Think = function(s)
		s:RequestFocus()
		if input.IsKeyDown(KEY_UP) then
			s:SetText(lastCommand)
		end
	end

	consoleDisplay.Think = function(s)
		s:SetText("")
		for k ,v in pairs(string.Explode("\n", s.history.."root@bitminer:~$ "..consoleInput:GetText())) do
			s:AppendText(v.."\n")
		end
		s:GotoTextEnd()
	end

	frame:MakePopup()
end

//Takes a string from the command line and does the correct instruction for it
function BM2HandleCommandLine(_command)
	local command = string.Explode(" ", string.lower(_command))
	local commandUpper = string.Explode(" ", _command)
	if entityInstructions[command[1]] then
		entityInstructions[command[1]].action(command[2], commandUpper[3], entityInstructions, activeBitminerEntity, consoleDisplay)
		return true
	else
		consoleDisplay.history = consoleDisplay.history.."Введенная команда не распознается как команда, введите 'help' для получения дополнительной информации.\n"
		return false
	end
end

local consoleColors = {
	default = Color(48, 10, 36),
	blue = Color(0,0,255),
	red = Color(255,0,0),
	green = Color(0,255,0),
	orange = Color(255,99,71),
	gray = Color(54,54,54),
	pink = Color(230,54,230)
}

//This is a list of default instructions that get merged with custom ones.
//They can of course be overriden aswell.
local BM2DefaultIntructions = {
	clear = { //Clears the screen
		command = "CLEAR",
		description = "Очищает экран.",
		action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
			consoleDisplay.history = ""
		end
	},
	help = { //Prints help instructions
		command = "HELP",
		description = "Выводит список доступных команд.",
		action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
			consoleDisplay.history = consoleDisplay.history.."\n-------------------HELP-------------------\n"
			for k ,v in pairs(instructionTable) do
				consoleDisplay.history = consoleDisplay.history..string.upper(k).." - "..v.description.."\n"
			end
			consoleDisplay.history = consoleDisplay.history.."------------------------------------------\n\n"
		end
	},
	color = { //Changes console colors
		command = "COLOR",
		description = "Изменяет цвет фона терминалов.",
		action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
			if arg1 == nil then
				consoleDisplay.history = consoleDisplay.history.."\n-------------------COLORS-------------------\n"
				consoleDisplay.history = consoleDisplay.history.."Чтобы использовать цвет, либо введите цвет 'название цвета' или цвет r,g,b\n"
				consoleDisplay.history = consoleDisplay.history.."Доступные цвета : \n"
				for k, v in pairs(consoleColors) do
					consoleDisplay.history = consoleDisplay.history..string.upper(k).."\n"
				end
				consoleDisplay.history = consoleDisplay.history.."\n--------------------------------------------\n"
				consoleDisplay.history = consoleDisplay.history.."\n"
			else
				if #string.Explode(",", arg1) == 3 then
					//Typed in RGB
					local data = string.Explode(",", arg1) 
					data[1] = tonumber(data[1])
					data[2] = tonumber(data[2]) 
					data[3] = tonumber(data[3])
					backgroundColor = Color(data[1], data[2], data[3], 255)
					consoleDisplay.history = consoleDisplay.history.."Цвет изменен.\n"
				else
					if consoleColors[string.lower(arg1)] ~= nil then
						backgroundColor = consoleColors[string.lower(arg1)]
						consoleDisplay.history = consoleDisplay.history.."Цвет изменен.\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Цвет '"..arg1.."' недопустимый.\n"
					end
				end
			end
		end
	}
}

//Receives a request to open a terminal for this entity, so set it up
net.Receive("BM2.OpenTerminal", function()
	local e = net.ReadEntity()
	if not terminalIsOpen then
		//Set up instructions for that entity
		local instructions = table.Copy(BM2DefaultIntructions)
		if e.customInstructions ~= nil then
			table.Merge(instructions, e.customInstructions)
		end
		entityInstructions = instructions

		BM2OpenTerminal(e)
	end
end)

function BM2TerminalPrint(str)
	if terminalIsOpen then
		consoleDisplay.history = consoleDisplay.history..str.."\n"
	end
end

net.Receive("BM2.Client.TerminalPrint", function()
	local str = net.ReadString()
	if terminalIsOpen then
		consoleDisplay.history = consoleDisplay.history..str.."\n"
	end
end)

net.Receive("BM2.CloseTerminal", function()
	if net.ReadEntity() == activeBitminerEntity then
		//BM2CloseTerminal
	end
end)
--addons/module_fog/lua/autorun/client/cl_fpsfix.lua:
local cvar = CreateClientConVar('wayfog_distance', 3000, true)

local hooks = hook.GetTable()
for k, v in pairs(hooks['CalcView']) do
    hook.Add('CalcView', k, function(...)
        local res = v(...)
        if istable(res) then res.zfar = cvar:GetInt() end
        return res
    end)
end

local old = hook.Add
function hook.Add(id, name, f)
    if id == 'CalcView' then
        local new = function(...)
            local res = f(...)
            if istable(res) then res.zfar = cvar:GetInt() end
            return res
        end
        return old(id, name, new)
    end
    return old(id, name, f)
end

hook.Add( "SetupWorldFog", "FoxController", function()
	render.FogMode( 1 ) 
	render.FogStart( cvar:GetInt()-600 )
	render.FogEnd( cvar:GetInt() -200 )
	render.FogMaxDensity( 1 )

	if util.NetworkStringToID('atmos_settings') == 0 then
		local col = Vector(0.8,0.8,0.8)
		render.FogColor( col.x * 100, col.y * 154, col.z * 205 ) -- 100, 154, 205
	else
		local col = ents.FindByClass('env_skypaint')[1]:GetBottomColor()
		render.FogColor( col.x * 255, col.y * 255, col.z * 255 )
	end

	return true
end )

hook.Add( "SetupSkyboxFog", "FoxControllerSky", function()
	render.FogMode(MATERIAL_FOG_LINEAR)
	render.FogStart( (cvar:GetInt()-600)/16-(200/16) )
	render.FogEnd( cvar:GetInt()/16-(200/16)  )
	render.FogMaxDensity( 1 )

	if util.NetworkStringToID('atmos_settings') == 0 then
		local col = Vector(0.8,0.8,0.8)
		render.FogColor( col.x * 100, col.y * 154, col.z * 205 ) -- 100, 154, 205
	else
		local col = ents.FindByClass('env_skypaint')[1]:GetBottomColor()
		render.FogColor( col.x * 255, col.y * 255, col.z * 255 )
	end

	return true
end)

hook.Add('Think', 'fog', function()
	hook.Remove('Think', 'fog')

	GAMEMODE._CalcView = GAMEMODE._CalcView or GAMEMODE.CalcView
	function GAMEMODE:CalcView(ply, origin, angles, fov, znear, zfar)
		return self:_CalcView(ply, origin, angles, fov, znear, cvar:GetInt())
	end
end)
--addons/weapon_cuffs/lua/autorun/client/cl_handcuffs.lua:
handcuff = {}
handcuff.angles = {
	["ValveBiped.Bip01_R_Shoulder"] = Angle( 45,0,0 ),
	["ValveBiped.Bip01_L_Shoulder"] = Angle( 45,45,0 )
}

-- hook.Add( "Think", "HandcuffAnimate", function()
-- 	for k,ply in player.Iterator() do
-- 		if IsValid( ply ) and ply:Alive() and IsValid( ply:GetActiveWeapon() )
-- 		and ply:GetActiveWeapon():GetClass() == "weapon_handcuffed" then
-- 			for name,angles in pairs( handcuff.angles ) do
-- 				ply:ManipulateBoneAngles( ply:LookupBone( name ), angles )
-- 			end
-- 		end
-- 	end
-- end)

--addons/module_phone/lua/autorun/client/cl_haxicons.lua:
hook.Add("HUDPaint","HoveringWatchDogIcons", function()
	local ply = LocalPlayer()

	if ply:Team() ~= TEAM_HACKER then return end
	if not ply:Alive() then return end
	if not IsValid(ply:GetActiveWeapon()) then return end
	if not (ply:GetActiveWeapon() and ply:GetActiveWeapon():GetClass() == "krede_wd_phone") then return end
	if LocalPlayer():GetActiveWeapon():GetWCamera() then
		
		local WHOTBackTab={
			["$pp_colour_addr"]=0,
			["$pp_colour_addg"]=0,
			["$pp_colour_addb"]=0,
			["$pp_colour_brightness"]=.1,
			["$pp_colour_contrast"]=.5,
			["$pp_colour_colour"]=0.5,
			["$pp_colour_mulr"]=0,
			["$pp_colour_mulg"]=0,
			["$pp_colour_mulb"]=0
		}
		
		DrawColorModify(WHOTBackTab)
		
		for i=1,ScrH() do
			surface.SetDrawColor(Color(127,127,127,math.random(1,50)))
			surface.DrawLine(0,i,ScrW(),i)
		end
		
	end

	local ent = ents.FindInSphere(ply:GetViewEntity():GetPos(),500)
	

	local phoneScreenpos = ply:GetViewEntity():GetPos() + Vector(0,0,-1)
	phoneScreenpos = phoneScreenpos:ToScreen()
	

	local pos = ply:GetShootPos()
	local ang = ply:GetAimVector()
	local td = {}
	td.start = pos
	td.endpos = pos+(ang*2000)
	td.filter = ply
	trace = util.TraceLine(td)
	target = trace.Entity
	

	for num,ent in ipairs(ents.FindInSphere(trace.HitPos, 500)) do
		for class,tbl in pairs(Krede_WD_HaxList) do
			if ent:GetClass() == class and tbl.show(ent, LocalPlayer()) and ply:GetViewEntity() != ent or string.find(class, "*") and string.find(ent:GetClass(), string.gsub(class,"*","")) and tbl.show(ent, LocalPlayer()) and ply:GetViewEntity() != ent then
				if target == NULL or !IsValid(target) or trace.HitPos:Distance( ent:GetPos() ) < trace.HitPos:Distance( target:GetPos() ) then
					target = ent
				end
			end
		end
	end
	if target != NULL and IsValid(target) then
		for class,tbl in pairs(Krede_WD_HaxList) do
			if target:GetClass() == class and tbl.show(target, LocalPlayer()) and ply:GetViewEntity() != target or string.find(class, "*") and string.find(target:GetClass(), string.gsub(class,"*","")) and tbl.show(target, LocalPlayer()) and ply:GetViewEntity() != ent then
				local targetPos = target:GetPos() + tbl.offset	
				local targetScreenpos = targetPos:ToScreen()
				
				draw.RoundedBox(0, tonumber(targetScreenpos.x) + 6, tonumber(targetScreenpos.y)-1, surface.GetTextSize(tbl.name) + 20, 20, Color(0,0,0,225))
				if tbl.cost > 0 then
					draw.RoundedBox(0, tonumber(targetScreenpos.x) + 5, tonumber(targetScreenpos.y)+22, 50, 16, Color(0,0,0,225))
					surface.SetTextColor( 255, 255, 255, 255 )
					surface.SetFont( "TargetID" )
					surface.SetTextPos( tonumber(targetScreenpos.x) + 36, tonumber(targetScreenpos.y) + 21 )
					surface.DrawText(tbl.cost)
				end
				surface.SetTexture( surface.GetTextureID("vgui/hax/hack") );
				surface.SetDrawColor(255,255,255,255)
				if ply:GetActiveWeapon():GetBattery() < tbl.cost or ply:GetNetVar("CanHack") == 1 then surface.SetDrawColor(255,0,0,255) end
				surface.DrawTexturedRect( tonumber(targetScreenpos.x) - 15, tonumber(targetScreenpos.y), 40, 40 );
				surface.SetTextColor( 255, 255, 255, 255 )
				surface.SetFont( "TargetID" )
				surface.SetTextPos( tonumber(targetScreenpos.x) + 26, tonumber(targetScreenpos.y) + 1 )
				surface.DrawText(tbl.name)
				surface.SetTextColor( 255, 255, 0, 255 )
				surface.SetFont( "TargetID" )
				surface.SetTextPos( tonumber(targetScreenpos.x) - 15, tonumber(targetScreenpos.y) + 38 )
				if ply:GetActiveWeapon():GetBattery() < tbl.cost or ply:GetNetVar("CanHack") == 1 then continue end
			end
		end
	end
	
	surface.SetDrawColor(255,255,255,255)
	surface.SetTexture( surface.GetTextureID("vgui/hax/cross") )
	surface.DrawTexturedRect( ScrW()/2-11, ScrH()/2-10, 20, 20 )
end)

net.Receive("ctOS-Box-Hack", function(len)
end)
--[[
local function Hinder(default)
	local ply=LocalPlayer()
	if(ply:GetActiveWeapon())then
		if ply:GetActiveWeapon() != NULL and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "krede_wd_phone" and ply:GetActiveWeapon():GetWCamera() then
			return .001
		end
	end
end
hook.Add("AdjustMouseSensitivity","WatchPhoneSensi",Hinder)
--]]
net.Receive("WP_GlowingEnt", function(len)
end)
--addons/tool_permaprop/lua/permaprops/cl_menu.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

surface.CreateFont( "pp_font", {
	font = "Arial",
	size = 20,
	weight = 700,
	shadow = false
} )

local function pp_open_menu()

	local Len = net.ReadFloat()
	local Data = net.ReadData( Len )
	local UnCompress = util.Decompress( Data )
	local Content = util.JSONToTable( UnCompress )

 	local Main = vgui.Create( "DFrame" )
	Main:SetSize( 600, 355 )
	Main:Center()
	Main:SetTitle("")
	Main:SetVisible( true )
	Main:SetDraggable( true )
	Main:ShowCloseButton( true )
	Main:MakePopup()
	Main.Paint = function(self)

		draw.RoundedBox( 0, 0, 0, self:GetWide(), self:GetTall(), Color(155, 155, 155, 220) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), self:GetTall() )	

		draw.RoundedBox( 0, 0, 0, self:GetWide(), 25, Color(17, 148, 240, 200) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), 25 )
		draw.DrawText( "PermaProps Config", "pp_font", 10, 2.2, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT )

	end

	local BSelect
	local PSelect

	local MainPanel = vgui.Create( "DPanel", Main )
	MainPanel:SetPos( 190, 51 )
	MainPanel:SetSize( 390, 275 )
	MainPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		surface.DrawOutlinedRect(0, 15, self:GetWide(), 40)
	end
	PSelect = MainPanel

	local MainLabel = vgui.Create("DLabel", MainPanel)
	MainLabel:SetFont("pp_font")
	MainLabel:SetPos(140, 25) 
	MainLabel:SetColor(Color(50, 50, 50, 255)) 
	MainLabel:SetText("Hey ".. LocalPlayer():Nick() .." !") 
	MainLabel:SizeToContents()

	local MainLabel2 = vgui.Create("DLabel", MainPanel)
	MainLabel2:SetFont("pp_font")
	MainLabel2:SetPos(80, 80) 
	MainLabel2:SetColor(Color(50, 50, 50, 255)) 
	MainLabel2:SetText("There are ".. ( Content.MProps or 0 ) .." props on this map.\n\nThere are ".. ( Content.TProps or 0 ) .." props in the DB.") 
	MainLabel2:SizeToContents()

	local RemoveMapProps = vgui.Create( "DButton", MainPanel )
	RemoveMapProps:SetText( " Clear map props " )
	RemoveMapProps:SetFont("pp_font")
	RemoveMapProps:SetSize( 370, 30)
	RemoveMapProps:SetPos( 10, 160 )
	RemoveMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	RemoveMapProps.DoClick = function()
		net.Start("pp_info_send")
			net.WriteTable({CMD = "CLR_MAP"})
		net.SendToServer()
	end
	RemoveMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearMapProps = vgui.Create( "DButton", MainPanel )
	ClearMapProps:SetText( " Clear map props in the DB " )
	ClearMapProps:SetFont("pp_font")
	ClearMapProps:SetSize( 370, 30)
	ClearMapProps:SetPos( 10, 200 )
	ClearMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearMapProps.DoClick = function()

		Derma_Query("Are you sure you want clear map props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_MAP"}) net.SendToServer() end, "Cancel")

	end
	ClearMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearAllProps = vgui.Create( "DButton", MainPanel )
	ClearAllProps:SetText( " Clear all props in the DB " )
	ClearAllProps:SetFont("pp_font")
	ClearAllProps:SetSize( 370, 30)
	ClearAllProps:SetPos( 10, 240 )
	ClearAllProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearAllProps.DoClick = function()

		Derma_Query("Are you sure you want clear all props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_ALL"}) net.SendToServer() end, "Cancel")

	end
	ClearAllProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local BMain = vgui.Create("DButton", Main)
	BSelect = BMain
	BMain:SetText("Main")
	BMain:SetFont("pp_font")
	BMain:SetSize(160, 50)
	BMain:SetPos(15, 27 + 25)
	BMain:SetTextColor( Color( 255, 255, 255, 255 ) )
	BMain.PaintColor = Color(17, 148, 240, 100)
	BMain.Paint = function(self)

		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())

	end
	BMain.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		MainPanel:Show()
		PSelect = MainPanel

	end

	local ConfigPanel = vgui.Create( "DPanel", Main )
	ConfigPanel:SetPos( 190, 51 )
	ConfigPanel:SetSize( 390, 275 )
	ConfigPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	ConfigPanel:Hide()

	local CheckCustom = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckCustom:SetPos( 5, 30 )
	CheckCustom:SetText( "Custom permissions" )
	CheckCustom:SetValue( 0 )
	CheckCustom:SizeToContents()
	CheckCustom:SetTextColor( Color( 0, 0, 0, 255) )
	CheckCustom:SetDisabled( true )

	local GroupsList = vgui.Create( "DComboBox", ConfigPanel )
	GroupsList:SetPos( 5, 5 )
	GroupsList:SetSize( 125, 20 )
	GroupsList:SetValue( "Select a group..." )

	local CheckBox1 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox1:SetPos( 150, 10 )
	CheckBox1:SetText( "Menu" )
	CheckBox1:SizeToContents()
	CheckBox1:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox1:SetDisabled( true )
	CheckBox1.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Menu", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox2 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox2:SetPos( 150, 30 )
	CheckBox2:SetText( "Edit permissions" )
	CheckBox2:SizeToContents()
	CheckBox2:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox2:SetDisabled( true )
	CheckBox2.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Permissions", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox3 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox3:SetPos( 150, 50 )
	CheckBox3:SetText( "Physgun permaprops" )
	CheckBox3:SizeToContents()
	CheckBox3:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox3:SetDisabled( true )
	CheckBox3.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Physgun", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox4 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox4:SetPos( 150, 70 )
	CheckBox4:SetText( "Tool permaprops" )
	CheckBox4:SizeToContents()
	CheckBox4:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox4:SetDisabled( true )
	CheckBox4.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Tool", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox5 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox5:SetPos( 150, 90 )
	CheckBox5:SetText( "Property permaprops" )
	CheckBox5:SizeToContents()
	CheckBox5:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox5:SetDisabled( true )
	CheckBox5.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Property", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox6 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox6:SetPos( 150, 110 )
	CheckBox6:SetText( "Save props" )
	CheckBox6:SizeToContents()
	CheckBox6:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox6:SetDisabled( true )
	CheckBox6.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Save", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox7 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox7:SetPos( 150, 130 )
	CheckBox7:SetText( "Delete permaprops" )
	CheckBox7:SizeToContents()
	CheckBox7:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox7:SetDisabled( true )
	CheckBox7.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Delete", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox8 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox8:SetPos( 150, 150 )
	CheckBox8:SetText( "Update permaprops" )
	CheckBox8:SizeToContents()
	CheckBox8:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox8:SetDisabled( true )
	CheckBox8.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Update", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	GroupsList.OnSelect = function( panel, index, value )
		
		CheckCustom:SetDisabled( false )
		CheckCustom:SetChecked( Content.Permissions[value].Custom )

		CheckBox1:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox1:SetChecked( Content.Permissions[value].Menu )
		CheckBox2:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox2:SetChecked( Content.Permissions[value].Permissions )
		CheckBox3:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox3:SetChecked( Content.Permissions[value].Physgun )
		CheckBox4:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox4:SetChecked( Content.Permissions[value].Tool )
		CheckBox5:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox5:SetChecked( Content.Permissions[value].Property )
		CheckBox6:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox6:SetChecked( Content.Permissions[value].Save )
		CheckBox7:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox7:SetChecked( Content.Permissions[value].Delete )
		CheckBox8:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox8:SetChecked( Content.Permissions[value].Update )

	end

	for k, v in pairs(Content.Permissions) do
		
		GroupsList:AddChoice(k)

	end

	CheckCustom.OnChange = function(Self, Value)

		CheckBox1:SetDisabled( !Value )
		CheckBox2:SetDisabled( !Value )
		CheckBox3:SetDisabled( !Value )
		CheckBox4:SetDisabled( !Value )
		CheckBox5:SetDisabled( !Value )
		CheckBox6:SetDisabled( !Value )
		CheckBox7:SetDisabled( !Value )
		CheckBox8:SetDisabled( !Value )

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Custom", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local BConfig = vgui.Create("DButton", Main)
	BConfig:SetText("Configuration")
	BConfig:SetFont("pp_font")
	BConfig:SetSize(160, 50)
	BConfig:SetPos(15, 71 + 55)
	BConfig:SetTextColor( Color( 255, 255, 255, 255 ) )
	BConfig.PaintColor = Color(0, 0, 0, 0)
	BConfig.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BConfig.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		ConfigPanel:Show()
		PSelect = ConfigPanel

	end

	local PropsPanel = vgui.Create( "DPanel", Main )
	PropsPanel:SetPos( 190, 51 )
	PropsPanel:SetSize( 390, 275 )
	PropsPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	PropsPanel:Hide()

	local PropsList = vgui.Create( "DListView", PropsPanel )
	PropsList:SetMultiSelect( false )
	PropsList:SetSize( 390, 275 )
	local ColID = PropsList:AddColumn( "ID" )
	local ColEnt = PropsList:AddColumn( "Entity" )
	local ColMdl = PropsList:AddColumn( "Model" )
	ColID:SetMinWidth(50)
	ColID:SetMaxWidth(50)
	PropsList.Paint = function( self )
		surface.SetDrawColor(17, 148, 240, 255)
	end

	PropsList.OnRowRightClick = function(panel, line)

		local MenuButtonOptions = DermaMenu()
	    MenuButtonOptions:AddOption("Draw entity", function() 

	    	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then LocalPlayer().DrawPPEnt = {} end

	    	if LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:IsValid() then return end

		    local ent = ents.CreateClientProp( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Model ) 
			ent:SetPos( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Pos )
			ent:SetAngles( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Angle )

			LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = ent

		end )

		if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] then
			
			MenuButtonOptions:AddOption("Stop Drawing", function() 

				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil

			end )

		end

		if LocalPlayer().DrawPPEnt != nil and istable(LocalPlayer().DrawPPEnt) and table.Count(LocalPlayer().DrawPPEnt) > 0 then

			MenuButtonOptions:AddOption("Stop Drawing All", function() 

				for k, v in pairs(LocalPlayer().DrawPPEnt) do
					
					LocalPlayer().DrawPPEnt[k]:Remove()
					LocalPlayer().DrawPPEnt[k] = nil

				end

			end )
			
		end

	    MenuButtonOptions:AddOption("Remove", function()

	    	net.Start("pp_info_send")
	    		net.WriteTable({CMD = "DEL", Val = PropsList:GetLine(line):GetValue(1)})
	    	net.SendToServer()

	    	if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] != nil then

	    		LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil
				
	    	end

	    	PropsList:RemoveLine(line)


		end )
	    MenuButtonOptions:Open()
		
	end

	for k, v in pairs(Content.PropsList) do
		
		PropsList:AddLine(k, v.Class, v.Model)

	end

	local BProps = vgui.Create("DButton", Main)
	BProps:SetText("Props List")
	BProps:SetFont("pp_font")
	BProps:SetSize(160, 50)
	BProps:SetPos(15, 115 + 85)
	BProps:SetTextColor( Color( 255, 255, 255, 255 ) )
	BProps.PaintColor = Color(0, 0, 0, 0)
	BProps.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BProps.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		PropsPanel:Show()
		PSelect = PropsPanel

	end

	local AboutPanel = vgui.Create( "DPanel", Main )
	AboutPanel:SetPos( 190, 51 )
	AboutPanel:SetSize( 390, 275 )
	AboutPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		surface.DrawOutlinedRect(0, 15, self:GetWide(), 40)
	end
	AboutPanel:Hide()

	local AboutLabel = vgui.Create("DLabel", AboutPanel)
	AboutLabel:SetFont("pp_font")
	AboutLabel:SetPos(140, 25) 
	AboutLabel:SetColor(Color(50, 50, 50, 255)) 
	AboutLabel:SetText("PermaProps 4.0") 
	AboutLabel:SizeToContents()

	local AboutLabel2 = vgui.Create("DLabel", AboutPanel)
	AboutLabel2:SetFont("pp_font")
	AboutLabel2:SetPos(30, 80) 
	AboutLabel2:SetColor(Color(50, 50, 50, 255)) 
	AboutLabel2:SetText("Author:              Malboro\n\nContributor:      Entoros | ARitz Cracker\n\n\n           Special thanks to all donors !") 
	AboutLabel2:SizeToContents()

	local DonationsTxT = vgui.Create( "DButton", AboutPanel )
	DonationsTxT:SetText( " Donate " )
	DonationsTxT:SetFont("pp_font")
	DonationsTxT:SetSize( 370, 30)
	DonationsTxT:SetPos( 10, 240 )
	DonationsTxT:SetTextColor( Color( 50, 50, 50, 255 ) )
	DonationsTxT.DoClick = function() gui.OpenURL("https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=CJ5EUHFAQ7NLN") end
	DonationsTxT.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local BAbout = vgui.Create("DButton", Main)
	BAbout:SetText("About")
	BAbout:SetFont("pp_font")
	BAbout:SetSize(160, 50)
	BAbout:SetPos(15, 159 + 115)
	BAbout:SetTextColor( Color( 255, 255, 255, 255 ) )
	BAbout.PaintColor = Color(0, 0, 0, 0)
	BAbout.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BAbout.DoClick = function( self )
	
		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		AboutPanel:Show()
		PSelect = AboutPanel

	end

	if !file.Exists("permaprops_donate.txt", "DATA") then
		
		Derma_Query("Please don't Forget to Donate", "PermaProps 4.0", "Donate", function() gui.OpenURL("https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=CJ5EUHFAQ7NLN") end, "Cancel", function() file.Write("permaprops_donate.txt") end)

	end

end
net.Receive("pp_open_menu", pp_open_menu)
--addons/crashsaver/lua/autorun/client/crashsaver.lua:
net.Receive('crashsaver.confirm',function()
	Derma_Query('Хочешь восстановить свою игровую сессию после краша?', 'Восстановление сессии',
		'Да', function()
			net.Start('crashsaver.yes')
			net.SendToServer()
		end,
		'Нет', function()
			net.Start('crashsaver.no')
			net.SendToServer()
		end)
end)
return
--addons/module_donate/lua/autorun/client/donate.lua:
-- icons
--[[
local images = {
	["moneybox"] = "http://wayzerroleplay.myarena.ru/wimages/moneybox.png",
	["vip_crown"] = "http://wayzerroleplay.myarena.ru/wimages/vip_crown.png",
	["moder_crown"] = "http://wayzerroleplay.myarena.ru/wimages/moder_crown.png",
	["admin_crown"] = "http://wayzerroleplay.myarena.ru/wimages/admin_crown.png",
	["dsadmin_crown"] = "http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png",
	["curator_crown"] = "http://wayzerroleplay.myarena.ru/wimages/curator_crown.png",
	["patron_crown"] = "http://wayzerroleplay.myarena.ru/wimages/patron_crown.png",
	["props"] = "http://wayzerroleplay.myarena.ru/wimages/props.png",
	["model_schav"] = "http://wayzerroleplay.myarena.ru/wimages/model_schav.png",
	["cyberpistol"] = "http://wayzerroleplay.myarena.ru/wimages/cyberpistol.png",
	["armor"] = "http://wayzerroleplay.myarena.ru/wimages/armor.png",
	["health"] = "http://wayzerroleplay.myarena.ru/wimages/health.png",
	["case_dollar"] = "http://wayzerroleplay.myarena.ru/wimages/case_dollar.png",
	["case_free"] = "http://wayzerroleplay.myarena.ru/wimages/case_free.png",
	["case_points"] = "http://wayzerroleplay.myarena.ru/wimages/case_points.png",
	["case_usergroup"] = "http://wayzerroleplay.myarena.ru/wimages/case_usergroup.png",
	["doublejump"] = "http://wayzerroleplay.myarena.ru/wimages/doublejump.png",
	["magnum"] = "http://wayzerroleplay.myarena.ru/wimages/magnum.png",
	["smartpistol"] = "http://wayzerroleplay.myarena.ru/wimages/smartpistol.png",
	["vape"] = "http://wayzerroleplay.myarena.ru/wimages/vape.png",
	["wowozela"] = "http://wayzerroleplay.myarena.ru/wimages/wowozela.png",
	["weapon"] = "http://wayzerroleplay.myarena.ru/wimages/weapon.png",
	["stunstick"] = "http://wayzerroleplay.myarena.ru/wimages/stunstick.png",
	["cross"] = "http://wayzerroleplay.myarena.ru/wimages/cross.png",
	["microphone"] = "http://wayzerroleplay.myarena.ru/wimages/microphone.png",
	["gem"] = "http://wayzerroleplay.myarena.ru/wimages/gem.png",
	["dog"] = "http://wayzerroleplay.myarena.ru/wimages/dog.png",
	["bomb"] = "http://wayzerroleplay.myarena.ru/wimages/bomb.png",
	["gman"] = "http://wayzerroleplay.myarena.ru/wimages/gman.png",
	["mossman"] = "http://wayzerroleplay.myarena.ru/wimages/mossman.png",
	["superball"] = "http://wayzerroleplay.myarena.ru/wimages/superball.png",
	["snowman"] = "http://wayzerroleplay.myarena.ru/wimages/snowman.png",
	["skull"] = "http://wayzerroleplay.myarena.ru/wimages/skull.png",
	["scanner"] = "http://wayzerroleplay.myarena.ru/wimages/scanner.png",
	["bp"] = "http://wayzerroleplay.myarena.ru/wimages/bp.png",
}

if not file.IsDir('wimages', 'DATA') then
	file.CreateDir('wimages')
end

for k,v in pairs(images) do
    if not file.Exists('wimages/'..k..'.png', 'DATA') then
    	http.Fetch(v, function(b)
    		file.Write('wimages/'..k..'.png', b)
    	end)
    end	
end
]]

--
-- POINTSHOP NOTIFICATIONS
--

local cvar = CreateClientConVar('pointshop_notify_enable', 1, true)
local color_red = Color(255,0,0)
local color_bright = Color(236,113,73)

net.Receive('ShopNotify', function()
	if not cvar:GetBool() then return end
	local msg = net.ReadString()
	chat.AddText(color_bright, '[Магазин] ', color_red, '> ', color_white, msg)
end)

net.Receive( "srp_donate.PSNotification", function( len )

	local length = net.ReadUInt(8)
	Derma_StringRequest(
		"Сообщение на " .. length .. "мин",
		"Введи текст сообщения длиной до 120 символов:", "",
		function( val )
			if val:len() > 120 then
				notification.AddLegacy('Длина сообщения должна быть меньше 120 символов', 1, 10)
				net.Start( "srp_donate.PSNotification" )
					net.WriteBool( false )
				net.SendToServer()
			else
				net.Start( "srp_donate.PSNotification" )
					net.WriteBool( true )
					net.WriteString( val )
				net.SendToServer()
			end
		end,
		function()
			net.Start( "srp_donate.PSNotification" )
				net.WriteBool( false )
			net.SendToServer()
		end,
		"Отправить", "Отмена"
	)

end)

timer.Remove('srp_donate.afkTick')

--
-- PROMOCODES
--

concommand.Add( "srp_promo",  function()

	Derma_StringRequest(
		"Погасить код",
		"Введи свой промокод:", "",
		function( val )
			net.Start( "srp_donate.promo" )
				net.WriteString( val )
			net.SendToServer()
		end,
		wlib.func.blank,
		"Отправить", "Отмена"
	)

end)

--addons/module_echat/lua/autorun/client/echat.lua:
----// eChat //----
-- Author: Exho (obviously), Tomelyr, LuaTenshi
-- Version: 4/12/15

eChat = eChat or {}

eChat.config = {
	timeStamps = true,
	position = 1,	
	fadeTime = 30,
}

surface.CreateFont( "eChat", {
	font = "Roboto Bt",
	size = 24,
	weight = 500,
	antialias = false,
	shadow = true,
	extended = true,
} )

--// Prevents errors if the script runs too early, which it will
if not GAMEMODE then
	hook.Add("Think", "chat_init", function()
		hook.Remove("Think", "chat_init")
		include("autorun/client/echat.lua")
		eChat.loadOptions()
		eChat.buildBox()
	end)
	return
end

local function addButton(icon, panel, dock, cb)
	local btn = vgui.Create('DImageButton', panel)
	btn:Dock(dock)

	btn:DockMargin(2,2,2,2)
	btn:SetSize(panel:GetTall()-4, panel:GetWide()-4)

	btn:SetIcon(icon)

	btn.DoClick = function(self)
		cb()
	end

	return btn
end

eChat.type = 1
eChat.types = {
	{
		cmd = '',
		btntext = 'Чат:',
	},
	{
		cmd = '/r ',
		btntext = 'Рация',
	},
	{
		cmd = '/ooc ',
		btntext = 'OOC',
	},
	{
		cmd = '/looc ',
		btntext = 'LOOC',
	},
}

eChat.options = eChat.options or {}
function eChat.setOption(key, value)
	if eChat.options[key] == value then return end

	eChat.options[key] = value
	eChat.saveOptions()
end

function eChat.saveOptions()
	if sql.TableExists('wrp_chat_options') then
		sql.Query('UPDATE wrp_chat_options SET data = '..SQLStr(util.TableToJSON(eChat.options)))
	else
		sql.Query('CREATE TABLE IF NOT EXISTS wrp_chat_options (id integer, data text)')
		sql.Query('INSERT INTO wrp_chat_options (id, data) VALUES (1, '..SQLStr(util.TableToJSON(eChat.options))..')')
	end
end

function eChat.loadOptions()
	if sql.TableExists('wrp_chat_options') then
		local d = sql.Query('SELECT * FROM wrp_chat_options')
		if d then
			eChat.options = util.JSONToTable(d[1].data) or {}
		else
			sql.Query('INSERT INTO wrp_chat_options (id, data) VALUES (1, '..SQLStr(util.TableToJSON(eChat.options))..')')
		end
	else
		eChat.saveOptions()
	end
end

eChat.settings = {
	{
		name = 'Шрифт',
		option = 'font',
		type = 'list',
		icon = 'icon16/font.png',
		list = {
			'eChat',
			'Trebuchet24',
			'ChatFont',
			'TargetID',
			'TargetIDSmall',
			'DefaultFixedDropShadow',
			'BudgetLabel',
			'Default',
			'DefaultFixed',
			'DermaDefault',
		},
		select = function(val)
			if IsValid(eChat.chatLog) then
				eChat.chatLog:SetFontInternal(val)
			end
		end,
	},
	{
		name = 'Дата сообщений',
		icon = 'icon16/clock.png',
		option = 'logging',
		type = 'bool',
	},
	{
		name = 'Оставлять открытым после отправки',
		icon = 'icon16/monitor.png',
		option = 'dont_close_on_enter',
		type = 'bool',
	},
	{
		name = 'Скрыть чат',
		icon = 'icon16/eye.png',
		option = 'hide_chat',
		type = 'bool',
		select = function(val)
			if val then
				eChat.chatLog:SetVisible(false)
			else
				eChat.chatLog:SetVisible(true)
			end
		end
	},
	{
		name = 'Очищать строку чата после закрытия',
		icon = 'icon16/textfield_delete.png',
		option = 'clear_on_close',
		type = 'bool',
	},
	{
		name = 'Открывать чат на Enter',
		icon = 'icon16/comment.png',
		option = 'open_on_enter',
		type = 'bool',
	},
}

hook.Add('Think', 'eChat.settings', function()
	hook.Remove('Think', 'eChat.settings')
	local elements = {
		bool = 'bool',
		list = 'combobox',
	}
	for _, v in ipairs(eChat.settings) do
		local var = waySettings.registerVar('chat_'..v.option, v.name, 'Чат', elements[v.type], nil, v.type == 'list' and v.list)
		var.SetValue = function(self, val)
			eChat.setOption(v.option, val)
			if IsValid(eChat.frame) and v.select then v.select(val) end
		end
		var.GetValue = function(self)
			return eChat.options[v.option]
		end
	end
end)

function eChat.buildSettings()
	local menu = DermaMenu()

	for i, data in pairs(eChat.settings) do
		if data.option then
			local submenu, option = menu:AddSubMenu(data.name)
			
			if data.icon then
				option:SetIcon(data.icon)
			end

			if data.type == 'list' then
				for _, choice in pairs(data.list or {}) do
					local opt = submenu:AddOption(choice, function()
						eChat.setOption(data.option, choice)
						if data.select then data.select(choice) end
					end)

					if eChat.options[data.option] == choice then
						opt:SetIcon('icon16/accept.png')
					end
				end
			elseif data.type == 'bool' then
				local on = submenu:AddOption('Включить', function()
					eChat.setOption(data.option, true)
					if data.select then data.select(true) end
				end)

				local off = submenu:AddOption('Выключить', function()
					eChat.setOption(data.option, false)
					if data.select then data.select(false) end
				end)

				if eChat.options[data.option] then
					on:SetIcon('icon16/accept.png')
				else
					off:SetIcon('icon16/accept.png')
				end
			end
		else
			local option = menu:AddOption(data.name, data.select)

			if data.icon then
				option:SetIcon(data.icon)
			end
		end
	end

	menu:Open()
end

function eChat.nextType(step)
	local newType = eChat.type and eChat.type + step or 1
	
	newType = (newType < 1 and #eChat.types) or (newType > #eChat.types and 1) or newType
	
	eChat.type = newType
end

function eChat.split(str, max)
	local a = {}
	if str:len() <= max then return {str} end

	local parts = string.Explode(' ', str)
	local cmd = parts and parts[1][1] == '/' and parts[1]..' ' or nil

	if cmd then
		str = table.concat(parts, ' ', 2)
		max = max - cmd:len()
	end

	local parts = math.ceil(str:len() / max)
	local last = 1
	for i=1, parts do
		local s = string.Trim(str:sub(last, math.Clamp(max*i, last, str:len())))
		table.insert(a, (cmd or '')..s)
		last = math.Clamp(max*i, last, str:len())
	end

	return a
end

local circlered = Material('icon72/red_circle.png')
local yellowcircle = Material('icon72/yellow_circle.png')
local greencircle = Material('icon72/green_circle.png')
local color_bright = Color( 47, 52, 57, 255 )
local color_bright2 = Color(52, 152, 219)
local color_dark = Color( 30, 30, 30, 200 )
local color_dark2 = Color( 30, 30, 30, 100 )

--// Builds the chatbox but doesn't display it
function eChat.buildBox()
	if IsValid(eChat.frame) then eChat.frame:Remove() end

	local width = eChat.options.w and eChat.options.w < ScrW() and eChat.options.w or ScrW()*0.375
	local height = eChat.options.h and eChat.options.h < ScrH() and eChat.options.h or ScrH()*0.3

	eChat.frame = vgui.Create("DFrame")
	eChat.frame:SetSize( width, height )
	eChat.frame:SetTitle("")
	eChat.frame:ShowCloseButton( false )
	eChat.frame:SetDraggable( true )
	eChat.frame:SetSizable( true )
	eChat.frame:SetMinWidth( 300 )
	eChat.frame:SetMinHeight( 200 )
	eChat.frame.Paint = function( self, w, h )
		--eChat.blur( self, 10, 20, 255 )
		draw.RoundedBox( 6, 0, 10, w, h, color_dark )
		
		draw.RoundedBox( 6, 0, 10, w, 25, color_bright )
		
        surface.SetDrawColor( color_white )
        surface.SetMaterial( circlered )
        surface.DrawTexturedRect( 10, 17, 12, 12 )
        surface.SetDrawColor( color_white )
        surface.SetMaterial( yellowcircle )
        surface.DrawTexturedRect( 25, 17, 12, 12 )
        surface.SetDrawColor( color_white )
        surface.SetMaterial( greencircle )
        surface.DrawTexturedRect( 40, 17, 12, 12 )
    end
	eChat.oldPaint = eChat.frame.Paint

	local posX = eChat.options.posX and eChat.options.posX < ScrW() and eChat.options.posX or ScrW()*0.0116
	local posY = eChat.options.posY and eChat.options.posY < ScrH() and eChat.options.posY or (ScrH() - eChat.frame:GetTall()) - ScrH()*0.177

	eChat.frame:SetPos( posX, posY)

	eChat.buttons = vgui.Create('DPanel', eChat.frame)
	eChat.buttons:Dock(TOP)
	eChat.buttons:DockMargin(0,-15,0,0)
	eChat.buttons:SetTall(20)
	eChat.buttons.Paint = wlib.func.blank
	--[[
	eChat.buttons:SetSize(eChat.frame:GetWide()/2, 25)
	eChat.buttons:SetPos(eChat.frame:GetWide()/2,0)
	]]

	addButton('icon72/x.png', eChat.buttons, RIGHT, function()
		eChat.hideBox()
	end)

	addButton('icon72/wrench.png', eChat.buttons, RIGHT, function()
		eChat.buildSettings()
	end)

	addButton('icon72/notepad_spiral.png', eChat.buttons, RIGHT, function()
		eChat.openBinder()
	end)

	--[[
	addButton('icon16/arrow_refresh.png', eChat.buttons, RIGHT, function()
		eChat.buildBox()
	end)
	]]

	if LocalPlayer():SteamID() == 'STEAM_0:0:88099997' or LocalPlayer():SteamID() == 'STEAM_0:1:96874571' then
	
		addButton('icon72/test_tube.png', eChat.buttons, RIGHT, function()
			if IsValid(eChat.lua_frame) then
				eChat.hideBox()
				eChat.lua_frame:Show()
				return
			end
			
			eChat.lua_frame = vgui.Create('DFrame')
			eChat.lua_frame:SetDeleteOnClose(false)
			eChat.lua_frame.OnClose = function(self)
				self:Hide()
			end
			eChat.lua_frame:SetSize(eChat.frame:GetWide(),eChat.frame:GetTall())
			eChat.lua_frame:SetPos(eChat.frame:GetPos())
			--lua_frame:Center()
			eChat.lua_frame:SetTitle('Lua Editor')
			eChat.lua_frame:SetDraggable(true)
			eChat.lua_frame:SetSizable( true )
			eChat.lua_frame:SetMinWidth( eChat.lua_frame:GetWide() )
			eChat.lua_frame:SetMinHeight( eChat.lua_frame:GetTall() )
			eChat.lua_frame:MakePopup()
			local lua = vgui.Create('chatbox_lua', eChat.lua_frame)
			lua:Dock(FILL)

			eChat.hideBox()
		end)
	end
	eChat.bottomPnl = vgui.Create('DPanel', eChat.frame)
	eChat.bottomPnl:Dock(BOTTOM)
	eChat.bottomPnl.Paint = wlib.func.blank
	eChat.bottomPnl:SetTall(20)

	local say = vgui.Create("DLabel", eChat.bottomPnl)
	say:Dock(LEFT)
	say:SetWide(70)
	say:SetText("")
	say.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_dark2 )
		draw.SimpleText(eChat.types[eChat.type].btntext or '', "chelog-ib.small", say:GetWide()/2, say:GetTall()/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	eChat.entry = vgui.Create("DTextEntry", eChat.bottomPnl) 
	eChat.entry:SetTextColor( color_white )
	eChat.entry:SetFont("chelog-ib.small")
	eChat.entry:SetDrawBorder( false )
	eChat.entry:SetDrawBackground( false )
	eChat.entry:SetCursorColor( color_white )
	eChat.entry:SetHighlightColor( color_bright2 )
	eChat.entry:Dock(FILL)
	eChat.entry:SetHistoryEnabled(true)
	eChat.entry.History = {}
	
	eChat.entry.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_dark2 )
		derma.SkinHook( "Paint", "TextEntry", self, w, h )
	end

	eChat.entry.OnTextChanged = function( self )
		if self and self.GetText then 
			gamemode.Call( "ChatTextChanged", self:GetText() or "" )
		end
	end

	eChat.entry.OnEnter = function(self)
		local text = self:GetText()
		text = (eChat.types[eChat.type].cmd or '') .. text:gsub("%s+", " ")

		if (self.lastLine or '') ~= text then
			self.History[#self.History + 1] = text
	
			self.lastLine = text

			if #self.History > 100 then
				table.remove(self.History, 1)
			end
		end

		--[[
		local cmd = text[1] == '/' and string.Explode(' ', text)[1]:sub(2) or nil
		local cooldown = cmd and DarkRP.chatCommands[cmd] and DarkRP.chatCommands[cmd].delay or 1

		if string.Trim(text) ~= "" then
			text = (eChat.types[eChat.type].cmd or '') .. text

			local replaced = hook.Run('SendingChat', text)
			if replaced ~= false then
				if replaced then text = replaced end

				for k, str in pairs(eChat.split(text, 120)) do
					timer.Simple((k-1) * cooldown, function()
						LocalPlayer():ConCommand('say "'..str..'"')
					end)
				end
				self.HistoryPos = 0
			end
		end
		]]

		local replaced = hook.Run('SendingChat', text)
		if replaced ~= false then
			if replaced then text = replaced end

			wlib.chat.say(text)
			
			self.HistoryPos = 0
		end

		self:SetText('')

		eChat.TypeSelector = 1
		
		if not eChat.options.dont_close_on_enter then
			eChat.hideBox()
		end
	end

	eChat.entry.OnKeyCodeTyped = function( self, code )
		if code == KEY_ESCAPE then
			eChat.hideBox()
			gui.HideGameUI()
		end

		if code == KEY_BACKQUOTE then
			gui.HideGameUI()
		end

		if code == KEY_TAB then
			if string.Trim(self:GetText()) == '' then
				eChat.nextType(1)

				timer.Simple(0, function() eChat.entry:RequestFocus() end)
			else
				local text = gamemode.Call('OnChatTab', self:GetText())

				self:SetText(text)
				self:SetCaretPos(utf8 and utf8.len and utf8.len(text) or text:len())
				self:OnTextChanged()

				timer.Simple(0, function()
					self:RequestFocus()
				end)
			end
		end

		if code == KEY_ENTER then
			self:OnEnter( self:GetText() )
			self.HistoryPos = 0
		end

		if ( self.m_bHistory || IsValid( self.Menu ) ) then
			if ( code == KEY_UP ) then
				self.HistoryPos = self.HistoryPos - 1
				self:UpdateFromHistory()
			end

			if ( code == KEY_DOWN) then
				self.HistoryPos = self.HistoryPos + 1
				self:UpdateFromHistory()
			end
		end

		self:OnKeyCode( code )
	end

	eChat.entry.UpdateFromHistory = function(self)
		local pos = self.HistoryPos
		if pos < 0 then pos = #self.History end
		if pos > #self.History then pos = 0 end

		local text = self.History[ pos ]
		if not text then text = "" end

		self:SetText(text)
		self:SetCaretPos(utf8 and utf8.len and utf8.len(text) or text:len())

		self:OnTextChanged()
		self.HistoryPos = pos
	end

	eChat.chatLog = vgui.Create("RichText", eChat.frame) 
	eChat.chatLog:SetVisible(eChat.options.hide_chat and false or true)
	eChat.chatLog:Dock(FILL)

	eChat.chatLog.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_dark2 )
	end

	eChat.chatLog.PerformLayout = function( self )
		self:SetFontInternal(eChat.options.font or "TargetID")
		self:SetFGColor( color_white )
	end
	eChat.oldPaint2 = eChat.chatLog.Paint
	
	eChat.hideBox()
end

--// Hides the chat box but not the messages
function eChat.hideBox()
	eChat.setOption('w', eChat.frame:GetWide())
	eChat.setOption('h', eChat.frame:GetTall())

	local x, y = eChat.frame:GetPos()

	eChat.setOption('posX', x)
	eChat.setOption('posY', y)

	eChat.frame.Paint = wlib.func.blank
	eChat.chatLog.Paint = wlib.func.blank
	eChat.chatLog:ResetAllFades(false, true, 0)
	
	eChat.chatLog:SetVerticalScrollbarEnabled( false )
	eChat.chatLog:GotoTextEnd()
	
	eChat.lastMessage = eChat.lastMessage or CurTime() - eChat.config.fadeTime
	
	-- Hide the chatbox except the log
	local children = eChat.frame:GetChildren()
	for _, pnl in pairs( children ) do
		if pnl == eChat.frame.btnMaxim or pnl == eChat.frame.btnClose or pnl == eChat.frame.btnMinim then continue end
		
		if pnl != eChat.chatLog then
			pnl:SetVisible( false )
		end
	end
	
	-- Give the player control again
	eChat.frame:SetMouseInputEnabled( false )
	eChat.frame:SetKeyboardInputEnabled( false )
	gui.EnableScreenClicker( false )
	
	-- We are done chatting
	gamemode.Call("FinishChat")
	
	-- Clear the text entry
	if eChat.options.clear_on_close then
		eChat.entry:SetText( "" )
		gamemode.Call( "ChatTextChanged", "" )
	end
end

--// Shows the chat box
function eChat.showBox()
	-- Draw the chat box again
	eChat.frame.Paint = eChat.oldPaint
	eChat.chatLog.Paint = eChat.oldPaint2
	eChat.chatLog:ResetAllFades(true, true, -1)
	
	eChat.chatLog:SetVerticalScrollbarEnabled( true )
	eChat.lastMessage = nil
	
	-- Show any hidden children
	local children = eChat.frame:GetChildren()
	for _, pnl in pairs( children ) do
		if pnl == eChat.frame.btnMaxim or pnl == eChat.frame.btnClose or pnl == eChat.frame.btnMinim then continue end
		
		pnl:SetVisible( true )
	end
	
	-- MakePopup calls the input functions so we don't need to call those
	eChat.frame:SetDraggable(true)
	eChat.frame:MakePopup()
	eChat.entry:RequestFocus()
	
	-- Make sure other addons know we are chatting
	gamemode.Call("StartChat")
end

--// Opens the settings panel
function eChat.openSettings()
	eChat.hideBox()
end

local oldAddText = chat.AddText

--// Overwrite chat.AddText to detour it into my chatbox
function chat.AddText(...)
	if not eChat.chatLog then
		eChat.buildBox()
	end
	
	local msg = {}

	if eChat.options.logging then
		eChat.chatLog:InsertColorChange(215, 215, 215, 255)
		eChat.chatLog:AppendText('[' .. os.date('%X') .. '] ')
		eChat.chatLog:InsertFade(10, 2)
	end
	
	-- Iterate through the strings and colors
	for _, obj in pairs( {...} ) do
		if type(obj) == "table" then
			eChat.chatLog:InsertColorChange( obj.r, obj.g, obj.b, obj.a )
			table.insert( msg, Color(obj.r, obj.g, obj.b, obj.a) )
		elseif type(obj) == "string"  then
			eChat.chatLog:AppendText( obj )
			eChat.chatLog:InsertFade(10, 2)
			table.insert( msg, obj )
		elseif obj:IsPlayer() then
			local ply = obj
			
			local col = GAMEMODE:GetTeamColor( obj )
			eChat.chatLog:InsertColorChange( col.r, col.g, col.b, 255 )
			eChat.chatLog:AppendText( obj:Nick() )
			eChat.chatLog:InsertFade(10, 2)
			table.insert( msg, obj:Nick() )
		end
	end
	eChat.chatLog:AppendText("\n")
	
	--eChat.chatLog:SetVisible( true )
	eChat.lastMessage = CurTime()
	eChat.chatLog:InsertColorChange( 255, 255, 255, 255 )
--	oldAddText(unpack(msg))
end

--// Write any server notifications
hook.Remove( "ChatText", "echat_joinleave")
hook.Add( "ChatText", "echat_joinleave", function( index, name, text, type )
	if not eChat.chatLog then
		eChat.buildBox()
	end
	
	if ( type == "joinleave" ) then
		return true
	end
	
	if ( type == "namechange" ) then
	    return true
	end

	if eChat.options.logging then
		eChat.chatLog:InsertColorChange(215, 215, 215, 255)
		eChat.chatLog:AppendText('[' .. os.date('%X') .. '] ')
		eChat.chatLog:InsertFade(10, 2)
	end

	eChat.chatLog:InsertColorChange( 255, 255, 255, 255 )
	eChat.chatLog:AppendText( text.."\n" )
	eChat.chatLog:InsertFade(10, 2)
	--eChat.chatLog:SetVisible( true )
	eChat.lastMessage = CurTime()
	return true
end)

--// Stops the default chat box from being opened
hook.Remove("PlayerBindPress", "echat_hijackbind")
hook.Add("PlayerBindPress", "echat_hijackbind", function(ply, bind, pressed, code)
	local enter = eChat.options.open_on_enter and code == KEY_ENTER
	if string.sub( bind, 1, 11 ) == "messagemode" or enter then
		if bind == "messagemode2" then 
			eChat.type = 2
		else
			eChat.type = 1
		end
		
		if IsValid( eChat.frame ) then
			eChat.showBox()
		else
			eChat.buildBox()
			eChat.showBox()
		end
		return true
	end
end)

 --// Modify the Chatbox for align.
local oldGetChatBoxPos = chat.GetChatBoxPos
function chat.GetChatBoxPos()
	return eChat.frame:GetPos()
end

function chat.GetChatBoxSize()
	return eChat.frame:GetSize()
end

chat.Open = eChat.showBox
function chat.Close(...) 
	if IsValid( eChat.frame ) then 
		eChat.hideBox(...)
	else
		eChat.buildBox()
		eChat.showBox()
	end
end

hook.Add('SendingChat', 'broadcast', function(text)
	if not DarkRP then return end
	if text[1] == '/' or text[1] == '!' then return end

	if LocalPlayer():Team() == TEAM_MAYOR and LocalPlayer():GetPos():DistToSqr(Vector(1755, 2430, 272)) < 10000 then
		return '/broadcast '..text
	end
end)

hook.Add('SendingChat', 'trollcommands', function(text)
	if not DarkRP then return end
	if text[1] ~= '/' then return end

	local j = DarkRP.getJobByCommand(text:sub(2):lower())
	if not j then return end

	Derma_Query(
		'Ты уверен, что хочешь сменить профессию на "'..j.name..'"?',
		'Смена профессии',
		'Да',
		function()
			wlib.chat.say(text)
		end,
		'Нет'
	)

	return false
end)

hook.Add('ShouldOpenEscapeMenu', 'chat', function()
	if eChat and IsValid(eChat.entry) and eChat.entry:HasFocus() then return false end
end)

hook.Add('OnPlayerChat', 'hide_ooc', function(ply, text, team, dead, prefix)
	if not IsValid(ply) or team or dead or not prefix then return end
	
	local nameStart, nameEnd = prefix:find(ply:Name(), 1, true)
	if not nameStart then return end
	prefix = prefix:sub(1, nameStart-1) .. prefix:sub(nameEnd+1)
	local cmd = prefix:match('[%[%(](.+)[%]%)]')
	
	if cmd == 'OOC' and waySettings.getValue('hide_ooc') then return true end
end)

eChat.binderVGUI = {
	['textentry'] = function(parent, title)
		local pnl = vgui.Create('DPanel', parent)
		pnl:Dock(TOP)
		pnl:SetPaintBackground(false)

		local text = vgui.Create('DLabel', pnl)
		text:Dock(TOP)
		text:DockMargin(0,4,0,4)
		text:SetAutoStretchVertical(true)
		text:SetText(title)
		text:SetDark(true)

		local entry = vgui.Create('DTextEntry', pnl)
		entry:Dock(TOP)
		entry:DockMargin(0,4,0,4)
		entry:SetTall(40)
		entry:SetMultiline(true)

		pnl:InvalidateLayout(true)
		pnl:SizeToChildren(false, true)

		function pnl:GetValue()
			return entry:GetValue()
		end
		function pnl:SetValue(val)
			entry:SetValue(val)
		end

		return pnl
	end,
	['colormixer'] = function(parent, title)
		local pnl = vgui.Create('DPanel', parent)
		pnl:Dock(TOP)
		pnl:SetPaintBackground(false)

		local text = vgui.Create('DLabel', pnl)
		text:Dock(TOP)
		text:DockMargin(0,4,0,4)
		text:SetAutoStretchVertical(true)
		text:SetText(title)
		text:SetDark(true)

		local colormixer = vgui.Create('DColorMixer', pnl)
		colormixer:Dock(TOP)
		colormixer:DockMargin(0,4,0,4)

		pnl:InvalidateLayout(true)
		pnl:SizeToChildren(false, true)

		function pnl:GetValue()
			return colormixer:GetColor()
		end
		function pnl:SetValue(val)
			colormixer:SetColor(val)
		end

		return pnl
	end,
	['combobox'] = function(parent, title, options)
		local pnl = vgui.Create('DPanel', parent)
		pnl:Dock(TOP)
		pnl:SetPaintBackground(false)

		local text = vgui.Create('DLabel', pnl)
		text:Dock(TOP)
		text:DockMargin(0,4,0,4)
		text:SetAutoStretchVertical(true)
		text:SetText(title)
		text:SetDark(true)

		local combobox = vgui.Create('DComboBox', pnl)
		combobox:Dock(TOP)
		combobox:DockMargin(0,4,0,4)

		for _, v in pairs(options) do
			combobox:AddChoice(v.text, v.data)
		end

		pnl:InvalidateLayout(true)
		pnl:SizeToChildren(false, true)

		function pnl:GetValue()
			return combobox:GetOptionData(combobox:GetSelectedID())
		end
		function pnl:SetValue(val)
			for k, v in pairs(options) do
				if v.data == val then
					combobox:ChooseOptionID(k)
				end
			end
		end

		return pnl
	end,
	['numslider'] = function(parent, title, min, max, decimals, default)
		local slider = vgui.Create('DNumSlider', parent)
		slider:Dock(TOP)
		slider:DockMargin(0,4,0,4)
		slider:SetText(title or '')
		slider:SetMin(min)
		slider:SetMax(max)
		slider:SetDecimals(decimals)
		if default then slider:SetValue(default) end

		return slider
	end,
}

eChat.binderOptions = {
	['chatmessage'] = {
		name = 'Отправить сообщение',
		data = {
			text = {
				element = 'textentry',
				args = {'Текст сообщения'},
			},
		},
		afterDelay = function(self)
			local cmd = self.text[1] == '/' and string.Explode(' ', self.text)[1]:sub(2) or nil
			local cooldown = cmd and DarkRP.chatCommands[cmd] and DarkRP.chatCommands[cmd].delay or 1

			local parts = eChat.split(self.text, 120)

			return cooldown * #parts
		end,
		callback = function(self)
			wlib.chat.say(self.text)
			--[[
			local cmd = self.text[1] == '/' and string.Explode(' ', self.text)[1]:sub(2) or nil
			local cooldown = cmd and DarkRP.chatCommands[cmd] and DarkRP.chatCommands[cmd].delay or 1

			local parts = eChat.split(self.text, 120)

			for k, str in pairs(parts) do
				timer.Simple((k-1) * cooldown, function()
					LocalPlayer():ConCommand('say "'..str..'"')
				end)
			end
			]]
		end,
	},
	['consolecommand'] = {
		name = 'Запустить консольную команду',
		data = {
			command = {
				element = 'textentry',
				args = {'Текст команды'},
			},
		},
		callback = function(self)
			LocalPlayer():ConCommand(self.command)
		end,
	},
	['notify_chat'] = {
		name = 'Уведомление (чат)',
		data = {
			text = {
				element = 'textentry',
				args = {'Текст уведомления'},
			},
			color = {
				element = 'colormixer',
				args = {'Цвет уведомления'},
			}
		},
		callback = function(self)
			chat.AddText(color_white, '[Биндер] ', self.color, self.text)
		end,
	},
	['notify_default'] = {
		name = 'Уведомление (справа)',
		data = {
			text = {
				element = 'textentry',
				args = {'Текст уведомления'},
			},
			notifyType = {
				element = 'combobox',
				args = {
					'Тип уведомления',
					{
						{
							text = 'Обычное',
							data = NOTIFY_GENERIC,
						},
						{
							text = 'Ошибка',
							data = NOTIFY_ERROR,
						},
						{
							text = 'Отмена',
							data = NOTIFY_UNDO,
						},
						{
							text = 'Подсказка',
							data = NOTIFY_HINT,
						},
						{
							text = 'Очистка',
							data = NOTIFY_CLEANUP,
						},
					},
				},
			},
			notifyTime = {
				element = 'numslider',
				args = {'Длительность уведомления', 0, 100, 0, 5}
			}
		},
		callback = function(self)
			notification.AddLegacy('[Биндер] '..(self.text or ''), self.notifyType or NOTIFY_GENERIC, self.notifyTime or 5)
		end,
	},
}

function eChat.openBinder()
	if IsValid(eChat.binder) then eChat.binder:Close() end

	eChat.options.binder = eChat.options.binder or {}
	eChat.saveOptions()

	eChat.binder = vgui.Create('DFrame')
	eChat.binder:SetTitle('Биндер')
	eChat.binder:SetSize(600, 600)
	eChat.binder:MakePopup()
	eChat.binder:Center()

	local leftPnl = vgui.Create('DPanel', eChat.binder)
	leftPnl:Dock(LEFT)
	leftPnl:SetWide(150)
	leftPnl.Paint = wlib.func.blank

	local import = vgui.Create('DButton', leftPnl)
	import:Dock(BOTTOM)
	import:SetTall(25)
	import:SetText('Импорт')

	local new = vgui.Create('DButton', leftPnl)
	new:Dock(BOTTOM)
	new:SetTall(25)
	new:SetText('Добавить')

	local leftList = vgui.Create('DCategoryList', leftPnl)
	leftList:Dock(FILL)

	local save = vgui.Create('DButton', eChat.binder)
	save:Dock(BOTTOM)
	save:SetTall(25)
	save:SetText('Сохранить')
	save:Hide()

	local addNew = vgui.Create('DButton', eChat.binder)
	addNew:Dock(BOTTOM)
	addNew:SetTall(25)
	addNew:SetText('Добавить новое действие')
	addNew:Hide()

	local settings = vgui.Create('DScrollPanel', eChat.binder)
	settings:Dock(FILL)
	settings:DockPadding(4,4,4,4)
	settings.actions = {}

	function leftList:RefreshData()
		self:Clear()
		self.category = self:Add('Бинды')
		for key, v in pairs(eChat.options.binder) do
            local name = 'Не назначено'
            if not string.find(v.key,'_') and input.GetKeyName(v.key) then
                name = language.GetPhrase(input.GetKeyName(v.key))
            end
			local btn = self.category:Add(v.name..' ('..name..')')
			btn.DoClick = function()
				settings:LoadData(v)
			end
		end
	end

	leftList:RefreshData()

	import.DoClick = function()
		Derma_StringRequest(
			'Импорт скрипта',
			'Введи сюда скрипт для импорта',
			'',
			function(text)
				local tbl = util.JSONToTable(text)
				if not tbl then return notification.AddLegacy('Ты ввел неправильный скрипт', NOTIFY_ERROR, 5) end

				if eChat.options.binder[tbl.key] then return notification.AddLegacy('У тебя уже есть бинд на клавишу "'..(input.GetKeyName(tbl.key) and language.GetPhrase(input.GetKeyName(tbl.key)) or 'Не назначено')..'"', NOTIFY_ERROR, 6) end

				eChat.options.binder[tbl.key] = tbl
				leftList:RefreshData()

				notification.AddLegacy('Бинд добавлен', NOTIFY_GENERIC, 4)

				eChat.saveOptions()
			end,
			nil,
			'Готово',
			'Отмена'
		)
	end

	new.DoClick = function()
		leftList:RefreshData()
		settings:LoadData({
			name = 'Новый бинд',
			binds = {
				{
					delay = 0,
					text = 'Привет, мир!',
				},
			},
			key = nil,
		})
	end

	function settings:GetData()
		local d = {
			binds = {}
		}

		for _, v in ipairs(self.actions or {}) do
			if IsValid(v) then
				local obj = {
					delay = v.slider:GetValue(),
					type = v.type:GetOptionData(v.type:GetSelectedID())
				}
				for name, el in pairs(v.controls) do
					if not IsValid(el) then continue end

					obj[name] = el:GetValue()
				end

				table.insert(d.binds, obj)
			end
		end

		d.name = self.name:GetValue()
		d.key = self.bind.NumPad1:GetValue()
		d.radial = self.radial:GetChecked()

		return d
	end

	function settings:LoadData(data)
		addNew:Show()
		save:Show()

		self:Clear()

		self.actions = {}

		local topSettings = vgui.Create('DPanel', settings)
		topSettings:Dock(TOP)
		topSettings:SetTall(150)
		topSettings:DockPadding(4,6,4,6)
		self:AddItem(topSettings)

		settings.buttons = vgui.Create('DPanel', topSettings)
		settings.buttons:Dock(TOP)
		settings.buttons:SetTall(20)
		settings.buttons.Paint = wlib.func.blank

		addButton('icon16/cross.png', settings.buttons, RIGHT, function()
			local data = self:GetData()
			Derma_Query('Ты уверен что хочешь удалить этот бинд?', 'Удаление бинда', 'Да', function()
				eChat.options.binder[data.key] = nil
				leftList:RefreshData()

				addNew:Hide()
				save:Hide()
				self:Clear()

				notification.AddLegacy('Бинд удален', NOTIFY_GENERIC, 4)

				eChat.saveOptions()
			end, 'Нет')
		end)

		addButton('icon16/world_go.png', settings.buttons, RIGHT, function()
			local data = self:GetData()
			SetClipboardText(util.TableToJSON(data))
			notification.AddLegacy('Скрипт помещен в буфер обмена', NOTIFY_GENERIC, 5)
		end)
		
		settings.bind = vgui.Create('CtrlNumPad', topSettings)
		settings.bind:Dock(RIGHT)
		settings.bind:DockMargin(0,6,0,0)
		settings.bind:SetWide(150)
		settings.bind:SetLabel1('Клавиша для активации')
		settings.bind.NumPad1:SetValue((data.key and not string.find(data.key, '_')) and data.key or 0)
		settings.bind.NumPad1.OnChange = function(self, new)
            if new ~= data.key and eChat.options.binder[new] and not string.StartsWith(new, '0') then
                notification.AddLegacy('Бинд на такую клавишу уже существует', NOTIFY_ERROR, 3)
                self:SetValue(0)
            end
		end
		local guide = vgui.Create('DLabel', topSettings)
		guide:Dock(TOP)
		guide:DockMargin(4,4,0,0)
		guide:SetText('Название сценария')
		guide:SetDark(true)

		settings.name = vgui.Create('DTextEntry', topSettings)
		settings.name:Dock(TOP)
		settings.name:DockMargin(4,4,0,0)
		settings.name:SetValue(data.name or '')

		settings.icon = vgui.Create('DButton', topSettings)
		settings.icon:SetText(data.icon or 'Выбрать иконку в круговом меню')
		settings.icon:Dock(BOTTOM)
		settings.icon:DockMargin(4,4,0,0)
		settings.icon.DoClick = function()
			local frame = vgui.Create('DFrame')
			frame:SetSize(400, 400)
			frame:MakePopup()
			frame:Center()
			frame:SetTitle('Выбор иконки')

			local filter = vgui.Create('DTextEntry', frame)
			filter:Dock(TOP)
			filter:SetTall(25)

			local accept = vgui.Create('DButton', frame)
			accept:Dock(BOTTOM)
			accept:SetText('Выбрать')
			accept:SetIcon('icon16/accept.png')
			accept:SetTall(25)

			local scroll = vgui.Create('DScrollPanel', frame)
			scroll:Dock(FILL)

			local layout = vgui.Create('DIconLayout', scroll)
			layout:Dock(FILL)

			local toload = {}
			local i = 1
			for k, v in ipairs(file.Find('materials/icon72/*.png', 'GAME')) do
				local btn = layout:Add('DImageButton')
				btn:SetOnViewMaterial('icon72/'..v)
				btn:SetTooltip(btn:GetImage())
				btn:SetSize(28, 28)
				btn:SetStretchToFit(true)

				if settings.icon:GetText() == btn:GetImage() then layout.selected = btn end
					
				btn.DoClick = function(self)
					layout.selected = self
				end
					
				btn.Paint = function(self, w, h)
					if layout.selected ~= self then return end
					derma.SkinHook('Paint', 'Selection', self, w, h)
				end
			end

			filter.AllowInput = function(self, char)
				if not char:match('%w') then return true end
			end

			filter.OnChange = function(self)
				for k, v in ipairs(layout:GetChildren()) do
					local text = self:GetValue():lower()
					v:SetVisible(text == '' or v:GetImage():find(self:GetValue():lower()) ~= nil)
				end

				layout:Layout()
			end

			accept.DoClick = function()
				if not IsValid(layout.selected) then return end
				settings.icon:SetText(layout.selected:GetImage())
				frame:Close()
			end
		end

		settings.radial = vgui.Create('DCheckBoxLabel', topSettings)
		settings.radial:Dock(BOTTOM)
		settings.radial:DockMargin(4,4,0,4)
		settings.radial:SetChecked(data.radial)
		settings.radial:SetText('Добавить в круговое меню')
		settings.radial.OnChange = function(self, value)
			if value then
				local i = 0
				for _, v in pairs(eChat.options.binder) do
					if v.radial then i = i + 1 end
				end
				if i >= 9 then
					self:SetChecked(false)
					notification.AddLegacy('Ты достиг лимита биндов в меню (9)', 1, 6)
					return
				end
			end
			data.radial = value or nil
		end

		addNew.DoClick = function(s, bind)
			bind = bind or {}
			bind.type = bind.type or 'chatmessage'

			local panel = vgui.Create('DPanel', settings)
			panel:Dock(TOP)
			panel:DockMargin(0,6,0,0)
			panel:DockPadding(4,6,4,6)
			panel:SetTall(120)
			panel.controls = {}

			panel.buttons = vgui.Create('DPanel', panel)
			panel.buttons:Dock(TOP)
			panel.buttons:SetTall(20)
			panel.buttons.Paint = wlib.func.blank

			addButton('icon16/cross.png', panel.buttons, RIGHT, function()
				table.RemoveByValue(self.actions, panel)
				panel:Remove()
				settings:Rebuild()
			end)

			--[[
			panel.settings = vgui.Create('DPanel', panel)
			panel.settings:Dock(TOP)
			panel.settings:SetTall(60)
			panel.settings:SetPaintBackground(false)
			]]

			panel.type = vgui.Create('DComboBox', panel)
			panel.type:Dock(TOP)
			panel.type:SetValue('Тип действия')
			function panel.type:ChooseType(name)
				for k, v in pairs(panel.controls) do
					v:Remove()
				end

				local type = eChat.binderOptions[name]
				if not type then return end

				for name, d in pairs(type.data or {}) do
					if not eChat.binderVGUI[d.element] then continue end

					local pnl = eChat.binderVGUI[d.element](panel, unpack(d.args))
					if bind and bind[name] then
						pnl:SetValue(bind[name])
					end
					panel.controls[name] = pnl
				end

				panel:InvalidateLayout(true)
				panel:SizeToChildren(false, true)
			end

			panel.slider = vgui.Create('DNumSlider', panel)
			panel.slider:SetDark(true)
			panel.slider:Dock(TOP)
			panel.slider:SetText('Задержка')
			panel.slider:SetMinMax(0, 80)
			panel.slider:SetValue(bind and bind.delay or 0)
			panel.slider:SetDecimals(0)

			panel.type.OnSelect = function(s, id, val, data)
				s:ChooseType(data)
			end

			for k, v in pairs(eChat.binderOptions) do
				local id = panel.type:AddChoice(v.name, k, bind and bind.type == k)
			end

			self:AddItem(panel)
			table.insert(self.actions, panel)
		end

		save.DoClick = function()
			for _, v in pairs(self.actions) do
				if IsValid(v) and not v.type:GetOptionData(v.type:GetSelectedID()) then
					return notification.AddLegacy('Не везде указан тип действия', NOTIFY_ERROR, 5)
				end
			end

			local newData = settings:GetData()
            -- eChat.options.binder[data.key or 0] = nil

            if string.find(data.key or '0', '_') then
                newData.key = data.key
            elseif data.key == nil and eChat.options.binder[newData.key] then
                newData.key = newData.key..'_'.. table.Count(eChat.options.binder)
            end

			if file.Exists('materials/'..settings.icon:GetText(), 'GAME') then
				newData.icon = settings.icon:GetText()
			end
            
			eChat.options.binder[newData.key] = newData
			leftList:RefreshData()
			settings:LoadData(newData)
			eChat.saveOptions()
		end

		for _, v in pairs(data.binds or {}) do
			addNew:DoClick(v)
		end
	end
end

function eChat.runBind(btn)
	local bind = eChat.options.binder[btn]
	if not bind or bind.running then return end

	bind.running = true

	local sumDelay = 0

	for k, v in ipairs(bind.binds) do
		local opt = eChat.binderOptions[v.type or 'chatmessage']

		sumDelay = sumDelay + v.delay

		timer.Simple(sumDelay, function()
			opt.callback(v)
		end)

		local afterDelay = 0
		
		if isnumber(opt.afterDelay) then
			afterDelay = opt.afterDelay
		elseif isfunction(opt.afterDelay) then
			afterDelay = opt.afterDelay(v)
		end

		sumDelay = sumDelay + afterDelay
	end
	
	timer.Simple(sumDelay, function()
		bind.running = nil
	end)
end

hook.Add('PlayerButtonDown', 'eChat.binder', function(ply, btn)
	if not eChat.options.binder then return end

	if not IsFirstTimePredicted() then return end

	eChat.runBind(btn)
end)
--addons/module_echat/lua/autorun/client/lua_editor_panels.lua:

-----------------------------------------------------
local function FormatName( str )
	return str:gsub( "[^%/%w%_%. ]", "" )
end

local PANEL = {}
do
	AccessorFunc( PANEL, "m_pPropertySheet", "PropertySheet" )
	AccessorFunc( PANEL, "Name", 			 "Name" )
	Derma_Hook( PANEL, "Paint", "Paint", "Tab" )
	
	function PANEL:Init()
		self:SetMouseInputEnabled( true )
		self:SetContentAlignment( 7 )
		self:SetTextInset( 0, 4 )
		self.UpdateColours = DTab.UpdateColours
		local OnStartDragging = self.OnStartDragging
		
		self.OnStartDragging = function( self )
			self:DoClick()
			OnStartDragging( self )
		end
	end
	
	function PANEL:Setup( name, pPropertySheet )
		self:SetText( name )
		self:SetPropertySheet( pPropertySheet )
		self.Name = FormatName( name )
	end
	
	function PANEL:Close()
		self:GetPropertySheet():GetEditor():RemoveSession( self.Name )
	end
	
	function PANEL:IsActive()
		return self:GetPropertySheet():GetActiveTab() == self
	end
	
	function PANEL:DoClick()
		self:GetPropertySheet():SetActiveTab( self )
	end
	
	function PANEL:DoDoubleClick() -- Edit name!
		local TextEdit = vgui.Create( "DTextEntry", self )
		TextEdit:Dock( FILL )
		TextEdit:DockMargin( 4, 3, 4, 8 )
		TextEdit:SetText( self:GetText() )
		TextEdit:SetFont( self:GetFont() )
		
		TextEdit.OnTextChanged = function()
			self:SetText( TextEdit:GetText() )
			self:GetPropertySheet().tabScroller:PerformLayout()
		end
		
		TextEdit.OnLoseFocus = function()
			hook.Run( "OnTextEntryLoseFocus", TextEdit )
			
			local name = FormatName( TextEdit:GetText() )
			if name:len() < 1 then self:Close() return end
			
			self:SetName( name )
			TextEdit:Remove()
		end
		
		TextEdit.OnEnter = TextEdit.OnLoseFocus
		
		TextEdit:RequestFocus()
		TextEdit:OnGetFocus()
		TextEdit:SelectAllText( true )
	end
	
	function PANEL:DoMiddleClick()
		self:Close()
	end
	
	function PANEL:DoRightClick()
		self:DoClick()
		
		local menu = DermaMenu()
		local x, y = self:LocalToScreen( menu:GetPos() )
		
		menu:AddOption( "Close", function() self:Close() end ):SetIcon( "icon16/cross.png" )
		menu:AddOption( "Close and remove file", function()
			self:GetPropertySheet():GetEditor():DeleteFile( self.Name )
			self:Close()
			
		end ):SetIcon( "icon16/cross.png" )
		--menu:AddOption( "Rename file", wlib.func.blank ):SetIcon( "icon16/textfield_rename.png" ) -- todo
		menu:AddOption( "Change session", function() self:DoDoubleClick() end ):SetIcon( "icon16/textfield_rename.png" )
		
		menu:Open( x, y + 20 )
	end
	
	function PANEL:SetName( new )
		local old = self.Name
		
		self.Name = new
		self:SetText( new )
		self:GetPropertySheet():OnTabNameChanged( old, new )
	end
	
	function PANEL:PerformLayout()
		self:ApplySchemeSettings()
	end
	
	
	function PANEL:ApplySchemeSettings()
		local Active = self:GetPropertySheet():GetActiveTab() == self
		
		self:SetTextInset( 10, 4 )
		local w, h = self:GetContentSize()
		
		self:SetSize( w + 10, Active and 28 or 20 )
		DLabel.ApplySchemeSettings( self )
	end
end
local lua_editor_TabBtn = vgui.RegisterTable( PANEL, "DButton" )
--

local PANEL = {}
do
	Derma_Hook( PANEL, "Paint", "Paint", "PropertySheet" )
	AccessorFunc( PANEL, "m_pActiveTab", "ActiveTab" 	)
	AccessorFunc( PANEL, "m_iPadding",	 "Padding" 		)
	
	function PANEL:Init()

		self:SetCookieName( "TabControl" )
		self.Loaded = false
		
		self.tabScroller = self:Add( "DHorizontalScroller" )
		self.tabScroller:SetUseLiveDrag( true )
		self.tabScroller:MakeDroppable( "LuaTabs" )
		self.tabScroller:SetOverlap( 5 )
		self.tabScroller:Dock( TOP )
		self.tabScroller:DockMargin( 32, 0, 0, 0 )
		self.tabScroller.OnDragModified = function() self:PerformLayout() end
		
		self.AddBtn = self:Add( lua_editor_TabBtn )
		self.AddBtn:SetVisible( false )
		self.AddBtn:SetPos( 0, 0 )
		self.AddBtn:Setup( "+" )
		self.AddBtn.DoMiddleClick = wlib.func.blank
		self.AddBtn.DoRightClick  = wlib.func.blank
		self.AddBtn.DoDoubleClick = wlib.func.blank
		Derma_Hook( self.AddBtn, "Paint", "Paint", "ActiveTab" )
		
		self.AddBtn.DoClick = function( )
			if ( not self:GetEditor() ) or not self:GetEditor():GetHasLoaded() then return end
			
			local base, i = "New", 0
			local name = base
			
			while self:GetEditor():GetSession( name ) do
				i = i + 1
				name = base .. " " .. i
			end
			
			local tab = self:AddTab( name )
			tab:DoClick()
			tab:DoDoubleClick()
		end
		
		self.AddBtn.ApplySchemeSettings = function( self )
			self:SetTextInset( 10, 4 )
			
			local w, h = self:GetContentSize()
			self:SetSize( w + 10, 28 )
			
			DLabel.ApplySchemeSettings( self )
		end
		
		self.AddBtn.UpdateColours = function( self, skin )
			return self:SetTextStyleColor( skin.Colours.Tab.Active.Down )
		end
		
		self.Editor = vgui.Create( "lua_editor", self )
		self.Editor:Dock( FILL )
		self.Editor:DockMargin( 4, 0, 4, 4 )
		self.Editor.OnLoaded = function()
			self.AddBtn:SetVisible( true )
			self:LoadTabs()
		end
		
		self.Editor.OnSessionAdded = function( Editor, name, content )
			self:AddTab( FormatName( name ) )
		end
		
		self.Editor.OnSessionRemoved = function( Editor, name )
		    self:CloseTab( self:GetTabByName( name ) )
		end
		
		self.Editor.OnSessionChanged = function( Editor, name )
		    self:SwitchToName( name )
		end

		hook.Add( "ShutDown", self, function()
			if not IsValid( self ) or not self.Loaded then return end
			self:SaveTabsOrder()
			self:SaveActiveTab()
		end )
	end
	
	function PANEL:GetEditor()
		return self.Editor
	end
	
	function PANEL:OnRemove()
		if not self.Loaded then return end
		self:SaveTabsOrder()
		self:SaveActiveTab()
	end
	
	function PANEL:GetTabByName( name )
		for k, Tab in pairs( self.tabScroller.Panels ) do
			if Tab.Name == name then
				return Tab
			end
		end
		return false
	end
	
	function PANEL:SwitchToName( name )
		local Tab = self:GetTabByName( name )
		if Tab then Tab:DoClick() end
	end
	
	function PANEL:AddTab( name )
		if not self:GetEditor() then return end
		if self:GetTabByName( name ) then return end
		
		local Tab = vgui.CreateFromTable( lua_editor_TabBtn, self )
		Tab:Setup( name, self )
		
		self.tabScroller:AddPanel( Tab )
		self.tabScroller.OffsetX = self.tabScroller.pnlCanvas:GetWide() - self:GetWide() + Tab:GetWide()
		
		if self.Loaded then
			self:SaveTabsOrder()
		end
		
		return Tab
	end
	
	function PANEL:SetActiveTab( tab )
		if ( self.m_pActiveTab == tab ) then return end
		
		self.m_pActiveTab = tab
		self:InvalidateLayout()
		self:GetEditor():SetSession( tab.Name )
		
		if self.Loaded then
			self:SaveActiveTab()
		end
	end

	function PANEL:OnTabNameChanged( oldName, newName )
		if newName:len() < 1 or not self:GetEditor():GetHasLoaded() then return end
		local Editor = self:GetEditor()
		
		if oldName != newName then
			Editor:RemoveSession( oldName )
			Editor:SetSession( newName )
		end
		
		self:SaveTabsOrder()
		Editor.HTML:RequestFocus()
	end

	function PANEL:LoadTabs()
		local Tabs = util.JSONToTable( self:GetCookie( "TabsOrder" ) or "" ) or {}
		
		for k, name in pairs( Tabs ) do
			self:GetEditor():AddSession( name )
		end
		
		self:SwitchToName( self:GetCookie( "ActiveTab" ) or "" )
		self.Loaded = true
	end
	
	function PANEL:SaveTabsOrder()
		local tabs = {}
		
		for k, v in next, self.tabScroller.Panels do
			tabs[ k ] = v.Name
		end
		
		self:SetCookie( "TabsOrder", util.TableToJSON( tabs ) )
	end
	
	function PANEL:SaveActiveTab()
		if not self:GetActiveTab() then return end
		
		self:SetCookie( "ActiveTab", self:GetActiveTab().Name )
	end
	
	function PANEL:PerformLayout()
		local ActiveTab = self:GetActiveTab()
		
		if not ActiveTab or not IsValid( ActiveTab ) then
			if not self.tabScroller.Panels[1] then
				self.AddBtn:DoClick()
			end
			
			return self:SetActiveTab( self.tabScroller.Panels[1] )
		end
		
		for k, Tab in pairs( self.tabScroller.Panels ) do
			Tab:SetZPos( Tab == ActiveTab and 100 or 1 )
		end
		
		ActiveTab:ApplySchemeSettings()
	end
	
	function PANEL:CloseTab( tab )
	    if not tab then return end
	    table.RemoveByValue( self.tabScroller.Panels, tab )
		
		tab:Remove()
		self.tabScroller:InvalidateLayout( true )
		self:PerformLayout()
		self:SaveTabsOrder()
	end
end

derma.DefineControl( "lua_editor_TabControl", "", PANEL, "Panel" )
--gamemodes/darkrp/gamemode/modules/police/sh_interface.lua:
DarkRP.PLAYER.isWanted = DarkRP.stub{
    name = "isWanted",
    description = "Whether this player is wanted",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is wanted",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getWantedReason = DarkRP.stub{
    name = "getWantedReason",
    description = "Get the reason why someone is wanted",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "The reason",
            type = "string"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isArrested = DarkRP.stub{
    name = "isArrested",
    description = "Whether this player is arrested",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is arrested",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isCP = DarkRP.stub{
    name = "isCP",
    description = "Whether this player is part of the police force (mayor, cp, chief).",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is part of the police force.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isMayor = DarkRP.stub{
    name = "isMayor",
    description = "Whether this player is a mayor.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a mayor.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isChief = DarkRP.stub{
    name = "isChief",
    description = "Whether this player is a Chief.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a Chief.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}


DarkRP.hookStub{
    name = "canRequestWarrant",
    description = "Whether someone can request a search warrant.",
    parameters = {
        {
            name = "target",
            description = "The player to get the search warrant for",
            type = "Player"
        },
        {
            name = "actor",
            description = "The player requesting the warrant",
            type = "Player"
        },
        {
            name = "reason",
            description = "The reason for the search warrant",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canRequest",
            description = "A yes or no as to whether the search warrant can be requested",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when it can't",
            type = "string"
        }
    }
}

DarkRP.hookStub{
    name = "canWanted",
    description = "Whether someone can make a player wanted",
    parameters = {
        {
            name = "target",
            description = "The player to make wanted by the police",
            type = "Player"
        },
        {
            name = "actor",
            description = "The player requesting the wanted status",
            type = "Player"
        },
        {
            name = "reason",
            description = "The reason",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canRequest",
            description = "A yes or no as to whether the wanted can be requested",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when it can't",
            type = "string"
        }
    }
}

DarkRP.hookStub{
    name = "canUnwant",
    description = "Whether someone can remove the wanted status from a player",
    parameters = {
        {
            name = "target",
            description = "The player to make wanted by the police",
            type = "Player"
        },
        {
            name = "actor",
            description = "The player requesting the wanted status",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canUnwant",
            description = "A yes or no answer",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when the answer is no",
            type = "string"
        }
    }
}

--gamemodes/darkrp/gamemode/modules/language/sh_interface.lua:
DarkRP.addLanguage = DarkRP.stub{
    name = "addLanguage",
    description = "Create a language/translation.",
    parameters = {
        {
            name = "Language name",
            description = "The short name of the language (\"en\" is English). Make sure the language name fits a possible value for gmod_language!",
            type = "string",
            optional = false
        },
        {
            name = "Language contents",
            description = "A table that contains the translation sentences. Look at sh_english.lua for an example.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.addPhrase = DarkRP.stub{
    name = "addPhrase",
    description = "Add a phrase to the existing translation.",
    parameters = {
        {
            name = "Language name",
            description = "The short name of the language (\"en\" is English). Make sure the language name fits a possible value for gmod_language!",
            type = "string",
            optional = false
        },
        {
            name = "key",
            description = "The name of the translated phrase.",
            type = "string",
            optional = false
        },
        {
            name = "translation",
            description = "The translation of the phrase.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getPhrase = DarkRP.stub{
    name = "getPhrase",
    description = "Get a phrase from the selected language.",
    parameters = {
        {
            name = "key",
            description = "The name of the translated phrase.",
            type = "string",
            optional = false
        },
        {
            name = "Phrase parameters",
            description = "Some phrases need extra information, like in \"PLAYERNAME just won the lottery!\". Not filling in the phrase parameters will cause errors.",
            type = "vararg",
            optional = false
        }
    },
    returns = {
        {
            name = "phrase",
            description = "The formatted phrase.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.getMissingPhrases = DarkRP.stub{
    name = "getMissingPhrases",
    description = "Get all the phrases a language is missing.",
    parameters = {
        {
            name = "languageCode",
            description = "The language code of the language. For English this is \"en\".",
            type = "string",
            optional = true
        }
    },
    returns = {
        {
            name = "missingPhrases",
            description = "All the missing phrases formatted in such way that you can copy and paste it in your language file.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.addChatCommandsLanguage = DarkRP.stub{
    name = "addChatCommandsLanguage",
    description = "Add a translation table for chat command descriptions. See darkrpmod/lua/darkrp_language/chatcommands.lua for an example.",
    parameters = {
        {
            name = "languageCode",
            description = "The language code of the language. For English this is \"en\".",
            type = "string",
            optional = false
        },
        {
            name = "translations",
            description = "Key-value table with chat command strings as keys and their translation as value.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getChatCommandDescription = DarkRP.stub{
    name = "getChatCommandDescription",
    description = "Get the translated description of a chat command.",
    parameters = {
        {
            name = "command",
            description = "The chat command string.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "description",
            description = "The translated chat command description.",
            type = "string"
        }
    },
    metatable = DarkRP
}

--gamemodes/darkrp/gamemode/modules/base/sh_interface.lua:
DarkRP.registerDarkRPVar = DarkRP.stub{
    name = "registerDarkRPVar",
    description = "Register a DarkRPVar by name. You should definitely register DarkRPVars. Registering DarkRPVars will make networking much more efficient.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "writeFn",
            description = "The function that writes a value for this DarkRPVar. Examples: net.WriteString, function(val) net.WriteUInt(val, 8) end.",
            type = "function",
            optional = false
        },
        {
            name = "readFn",
            description = "The function that reads and returns a value for this DarkRPVar. Examples: net.ReadString, function() return net.ReadUInt(8) end.",
            type = "function",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVar = DarkRP.stub{
    name = "writeNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function writes the net data for a specific DarkRPVar.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVarRemoval = DarkRP.stub{
    name = "writeNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function sets a DarkRPVar to nil.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVar = DarkRP.stub{
    name = "readNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function reads the net data for a specific DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any"
        }
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVarRemoval = DarkRP.stub{
    name = "readNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function the removal of a DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayer = DarkRP.stub{
    name = "findPlayer",
    description = "Find a single player based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "The player that matches the description.",
            type = "Player"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayers = DarkRP.stub{
    name = "findPlayers",
    description = "Find a list of players based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "Table of players that match the description.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.nickSortedPlayers = DarkRP.stub{
    name = "nickSortedPlayers",
    description = "A table of players sorted by RP name.",
    parameters = {},
    returns = {
        {
            name = "players",
            description = "The list of players sorted by RP name.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.explodeArg = DarkRP.stub{
    name = "explodeArg",
    description = "String arguments exploded into a table. It accounts for substrings in quotes, which makes it more intelligent than string.Explode",
    parameters = {
        {
            name = "arg",
            description = "The full string of the argument",
            type = "string",
            optional = false
        },
    },
    returns = {
        {
            name = "args",
            description = "The table of arguments",
            type = "table"
        }
    },
    metatable = DarkRP
}


DarkRP.formatMoney = DarkRP.stub{
    name = "formatMoney",
    description = "Format a number as a money value. Includes currency symbol.",
    parameters = {
        {
            name = "amount",
            description = "The money to format, e.g. 100000.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "money",
            description = "The money as a nice string, e.g. \"$100,000\".",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.getJobByCommand = DarkRP.stub{
    name = "getJobByCommand",
    description = "Get the job table and number from the command of the job.",
    parameters = {
        {
            name = "command",
            description = "The command of the job, without preceding slash (e.g. 'medic' for medic)",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "tbl",
            description = "A table containing all information about the job.",
            type = "table"
        },
        {
            name = "jobindex",
            description = "The index of the job (for 'medic' it's the value of TEAM_MEDIC).",
            type = "number"
        }
    },
    metatable = DarkRP
}

DarkRP.simplerrRun = DarkRP.stub{
    name = "simplerrRun",
    description = "Run a function with the given parameters and send any runtime errors to admins.",
    parameters = {
        {
            name = "f",
            description = "The function to be called.",
            type = "function",
            optional = false
        },
        {
            name = "args",
            description = "The arguments to be given to f.",
            type = "vararg",
            optional = true
        },
    },
    returns = {
        {
            name = "retVals",
            description = "The return values of f.",
            type = "vararg"
        }
    },
    metatable = DarkRP
}

DarkRP.error = DarkRP.stub{
    name = "error",
    description = "Throw a simplerr formatted error. Also halts the stack, which means that statements after calling this function will not execute.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false. This return value will never be reached.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message. This return value will never be reached.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.errorNoHalt = DarkRP.stub{
    name = "errorNoHalt",
    description = "Throw a simplerr formatted error. Unlike DarkRP.error, this does not halt the stack. This means that statements after calling this function will be executed like normal.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message.",
            type = "string"
        }
    },
    metatable = DarkRP
}

-- This function is one of the few that's already defined before the stub is created
DarkRP.stub{
    name = "SteamName",
    description = "Retrieve a player's real (steam) name.",
    parameters = {

    },
    returns = {
        {
            name = "name",
            description = "The player's steam name.",
            type = "string"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getJobTable = DarkRP.stub{
    name = "getJobTable",
    description = "Get the job table of a player.",
    parameters = {
    },
    returns = {
        {
            name = "job",
            description = "Table with the job information.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getDarkRPVar = DarkRP.stub{
    name = "getDarkRPVar",
    description = "Get the value of a DarkRPVar, which is shared between server and client.",
    parameters = {
        {
            name = "var",
            description = "The name of the variable.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "value",
            description = "The value of the DarkRP var.",
            type = "any"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgenda = DarkRP.stub{
    name = "getAgenda",
    description = "Get the agenda a player manages.",
    deprecated = "Use ply:getAgendaTable() instead.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgendaTable = DarkRP.stub{
    name = "getAgendaTable",
    description = "Get the agenda a player can see. Note: when a player is not the manager of an agenda, it returns the agenda of the manager.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.hasDarkRPPrivilege = DarkRP.stub{
    name = "hasDarkRPPrivilege",
    description = "Whether the player has a certain privilege.",
    parameters = {
        {
            name = "priv",
            description = "The name of the privilege.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player has the privilege.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getEyeSightHitEntity = DarkRP.stub{
    name = "getEyeSightHitEntity",
    description = "Get the entity that is closest to a player's line of sight and its distance.",
    parameters = {
        {
            name = "searchDistance",
            description = "How far to look. You usually don't want this function to return an entity millions of units away. The default is 100 units.",
            type = "number",
            optional = true
        },
        {
            name = "hitDistance",
            description = "The maximum distance between the player's line of sight and the object. Basically how far the player can be 'looking away' from the object. The default is 15 units.",
            type = "number",
            optional = true
        },
        {
            name = "filter",
            description = "The filter for which entities to look for. By default it only looks for players.",
            type = "function",
            optional = true
        }
    },
    returns = {
        {
            name = "closestEnt",
            description = "The entity that is closest to the player's line of sight. Returns nil when not found.",
            type = "Entity"
        },
        {
            name = "distance",
            description = "The (minimum) distance between the player's line of sight and the object.",
            type = "number"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.VECTOR.isInSight = DarkRP.stub{
    name = "isInSight",
    description = "Decides whether the vector could be seen by the player if they were to look at it.",
    parameters = {
        {
            name = "filter",
            description = "Trace filter that decides what the player can see through.",
            type = "table",
            optional = false
        },
        {
            name = "ply",
            description = "The player for whom the vector may or may not be visible.",
            type = "Player",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player can see the position.",
            type = "boolean"
        },
        {
            name = "HitPos",
            description = "The position of the thing that blocks the player's sight.",
            type = "Vector"
        }
    },
    metatable = DarkRP.VECTOR
}

DarkRP.hookStub{
    name = "UpdatePlayerSpeed",
    description = "Change a player's walking and running speed.",
    deprecated = "Use GMod's SetupMove and Move hooks instead.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the speed changes.",
            type = "Player"
        }
    },
    returns = {
    }
}

--[[---------------------------------------------------------------------------
Creating custom items
---------------------------------------------------------------------------]]
DarkRP.createJob = DarkRP.stub{
    name = "createJob",
    description = "Create a job for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the job.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the job.",
            type = "table",
            optional = false
        }
    },
    returns = {
        {
            name = "team",
            description = "The team number of the job you've created.",
            type = "number"
        }
    },
    metatable = DarkRP
}
AddExtraTeam = DarkRP.createJob

DarkRP.removeJob = DarkRP.stub{
    name = "removeJob",
    description = "Remove a job from DarkRP.",
    parameters = {
        {
            name = "i",
            description = "The TEAM_ number of the job. Also the index of the job in RPExtraTeams.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeShipment = DarkRP.stub{
    name = "removeShipment",
    description = "Remove a shipment from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeVehicle = DarkRP.stub{
    name = "removeVehicle",
    description = "Remove a vehicle from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntity = DarkRP.stub{
    name = "removeEntity",
    description = "Remove an entity from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeGroupChat = DarkRP.stub{
    name = "removeGroupChat",
    description = "Remove a groupchat from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAmmoType = DarkRP.stub{
    name = "removeAmmoType",
    description = "Remove an ammotype from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntityGroup = DarkRP.stub{
    name = "removeEntityGroup",
    description = "Remove an entitygroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAgenda = DarkRP.stub{
    name = "removeAgenda",
    description = "Remove a agenda from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeDemoteGroup = DarkRP.stub{
    name = "removeDemoteGroup",
    description = "Remove an demotegroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createShipment = DarkRP.stub{
    name = "createShipment",
    description = "Create a shipment for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the shipment.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the shipment.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomShipment = DarkRP.createShipment

DarkRP.createVehicle = DarkRP.stub{
    name = "createVehicle",
    description = "Create a vehicle for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the vehicle.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the vehicle.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createVehicle

DarkRP.createEntity = DarkRP.stub{
    name = "createEntity",
    description = "Create a entity for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the entity.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the entity.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createEntity

DarkRP.createAgenda = DarkRP.stub{
    name = "createAgenda",
    description = "Create an agenda for groups of jobs to communicate.",
    parameters = {
        {
            name = "title",
            description = "The name of the agenda.",
            type = "string",
            optional = false
        },
        {
            name = "manager",
            description = "The team numer of the manager of the agenda (the one who can set the agenda).",
            type = "number",
            optional = false
        },
        {
            name = "listeners",
            description = "The jobs that can see this agenda.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddAgenda = DarkRP.createAgenda

DarkRP.getAgendas = DarkRP.stub{
    name = "getAgendas",
    description = "Get all agendas. Note: teams that share an agenda use the exact same agenda table. E.g. when you change the agenda of the CP, the agenda of the Chief will automatically be updated as well. Make sure this property is maintained when modifying the agenda table. Not maintaining that property will lead to players not seeing the right agenda text.",
    parameters = {

    },
    returns = {
        {
            name = "agendas",
            description = "Table in which the keys are team numbers and the values agendas.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createGroupChat = DarkRP.stub{
    name = "createGroupChat",
    description = "Create a group chat.",
    parameters = {
        {
            name = "functionOrJob",
            description = "A function that returns whether the person can see the group chat, or a team number.",
            type = "any",
            optional = false
        },
        {
            name = "teamNr",
            description = "VarArg team number.",
            type = "number",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}
GM.AddGroupChat = DarkRP.createGroupChat

DarkRP.createAmmoType = DarkRP.stub{
    name = "createAmmoType",
    description = "Create an ammo type.",
    parameters = {
        {
            name = "name",
            description = "The name of the ammo.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the ammo.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createDemoteGroup = DarkRP.stub{
    name = "createDemoteGroup",
    description = "Create a demote group. When you get banned (demoted) from one of the jobs in this group, you will be banned from every job in this group.",
    parameters = {
        {
            name = "name",
            description = "The name of the demote group.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table consisting of a list of job.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroup = DarkRP.stub{
    name = "getDemoteGroup",
    description = "Get the demote group of a team. Every team in the same group will return the same object.",
    parameters = {
        {
            name = "teamNr",
            description = "Table consisting of a list of job.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "set",
            description = "The demote group identifier.",
            type = "Disjoint-Set"
        }
    },
    metatable = DarkRP
}

DarkRP.getGroupChats = DarkRP.stub{
    name = "getGroupChats",
    description = "Get all group chats.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table with functions that decide who can hear who.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroups = DarkRP.stub{
    name = "getDemoteGroups",
    description = "Get all demote groups Every team in the same group will return the same object.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table in which the keys are team numbers and the values Disjoint-Set.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createCategory = DarkRP.stub{
    name = "createCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "tbl",
            description = "Table describing the category.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.addToCategory = DarkRP.stub{
    name = "addToCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        },
        {
            name = "cat",
            description = "The name of the category. Note that the category must exist. Defaults to 'Other'.",
            type = "string",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeFromCategory = DarkRP.stub{
    name = "removeFromCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getCategories = DarkRP.stub{
    name = "getCategories",
    description = "Get all categories for all F4 menu tabs.",
    parameters = {
    },
    returns = {
        {
            name = "tbl",
            description = "all categories.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "DarkRPVarChanged",
    description = "Called when a DarkRPVar was changed.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the DarkRPVar changed.",
            type = "Player"
        },
        {
            name = "varname",
            description = "The name of the variable that has changed.",
            type = "string"
        },
        {
            name = "oldValue",
            description = "The old value of the DarkRPVar.",
            type = "any"
        },
        {
            name = "newvalue",
            description = "The new value of the DarkRPVar.",
            type = "any"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "canBuyPistol",
    description = "Whether a player can buy a pistol.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyShipment",
    description = "Whether a player can buy a shipment.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyVehicle",
    description = "Whether a player can buy a vehicle.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "vehicleTable",
            description = "The table, as defined in the vehicles file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyAmmo",
    description = "Whether a player can buy ammo.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "ammoTable",
            description = "The table, as defined in the a ammo file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyCustomEntity",
    description = "Whether a player can a certain custom entity.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "entTable",
            description = "The table, as defined by the user.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "onJobRemoved",
    description = "Called when a job was removed.",
    parameters = {
        {
            name = "num",
            description = "The TEAM_ number of the job.",
            type = "number"
        },
        {
            name = "jobbtable",
            description = "The table containing all the job info.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onShipmentRemoved",
    description = "Called when a shipment was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onVehicleRemoved",
    description = "Called when a vehicle was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityRemoved",
    description = "Called when a buyable entity was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onGroupChatRemoved",
    description = "Called when a groupchat was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAmmoTypeRemoved",
    description = "Called when a ammotype was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityGroupRemoved",
    description = "Called when an entity group was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAgendaRemoved",
    description = "Called when an agenda was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onDemoteGroupRemoved",
    description = "Called when a job was demotegroup.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "loadCustomDarkRPItems",
    description = "Runs right after the scripts from the DarkRPMod are run. You can add custom jobs, entities, shipments and whatever in this hook.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPStartedLoading",
    description = "Runs at the very start of loading DarkRP. Not even sandbox has loaded here yet.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPFinishedLoading",
    description = "Runs right after DarkRP itself has loaded. All DarkRPMod stuff (except for disabled_defaults) is loaded during this hook. NOTE! NO CUSTOM STUFF WILL BE AVAILABLE DURING THIS HOOK. USE `loadCustomDarkRPItems` INSTEAD IF YOU WANT THAT!",
    parameters = {
    },
    returns = {
    }
}

--gamemodes/darkrp/gamemode/modules/sandbox/sh_init.lua:
cleanup.Register( "props" )
cleanup.Register( "ragdolls" )
cleanup.Register( "effects" )
cleanup.Register( "npcs" )
cleanup.Register( "constraints" )
cleanup.Register( "ropeconstraints" )
cleanup.Register( "sents" )
cleanup.Register( "vehicles" )

function GM:GravGunPunt( ply, ent )

	if ( ent:IsValid() && ent.GravGunPunt ) then
		return ent:GravGunPunt( ply )
	end

	return true

end

function GM:GravGunPickupAllowed( ply, ent )

	if ( ent:IsValid() && ent.GravGunPickupAllowed ) then
		return ent:GravGunPickupAllowed( ply )
	end

	return true

end
--gamemodes/darkrp/gamemode/modules/sandbox/cl_spawnmenu.lua:
include( "spawnmenu/spawnmenu.lua" )

--[[---------------------------------------------------------
	If false is returned then the spawn menu is never created.
	This saves load times if your mod doesn't actually use the
	spawn menu for any reason.
-----------------------------------------------------------]]
function GM:SpawnMenuEnabled()
	return true
end

--[[---------------------------------------------------------
	Called when spawnmenu is trying to be opened.
	Return false to dissallow it.
-----------------------------------------------------------]]
function GM:SpawnMenuOpen()
	return true
end

function GM:SpawnMenuOpened()
	--[[
	self:SuppressHint( "OpeningMenu" )
	self:AddHint( "OpeningContext", 20 )
	self:AddHint( "EditingSpawnlists", 5 )
	]]
end

function GM:SpawnMenuClosed()
end

function GM:SpawnMenuCreated(spawnmenu)
end

--[[---------------------------------------------------------
	If false is returned then the context menu is never created.
	This saves load times if your mod doesn't actually use the
	context menu for any reason.
-----------------------------------------------------------]]
function GM:ContextMenuEnabled()
	return true
end

--[[---------------------------------------------------------
	Called when context menu is trying to be opened.
	Return false to dissallow it.
-----------------------------------------------------------]]
function GM:ContextMenuOpen()
	return true
end

function GM:ContextMenuOpened()
	--[[
	self:SuppressHint( "OpeningContext" )
	self:AddHint( "ContextClick", 20 )
	]]
end

function GM:ContextMenuClosed()
end

function GM:ContextMenuCreated()
end

--[[---------------------------------------------------------
	Backwards compatibility. Do Not Use!!!
-----------------------------------------------------------]]
function GM:GetSpawnmenuTools( name )
	return spawnmenu.GetToolMenu( name )
end

--[[---------------------------------------------------------
	Backwards compatibility. Do Not Use!!!
-----------------------------------------------------------]]
function GM:AddSTOOL( category, itemname, text, command, controls, cpanelfunction )
	self:AddToolmenuOption( "Main", category, itemname, text, command, controls, cpanelfunction )
end

function GM:PreReloadToolsMenu()
end

--[[---------------------------------------------------------
	Don't hook or override this function.
	Hook AddToolMenuTabs instead!
-----------------------------------------------------------]]
function GM:AddGamemodeToolMenuTabs()

	-- This is named like this to force it to be the first tab
	spawnmenu.AddToolTab( "Main",		"#spawnmenu.tools_tab", "icon16/wrench.png" )
	spawnmenu.AddToolTab( "Utilities",	"#spawnmenu.utilities_tab", "icon16/page_white_wrench.png" )

end

--[[---------------------------------------------------------
	Add your custom tabs here.
-----------------------------------------------------------]]
function GM:AddToolMenuTabs()

	-- Hook me!

end

--[[---------------------------------------------------------
	Add categories to your tabs
-----------------------------------------------------------]]
function GM:AddGamemodeToolMenuCategories()

	--spawnmenu.AddToolCategory( "Main", "Constraints",	"#spawnmenu.tools.constraints" )
	--spawnmenu.AddToolCategory( "Main", "Construction",	"#spawnmenu.tools.construction" )
	--spawnmenu.AddToolCategory( "Main", "Poser",			"#spawnmenu.tools.posing" )
	--spawnmenu.AddToolCategory( "Main", "Render",		"#spawnmenu.tools.render" )

end

--[[---------------------------------------------------------
	Add categories to your tabs
-----------------------------------------------------------]]
function GM:AddToolMenuCategories()

	-- Hook this function to add custom stuff

end

function GM:PopulateToolMenu()
end

function GM:PostReloadToolsMenu()
end

--[[---------------------------------------------------------
	Add categories to your tabs
-----------------------------------------------------------]]
function GM:PopulatePropMenu()

	-- This function makes the engine load the spawn menu text files.
	-- We call it here so that any gamemodes not using the default
	-- spawn menu can totally not call it.
	spawnmenu.PopulateFromEngineTextFiles()

end
--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/toolpanel.lua:

include( "controlpanel.lua" )

local PANEL = {}

AccessorFunc( PANEL, "m_TabID", "TabID" )

function PANEL:Init()

	self.HorizontalDivider = vgui.Create( "DHorizontalDivider", self )
	self.HorizontalDivider:Dock( FILL )
	self.HorizontalDivider:SetLeftWidth( 130 )
	self.HorizontalDivider:SetLeftMin( 130 )
	self.HorizontalDivider:SetRightMin( 200 )
	if ( ScrW() >= 1024 ) then self.HorizontalDivider:SetRightMin( 256 ) end
	self.HorizontalDivider:SetDividerWidth( 6 )
	self.HorizontalDivider:SetCookieName( "SpawnMenuToolMenuDiv" )

	local leftContainer = vgui.Create( "Panel", self.HorizontalDivider )

	self.SearchBar = vgui.Create( "DTextEntry", leftContainer )
	self.SearchBar:SetWidth( 130 )
	self.SearchBar:SetPlaceholderText( "#spawnmenu.quick_filter" )
	self.SearchBar:DockMargin( 0, 0, 0, 5 )
	self.SearchBar:Dock( TOP )
	self.SearchBar:SetUpdateOnType( true )
	self.SearchBar.OnValueChange = function( s, text )
		local text = text:Trim():lower()

		for id, category in pairs( self.List.pnlCanvas:GetChildren() ) do
			local count = 0
			local category_matched = false

			if ( string.find( category.Header:GetText():lower(), text, nil, true ) ) then
				category_matched = true
			end

			for id, item in pairs( category:GetChildren() ) do
				if ( item == category.Header ) then continue end

				local str = item.Text
				if ( str:StartWith( "#" ) ) then str = str:sub( 2 ) end
				str = language.GetPhrase( str )

				if ( !category_matched && !string.find( str:lower(), text, nil, true ) ) then
					item:SetVisible( false )
				else
					item:SetVisible( true )
					count = count + 1
				end
				item:InvalidateLayout()
			end

			if ( count < 1 && !category_matched ) then
				category:SetVisible( false )
			else
				category:SetVisible( true )

				 -- Make sure the category is expanded, but restore the state when we quit searching
				if ( text == "" ) then
					if ( category._preSearchState != nil ) then
						category:SetExpanded( category._preSearchState )
						category._preSearchState = nil
					end
				else
					if ( category._preSearchState == nil ) then category._preSearchState = category:GetExpanded() end
					category:SetExpanded( true )
				end
			end
			category:InvalidateLayout()
		end
		self.List.pnlCanvas:InvalidateLayout()
		self.List:InvalidateLayout()
	end

	self.List = vgui.Create( "DCategoryList", leftContainer )
	self.List:SetWidth( 130 )
	self.List:Dock( FILL )

	self.HorizontalDivider:SetLeft( leftContainer )

	self.Content = vgui.Create( "DCategoryList", self.HorizontalDivider )
	self.HorizontalDivider:SetRight( self.Content )

end

function PANEL:LoadToolsFromTable( inTable )

	local inTable = table.Copy( inTable )

	for k, v in pairs( inTable ) do

		if ( istable( v ) ) then

			-- Remove these from the table so we can
			-- send the rest of the table to the other
			-- function

			local Name = v.ItemName
			local Label = v.Text
			v.ItemName = nil
			v.Text = nil

			self:AddCategory( Name, Label, v )

		end

	end

end

function PANEL:AddCategory( name, lbl, tItems )

	local Category = self.List:Add( lbl )

	Category:SetCookieName( "ToolMenu." .. tostring( self:GetTabID() ) .. "." .. tostring( name ) )

	local tools = {}
	for k, v in pairs( tItems ) do
		local name = v.Text or v.ItemName or v.Controls or v.Command or tostring( k )
		tools[ language.GetPhrase( name ) ] = v
	end

	local currentMode = GetConVarString( "gmod_toolmode" )
	for k, v in SortedPairs( tools ) do

		local item = Category:Add( v.Text or k )

		item.DoClick = function( button )

			spawnmenu.ActivateTool( button.Name )

		end

		item.ControlPanelBuildFunction	= v.CPanelFunction
		item.Command					= v.Command
		item.Name						= v.ItemName
		item.Controls					= v.Controls
		item.Text						= v.Text

		-- Mark this button as the one to select on first spawnmenu open
		if ( currentMode == v.ItemName ) then
			timer.Simple( 0, function() -- Have to wait a frame to get the g_SpawnMenu global, ew
				g_SpawnMenu.StartupTool = item
			end )
		end

	end

	self:InvalidateLayout()

end

-- Internal, makes the given tool highlighted in its DCategoryList
function PANEL:SetActiveToolText( str )

	for id, category in pairs( self.List.pnlCanvas:GetChildren() ) do

		for id, item in pairs( category:GetChildren() ) do
			if ( item == category.Header ) then continue end

			if ( item.Name == str ) then
				self.List:UnselectAll()
				item:SetSelected( true )
				return
			end
		end

	end

end

function PANEL:SetActive( cp )

	local kids = self.Content:GetCanvas():GetChildren()
	for k, v in pairs( kids ) do
		v:SetVisible( false )
	end

	self.Content:AddItem( cp )
	cp:SetVisible( true )
	cp:Dock( TOP )

end

vgui.Register( "ToolPanel", PANEL, "Panel" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controls/manifest.lua:

include( "control_presets.lua" )
include( "ropematerial.lua" )

include( "ctrlnumpad.lua" )
include( "ctrlcolor.lua" )
include( "ctrllistbox.lua" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controls/ctrlnumpad.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_ConVar1", "ConVar1" )
AccessorFunc( PANEL, "m_ConVar2", "ConVar2" )

--[[---------------------------------------------------------
	Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self.NumPad1 = vgui.Create( "DBinder", self )
	self.Label1 = vgui.Create( "DLabel", self )
	self.Label1:SetDark( true )

	self.NumPad2 = vgui.Create( "DBinder", self )
	self.Label2 = vgui.Create( "DLabel", self )
	self.Label2:SetDark( true )

	self:SetPaintBackground( false )

	self:SetHeight( 200 )

end

--[[---------------------------------------------------------
	Name: SetLabel1
-----------------------------------------------------------]]
function PANEL:SetLabel1( txt )
	if ( !txt ) then return end
	self.Label1:SetText( txt )
end

--[[---------------------------------------------------------
	Name: SetLabel2
-----------------------------------------------------------]]
function PANEL:SetLabel2( txt )
	if ( !txt ) then return end
	self.Label2:SetText( txt )
end

--[[---------------------------------------------------------
	Name: SetConVar1
-----------------------------------------------------------]]
function PANEL:SetConVar1( cvar )
	self.NumPad1:SetConVar( cvar )
	self.m_ConVar1 = cvar
end

--[[---------------------------------------------------------
	Name: SetConVar2
-----------------------------------------------------------]]
function PANEL:SetConVar2( cvar )
	self.NumPad2:SetConVar( cvar )
	self.m_ConVar2 = cvar
end

--[[---------------------------------------------------------
	Name: Init
-----------------------------------------------------------]]
function PANEL:PerformLayout()

	self:SetTall( 70 )

	self.NumPad1:InvalidateLayout( true )
	self.NumPad1:SetSize( 100, 50 )

	if ( self.m_ConVar2 ) then
		self.NumPad2:InvalidateLayout( true )
		self.NumPad2:SetSize( 100, 50 )
	end

	if ( !self.m_ConVar2 ) then

		self.Label1:SizeToContents()

		self.NumPad2:SetVisible( false )
		self.Label2:SetVisible( false )

		self.NumPad1:CenterHorizontal( 0.5 )
		self.NumPad1:AlignTop( 20 )

		self.Label1:CenterHorizontal()
		self.Label1:AlignTop( 0 )

	else

		self.Label1:SizeToContents()
		self.Label2:SizeToContents()

		self.NumPad2:SetVisible( true )
		self.Label2:SetVisible( true )

		self.NumPad1:CenterHorizontal( 0.25 )
		self.Label1:CenterHorizontal( 0.25 )
		self.NumPad1:AlignTop( 20 )

		self.NumPad2:CenterHorizontal( 0.75 )
		self.Label2:CenterHorizontal( 0.75 )
		self.NumPad2:AlignTop( 20 )
		self.Label2:AlignTop( 0 )

	end

end

vgui.Register( "CtrlNumPad", PANEL, "DPanel" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controls/ctrllistbox.lua:

local PANEL = {}

--AccessorFunc( PANEL, "m_ConVarR", "ConVarR" )

--[[---------------------------------------------------------
	Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self.ConVars = {}
	self.Options = {}

end

--[[---------------------------------------------------------
	Name: AddOption
-----------------------------------------------------------]]
function PANEL:AddOption( strName, tabConVars )

	self:AddChoice( strName, tabConVars )

	for k, v in pairs( tabConVars ) do
		self.ConVars[ k ] = 1
	end

end

--[[---------------------------------------------------------
	Name: OnSelect
-----------------------------------------------------------]]
function PANEL:OnSelect( index, value, data )

	for k, v in pairs( data ) do

		RunConsoleCommand( k, tostring( v ) )

	end

end

--[[---------------------------------------------------------
	Name: Think
-----------------------------------------------------------]]
function PANEL:Think( CheckConvarChanges )

	self:CheckConVarChanges()

end

--[[---------------------------------------------------------
	Name: ConVarsChanged
-----------------------------------------------------------]]
function PANEL:ConVarsChanged()

	for k, v in pairs( self.ConVars ) do

		if ( self[ k ] == nil ) then return true end
		if ( self[ k ] != GetConVarString( k ) ) then return true end

	end

	return false

end

--[[---------------------------------------------------------
	Name: CheckForMatch
-----------------------------------------------------------]]
function PANEL:CheckForMatch( cvars )

	if ( table.IsEmpty( cvars ) ) then return false end

	for k, v in pairs( cvars ) do

		if ( tostring(v) != GetConVarString( k ) ) then
			return false
		end

	end

	return true

end

--[[---------------------------------------------------------
	Name: CheckConVarChanges
-----------------------------------------------------------]]
function PANEL:CheckConVarChanges()

	if (!self:ConVarsChanged()) then return end

	for k, v in pairs( self.ConVars ) do
		self[ k ] = GetConVarString( k )
	end

	for k, v in pairs( self.Data ) do

		if ( self:CheckForMatch( v ) ) then
			self:SetText( self:GetOptionText(k) )
			return
		end

	end

end

vgui.Register( "CtrlListBox", PANEL, "DComboBox" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/content.lua:

include( "contenticon.lua" )
include( "postprocessicon.lua" )

include( "contentcontainer.lua" )
include( "contentsidebar.lua" )

include( "contenttypes/custom.lua" )
include( "contenttypes/npcs.lua" )
include( "contenttypes/weapons.lua" )
include( "contenttypes/entities.lua" )
include( "contenttypes/postprocess.lua" )
include( "contenttypes/vehicles.lua" )
include( "contenttypes/saves.lua" )
include( "contenttypes/dupes.lua" )

include( "contenttypes/gameprops.lua" )
include( "contenttypes/addonprops.lua" )

local PANEL = {}

AccessorFunc( PANEL, "m_pSelectedPanel", "SelectedPanel" )

function PANEL:Init()

	self:SetPaintBackground( false )

	self.CategoryTable = {}

	self.HorizontalDivider = vgui.Create( "DHorizontalDivider", self )
	self.HorizontalDivider:Dock( FILL )
	self.HorizontalDivider:SetLeftWidth( 192 )
	self.HorizontalDivider:SetLeftMin( 100 )
	self.HorizontalDivider:SetRightMin( 100 )
	if ( ScrW() >= 1024 ) then self.HorizontalDivider:SetLeftMin( 192 ) self.HorizontalDivider:SetRightMin( 400 ) end
	self.HorizontalDivider:SetDividerWidth( 6 )
	self.HorizontalDivider:SetCookieName( "SpawnMenuCreationMenuDiv" )

	self.ContentNavBar = vgui.Create( "ContentSidebar", self.HorizontalDivider )
	self.HorizontalDivider:SetLeft( self.ContentNavBar )

end

function PANEL:EnableModify()
	self.ContentNavBar:EnableModify()
end

function PANEL:EnableSearch( ... )
	self.ContentNavBar:EnableSearch( ... )
end

function PANEL:CallPopulateHook( HookName )

	hook.Call( HookName, GM, self, self.ContentNavBar.Tree, self.OldSpawnlists )

end

function PANEL:SwitchPanel( panel )

	if ( IsValid( self.SelectedPanel ) ) then
		self.SelectedPanel:SetVisible( false )
		self.SelectedPanel = nil
	end

	self.SelectedPanel = panel

	if ( !IsValid( panel ) ) then return end

	self.HorizontalDivider:SetRight( self.SelectedPanel )
	self.HorizontalDivider:InvalidateLayout( true )

	self.SelectedPanel:SetVisible( true )
	self:InvalidateParent()

end

function PANEL:OnSizeChanged()
	self.HorizontalDivider:LoadCookies()
end

vgui.Register( "SpawnmenuContentPanel", PANEL, "DPanel" )

local function CreateContentPanel()

	local ctrl = vgui.Create( "SpawnmenuContentPanel" )

	ctrl.OldSpawnlists = ctrl.ContentNavBar.Tree:AddNode( "#spawnmenu.category.browse", "icon16/cog.png" )

	ctrl:EnableModify()
	hook.Call( "PopulatePropMenu", GM )
	ctrl:CallPopulateHook( "PopulateContent" )

	ctrl.OldSpawnlists:MoveToFront()
	ctrl.OldSpawnlists:SetExpanded( true )

	return ctrl

end

spawnmenu.AddCreationTab( "#spawnmenu.content_tab", CreateContentPanel, "icon16/application_view_tile.png", -10 )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contentcontainer.lua:

local PANEL = {}

DEFINE_BASECLASS( "DScrollPanel" )

AccessorFunc( PANEL, "m_pControllerPanel",			"ControllerPanel" )
AccessorFunc( PANEL, "m_strCategoryName",			"CategoryName" )
AccessorFunc( PANEL, "m_bTriggerSpawnlistChange",	"TriggerSpawnlistChange" )

--[[---------------------------------------------------------
	Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self:SetPaintBackground( false )

	self.IconList = vgui.Create( "DTileLayout", self:GetCanvas() )
	self.IconList:SetBaseSize( 64 )
	self.IconList:MakeDroppable( "SandboxContentPanel", true )
	self.IconList:SetSelectionCanvas( true )
	--self.IconList:SetUseLiveDrag( true )
	self.IconList:Dock( TOP )
	self.IconList.OnModified = function() self:OnModified() end
	self.IconList.OnMousePressed = function( s, btn )

		-- A bit of a hack
		s:EndBoxSelection()
		if ( btn != MOUSE_RIGHT ) then DPanel.OnMousePressed( s, btn ) end

	end
	self.IconList.OnMouseReleased = function( s, btn )

		DPanel.OnMouseReleased( s, btn )

		if ( btn != MOUSE_RIGHT || s:GetReadOnly() ) then return end

		local menu = DermaMenu()
		menu:AddOption( "#spawnmenu.newlabel", function()

			local label = vgui.Create( "ContentHeader" )
			self:Add( label )

			-- Move the label to player's cursor, but make sure it's per line, not per icon
			local x, y = self.IconList:ScreenToLocal( input.GetCursorPos() )
			label:MoveToAfter( self.IconList:GetClosestChild( self:GetCanvas():GetWide(), y ) )

			self:OnModified()

			-- Scroll to the newly added item
			--[[timer.Simple( 0, function()
				local x, y = label:GetPos()
				self.VBar:AnimateTo( y - self:GetTall() / 2 + label:GetTall() / 2, 0.5, 0, 0.5 )
			end )]]

		end ):SetIcon( "icon16/text_heading_1.png" )
		menu:Open()

	end

	self.IconList.ContentContainer = self

end

function PANEL:Add( pnl )

	self.IconList:Add( pnl )

	if ( pnl.InstallMenu ) then
		pnl:InstallMenu( self )
	end

	self:Layout()

end

function PANEL:Layout()

	self.IconList:Layout()
	self:InvalidateLayout()

end

function PANEL:PerformLayout( w, h )

	BaseClass.PerformLayout( self, w, h )
	self.IconList:SetMinHeight( self:GetTall() - 16 )

end

--[[---------------------------------------------------------
	Name: RebuildAll
-----------------------------------------------------------]]
function PANEL:RebuildAll( proppanel )

	local items = self.IconList:GetChildren()

	for k, v in pairs( items ) do

		v:RebuildSpawnIcon()

	end

end

--[[---------------------------------------------------------
	Name: GetCount
-----------------------------------------------------------]]
function PANEL:GetCount()

	local items = self.IconList:GetChildren()
	return #items

end

function PANEL:Clear()

	self.IconList:Clear( true )

end

function PANEL:SetTriggerSpawnlistChange( bTrigger )

	self.m_bTriggerSpawnlistChange = bTrigger
	self.IconList:SetReadOnly( !bTrigger )

end

function PANEL:OnModified()

	if ( !self:GetTriggerSpawnlistChange() ) then return end

	hook.Run( "SpawnlistContentChanged" )

end

function PANEL:ContentsToTable( contentpanel )

	local tab = {}

	local items = self.IconList:GetChildren()

	for k, v in pairs( items ) do

		v:ToTable( tab )

	end

	return tab

end

function PANEL:Copy()

	local copy = vgui.Create( "ContentContainer", self:GetParent() )
	copy:CopyBase( self )

	copy.IconList:CopyContents( self.IconList )

	return copy

end

vgui.Register( "ContentContainer", PANEL, "DScrollPanel" )

hook.Add( "SpawnlistOpenGenericMenu", "DragAndDropSelectionMenu", function( canvas )

	if ( canvas:GetReadOnly() ) then return end

	local selected = canvas:GetSelectedChildren()

	local menu = DermaMenu()
	menu:AddOption( language.GetPhrase( "spawnmenu.menu.deletex" ):format( #selected ), function()

		for k, v in pairs( selected ) do
			v:Remove()
		end

		hook.Run( "SpawnlistContentChanged" )

	end ):SetIcon( "icon16/bin_closed.png" )

	-- This is less than ideal
	local spawnicons = 0
	local icon = nil
	for id, pnl in pairs( selected ) do
		if ( pnl.InternalAddResizeMenu ) then
			spawnicons = spawnicons + 1
			icon = pnl
		end
	end

	if ( spawnicons > 0 ) then
		icon:InternalAddResizeMenu( menu, function( w, h )

			for id, pnl in pairs( selected ) do
				if ( !pnl.InternalAddResizeMenu ) then continue end
				pnl:SetSize( w, h )
				pnl:InvalidateLayout( true )
				pnl:GetParent():OnModified()
				pnl:GetParent():Layout()
				pnl:SetModel( pnl:GetModelName(), pnl:GetSkinID(), pnl:GetBodyGroup() )
			end

		end, language.GetPhrase( "spawnmenu.menu.resizex" ):format( spawnicons ) )

		menu:AddOption( language.GetPhrase( "spawnmenu.menu.rerenderx" ):format( spawnicons ), function()
			for id, pnl in pairs( selected ) do
				if ( !pnl.RebuildSpawnIcon ) then continue end
				pnl:RebuildSpawnIcon()
			end
		end ):SetIcon( "icon16/picture.png" )
	end

	menu:Open()

end )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contentheader.lua:

surface.CreateFont( "ContentHeader", {
	font	= "Helvetica",
	size	= 50,
	weight	= 1000
} )

local PANEL = {}

function PANEL:Init()

	self:SetFont( "ContentHeader" )
	self:SetBright( true )
	self:SetExpensiveShadow( 2, Color( 0, 0, 0, 130 ) )

	self:SetSize( 64, 64 )

	self.OwnLine = true
	self.m_bStretch = true

end

function PANEL:PerformLayout()

	self:SizeToContents()

end

function PANEL:SizeToContents()

	local w = self:GetContentSize()

	-- Don't let the text overflow the parent's width
	if ( IsValid( self:GetParent() ) ) then
		w = math.min( w, self:GetParent():GetWide() - 32 )
	end

	-- Add a bit more room so it looks nice as a textbox :)
	-- And make sure it has at least some width
	self:SetSize( math.max( w, 64 ) + 16, 64 )

end

function PANEL:ToTable( bigtable )

	local tab = {}

	tab.type = "header"
	tab.text = self:GetText()

	table.insert( bigtable, tab )

end

function PANEL:Copy()

	local copy = vgui.Create( "ContentHeader", self:GetParent() )
	copy:SetText( self:GetText() )
	copy:CopyBounds( self )

	return copy

end

function PANEL:PaintOver( w, h )

	self:DrawSelections()

end

function PANEL:OnLabelTextChanged( txt )

	hook.Run( "SpawnlistContentChanged" )
	return txt

end

function PANEL:IsEnabled()

	-- This is a hack!
	return !IsValid( self:GetParent() ) || !self:GetParent().GetReadOnly || !self:GetParent():GetReadOnly()

end

function PANEL:DoRightClick()

	local pCanvas = self:GetSelectionCanvas()
	if ( IsValid( pCanvas ) && pCanvas:NumSelectedChildren() > 0 && self:IsSelected() ) then
		return hook.Run( "SpawnlistOpenGenericMenu", pCanvas )
	end

	self:OpenMenu()

end

function PANEL:OpenMenu()

	-- Do not allow removal from read only panels
	if ( IsValid( self:GetParent() ) && self:GetParent().GetReadOnly && self:GetParent():GetReadOnly() ) then return end

	local menu = DermaMenu()
	menu:AddOption( "#spawnmenu.menu.delete", function() self:Remove() hook.Run( "SpawnlistContentChanged" ) end ):SetIcon( "icon16/bin_closed.png" )
	menu:Open()

end

vgui.Register( "ContentHeader", PANEL, "DLabelEditable" )

spawnmenu.AddContentType( "header", function( container, obj )

	if ( !obj.text || !isstring( obj.text ) ) then return end

	local label = vgui.Create( "ContentHeader", container )
	label:SetText( obj.text )

	container:Add( label )

end )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/gameprops.lua:

local function recurseAddFiles( folder, pathid, list )

	local addedLabel = false

	local files, folders = file.Find( folder .. "/*", pathid )
	for id, file in pairs( files or {} ) do
		if ( file:EndsWith( ".mdl" ) ) then
			if ( !addedLabel ) then
				table.insert( list, { type = "header", text = folder } )
				addedLabel = true
			end

			table.insert( list, { type = "model", model = folder .. "/" .. file } )
		end
	end

	for id, fold in pairs( folders or {} ) do
		recurseAddFiles( folder .. "/" .. fold, pathid, list )
	end

end

function GenerateSpawnlistFromPath( folder, path, name, icon, appid )

	local contents = {}
	recurseAddFiles( folder, path, contents )

	AddPropsOfParent( g_SpawnMenu.CustomizableSpawnlistNode.SMContentPanel, g_SpawnMenu.CustomizableSpawnlistNode, 0, { [ folder ] = {
		icon = icon or "icon16/page.png",
		id = math.random( 0, 999999 ), -- Eeehhhh
		name = name or folder,
		parentid = 0,
		needsapp = appid,
		contents = contents
	} } )

	-- We added a new spawnlist, show the save changes button
	hook.Run( "SpawnlistContentChanged" )

end

local function GamePropsRightClick( self )

	local menu = DermaMenu()
	menu:AddOption( "#spawnmenu.createautospawnlist", function()

		-- Find the "root" node for this game
		local parent = self
		local icon = parent:GetIcon()
		while ( !icon:StartWith( "games" ) ) do
			parent = parent:GetParentNode()
			if ( !IsValid( parent ) ) then break end
			icon = parent:GetIcon()
		end

		local name = parent:GetText()
		if ( self:GetFolder() != "models" ) then
			name = name .. " - " .. self:GetFolder():sub( 8 )
		end

		GenerateSpawnlistFromPath( self:GetFolder(), self:GetPathID(), name, icon, parent.GameAppID )

	end ):SetIcon( "icon16/page_add.png" )

	menu:Open()

end

local function InstallNodeRightclick( self, newNode )
	newNode.DoRightClick = GamePropsRightClick
	newNode.OnNodeAdded = InstallNodeRightclick
end

local function AddBrowseContent( ViewPanel, node, name, icon, path, pathid, pnlContent, appid )

	local models = node:AddFolder( name, path .. "models", pathid, false )
	models:SetIcon( icon )
	models.BrowseContentType = "models"
	models.BrowseExtension = "*.mdl"
	models.ContentType = "model"
	models.ViewPanel = ViewPanel
	models.GameAppID = appid

	-- If we click on a subnode of this tree, it gets reported upwards (to us)
	models.OnNodeSelected = function( slf, node )

		-- Already viewing this panel
		if ( ViewPanel && ViewPanel.CurrentNode && ViewPanel.CurrentNode == node ) then
			if ( pnlContent.SelectedPanel != ViewPanel ) then pnlContent:SwitchPanel( ViewPanel ) end
			return
		end

		-- Clear the viewpanel in preperation for displaying it
		ViewPanel:Clear( true )
		ViewPanel.CurrentNode = node

		-- Fill the viewpanel with models that are in this node's folder
		local node_path = node:GetFolder()
		local SearchString = node_path .. "/*.mdl"

		local mdls = file.Find( SearchString, node:GetPathID() )
		if ( mdls ) then
			for k, v in pairs( mdls ) do
				local cp = spawnmenu.GetContentType( "model" )
				if ( cp ) then
					cp( ViewPanel, { model = node_path .. "/" .. v } )
				end
			end
		else
			MsgN( "Warning! Not opening '" .. node_path .. "' because we cannot search in it!"  )
		end

		-- Switch to it
		pnlContent:SwitchPanel( ViewPanel )
		ViewPanel.CurrentNode = node

	end

	InstallNodeRightclick( node, models )

end

local function RefreshGames( MyNode )

	local games = engine.GetGames()
	table.insert( games, {
		title = "All",
		folder = "GAME",
		icon = "all",
		mounted = true
	} )
	table.insert( games, {
		title = "Garry's Mod",
		folder = "garrysmod",
		mounted = true
	} )

	-- Create a list of mounted games, allowing us to browse them
	for _, game in SortedPairsByMemberValue( games, "title" ) do

		if ( !game.mounted ) then continue end

		AddBrowseContent( MyNode.ViewPanel, MyNode, game.title, "games/16/" .. ( game.icon or game.folder ) .. ".png", "", game.folder, MyNode.pnlContent, game.depot )

	end

end

-- Called when setting up the sidebar on the spawnmenu - to populate the tree
local myGamesNode
hook.Add( "PopulateContent", "GameProps", function( pnlContent, tree, node )

	-- Create a node in the `other` category on the tree
	myGamesNode = node:AddNode( "#spawnmenu.category.games", "icon16/folder_database.png" )
	myGamesNode.pnlContent = pnlContent

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )
	ViewPanel.IconList:SetReadOnly( true )
	myGamesNode.ViewPanel = ViewPanel

	RefreshGames( myGamesNode )

end )


hook.Add( "GameContentChanged", "RefreshSpawnmenuGames", function()

	if ( !IsValid( myGamesNode ) ) then return end

	-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
	myGamesNode:Clear()
	myGamesNode.ViewPanel:Clear( true )

	RefreshGames( myGamesNode )

end )

--gamemodes/darkrp/gamemode/modules/police/license/shared.lua:
nw.Register('License')
    :Write(function(val)
        net.WriteEntity(val.cop or NULL)
        net.WriteString(val.term or '')
        net.WriteBool(val.fake or false)
        net.WriteUInt(val.time or 0, 32)
    end)
    :Read(function()
        local a = {
            cop = net.ReadEntity(),
            term = net.ReadString(),
            fake = net.ReadBool(),
            time = net.ReadUInt(32)
        }
        a.term = a.term == '' and 'Лицензия' or a.term

        return a
    end)
    :SetPlayer()

local meta = FindMetaTable('Player')

function meta:GetLicense()
    return self:GetNetVar('License')
end

function meta:HasLicense()
    return self:GetLicense() and true or false
end

DarkRP.declareChatCommand{
    command = 'givelicense',
    description = 'Выдать лицезнию',
    delay = 1.5,
}

DarkRP.declareChatCommand{
    command = 'revokelicense',
    description = 'Забрать лицезнию',
    delay = 1.5,
}

DarkRP.declareChatCommand{
    command = 'showlicense',
    description = 'Показать лицензию игрокам рядом',
    delay = 3,
}
--gamemodes/darkrp/gamemode/modules/language/sh_language.lua:
local rp_languages = {}
local selectedLanguage = GetConVar("gmod_language"):GetString() -- Switch language by setting gmod_language to another language

function DarkRP.addLanguage(name, tbl)
    local old = rp_languages[name] or {}
    rp_languages[name] = tbl

    -- Merge the language with the translations added by DarkRP.addPhrase
    for k,v in pairs(old) do
        if rp_languages[name][k] then continue end
        rp_languages[name][k] = v
    end
    LANGUAGE = rp_languages[name] -- backwards compatibility
end

function DarkRP.addPhrase(lang, name, phrase)
    rp_languages[lang] = rp_languages[lang]  or {}
    rp_languages[lang][name] = phrase
end

function DarkRP.getPhrase(name, ...)
    local langTable = rp_languages[selectedLanguage] or rp_languages.en

    return (langTable[name] or rp_languages.en[name]) and string.format(langTable[name] or rp_languages.en[name], ...) or nil
end

function DarkRP.getMissingPhrases(lang)
    lang = lang or selectedLanguage
    local res = {}
    local format = "%s = \"%s\","

    for k,v in pairs(rp_languages.en) do
        if rp_languages[lang][k] then continue end
        table.insert(res, string.format(format, k, v))
    end

    return #res == 0 and "No language strings missing!" or table.concat(res, "\n")
end

local function getMissingPhrases(ply, cmd, args)
    if not args[1] then print("Please run the command with a language code e.g. darkrp_getphrases \"en\"") return end
    local lang = rp_languages[args[1]]
    if not lang then print("This language does not exist! Make sure the casing is right.")
        print("Available languages:")
        for k,v in pairs(rp_languages) do print(k) end
        return
    end

    print(DarkRP.getMissingPhrases(args[1]))
end
if CLIENT then concommand.Add("darkrp_getphrases", getMissingPhrases) end

--[[---------------------------------------------------------------------------
Chat command translating
---------------------------------------------------------------------------]]
local chatCmdDescriptions = {}
function DarkRP.addChatCommandsLanguage(lang, tbl)
    chatCmdDescriptions[lang] = chatCmdDescriptions[lang] or {}

    table.Merge(chatCmdDescriptions[lang], tbl)
end

function DarkRP.getChatCommandDescription(name)
    local cmd = DarkRP.getChatCommand(name)
    return chatCmdDescriptions[selectedLanguage] and chatCmdDescriptions[selectedLanguage][name] or
        cmd and cmd.description or
        nil
end

local function getMissingCmdTranslations()
    local cmds = DarkRP.getSortedChatCommands()

    -- No commands have been translated
    if not chatCmdDescriptions[selectedLanguage] then return cmds end

    -- Remove translated commands and maintain keys
    local count = #cmds
    for i = 1, count do
        if chatCmdDescriptions[selectedLanguage][cmds[i].command] then
            cmds[i] = nil
        end
    end

    cmds = table.ClearKeys(cmds)

    return cmds
end

local function printMissingChatTranslations()
    local cmds = getMissingCmdTranslations()
    local text = {}

    local maxCmdLength = 0
    for k,v in pairs(cmds) do maxCmdLength = math.Max(maxCmdLength, string.len(v.command)) end

    for k,v in pairs(cmds) do
        text[k] = string.format([=[["%s"]%s=    "%s",]=], v.command, string.rep(' ', 4 + maxCmdLength - string.len(v.command)), v.description)
    end

    MsgC(Color(0, 255, 0), string.format("%s untranslated chat command descriptions!\n", #cmds))

    text = table.concat(text, "\n    ")
    SetClipboardText(text)

    MsgC(Color(0, 255, 0), "text copied to clipboard!\n")
end
if CLIENT then concommand.Add("darkrp_translateChatCommands", printMissingChatTranslations) end

--gamemodes/darkrp/gamemode/modules/fpp/pp/client/buddies.lua:
FPP = FPP or {}

--Make buddies if not there
sql.Query("CREATE TABLE IF NOT EXISTS FPP_Buddies('steamid' TEXT NOT NULL, 'name' TEXT NOT NULL, 'physgun' INTEGER NOT NULL, 'gravgun' INTEGER NOT NULL, 'toolgun' INTEGER NOT NULL, 'playeruse' INTEGER NOT NULL, 'entitydamage' INTEGER NOT NULL, PRIMARY KEY('steamid'));")

FPP.Buddies = {}
function FPP.LoadBuddies()
    local data = sql.Query("SELECT * FROM FPP_Buddies")
    if data then
        for _, v in pairs(data) do
            FPP.Buddies[v.steamid] = {name = v.name, physgun = v.physgun, gravgun = v.gravgun, toolgun = v.toolgun, playeruse = v.playeruse, entitydamage = v.entitydamage} --Put all the buddies in the table
            for _, ply in player.Iterator() do --If the buddies are in the server then add them serverside
                if ply:SteamID() == v.steamid then
                    -- update the name
                    sql.Query("UPDATE FPP_Buddies SET name = " .. sql.SQLStr(ply:Nick()) .. " WHERE steamid = " .. sql.SQLStr(v.steamid) .. ";")
                    FPP.Buddies[v.steamid].name = ply:Nick()
                    RunConsoleCommand("FPP_SetBuddy", ply:UserID(), v.physgun, v.gravgun, v.toolgun, v.playeruse, v.entitydamage)
                end
            end
        end
    end
end
hook.Add("InitPostEntity", "FPP_Start", FPP.LoadBuddies)

function FPP.SaveBuddy(SteamID, Name, Type, value)
    if Type == "remove" then
        FPP.Buddies[SteamID] = nil
        sql.Query("DELETE FROM FPP_Buddies WHERE steamid = " .. sql.SQLStr(SteamID) .. ";")
        for _, v in player.Iterator() do
            if v:SteamID() == SteamID then
                RunConsoleCommand("FPP_SetBuddy", v:UserID(), "0", "0", "0", "0", "0")
            end
        end
        return
    end

    FPP.Buddies[SteamID] = FPP.Buddies[SteamID] or {name = Name, physgun = 0, gravgun = 0, toolgun = 0, playeruse = 0, entitydamage = 0} -- Create if not there
    FPP.Buddies[SteamID][Type] = value

    local data = sql.Query("SELECT * FROM FPP_Buddies WHERE steamid = " .. sql.SQLStr(SteamID) .. ";")
    if data then
        sql.Query("UPDATE FPP_Buddies SET " .. Type .. " = " .. value .. " WHERE steamid = " .. sql.SQLStr(SteamID) .. ";")
        -- Oi! update the name!
        sql.Query("UPDATE FPP_Buddies SET name = " .. sql.SQLStr(Name) .. " WHERE steamid = " .. sql.SQLStr(SteamID) .. ";")
        FPP.Buddies[SteamID].name = Name
    else
        sql.Query("INSERT INTO FPP_Buddies VALUES(" .. sql.SQLStr(SteamID) .. ", " .. sql.SQLStr(Name) .. ", " .. FPP.Buddies[SteamID].physgun .. ", " .. FPP.Buddies[SteamID].gravgun .. ", " .. FPP.Buddies[SteamID].toolgun .. ", " .. FPP.Buddies[SteamID].playeruse .. ", " .. FPP.Buddies[SteamID].entitydamage .. ");")
    end

    --Let the server know of your changes
    for _, v in player.Iterator() do
        if v:SteamID() == SteamID then -- If the person you're adding is in the server then add him serverside
            RunConsoleCommand("FPP_SetBuddy", v:UserID(), FPP.Buddies[SteamID].physgun, FPP.Buddies[SteamID].gravgun, FPP.Buddies[SteamID].toolgun, FPP.Buddies[SteamID].playeruse, FPP.Buddies[SteamID].entitydamage)
            --Don't break because there can be people(bots actually) with the same steam ID
        end
    end

    local ShouldRemove = true -- Remove the buddy if he isn't buddy in anything anymore
    for _, v in pairs(FPP.Buddies[SteamID]) do
        if v == 1 or v == "1" then
            ShouldRemove = false
            break
        end
    end

    if ShouldRemove then -- If everything = 0 then he's not your friend anymore
        FPP.Buddies[SteamID] = nil
        sql.Query("DELETE FROM FPP_Buddies WHERE steamid = " .. sql.SQLStr(SteamID) .. ";")
        for _, v in player.Iterator() do
            if v:SteamID() == SteamID then
                RunConsoleCommand("FPP_SetBuddy", v:UserID(), "0", "0", "0", "0", "0")
            end
        end
    end
end

function FPP.NewBuddy(um)
    local ply = net.ReadEntity()

    if not IsValid(ply) or not ply:IsPlayer() then return end
    local SteamID = ply:SteamID()

    local data = sql.Query("SELECT * FROM FPP_Buddies")
    if not data then return end

    for _, v in pairs(data) do
        -- make the player buddy if they're in your buddies list
        if v.steamid ~= SteamID then continue end

        RunConsoleCommand("FPP_SetBuddy", ply:UserID(), v.physgun, v.gravgun, v.toolgun, v.playeruse, v.entitydamage)
        -- update the name
        sql.Query("UPDATE FPP_Buddies SET name = " .. sql.SQLStr(ply:Nick()) .. " WHERE steamid = " .. sql.SQLStr(SteamID) .. ";")
        FPP.Buddies[SteamID] = FPP.Buddies[SteamID] or {}
        FPP.Buddies[SteamID].name = ply:Nick()
    end
end
net.Receive("FPP_CheckBuddy", FPP.NewBuddy)

--gamemodes/darkrp/gamemode/modules/fpp/pp/client/ownability.lua:
FPP = FPP or {}

FPP.entOwners       = FPP.entOwners or {}
FPP.entTouchability = FPP.entTouchability or {}
FPP.entTouchReasons = FPP.entTouchReasons or {}

local touchTypes = {
    Physgun = 1,
    Gravgun = 2,
    Toolgun = 4,
    PlayerUse = 8,
    EntityDamage = 16
}

local reasonSize = 4 -- bits
local reasons = {
    [1] = "owner", -- you can't touch other people's props
    [2] = "world",
    [3] = "disconnected",
    [4] = "blocked",
    [5] = "constrained",
    [6] = "buddy",
    [7] = "shared",
    [8] = "player", -- you can't pick up players
}

local function receiveTouchData(len)
    repeat
        local entIndex = net.ReadUInt(32)
        local ownerIndex = net.ReadUInt(32)
        local touchability = net.ReadUInt(5)
        local reason = net.ReadUInt(20)

        FPP.entOwners[entIndex] = ownerIndex
        FPP.entTouchability[entIndex] = touchability
        FPP.entTouchReasons[entIndex] = reason
    until net.ReadBit() == 1
end
net.Receive("FPP_TouchabilityData", receiveTouchData)

function FPP.entGetOwner(ent)
    local idx = FPP.entOwners[ent:EntIndex()]
    ent.FPPOwner = idx and Entity(idx) or nil

    return ent.FPPOwner
end

function FPP.canTouchEnt(ent, touchType)
    ent.FPPCanTouch = FPP.entTouchability[ent:EntIndex()]
    if not touchType or not ent.FPPCanTouch then
        return ent.FPPCanTouch
    end

    return bit.bor(ent.FPPCanTouch, touchTypes[touchType]) == ent.FPPCanTouch
end


local touchTypeMultiplier = {
    ["Physgun"] = 0,
    ["Gravgun"] = 1,
    ["Toolgun"] = 2,
    ["PlayerUse"] = 3,
    ["EntityDamage"] = 4
}

function FPP.entGetTouchReason(ent, touchType)
    local idx = FPP.entTouchReasons[ent:EntIndex()] or 0
    ent.FPPCanTouchWhy = idx

    if not touchType then
        return ent.FPPCanTouchWhy
    end

    local maxReasonValue = 15
    -- 1111 shifted to the right touch type
    local touchTypeMask = bit.lshift(maxReasonValue, reasonSize * touchTypeMultiplier[touchType])
    -- Extract reason for touch type from reason number
    local touchTypeReason = bit.band(idx, touchTypeMask)
    -- Shift it back to the right
    local reasonNr = bit.rshift(touchTypeReason, reasonSize * touchTypeMultiplier[touchType])

    local reason = reasons[reasonNr]
    local owner = ent:CPPIGetOwner()

    if reasonNr == 1 then -- convert owner to the actual player
        return not isnumber(owner) and IsValid(owner) and owner:Nick() or "Unknown player"
    elseif reasonNr == 6 then
        return "Buddy (" .. (IsValid(owner) and owner:Nick() or "Unknown player") .. ")"
    end

    return reason
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/messaging/sh_shared.lua:
FAdmin.Messages = {}

FAdmin.Messages.MsgTypes = {
    ERROR = {TEXTURE = "icon16/exclamation.png", COLOR = Color(255,180,0,80)},
    NOTIFY = {TEXTURE = "vgui/notices/error", COLOR = Color(255,255,0,80)},
    QUESTION = {TEXTURE = "vgui/notices/hint", COLOR = Color(0,0,255,80)},
    GOOD = {TEXTURE = "icon16/tick.png", COLOR = Color(0,255,0,80)},
    BAD = {TEXTURE = "icon16/cross.png", COLOR = Color(255,0,0,80)}
}
FAdmin.Messages.MsgTypesByName = {
    ERROR = 1,
    NOTIFY = 2,
    QUESTION = 3,
    GOOD = 4,
    BAD = 5,
}

function FAdmin.PlayerName(ply)
    if isstring(ply) then return ply end
    
    if CLIENT and ply == LocalPlayer() then return "Ты" end

    return isentity(ply) and (ply:EntIndex() == 0 and "Сервер" or ply:Name()) or "Неизвестно"
end

function FAdmin.TargetsToString(targets)
    if not istable(targets) then
        return FAdmin.PlayerName(targets)
    end

    if #targets == 0 then
        return "no one"
    end

    if #targets == #player.GetAll() and #targets ~= 1 then
        return "everyone"
    end

    targets = table.Copy(targets)
    local names = fn.Map(FAdmin.PlayerName, targets)

    if #names == 1 then
        return names[1]
    end

    return table.concat(names, ", ", 1, #names - 1) .. " and " .. names[#names]
end

FAdmin.Notifications = {}

local validNotification = tc.checkTable{
    -- A name to identify the notification by
    name =
        tc.addHint(
            isstring,
            "The name must be a string!"
        ),

    -- Whether the notification applies to some kind of target
    hasTarget =
        tc.addHint(
            tc.optional(isbool),
            "hasTarget must either be true, false or nil!"
        ),

    -- Who receives the notification. Can be either one of the list or a function that returns a table of players
    receivers =
        tc.addHint(
            fn.FOr{tc.client, isfunction, tc.oneOf{"everyone", "admins", "superadmins", "self", "targets", "involved", "involved+admins", "involved+superadmins"}},
            "receivers must either be a function returning a table of players or one of 'admins', 'superadmins', 'everyone', 'self', 'targets', 'involved', 'involved+admins', 'involved+superadmins'"
        ),

    -- A table containing the message in parts. There are special strings
    message =
        tc.addHint(
            tc.tableOf(isstring),
            "The message field must be a table of strings! with special strings 'targets', 'you', 'instigator', 'extraInfo.#', with # a number."
        ),

    -- The message type when chat notifications are disabled. NOTIFY by default
    msgType =
        tc.default(
            "NOTIFY",
            tc.addHint(
                tc.oneOf{"ERROR", "NOTIFY", "QUESTION", "GOOD", "BAD"}, "msgType must be one of 'ERROR', 'NOTIFY', 'QUESTION', 'GOOD', 'BAD'"
            )
        ),

    -- A function that writes extra data in the net message
    writeExtraInfo =
        tc.addHint(
            tc.optional(isfunction),
            "writeExtraInfo must be a function"
        ),

    -- A function that reads the written data, formats it and puts it in a table
    readExtraInfo =
        tc.addHint(
            tc.optional(isfunction),
            "writeExtraInfo must be a function"
        ),

    -- When using extra information, this table contains the colours of the extraInfo messages
    extraInfoColors =
        tc.addHint(
            tc.optional(tc.tableOf(tc.iscolor)),
            "extraInfoColors must be a table of colours!"
        ),

    -- Whether the notification is to be logged to console
    logging =
        tc.default(true,
            tc.addHint(
                isbool,
                "logging must be a boolean!"
            )
        ),
}


FAdmin.NotificationNames = {}

function FAdmin.Messages.RegisterNotification(tbl)
    local correct, err = validNotification(tbl)

    if not correct then
        error(string.format("Incorrect notification format for notification '%s'!\n\n%s", istable(tbl) and tbl.name or "unknown", err), 2)
    end

    local key = table.insert(FAdmin.Notifications, tbl)
    FAdmin.NotificationNames[tbl.name] = key

    return key
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/commands/cl_concommands.lua:
local function AutoComplete(command, args)
    local autocomplete = {}
    args = string.Explode(" ", args)
    table.remove(args, 1) --Remove the first space
    if args[1] == "" then
        for k,v in pairs(FAdmin.Commands.List) do
            table.insert(autocomplete, command .. " " .. k)
        end
    elseif not args[2] or args[3] then
        for k,v in pairs(FAdmin.Commands.List) do
            if string.sub(k, 1, string.len(args[1])) == args[1] then
                local ExtraArgs = table.concat(v.ExtraArgs, "    ")
                table.insert(autocomplete, command .. " " .. k .. "        " .. ExtraArgs)
            end
        end
    elseif not args[3] and FAdmin.Commands.List[string.lower(args[1])] and FAdmin.Commands.List[string.lower(args[1])].ExtraArgs[1] == "<Player>" then
        for k,v in player.Iterator() do
            if args[2] == "" or table.HasValue(FAdmin.FindPlayer(args[2]) or {}, v) then
                table.insert(autocomplete, command .. " " .. args[1] .. " " .. v:Nick())
            end
        end
    end
    table.sort(autocomplete)
    return autocomplete
end
concommand.Add("FAdmin", function(ply, cmd, args)
    RunConsoleCommand("_" .. cmd, unpack(args))
end, AutoComplete)

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/cl_start.lua:
FAdmin.ScoreBoard = FAdmin.ScoreBoard or {}

local ScreenWidth, ScreenHeight = ScrW(), ScrH()

FAdmin.ScoreBoard.X = ScreenWidth * 0.05
FAdmin.ScoreBoard.Y = ScreenHeight * 0.025
FAdmin.ScoreBoard.Width = ScreenWidth * 0.9
FAdmin.ScoreBoard.Height = ScreenHeight * 0.95

FAdmin.ScoreBoard.Controls = FAdmin.ScoreBoard.Controls or {}
FAdmin.ScoreBoard.CurrentView = "Main"

FAdmin.ScoreBoard.Main = FAdmin.ScoreBoard.Main or {}
FAdmin.ScoreBoard.Main.Controls = FAdmin.ScoreBoard.Main.Controls or {}
FAdmin.ScoreBoard.Main.Logo = "gui/gmod_logo"

FAdmin.ScoreBoard.Player = FAdmin.ScoreBoard.Player or {}
FAdmin.ScoreBoard.Player.Controls = FAdmin.ScoreBoard.Player.Controls or {}
FAdmin.ScoreBoard.Player.Player = NULL
FAdmin.ScoreBoard.Player.Logo = "fadmin/back"

FAdmin.ScoreBoard.Server = FAdmin.ScoreBoard.Server or {}
FAdmin.ScoreBoard.Server.Controls = FAdmin.ScoreBoard.Server.Controls or {}
FAdmin.ScoreBoard.Server.Logo = "fadmin/back"

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/cl_scoreboardserver.lua:
FAdmin.ScoreBoard.Server.Information = {} -- Compatibility for autoreload
FAdmin.ScoreBoard.Server.ActionButtons = {} -- Refresh server buttons when reloading gamemode

local function MakeServerOptions()
    local _, YPos, Width = 20, FAdmin.ScoreBoard.Y + 120 + FAdmin.ScoreBoard.Height / 5 + 20, (FAdmin.ScoreBoard.Width - 40) / 3

    FAdmin.ScoreBoard.Server.Controls.ServerActionsCat = FAdmin.ScoreBoard.Server.Controls.ServerActionsCat or vgui.Create("FAdminPlayerCatagory")
    FAdmin.ScoreBoard.Server.Controls.ServerActionsCat:SetLabel("  Server Actions")
    FAdmin.ScoreBoard.Server.Controls.ServerActionsCat.CatagoryColor = Color(155, 0, 0, 255)
    FAdmin.ScoreBoard.Server.Controls.ServerActionsCat:SetSize(Width-5, FAdmin.ScoreBoard.Height - 20 - YPos)
    FAdmin.ScoreBoard.Server.Controls.ServerActionsCat:SetPos(FAdmin.ScoreBoard.X + 20, YPos)
    FAdmin.ScoreBoard.Server.Controls.ServerActionsCat:SetVisible(true)
    function FAdmin.ScoreBoard.Server.Controls.ServerActionsCat:Toggle()
    end

    FAdmin.ScoreBoard.Server.Controls.ServerActions = FAdmin.ScoreBoard.Server.Controls.ServerActions or vgui.Create("FAdminPanelList")
    FAdmin.ScoreBoard.Server.Controls.ServerActionsCat:SetContents(FAdmin.ScoreBoard.Server.Controls.ServerActions)
    FAdmin.ScoreBoard.Server.Controls.ServerActions:SetTall(FAdmin.ScoreBoard.Height - 20 - YPos)
    for k,v in pairs(FAdmin.ScoreBoard.Server.Controls.ServerActions:GetChildren()) do
        if k == 1 then continue end
        v:Remove()
    end

    FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat = FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat or vgui.Create("FAdminPlayerCatagory")
    FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat:SetLabel("  Player Actions")
    FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat.CatagoryColor = Color(0, 155, 0, 255)
    FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat:SetSize(Width-5, FAdmin.ScoreBoard.Height - 20 - YPos)
    FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat:SetPos(FAdmin.ScoreBoard.X + 20 + Width, YPos)
    FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat:SetVisible(true)
    function FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat:Toggle()
    end

    FAdmin.ScoreBoard.Server.Controls.PlayerActions = FAdmin.ScoreBoard.Server.Controls.PlayerActions or vgui.Create("FAdminPanelList")
    FAdmin.ScoreBoard.Server.Controls.PlayerActionsCat:SetContents(FAdmin.ScoreBoard.Server.Controls.PlayerActions)
    FAdmin.ScoreBoard.Server.Controls.PlayerActions:SetTall(FAdmin.ScoreBoard.Height - 20 - YPos)
    for k,v in pairs(FAdmin.ScoreBoard.Server.Controls.PlayerActions:GetChildren()) do
        if k == 1 then continue end
        v:Remove()
    end

    FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat = FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat or vgui.Create("FAdminPlayerCatagory")
    FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat:SetLabel("  Server Settings")
    FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat.CatagoryColor = Color(0, 0, 155, 255)
    FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat:SetSize(Width-5, FAdmin.ScoreBoard.Height - 20 - YPos)
    FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat:SetPos(FAdmin.ScoreBoard.X + 20 + Width * 2, YPos)
    FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat:SetVisible(true)
    function FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat:Toggle()
    end

    FAdmin.ScoreBoard.Server.Controls.ServerSettings = FAdmin.ScoreBoard.Server.Controls.ServerSettings or vgui.Create("FAdminPanelList")
    FAdmin.ScoreBoard.Server.Controls.ServerSettingsCat:SetContents(FAdmin.ScoreBoard.Server.Controls.ServerSettings)
    FAdmin.ScoreBoard.Server.Controls.ServerSettings:SetTall(FAdmin.ScoreBoard.Height - 20 - YPos)
    for k,v in pairs(FAdmin.ScoreBoard.Server.Controls.ServerSettings:GetChildren()) do
        if k == 1 then continue end
        v:Remove()
    end

    for k, v in ipairs(FAdmin.ScoreBoard.Server.ActionButtons) do
        local visible = v.Visible == true or (type(v.Visible) == "function" and v.Visible(LocalPlayer()) == true)

        local ActionButton = vgui.Create("FAdminActionButton")
        if type(v.Image) == "string" then
            ActionButton:SetImage(v.Image or "icon16/exclamation")
        elseif type(v.Image) == "table" then
            ActionButton:SetImage(v.Image[1])
            if v.Image[2] then ActionButton:SetImage2(v.Image[2]) end
        elseif type(v.Image) == "function" then
            local img1, img2 = v.Image()
            ActionButton:SetImage(img1)
            if img2 then ActionButton:SetImage2(img2) end
        else
            ActionButton:SetImage("icon16/exclamation")
        end
        local name = v.Name
        if type(name) == "function" then name = name() end
        ActionButton:SetText(DarkRP.deLocalise(name))
        ActionButton:SetBorderColor(visible and v.color or Color(120, 120, 120))
        ActionButton:SetDisabled(not visible)
        ActionButton:Dock(TOP)

        function ActionButton:DoClick()
            return v.Action(self)
        end

        FAdmin.ScoreBoard.Server.Controls[v.TYPE]:Add(ActionButton)
        if v.OnButtonCreated then
            v.OnButtonCreated(ActionButton)
        end
    end
end

function FAdmin.ScoreBoard.Server:AddServerAction(Name, Image, color, Visible, Action, OnButtonCreated)
    table.insert(FAdmin.ScoreBoard.Server.ActionButtons, {TYPE = "ServerActions", Name = Name, Image = Image, color = color, Visible = Visible, Action = Action, OnButtonCreated = OnButtonCreated})
end

function FAdmin.ScoreBoard.Server:AddPlayerAction(Name, Image, color, Visible, Action, OnButtonCreated)
    table.insert(FAdmin.ScoreBoard.Server.ActionButtons, {TYPE = "PlayerActions", Name = Name, Image = Image, color = color, Visible = Visible, Action = Action, OnButtonCreated = OnButtonCreated})
end

function FAdmin.ScoreBoard.Server:AddServerSetting(Name, Image, color, Visible, Action, OnButtonCreated)
    table.insert(FAdmin.ScoreBoard.Server.ActionButtons, {TYPE = "ServerSettings", Name = Name, Image = Image, color = color, Visible = Visible, Action = Action, OnButtonCreated = OnButtonCreated})
end

function FAdmin.ScoreBoard.Server.Show(ply)
    FAdmin.ScoreBoard.Server.InfoPanels = FAdmin.ScoreBoard.Server.InfoPanels or {}
    for k,v in pairs(FAdmin.ScoreBoard.Server.InfoPanels) do
        if IsValid(v) then
            v:Remove()
            FAdmin.ScoreBoard.Server.InfoPanels[k] = nil
        end
    end

    if IsValid(FAdmin.ScoreBoard.Server.Controls.InfoPanel) then
        FAdmin.ScoreBoard.Server.Controls.InfoPanel:Remove()
    end
    FAdmin.ScoreBoard.Server.Controls.InfoPanel = vgui.Create("FAdminPanelList")
    FAdmin.ScoreBoard.Server.Controls.InfoPanel:SetPos(FAdmin.ScoreBoard.X + 20, FAdmin.ScoreBoard.Y + 120)
    FAdmin.ScoreBoard.Server.Controls.InfoPanel:SetSize(FAdmin.ScoreBoard.Width - 40, FAdmin.ScoreBoard.Height / 5)
    FAdmin.ScoreBoard.Server.Controls.InfoPanel:SetVisible(true)
    FAdmin.ScoreBoard.Server.Controls.InfoPanel:Clear(true)

    local function AddInfoPanel()
        local pan = vgui.Create("FAdminPanelList")
        pan:SetSize(1, FAdmin.ScoreBoard.Server.Controls.InfoPanel:GetTall())
        pan:Dock(LEFT)
        FAdmin.ScoreBoard.Server.Controls.InfoPanel:Add(pan)

        table.insert(FAdmin.ScoreBoard.Server.InfoPanels, pan)
        return pan
    end

    local SelectedPanel = AddInfoPanel() -- Make first panel to put the first things in

    for k, v in pairs(FAdmin.ScoreBoard.Server.Information) do
        local Text = vgui.Create("DLabel")
        Text:SetFont("Default")
        Text:SetColor(Color(255,255,255,200))
        Text:Dock(TOP)
        Text.Func = v.Func

        local EndText
        local function RefreshText()
            local Value = v.func()

            if not Value or Value == "" then
                Value = "N/A"
            end

            EndText = v.name .. ":  " .. Value
            local strLen = string.len(EndText)

            if strLen > 40 then
                local NewValue = string.sub(EndText, 1, 40)

                for i = 40, strLen, 34 do
                    NewValue = NewValue .. "\n        " .. string.sub(EndText, i + 1, i + 34)
                end

                EndText = NewValue
            else
                local MaxWidth = 240
                surface.SetFont("Default")
                local TextWidth = surface.GetTextSize(v.name .. ": " .. Value)

                if TextWidth <= MaxWidth then
                    local SpacesAmount = (MaxWidth - TextWidth) / 3
                    local Spaces = ""

                    for i = 1, SpacesAmount, 1 do
                        Spaces = Spaces .. " "
                    end

                    EndText = v.name .. ":" .. Spaces .. Value
                end
            end

            Text:SetText(DarkRP.deLocalise(EndText))
            Text:SizeToContents()
            Text:SetTooltip("Click to copy " .. v.name .. " to clipboard")
            Text:SetMouseInputEnabled(true)
        end

        RefreshText()

        function Text:OnMousePressed(mcode)
            self:SetTooltip(v.name .. " copied to clipboard!")
            ChangeTooltip(self)
            SetClipboardText(v.func() or "")
            self:SetTooltip("Click to copy " .. v.name .. " to clipboard")
        end

        timer.Create("FAdmin_Scoreboard_text_update_" .. v.name, 1, 0, function()
            if not IsValid(Text) then
                timer.Remove("FAdmin_Scoreboard_text_update_" .. v.name)
                FAdmin.ScoreBoard.ChangeView("Main")

                return
            end

            RefreshText()
        end)

        if #SelectedPanel:GetChildren() * 17 + 17 >= SelectedPanel:GetTall() or v.NewPanel then
            SelectedPanel = AddInfoPanel()
        end
        -- Add new panel if the last one is full
        SelectedPanel:Add(Text)
        if Text:GetWide() > SelectedPanel:GetWide() then
            SelectedPanel:SetWide(Text:GetWide() + 40)
        end
    end

    MakeServerOptions()
end
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/voicemute/cl_init.lua:
hook.Add("PlayerBindPress", "FAdmin_voicemuted", function(ply, bind, pressed)
    if ply:FAdmin_GetGlobal("FAdmin_voicemuted") and string.find(string.lower(bind), "voicerecord") then return true end
    -- The voice muting is not done clientside, this is just so people know they can't talk
end)

FAdmin.StartHooks["VoiceMute"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "voicemute",
        hasTarget = true,
        message = {"instigator", " замутил голосовой чат ", "targets", " ", "extraInfo.1"},
        readExtraInfo = function()
            local time = net.ReadUInt(16)
            return {time == 0 and FAdmin.PlayerActions.commonTimes[time] or string.format("на %s", FAdmin.PlayerActions.commonTimes[time] or (time .. " секунд"))}
        end
    }

    FAdmin.Messages.RegisterNotification{
        name = "voiceunmute",
        hasTarget = true,
        message = {"instigator", " снял мут голосового чата с ", "targets"}
    }

    FAdmin.Access.AddPrivilege("Voicemute", 2)
    FAdmin.Commands.AddCommand("Voicemute", nil, "<Player>")
    FAdmin.Commands.AddCommand("UnVoicemute", nil, "<Player>")

    wayscore.AddActionButton('voicemute', {
        name = function(ply) return ply:FAdmin_GetGlobal('FAdmin_voicemuted') and 'Снять войсмут' or 'Выдать войсмут' end,
        icon = function(ply)
            return 'fadmin/icons/voicemute', not ply:FAdmin_GetGlobal('FAdmin_voicemuted') and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        category = 'Чат',
        order = 19000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Voicemute', ply) end,
        callback = function(ply, button)
            if not ply:FAdmin_GetGlobal('FAdmin_voicemuted') then
                FAdmin.PlayerActions.addTimeMenu(function(secs)
                    RunConsoleCommand('_FAdmin', 'voicemute', ply:UserID(), secs)
                    button:SetImage2('null')
                    button:SetText('Снять войсмут')
                    button:GetParent():InvalidateLayout()
                end)
            else
                RunConsoleCommand('_FAdmin', 'unvoicemute', ply:UserID())
            end

            button:SetImage2('fadmin/icons/disable')
            button:SetText('Выдать войсмут')
            button:GetParent():InvalidateLayout()
        end,
    })

    wayscore.AddActionButton('selfmute', {
        name = function(ply) return ply.FAdminMuted and 'Размутить у себя' or 'Замутить у себя' end,
        icon = function(ply)
            return 'fadmin/icons/voicemute', not ply.FAdminMuted and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        category = 'Чат',
        order = 0,
        callback = function(ply, button)
            ply:SetMuted(not ply.FAdminMuted)
            ply.FAdminMuted = not ply.FAdminMuted
    
            if ply.FAdminMuted then
                button:SetImage2("null")
                button:SetText("Размутить у себя")
                button:GetParent():InvalidateLayout()
                return
            end

            button:SetImage2("fadmin/icons/disable")
            button:SetText("Замутить у себя")
            button:GetParent():InvalidateLayout()
        end,
    })

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("Замутить/Размутить у себя", function(ply, Panel)
        ply:SetMuted(not ply.FAdminMuted)
        ply.FAdminMuted = not ply.FAdminMuted
    end)
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/slay/cl_init.lua:
FAdmin.StartHooks["Slay"] = function()
    FAdmin.Access.AddPrivilege("Slay", 2)
    FAdmin.Commands.AddCommand("Slay", nil, "<Player>", "[Normal/Silent/Explode/Rocket]")

    wayscore.AddActionButton('slay', {
        name = 'Убить',
        icon = 'fadmin/icons/slay',
        color = Color(255,130,0),
        category = 'Развлечения',
        order = 17000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Slay', ply) end,
        callback = function(ply)
            local menu = DermaMenu()
    
            local Padding = vgui.Create("DPanel")
            Padding:SetPaintBackgroundEnabled(false)
            Padding:SetSize(1,5)
            menu:AddPanel(Padding)
    
            local Title = vgui.Create("DLabel")
            Title:SetText("  Вид убийства:\n")
            Title:SetFont("UiBold")
            Title:SizeToContents()
            Title:SetTextColor(color_black)
            menu:AddPanel(Title)
    
            for k,v in pairs(FAdmin.PlayerActions.SlayTypes) do
                local uid = ply:UserID()
                menu:AddOption(v, function()
                    RunConsoleCommand("_FAdmin", "slay", uid, k)
                end)
            end
    
            menu:Open()
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/ragdoll/sh_shared.lua:
-- lua_Run A = Player(5):GetEyeTrace().Entity
-- lua_run for i = 1, A:GetPhysicsObjectCount() do B = A:WorldToLocal(A:GetPhysicsObjectNum(i):GetPos()) print("Vector("..B.x..", "..B.y..", "..B.z.."),") end
-- lua_run for i = 1, A:GetPhysicsObjectCount() do B = A:GetPhysicsObjectNum(i):GetAngle() print("Angle("..B.p..", "..B.y..", "..B.r.."),") end

FAdmin.PlayerActions.RagdollTypes = {
    [1] = "Normal",
    [2] = "Kick him in the nuts",
    [3] = "Hang",
    [4] = "Unragdoll"
}

FAdmin.StartHooks["Ragdolling"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "ragdoll",
        hasTarget = true,
        message = {"instigator", " превратил ", "targets", " в ragdoll ", "extraInfo.1"},
        receivers = "involved+admins",
        writeExtraInfo = function(info) net.WriteUInt(info[1], 16) end,
        readExtraInfo = function()
            local time = net.ReadUInt(16)
            return {time == 0 and FAdmin.PlayerActions.commonTimes[time] or string.format("на %s", FAdmin.PlayerActions.commonTimes[time] or (time .. " секунд"))}
        end
    }

    FAdmin.Messages.RegisterNotification{
        name = "unragdoll",
        hasTarget = true,
        message = {"instigator", " снял ragdoll с ", "targets"},
        receivers = "involved+admins",
    }
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/police/cl_init.lua:
FAdmin.StartHooks["police_cl"] = function()
    wayscore.AddActionButton('unarrest', {
        name = function(ply)
            return 'Разарестовать'
        end,
        icon = function(ply)
            return 'fadmin/icons/jail', ply:isWanted() and 'fadmin/icons/disable'
        end,
        color = Color(0,0,200),
        category = 'Полиция',
        check = function(ply) return LocalPlayer():IsAdmin() and ply:isArrested() end,
        callback = function(ply)
            RunConsoleCommand('fadmin', 'unarrest', ply:UserID())
        end
    })
end
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/noclip/sh_shared.lua:
local sbox_noclip = GetConVar("sbox_noclip")

local function sendNoclipMessage(ply)
    if not SERVER or ply.FADmin_HasGotNoclipMessage then return end

    FAdmin.Messages.SendMessage(ply, 4, "Noclip allowed")
    ply.FADmin_HasGotNoclipMessage = true
end

hook.Add("PlayerNoClip", "FAdmin_noclip", function(ply)
    if ply:FAdmin_GetGlobal("FADmin_DisableNoclip") then
        if SERVER then
            FAdmin.Messages.SendMessage(ply, 5, "Noclip disallowed!")
        end

        return false
    end

    -- No further judgement when sbox_noclip is on
    if sbox_noclip and sbox_noclip:GetBool() then return end

    if ply:FAdmin_GetGlobal("FADmin_CanNoclip") then
        sendNoclipMessage(ply)

        return true
    end

    -- Has privilege
    if not FAdmin.Access.PlayerHasPrivilege(ply, "Noclip") then return end

    -- Disallow if other hooks say no
    for k, v in pairs(hook.GetTable().PlayerNoClip) do
        if k == "FAdmin_noclip" then continue end
        if v(ply) == false then return false end
    end

    sendNoclipMessage(ply)

    ply.cantJailbreak = true

    return true
end)

FAdmin.StartHooks['zz_Noclip'] = function()
    FAdmin.Access.AddPrivilege('Noclip', 2)
end
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/jail/sh_shared.lua:
FAdmin.PlayerActions.JailTypes = {}
FAdmin.PlayerActions.JailTypes[1] = "Small"
FAdmin.PlayerActions.JailTypes[2] = "Normal"
FAdmin.PlayerActions.JailTypes[3] = "Big"
FAdmin.PlayerActions.JailTypes[4] = "Unjail"

hook.Add("CanTool", "FAdmin_jailed", function(ply) -- shared so it doesn't look like you can use tool
    if ply:FAdmin_GetGlobal("fadmin_jailed") then
        return false
    end
end)

hook.Add("PlayerNoClip", "FAdmin_jail", function(ply)
    if ply:FAdmin_GetGlobal("fadmin_jailed") then
        return false
    end
end)

FAdmin.StartHooks["Jailing"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "jail",
        hasTarget = true,
        message = {"instigator", " посадил ", "targets", " в jail ", "extraInfo.1"},
        receivers = "involved+admins",
        writeExtraInfo = function(info) net.WriteUInt(info[1], 16) end,
        readExtraInfo = function()
            local time = net.ReadUInt(16)
            return {time == 0 and FAdmin.PlayerActions.commonTimes[time] or string.format("на %s", FAdmin.PlayerActions.commonTimes[time] or (time .. " секунд"))}
        end
    }

    FAdmin.Messages.RegisterNotification{
        name = "unjail",
        hasTarget = true,
        message = {"instigator", " выпустил ", "targets", " из jail"},
        receivers = "involved+admins",
    }
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/jail/cl_init.lua:
FAdmin.StartHooks["Jail"] = function()
    FAdmin.Access.AddPrivilege("Jail", 2)
    FAdmin.Commands.AddCommand("Jail", nil, "<Player>", "[Small/Normal/Big]", "[Time]")
    FAdmin.Commands.AddCommand("UnJail", nil, "<Player>")

    wayscore.AddActionButton('jail', {
        name = function(ply) return ply:FAdmin_GetGlobal('fadmin_jailed') and 'Снять jail' or 'Jail' end,
        icon = function(ply)
            return 'fadmin/icons/jail', ply:FAdmin_GetGlobal('fadmin_jailed') and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        category = 'Администрирование',
        order = 14000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Jail', ply) end,
        callback = function(ply, button)
            if ply:FAdmin_GetGlobal("fadmin_jailed") then
                RunConsoleCommand("_FAdmin", "unjail", ply:UserID())
                button:SetImage2("null")
                button:SetText("Jail")
                button:GetParent():InvalidateLayout()
                return
            end

            local menu = DermaMenu()
    
            local Padding = vgui.Create("DPanel")
            Padding:SetPaintBackgroundEnabled(false)
            Padding:SetSize(1,5)
            menu:AddPanel(Padding)
    
            local Title = vgui.Create("DLabel")
            Title:SetText("  Тип jail\'а:\n")
            Title:SetFont("UiBold")
            Title:SizeToContents()
            Title:SetTextColor(color_black)
    
            menu:AddPanel(Title)
    
            for k,v in pairs(FAdmin.PlayerActions.JailTypes) do
                if v == "Unjail" then continue end
                FAdmin.PlayerActions.addTimeSubmenu(menu, v .. " jail",
                    function()
                        RunConsoleCommand("_FAdmin", "Jail", ply:UserID(), k)
                        button:SetText("Снять jail")
                        button:GetParent():InvalidateLayout()
                        button:SetImage2("fadmin/icons/disable")
                    end,
                    function(secs)
                        RunConsoleCommand("_FAdmin", "Jail", ply:UserID(), k, secs)
                        button:SetText("Снять jail")
                        button:GetParent():InvalidateLayout()
                        button:SetImage2("fadmin/icons/disable")
                    end
                )
            end
    
            menu:Open()
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/giveweapons/sh_hl2weapons.lua:
FAdmin.HL2Guns = {
--    Crowbar = "weapon_crowbar",
    Gravgun = "weapon_gravgun",
    Physgun = "weapon_physgun",
--    Stunstick = "weapon_stunstick",
--    Pistol = "weapon_pistol",
--    ["357"] = "weapon_357",
--    Smg1 = "weapon_smg1",
--    Ar2 = "weapon_ar2",
--    Shotgun = "weapon_shotgun",
--    Crossbow = "weapon_crossbow",
--    Grenade = "weapon_frag",
--    RPG = "weapon_rpg",
--    ["S.L.A.M."] = "weapon_SLAM",
    Camera = "gmod_camera",
    Toolgun = "gmod_tool"
}

FAdmin.AmmoTypes = {
    AR2 = 30,
    AR2AltFire = 3,
    pistol = 180,
    smg1 = 45,
    ["357"] = 6,
    XBowBolt = 3,
    Buckshot = 6,
    RPG_Round = 3,
    SMG1_Grenade = 1,
    Grenade = 3,
    slam = 1
}

FAdmin.StartHooks["GivingWeapons"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "giveweapon",
        hasTarget = true,
        message = {"instigator", " выдал ", "extraInfo.1", " игроку ", "targets"},
        receivers = "involved+admins",
        writeExtraInfo = function(i) net.WriteString(i[1]) end,
        readExtraInfo = function()
            return {net.ReadString()}
        end,
        extraInfoColors = {Color(160, 171, 189)}
    }

    FAdmin.Messages.RegisterNotification{
        name = "giveammo",
        hasTarget = true,
        message = {"instigator", " gave ", "extraInfo.1", " ", "extraInfo.2", " ammo to ", "targets"},
        receivers = "involved+admins",
        writeExtraInfo = function(info) net.WriteUInt(info[1], 32) net.WriteString(info[2]) end,
        readExtraInfo = function()
            return {tostring(net.ReadUInt(32)), net.ReadString()}
        end,
        extraInfoColors = {Color(160, 171, 189)}
    }
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/chatmute/cl_init.lua:
FAdmin.StartHooks["Chatmute"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "chatmute",
        hasTarget = true,
        message = {"instigator", " замутил текстовый чат ", "targets", " ", "extraInfo.1"},
        readExtraInfo = function()
            local time = net.ReadUInt(16)

            return {time == 0 and FAdmin.PlayerActions.commonTimes[time] or string.format("на %s", FAdmin.PlayerActions.commonTimes[time] or (time .. " секунд"))}
        end
    }

    FAdmin.Messages.RegisterNotification{
        name = "chatunmute",
        hasTarget = true,
        message = {"instigator", " снял мут текстового чата с ", "targets"},
    }

    FAdmin.Access.AddPrivilege("Chatmute", 2)
    FAdmin.Commands.AddCommand("Chatmute", nil, "<Player>")
    FAdmin.Commands.AddCommand("UnChatmute", nil, "<Player>")

    wayscore.AddActionButton('chatmute', {
        name = function(ply) return ply:FAdmin_GetGlobal('FAdmin_chatmuted') and 'Снять чатмут' or 'Выдать чатмут' end,
        icon = function(ply)
            return 'fadmin/icons/chatmute', not ply:FAdmin_GetGlobal('FAdmin_chatmuted') and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        category = 'Чат',
        order = 18000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Chatmute', ply) end,
        callback = function(ply, button)
            if not ply:FAdmin_GetGlobal('FAdmin_chatmuted') then
                FAdmin.PlayerActions.addTimeMenu(function(secs)
                    RunConsoleCommand('_FAdmin', 'chatmute', ply:UserID(), secs)
                    button:SetImage2('null')
                    button:SetText('Снять чатмут')
                    button:GetParent():InvalidateLayout()
                end)
            else
                RunConsoleCommand('_FAdmin', 'UnChatmute', ply:UserID())
            end

            button:SetImage2('fadmin/icons/disable')
            button:SetText('Выдать чатмут')
            button:GetParent():InvalidateLayout()
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/cppi/sh_cppi.lua:
if CPPI then return end
CPPI = {}
CPPI.CPPI_DEFER = 100100 --\100\100 = dd
CPPI.CPPI_NOTIMPLEMENTED = 7080

function CPPI:GetName()
    return "DarkRP"
end

function CPPI:GetVersion()
    return CPPI.CPPI_NOTIMPLEMENTED
end

function CPPI:GetInterfaceVersion()
    return CPPI.CPPI_NOTIMPLEMENTED
end

function CPPI:GetNameFromUID(uid)
    return CPPI.CPPI_NOTIMPLEMENTED
end

local PLAYER = FindMetaTable("Player")
function PLAYER:CPPIGetFriends()
    return CPPI.CPPI_NOTIMPLEMENTED
end

local ENTITY = FindMetaTable("Entity")
function ENTITY:CPPIGetOwner()
    return NULL, CPPI.CPPI_NOTIMPLEMENTED
end

if SERVER then
    function ENTITY:CPPISetOwner(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPISetOwnerUID(UID)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanTool(ply, tool)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanPhysgun(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanPickup(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanPunt(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end
end

--gamemodes/darkrp/gamemode/modules/chat/cl_chat.lua:
--[[---------------------------------------------------------------------------
Gamemode function
---------------------------------------------------------------------------]]
function GM:OnPlayerChat()
end

--[[---------------------------------------------------------------------------
Add a message to chat
---------------------------------------------------------------------------]]
local function AddToChat(bits)
    local col1 = Color(net.ReadUInt(8), net.ReadUInt(8), net.ReadUInt(8))

    local prefixText = net.ReadString()
    local ply = net.ReadEntity()
    ply = IsValid(ply) and ply or LocalPlayer()

    if not IsValid(ply) then return end

    if prefixText == "" or not prefixText then
        prefixText = ply:Nick()
        prefixText = prefixText ~= "" and prefixText or ply:SteamName()
    end

    local col2 = Color(net.ReadUInt(8), net.ReadUInt(8), net.ReadUInt(8))

    local text = net.ReadString()
    local shouldShow
    if text and text ~= "" then
        if IsValid(ply) then
            col1 = hook.Run('GetTeamColor', ply) or col1
            shouldShow = hook.Call("OnPlayerChat", GAMEMODE, ply, text, false, not ply:Alive(), prefixText, col1, col2)
        end

        if shouldShow ~= true then
            chat.AddNonParsedText(col1, prefixText, col2, ": " .. text)
            chat.PlaySound()
        end
    else
        shouldShow = hook.Call("ChatText", GAMEMODE, "0", prefixText, prefixText, "darkrp")

        if shouldShow ~= true then
            chat.AddNonParsedText(col1, prefixText)
            chat.PlaySound()
        end
    end
end
net.Receive("DarkRP_Chat", AddToChat)

--[[---------------------------------------------------------------------------
Credits

Please only ADD to the credits.
---------------------------------------------------------------------------]]
local creds =
[[

LightRP was created by Rick darkalonio. LightRP was sandbox with some added RP elements.
LightRP was released at the end of January 2007

DarkRP was created as a spoof of LightRP by Rickster, somewhere during the summer of 2007.
Note: There was a DarkRP in 2006, but that was an entirely different gamemode.

Rickster went to serve his country and went to Afghanistan. During that time, the following people updated DarkRP:
Picwizdan
Sibre
[GNC] Matt
PhilXYZ
Chromebolt A.K.A. Unib5 (STEAM_0:1:19045957)

In 2008, Unib5 was administrator on a DarkRP server called EuroRP, owned by Jiggu. FPtje frequently joined this server to prop kill en masse. While Jiggu loved watching the chaos unfold, Unib5 hated it and banned FPtje on sight. Since Jiggu kept unbanning FPtje, Unib5 felt powerless. In an attempt to stop FPtje, Unib5 put FPtje's favourite prop killing props (the locker and the sawblade) in the default blacklist of DarkRP in an update. This in turn enraged FPtje, as he swore to make an update in secret that would suddenly pop up and overthrow the established version. As a result, DarkRP 2.3.1 was released in December 2008. After a bit of a fight, FPtje became the official updater of DarkRP.

Current developer:
    Falco A.K.A. FPtje Atheos (STEAM_0:0:8944068)

People who have contributed (ordered by commits, with at least two commits)
    Bo98
    Drakehawke (STEAM_0:0:22342869) (64 commits on old SVN)
    FiG-Scorn
    Noiwex
    KoZ
    Eusion (STEAM_0:0:20450406) (3 commits on old SVN)
    Gangleider
    MattWalton12
    TypicalRookie
]]

local function credits()
    chat.AddNonParsedText(Color(255, 0, 0, 255), "[", Color(50,50,50,255), GAMEMODE.Name, Color(255, 0, 0, 255), "] ", Color(255, 255, 255, 255), DarkRP.getPhrase("credits_see_console"))

    MsgC(Color(255, 0, 0, 255), DarkRP.getPhrase("credits_for", GAMEMODE.Name), Color(255, 255, 255, 255), creds)
end
net.Receive("DarkRP_Credits", credits)

--gamemodes/darkrp/gamemode/modules/base/sh_util.lua:
--[[---------------------------------------------------------------------------
Utility functions
---------------------------------------------------------------------------]]

local vector = FindMetaTable("Vector")
local meta = FindMetaTable("Player")

--[[---------------------------------------------------------------------------
Decides whether the vector could be seen by the player if they were to look at it
---------------------------------------------------------------------------]]
function vector:isInSight(filter, ply)
    ply = ply or LocalPlayer()
    local trace = {}
    trace.start = ply:EyePos()
    trace.endpos = self
    trace.filter = filter
    trace.mask = -1
    local TheTrace = util.TraceLine(trace)

    return not TheTrace.Hit, TheTrace.HitPos
end

--[[---------------------------------------------------------------------------
Turn a money amount into a pretty string
---------------------------------------------------------------------------]]
local string_comma = string.Comma

function DarkRP.formatMoney(n)
    return '$' .. string_comma(n)
end

--[[---------------------------------------------------------------------------
Find a player based on given information
---------------------------------------------------------------------------]]
function DarkRP.findPlayer(info)
    return wlib.player.find(info)
end

--[[---------------------------------------------------------------------------
Find multiple players based on a string criterium
Taken from FAdmin]]
---------------------------------------------------------------------------*/
function DarkRP.findPlayers(info)
    local players = wlib.player.findAll(info)
    return players[1] and {players[1]} or nil
end

function meta:getEyeSightHitEntity(searchDistance, hitDistance, filter)
    searchDistance = searchDistance or 100
    hitDistance = (hitDistance or 15) * (hitDistance or 15)

    filter = filter or function(p) return p:IsPlayer() and p ~= self end

    self:LagCompensation(true)

    local shootPos = self:GetShootPos()
    local entities = ents.FindInSphere(shootPos, searchDistance)
    local aimvec = self:GetAimVector()

    local smallestDistance = math.huge
    local foundEnt

    for k, ent in pairs(entities) do
        if not IsValid(ent) or filter(ent) == false then continue end

        local center = ent:GetPos()

        -- project the center vector on the aim vector
        local projected = shootPos + (center - shootPos):Dot(aimvec) * aimvec

        if aimvec:Dot((projected - shootPos):GetNormalized()) < 0 then continue end

        -- the point on the model that has the smallest distance to your line of sight
        local nearestPoint = ent:NearestPoint(projected)
        local distance = nearestPoint:DistToSqr(projected)

        if distance < smallestDistance then
            local trace = {
                start = self:GetShootPos(),
                endpos = nearestPoint,
                filter = {self, ent}
            }
            local traceLine = util.TraceLine(trace)
            if traceLine.Hit then continue end

            smallestDistance = distance
            foundEnt = ent
        end
    end

    self:LagCompensation(false)

    if smallestDistance < hitDistance then
        return foundEnt, math.sqrt(smallestDistance)
    end

    return nil
end

--[[---------------------------------------------------------------------------
Print the currently available vehicles
---------------------------------------------------------------------------]]
local function GetAvailableVehicles(ply)
    if SERVER and IsValid(ply) and not ply:IsAdmin() then return end
    local print = SERVER and ServerLog or Msg

    print(DarkRP.getPhrase("rp_getvehicles") .. "\n")
    for k,v in pairs(DarkRP.getAvailableVehicles()) do
        print("\"" .. k .. "\"" .. "\n")
    end
end
if SERVER then
    concommand.Add("rp_getvehicles_sv", GetAvailableVehicles)
else
    concommand.Add("rp_getvehicles", GetAvailableVehicles)
end

--[[---------------------------------------------------------------------------
Whether a player has a DarkRP privilege
---------------------------------------------------------------------------]]
function meta:hasDarkRPPrivilege(priv)
    if FAdmin then
        return FAdmin.Access.PlayerHasPrivilege(self, priv)
    end
    return self:IsAdmin()
end

--[[---------------------------------------------------------------------------
Convenience function to return the players sorted by name
---------------------------------------------------------------------------]]
function DarkRP.nickSortedPlayers()
    local plys = player.GetAll()
    table.sort(plys, function(a,b) return a:Nick() < b:Nick() end)
    return plys
end

--[[---------------------------------------------------------------------------
Convert a string to a table of arguments
---------------------------------------------------------------------------]]
local bitlshift, stringgmatch, stringsub, tableinsert = bit.lshift, string.gmatch, string.sub, table.insert
function DarkRP.explodeArg(arg)
    local args = {}

    local from, to, diff = 1, 0, 0
    local inQuotes, wasQuotes = false, false

    for c in stringgmatch(arg, '.') do
        to = to + 1

        if c == '"' then
            inQuotes = not inQuotes
            wasQuotes = true

            continue
        end

        if c == ' ' and not inQuotes then
            diff = wasQuotes and 1 or 0
            wasQuotes = false
            tableinsert(args, stringsub(arg, from + diff, to - 1 - diff))
            from = to + 1
        end
    end
    diff = wasQuotes and 1 or 0

    if from ~= to + 1 then tableinsert(args, stringsub(arg, from + diff, to + 1 - bitlshift(diff, 1))) end

    return args
end

--gamemodes/darkrp/gamemode/modules/base/sh_playerclass.lua:
local PLAYER_CLASS = {}

if ( CLIENT ) then

	CreateConVar( "cl_playercolor", "0.24 0.34 0.41", { FCVAR_ARCHIVE, FCVAR_USERINFO, FCVAR_DONTRECORD }, "The value is a Vector - so between 0-1 - not between 0-255" )
	CreateConVar( "cl_weaponcolor", "0.30 1.80 2.10", { FCVAR_ARCHIVE, FCVAR_USERINFO, FCVAR_DONTRECORD }, "The value is a Vector - so between 0-1 - not between 0-255" )
	CreateConVar( "cl_playerskin", "0", { FCVAR_ARCHIVE, FCVAR_USERINFO, FCVAR_DONTRECORD }, "The skin to use, if the model has any" )
	CreateConVar( "cl_playerbodygroups", "0", { FCVAR_ARCHIVE, FCVAR_USERINFO, FCVAR_DONTRECORD }, "The bodygroups to use, if the model has any" )

end


PLAYER_CLASS.TauntCam = TauntCamera()

-- Value of -1 = set to config value, if a corresponding setting existsS
PLAYER_CLASS.DisplayName = "DarkRP Base Player Class"
PLAYER_CLASS.WalkSpeed = -1
PLAYER_CLASS.RunSpeed = -1
PLAYER_CLASS.DuckSpeed = 0.3
PLAYER_CLASS.UnDuckSpeed = 0.3
PLAYER_CLASS.TeammateNoCollide = false
PLAYER_CLASS.StartHealth = -1

function PLAYER_CLASS:SetModel()

	local skin = self.Player:GetInfoNum( "cl_playerskin", 0 )
	self.Player:SetSkin( skin )

end

function PLAYER_CLASS:Spawn()
	
	local col = self.Player:GetInfo('cl_playercolor')
	self.Player:SetPlayerColor(Vector(col))

	local col = self.Player:GetInfo('cl_weaponcolor')
	self.Player:SetWeaponColor(Vector(col))

end

function PLAYER_CLASS:ShouldDrawLocal()

	if ( self.TauntCam:ShouldDrawLocalPlayer( self.Player, self.Player:IsPlayingTaunt() ) ) then return true end

end

--
-- Allow player class to create move
--
function PLAYER_CLASS:CreateMove( cmd )

	if ( self.TauntCam:CreateMove( cmd, self.Player, self.Player:IsPlayingTaunt() ) ) then return true end

end

--
-- Allow changing the player's view
--
function PLAYER_CLASS:CalcView( view )

	if ( self.TauntCam:CalcView( view, self.Player, self.Player:IsPlayingTaunt() ) ) then return true end

	-- Your stuff here

end

function PLAYER_CLASS:GetHandsModel()

	local name = player_manager.TranslateToPlayerModelName(self.Player:GetModel())
	return player_manager.TranslatePlayerHands(name)

end

player_manager.RegisterClass("player_darkrp", PLAYER_CLASS, "player_default")

--gamemodes/darkrp/gamemode/modules/base/cl_drawfunctions.lua:
--DEFINE_BASECLASS("gamemode_base")

-- concatenate a space to avoid the text being parsed as valve string
local function safeText(text)
    return string.match(text, "^#([a-zA-Z_]+)$") and text .. " " or text
end

DarkRP.deLocalise = safeText

function draw.DrawNonParsedText(text, font, x, y, color, xAlign)
    return draw.DrawText(safeText(text), font, x, y, color, xAlign)
end

function draw.DrawNonParsedSimpleText(text, font, x, y, color, xAlign, yAlign)
    return draw.SimpleText(safeText(text), font, x, y, color, xAlign, yAlign)
end

function surface.DrawNonParsedText(text)
    return surface.DrawText(safeText(text))
end

function chat.AddNonParsedText(...)
    local tbl = {...}
    for i = 2, #tbl, 2 do
        tbl[i] = safeText(tbl[i])
    end
    return chat.AddText(unpack(tbl))
end

local noDraw = {
    ["CHudHealth"] = true,
    ["CHudBattery"] = true,
    ["CHudSuitPower"] = true,
    ["CHUDQuickInfo"] = true,
    ['CHudAmmo']    = true,
    ['CHudChat']    = true,
    ['CHudSecondaryAmmo'] = true,
    ['CHudWeaponSelection'] = true,
}

function GM:HUDShouldDraw(name)
    if noDraw[name] then return false end
    return true
end

function GM:HUDDrawTargetID()
    return false
end

function GM:DrawDeathNotice( x, y )
    return false
end
--gamemodes/darkrp/gamemode/config/jobrelated.lua:
--[[--------------------------------------------------------
    disable_falldamage
    respawnTime
    modelScale
    viewScale
--------------------------------------------------------]]
local GAMEMODE = GAMEMODE or GM

--[[--------------------------------------------------------
    Мирные
--------------------------------------------------------]]

TEAM_CITIZEN = DarkRP.createJob("Гражданин", {
    color = Color(20, 150, 20, 255),
    model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    description = [[Гражданин является основным слоем общества, чуть ли не бродягой. У данной профессии нет особой роли в жизни города.]],
    command = "citizen",
    max = 0,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_CITIZENKID = DarkRP.createJob("Ребенок", {
    color = Color(0, 131, 113, 255),
    model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    description = [[Маленький гражданин.]],
    command = "citizenkid",
    weapons = {"weapon_vape_medicinal", "weapon_bugbait"},
    max = 0,
    modelScale = 0.7,
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {},
})

TEAM_CHOCMAKER = DarkRP.createJob("Кондитер", {
    color = Color(122, 122, 71, 255),
    model = {
        "models/player/kleiner.mdl"
    },
    description = [[Создавай шоколад и продавай скупщику. Если ты умрешь, ты потеряешь весь собранный шоколад!]],
    weapons = {},
    command = "chocmaker",
    max = 2,
    salary = 350,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_MINERS = DarkRP.createJob("БитМайнер", {
    color = Color(0, 255, 205, 255),
    model = {"models/player/group01/male_02.mdl"},
    description = [[БитМайнер - вы хорошо разбираетесь в серверах. Зарабатывайте биткоины, обменивайте их на реальную валюту.]],
    command = "miners",
    weapons = {"bit_usb"},
    max = 8,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_SAMOGON = DarkRP.createJob("Самогонщик", {
    color = Color(29, 105, 56, 255),
    model = {"models/player/group02/male_06.mdl"},
    description = [[Изготавливай самогон и продавай его скупщику]],
    command = "samogon",
    max = 2,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_SECKTA = DarkRP.createJob("Священник", {
    color = Color(111, 54, 5, 255),
    model = {
        "models/player/monk.mdl"
    },
    description = [[Священник - представитель духовенства, одной из ступеней христианской церковной иерархии]],
    command = "adept",
    weapons = {"weapon_svechenik"},
    max = 4,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {"melee"},
})

TEAM_BARMEN = DarkRP.createJob("Бармен", { 
    color = Color(106, 144, 148, 255), 
    model = {"models/player/group01/male_04.mdl"}, 
    description = [[Бармен. Откройте бар, продавайте пиво,сигары и многое другое.]], 
    command = "bar", 
    max = 6, 
    salary = 500, 
    admin = 0, 
    vote = false, 
    hasLicense = false, 
    candemote = false, 
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_PARKOUR = DarkRP.createJob("Паркурист", { 
    color = Color(0, 255, 255, 255), 
    model = {"models/player/p2_chell.mdl"}, 
    description = [[Паркурист. Вы с самого детсва занимались побегушками во дворе и по сей день вы продолжаете этим заниматся.]], 
    weapons = {"climb_swep2", "realistic_hook"}, 
    command = "parkour", 
    max = 6, 
    PlayerLoadout = function(ply)
        ply:SetBaseRunSpeed(300) -- скорость бега
    end,
    salary = 500, 
    admin = 0, 
    vote = false, 
    hasLicense = false, 
    candemote = false, 
    category = "Мирные", 
    disable_falldamage = true,
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_SHAZAM = DarkRP.createJob("Человек Паук", {
    color = Color(255, 0, 0, 255),
    model = {"models/sm2/spider-man.mdl"},
    description = [[Спасайте город от злодеев!]],
    weapons = {"spidermans_swep", "weapon_spiderfists", "weapon_cuff_police"},
    command = "shazam",
    max = 1,
    salary = 0,
    PlayerLoadout = function(ply)
        ply:SetHealth(200) -- ХП
        ply:SetMaxHealth(200)
        ply:SetBaseRunSpeed(430) -- скорость бега
        ply:SetBaseJumpPower(400) -- Прыжок
        ply:StripWeapon( "weapon_fists" )
    end,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    customCheck = function(ply)
        if SERVER and not ply:IsVIP() then return false end
        return #team.GetPlayers(TEAM_HOMELANDER) < 1 and ply:Team() ~= TEAM_HOMELANDER
    end,
    CustomCheckFailMsg = "Достигнут лимит героев или нет привилегии VIP",
    disable_falldamage = true,
    allowedWeapons = {},
    noFear = true,
    defaultModel = true,
})

TEAM_HOMELANDER = DarkRP.createJob("Хоумлендер", {
    color = Color(255, 0, 0, 255),
    model = {"models/theboys/homelander.mdl"},
    description = [[Спасайте город от злодеев!]],
    weapons = {"weapon_spiderfists", "weapon_cuff_police"},
    command = "homelander",
    max = 1,
    salary = 0,
    PlayerLoadout = function(ply)
        ply:SetHealth(200) -- ХП
        ply:SetMaxHealth(200)
        ply:SetBaseRunSpeed(430) -- скорость бега
        ply:SetBaseJumpPower(400) -- Прыжок
        ply:StripWeapon( "weapon_fists" )
    end,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    customCheck = function(ply)
        if SERVER and not ply:IsVIP() then return false end
        return #team.GetPlayers(TEAM_SHAZAM) < 1 and ply:Team() ~= TEAM_SHAZAM
    end,
    CustomCheckFailMsg = "Достигнут лимит героев или нет привилегии VIP",
    disable_falldamage = true,
    allowedWeapons = {},
    noFear = true,
    defaultModel = true,
})

TEAM_BANK = DarkRP.createJob("Банкир", {
    color = Color(0, 105, 67, 255),
    model = {
        "models/player/hostage/hostage_02.mdl",
        "models/player/hostage/hostage_03.mdl",
    },
    description = [[Вы банкир. Может держать легально принтеры и требовать за хранение процент]],
    command = "BANK",
    max = 4,
    salary = 800,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {'melee', 'pistols', 'laserjetpack'},
})

TEAM_SECYRITY = DarkRP.createJob("Охранник", {
    color = Color(0, 230, 255, 255),
    model = {"models/player/odessa.mdl"},
    description = [[Охранник. Вы простой гражданин, который желает устроится на какое-нибудь предприятие охранником.]],
    weapons = {"stunstick", "weaponchecker"},
    command = "oxrana",
    max = 4,
    salary = 600,
    admin = 0,
    vote = false,
    hasLicense = false,
    allowedWeapons = {"melee", "pistols", "laserjetpack", "smg", "shotguns"},
    candemote = false,
    category = "Мирные",
})

TEAM_SECYRITYVIP = DarkRP.createJob("Старый Охранник", {
    color = Color(0, 230, 255, 255),
    model = {"models/player/odessa.mdl"},
    description = [[Охранник. Вы простой гражданин, который желает устроится на какое-нибудь предприятие охранником.]],
    weapons = {"stunstick", "weapon_cuff_police", "weaponchecker"},
    command = "oxranavip",
    max = 4,
    salary = 750,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    allowedWeapons = {"melee", "pistols", "laserjetpack", "smg", "shotguns"},
})

TEAM_GUN = DarkRP.createJob("Продавец оружия", {
    color = Color(255, 140, 0, 255),
    model = "models/player/group01/male_08.mdl",
    description = [[Обустройте магазин и занимайтесь продажей оружия, но для начала приобретите лицензию!]],
    command = "gundealer",
    max = 3,
    salary = 650,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Мирные",
})

TEAM_VRACH = DarkRP.createJob("Доктор", {
    color = Color(47, 79, 79, 255),
    model = {
        "models/player/group03m/male_01.mdl",
        "models/player/group03m/male_02.mdl",
        "models/player/group03m/male_03.mdl",
        "models/player/group03m/male_04.mdl",
        "models/player/group03m/male_06.mdl",
        "models/player/group03m/male_08.mdl",
        "models/player/group03m/female_02.mdl",
        "models/player/group03m/female_03.mdl"},
    description = [[Доктор. Его задача лечить больных. Он может делать это платно или же бесплатно.]],
    weapons = {"med_kit"},
    command = "vrach",
    max = 6,
    salary = 600,
    admin = 0,
    vote = false,
    hasLicense = false,
    medic = true,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_MEDIC = DarkRP.createJob("Нарколог", {
    color = Color(47, 79, 79, 255),
    model = "models/player/magnusson.mdl",
    description = [[Вы доктор который лечит людей от различных зависимостей. Вы можете незаконно заниматся продажей вредных веществ.]],
    weapons = {"med_kit"},
    command = "medic",
    max = 6,
    salary = 600,
    admin = 0,
    vote = false,
    hasLicense = false,
    medic = true,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_VAC = DarkRP.createJob("Работник Valve", {
    color = Color(205, 255, 0, 255),
    model = "models/player/gman_high.mdl",
    description = [[Выдай VAC какому-нибудь чуваку и скорее свали от него, пока он тебя не отпи....]],
    weapons = {"vacban"},
    command = "vacjob",
    max = 2,
    salary = 700,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    allowedWeapons = {"melee", "pistols", "laserjetpack", "smgs"},
})

--[[--------------------------------------------------------
    Нейтральные
--------------------------------------------------------]]

TEAM_SKATE = DarkRP.createJob("Скейтер", {
    color = Color(0, 59, 92, 255),
    model = {
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    description = [[Скейтер - человек который занимается одним из видов спорта Скейтбординг]],
    command = "scater",
    max = 4,
    weapons = {"weapon_vape"},
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Криминал",
    allowedWeapons = {"melee", "pistols", "laserjetpack", "smgs"},
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    canRobBank = true,
})

TEAM_HACKER = DarkRP.createJob("Хакер", {
    color = Color(205, 205, 205, 255),
    model = {"models/player/leet.mdl"},
    description = [[Хакер. Вы профессиональный взломщик электроники. Благодаря вашему телефону вас будет трудно вычислить!]],
    weapons = {"lockpick", "keypad_cracker", "unarrest_stick", "krede_wd_phone", "moneychecker"},
    command = "hacker",
    max = 3,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = true,
    category = "Нейтральные",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    allowedWeapons = {"melee", "pistols", "laserjetpack", "smgs"},
    canRobBank = true,
})

--[[--------------------------------------------------------
    ЧВК
--------------------------------------------------------]]

local pmcRadio = {"pmc", "police-pmc"}

TEAM_ARMIAS = DarkRP.createJob("Рядовой ЧВК", {
    color = Color(19, 111, 5, 255),
    model = {
        "models/player/dod_american.mdl"
    },
    description = [[Рядовой - военнослужащий. \n Подчиняется приказам генерала.]],
    command = "adrme",
    max = 0,
    weapons = {"ptp_cs_ak47", "ptp_cs_deagle", "csgo_bayonet", "weapon_army"},
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
    end,
    salary = 650,
    admin = 0,
    vote = false,
    hasLicense = true,
    candemote = false,
    category = "Нейтральные",
    --customCheck = function(ply) return CLIENT or not IsValid(ply) end,
    CustomCheckFailMsg = "Набрать в ЧВК может только Генерал",
    hasRadio = true,
    radioChannels = pmcRadio,
    banGroup = 'pmc',
    fearCount = 3,
})

TEAM_SHPION = DarkRP.createJob("Диверсант ЧВК", {
    color = Color(19, 111, 5, 255),
    model = {
        "models/player/dod_american.mdl"
    },
    description = [[Диверсант - военнослужащий. \n Подчиняется приказам генерала.]],
    command = "diversantchvk",
    max = 2,
    weapons = {"ptp_cs_tmp", "ptp_cs_usp", "csgo_bayonet", "weapon_army", "ultimate_disguise_kit", "lockpick", "keypad_cracker"},
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
    end,
    salary = 650,
    admin = 0,
    vote = false,
    hasLicense = true,
    candemote = false,
    category = "Нейтральные",
    --customCheck = function(ply) return CLIENT or not IsValid(ply) end,
    CustomCheckFailMsg = "Набрать в ЧВК может только Генерал",
    hasRadio = true,
    radioChannels = pmcRadio,
    banGroup = 'pmc',
    fearCount = 3,
})

TEAM_ARMIARIOT = DarkRP.createJob("Штурмовик ЧВК", {
    color = Color(19, 111, 5, 255),
    model = {
        "models/player/dod_american.mdl"
    },
    description = [[Штурмовик ЧВК - военнослужащий. \n Подчиняется приказам генерала.]],
    command = "adrmeriot",
    max = 0,
    weapons = {"ptp_cs_p90", "ptp_cs_deagle", "csgo_bayonet", "swat_shield", "weapon_army"},
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
    end,
    salary = 650,
    admin = 0,
    vote = false,
    hasLicense = true,
    candemote = false,
    category = "Нейтральные",
    --customCheck = function(ply) return CLIENT or not IsValid(ply) end,
    CustomCheckFailMsg = "Набрать в ЧВК может только Генерал",
    hasRadio = true,
    radioChannels = pmcRadio,
    banGroup = 'pmc',
    fearCount = 3,
})

TEAM_ARMIASMED = DarkRP.createJob("Медик ЧВК", {
    color = Color(19, 111, 5, 255),
    model = {
        "models/player/dod_american.mdl"
    },
    description = [[Восстанавливайте больных бойцов. Лечите ранения.]],
    command = "adrmedic",
    max = 0,
    weapons = {"ptp_cs_autoshotgun", "ptp_cs_deagle", "csgo_bayonet", "weapon_medkit", "weapon_army"},
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
    end,
    salary = 650,
    admin = 0,
    vote = false,
    hasLicense = true,
    candemote = false,
    medic = true,
    category = "Нейтральные",
    --customCheck = function(ply) return CLIENT or not IsValid(ply) end,
    CustomCheckFailMsg = "Набрать в ЧВК может только Генерал",
    hasRadio = true,
    radioChannels = pmcRadio,
    banGroup = 'pmc',
    fearCount = 3,
})

TEAM_ARMIA = DarkRP.createJob("Генерал ЧВК", {
    color = Color(19, 111, 5, 255),
    model = {
        "models/player/dod_german.mdl"
    },
    description = [[Генерал - главный военнослужащий. \n Отдаёт приказы рядовым, находится в подчинении у мэра ]],
    command = "adrmeds",
    max = 1,
    weapons = {"wrp_weapon_mosin", "ptp_cs_ak47", "ptp_cs_deagle", "csgo_bayonet", "weapon_army"},
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
    end,
    salary = 700,
    admin = 0,
    vote = false,
    hasLicense = true,
    candemote = false,
    category = "Нейтральные",
    hasRadio = true,
    radioChannels = pmcRadio,
    banGroup = 'pmc',
    fearCount = 3,
})

--[[--------------------------------------------------------
    Полиция
--------------------------------------------------------]]

local policeRadio = {"police", "police-pmc"}

TEAM_DETECTIVE = DarkRP.createJob("Детектив", {
    color = Color(0, 85, 151, 255),
    model = {
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    description = [[Детектив. Расследуйте убийства, вступайте в различные преступные организации, ловите преступников.]],
    command = "detective",
    weapons = {"stungun", "ultimate_disguise_kit", "weaponchecker", "lockpick", "keypad_cracker", "arrest_stick", "unarrest_stick", "weapon_cuff_police", "ptp_cs_357"},
    max = 6,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
    end,
    salary = 600,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Государство",
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_POLICE = DarkRP.createJob("Рядовой Полиции", {
    color = Color(25, 25, 170, 255),
    model = {"models/player/riot.mdl"},
    description = [[Полицейский является защитником каждого, кто живет в городе. Вы можете арестовывать людей, нарушающих законы, участвовать в штурмах, либо патрулировать улицы. \n Хотим напомнить, что вы обязательно должны выполнять поручения шефа полиции. \n Если вы пытаетесь задержать преступника, то, помимо огнестрельного оружия, у вас есть полицейская дубинка, которая является отличным инструментом, приводящим нарушителя в чувство. \n Также, у вас есть ручной таран, который поможет выломать дверь, но не стоит забывать, что для этого нужен ордер на обыск.]],
    weapons = {"arrest_stick", "unarrest_stick", "stunstick", "door_ram", "weaponchecker", "ptp_cs_usp", "weapon_cuff_police"},
    command = "cp",
    max = 6,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(100)
    end,
    salary = 600,
    admin = 0,
    vote = false,
    hasLicense = true,
    ammo = {
        ["pistol"] = 160,
    },
    category = "Государство",
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_CHIEF = DarkRP.createJob("Капитан полиции", {
    color = Color(20, 20, 255, 255),
    model = {"models/player/urban.mdl"},
    description = [[Капитан Полиции - глава всей полиции в городе. \n Отдавайте приказы своим подчинённым и держите город под защитой]],
    weapons = {"arrest_stick", "unarrest_stick", "ptp_cs_deagle", "ptp_cs_m4", "stunstick", "door_ram", "weaponchecker", "weapon_cuff_police"},
    command = "chief",
    max = 1,
    salary = 900,
    admin = 0,
    vote = false,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(100)
    end,
    hasLicense = true,
    chief = true,
    ammo = {
        ["pistol"] = 60,
        ["smg"] = 160,
    },
    category = "Государство",
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_POLICES = DarkRP.createJob("Сержант Полиции", {
    color = Color(25, 25, 170, 255),
    model = {"models/player/swat.mdl"},
    description = [[Сержант Полиции. Очередной ранг в полиции. Командуйте рядовыми.]],
    weapons = {"arrest_stick", "unarrest_stick", "ptp_cs_p228", "ptp_cs_famas", "stunstick", "door_ram", "weaponchecker", "weapon_cuff_police"},
    command = "cp2",
    max = 5,
    salary = 800,
    admin = 0,
    vote = false,
    hasLicense = true,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(100)
    end,
    ammo = {
        ["pistol"] = 160,
        ["smg"] = 160,
    },
    category = "Государство",
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_SNIPER = DarkRP.createJob("Снайпер Полиции", {
    color = Color(25, 25, 170, 255),
    model = {"models/player/swat.mdl"},
    description = [[Вы зоркий боец. Именно вы должны наблюдать за городом с высоты птичьего полета!]],
    weapons = {"arrest_stick", "realistic_hook", "unarrest_stick", "ptp_cs_p228", "ptp_cs_g3sg1", "stunstick", "door_ram", "weaponchecker", "weapon_cuff_police", "sniper_stungun"},
    command = "sniper2",
    max = 4,
    salary = 750,
    admin = 0,
    vote = false,
    hasLicense = true,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(100)
    end,
    chief = true,
    ammo = {
        ["pistol"] = 160,
        ["smg"] = 160,
    },
    category = "Государство",
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_MOLOT = DarkRP.createJob("Отряд Молот", {
    color = Color(25, 25, 170, 255),
    model = {"models/player/combine_soldier_prisonguard.mdl"},
    description = [[Отряд Молот - особый отряд для проведения спец.операций.]],
    weapons = {"realistic_hook", "arrest_stick", "unarrest_stick", "ptp_cs_fiveseven", "ptp_cs_aug", "stunstick", "door_ram", "weaponchecker", "weapon_cuff_police", "swat_shield"},
    command = "molot",
    max = 4,
    salary = 750,
    admin = 0,
    vote = false,
    hasLicense = true,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(100)
    end,
    ammo = {
        ["pistol"] = 160,
        ["smg"] = 160,
    },
    category = "Государство",
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_TANKIST = DarkRP.createJob("Джаггернаут", {
    color = Color(25, 25, 170, 255),
    model = {"models/player/combine_super_soldier.mdl"},
    description = [[Вы особый боец. На вашем теле мощная броня. Бадитам это не понравится!]],
    weapons = {"arrest_stick", "unarrest_stick", "stunstick", "door_ram", "weaponchecker", "ptp_cs_para", "weapon_cuff_police"},
    command = "tank",
    max = 1,
    salary = 800,
    admin = 0,
    vote = false,
    hasLicense = true,
    ammo = {
        ["smg"] = 560,
    },
    PlayerLoadout = function(ply)
        ply:SetHealth(200)
        ply:SetMaxHealth(200)
        ply:SetArmor(500)
        ply:SetMaxArmor(500)
    end,
    modelScale = 1.2,
    category = "Государство",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_POLICEMED = DarkRP.createJob("Полицейский Медик", {
    color = Color(25, 25, 170, 255),
    model = {"models/player/gasmask.mdl"},
    description = [[Полицейский медик занимается лечением своих товарищей.]],
    weapons = {"arrest_stick", "unarrest_stick", "ptp_cs_usp", "ptp_cs_pumpshotgun", "stunstick", "door_ram", "weaponchecker", "med_kit", "weapon_cuff_police"},
    command = "cp3",
    max = 6,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(100)
    end,
    salary = 700,
    admin = 0,
    vote = false,
    hasLicense = true,
    ammo = {
        ["pistol"] = 160,
        ["buckshot"] = 100,
    },
    category = "Государство",
    medic = true,
    hasRadio = true,
    radioChannels = policeRadio,
    banGroup = 'police',
    fearCount = 3,
})

TEAM_SUPERPOLICE = DarkRP.createJob("Киберсолдат", {
    color = Color(25, 40, 210, 255),
    model = {"models/player/police.mdl"},
    description = [[Киберсолдат с особым оружием, способен быстро перемещаться по абсолютно любой локации за счет лазергана и скорости бега.]],
    weapons = {"arrest_stick", "unarrest_stick", "laserjetpack", "ptp_cs_tmp", "stunstick", "door_ram", "weaponchecker", "weapon_cuff_police"},
    command = "cpcyber",
    max = 1,
    PlayerLoadout = function(ply)
        ply:SetHealth(ply:GetMaxHealth())
        ply:SetArmor(100)
        ply:SetBaseRunSpeed(290)
    end,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = true,
    category = "Государство",
    hasRadio = true,
    radioChannels = policeRadio,
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    banGroup = 'police',
    fearCount = 3,
})

TEAM_MAYOR = DarkRP.createJob("Мэр", {
    color = Color(150, 20, 20, 255),
    model = "models/player/breen.mdl",
    description = [[Вы глава города. Устанавливайте законы и контролируйте порядок во всех частях города.]],
    weapons = {"stungun", "stunstick", "arrest_stick", "unarrest_stick", "weaponchecker", "weapon_cuff_police"},
    command = "mayor",
    max = 1,
    salary = 1125,
    admin = 0,
    vote = true,
    hasLicense = false,
    mayor = true,
    category = "Государство",
    PlayerDeath = function(ply, wep, killer)
        if dEvents and dEvents.getEventer(ply) then return end
        if ply:GetNetVar('duelSystem.OnDuel') then return end
        
        if ply.LastJob then
            local time = CurTime() - ply.LastJob
            if time < 10*60 then
                local tbl = string.FormattedTime(10*60 - time)
                DarkRP.notify(ply, 0, 10, ('У тебя осталось %s мин %s с неприкосновенности'):format(tbl.m, tbl.s))
                
                return
            end
        end
        
        if ply:Team() == TEAM_MAYOR then
            ply:teamBan(ply:Team(), 600)
            ply:changeTeam(GAMEMODE.DefaultTeam, true)
            DarkRP.notifyAll(1, 4, IsValid(killer) and killer ~= ply and 'Мэр был убит' or 'Мэр совершил самоубийство')
        end
    end,
    OnPlayerChangedTeam = function(ply, old, new)
        local pos = GAMEMODE.Config.CityHallPos
        if not pos then return end
    
        local builds = {}
    
        for _, ent in ipairs(ents.FindInBox(pos[1], pos[2])) do
            local owner = ent:CPPIGetOwner()
            if not IsValid(owner) or owner == ply then continue end
    
            builds[owner] = builds[owner] or {}
            table.insert(builds[owner], ent)
        end

        if table.Count(builds) == 0 then return end
    
        local fields = {
            {
                type = 'text',
                text = 'Выбери ниже игроков, чьи пропы ты хочешь удалить из мэрии',
            }
        }
        for p, props in pairs(builds) do
            table.insert(fields, {
                type = 'bool',
                name = ('%s(%s) - %s'):format(p:Name(), team.GetName(p:Team()), wlib.string.formatPlural({'проп', 'пропа', 'пропов'}, #props)),
                player = p,
            })
        end
    
        wlib.requests.send(ply, fields, function(res)
            if ply:Team() ~= new then return end
    
            for k, ans in ipairs(res) do
                if not ans then continue end
    
                local p = fields[k+1].player
                for _, ent in ipairs(builds[p] or {}) do
                    if IsValid(ent) then ent:Remove() end
                end
                DarkRP.notify(p, 0, 5, ply:Name()..' удалил твои пропы в мэрии')
            end
    
            DarkRP.notify(ply, 0, 5, 'Ты успешно удалил пропы выбранных игроков из мэрии')
        end)
    end,
    noSwitchJob = true,
    allowedWeapons = {"melee", "pistols", "laserjetpack", "wrp_weapon_mosin"},
    hasRadio = true,
    radioChannels = policeRadio,
})

TEAM_NALOG = DarkRP.createJob("Налоговый инспектор", {
    color = Color(38, 71, 87, 255),
    model = {"models/player/hostage/hostage_01.mdl", "models/player/hostage/hostage_04.mdl"},
    description = [[Собирайте налоги с жителей города]],
    weapons = {"stungun", "stunstick", "weapon_cuff_police", "weapon_nalog"},
    command = "nalog",
    max = 2,
    salary = 666,
    admin = 0,
    vote = false,
    hasLicense = true,
    category = "Государство",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
    hasRadio = true,
    radioChannels = {"police"},
    banGroup = 'police',
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_TECHNICIAN = DarkRP.createJob("Городской рабочий", {
    color = Color(38, 71, 87, 255),
    model = "models/player/odessa.mdl",
    description = [[Устраняй неисправности в городе]],
    weapons = {},
    command = "technician",
    max = 2,
    salary = 300,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

--[[--------------------------------------------------------
    Криминал
--------------------------------------------------------]]

TEAM_GANG = DarkRP.createJob("Мафия", {
    color = Color(75, 75, 75, 255),
    model = {
        "models/player/Group03/Female_01.mdl",
        "models/player/Group03/Female_02.mdl",
        "models/player/Group03/Female_03.mdl",
        "models/player/Group03/Female_04.mdl",
        "models/player/Group03/Female_06.mdl",
        "models/player/group03/male_01.mdl",
        "models/player/Group03/Male_02.mdl",
        "models/player/Group03/male_03.mdl",
        "models/player/Group03/Male_04.mdl",
        "models/player/Group03/Male_05.mdl",
        "models/player/Group03/Male_06.mdl",
        "models/player/Group03/Male_07.mdl",
        "models/player/Group03/Male_08.mdl",
        "models/player/Group03/Male_09.mdl"},
    description = [[Мафия - криминальная профессия. Совершайте грабежи в переулках, торгуйте наркотиками, печатайте деньги на денежных принтерах.]],
    weapons = {"unarrest_stick", "moneychecker", "weapon_cuff_rope", "sent_tablet"},
    command = "gangster",
    max = 12,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Криминал",
    canRobBank = true,
})

TEAM_CANNON = DarkRP.createJob("Группа Отстрел", {
    color = Color(75, 75, 75, 255),
    model = {
        "models/player/Group03/Female_01.mdl",
        "models/player/Group03/Female_02.mdl",
        "models/player/Group03/Female_03.mdl",
        "models/player/Group03/Female_04.mdl",
        "models/player/Group03/Female_06.mdl",
        "models/player/group03/male_01.mdl",
        "models/player/Group03/Male_02.mdl",
        "models/player/Group03/male_03.mdl",
        "models/player/Group03/Male_04.mdl",
        "models/player/Group03/Male_05.mdl",
        "models/player/Group03/Male_06.mdl",
        "models/player/Group03/Male_07.mdl",
        "models/player/Group03/Male_08.mdl",
        "models/player/Group03/Male_09.mdl"},
    description = [[Группа Отстрел - Расходный материал Мафии, чаще всего подвергаются риску или используются для выполнения опасных задач.]],
    weapons = {"unarrest_stick", "moneychecker", "weapon_cuff_rope", "fridge_shield_unbreakable", "weapon_hl2hook", "sent_tablet"},
    command = "gangstercannon",
    max = 4,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Криминал",
    canRobBank = true,
})

TEAM_BLAIZER = DarkRP.createJob("Блейзер", {
    color = Color(75, 75, 75, 255),
    model = {
        "models/player/Group03/Female_01.mdl",
        "models/player/Group03/Female_02.mdl",
        "models/player/Group03/Female_03.mdl",
        "models/player/Group03/Female_04.mdl",
        "models/player/Group03/Female_06.mdl",
        "models/player/group03/male_01.mdl",
        "models/player/Group03/Male_02.mdl",
        "models/player/Group03/male_03.mdl",
        "models/player/Group03/Male_04.mdl",
        "models/player/Group03/Male_05.mdl",
        "models/player/Group03/Male_06.mdl",
        "models/player/Group03/Male_07.mdl",
        "models/player/Group03/Male_08.mdl",
        "models/player/Group03/Male_09.mdl"},
    description = [[Блейзер - Боевая еденица мафии с молниеносной скоростью, мастер скрытных операций, ловко проникающий в нужные места при помощи реактивного ранца.]],
    weapons = {"unarrest_stick", "moneychecker", "weapon_cuff_rope", "sent_tablet"},
    command = "gangsterblaizer",
    max = 1,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    disable_falldamage = true,
    controls = {
        {key = KEY_LSHIFT, desc = "Ранец (в прыжке)"}
    },
    canRobBank = true,
})

TEAM_BANDITVIP = DarkRP.createJob("Бандит", {
    color = Color(75, 75, 75, 255),
    model = {
        "models/player/Group03/Female_01.mdl",
        "models/player/Group03/Female_02.mdl",
        "models/player/Group03/Female_03.mdl",
        "models/player/Group03/Female_04.mdl",
        "models/player/Group03/Female_06.mdl",
        "models/player/group03/male_01.mdl",
        "models/player/Group03/Male_02.mdl",
        "models/player/Group03/male_03.mdl",
        "models/player/Group03/Male_04.mdl",
        "models/player/Group03/Male_05.mdl",
        "models/player/Group03/Male_06.mdl",
        "models/player/Group03/Male_07.mdl",
        "models/player/Group03/Male_08.mdl",
        "models/player/Group03/Male_09.mdl"},
    description = [[Бандит - универсальная криминальная профессия. Умеет взламывать двери и обворовывать людей.]],
    weapons = {"unarrest_stick", "moneychecker", "lockpick", "pickpocket", "csgo_bayonet", "weapon_cuff_rope", "sent_tablet"},
    command = "gangstervip",
    max = 4,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    PlayerLoadout = function(ply)
        ply:SetArmor(115)
        ply:SetMaxArmor(115)
    end,
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    hasRadio = true,
    canRobBank = true,
})

TEAM_GANGMED = DarkRP.createJob("Лекарь Мафии", {
    color = Color(31, 31, 31, 255),
    model = {
        "models/player/Group03/Female_01.mdl",
        "models/player/Group03/Female_02.mdl",
        "models/player/Group03/Female_03.mdl",
        "models/player/Group03/Female_04.mdl",
        "models/player/Group03/Female_06.mdl",},
    description = [[Доктор Мафии - ваша задача лечить участников вашей мафии]],
    weapons = {"unarrest_stick", "moneychecker", "weapon_medkit", "weapon_cuff_rope", "sent_tablet"},
    command = "gangstermedic",
    max = 3,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    medic = true,
    category = "Криминал",
    canRobBank = true,
})

TEAM_BANTANK = DarkRP.createJob("Громила", {
    color = Color(75, 75, 75, 255),
    model = {"models/player/phoenix.mdl",}, -- models/player/phoenix.mdl
    description = [[Вы не такой как остальные мафиози, это видно по вашему телосложению. Вы намного крепче и выносливее.]],
    weapons = {"unarrest_stick", "moneychecker", "weapon_cuff_rope", "sent_tablet"},
    command = "bantank",
    max = 1,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Криминал",
    PlayerLoadout = function(ply)
        ply:SetHealth(200) -- ХП
        ply:SetMaxHealth(200)
        ply:SetArmor(500) -- Броня
        ply:SetMaxArmor(500)
    end,
    modelScale = 1.2,
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    fearCount = 3,
    canRobBank = true,
})

TEAM_VOR = DarkRP.createJob("Вор", {
    color = Color(75, 75, 75, 255),
    model = {"models/player/arctic.mdl"},
    description = [[Вы вор. У вас есть отмычка с помощью которой вы сможете взламывать дверные замки.]],
    weapons = {"lockpick", "keypad_cracker", "pickpocket"},
    command = "vor",
    max = 6,
    salary = 500,
    PlayerLoadout = function(ply)
        ply:SetHealth(100) -- ХП
    end,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Криминал",
    allowedWeapons = {"melee", "pistols", "laserjetpack", "smgs"},
    canRobBank = true,
})

TEAM_PROVOR = DarkRP.createJob("Профессиональный Вор", {
    color = Color(75, 75, 75, 255),
    model = {"models/player/arctic.mdl"},
    description = [[Чем отличается проф.вор от простого? Профессиональный вор проверен временем и за годы воровства изучил навык паркура.]],
    weapons = {"lockpick", "keypad_cracker", "climb_swep2", "unarrest_stick", "pickpocket"},
    command = "provor",
    max = 6,
    salary = 500,
    PlayerLoadout = function(ply)
        ply:SetHealth(100) -- ХП
    end,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    disable_falldamage = true,
    allowedWeapons = {"melee", "pistols", "laserjetpack", "smgs"},
    canRobBank = true,
})

TEAM_ASSAS = DarkRP.createJob("Ассасин", { 
    color = Color(110, 110, 110, 255), 
    model = {"models/player/altair_ibnlaahad.mdl"}, 
    description = [[Ассасин - убийца. Выполняйте заказы других игроков за плату.]], 
    weapons = {"climb_swep2", "lockpick", "keypad_cracker", "csgo_bayonet", "pickpocket", "weapon_cuff_rope"},
    command = "assasin", 
    max = 3, 
    PlayerLoadout = function(ply)
        ply:SetHealth(100) -- ХП -- скорость бега
        ply:SetBaseRunSpeed(300)
    end,
    salary = 0, 
    admin = 0, 
    vote = false, 
    hasLicense = false, 
    candemote = false, 
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    disable_falldamage = true,
    allowedWeapons = {"melee"},
    fearCount = 3,
})

TEAM_BLACKSS = DarkRP.createJob("Иссохший", {
    color = Color(84, 71, 37, 255),
    model = {"models/player/charple.mdl"},
    description = [[Иссохший. Вы главный враг Человека паука.]],
    weapons = {"weapon_spiderfists", "weapon_cuff_police"},
    command = "blackv",
    max = 1,
    salary = 0,
    PlayerLoadout = function(ply)
        ply:SetHealth(200) -- ХП
        ply:SetMaxHealth(200)
        ply:SetBaseRunSpeed(430) -- скорость бега
        ply:SetBaseJumpPower(750) -- Прыжок
        ply:StripWeapon( "weapon_fists" )
    end,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Криминал",
  --  allowedWeapons = {"allowAll"},
    customCheck = function(ply)
        if SERVER and not ply:IsVIP() then return false end
        return #team.GetPlayers(TEAM_NOBLOOD) < 1 and ply:Team() ~= TEAM_NOBLOOD
    end,
    CustomCheckFailMsg = "Достигнут лимит злодеев или нет привилегии VIP",
    disable_falldamage = true,
    allowedWeapons = {},
    noFear = true,
    defaultModel = true,
})

TEAM_NOBLOOD = DarkRP.createJob("Бескровный", {
    color = Color(84, 71, 37, 255),
    model = {"models/player/soldier_stripped.mdl"},
    description = [[Бескровный. Злодей города.]],
    weapons = {"weapon_hl2katana", "weapon_cuff_police"},
    command = "noblood",
    max = 1,
    salary = 0,
    PlayerLoadout = function(ply)
        ply:SetHealth(150) -- ХП
        ply:SetMaxHealth(150)
        ply:SetBaseRunSpeed(325) -- скорость бега
        ply:SetBaseJumpPower(325) -- Прыжок
    end,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Криминал",
  --  allowedWeapons = {"allowAll"},
    customCheck = function(ply)
        if SERVER and not ply:IsVIP() then return false end
        return #team.GetPlayers(TEAM_BLACKSS) < 1 and ply:Team() ~= TEAM_BLACKSS
    end,
    CustomCheckFailMsg = "Достигнут лимит злодеев или нет привилегии VIP",
    disable_falldamage = true,
    allowedWeapons = {},
    noFear = true,
    defaultModel = true,
})

TEAM_MOB = DarkRP.createJob("Наемный Убийца", { 
    color = Color(0, 31, 25, 255), 
    model = {"models/player/group03/male_08.mdl"}, 
    description = [[Вы проработали на многих работах и не одна вам не подошла. Единственное легкое и простое дело для вас - убийство.]], 
    weapons = {"lockpick", "keypad_cracker"}, 
    command = "mob", 
    max = 6, 
    salary = 500, 
    admin = 0, 
    vote = false, 
    hasLicense = false, 
    candemote = false, 
    category = "Криминал", 
})

TEAM_MOBIK = DarkRP.createJob("Опытный наёмник", { 
    color = Color(0, 31, 25, 255), 
    model = {"models/player/group03/male_08.mdl"}, 
    description = [[Вы проработали на многих работах и не одна вам не подошла. Единственное легкое и простое дело для вас - убийство.]], 
    weapons = {"lockpick", "keypad_cracker", "realistic_hook", "ultimate_disguise_kit", "weapon_cuff_police"}, 
    command = "mobik", 
    max = 3, 
    salary = 500, 
    admin = 0, 
    vote = false, 
    hasLicense = false, 
    candemote = false, 
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
})

TEAM_NASILNIK = DarkRP.createJob("Борец", {
    color = Color(222, 0, 214, 255),
    model = {
        "models/player/Group02/male_08.mdl",
    },
    description = [[Борец насильник, отрабатывайте свои приемы на проходимцах]],
    weapons = {"weapon_rape"},
    command = "nasil",
    max = 2,
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

TEAM_MANUAK = DarkRP.createJob("Маньяк", {
    color = Color(0, 0, 0, 255),
    model = {
        "models/player/Group02/male_02.mdl",
    },
    description = [[Маньяк. Психически ненормальный человек, готов убить любого за сущий пустяк!]],
    weapons = {"csgo_bayonet", "weapon_crowbar", "ultimate_disguise_kit", "rchainsaw", "weapon_cuff_rope"},
    command = "maniak",
    max = 2,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    allowedWeapons = {"melee"},
    fearCount = 3,
})

TEAM_BOMB = DarkRP.createJob("Террорист", {
    color = Color(222, 222, 0, 255),
    model = {"models/player/guerilla.mdl"},
    description = [[Террорист. Вы хорошо разбираетесь в взрывчатке. Используйте этот навык в своих целях.]],
    command = "Terror",
    max = 1,
    weapons = {"weapon_slam"},
    salary = 500,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Криминал",
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    canRobBank = true,
})

TEAM_HOBO = DarkRP.createJob("Бомж", {
    color = Color(80, 45, 0, 255),
    model = "models/player/corpse1.mdl",
    description = [[Вы бомж. Постройте шалаш и попрошайничайте деньги у прохожих]],
    weapons = {"weapon_bugbait"},
    command = "hobo",
    max = 0,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    hobo = true,
    category = "Криминал",
    allowedWeapons = {"melee"},
})

TEAM_AFHOBO = DarkRP.createJob("Авторитетный Бомж", {
    color = Color(80, 45, 0, 255),
    model = "models/player/corpse1.mdl",
    description = [[Авторитетный Бомж. Вы прославились своей профессиональной игрой на гитаре. Все бомжи в городе вас уважают.]],
    weapons = {"weapon_bugbait", "guitar_stalker", "csgo_bayonet"},
    command = "afhobo",
    max = 1,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    hobo = true,
    category = "Криминал",
    allowedWeapons = {"melee"},
})

TEAM_METH = DarkRP.createJob("Варщик мета", {
    color = Color(0, 80, 60, 255),
    model = {
        "models/player/group02/male_06.mdl",
    },
    description = [[Мет моя жизнь, блять!]],
    command = "creatormeth",
    max = 6,
    PlayerLoadout = function(ply)
        ply:SetHealth(100) -- ХП
    end,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Криминал",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})

/*

TEAM_SPACE = DarkRP.createJob("Космонавт", {
    color = Color(56, 41, 99, 255),
    model = {
        "models/player/spacesuit.mdl",
    },
    description = [[С днем космонавтики!]],
    command = "spacemans",
    max = 4,
    PlayerLoadout = function(ply)
        ply:SetHealth(100) -- ХП
    end,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})




TEAM_JESUS = DarkRP.createJob("Иисус Христос", {
    color = Color(56, 41, 99, 255),
    model = {
        "models/player/jesus/jesus.mdl",
    },
    description = [[С пасхой!]],
    command = "jesus",
    max = 1,
    PlayerLoadout = function(ply)
        ply:SetHealth(1000)
        ply:SetMaxHealth(1000)
    end,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Мирные",
    allowedWeapons = {"melee", "pistols", "laserjetpack"},
})
*/
--[[--------------------------------------------------------
    Прочее
--------------------------------------------------------]]

local admins = {
    "WayZer Team",
    "Trusted",
    "admin",
    "moder",
    "+Helper",
    "Helper",
    "Patron",
}

TEAM_ADMIN = DarkRP.createJob("Администратор", {
    color = Color(131, 53, 233, 255),
    model = {"models/player/barney.mdl"},
    description = [[NONRP]],
    weapons = {"arrest_stick", "unarrest_stick", "stunstick", "weapon_keypadchecker", "weaponchecker"},
    command = "admin",
    max = 0,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = true,
    PlayerSpawn = function(ply)
        if table.HasValue(admins, ply:GetDisplayUserGroup()) then
            ply:SetModel("models/wayzer/admin1337.mdl")
        elseif ply:SteamID() == "STEAM_0:0:88099997" then
            ply:SetModel("models/wayzer/admin_boss.mdl")
        end
    end,
    category = "Остальное",
    customCheck = function(ply) return CLIENT or ply:GetUserGroup() == "Patron" or ply:GetUserGroup() == "Helper" or ply:GetUserGroup() == "moder"  or ply:GetUserGroup() == "+Eventer" or ply:GetUserGroup() == "Eventer" or ply:GetUserGroup() == "+Eventer" or ply:GetUserGroup() == "admin" or ply:GetUserGroup() == "superadmin" or ply:GetUserGroup() == "+Helper" or ply:GetUserGroup() == "DAdmin" or ply:GetUserGroup() == "DModerator" or ply:GetUserGroup() == "Curator" or ply:GetUserGroup() == "Sponsor" or ply:GetUserGroup() == "DSAdmin" or ply:GetUserGroup() == "Trusted" or ply:GetUserGroup() == "+Helper" or ply:GetUserGroup() == "WayZer Team" end,
    CustomCheckFailMsg = "Эта работа только для VIP пользователей",
    respawnTime = 0,
    hasRadio = true,
    radioChannels = {"admin"},
    noFear = true,
})

TEAM_BANNED = DarkRP.createJob("Птица", {
    color = Color(0, 0, 0, 255),
    model = {"models/crow.mdl", "models/pigeon.mdl" },
    description = [[You are banned]],
    command = "iambanned",
    max = 0,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    hobo = true,
    category = "Остальное",
    viewScale = 0.2,
    PlayerLoadout = function( ply )
        return true
    end,
    PlayerSpawn = function(ply)
        ply:SetMoveType(MOVETYPE_FLY)
    end,
    customCheck = function(ply)
        return false, "Зачем тебе это?"
    end,
    respawnTime = 0,
    allowedWeapons = {},
    noFear = true,
})

-- Compatibility for when default teams are disabled
TEAM_CITIZEN = TEAM_CITIZEN  or -1
TEAM_POLICE  = TEAM_POLICE   or -1
TEAM_GANG    = TEAM_GANG     or -1
TEAM_MOB     = TEAM_MOB      or -1
TEAM_GUN     = TEAM_GUN      or -1
TEAM_MEDIC   = TEAM_MEDIC    or -1
TEAM_CHIEF   = TEAM_CHIEF    or -1
TEAM_MAYOR   = TEAM_MAYOR    or -1
TEAM_HOBO    = TEAM_HOBO     or -1
TEAM_COOK    = TEAM_COOK     or -1

-- Group chats
DarkRP.createGroupChat(function(ply) return ply:isCP() end)
DarkRP.createGroupChat(TEAM_MOB, TEAM_GANG)
DarkRP.createGroupChat(function(listener, ply) return not ply or ply:Team() == listener:Team() end)

-- Initial team when first spawning
GAMEMODE.DefaultTeam = TEAM_CITIZEN

-- Teams that belong to Civil Protection
GAMEMODE.CivilProtection = {
    [TEAM_POLICE] = true,
    [TEAM_CHIEF] = true,
    [TEAM_MAYOR] = true,
    [TEAM_POLICES] = true,
    [TEAM_MOLOT] = true,
    [TEAM_TANKIST] = true,
    [TEAM_POLICEMED] = true,
    [TEAM_SNIPER] = true,
    [TEAM_DETECTIVE] = true,
    [TEAM_SUPERPOLICE] = true,
    [TEAM_NALOG] = true,
}

-- Hitman team

-- Demote groups
DarkRP.createDemoteGroup("Citizen", {TEAM_AFHOBO, TEAM_HOBO, TEAM_MAYOR, TEAM_POLICEMED, TEAM_TANKIST, TEAM_MOLOT, TEAM_POLICES, TEAM_CHIEF, TEAM_MEDIC, TEAM_VRACH, TEAM_GUN, TEAM_PROVOR, TEAM_VOR, TEAM_BANTANK, TEAM_GANG, TEAM_POLICE, TEAM_SECYRITY, TEAM_BOMB, TEAM_BANK, TEAM_MANUAK, TEAM_NASILNIK, TEAM_HACKER, TEAM_MOB, TEAM_SPIDERMAN, TEAM_PARKOUR, TEAM_TVMASTER, TEAM_DETECTIVE})

-- Default categories
DarkRP.createCategory{
    name = "Мирные",
    categorises = "jobs",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Государство",
    categorises = "jobs",
    startExpanded = true,
    color = Color(25, 25, 170, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 101,
}

DarkRP.createCategory{
    name = "Криминал",
    categorises = "jobs",
    startExpanded = true,
    color = Color(75, 75, 75, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 101,
}

DarkRP.createCategory{
    name = "Нейтральные",
    categorises = "jobs",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Остальное",
    categorises = "jobs",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

--addons/weapon_knifecsgo/lua/weapons/csgo_talon.lua:
if not file.Exists( "weapons/csgo_baseknife.lua", "LUA" ) then
  SWEP.Spawnable = false
  print( "csgo_talon failed to initialize: csgo_baseknife.lua not found. Did you install the main part?" )
  return
end

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( "csgo_baseknife" )

if ( SERVER ) then
  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  if TTT then
    SWEP.EquipMenuData = nil
  end
end

if ( CLIENT ) then
  SWEP.Slot         = TTT and 6 or 2
  SWEP.SlotPos      = 0
end

SWEP.PrintName      = "Нож Talon"
SWEP.Category       = "Запрещено"

SWEP.Spawnable      = false
SWEP.AdminSpawnable = true

SWEP.ViewModel      = "models/weapons/horizon/v_csgo_talon.mdl"
SWEP.WorldModel     = "models/weapons/horizon/w_csgo_talon.mdl"

SWEP.SkinIndex      = 0
SWEP.PaintMaterial  = nil
SWEP.AreDaggers     = false

util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/entities/csgo_talon.vmt"

--gamemodes/darkrp/entities/weapons/gmod_tool/shared.lua:

-- Variables that are used on both client and server

SWEP.PrintName		= "#GMOD_ToolGun"
SWEP.Author			= "Facepunch"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModel		= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel		= "models/weapons/w_toolgun.mdl"

SWEP.UseHands		= true
SWEP.Spawnable		= true

-- Be nice, precache the models
util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- Todo, make/find a better sound.
SWEP.ShootSound = Sound( "Airboat.FireGunRevDown" )

SWEP.Tool = {}

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.CanHolster = true
SWEP.CanDeploy = true

function SWEP:InitializeTools()

	local owner = self:GetOwner()

	local temp = {}

	for k, v in pairs( self.Tool ) do

		temp[k] = table.Copy( v )
		temp[k].SWEP = self
		temp[k].Owner = owner
		temp[k].Weapon = self
		temp[k]:Init()

	end

	self.Tool = temp

end

function SWEP:SetupDataTables()

	self:NetworkVar( "Entity", 0, "TargetEntity1" )
	self:NetworkVar( "Entity", 1, "TargetEntity2" )
	self:NetworkVar( "Entity", 2, "TargetEntity3" )
	self:NetworkVar( "Entity", 3, "TargetEntity4" )

end

-- Convenience function to check object limits
function SWEP:CheckLimit( str )
	return self:GetOwner():CheckLimit( str )
end

function SWEP:Initialize()

	self:SetHoldType( "revolver" )

	self:InitializeTools()

	-- We create these here. The problem is that these are meant to be constant values.
	-- in the toolmode they're not because some tools can be automatic while some tools aren't.
	-- Since this is a global table it's shared between all instances of the gun.
	-- By creating new tables here we're making it so each tool has its own instance of the table
	-- So changing it won't affect the other tools.

	self.Primary = {
		ClipSize = -1,
		DefaultClip = -1,
		Automatic = false,
		Ammo = "none"
	}

	self.Secondary = {
		ClipSize = -1,
		DefaultClip = -1,
		Automatic = false,
		Ammo = "none"
	}

end

function SWEP:OnRestore()

	self:InitializeTools()

end

function SWEP:Precache()

	util.PrecacheSound( self.ShootSound )

end

-- Returns the mode we're in
function SWEP:GetMode()

	return self.Mode

end

-- Think does stuff every frame
function SWEP:Think()

	-- SWEP:Think is called one more time clientside
	-- after holstering using Player:SelectWeapon in multiplayer
	if ( CLIENT and self.m_uHolsterFrame == FrameNumber() ) then return end

	local owner = self:GetOwner()
	if ( !owner:IsPlayer() ) then return end

	local curmode = owner:GetInfo( "gmod_toolmode" )
	self.Mode = curmode

	local tool = self:GetToolObject( curmode )
	if ( !tool ) then return end

	tool:CheckObjects()

	local lastmode = self.current_mode
	self.last_mode = lastmode
	self.current_mode = curmode

	-- Release ghost entities if we're not allowed to use this new mode?
	if ( !tool:Allowed() ) then
		if ( lastmode ) then
			local lastmode_obj = self:GetToolObject( lastmode )

			if ( lastmode_obj ) then
				lastmode_obj:ReleaseGhostEntity() -- In case tool overwrites the default Holster
				lastmode_obj:Holster( true )
			end
		end

		return
	end

	if ( lastmode and lastmode ~= curmode ) then
		local lastmode_obj = self:GetToolObject( lastmode )

		if ( lastmode_obj ) then
			-- We want to release the ghost entity just in case
			lastmode_obj:ReleaseGhostEntity()
			lastmode_obj:Holster( true )
		end

		-- Deploy the new tool
		tool:Deploy( true )
	end

	self.Primary.Automatic = tool.LeftClickAutomatic or false
	self.Secondary.Automatic = tool.RightClickAutomatic or false
	self.RequiresTraceHit = tool.RequiresTraceHit or true

	tool:Think()

end

-- The shoot effect
function SWEP:DoShootEffect( hitpos, hitnormal, entity, physbone, bFirstTimePredicted )

	local owner = self:GetOwner()

	self:EmitSound( self.ShootSound )
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK ) -- View model animation

	-- There's a bug with the model that's causing a muzzle to
	-- appear on everyone's screen when we fire this animation.
	owner:SetAnimation( PLAYER_ATTACK1 ) -- 3rd Person Animation

	if ( !bFirstTimePredicted ) then return end
	if ( GetConVarNumber( "gmod_drawtooleffects" ) == 0 ) then return end

	local effectdata = EffectData()
	effectdata:SetOrigin( hitpos )
	effectdata:SetNormal( hitnormal )
	effectdata:SetEntity( entity )
	effectdata:SetAttachment( physbone )
	util.Effect( "selection_indicator", effectdata )

	local effect_tr = EffectData()
	effect_tr:SetOrigin( hitpos )
	effect_tr:SetStart( owner:GetShootPos() )
	effect_tr:SetAttachment( 1 )
	effect_tr:SetEntity( self )
	util.Effect( "ToolTracer", effect_tr )

end

local toolmask = bit.bor( CONTENTS_SOLID, CONTENTS_MOVEABLE, CONTENTS_MONSTER, CONTENTS_WINDOW, CONTENTS_DEBRIS, CONTENTS_GRATE, CONTENTS_AUX )

-- Trace a line then send the result to a mode function
function SWEP:PrimaryAttack()

	local owner = self:GetOwner()

	local tr = util.GetPlayerTrace( owner )
	tr.mask = toolmask
	tr.mins = vector_origin
	tr.maxs = tr.mins
	local trace = util.TraceLine( tr )
	if ( !trace.Hit ) then trace = util.TraceHull( tr ) end
	if ( !trace.Hit ) then return end

	local tool = self:GetToolObject()
	if ( !tool ) then return end

	tool:CheckObjects()

	-- Does the server setting say it's ok?
	if ( !tool:Allowed() ) then return end

	-- Ask the gamemode if it's ok to do this
	local mode = self:GetMode()
	if ( !gamemode.Call( "CanTool", owner, trace, mode, tool, 1 ) ) then return end

	if ( !tool:LeftClick( trace ) ) then return end

	self:DoShootEffect( trace.HitPos, trace.HitNormal, trace.Entity, trace.PhysicsBone, IsFirstTimePredicted() )

end

function SWEP:SecondaryAttack()

	local owner = self:GetOwner()

	local tr = util.GetPlayerTrace( owner )
	tr.mask = toolmask
	tr.mins = vector_origin
	tr.maxs = tr.mins
	local trace = util.TraceLine( tr )
	if ( !trace.Hit ) then trace = util.TraceHull( tr ) end
	if ( !trace.Hit ) then return end

	local tool = self:GetToolObject()
	if ( !tool ) then return end

	tool:CheckObjects()

	-- Does the server setting say it's ok?
	if ( !tool:Allowed() ) then return end

	-- Ask the gamemode if it's ok to do this
	local mode = self:GetMode()
	if ( !gamemode.Call( "CanTool", owner, trace, mode, tool, 2 ) ) then return end

	if ( !tool:RightClick( trace ) ) then return end

	self:DoShootEffect( trace.HitPos, trace.HitNormal, trace.Entity, trace.PhysicsBone, IsFirstTimePredicted() )

end

function SWEP:Reload()

	local owner = self:GetOwner()

	-- This makes the reload a semi-automatic thing rather than a continuous thing
	if ( !owner:KeyPressed( IN_RELOAD ) ) then return end

	local tr = util.GetPlayerTrace( owner )
	tr.mask = toolmask
	tr.mins = vector_origin
	tr.maxs = tr.mins
	local trace = util.TraceLine( tr )
	if ( !trace.Hit ) then trace = util.TraceHull( tr ) end
	if ( !trace.Hit ) then return end

	local tool = self:GetToolObject()
	if ( !tool ) then return end

	tool:CheckObjects()

	-- Does the server setting say it's ok?
	if ( !tool:Allowed() ) then return end

	-- Ask the gamemode if it's ok to do this
	local mode = self:GetMode()
	if ( !gamemode.Call( "CanTool", owner, trace, mode, tool, 3 ) ) then return end

	if ( !tool:Reload( trace ) ) then return end

	self:DoShootEffect( trace.HitPos, trace.HitNormal, trace.Entity, trace.PhysicsBone, IsFirstTimePredicted() )

end

function SWEP:Holster()

	local toolobj = self:GetToolObject()
	local CanHolster

	if ( toolobj ) then
		CanHolster = toolobj:Holster()
		if ( CanHolster == nil ) then CanHolster = self.CanHolster end
	else
		-- Just do what the SWEP wants to do if there's no tool
		CanHolster = self.CanHolster
	end

	-- Save the frame the weapon was holstered on to prevent
	-- the extra Think call after calling Player:SelectWeapon in multiplayer
	if ( CLIENT and CanHolster == true ) then self.m_uHolsterFrame = FrameNumber() end

	if ( CanHolster == true and toolobj ) then toolobj:ReleaseGhostEntity() end

	return CanHolster

end

-- Delete ghosts here in case the weapon gets deleted all of a sudden somehow
function SWEP:OnRemove()

	if ( !self:GetToolObject() ) then return end

	self:GetToolObject():ReleaseGhostEntity()

end


-- This will remove any ghosts when a player dies and drops the weapon
function SWEP:OwnerChanged()

	if ( !self:GetToolObject() ) then return end

--	self:GetToolObject():ReleaseGhostEntity()

end

-- Deploy
function SWEP:Deploy()

	-- Just do what the SWEP wants to do if there is no tool
	if ( !self:GetToolObject() ) then return self.CanDeploy end

	self:GetToolObject():UpdateData()

	local CanDeploy = self:GetToolObject():Deploy()
	if ( CanDeploy ~= nil ) then return CanDeploy end

	return self.CanDeploy

end

function SWEP:GetToolObject( tool )

	local mode = tool or self:GetMode()

	if ( !mode ) then
		local owner = self:GetOwner()
		if ( IsValid( owner ) and owner:IsPlayer() and ( SERVER or owner == LocalPlayer() ) ) then
			mode = owner:GetInfo( "gmod_toolmode" )
		end
	end

	if ( !self.Tool[ mode ] ) then return false end

	return self.Tool[ mode ]

end

function SWEP:FireAnimationEvent( pos, ang, event, options )

	-- Disables animation based muzzle event
	if ( event == 21 ) then return true end
	-- Disable thirdperson muzzle flash
	if ( event == 5003 ) then return true end

end

include( "stool.lua" )

--gamemodes/darkrp/entities/weapons/gmod_tool/object.lua:
nw.Register 'ToolStage'
	:Write(net.WriteUInt, 16)
	:Read(net.ReadUInt, 16)
	:Filter(function(self)
		return self.Owner
	end)
	:SetNoSync()

nw.Register 'ToolOp'
	:Write(net.WriteUInt, 16)
	:Read(net.ReadUInt, 16)
	:Filter(function(self)
		return self.Owner
	end)
	:SetNoSync()

function ToolObj:UpdateData()

	self:SetStage( self:NumObjects() )

end

function ToolObj:SetStage( i )

	if ( SERVER ) then
		self:GetWeapon():SetNetVar( "ToolStage", i )
	end

end

function ToolObj:GetStage()
	return self:GetWeapon():GetNetVar( "ToolStage", 0 )
end

function ToolObj:SetOperation( i )

	if ( SERVER ) then
		self:GetWeapon():SetNetVar( "ToolOp", i )
	end

end

function ToolObj:GetOperation()
	return self:GetWeapon():GetNetVar( "ToolOp", 0 )
end


-- Clear the selected objects
function ToolObj:ClearObjects()

	self:ReleaseGhostEntity()
	self.Objects = {}
	self:SetStage( 0 )
	self:SetOperation( 0 )

end

--[[---------------------------------------------------------
	Since we're going to be expanding this a lot I've tried
	to add accessors for all of this crap to make it harder
	for us to mess everything up.
-----------------------------------------------------------]]
function ToolObj:GetEnt( i )

	if ( !self.Objects[i] ) then return NULL end

	return self.Objects[i].Ent
end


--[[---------------------------------------------------------
	Returns the world position of the numbered object hit
	We store it as a local vector then convert it to world
	That way even if the object moves it's still valid
-----------------------------------------------------------]]
function ToolObj:GetPos( i )

	if ( self.Objects[i].Ent:EntIndex() == 0 ) then
		return self.Objects[i].Pos
	else
		if ( IsValid( self.Objects[i].Phys ) ) then
			return self.Objects[i].Phys:LocalToWorld( self.Objects[i].Pos )
		else
			return self.Objects[i].Ent:LocalToWorld( self.Objects[i].Pos )
		end
	end

end

-- Returns the local position of the numbered hit
function ToolObj:GetLocalPos( i )
	return self.Objects[i].Pos
end

-- Returns the physics bone number of the hit (ragdolls)
function ToolObj:GetBone( i )
	return self.Objects[i].Bone
end

function ToolObj:GetNormal( i )
	if ( self.Objects[i].Ent:EntIndex() == 0 ) then
		return self.Objects[i].Normal
	else
		local norm
		if ( IsValid( self.Objects[i].Phys ) ) then
			norm = self.Objects[i].Phys:LocalToWorld( self.Objects[i].Normal )
		else
			norm = self.Objects[i].Ent:LocalToWorld( self.Objects[i].Normal )
		end

		return norm - self:GetPos(i)
	end
end

-- Returns the physics object for the numbered hit
function ToolObj:GetPhys( i )

	if ( self.Objects[i].Phys == nil ) then
		return self:GetEnt(i):GetPhysicsObject()
	end

	return self.Objects[i].Phys
end


-- Sets a selected object
function ToolObj:SetObject( i, ent, pos, phys, bone, norm )

	self.Objects[i] = {}
	self.Objects[i].Ent = ent
	self.Objects[i].Phys = phys
	self.Objects[i].Bone = bone
	self.Objects[i].Normal = norm

	-- Worldspawn is a special case
	if ( ent:EntIndex() == 0 ) then

		self.Objects[i].Phys = nil
		self.Objects[i].Pos = pos

	else

		norm = norm + pos

		-- Convert the position to a local position - so it's still valid when the object moves
		if ( IsValid( phys ) ) then
			self.Objects[i].Normal = self.Objects[i].Phys:WorldToLocal( norm )
			self.Objects[i].Pos = self.Objects[i].Phys:WorldToLocal( pos )
		else
			self.Objects[i].Normal = self.Objects[i].Ent:WorldToLocal( norm )
			self.Objects[i].Pos = self.Objects[i].Ent:WorldToLocal( pos )
		end

	end

	if ( SERVER ) then
		-- Todo: Make sure the client got the same info
	end

end


-- Returns the number of objects in the list
function ToolObj:NumObjects()

	if ( CLIENT ) then

		return self:GetStage()

	end

	return #self.Objects

end


-- Returns the number of objects in the list
function ToolObj:GetHelpText()

	return "#tool." .. GetConVarString( "gmod_toolmode" ) .. "." .. self:GetStage()

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/creator.lua:

TOOL.AddToMenu = false
TOOL.ClientConVar[ "type" ] = "0"
TOOL.ClientConVar[ "name" ] = "0"
TOOL.ClientConVar[ "arg" ] = "0"

TOOL.Information = { { name = "left" } }

function TOOL:LeftClick( trace, attach )

	local type = self:GetClientNumber( "type", 0 )
	local name = self:GetClientInfo( "name", 0 )
	local arg = self:GetClientInfo( "arg", 0 )

	if ( CLIENT ) then return true end

	if ( type == 0 ) then

--		Spawn_SENT( self:GetOwner(), name, trace )

	elseif ( type == 1 ) then

		Spawn_Vehicle( self:GetOwner(), name, trace )

	elseif ( type == 2 ) then

		Spawn_NPC( self:GetOwner(), name, arg, trace )

	elseif ( type == 3 ) then

	elseif ( type == 4 ) then

		CCSpawn( self:GetOwner(), nil, { name } ) -- Props

	end

	return true

end

--addons/weapon_hover/lua/weapons/gmod_tool/stools/hoverboard.lua:

// basic
TOOL.Category = "CYBER PACK"
TOOL.Name = "#tool.hoverboard.name"

-- TO ADD NEW HOVERBOARDS, CHECK OUT THE AUTORUN FILE

AddCSLuaFile( "vgui/hoverboard_gui.lua" )

cleanup.Register( "hoverboards" )

for _, hbt in pairs( HoverboardTypes ) do

	list.Set( "HoverboardModels", hbt[ 'model' ], {} )
	util.PrecacheModel( hbt[ 'model' ] )

	if ( SERVER && GetConVarNumber( "rb655_force_downloads" ) > 0 ) then

		resource.AddFile( hbt[ 'model' ] )

		if ( hbt[ 'files' ] ) then

			for __, f in pairs( hbt[ 'files' ] ) do

				resource.AddFile( f ) // send other files

			end

		end

	end

end

TOOL.ClientConVar[ 'model' ] = "models/UT3/hoverboard.mdl"
TOOL.ClientConVar[ 'lights' ] = 0
TOOL.ClientConVar[ 'mousecontrol' ] = 1
TOOL.ClientConVar[ 'boostshake' ] = 1
TOOL.ClientConVar[ 'height' ] = 72
TOOL.ClientConVar[ 'viewdist' ] = 128
TOOL.ClientConVar[ 'trail_size' ] = 5
TOOL.ClientConVar[ 'trail_r' ] = 128
TOOL.ClientConVar[ 'trail_g' ] = 128
TOOL.ClientConVar[ 'trail_b' ] = 255
TOOL.ClientConVar[ 'boost_r' ] = 128
TOOL.ClientConVar[ 'boost_g' ] = 255
TOOL.ClientConVar[ 'boost_b' ] = 128
TOOL.ClientConVar[ 'recharge_r' ] = 255
TOOL.ClientConVar[ 'recharge_g' ] = 128
TOOL.ClientConVar[ 'recharge_b' ] = 128
TOOL.ClientConVar[ 'speed' ] = 10
TOOL.ClientConVar[ 'jump' ] = 10
TOOL.ClientConVar[ 'turn' ] = 10
TOOL.ClientConVar[ 'flip' ] = 10
TOOL.ClientConVar[ 'twist' ] = 5

function TOOL:LeftClick( trace )
	local pl = self:GetOwner()
	if not (pl:PS_HasItem("cyberitem") or pl:PS_HasItem("cyberitem_navsegda") or pl:Team() == TEAM_SKATE) then return false end
	local result, hoverboard = self:CreateBoard( trace )
	return result
end

function TOOL:RightClick( trace )
	--[[
	local result, hoverboard = self:CreateBoard( trace )

	if ( CLIENT ) then return result end // client result

	if ( IsValid( hoverboard ) ) then // validate board

		local pl = self:GetOwner() // owner
		local dist = ( hoverboard:GetPos() - pl:GetPos() ):Length() // check distance
		if not pl:PS_HasItem("cyberitem") and not pl:PS_HasItem("cyberitem_navsegda") then return end
		if ( dist <= 512 ) then // make sure its relatively close?

			timer.Simple( 0.25, function() // had to delay it to avoid errors

				if ( IsValid( hoverboard ) && IsValid( pl ) ) then hoverboard:SetDriver( pl ) end

			end )

		end

	end

	return result
	]]
end

function TOOL:CreateBoard( trace )
	if CLIENT then return end

	local pl = self:GetOwner()
	if ( GetConVarNumber( "sv_hoverboard_adminonly" ) > 0 && !( pl:IsAdmin() || pl:IsSuperAdmin() ) ) then return false end
	
	if not (pl:PS_HasItem("cyberitem") or pl:PS_HasItem("cyberitem_navsegda") or pl:Team() == TEAM_SKATE) then return false end

	local model = self:GetClientInfo( "model" )
	local mcontrol = self:GetClientNumber( "mousecontrol" )
	local shake = self:GetClientNumber( "boostshake" )
	local trailsize = math.Clamp( self:GetClientNumber( "trail_size" ), 0, 10 )
	local height = math.Clamp( self:GetClientNumber( "height" ), 36, 100 )
	local viewdist = math.Clamp( self:GetClientNumber( "viewdist" ), 64, 256 )
	local trail = Vector( self:GetClientNumber( "trail_r" ), self:GetClientNumber( "trail_g" ), self:GetClientNumber( "trail_b" ) )
	local boost = Vector( self:GetClientNumber( "boost_r" ), self:GetClientNumber( "boost_g" ), self:GetClientNumber( "boost_b" ) )
	local recharge = Vector( self:GetClientNumber( "recharge_r" ), self:GetClientNumber( "recharge_g" ), self:GetClientNumber( "recharge_b" ) )

	local attributes = {
		speed = math.Clamp( self:GetClientNumber( "speed" ), 0, 15 ),
		jump = math.Clamp( self:GetClientNumber( "jump" ), 0, 15 ),
		turn = math.Clamp( self:GetClientNumber( "turn" ), 0, 15 ),
		flip = math.Clamp( self:GetClientNumber( "flip" ), 0, 15 ),
		twist = math.Clamp( self:GetClientNumber( "twist" ), 0, 15 )
	}

	local ang = pl:GetAngles()
	ang.p = 0
	ang.y = ang.y + 180

	local pos = trace.HitPos + trace.HitNormal * 32

	local hoverboard = MakeHoverboard( pl, model, ang, pos, mcontrol, shake, height, viewdist, trailsize, trail, boost, recharge, attributes )
	if ( !IsValid( hoverboard ) ) then return false end

	undo.Create( "Hoverboard" )
		undo.AddEntity( hoverboard )
		undo.SetPlayer( pl )
	undo.Finish()

	return true, hoverboard
end

function TOOL:Reload( trace )
end

function TOOL:Think()
end

if ( SERVER ) then

	function MakeHoverboard( pl, model, ang, pos, mcontrol, shake, height, viewdist, trailsize, trail, boost, recharge, attributes )

		if ( IsValid( pl ) && !pl:CheckLimit( "hoverboards" ) ) then return false end

		local hoverboard = ents.Create( "modulus_hoverboard" )

		if ( !IsValid( hoverboard ) ) then return false end

		local boardinfo

		for _, board in pairs( HoverboardTypes ) do

			if ( board[ 'model' ]:lower() == model:lower() ) then

				boardinfo = board
				break

			end

		end

		if ( !boardinfo ) then return false end

		util.PrecacheModel( model )

		hoverboard:SetModel( model )
		hoverboard:SetAngles( ang )
		hoverboard:SetPos( pos )

		hoverboard:SetBoardRotation( 0 )

		if ( boardinfo[ "rotation" ] ) then

			local rot = tonumber( boardinfo[ "rotation" ] )

			hoverboard:SetBoardRotation( tonumber( boardinfo[ "rotation" ] ) )

			ang.y = ang.y - rot
			hoverboard:SetAngles( ang )

		end

		hoverboard:Spawn()
		hoverboard:Activate()

		hoverboard:SetAvatarPosition( Vector( 0, 0, 0 ) )

		if ( boardinfo[ 'driver' ] ) then

			hoverboard:SetAvatarPosition( boardinfo[ 'driver' ] )

		end

		for k, v in pairs( boardinfo ) do

			if ( k:sub( 1, 7 ):lower() == "effect_" && type( boardinfo[ k ] == "table" ) ) then

				local effect = boardinfo[ k ]

				local normal
				if ( effect[ 'normal' ] ) then normal = effect[ 'normal' ] end

				hoverboard:AddEffect( effect[ 'effect' ] or "trail", effect[ 'position' ], normal, effect[ 'scale' ] or 1 )

			end

		end

		hoverboard:SetControls( math.Clamp( tonumber( mcontrol ), 0, 1 ) ) // controls
		hoverboard:SetBoostShake( math.Clamp( tonumber( shake ), 0, 1 ) ) // boost shake
		hoverboard:SetHoverHeight( math.Clamp( tonumber( height ), 36, 100 ) ) // hover height
		hoverboard:SetViewDistance( math.Clamp( tonumber( viewdist ), 64, 256 ) ) // view distance
		hoverboard:SetSpring( 0.21 * ( ( 72 / height ) * ( 72 / height ) ) ) // spring

		trailsize = math.Clamp( trailsize, 0, 10 ) * 0.3
		hoverboard:SetTrailScale( trailsize )
		hoverboard:SetTrailColor( trail )
		hoverboard:SetTrailBoostColor( boost )
		hoverboard:SetTrailRechargeColor( recharge )

		//local count = 0
		//local points = GetConVarNumber( "sv_hoverboard_points" )

		for k, v in pairs( attributes ) do

			//local remaining = points - count

			//v = math.Clamp( v, 0, math.min( 16, remaining ) )

			v = math.Clamp( v, 0, 16 )

			//attributes[ k ] = v

			//count = count + v

		end

		/*for k, v in pairs( boardinfo[ 'bonus' ] or {} ) do

			if ( attributes[ k ] ) then

				attributes[ k ] = attributes[ k ] + tonumber( v )

			end

		end*/

		local speed = ( attributes[ 'speed' ] * 0.1 ) * 20
		hoverboard:SetSpeed( speed )
		local jump = ( attributes[ 'jump' ] * 0.1 ) * 250 -- It seems to me that this should be 2500
		hoverboard:SetJumpPower( jump )
		local turn = ( attributes[ 'turn' ] * 0.1 ) * 25
		hoverboard:SetTurnSpeed( turn )
		local flip = ( attributes[ 'flip' ] * 0.1 ) * 25
		hoverboard:SetPitchSpeed( flip )
		local twist = ( attributes[ 'twist' ] * 0.1 ) * 25
		hoverboard:SetYawSpeed( twist )
		local roll = ( ( flip + twist * 0.5 ) / 50 ) * 22
		hoverboard:SetRollSpeed( roll )

	--	DoPropSpawnedEffect( hoverboard )

		if ( IsValid( pl ) ) then
			pl:AddCount( "hoverboards", hoverboard )
			pl:AddCleanup( "hoverboards", hoverboard )
			hoverboard.Creator = pl:UniqueID()
		end

		return hoverboard

	end

	return
end

language.Add( "tool.hoverboard.name", "Hoverboards" )
language.Add( "tool.hoverboard.desc", "Spawn customized hoverboards" )
language.Add( "tool.hoverboard.0", "Left click to spawn a hoverboard. Right click to spawn a hoverboard & mount onto it." )

language.Add( "tool.hoverboard.lights", "Trail lights" )
language.Add( "tool.hoverboard.lights.help", "The next commands are accessible to the server hoster only ON A LISTEN SERVER ONLY!" )

language.Add( "Undone_hoverboard", "Undone Hoverboard" )
language.Add( "SBoxLimit_hoverboards", "You've reached the Hoverboard limit!" )

local hbpanel = vgui.RegisterFile( "vgui/hoverboard_gui.lua" )

function TOOL.BuildCPanel( cp )

	//cp:AddControl( "PropSelect", { Label = "Hoverboard Model", Height = 3, ConVar = "hoverboard_model", Models = list.Get( "HoverboardModels" ) } )

	local panel = vgui.CreateFromTable( hbpanel )
	panel:PopulateBoards( HoverboardTypes )
	panel:PerformLayout( )
	cp:AddPanel( panel )

	cp:AddControl( "Color", { Label = "Trail Color", Red = "hoverboard_trail_r", Green = "hoverboard_trail_g", Blue = "hoverboard_trail_b", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )
	cp:AddControl( "Color", { Label = "Boost Color", Red = "hoverboard_boost_r", Green = "hoverboard_boost_g", Blue = "hoverboard_boost_b", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )
	cp:AddControl( "Color", { Label = "Recharge Color", Red = "hoverboard_recharge_r", Green = "hoverboard_recharge_g", Blue = "hoverboard_recharge_b", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )

	cp:AddControl( "Slider", { Label = "Trail Size", Min = 0, Max = 10, Command = "hoverboard_trail_size" } )
	cp:AddControl( "Slider", { Label = "Hover Height", Min = 36, Max = 100, Command = "hoverboard_height" } )
	cp:AddControl( "Slider", { Label = "View Distance", Min = 64, Max = 256, Command = "hoverboard_viewdist" } )

	cp:AddControl( "Checkbox", { Label = "Mouse Control", Command = "hoverboard_mousecontrol" } )
	cp:AddControl( "Checkbox", { Label = "Boost Shake", Command = "hoverboard_boostshake" } )
	cp:AddControl( "Checkbox", { Label = "#tool.hoverboard.lights", Command = "hoverboard_lights", Help = true } )

	//cp:AddControl( "Checkbox", { Label = "ADMIN: Can Fall From Hoverboard?", Command = "sv_hoverboard_canfall" } )
	cp:AddControl( "Checkbox", { Label = "ADMIN: Can Share?", Command = "sv_hoverboard_canshare" } )
	cp:AddControl( "Checkbox", { Label = "ADMIN: Can Steal?", Command = "sv_hoverboard_cansteal" } )
	cp:AddControl( "Checkbox", { Label = "ADMIN: Admin Only?", Command = "sv_hoverboard_adminonly" } )
	cp:AddControl( "Slider", { Label = "ADMIN: Max Hoverboards Per Player", Min = 1, Max = 10, Command = "sbox_maxhoverboards" } )
	//cp:AddControl( "Slider", { Label = "ADMIN: Max Points", Min = 5, Max = 80, Command = "sv_hoverboard_points" } )

end

--addons/tool_keypad/lua/weapons/gmod_tool/stools/keypad_pattern.lua:
if SERVER then
    CreateConVar("sbox_maxpattern_keypads", 10)
end

TOOL.Category = "WayZer's Role Play"
TOOL.Name = PatternKeypad.language.toolName -- Change this in the config file
TOOL.Command = nil

TOOL.ClientConVar["combination"] = "3,3:1,2,3"
TOOL.ClientConVar["weld"] = "1"
TOOL.ClientConVar["freeze"] = "1"

TOOL.ClientConVar["key_granted"] = "0"
TOOL.ClientConVar["key_denied"] = "0"

TOOL.ClientConVar["repeats_granted"] = "0"
TOOL.ClientConVar["repeats_denied"] = "0"

TOOL.ClientConVar["length_granted"] = "5"
TOOL.ClientConVar["length_denied"] = "0.1"

TOOL.ClientConVar["delay_granted"] = "0"
TOOL.ClientConVar["delay_denied"] = "0"

TOOL.ClientConVar["init_delay_granted"] = "0"
TOOL.ClientConVar["init_delay_denied"] = "0"

TOOL.ClientConVar["color_primary"] = "59,73,84"
TOOL.ClientConVar["color_secondary"] = "211,47,47"
TOOL.ClientConVar["color_granted"] = "100,255,50"
TOOL.ClientConVar["color_denied"] = "255,40,20"

if CLIENT then
    language.Add("tool.keypad_pattern.name", PatternKeypad.language.toolName)
    language.Add("tool.keypad_pattern.0", PatternKeypad.language.toolInstruction)
    language.Add("tool.keypad_pattern.desc", PatternKeypad.language.toolDescription)

    language.Add("Undone_pattern_keypad", PatternKeypad.language.undo)
    language.Add("Cleanup_pattern_keypads", PatternKeypad.language.cleanName)
    language.Add("Cleaned_pattern_keypads", PatternKeypad.language.cleanedUp)

    language.Add("SBoxLimit_pattern_keypads", PatternKeypad.language.limitReached)
end

cleanup.Register("pattern_keypads")

function TOOL:SetupKeypad(ent, width, height, combination)
    ent:SetData({
        combination = combination,
        width = width,
        height = height,

        grantedRepeats   = math.Clamp(self:GetClientNumber("repeats_granted"), 0, 5),
        grantedLength    = math.Clamp(self:GetClientNumber("length_granted"), 5, 10),
        grantedDelay     = math.Clamp(self:GetClientNumber("delay_granted"), 0, 10),
        grantedInitDelay = math.Clamp(self:GetClientNumber("init_delay_granted"), 0, 10),
        grantedKey       = self:GetClientInfo("key_granted"),

        deniedRepeats   = math.Clamp(self:GetClientNumber("repeats_denied"), 0, 5),
        deniedLength    = math.Clamp(self:GetClientNumber("length_denied"), 0.1, 10),
        deniedDelay     = math.Clamp(self:GetClientNumber("delay_denied"), 0, 10),
        deniedInitDelay = math.Clamp(self:GetClientInfo("init_delay_denied"), 0, 10),
        deniedKey       = self:GetClientInfo("key_denied"),

        owner = self:GetOwner()
    })
end

function TOOL:LeftClick(tr)
    if IsValid(tr.Entity) and tr.Entity:IsPlayer() then return false end

    if CLIENT then return true end

    local ply = self:GetOwner()
    local width, height, combination = PatternKeypad.parseCombination(self:GetClientInfo("combination"))

	if #combination <= 1 then
		ply:PrintMessage(3, PatternKeypad.language.errorNoPattern)
		return false
	end

    local ent
    if IsValid(tr.Entity) and tr.Entity:GetClass():lower() == "keypad_pattern" then
        ent = tr.Entity
    else
        if not self:GetWeapon():CheckLimit("pattern_keypads") then return false end

        ent = ents.Create("keypad_pattern")
        ent:SetAngles(tr.HitNormal:Angle())
        ent:Spawn()
        ent:SetPos(tr.HitPos + tr.HitNormal / 2)

        local freeze = util.tobool(self:GetClientNumber("freeze"))
        local weld = util.tobool(self:GetClientNumber("weld"))

        if freeze or weld then
            local phys = ent:GetPhysicsObject()
            if IsValid(phys) then
                phys:EnableMotion(false)
            end

            if weld then constraint.Weld(ent, tr.Entity, 0, 0, 0, true, false) end
        end

        ply:AddCount("pattern_keypads", ent)
        ply:AddCleanup("pattern_keypads", ent)

        undo.Create("pattern_keypad")
            undo.AddEntity(ent)
            undo.SetPlayer(ply)
        undo.Finish()
    end

    ent:SetColors(self:GetClientInfo("color_primary") .. "-" .. self:GetClientInfo("color_secondary") .. "-" .. self:GetClientInfo("color_granted") .. "-" .. self:GetClientInfo("color_denied"))

    self:SetupKeypad(ent, width, height, combination)

    return true
end

function TOOL:RightClick(tr)

end

if CLIENT then

    concommand.Add("keypad_pattern_reset", function(ply)
        ply:ConCommand("keypad_pattern_repeats_granted 0")
        ply:ConCommand("keypad_pattern_repeats_denied 0")
        ply:ConCommand("keypad_pattern_length_granted 5")
        ply:ConCommand("keypad_pattern_length_denied 0.1")
        ply:ConCommand("keypad_pattern_delay_granted 0")
        ply:ConCommand("keypad_pattern_delay_denied 0")
        ply:ConCommand("keypad_pattern_init_delay_granted 0")
        ply:ConCommand("keypad_pattern_init_delay_denied 0")
    end)

    function TOOL.BuildCPanel(CPanel)
        local panel = vgui.Create("DPatternKeypadGrid")
        panel:SetConVar("keypad_pattern_combination")
        CPanel:AddItem(panel)

        local colorPanel = vgui.Create("DPanel")
        colorPanel:SetTall(64)
        colorPanel:SetPaintBackground(false)
        CPanel:AddItem(colorPanel)

        local colors = PatternKeypad.availableColors

        local colorSwitchPrimary = vgui.Create("DPatternKeypadColorSelector", colorPanel)
        colorSwitchPrimary:SetConVar("keypad_pattern_color_primary")
        colorSwitchPrimary:SetSize(32, 32)
        colorSwitchPrimary:SetColors(colors)

        local labelPrimary = vgui.Create("DLabel", colorPanel)
        labelPrimary:SetText(PatternKeypad.language.toolColorPrimary)
        labelPrimary:SizeToContents()
        labelPrimary:SetTextColor(Color(0, 0, 0))

        local colorSwitchSecondary = vgui.Create("DPatternKeypadColorSelector", colorPanel)
        colorSwitchSecondary:SetConVar("keypad_pattern_color_secondary")
        colorSwitchSecondary:SetSize(32, 32)
        colorSwitchSecondary:SetColors(colors)

        local labelSecondary = vgui.Create("DLabel", colorPanel)
        labelSecondary:SetText(PatternKeypad.language.toolColorSecondary)
        labelSecondary:SizeToContents()
        labelSecondary:SetTextColor(Color(0, 0, 0))

        local colorSwitchGranted = vgui.Create("DPatternKeypadColorSelector", colorPanel)
        colorSwitchGranted:SetConVar("keypad_pattern_color_granted")
        colorSwitchGranted:SetSize(32, 32)
        colorSwitchGranted:SetColors(colors)

        local labelGranted = vgui.Create("DLabel", colorPanel)
        labelGranted:SetText(PatternKeypad.language.toolColorGranted)
        labelGranted:SizeToContents()
        labelGranted:SetTextColor(Color(0, 0, 0))

        local colorSwitchDenied = vgui.Create("DPatternKeypadColorSelector", colorPanel)
        colorSwitchDenied:SetConVar("keypad_pattern_color_denied")
        colorSwitchDenied:SetSize(32, 32)
        colorSwitchDenied:SetColors(colors)

        local labelDenied = vgui.Create("DLabel", colorPanel)
        labelDenied:SetText(PatternKeypad.language.toolColorDenied)
        labelDenied:SizeToContents()
        labelDenied:SetTextColor(Color(0, 0, 0))

        function colorPanel:PerformLayout(w, h)
            local offset = w / 10
            local areaW = w - 32 - offset * 2

            colorSwitchPrimary:SetPos(offset, 16)
            labelPrimary:SetPos(offset + 16 - labelPrimary:GetWide() / 2, 0)

            colorSwitchSecondary:SetPos(offset + areaW / 3, 16)
            labelSecondary:SetPos(offset + areaW / 3 + 16 - labelSecondary:GetWide() / 2, 0)

            colorSwitchGranted:SetPos(offset + areaW / 3 * 2, 16)
            labelGranted:SetPos(offset + areaW / 3 * 2 + 16 - labelGranted:GetWide() / 2, 0)

            colorSwitchDenied:SetPos(offset + areaW, 16)
            labelDenied:SetPos(offset + areaW + 16 - labelDenied:GetWide() / 2, 0)
        end

        CPanel:CheckBox(PatternKeypad.language.toolWeld, "keypad_pattern_weld")
        CPanel:CheckBox(PatternKeypad.language.toolFreeze, "keypad_pattern_freeze")

        local ctrl = vgui.Create("CtrlNumPad")
        ctrl:SetConVar1("keypad_pattern_key_granted")
        ctrl:SetConVar2("keypad_pattern_key_denied")
        ctrl:SetLabel1("Принято")
        ctrl:SetLabel2("Отказано")
        CPanel:AddItem(ctrl)

        local granted = vgui.Create("DForm")
        granted:SetName(PatternKeypad.language.toolGrantedSettings)

        granted:NumSlider(PatternKeypad.language.toolHoldLength, "keypad_pattern_length_granted", 5, 10, 2)
        granted:NumSlider(PatternKeypad.language.toolInitialDelay, "keypad_pattern_init_delay_granted", 0, 10, 2)
        granted:NumSlider(PatternKeypad.language.toolMultiplePressDelay, "keypad_pattern_delay_granted", 0, 10, 2)
        granted:NumSlider(PatternKeypad.language.toolAdditionalRepeats, "keypad_pattern_repeats_granted", 0, 5, 0)
        CPanel:AddItem(granted)

        local denied = vgui.Create("DForm")
        denied:SetName(PatternKeypad.language.toolDeniedSettings)

        denied:NumSlider(PatternKeypad.language.toolHoldLength, "keypad_pattern_length_denied", 0.1, 10, 2)
        denied:NumSlider(PatternKeypad.language.toolInitialDelay, "keypad_pattern_init_delay_denied", 0, 10, 2)
        denied:NumSlider(PatternKeypad.language.toolMultiplePressDelay, "keypad_pattern_delay_denied", 0, 10, 2)
        denied:NumSlider(PatternKeypad.language.toolAdditionalRepeats, "keypad_pattern_repeats_denied", 0, 5, 0)
        CPanel:AddItem(denied)

        CPanel:Button(PatternKeypad.language.toolDefaults, "keypad_pattern_reset")
    end
end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/leafblower.lua:

TOOL.AddToMenu = false

--
-- This tool is the most important aspect of Garry's Mod
--

TOOL.LeftClickAutomatic = true

function TOOL:LeftClick( trace )

	if ( CLIENT ) then return end

	util.PrecacheSound( "ambient/wind/wind_hit2.wav" )
	self:GetOwner():EmitSound( "ambient/wind/wind_hit2.wav" )

	if ( IsValid( trace.Entity ) and IsValid( trace.Entity:GetPhysicsObject() ) ) then

		local phys = trace.Entity:GetPhysicsObject()	-- The physics object
		local direction = trace.StartPos - trace.HitPos	-- The direction of the force
		local force = 32								-- The ideal amount of force
		local distance = direction:Length()				-- The distance the phys object is from the gun
		local maxdistance = 512							-- The max distance the gun should reach

		-- Lessen the force from a distance
		local ratio = math.Clamp( 1 - ( distance / maxdistance ), 0, 1 )

		-- Set up the 'real' force and the offset of the force
		local vForce = -direction * ( force * ratio )
		local vOffset = trace.HitPos

		-- Apply it!
		phys:ApplyForceOffset( vForce, vOffset )

	end

end

--addons/tool_precision/lua/weapons/gmod_tool/stools/precision.lua:
TOOL.Category		= "WayZer's Role Play"
TOOL.Name			= "#Precision"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "mode" ]	 			= "1"
TOOL.ClientConVar[ "user" ] 			= "1"

TOOL.ClientConVar[ "nocollide" ]		= "1"
TOOL.ClientConVar[ "nocollideall" ]		= "0"
TOOL.ClientConVar[ "rotation" ] 		= "15"
TOOL.ClientConVar[ "rotate" ] 			= "1"
TOOL.ClientConVar[ "offset" ]	 		= "0"
TOOL.ClientConVar[ "forcelimit" ]		= "0"
TOOL.ClientConVar[ "torquelimit" ] 		= "0"
TOOL.ClientConVar[ "friction" ]	 		= "0"
TOOL.ClientConVar[ "width" ]	 		= "1"
TOOL.ClientConVar[ "offsetpercent" ] 	= "1"
TOOL.ClientConVar[ "removal" ]	 		= "0"
TOOL.ClientConVar[ "move" ]	 			= "1"
TOOL.ClientConVar[ "physdisable" ]		= "0"
TOOL.ClientConVar[ "ShadowDisable" ]	= "0"
TOOL.ClientConVar[ "allowphysgun" ]		= "0"
TOOL.ClientConVar[ "autorotate" ]		= "0"
TOOL.ClientConVar[ "entirecontrap" ]	= "0"
TOOL.ClientConVar[ "nudge" ]			= "25"
TOOL.ClientConVar[ "nudgepercent" ]		= "1"
TOOL.ClientConVar[ "disablesliderfix" ]	= "0"

--adv ballsocket
TOOL.ClientConVar[ "XRotMin" ]		= "-180"
TOOL.ClientConVar[ "XRotMax" ]		= "180"
TOOL.ClientConVar[ "YRotMin" ]		= "-180"
TOOL.ClientConVar[ "YRotMax" ]		= "180"
TOOL.ClientConVar[ "ZRotMin" ]		= "-180"
TOOL.ClientConVar[ "ZRotMax" ]		= "180"
TOOL.ClientConVar[ "XRotFric" ]		= "0"
TOOL.ClientConVar[ "YRotFric" ]		= "0"
TOOL.ClientConVar[ "ZRotFric" ]		= "0"
TOOL.ClientConVar[ "FreeMov" ]		= "0"

--Removal
TOOL.ClientConVar[ "removal_nocollide" ]	= "1"
TOOL.ClientConVar[ "removal_weld" ]	 		= "1"
TOOL.ClientConVar[ "removal_axis" ]	 		= "1"
TOOL.ClientConVar[ "removal_ballsocket" ]	= "1"
TOOL.ClientConVar[ "removal_advballsocket" ]= "1"
TOOL.ClientConVar[ "removal_slider" ]	 	= "1"
TOOL.ClientConVar[ "removal_parent" ]	 	= "1"
TOOL.ClientConVar[ "removal_other" ]	 	= "1"


TOOL.ClientConVar[ "enablefeedback" ]	= "1"
TOOL.ClientConVar[ "chatfeedback" ]		= "1"
TOOL.ClientConVar[ "nudgeundo" ]		= "0"
TOOL.ClientConVar[ "moveundo" ]			= "1"
TOOL.ClientConVar[ "rotateundo" ]		= "1"

function TOOL:DoParent( Ent1, Ent2 )
	local TempEnt = Ent2
	if !(Ent1 && Ent1:IsValid() && Ent1:EntIndex() != 0) then
		self:SendMessage( "Oops, First Target was world or something invalid" )
		return
	end
	if !(Ent2 && Ent2:IsValid() && Ent2:EntIndex() != 0) then
		self:SendMessage( "Oops, Second Target was world or something invalid" )
		return
	end
	if ( Ent1 == Ent2 ) then
		self:SendMessage( "Oops, Can't parent something to itself" )
		return
	end
	Ent1:SetMoveType(MOVETYPE_NONE)
	local disablephysgun = self:GetClientNumber( "allowphysgun" ) == 0
	Ent1.PhysgunDisabled = disablephysgun
	Ent1:SetUnFreezable( disablephysgun )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( false )
	end
	while true do
		if ( !TempEnt:GetParent():IsValid() ) then
			Ent1:SetParent( Ent2 )
			if self:GetClientNumber( "entirecontrap" ) == 0 then self:SendMessage( "Parent Set." ) end
			Phys1:Wake()
			break
		elseif ( TempEnt:GetParent() == Ent1 ) then
			UndoParent( TempEnt )
			timer.Simple( 0.1, function()--delay to stop crash
				Ent1.SetParent( Ent1, Ent2)
			end)
			self:SendMessage( "Oops, Closed Parent Loop Detected; Broken loop and set parent." )
			break
		else
			TempEnt = TempEnt:GetParent()
		end
	end
	Phys1:Wake()
	--Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
end

function TOOL:UndoParent( Ent1 )
	Ent1:SetParent( nil )
	Ent1:SetMoveType(MOVETYPE_VPHYSICS)
	Ent1.PhysgunDisabled = false
	Ent1:SetUnFreezable( false )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( true )
		Phys1:Wake()
		--Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
	end
end

function TOOL:DoApply(CurrentEnt, FirstEnt, autorotate, nocollideall, ShadowDisable )
	local CurrentPhys = CurrentEnt:GetPhysicsObject()

	--local col = CurrentEnt:GetCollisionGroup()
	--col = 19
	--CurrentEnt:SetCollisionGroup(col)
	--self:SendMessage("New group: "..col)

	--if ( CurrentPhys:IsDragEnabled() ) then
	--end
	--CurrentPhys:SetAngleDragCoefficient(1.05)
	--CurrentPhys:SetDragCoefficient(1.05)

	if ( autorotate ) then
		if ( CurrentEnt == FirstEnt ) then--Snap-rotate original object first.  Rest needs to rotate around it.
			local angle = CurrentPhys:RotateAroundAxis( Vector( 0, 0, 1 ), 0 )
			self.anglechange = Vector( angle.p - (math.Round(angle.p/45))*45, angle.r - (math.Round(angle.r/45))*45, angle.y - (math.Round(angle.y/45))*45 )
			if ( table.Count(self.TaggedEnts) == 1 ) then
				angle.p = (math.Round(angle.p/45))*45
				angle.r = (math.Round(angle.r/45))*45--Only rotate on these axies if it's singular.
			end
			angle.y = (math.Round(angle.y/45))*45
			CurrentPhys:SetAngles( angle )
		else
			local distance = math.sqrt(math.pow((CurrentEnt:GetPos().X-FirstEnt:GetPos().X),2)+math.pow((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y),2))
			local theta = math.atan((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y) / (CurrentEnt:GetPos().X-FirstEnt:GetPos().X)) - math.rad(self.anglechange.Z)
			if (CurrentEnt:GetPos().X-FirstEnt:GetPos().X) < 0 then
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X - (distance*(math.cos(theta))), FirstEnt:GetPos().Y - (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			else
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X + (distance*(math.cos(theta))), FirstEnt:GetPos().Y + (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			end
			CurrentPhys:SetAngles( CurrentPhys:RotateAroundAxis( Vector( 0, 0, -1 ), self.anglechange.Z ) )
		end
	end

	CurrentPhys:EnableCollisions( !nocollideall )
	CurrentEnt:DrawShadow( !ShadowDisable )
	if physdis then
		CurrentEnt:SetMoveType(MOVETYPE_NONE)
		CurrentEnt.PhysgunDisabled = disablephysgun
		CurrentEnt:SetUnFreezable( disablephysgun )
	else
		CurrentEnt:SetMoveType(MOVETYPE_VPHYSICS)
		CurrentEnt.PhysgunDisabled = false
		CurrentEnt:SetUnFreezable( false )
	end
	CurrentPhys:Wake()
end

function TOOL:CreateUndo(constraint,undoname)
	if (constraint) then
		undo.Create(undoname)
		undo.AddEntity( constraint )
		undo.SetPlayer( self:GetOwner() )
		undo.Finish()
		self:GetOwner():AddCleanup( "constraints", constraint )
	end
end

function TOOL:UndoRepairToggle()
	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then--parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then --not a ragdoll
						if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
						elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
						end
						if ( speeddamp == 0 && angledamp == 0 ) then
							CurrentPhys:SetDamping( 5, 5 )
						elseif ( speeddamp == 5 && angledamp == 5 ) then
							CurrentPhys:SetDamping( 0, 0 )
						end
						CurrentPhys:Wake()
					end
				end
			end
		end
	end
	self.RepairTodo = false
end

function TOOL:DoConstraint(mode)
	self:SetStage(0)
	-- Get information we're about to use
	local Ent1,  Ent2  = self:GetEnt(1),    self:GetEnt(2)

	if ( !Ent1:IsValid() || CLIENT ) then
		self:ClearObjects()
		return false--Something happened to original target, don't continue
	end
	-- Get client's CVars
	local forcelimit 	= self:GetClientNumber( "forcelimit", 0 )
    --local freeze		= util.tobool( self:GetClientNumber( "freeze", 1 ) )
	local nocollide		= self:GetClientNumber( "nocollide", 0 )
	local nocollideall	= util.tobool( self:GetClientNumber( "nocollideall", 0 ) )
	local torquelimit	= self:GetClientNumber( "torquelimit", 0 )
	local width			= self:GetClientNumber( "width", 1 )
	local friction		= self:GetClientNumber( "friction", 0 )
	local physdis		= util.tobool( self:GetClientNumber( "physdisable", 0 ) )
	local ShadowDisable = util.tobool( self:GetClientNumber( "ShadowDisable", 0 ) )
	local autorotate 	= util.tobool(self:GetClientNumber( "autorotate",1 ))
	local removal_nocollide 	= util.tobool(self:GetClientNumber( "removal_nocollide",1 ))
	local removal_weld 	= util.tobool(self:GetClientNumber( "removal_weld",1 ))
	local removal_axis 	= util.tobool(self:GetClientNumber( "removal_axis",1 ))
	local removal_ballsocket 	= util.tobool(self:GetClientNumber( "removal_ballsocket",1 ))
	local removal_advballsocket 	= util.tobool(self:GetClientNumber( "removal_advballsocket",1 ))
	local removal_slider 	= util.tobool(self:GetClientNumber( "removal_slider",1 ))
	local removal_parent 	= util.tobool(self:GetClientNumber( "removal_parent",1 ))
	local removal_other 	= util.tobool(self:GetClientNumber( "removal_other",1 ))
	local Bone1 = self:GetBone(1)
	local LPos1 = self:GetLocalPos(1)
	local Bone2 = nil
	local LPos2 = nil
	if ( Ent2 && (Ent2:IsValid() || Ent2:IsWorld()) ) then
		Bone2 = self:GetBone(2)
		LPos2 = self:GetLocalPos(2)
	end
	local Phys1 = self:GetPhys(1)

	local NumApp = 0


	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then--parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then --not a ragdoll
						if (  util.tobool( nocollide ) && (mode == 1 || mode == 3)) then -- not weld/axis/ballsocket or single application
							local constraint = constraint.NoCollide(CurrentEnt, Ent2, 0, Bone2)
						end
						if ( mode == 1 ) then --Apply
							self:DoApply( CurrentEnt, Ent1, autorotate, nocollideall, ShadowDisable )
						elseif ( mode == 2 ) then --Rotate
							--self:SendMessage("Sorry, No entire contraption rotating... yet")
							--return false--TODO: Entire contrpation rotaton
						elseif ( mode == 3 ) then --move
							--self:SendMessage("Sorry, No entire contraption moving... yet")
							--return false--todo: entire contraption move/snap
						elseif ( mode == 4 ) then --weld
							local constr = constraint.Weld( CurrentEnt, Ent2, 0, Bone2, forcelimit,  util.tobool( nocollide ) )
							self:CreateUndo(constr,"Precision_Weld")
						elseif ( mode == 5 ) then --doaxis
							local constr = constraint.Axis( CurrentEnt, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide )
							self:CreateUndo(constr,"Precision_Axis")
						elseif ( mode == 6 ) then --ballsocket
							-- local constr = constraint.Ballsocket( CurrentEnt, Ent2, 0, Bone2, LPos2, forcelimit, torquelimit, nocollide )
							-- self:CreateUndo(constr,"Precision_Ballsocket")
						elseif ( mode == 7 ) then --adv ballsocket
							-- local constr = constraint.AdvBallsocket( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, forcelimit, torquelimit, self:GetClientNumber( "XRotMin", -180 ), self:GetClientNumber( "YRotMin", -180 ), self:GetClientNumber( "ZRotMin", -180 ), self:GetClientNumber( "XRotMax", 180 ), self:GetClientNumber( "YRotMax", 180 ), self:GetClientNumber( "ZRotMax", 180 ), self:GetClientNumber( "XRotFric", 0 ), self:GetClientNumber( "YRotFric", 0 ), self:GetClientNumber( "ZRotFric", 0 ), self:GetClientNumber( "FreeMov", 0 ), nocollide )
							-- self:CreateUndo(constr,"Precision_Advanced_Ballsocket")
						elseif ( mode == 8 ) then --slider
							-- local constraint0 = constraint.Slider( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, width )
							-- if (constraint0) then
							-- 	undo.Create("Precision_Slider")
							-- 	if ( self:GetClientNumber( "disablesliderfix" ) == 0 ) then
							-- 		local constraint2 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, 0, -180, -180, 0, 180, 180, 50, 0, 0, 1, 0 )
							-- 		if (constraint2) then
							-- 			undo.AddEntity( constraint2 )
							-- 		end
							-- 		local constraint3 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, 0, -180, 180, 0, 180, 0, 50, 0, 1, 0 )
							-- 		if (constraint3) then
							-- 			undo.AddEntity( constraint3 )
							-- 		end
							-- 		local constraint4 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, -180, 0, 180, 180, 0, 0, 0, 50, 1, 0 )
							-- 		if (constraint4) then
							-- 			undo.AddEntity( constraint4 )
							-- 		end
							-- 	end
							-- 	undo.AddEntity( constraint0 )
							-- 	undo.SetPlayer( self:GetOwner() )
							-- 	undo.Finish()
							-- 	self:GetOwner():AddCleanup( "constraints", constraint0 )
							-- end
						elseif ( mode == 9 ) then --Parent
							-- self:DoParent( CurrentEnt, Ent2 )
						elseif ( mode == 10 && !self.RepairTodo ) then--Repair spaz
							if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
							elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
							end
								--CurrentPhys:EnableGravity( !CurrentPhys:IsGravityEnabled() )--Can't disable gravity - sliders would go nuts and disappear.	
							local speeddamp,angledamp = CurrentPhys:GetDamping()
							if ( speeddamp == 0 && angledamp == 0 ) then
								CurrentPhys:SetDamping( 5, 5 )
							elseif ( speeddamp == 5 && angledamp == 5 ) then
								CurrentPhys:SetDamping( 0, 0 )
							end
							CurrentEnt:SetPos(CurrentEnt:GetPos())
							CurrentPhys:Wake()
						elseif ( mode == 11 ) then --Removal
							if ( CLIENT ) then return true end--? should probably be in more places
							if ( removal_nocollide ) then
								constraint.RemoveConstraints( CurrentEnt, "NoCollide" )
								CurrentPhys:EnableCollisions(true)
							end
							if ( removal_weld ) then
								constraint.RemoveConstraints( CurrentEnt, "Weld" )
							end
							if ( removal_axis ) then
								constraint.RemoveConstraints( CurrentEnt, "Axis" )
							end
							if ( removal_ballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "Ballsocket" )
							end
							if ( removal_advballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "AdvBallsocket" )
							end
							if ( removal_slider ) then
								constraint.RemoveConstraints( CurrentEnt, "Slider" )
							end
							if ( removal_parent) then
								if ( CurrentEnt:GetParent():IsValid() ) then
									self:UndoParent( CurrentEnt )
								end
							end
							if ( removal_other ) then
								constraint.RemoveConstraints( CurrentEnt, "Elastic" )
								constraint.RemoveConstraints( CurrentEnt, "Hydraulic" )
								constraint.RemoveConstraints( CurrentEnt, "Keepupright" )
								constraint.RemoveConstraints( CurrentEnt, "Motor" )
								constraint.RemoveConstraints( CurrentEnt, "Muscle" )
								constraint.RemoveConstraints( CurrentEnt, "Pulley" )
								constraint.RemoveConstraints( CurrentEnt, "Rope" )
								constraint.RemoveConstraints( CurrentEnt, "Winch" )
							end
						end
					end
				end
			end
		end
		NumApp = NumApp + 1
	end--Next
	if ( mode == 1 ) then
		self:SendMessage( NumApp .. " items targeted for apply." )
	elseif ( mode == 2 ) then
		self:SendMessage( NumApp .. " items targeted for rotate." )
	elseif ( mode == 3 ) then
		self:SendMessage( NumApp .. " items targeted for move." )
	elseif ( mode == 4 ) then
		self:SendMessage( NumApp .. " items targeted for weld." )
	elseif ( mode == 5 ) then
		self:SendMessage( NumApp .. " items targeted for axis." )
	elseif ( mode == 6 ) then
		-- self:SendMessage( NumApp .. " items targeted for ballsocket." )
	elseif ( mode == 7 ) then
		-- self:SendMessage( NumApp .. " items targeted for adv. ballsocket." )
	elseif ( mode == 8 ) then
		-- self:SendMessage( NumApp .. " items targeted for slider." )
	elseif ( mode == 9 ) then
		-- self:SendMessage( NumApp .. " items targeted for parenting." )
	elseif ( mode == 10 ) then
		self:SendMessage( NumApp .. " items targeted for repair." )
	elseif ( mode == 11 ) then
		self:SendMessage( NumApp .. " items targeted for constraint removal." )
	end


	if ( mode == 10 ) then
		self.RepairTodo = true
		timer.Simple( 1.0, function()
		self:ClearSelection()
		end)
	else
		self:ClearSelection()
	end
	-- Clear the objects so we're ready to go again
	self:ClearObjects()
end

function TOOL:SendMessage( message )
	if ( self:GetClientNumber( "enablefeedback" ) == 0 ) then return end
	if ( self:GetClientNumber( "chatfeedback" ) == 1 ) then
		self:GetOwner():PrintMessage( HUD_PRINTTALK, "Tool: " .. message )
	else
		self:GetOwner():PrintMessage( HUD_PRINTCENTER, message )
	end
end

function TOOL:TargetValidity ( trace, Phys ) --TODO: Parented stuff should return 1
	if ( SERVER && (!util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) || !Phys:IsValid()) ) then
		local mode = self:GetClientNumber( "mode" )
		if ( trace.Entity:GetParent():IsValid() ) then
			return 2--Valid parent, but itself isn't
		else
			return 0--No valid phys
		end
	elseif ( trace.Entity:IsPlayer() ) then
		return 0-- Don't attach players, or to players
	elseif ( trace.HitWorld ) then
		return 1-- Only allow second click to be here...
	else
		return 3--Everything seems good
	end
end

function TOOL:StartRotate()
	local Ent = self:GetEnt(1)
	local Phys = self:GetPhys(1)
	local oldposu = Ent:GetPos()
	local oldangles = Ent:GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end

	if ( self:GetClientNumber( "rotateundo" )) then
		if SERVER then
			undo.Create("Precision_Rotate")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( MoveUndo, Ent, oldposu, oldangles )
			undo.Finish()
		end
	end

	if IsValid( Phys ) then
		Phys:EnableMotion( false ) --else it drifts
	end

	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	self.axis = self:GetNormal(1)
	self.axisY = self.axis:Cross(Ent:GetUp())
	if self:WithinABit( self.axisY, Vector(0,0,0) ) then
		self.axisY = self.axis:Cross(Ent:GetForward())
	end
	self.axisZ = self.axisY:Cross(self.axis)
	self.realdegrees = 0
	self.lastdegrees = -((rotation/2) % rotation)
	self.realdegreesY = 0
	self.lastdegreesY = -((rotation/2) % rotation)
	self.realdegreesZ = 0
	self.lastdegreesZ = -((rotation/2) % rotation)
	self.OldPos = self:GetPos(1)--trace.HitPos
end

function TOOL:DoMove()
	-- Get information we're about to use
	local Norm1, Norm2 = self:GetNormal(1),   self:GetNormal(2)
	local Phys1, Phys2 = self:GetPhys(1),     self:GetPhys(2)

	local Ang1, Ang2 = Norm1:Angle(), (Norm2 * -1):Angle()
	if self:GetClientNumber( "autorotate" ) == 1 then
		Ang2.p = (math.Round(Ang2.p/45))*45
		Ang2.r = (math.Round(Ang2.r/45))*45
		Ang2.y = (math.Round(Ang2.y/45))*45
		Norm2 = Ang2:Forward() * -1
	end


	local oldposu = self:GetEnt(1):GetPos()
	local oldangles = self:GetEnt(1):GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	if self:GetClientNumber( "moveundo" ) == 1 then
	undo.Create("Precision Move")
		undo.SetPlayer(self:GetOwner())
		undo.AddFunction( MoveUndo, self:GetEnt(1), oldposu, oldangles )
	undo.Finish()
	end

	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	if ( (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2) then--Set axies for rotation mode directions
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
		self.realdegrees = 0
		self.lastdegrees = -((rotation/2) % rotation)
		self.realdegreesY = 0
		self.lastdegreesY = -((rotation/2) % rotation)
		self.realdegreesZ = 0
		self.lastdegreesZ = -((rotation/2) % rotation)
	else
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
	end



	local TargetAngle = Phys1:AlignAngles( Ang1, Ang2 )--Get angle Phys1 would be at if difference between Ang1 and Ang2 was added


	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end

	Phys1:SetAngles( TargetAngle )


	local NewOffset = math.Clamp( self:GetClientNumber( "offset" ), -100, 100 )
	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	if ( offsetpercent ) then
		local  Ent2  = self:GetEnt(2)
		local glower = Ent2:OBBMins()
		local gupper = Ent2:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(Norm2,Ent2:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(Norm2,Ent2:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end
	Norm2 = Norm2 * (-0.0625 + NewOffset)
	local TargetPos = self:GetPos(2) + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
	--self:SetPos(2)

	-- Set the position

	Phys1:SetPos( TargetPos )
	Phys1:EnableMotion( false )

	-- Wake up the physics object so that the entity updates
	Phys1:Wake()
end

function TOOL:ToggleColor( CurrentEnt )
	color = CurrentEnt:GetColor()
	color["a"] = color["a"] - 128
	if ( color["a"] < 0 ) then
		color["a"] = color["a"] + 256
	end
	color["r"] = color["r"] - 128
	if ( color["r"] < 0 ) then
		color["r"] = color["r"] + 256
	end
	color["g"] = color["g"] - 128
	if ( color["g"] < 0 ) then
		color["g"] = color["g"] + 256
	end
	color["b"] = color["b"] - 128
	if ( color["b"] < 0 ) then
		color["b"] = color["b"] + 256
	end
	CurrentEnt:SetColor( color )
	if ( color["a"] == 255 ) then
		CurrentEnt:SetRenderMode( 0 )
	else
		CurrentEnt:SetRenderMode( 1 )
	end
end

function TOOL:ClearSelection()
	if ( self.RepairTodo ) then
		self:UndoRepairToggle()
	end
	if ( self.TaggedEnts ) then
		local color
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
		end
	end
	self.TaggedEnts = {}
end

function TOOL:SelectEnts(StartEnt, AllConnected)
	self:ClearSelection()
	if ( CLIENT ) then return end
	local color
	if ( AllConnected == 1 ) then
		local NumApp = 0
		EntsTab = {}
		ConstsTab = {}
		GetAllEnts(StartEnt, self.TaggedEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
			NumApp = NumApp + 1
		end
		self:SendMessage( NumApp .. " objects selected." )
	else
		if ( StartEnt and StartEnt:IsValid() ) then
			local CurrentPhys = StartEnt:GetPhysicsObject()
			if ( CurrentPhys:IsValid() ) then
				table.insert(self.TaggedEnts, StartEnt)
				self:ToggleColor(StartEnt)
			end
		end
	end
end

function TOOL:LeftClick( trace )
	local stage = self:GetStage()--0 = started, 1 = moving/second target, 2 = rotation?
	local mode = self:GetClientNumber( "mode" )
	local moving = ( mode == 3 || (self:GetClientNumber( "move" ) == 1 && mode >= 3 && mode <= 8 ) )
	local rotating = ( self:GetClientNumber( "rotate" ) == 1 )
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )


	if ( stage == 0 ) then--first click - choose a target.
		if ( self:TargetValidity(trace, Phys) <= 1 ) then
			return false--No phys or hit world
		end
		self:SetObject( 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )

		if (self:GetClientNumber( "entirecontrap" ) == 1 || mode == 10 ) then
			self:SelectEnts(trace.Entity,1)
		else
			self:SelectEnts(trace.Entity,0)
		end
		if ( mode == 1 || mode == 10 || mode == 11 ) then --Don't care about stage, always apply.
			self:DoConstraint(mode)
		else
			if ( mode == 9 ) then
				self:SetStage(1)
			else
				if ( moving ) then--Moving
					self:StartGhostEntity( trace.Entity )
					self:SetStage(1)
				elseif ( mode == 2 ) then--Straight to rotate
					self:StartRotate()
					self:SetStage(2)
				else
					self:SetStage(1)
				end
			end
		end
	elseif ( stage == 1 ) then--Second click
		self:SetObject( 2, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )

		if ( self:GetEnt(1) == self:GetEnt(2) ) then
			SavedPos = self:GetPos(2)
		end
		if ( mode == 9 ) then
			-- self:DoConstraint(mode)
		else
			if ( moving ) then
				if ( CLIENT ) then
					self:ReleaseGhostEntity()
					return true
				end
				if ( SERVER && !game.SinglePlayer() ) then
					self:ReleaseGhostEntity()
					--return true
				end
				self:DoMove()
			end
			if ( rotating ) then
				self:StartRotate()
				self:SetStage(2)
			else
				self:DoConstraint(mode)
			end
		end
	elseif ( stage == 2 ) then--Done rotate
		self:DoConstraint(mode)
	end
	return true
end

function TOOL:WithinABit( v1, v2 )
	local tol = 0.1
	local da = v1.x-v2.x
	local db = v1.y-v2.y
	local dc = v1.z-v2.z
	if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
		return true
	else
		da = v1.x+v2.x
		db = v1.y+v2.y
		dc = v1.z+v2.z
		if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
			return true
		else
			return false
		end
	end
end

if ( SERVER ) then

	function GetAllEnts( Ent, OrderedEntList, EntsTab, ConstsTab )
		if ( Ent and Ent:IsValid() ) and ( !EntsTab[ Ent:EntIndex() ] ) then
			EntsTab[ Ent:EntIndex() ] = Ent
			table.insert(OrderedEntList, Ent)
			if ( !constraint.HasConstraints( Ent ) ) then return OrderedEntList end
			for key, ConstraintEntity in pairs( Ent.Constraints ) do
				if ( !ConstsTab[ ConstraintEntity ] ) then
					ConstsTab[ ConstraintEntity ] = true
					local ConstTable = ConstraintEntity:GetTable()
					for i=1, 6 do
						local e = ConstTable[ "Ent"..i ]
						if ( e and e:IsValid() ) and ( !EntsTab[ e:EntIndex() ] ) then
							GetAllEnts( e, OrderedEntList, EntsTab, ConstsTab )
						end
					end
				end
			end
		end
		return OrderedEntList
	end

	function GetAllConstraints( EntsTab )
		local ConstsTab = {}
		for key, Ent in pairs( EntsTab ) do
			if ( Ent and Ent:IsValid() ) then
				local MyTable = constraint.GetTable( Ent )
				for key, Constraint in pairs( MyTable ) do
					if ( !ConstsTab[ Constraint.Constraint ] ) then
						ConstsTab[ Constraint.Constraint ] = Constraint
					end
				end
			end
		end
		return ConstsTab
	end
end

function TOOL:UpdateCustomGhost( ghost, player, offset )

	-- Ghost is identically buggy to that of easyweld...  welding two frozen props and two unfrozen props yields different ghosts even if identical allignment

	if (ghost == nil) then return end
	if (!ghost:IsValid()) then ghost = nil return end

	local tr = util.GetPlayerTrace( player, player:GetAimVector() )
	local trace = util.TraceLine( tr )
	if (!trace.Hit) then return end

	local Ang1, Ang2 = self:GetNormal(1):Angle(), (trace.HitNormal * -1):Angle()
	local TargetAngle = self:GetEnt(1):AlignAngles( Ang1, Ang2 )

	self.GhostEntity:SetPos( self:GetEnt(1):GetPos() )

	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end
	self.GhostEntity:SetAngles( TargetAngle )

	local TraceNormal = trace.HitNormal

	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(TraceNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x) -0.5
		elseif self:WithinABit(TraceNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y) -0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end

	local TranslatedPos = ghost:LocalToWorld( self:GetLocalPos(1) )
	local TargetPos = trace.HitPos + (self:GetEnt(1):GetPos() - TranslatedPos) + (TraceNormal*NewOffset)

	self.GhostEntity:SetPos( TargetPos )
end

function TOOL:Think()
	--if CLIENT then return end
	local pl = self:GetOwner()
	local wep = pl:GetActiveWeapon()
	if not wep:IsValid() or wep:GetClass() != "gmod_tool" or pl:GetInfo("gmod_toolmode") != "precision" then return end

	if (self:NumObjects() < 1) then return end
	local Ent1 = self:GetEnt(1)
	if ( SERVER ) then
		if ( !Ent1:IsValid() ) then
			self:ClearObjects()
			return
		end
	end
	local mode = self:GetClientNumber( "mode" )

	if self:NumObjects() == 1 && mode != 2 then
		if ( (self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
			if ( mode <= 8 ) then--no move = no ghost in parent mode
				local offset = math.Clamp( self:GetClientNumber( "offset" ), -100, 100 )
				self:UpdateCustomGhost( self.GhostEntity, self:GetOwner(), offset )
			end
		end
	else
		local rotate = (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2
		if ( SERVER && rotate && mode <= 8 ) then
			local offset = math.Clamp( self:GetClientNumber( "offset" ), -100, 100 )

			local Phys1 = self:GetPhys(1)

			local cmd = self:GetOwner():GetCurrentCommand()

			local rotation		= self:GetClientNumber( "rotation" )
			if ( rotation < 0.02 ) then rotation = 0.02 end
			local degrees = cmd:GetMouseX() * 0.02

			local newdegrees = 0
			local changedegrees = 0

			local angle = 0
			if( self:GetOwner():KeyDown( IN_RELOAD ) ) then
				self.realdegreesY = self.realdegreesY + degrees
				newdegrees =  self.realdegreesY - ((self.realdegreesY + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesY - newdegrees
				self.lastdegreesY = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisY , changedegrees )
			elseif( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then
				self.realdegreesZ = self.realdegreesZ + degrees
				newdegrees =  self.realdegreesZ - ((self.realdegreesZ + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesZ - newdegrees
				self.lastdegreesZ = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisZ , changedegrees )
			else
				self.realdegrees = self.realdegrees + degrees
				newdegrees =  self.realdegrees - ((self.realdegrees + (rotation/2)) % rotation)
				changedegrees = self.lastdegrees - newdegrees
				self.lastdegrees = newdegrees
				angle = Phys1:RotateAroundAxis( self.axis , changedegrees )
			end
			Phys1:SetAngles( angle )

			if ( ( self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
				local WPos2 = self:GetPos(2)
				local Ent2 = self:GetEnt(2)
				-- Move so spots join up
				local Norm2 = self:GetNormal(2)

				local NewOffset = offset
				local offsetpercent	= self:GetClientNumber( "offsetpercent" ) == 1
				if ( offsetpercent ) then
					local glower = Ent2:OBBMins()
					local gupper = Ent2:OBBMaxs()
					local height = math.abs(gupper.z - glower.z) -0.5
					if self:WithinABit(Norm2,Ent2:GetForward()) then
						height = math.abs(gupper.x - glower.x) -0.5
					elseif self:WithinABit(Norm2,Ent2:GetRight()) then
						height = math.abs(gupper.y - glower.y) -0.5
					end
					NewOffset = NewOffset / 100
					NewOffset = NewOffset * height
				end

				Norm2 = Norm2 * (-0.0625 + NewOffset)
				local TargetPos = Vector(0,0,0)
				if ( self:GetEnt(1) == self:GetEnt(2) ) then
	------------------------------------------
					TargetPos = SavedPos + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				else
					TargetPos = WPos2 + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				end
				Phys1:SetPos( TargetPos )
			else
				-- Move so rotating on axis

				local TargetPos = (Phys1:GetPos() - self:GetPos(1)) + self.OldPos
				Phys1:SetPos( TargetPos )
			end
			Phys1:Wake()
		end
	end
end

function TOOL:Nudge( trace, direction )
	if (!trace.Entity:IsValid() || trace.Entity:IsPlayer() ) then return false end
	local Phys1 = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	local offsetpercent		= self:GetClientNumber( "nudgepercent" ) == 1
	local offset		= self:GetClientNumber( "nudge", 100 )
	local max = 8192
	if ( offsetpercent != 1 ) then
		if ( offset > max ) then
			offset = max
		elseif ( offset < -max ) then
			offset = -max
		end
	end
	--if ( offset == 0 ) then offset = 1 end
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(trace.HitNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(trace.HitNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		local cap = math.floor(max / height)--No more than max units.
		if ( NewOffset > cap ) then
			NewOffset = cap
		elseif ( NewOffset < -cap ) then
			NewOffset = -cap
		end
		NewOffset = NewOffset * height
	end

	if ( self:GetClientNumber( "entirecontrap" ) == 1 ) then
		local NumApp = 0
		local TargetEnts = {}
		local EntsTab = {}
		local ConstsTab = {}
		GetAllEnts(trace.Entity, TargetEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(TargetEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then

					--[[if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
						local oldpos = CurrentPhys:GetPos()
						local function NudgeUndo( Undo, Entity, oldpos )
							if CurrentEnt:IsValid() then
								CurrentEnt:SetPos( oldpos )
							end
						end
						undo.Create("Nrecision Nudge")
							undo.SetPlayer(self:GetOwner())
							undo.AddFunction( NudgeUndo, CurrentEnt, oldpos )
						undo.Finish()
					end]] -- todo: all in 1 undo for mass nudging

					local TargetPos = CurrentPhys:GetPos() + trace.HitNormal * NewOffset * direction
					CurrentPhys:SetPos( TargetPos )
					CurrentPhys:Wake()
					if (CurrentEnt:GetMoveType() == 0 ) then --phys disabled, so move manually
						CurrentEnt:SetPos( TargetPos )
					end

				end
			end
			NumApp = NumApp + 1
		end
		if ( direction == -1 ) then
			self:SendMessage( NumApp .. " items pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( NumApp .. " items pulled." )
		else
			self:SendMessage( NumApp .. " items nudged." )
		end
	else
		if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
			local oldpos = Phys1:GetPos()
			local function NudgeUndo( Undo, Entity, oldpos )
				if trace.Entity:IsValid() then
					trace.Entity:SetPos( oldpos )
				end
			end
			undo.Create("Precision PushPull")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( NudgeUndo, trace.Entity, oldpos )
			undo.Finish()
		end
		local TargetPos = Phys1:GetPos() + trace.HitNormal * NewOffset * direction
		Phys1:SetPos( TargetPos )
		Phys1:Wake()
		if ( trace.Entity:GetMoveType() == 0 ) then
			trace.Entity:SetPos( TargetPos )
		end
		if ( direction == -1 ) then
			self:SendMessage( "target pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( "target pulled." )
		else
			self:SendMessage( "target nudged." )
		end
	end
	return true
end

function TOOL:RightClick( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, -1 )
	end
end

function TOOL:Reload( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, 1 )
	end
end

if CLIENT then
	language.Add( "Tool.precision.name", "Precision Tool 0.98e" )
	language.Add( "Tool.precision.desc", "Accurately moves/constrains objects" )
	language.Add( "Tool.precision.0", "Primary: Move/Apply | Secondary: Push | Reload: Pull" )
	language.Add( "Tool.precision.1", "Target the second item. If enabled, this will move the first item.  (Swap weps to cancel)" )
	language.Add( "Tool.precision.2", "Rotate enabled: Turn left and right to rotate the object (Hold Reload or Secondary for other rotation directions!)" )


	language.Add("Undone.precision", "Undone Precision Constraint")
	language.Add("Undone.precision.nudge", "Undone Precision PushPull")
	language.Add("Undone.precision.rotate", "Undone Precision Rotate")
	language.Add("Undone.precision.move", "Undone Precision Move")
	language.Add("Undone.precision.weld", "Undone Precision Weld")
	language.Add("Undone.precision.axis", "Undone Precision Axis")
	language.Add("Undone.precision.ballsocket", "Undone Precision Ballsocket")
	language.Add("Undone.precision.advanced.ballsocket", "Undone Precision Advanced Ballsocket")
	language.Add("Undone.precision.slider", "Undone Precision Slider")

	local showgenmenu = 0--Seems to hide often, probably for the best

	local function AddDefControls( Panel )
		Panel:ClearControls()

		Panel:AddControl("ComboBox",
		{
			Label = "#Presets",
			MenuButton = 1,
			Folder = "precision",
			Options = {},
			CVars =
			{
				[0] = "precision_offset",
				[1] = "precision_forcelimit",
				[2] = nil,
				[3] = "precision_nocollide",
				[4] = "precision_nocollideall",
				[5] = "precision_rotation",
				[6] = "precision_rotate",
				[7] = "precision_torquelimit",
				[8] = "precision_friction",
				[9] = "precision_mode",
				[10] = "precision_width",
				[11] = "precision_offsetpercent",
				[12] = "precision_removal",
				[13] = "precision_move",
				[14] = "precision_physdisable",
				[15] = "precision_advballsocket",
				[16] = "precision_XRotMin",
				[17] = "precision_XRotMax",
				[18] = "precision_YRotMin",
				[19] = "precision_YRotMax",
				[20] = "precision_ZRotMin",
				[21] = "precision_ZRotMax",
				[22] = "precision_XRotFric",
				[23] = "precision_YRotFric",
				[24] = "precision_ZRotFric",
				[25] = "precision_FreeMov",
				[26] = "precision_ShadowDisable",
				[27] = "precision_allowphysgun",
				[28] = "precision_autorotate",
				[29] = "precision_massmode",
				[30] = "precision_nudge",
				[31] = "precision_nudgepercent",
				[32] = "precision_disablesliderfix"
			}
		})

		--Panel:AddControl( "Label", { Text = "Secondary attack pushes, Reload pulls by this amount:", Description	= "Phx 1x is 47.45, Small tiled cube is 11.8625 and thin is 3 exact units" }  )
		Panel:AddControl( "Slider",  { Label	= "Push/Pull Amount",
					Type	= "Float",
					Min		= 1,
					Max		= 100,
					Command = "precision_nudge",
					Description = "Distance to push/pull props with altfire/reload"}	 ):SetDecimals( 4 )


		Panel:AddControl( "Checkbox", { Label = "Push/Pull as Percent (%) of target's depth", Command = "precision_nudgepercent", Description = "Unchecked = Exact units, Checked = takes % of width from target prop when pushing/pulling" } )


		local user = LocalPlayer():GetInfoNum( "precision_user", 0 )
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 0 )
		--Panel:AddControl( "Label", { Text = "Primary attack uses the tool's main mode.", Description	= "Select a mode and configure the options, be sure to try new things out!" }  )

		local list = vgui.Create("DListView")

		--17 per item + 16 for title
		local height = 203 --All 11 shown
		if ( user < 2 ) then
			height = 135 --7 shown
		elseif ( user < 3 ) then
			height = 170 --9 shown
		end


		list:SetSize(30,height)
		--list:SizeToContents()
		list:AddColumn("Tool Mode")
		list:SetMultiSelect(false)
		function list:OnRowSelected(LineID, line)
			if not (mode == LineID) then
				RunConsoleCommand("precision_setmode", LineID)
			end
		end

		if ( mode == 1 ) then
			list:AddLine(" 1 ->Apply<- (Directly apply settings to target)")
		else
			list:AddLine(" 1   Apply   (Directly apply settings to target)")
		end
		if ( mode == 2 ) then
			list:AddLine(" 2 ->Rotate<- (Turn an object without moving it)")
		else
			list:AddLine(" 2   Rotate   (Turn an object without moving it)")
		end
		if ( mode == 3 ) then
			list:AddLine(" 3 ->Move<- (Snap objects together - Great for building!)")
		else
			list:AddLine(" 3   Move   (Snap objects together - Great for building!)")
		end
		if ( mode == 4 ) then
			list:AddLine(" 4 ->Weld<-")
		else
			list:AddLine(" 4   Weld")
		end
		if ( mode == 5 ) then
			list:AddLine(" 5 ->Axis<-")
		else
			list:AddLine(" 5   Axis")
		end
		if ( mode == 6 ) then
			list:AddLine(" 6 ->Ballsocket<-")
		else
			list:AddLine(" 6   Ballsocket")
		end
		if ( user >= 2 ) then
			if ( mode == 7 ) then
				list:AddLine(" 7 ->Adv Ballsocket<-")
			else
				list:AddLine(" 7   Adv Ballsocket")
			end
			if ( mode == 8 ) then
				list:AddLine(" 8 ->Slider<-")
			else
				list:AddLine(" 8   Slider")
			end
		end
		if ( user >= 3 ) then
			if ( mode == 9 ) then
				list:AddLine(" 9 ->Parent<- (Like a solid weld, but without object collision)")
			else
				list:AddLine(" 9   Parent   (Like a solid weld, but without object collision)")
			end
			if ( mode == 10 ) then
				list:AddLine("10 ->Repair<- (Attempts to fix a flailing contraption)")
			else
				list:AddLine("10   Repair   (Attempts to fix a flailing contraption)")
			end
		end
		if ( mode == 11 ) then
			list:AddLine("11 ->Removal<- (Undoes constraints from target)")
		else
			list:AddLine("11   Removal   (Undoes constraints from target)")
		end
		list:SortByColumn(1)
		Panel:AddItem(list)

		if ( mode >= 4 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Move Target? ('Easy' constraint mode)", Command = "precision_move", Description = "Uncheck this to apply the constraint without altering positions." } )
		end
		if (  mode >= 3 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Rotate Target? (Rotation after moving)", Command = "precision_rotate", Description = "Uncheck this to remove the extra click for rotation. Handy for speed building." } )
			--Panel:AddControl( "Label", { Text = "This is the distance from touching of the targeted props after moving:", Description	= "Use 0 mostly, % takes the second prop's width." }  )
			Panel:AddControl( "Slider",  { Label	= "Snap Distance",
					Type	= "Float",
					Min		= 0,
					Max		= 10,
					Command = "precision_offset",
					Description = "Distance offset between joined props.  Type in negative to inset when moving."}	 )
			Panel:AddControl( "Checkbox", { Label = "Snap distance as Percent (%) of target's depth", Command = "precision_offsetpercent", Description = "Unchecked = Exact units, Checked = takes % of width from second prop" } )
		end
		if ( mode >= 2 && mode <= 8 ) then
			Panel:AddControl( "Slider",  { Label	= "Rotation Snap (Degrees)",
					Type	= "Float",
					Min		= 0.02,
					Max		= 90,
					Command = "precision_rotation",
					Description = "Rotation rotates by this amount at a time. No more guesswork. Min: 0.02 degrees "}	 ):SetDecimals( 4 )
		end
		if ( mode <= 8 ) then

			if ( mode >= 3 && mode <= 8 ) then
				Panel:AddControl( "Checkbox", { Label = "No Collide Targets", Command = "precision_nocollide", Description = "Nocollide pairs of props when this tool is used. Note: No current way to remove this constraint when used alone."  } )
			end
		end

		if ( user >= 2 || mode == 1 ) then
			if ( (mode >= 3 && mode <= 8) || mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Auto-align to world (nearest 45 degrees)", Command = "precision_autorotate", Description = "Rotates to the nearest world axis (similar to holding sprint and use with physgun)"  } )
			end

			if ( mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Disable target shadow", Command = "precision_ShadowDisable", Description = "Disables shadows cast from the prop"  } )
			end
		end

		if ( user >= 3 ) then
			if ( mode == 1 ) then --apply
				Panel:AddControl( "Checkbox", { Label = "Only Collide with Player", Command = "precision_nocollideall", Description = "Nocollides the first prop to everything and the world (except players collide with it). Warning: don't let it fall away through the world."  } )
				Panel:AddControl( "Checkbox", { Label = "Disable Physics on object", Command = "precision_physdisable", Description = "Disables physics on the first prop (gravity, being shot etc won't effect it)"  } )
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on PhysDisable objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use if you want to be able to manually move props after phyics disabling them (may break clipboxes)."  } )

				--Panel:AddControl( "Checkbox", { Label = "Drag", Command = "precision_drag", Description = ""  } )
			end
			if ( mode == 9 ) then --parent
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on Parented objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use this if you want to play with the parenting hierarchy etc."  } )
			end
		end
		if ( user >= 2 ) then
			if ( mode != 2 && mode != 3 && mode != 10 ) then --todo: entire contrap move/rotate support
				Panel:AddControl( "Checkbox", { Label = "Entire Contraption! (Everything connected to target)", Command = "precision_entirecontrap", Description = "For mass constraining or removal or nudging or applying of things. Yay generic."  } )
			end
		end

		if ( user >= 2 ) then
			if ( (mode >= 4 && mode <= 7) ) then --breakable constraint
				Panel:AddControl( "Slider",  { Label	= "Force Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_forcelimit",
						Description = "Applies to most constraint modes" }	 )
			end


			if ( mode == 5 || mode == 6 || mode == 7 ) then --axis or ballsocket
				Panel:AddControl( "Slider",  { Label	= "Torque Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_torquelimit",
						Description = "Breakpoint of turning/rotational force"}	 )
			end
		end

		if ( mode == 5 ) then --axis
			Panel:AddControl( "Slider",  { Label	= "Axis Friction",
					Type	= "Float",
					Min		= 0.0,
					Max		= 100,
					Command = "precision_friction",
					Description = "Turning resistance, this is best at 0 in most cases to conserve energy"}	 )
		end

		if ( mode ==7 ) then --adv ballsocket
			Panel:AddControl( "Slider",  { Label	= "X Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMin",
					Description = "Rotation minimum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMax",
					Description = "Rotation maximum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMin",
					Description = "Rotation minimum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMax",
					Description = "Rotation maximum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMin",
					Description = "Rotation minimum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMax",
					Description = "Rotation maximum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_XRotFric",
					Description = "Rotation friction of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_YRotFric",
					Description = "Rotation friction of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_ZRotFric",
					Description = "Rotation friction of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Checkbox", { Label = "Free Movement", Command = "precision_FreeMov", Description = "Only lock relative rotation, not position?"  } )
		end

		if ( mode == 8 ) then --slider
			-- Panel:AddControl( "Slider",  { Label	= "Slider Width",
			-- 		Type	= "Float",
			-- 		Min		= 0.0,
			-- 		Max		= 10,
			-- 		Command = "precision_width",
			-- 		Description = "Width of the slider black line (0 = invisible)"}	 )

			-- Panel:AddControl( "Checkbox", { Label = "Turn Off Minor Slider Stabilisation", Command = "precision_disablesliderfix", Description = "Fix being separate X/Y/Z advanced ballsocket locks between the props.  This stops most spaz caused by rotation, but not spaz caused by displacement." } )
			-- Panel:AddControl( "Label", { Text = "Stabilisation is separate X/Y/Z adv. ballsockets; it makes it far less prone to rotation triggered spaz, but the difference is only noticeable sometimes as it's still just as prone to spaz caused by drifting.", Description	= "Due to lack of working descriptions at time of coding" }  )
		end

		if ( mode == 9 ) then --parent
			Panel:AddControl( "Label", { Text = "Parenting Notes:", Description	= "Due to lack of working descriptions at time of coding" }  )
			Panel:AddControl( "Label", { Text = "Parenting objects is most similar to a very strong weld, but it stops most interaction on the first object when you attach it to the second.  Players can walk on it, but it will fall through players.  It will not collide with objects or the world.  It will also not cause any extra physics lag/spaz.  Try it out on a test object, and decide if it's useful to you!", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Parented objects are most useful for: Adding detail to moving objects without creating extra physics lag.  Things like houses that you want to move (though you can only safely walk on parented objects when they are still.)", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Possible issues:  Remove constraints first to avoid spaz. Duplicating or such may cause the collision model to become separated.  Best to test it if in doubt.", Description	= "Why must labels cause menu flicker? D:" }  )
		end

		if ( mode == 10 ) then --repair
			Panel:AddControl( "Label", { Text = "Repair mode", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Usage: When a contraption is going crazy, colliding, making rubbing noises.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "What it does: Temporarily toggles collisions, allowing things that are bent out of shape to pop back.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Warning: No guarantees.  This may turn things inside-out or make things worse depending on the situation.", Description	= "" }  )
		end
		if ( mode == 11 ) then --removal
			Panel:AddControl( "Label", { Text = "This mode will remove:", Description	= "" }  )
			Panel:AddControl( "Checkbox", { Label = "Nocollide", Command = "precision_removal_nocollide", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Weld", Command = "precision_removal_weld", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Axis", Command = "precision_removal_axis", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Ballsocket", Command = "precision_removal_ballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Adv. Ballsocket", Command = "precision_removal_advballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Slider", Command = "precision_removal_slider", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Parent", Command = "precision_removal_parent", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Other", Command = "precision_removal_other", Description = "" } )
			Panel:AddControl( "Label", { Text = "(Other = Rope/slider variants like winch/hydraulic, also motor/keepupright)", Description	= "" }  )
			Panel:AddControl( "Button", { Label = "Select All", Command = "precision_removal_all", Description = ""  } )
			Panel:AddControl( "Button", { Label = "Select None", Command = "precision_removal_none", Description = ""  } )

		end
		if ( showgenmenu == 1 ) then
			Panel:AddControl( "Button", { Label = "\\/ General Tool Options \\/", Command = "precision_generalmenu", Description = "Collapse menu"  } )




		local params = {Label = "User Level",Description = "Shows options appropriate to user experience level", MenuButton = "0", Height = 67, Options = {}}
		if ( user == 1 ) then
			params.Options[" 1 ->Normal<-"] = { precision_setuser = "1" }
		else
			params.Options[" 1   Normal"] = { precision_setuser = "1" }
		end
		if ( user == 2 ) then
			params.Options[" 2 ->Advanced<-"] = { precision_setuser = "2" }
		else
			params.Options[" 2   Advanced"] = { precision_setuser = "2" }
		end
		if ( user == 3 ) then
			params.Options[" 3 ->Experimental<-"] = { precision_setuser = "3" }
		else
			params.Options[" 3   Experimental"] = { precision_setuser = "3" }
		end

		Panel:AddControl( "ListBox", params )

			--Panel:AddControl( "Label", { Text = "General Tool Options:", Description	= "Note: These don't save with presets." }  )
			Panel:AddControl( "Checkbox", { Label = "Enable tool feedback messages?", Command = "precision_enablefeedback", Description = "Toggle for feedback messages incase they get annoying"  } )
			Panel:AddControl( "Checkbox", { Label = "On = Feedback in Chat, Off = Centr Scrn", Command = "precision_chatfeedback", Description = "Chat too cluttered? Can have messages centre screen instead"  } )
			--Panel:AddControl( "Checkbox", { Label = "Hide Menu Tips?", Command = "precision_hidehints", Description = "Streamline the menu once you're happy with using the tool."  } )
			Panel:AddControl( "Checkbox", { Label = "Add Push/Pull to Undo List", Command = "precision_nudgeundo", Description = "For if you're in danger of nudging somthing to where you can't reach it"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Movement to Undo List", Command = "precision_moveundo", Description = "So you don't have to secondary fire with nocollide to undo mistakes"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Rotation to Undo List", Command = "precision_rotateundo", Description = "So you can find the exact rotation value easier"  } )
			Panel:AddControl( "Button", { Label = "Restore Current Mode Default", Command = "precision_defaultrestore", Description = "Collapse menu"  } )
		else
			Panel:AddControl( "Button", { Label = "-- General Tool Options --", Command = "precision_generalmenu", Description = "Expand menu"  } )
			if ( user == 1 ) then
				Panel:AddControl( "Label", { Text = "(Note: For more modes and options like slider, use this options button and change the user level)", Description = "" }  )
			end
		end
	end



	local function precision_defaults()
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 3 )
		if mode  == 1 then
	--		RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_ShadowDisable", "0")
			RunConsoleCommand("precision_nocollideall", "0")
			RunConsoleCommand("precision_physdisable", "0")
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 2 then
			RunConsoleCommand("precision_rotation", "15")
	--		RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 3 then
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
	--		RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 4 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
	--		RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
		elseif mode == 5 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
    --		RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_friction", "0")
		elseif mode == 6 then
			-- RunConsoleCommand("precision_move", "1")
			-- RunConsoleCommand("precision_rotate", "1")
			-- RunConsoleCommand("precision_offset", "0")
			-- RunConsoleCommand("precision_offsetpercent", "1")
			-- RunConsoleCommand("precision_rotation", "15")
			-- RunConsoleCommand("precision_freeze", "1")
			-- RunConsoleCommand("precision_nocollide", "1")
			-- RunConsoleCommand("precision_autorotate", "0")
			-- RunConsoleCommand("precision_entirecontrap", "0")
			-- RunConsoleCommand("precision_forcelimit", "0")
			-- RunConsoleCommand("precision_torquelimit", "0")
		elseif mode == 7 then
			-- RunConsoleCommand("precision_move", "0")
			-- RunConsoleCommand("precision_rotate", "1")
			-- RunConsoleCommand("precision_offset", "0")
			-- RunConsoleCommand("precision_offsetpercent", "1")
			-- RunConsoleCommand("precision_rotation", "15")
			-- RunConsoleCommand("precision_freeze", "1")
			-- RunConsoleCommand("precision_nocollide", "1")
			-- RunConsoleCommand("precision_autorotate", "0")
			-- RunConsoleCommand("precision_entirecontrap", "0")
			-- RunConsoleCommand("precision_forcelimit", "0")
			-- RunConsoleCommand("precision_torquelimit", "0")
			-- RunConsoleCommand("precision_XRotMin", "0")
			-- RunConsoleCommand("precision_XRotMax", "0")
			-- RunConsoleCommand("precision_YRotMin", "0")
			-- RunConsoleCommand("precision_YRotMax", "0")
			-- RunConsoleCommand("precision_ZRotMin", "0")
			-- RunConsoleCommand("precision_ZRotMax", "0")
			-- RunConsoleCommand("precision_XRotFric", "0")
			-- RunConsoleCommand("precision_YRotFric", "0")
			-- RunConsoleCommand("precision_ZRotFric", "0")
			-- RunConsoleCommand("precision_FreeMov", "1")
		elseif mode == 8 then
			-- RunConsoleCommand("precision_move", "1")
			-- RunConsoleCommand("precision_rotate", "1")
			-- RunConsoleCommand("precision_offset", "0")
			-- RunConsoleCommand("precision_offsetpercent", "1")
			-- RunConsoleCommand("precision_rotation", "15")
			-- RunConsoleCommand("precision_freeze", "1")
			-- RunConsoleCommand("precision_nocollide", "0")
			-- RunConsoleCommand("precision_autorotate", "0")
			-- RunConsoleCommand("precision_entirecontrap", "0")
			-- RunConsoleCommand("precision_width", "1")
			-- RunConsoleCommand("precision_disablesliderfix", "0")
		elseif mode == 9 then
			-- RunConsoleCommand("precision_allowphysgun", "0")
			-- RunConsoleCommand("precision_entirecontrap", "0")
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_defaultrestore", precision_defaults )

	local function precision_genmenu()
		if ( showgenmenu == 1 ) then
			showgenmenu = 0
		else
			showgenmenu = 1
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_generalmenu", precision_genmenu )


	function precision_setmode( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_mode", 3 ) != args[1] then
			RunConsoleCommand("precision_mode", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setmode", precision_setmode )


	function precision_setuser( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_user", 3 ) != args[1] then
			RunConsoleCommand("precision_user", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setuser", precision_setuser )


	function precision_updatecpanel()
		local Panel = controlpanel.Get( "precision" )
		if (!Panel) then return end
		--custom panel building ( wtf does Panel:AddDefaultControls() get it's defaults from? )
		AddDefControls( Panel )
	end
	concommand.Add( "precision_updatecpanel", precision_updatecpanel )

	function TOOL.BuildCPanel( Panel )
		AddDefControls( Panel )
	end

	local function precision_removalall()
		RunConsoleCommand("precision_removal_nocollide", "1")
		RunConsoleCommand("precision_removal_weld", "1")
		RunConsoleCommand("precision_removal_axis", "1")
		RunConsoleCommand("precision_removal_ballsocket", "1")
		RunConsoleCommand("precision_removal_advballsocket", "1")
		RunConsoleCommand("precision_removal_slider", "1")
		RunConsoleCommand("precision_removal_parent", "1")
		RunConsoleCommand("precision_removal_other", "1")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_all", precision_removalall )
	local function precision_removalnone()
		RunConsoleCommand("precision_removal_nocollide", "0")
		RunConsoleCommand("precision_removal_weld", "0")
		RunConsoleCommand("precision_removal_axis", "0")
		RunConsoleCommand("precision_removal_ballsocket", "0")
		RunConsoleCommand("precision_removal_advballsocket", "0")
		RunConsoleCommand("precision_removal_slider", "0")
		RunConsoleCommand("precision_removal_parent", "0")
		RunConsoleCommand("precision_removal_other", "0")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_none", precision_removalnone )

	function TOOL:FreezeMovement()
		local stage = self:GetStage()
		if ( stage == 2 ) then
			return true
		--elseif ( iNum > 0 && self:GetClientNumber("mode") == 2 ) then
		--	return true
		end
		return false
	end
end

function TOOL:Holster()
	self:ClearObjects()
	self:SetStage(0)
	self:ClearSelection()
end
--addons/tool_textscreen/lua/weapons/gmod_tool/stools/wrp_text_placements.lua:
TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.wrp_text_placements.name"
TOOL.Information = {
	{name = "left"}
} 

for i=1, 5 do
	TOOL.ClientConVar["text"..i] = ""
	TOOL.ClientConVar["size"..i] = "50"
	TOOL.ClientConVar["r"..i] = "255"
	TOOL.ClientConVar["g"..i] = "255"
	TOOL.ClientConVar["b"..i] = "255"
	TOOL.ClientConVar["a"..i] = "255"
end

if SERVER then
	CreateConVar("sbox_maxtextplacements", "3", {FCVAR_NOTIFY, FCVAR_REPLICATED})	
end

if CLIENT then
	language.Add("tool.wrp_text_placements.name", "3D2D Текст")	
	language.Add("tool.wrp_text_placements.desc", "Создай текст с несколькими строками и разными цветами.")	
    language.Add("tool.wrp_text_placements.left", "Заспавнить текст.")
    language.Add("tool.wrp_text_placements.right", "Обновить существующий текст.")
	language.Add("Undone_wrp_text_placements", "Отменен 3D2D текст")

	for i=1, 5 do
		language.Add("tool.wrp_text_placements.text"..i, "Строка "..i)
		language.Add("tool.wrp_text_placements.text"..i..".help", "Строка "..i)
		language.Add("tool.wrp_text_placements.size"..i, "Размер текста")
		language.Add("tool.wrp_text_placements.size"..i..".help", "Размер текста")
		language.Add("tool.wrp_text_placements.color"..i, "Цвет текста")
		language.Add("tool.wrp_text_placements.color"..i..".help", "Цвет текста")
	end
end

function TOOL:BuildLines()
	local lines = {}
	for i=1, 5 do
		lines[i] = self:GetClientInfo("text"..i)
	end
	for i=5, 1, -1 do
		if not (lines[i] == "") then break end
		lines[i] = nil
	end

	return lines
end

function TOOL:CreateEntity(trace)
	local newEnt = ents.Create("wrp_text")
	newEnt:SetPos(trace.HitPos)

	local angle = trace.HitNormal:Angle()
	angle:RotateAroundAxis(trace.HitNormal:Angle():Right(), -90)
	angle:RotateAroundAxis(trace.HitNormal:Angle():Forward(), 90)
	newEnt:SetAngles(angle)

	newEnt:Spawn()
	newEnt:Activate()

	return newEnt
end

function TOOL:LeftClick(trace)
	if CLIENT then return true end
	local ply = self:GetOwner()

	if not ply:CheckLimit("textscreens") then return end
	local text = self:BuildLines()
	if not text then return end

	local ent = self:CreateEntity(trace)
	for k, v in pairs(text) do
		ent:SetText(k, v)
		ent:SetTextColor(k, Color(math.Clamp(self:GetClientNumber("r"..k, 255), 0, 255), math.Clamp(self:GetClientNumber("g"..k, 255), 0, 255), math.Clamp(self:GetClientNumber("b"..k, 255), 0, 255)))
		ent:SetTextSize(k, math.Clamp(self:GetClientNumber("size"..k, 50), 30, 100))
	end

	ply:AddCount("textscreens", ent)
	ply:AddCleanup("textscreens", ent)
	undo.Create("wrp_text_placements")
		undo.AddEntity(ent)
		undo.SetPlayer(ply)
	undo.Finish()

	return true
end

local ConVarsDefault = TOOL:BuildConVarList()
function TOOL.BuildCPanel(panel)
	panel:AddControl("Header", {Text = "#tool.wrp_text_placements.name", Description = "#tool.wrp_text_placements.desc"})
		
	panel:AddControl("ComboBox", {MenuButton = 1, Folder = "wrp_text_placements", Options = {["#preset.default"] = ConVarsDefault}, CVars = table.GetKeys(ConVarsDefault)})

	for i=1, 5 do
		panel:AddControl("Header", {Text = "#tool.wrp_text_placements.text"..i, Description = "#tool.wrp_text_placements.text"..i})
		panel:AddControl("textbox", {Label = "#tool.wrp_text_placements.text"..i, Command = "wrp_text_placements_text"..i, MaxLenth = "30"})
		panel:AddControl("Slider", {Label = "#tool.wrp_text_placements.size"..i, Command = "wrp_text_placements_size"..i, Type = "Int", Min = 30, Max = 100})
		panel:AddControl("Color", {Label = "#tool.wrp_text_placements.color"..i, Red = "wrp_text_placements_r"..i, Green = "wrp_text_placements_g"..i, Blue = "wrp_text_placements_b"..i, Alpha = "wrp_text_placements_a"..i})
	end
end
--addons/module_itemstore/lua/weapons/itemstore_checker.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.PrintName = "Обыск инвентаря"

SWEP.Purpose = "Checking the inventory of another player"
SWEP.Instructions = "Primary attack: check inventory of player in front of you"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Проверить инвентарь"},
}

SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.ViewModel = "models/weapons/cstrike/c_c4.mdl"
SWEP.WorldModel = ""
SWEP.UseHands = true

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Slot               = 1
SWEP.SlotPos 			= 10
SWEP.DrawAmmo           = false
SWEP.DrawCrosshair      = true

SWEP.Range = 250

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end

function SWEP:OnDrop()
	self:Remove()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end

	local tr = util.TraceLine{
		start = self:GetOwner():GetShootPos(),
		endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * self.Range,
		filter = self:GetOwner()
	}

	if not tr.Hit then return end
	if not IsValid( tr.Entity ) or not tr.Entity:IsPlayer() then return end

	local inv = tr.Entity.Inventory
	if not inv then return end

	inv:Sync( self:GetOwner() )
	self:GetOwner():OpenContainer( inv:GetID(), itemstore.Translate( "inventory" ), true )
end

function SWEP:SecondaryAttack()
end

--addons/module_css2/lua/weapons/ptp_cs_357/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.CrosshairEnabled = true
	SWEP.DrawCrosshair = false
	SWEP.PrintName = ".357 Revolver"
	SWEP.CSMuzzleFlashes = false
	
	SWEP.AimPos = Vector(-4.791, 20.958, 0.66)
	SWEP.AimAng = Vector(0, -0.216, 0)
	
	SWEP.SprintPos = Vector(1.185, -15.796, -14.254)
	SWEP.SprintAng = Vector(64.567, 0, 0)
	
	SWEP.ZoomAmount = 40
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "f"
	killicon.AddFont("swb_357", "SWB_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "swb_pistol_large"
	SWEP.MuzzlePosMod = {x = 6.5, y =	30, z = -2}
	--SWEP.PosBasedMuz = true
end

SWEP.FadeCrosshairOnAim = true

SWEP.SpeedDec = 12
SWEP.BulletDiameter = 9.1
SWEP.CaseLength = 33

SWEP.PlayBackRate = 2
SWEP.PlayBackRateSV = 2

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_revolver_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "revolver"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"double"}
SWEP.Base = "swb_base"
SWEP.Category = "Премиум"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/c_357.mdl"
SWEP.WorldModel		= "models/weapons/w_357.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 6
SWEP.Primary.DefaultClip	= 6
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.FireDelay = 0.4
SWEP.FireSound = Sound("Weapon_357.Single")
SWEP.Recoil = 2
SWEP.Chamberable = false

SWEP.HipSpread = 0.03
SWEP.AimSpread = 0.004
SWEP.VelocitySensitivity = 1.85
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.015
SWEP.SpreadCooldown = 0.5
SWEP.Shots = 1
SWEP.Damage = 80
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_aug/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Steyr AUG"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-8.322, -7, 2.174)
	SWEP.AimAng = Vector(0.151, -3.701, -10.429)
	
		
	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 25
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 25
	SWEP.MaxZoom = 50
	
	SWEP.IconLetter = "z"
	
	SWEP.MuzzleEffect = false
	SWEP.InvertShellEjectAngle = true
	
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_rif_aug.mdl"
SWEP.WorldModel = "models/weapons/w_rif_aug.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 30
SWEP.Primary.DefaultClip = 90
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("weapons/aug/aug-1.wav")
SWEP.Recoil = 0.9

SWEP.HipSpread = 0.05
SWEP.AimSpread = 0.0012
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 44
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_m4/shared.lua:
AddCSLuaFile()

if CLIENT then

	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M4A1"
	SWEP.CSMuzzleFlashes = true
	
	--SWEP.AimPos = Vector(-3.441, -4.723, 1.12)
	--SWEP.AimAng = Vector(0, 0, 0)
	SWEP.AimPos = Vector(-8.14, -3.7, 0.2)
	SWEP.AimAng = Vector(3.45, -2.768, -5.4)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author	= ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_rif_m4a1.mdl"
SWEP.WorldModel = "models/weapons/w_rif_m4a1.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable	= true

SWEP.Primary.ClipSize = 30
SWEP.Primary.DefaultClip = 90
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_M4A1.Single")
SWEP.FireSoundSuppressed = Sound("Weapon_M4A1.Silenced")
SWEP.Recoil = 0.7

SWEP.Suppressable = true

SWEP.HipSpread = 0.035
SWEP.AimSpread = 0.0015
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 42
SWEP.DeployTime = 1

SWEP.ForceVMSequences = {
	[12] = 8,
}
--addons/module_css2/lua/weapons/ptp_cs_mac10/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "MAC-10"
	SWEP.CSMuzzleFlashes = true

	SWEP.AimPos = Vector(-1.68, -2.089, 1.48)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 1.802)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ZoomAmount = 30
	SWEP.ViewModelMovementScale = 0.7
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "l"
	
	SWEP.MuzzleEffect = false

end

SWEP.CanPenetrate = false
SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 15
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_smg_mac10.mdl"
SWEP.WorldModel = "models/weapons/w_smg_mac10.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 40
SWEP.Primary.DefaultClip = 120
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"
SWEP.Chamberable = false

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_MAC10.Single")	
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.02
SWEP.AimSpread = 0.01
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 35
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--addons/module_css2/lua/weapons/ptp_cs_p228/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Sig Sauer P228"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.949, -2.096, 2.88)
	SWEP.AimAng = Vector(-0.401, 0, 0)
		
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_pist_p228.mdl"
SWEP.WorldModel = "models/weapons/w_pist_p228.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 12
SWEP.Primary.DefaultClip = 36
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.FireDelay = 0.013
SWEP.FireSound = Sound("Weapon_P228.Single")	
SWEP.Recoil = 0.5

SWEP.HipSpread = 0.025
SWEP.AimSpread = 0.0115
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 44
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_p90/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FN P90"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7, 1, 0)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 40
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true

	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 20
SWEP.BulletDiameter = 5.7
SWEP.CaseLength = 28

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.FadeCrosshairOnAim = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author	= ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_smg_p90.mdl"
SWEP.WorldModel = "models/weapons/w_smg_p90.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 50
SWEP.Primary.DefaultClip = 150
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_P90.Single")	
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.03
SWEP.AimSpread = 0.007
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 35
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--addons/module_css2/lua/weapons/ptp_cs_sg550/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "SIG SG 550"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.461, -13.646, 1.519)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(0, 0, 0)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 25
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 25
	SWEP.MaxZoom = 65
	
	SWEP.IconLetter = "z"
	
	SWEP.MuzzleEffect = false
	SWEP.InvertShellEjectAngle = true

end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 20
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_snip_sg550.mdl"
SWEP.WorldModel = "models/weapons/w_snip_sg550.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 15
SWEP.Primary.DefaultClip = 45
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.28
SWEP.FireSound = Sound("Weapon_SG550.Single")
SWEP.Recoil = 1

SWEP.HipSpread = 0.06
SWEP.AimSpread = 0.001
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 90
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_sg552/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "SIG SG 552"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.881, -18.001, 2.599)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(0.922, -3.836, 0.704)
	SWEP.SprintAng = Vector(-10.207, 31.819, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 25
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 25
	SWEP.MaxZoom = 50
	
	SWEP.IconLetter = "z"
	
	SWEP.MuzzleEffect = false
	SWEP.InvertShellEjectAngle = true

end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 20
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_rif_sg552.mdl"
SWEP.WorldModel = "models/weapons/w_rif_sg552.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 30
SWEP.Primary.DefaultClip = 90
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_SG552.Single")
SWEP.Recoil = 0.65

SWEP.HipSpread = 0.042
SWEP.AimSpread = 0.001
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 40
SWEP.DeployTime = 1
--addons/module_stungun/lua/weapons/sniper_stungun/shared.lua:
SWEP.Base = "stungun"
SWEP.PrintName = "Снайпер-Тайзер"
SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_snip_g3sg1.mdl"
SWEP.WorldModel = "models/weapons/w_snip_g3sg1.mdl"

SWEP.Slot = 0
SWEP.SlotPos = 0
SWEP.UseHands = true

SWEP.HoldType = "ar2"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Range = 10000

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

if SERVER then
	function SWEP:Equip()
	end

	function SWEP:OnDrop()
	end

	function SWEP:Deploy()
		local owner = self:GetOwner()
		owner:MoveModifier('sniper_tazer', {walkmul = 0.3, norun = true})
		return true
	end

	function SWEP:Holster()
		local owner = self:GetOwner()
		owner:MoveModifier('sniper_tazer')
	    return true
	end
end
--addons/weapon_spiderswep/lua/weapons/spidermans_swep/shared.lua:

SWEP.Author			= "chelog"
SWEP.Category 		= "Запрещено"
SWEP.Purpose		= "Allows you to be Spider-Man"
SWEP.Instructions	= "Silent Edition, without startup music. Left click to shoot web and then jump!"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Паутина из левой руки"},
	{key = MOUSE_RIGHT, desc = "Паутина из правой руки"},
	{key = KEY_R, desc = "Липкая паутина"},
}

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= true

SWEP.HoldType 			= "normal"
SWEP.PrintName			= "Паутина"
SWEP.Slot				= 2
SWEP.SlotPos			= 0
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/weapons/v_spiderweb.mdl"
SWEP.WorldModel			= "models/weapons/c_sw_free_hands.mdl"
SWEP.ViewModelFlip = false

SWEP.Beam = {}
SWEP.Tr = {}
SWEP.dtt = {}
SWEP.startTime = {}
SWEP.endTime = {}
SWEP.speed = {}
SWEP.addVel = Vector()
SWEP.MaxWebs = 10

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
	self:SetWebsRemaining(self.MaxWebs)
end

function SWEP:SetupDataTables()
	self:NetworkVar("Int", 0, "WebsRemaining")
end

function SWEP:Think()

	if (!self:GetOwner() || self:GetOwner() == NULL) then return end

	if ( self:GetOwner():KeyPressed( IN_ATTACK ) ) then

		self:StartAttack( 1 )

	elseif SERVER and ( self:GetOwner():KeyDown( IN_ATTACK ) ) then

		self:UpdateAttack( 1 )

	elseif SERVER and ( self:GetOwner():KeyReleased( IN_ATTACK ) ) then

		self:EndAttack( 1, true )

	end

	if ( self:GetOwner():KeyPressed( IN_ATTACK2 ) ) then

		self:StartAttack( 2 )

	elseif SERVER and ( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then

		self:UpdateAttack( 2 )

	elseif SERVER and ( self:GetOwner():KeyReleased( IN_ATTACK2 ) ) then

		self:EndAttack( 2, true )

	end

	self:GetOwner():SetVelocity( self.addVel )
	self.addVel = Vector()

end

function SWEP:DoTrace( num, endpos )
	local trace = {}
		trace.start = self:GetOwner():GetShootPos()
		trace.endpos = trace.start + (self:GetOwner():GetAimVector() * 14096)
		if(endpos) then trace.endpos = (endpos - self.Tr[num].HitNormal * 7) end
		trace.filter = { self:GetOwner(), self.Weapon }

	self.Tr[num] = nil
	self.Tr[num] = util.TraceLine( trace )
end

function SWEP:StartAttack( num )
	local gunPos = self:GetOwner():GetShootPos()
	local disTrace = self:GetOwner():GetEyeTrace()
	local hitPos = disTrace.HitPos

	-- local x = (gunPos.x - hitPos.x)^2;
	-- local y = (gunPos.y - hitPos.y)^2;
	-- local z = (gunPos.z - hitPos.z)^2;
	-- local distance = math.sqrt(x + y + z);
	--
	-- local distanceCvar = GetConVarNumber("rope_distance")
	-- inRange = false
	-- if distance <= distanceCvar then
	-- 	inRange = true
	-- end


	if (SERVER) then

		if (!self.Beam[num]) then
			self.Beam[num] = ents.Create( "rope" )
				self.Beam[num]:SetPos( self:GetOwner():GetShootPos() )
			self.Beam[num]:Spawn()
		end

		self.Beam[num]:SetParent( self:GetOwner() )
		self.Beam[num]:SetOwner( self:GetOwner() )

	end

	self:DoTrace( num )
	self.speed[num] = 10000
	self.startTime[num] = CurTime()
	self.endTime[num] = CurTime() + self.speed[num]
	self.dtt[num] = -1

	if (SERVER && self.Beam[num]) then
		self.Beam[num]:GetTable():SetEndPos( self.Tr[num].HitPos )
		self:UpdateAttack()
	end

end

function SWEP:UpdateAttack( num )

	if not self:GetOwner():IsLagCompensated() then
		self:GetOwner():LagCompensation( true )
	end

	if not self.Tr[num] then return end
	if (!endpos) then endpos = self.Tr[num].HitPos end

	if (SERVER && self.Beam[num]) then
		self.Beam[num]:GetTable():SetEndPos( endpos )
	end

	lastpos = endpos

	if ( self.Tr[num].Entity:IsValid() ) then

	endpos = self.Tr[num].Entity:GetPos()
			if ( SERVER && self.Beam[num] ) then
			self.Beam[num]:GetTable():SetEndPos( endpos )
			end

	end

	local vVel = (endpos - self:GetOwner():GetPos())
	local Distance = endpos:Distance(self:GetOwner():GetPos())

	local et = (self.startTime[num] + (Distance/self.speed[num]))
	if(self.dtt[num] != 0) then
		self.dtt[num] = (et - CurTime()) / (et - self.startTime[num])
	end
	if(self.dtt[num] < 0) then
		self.dtt[num] = 0
	end

	if(self.dtt[num] == 0) then
		zVel = self:GetOwner():GetVelocity().z
		vVel = vVel:GetNormalized()*(math.Clamp(Distance,0,7))*10
		if( SERVER ) then
			local gravity = GetConVarNumber("sv_Gravity")
			vVel:Add(Vector(0,0,(gravity/100)*3))
			if(zVel < 0) then
				vVel:Sub(Vector(0,0,zVel/100))
			end
			self.addVel = self.addVel + vVel
		end
	end

	endpos = nil

	self:GetOwner():LagCompensation( false )

end

function SWEP:EndAttack( num, shutdownsound )

	if ( CLIENT ) then return end
	if ( !self.Beam[num] ) then return end

	self.Beam[num]:Remove()
	self.Beam[num] = nil

end

function SWEP:Attack2()



end

function SWEP:Holster()
	self:EndAttack( 1, false )
	self:EndAttack( 2, false )
	return true
end

function SWEP:OnRemove()
	self:EndAttack( 1, false )
	self:EndAttack( 2, false )
	return true
end


function SWEP:PrimaryAttack()
    self.ViewModelFlip = false
	self.Weapon:EmitSound("web/webfire.wav")
	self.Weapon:SendWeaponAnim(ACT_VM_SWINGMISS)
end

function SWEP:SecondaryAttack()
    self.ViewModelFlip = true
	self.Weapon:EmitSound("web/webfire.wav")
	self.Weapon:SendWeaponAnim(ACT_VM_SWINGMISS)
end

function SWEP:Reload()
    if ( !self:GetOwner():KeyPressed( IN_RELOAD ) ) then return end
    self.Weapon:SendWeaponAnim(ACT_VM_SWINGMISS)
	if CLIENT then return end

 -- if ( !self:GetOwner():KeyPressed( IN_RELOAD ) ) then return end
    if self:GetWebsRemaining() <= 0 then return end
    
    self.Weapon:EmitSound("web/webfire.wav")
	local ply = self:GetOwner()
	local tr = ply:GetEyeTrace().HitPos
    ply:EmitSound("web/webfire.wav")
	local web = ents.Create('cobweb')
	web:SetPos(tr)
	web:Spawn()
	
	self:SetWebsRemaining(self:GetWebsRemaining() - 1)

	timer.Simple(20, function()
		if IsValid(web) then 
		    web:Remove()
		end
		
        if IsValid(self) then
		    self:SetWebsRemaining(self:GetWebsRemaining() + 1) 
        end
	end)

end
--addons/weapon_shield/lua/weapons/swat_shield/shared.lua:
SWEP.PrintName = 'Molot Shield'
SWEP.Author	= 'doxzter'
SWEP.Instructions = ''
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Толкнуть"},
}
SWEP.Spawnable = true
SWEP.AdminOnly = true

SWEP.ViewModel = ''
SWEP.WorldModel = 'models/arleitiss/riotshield/shield.mdl'

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom	= false

SWEP.Slot = 3
SWEP.SlotPos = 3
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

SWEP.Category = 'Запрещено'
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = 'none'
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = 'none'

function SWEP:Initialize()
	self:SetHoldType('melee2')
end
--addons/module_css2/lua/weapons/swb_base/cl_hud.lua:
surface.CreateFont("SWB_HUD72", {font = "Default", size = 72, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD48", {font = "Default", size = 48, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD36", {font = "Default", size = 36, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD28", {font = "Default", size = 28, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD24", {font = "Default", size = 24, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD16", {font = "Default", size = 16, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_KillIcons", {font = "csd", size = ScreenScale(30), weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_SelectIcons", {font = "csd", size = ScreenScale(60), weight = 500, blursize = 0, antialias = true, shadow = false})

local cvar_crosshair = CreateClientConVar('swb_enable_crosshair', '1', true)

SWEP.CrossAmount = 0
SWEP.CrossAlpha = 255
SWEP.FadeAlpha = 0
SWEP.AimTime = 0

local ClumpSpread = surface.GetTextureID("swb/clumpspread_ring")
local RifleSpread = surface.GetTextureID("swb/rifle_aim")
local Bullet = surface.GetTextureID("swb/bullet")
local White, Black = Color(255, 255, 255, 255), Color(0, 0, 0, 255)
local x, y, x2, y2, lp, size, FT, CT, tr, x3, x4, y3, y4, UCT, sc1, sc2
local td = {}

local dst = draw.SimpleText

function draw.ShadowText(text, font, x, y, colortext, colorshadow, dist, xalign, yalign)
	dst(text, font, x + dist, y + dist, colorshadow, xalign, yalign)
	dst(text, font, x, y, colortext, xalign, yalign)
end

function SWEP:DrawHUD()
	FT, CT, x, y = FrameTime(), CurTime(), ScrW(), ScrH()
	UCT = UnPredictedCurTime()
	
	if self.dt.State == SWB_AIMING then
		if UCT > self.AimTime then
			if self.DrawBlackBarsOnAim then
				surface.SetDrawColor(0, 0, 0, 255)
				
				if self.ScaleOverlayToScreenHeight then
					x3 = (x - y) / 2
					y3 = y / 2
					x4 = x - x3
					y4 = y - y3
					
					surface.DrawRect(0, 0, x3, y)
					surface.DrawRect(x4, 0, x3, y)
				else
					x3 = (x - 1024) / 2
					y3 = (y - 1024) / 2
					x4 = x - x3
					y4 = y - y3
					
					surface.DrawRect(0, 0, x3, y)
					surface.DrawRect(x4, 0, x3, y)
					surface.DrawRect(0, 0, x, y3)
					surface.DrawRect(0, y4, x, y3)
				end
			end
		end
		
		if self.AimOverlay then
			if UCT > self.AimTime or self.InstantDissapearOnAim then
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(self.AimOverlay)
				
				if self.StretchOverlayToScreen then
					surface.DrawTexturedRect(0, 0, x, y)
				elseif self.ScaleOverlayToScreenHeight then
					surface.DrawTexturedRect(x * 0.5 - y * 0.5, y * 0.5 - y * 0.5, y, y)
				else
					surface.DrawTexturedRect(x * 0.5 - 512, y * 0.5 - 512, 1024, 1024)
				end
			end
		end
		
		if self.FadeDuringAiming then
			if UCT < self.AimTime then
				self.FadeAlpha = math.Approach(self.FadeAlpha, 255, FT * 1500)
			else
				self.FadeAlpha = Lerp(FT * 10, self.FadeAlpha, 0)
			end
			
			surface.SetDrawColor(0, 0, 0, self.FadeAlpha)
			surface.DrawRect(0, 0, x, y)
		end
	else
		self.FadeAlpha = 0
	end
	
	if cvar_crosshair:GetBool() and self.CrosshairEnabled then
		lp = self:GetOwner():ShouldDrawLocalPlayer()
		
		if lp then
			td.start = self:GetOwner():GetShootPos()
			td.endpos = td.start + (self:GetOwner():EyeAngles() + self:GetOwner():GetPunchAngle()):Forward() * 16384
			td.filter = self:GetOwner()
			
			tr = util.TraceLine(td)
			
			x2 = tr.HitPos:ToScreen()
			x2, y2 = x2.x, x2.y
		else
			x2, y2 = math.Round(x * 0.5), math.Round(y * 0.5)
		end
		
		if (self.dt.State == SWB_AIMING and self.FadeCrosshairOnAim) or self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION or self.dt.Safe or self:GetOwner():InVehicle() or ((self.IsReloading or self.IsFiddlingWithSuppressor) and self.Cycle <= 0.9) then
			self.CrossAlpha = Lerp(FT * 15, self.CrossAlpha, 0)
		else
			self.CrossAlpha = Lerp(FT * 15, self.CrossAlpha, 255)
		end
		
		if self.ClumpSpread then
			size = math.ceil(self.ClumpSpread * 2500)
			surface.SetDrawColor(0, 0, 0, self.CrossAlpha)
			surface.SetTexture(ClumpSpread)
			surface.DrawTexturedRect(x2 - size * 0.5 - 1, y2 - size * 0.5 - 1, size + 2, size + 2)
					
			surface.SetDrawColor(255, 255, 255, self.CrossAlpha)
			surface.DrawTexturedRect(x2 - size * 0.5, y2 - size * 0.5, size, size)
		end

		if self.RifleSpread then
			size = math.ceil(self.RifleSpread * 2500)
			surface.SetDrawColor(0, 0, 0, self.CrossAlpha)
			surface.SetTexture(RifleSpread)
			surface.DrawTexturedRect(x2 - size * 0.5 - 1, y2 - size * 0.5 - 1, size + 2, size + 2)
					
			surface.SetDrawColor(255, 255, 255, self.CrossAlpha)
			surface.DrawTexturedRect(x2 - size * 0.5, y2 - size * 0.5, size, size)
		end

		self.CrossAmount = Lerp(FT * 10, self.CrossAmount, (self.CurCone * 350) * (90 / (math.Clamp(GetConVarNumber("fov_desired"), 75, 90) - self.CurFOVMod)))
		surface.SetDrawColor(0, 0, 0, self.CrossAlpha * 0.75) -- BLACK crosshair parts
		
		if self.CrosshairParts.left then
			surface.DrawRect(x2 - 13 - self.CrossAmount, y2 - 1, 12, 3) -- left cross
		end
		
		if self.CrosshairParts.right then
			surface.DrawRect(x2 + 3 + self.CrossAmount, y2 - 1, 12, 3) -- right cross
		end
		
		if self.CrosshairParts.upper then
			surface.DrawRect(x2 - 1, y2 - 13 - self.CrossAmount, 3, 12) -- upper cross
		end
		
		if self.CrosshairParts.lower then
			surface.DrawRect(x2 - 1, y2 + 3 + self.CrossAmount, 3, 12) -- lower cross
		end
		
		surface.SetDrawColor(255, 255, 255, self.CrossAlpha) -- WHITE crosshair parts
		
		if self.CrosshairParts.left then
			surface.DrawRect(x2 - 12 - self.CrossAmount, y2, 10, 1) -- left cross
		end
		
		if self.CrosshairParts.right then
			surface.DrawRect(x2 + 4 + self.CrossAmount, y2, 10, 1) -- right cross
		end
		
		if self.CrosshairParts.upper then
			surface.DrawRect(x2, y2 - 12 - self.CrossAmount, 1, 10) -- upper cross
		end
		
		if self.CrosshairParts.lower then
			surface.DrawRect(x2, y2 + 4 + self.CrossAmount, 1, 10) -- lower cross
		end
	end
	
	--[[
	sc1, sc2 = ScreenScale(22), ScreenScale(44)
	draw.ShadowText(self.FireModeDisplay, "SWB_HUD16", x - sc1 - self.BulletDisplay * 20, y - sc2 + 25, White, Black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

	if self.BulletDisplay and self.BulletDisplay > 0 then
		surface.SetTexture(Bullet)
		for i = 1, self.BulletDisplay do
			surface.SetDrawColor(0, 0, 0, 255)
			surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 5, y - sc2 + 18, 16, 16)
			surface.SetDrawColor(255, 255, 255, 255)
			surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 6, y - sc2 + 18, 16, 16)
		end
	end
	]]

	if self.CustomHud then
		self:CustomHud()
	end
end

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	if self.SelectIcon then
		surface.SetDrawColor(255, 210, 0, 255)
		surface.SetTexture(self.SelectIcon)
		surface.DrawTexturedRect(x + tall * 0.2, y, tall, tall)
	
		draw.SimpleText(self.IconLetter, "SWB_SelectIcons", x + wide/2, y + tall*0.2, Color( 255, 210, 0, alpha ), TEXT_ALIGN_CENTER)
	end
end
--addons/module_disguise/lua/weapons/ultimate_disguise_kit/shared.lua:
AddCSLuaFile()

SWEP.PrintName = "Маскировка"
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

SWEP.Base = "weapon_base"

SWEP.Author = "Quintalos"
SWEP.Instructions = ""
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Замаскироваться"},
	{
		key = MOUSE_RIGHT,
		desc = "Снять маскировку",
		check = function(wep)
			return LocalPlayer():GetNetVar('disguised', false)
		end,
	},
}
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IconLetter = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix	 = "rpg"
SWEP.WorldModel	= ""

SWEP.Spawnable = true
SWEP.AdminOnly = true

SWEP.ViewModel			= "models/weapons/v_c4.mdl"
SWEP.WorldModel			= "models/weapons/w_c4.mdl"

SWEP.Category = "Запрещено"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""
SWEP.IdleStance = "slam"

if CLIENT then
	local color_dark = Color( 47, 52, 57 )
	local color_bright = Color( 240, 240, 240 )
	local color_other = Color( 220, 220, 220 )
	local scrW,scrH = ScrW(), ScrH()

	function SWEP:DrawHUD()
		local ply = LocalPlayer()
		if not ply:Alive() or ply:InVehicle() then return end
		if not ply:GetNetVar("disguised") then return end

		local last = ply:GetNetVar("last_disguise")
		if not last then return end

		local time = string.FormattedTime(DISGUISE_KIT_TIME - (CurTime() - last))

		draw.RoundedBoxEx( 4, scrW - 205, scrH - 55, 200, 50, color_dark, true, false, true, false )

		draw.SimpleText( ("%02i:%02i"):format(time.m, time.s), "flatHUD_font28", scrW - 105, scrH - 38, color_bright, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( "До конца маскировки", "flatHUD_font14", scrW - 105, scrH - 17, color_other, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
end

function SWEP:Initialize()
	self:SetHoldType(self.IdleStance)
end

function SWEP:Deploy()
	return true
end

function SWEP:Holster()
	if not SERVER then return true end
	
	self:GetOwner():DrawViewModel(true)
	self:GetOwner():DrawWorldModel(true)

	return true
end

function SWEP:PrimaryAttack()
	self.Weapon:SetNextPrimaryFire(0.6)
	if (!SERVER) then return end
	local ply = self:GetOwner()
	local last = ply:GetNetVar("last_disguise")
	net.Start("DisguiseKitOpen")
		net.WriteTable({
			disguises = util.JSONToTable(file.Read("disguise_teams.txt")),
			timeleft = last and math.floor(CurTime() - last) or 0,
		})
	net.Send(ply)
end

function SWEP:Reload()
	if not SERVER then return end
	if self.NextReload and self.NextReload > CurTime() then return end

	self.NextReload = CurTime()+2

	local ply = self:GetOwner()

	if not ply:GetNetVar("disguised") then return DarkRP.notify(ply, 1, 3, 'Ты не замаскирован') end

	local job = ply:getJobTable()
	ply:SetModel(isstring(job.model) and job.model or job.model[math.random(#job.model)])
	ply:updateJob(job.name)
	ply:SetNetVar("disguise_team", nil)
	ply:SetNetVar("disguised", false)
	ply:SetNetVar("last_disguise", CurTime()-DISGUISE_KIT_COOLDOWN+15)

	DarkRP.notify(ply, 0, 5, 'Маскировка снята')
end

function SWEP:SecondaryAttack()
	return true
end

function SWEP:ShouldDropOnDie()
	return false
end -- dwhjkdnaw

--addons/_smallscripts/lua/weapons/weapon_army.lua:
AddCSLuaFile()
 
if CLIENT then --Client stuff
	SWEP.PrintName = "Набор в ЧВК" --Name
	SWEP.Slot = 1
	SWEP.SlotPos = 3
	SWEP.DrawAmmo = false --Draw ammo in bottom right corner
	SWEP.DrawCrosshair = false --Draw crosshair?
end
 
SWEP.Author = "KillerLUA" --Author
SWEP.Instructions = "Left or right click to give the player a pay day" --How to use
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Призвать игрока"},
}
SWEP.Contact = "" --Contact
SWEP.Purpose = "Gives people paydays" --Purpose
 
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "stunstick"
 
SWEP.Spawnable = true
SWEP.AdminOnly = true --Only spawnable by admins!
 
SWEP.NextStrike = 0
 
SWEP.ViewModel = Model("models/weapons/v_stunstick.mdl") --The model while being held
SWEP.WorldModel = Model("models/weapons/w_stunbaton.mdl") --World model (on the ground)
 
SWEP.Sound = Sound("weapons/stunstick/stunstick_swing1.wav") --The sound
 
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false 
SWEP.Primary.Ammo = ""
 
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""
 
function SWEP:Initialize()
	self:SetHoldType("normal")
end
 
function SWEP:PrimaryAttack()
	if CurTime() < self.NextStrike then return end
 
	self:SetHoldType("normal")
	timer.Simple(0.3, function() if self:IsValid() then self:SetHoldType("normal") end end) --Checks that the swep hasn't quickly been switched

	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self.Weapon:EmitSound(self.Sound) ---Emit a sound, the stunstick wack
	self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
 
	self.NextStrike = CurTime() + 5
 
	if CLIENT then return end --No clients past here
 
	self:GetOwner():LagCompensation(true)
	local trace = util.QuickTrace(self:GetOwner():EyePos(), self:GetOwner():GetAimVector() * 90, {self:GetOwner()})
	self:GetOwner():LagCompensation(false)

	local ent = self:GetOwner():getEyeSightHitEntity(nil, nil, function(p) return p ~= self:GetOwner() and p:IsPlayer() and p:Alive() end)
    
    if not IsValid(ent) or (self:GetOwner():EyePos():DistToSqr(ent:GetPos()) > 8100) or (not ent:IsPlayer() and not ent:IsNPC()) then
		return
	end
	
	if ent:Team() == TEAM_BANNED then return end
	if ent.AlreadyJoined and CurTime() < ent.AlreadyJoined then return end
	
	ent.AlreadyJoined = CurTime() + 30
	ent.armyInvited = true
	
	net.Start("query_army")
	net.Send(ent)
    
    
--	ent:payDay() --Give them a payday
end
 
function SWEP:SecondaryAttack()
	self:PrimaryAttack() --Run Primary Attack
end

if SERVER then
    hook.Add("PlayerDeath","army_death",function(ply, inf, attacker)
        if not attacker:IsValid() then return end
        if not attacker:IsPlayer() then return end
		
		if ply:GetNetVar('duelSystem.OnDuel') or attacker:GetNetVar('duelSystem.OnDuel') then return end
    	
    	if ( ply:Team() == TEAM_MAYOR ) and ( attacker:Team() == TEAM_ARMIASMED or attacker:Team() == TEAM_ARMIAS or attacker:Team() == TEAM_ARMIA ) then
    	    local comandir
			for _, v in player.Iterator() do
				if v:Team() == TEAM_ARMIA then
					comandir = v
					break
				end
    	    end
			
			if comandir then
				ply:changeTeam(TEAM_CITIZEN, true, true)
				comandir:changeTeam(TEAM_MAYOR, true, true)
				DarkRP.notifyAll(0, 4, "ЧВК захватили власть! Генерал стал мэром!")
			end
    	end
    end) 

    util.AddNetworkString("start_army")
    util.AddNetworkString("query_army")
    
    net.Receive("start_army", function(len, ply)
        
        if not ply.armyInvited then return end
        
    	local team = net.ReadString()
    	local pos = ply:GetPos()
    	
    	if team == 'soldier' then ply:changeTeam( TEAM_ARMIAS, true, true )
    	else ply:changeTeam( TEAM_ARMIASMED, true, true )end
    	
    	ply:Spawn()
    	ply:SetPos(pos)
    	
    	ply.armyInvited = false
    end)
end

if CLIENT then
    local answer = nil
    net.Receive("query_army", function()
        if IsValid(answer) then return end
        answer = Derma_Query( "Вступить в отряд ЧВК?", "ЧВК", "Рядовой ЧВК", function()
            net.Start("start_army")
            net.WriteString("soldier")
            net.SendToServer()
        end, "Медик ЧВК", function() 
            net.Start("start_army")
            net.WriteString("medic")
            net.SendToServer()
        end, "Отказаться")
    end)
end
--gamemodes/darkrp/entities/weapons/weapon_cs_base2/shared.lua:
AddCSLuaFile()

if SERVER then
    include("sv_commands.lua")
    include("sh_commands.lua")
    SWEP.Weight = 5
    SWEP.AutoSwitchTo = false
    SWEP.AutoSwitchFrom = false
end

if CLIENT then
    SWEP.DrawAmmo           = true
    SWEP.DrawCrosshair      = false
    SWEP.ViewModelFOV       = 82
    SWEP.ViewModelFlip      = false
    SWEP.CSMuzzleFlashes    = true

    -- This is the font that's used to draw the death icons
    surface.CreateFont("CSKillIcons", {
        size = ScreenScale(30),
        weight = 500,
        antialias = true,
        shadow = true,
        font = "csd"
    })
    surface.CreateFont("CSSelectIcons", {
        size = ScreenScale(60),
        weight = 500,
        antialias = true,
        shadow = true,
        font = "csd"
    })
end

SWEP.Base = "weapon_base"

SWEP.Author = "DarkRP Developers"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.UseHands = true

SWEP.HoldType = "normal"

SWEP.Primary.Sound = Sound("Weapon_AK47.Single")
SWEP.Primary.Recoil = 1.5
SWEP.Primary.Damage = 40
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.02
SWEP.Primary.Delay = 0.15

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.MultiMode = false

SWEP.DarkRPBased = true

function SWEP:Initialize()
    if CLIENT and IsValid(self:GetOwner()) then
        local vm = self:GetOwner():GetViewModel()
        self:ResetDarkRPBones(vm)
    end

    self:SetHoldType("normal")
    if SERVER then
        self:SetNPCMinBurst(30)
        self:SetNPCMaxBurst(30)
        self:SetNPCFireRate(0.01)
    end

    self:SetIronsights(false)
    self:SetTotalUsedMagCount(0)
    self:SetFireMode(self.Primary.Automatic and "auto" or "semi")
end

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "Ironsights")
    self:NetworkVar("Bool", 1, "Reloading")
    self:NetworkVar("Float", 0, "LastPrimaryAttack")
    self:NetworkVar("Float", 1, "ReloadEndTime")
    self:NetworkVar("Float", 2, "BurstTime")
    self:NetworkVar("Float", 3, "LastNonBurst")
    self:NetworkVar("Int", 0, "BurstBulletNum")
    self:NetworkVar("Int", 1, "TotalUsedMagCount")
    self:NetworkVar("String", 0, "FireMode")
    self:NetworkVar("Entity", 0, "LastOwner")
    self:NetworkVarNotify("Ironsights", fc{self.IronsightsChanged, fp{fn.Id, self}, fp{select, 4}})
end

function SWEP:Deploy()
    self:SetHoldType("normal")

    self:IronsightsChanged(self:GetIronsights())

    return true
end

function SWEP:OwnerChanged()
    if IsValid(self:GetOwner()) then self:SetLastOwner(self:GetOwner()) end
end

function SWEP:Holster()
    self:SetIronsights(false)
    if CLIENT then self.hasShot = false end

    if not IsValid(self:GetOwner()) then return true end
    if CLIENT then
        local vm = self:GetOwner():GetViewModel()
        self:ResetDarkRPBones(vm)
    end

    return true
end

function SWEP:OnRemove()
    self:SetIronsights(false)

    if CLIENT and IsValid(self:GetOwner()) then
        local vm = self:GetOwner():GetViewModel()
        self:ResetDarkRPBones(vm)
    end
end

--[[---------------------------------------------------------
Reload does nothing
---------------------------------------------------------]]
function SWEP:Reload()
    if not self:DefaultReload(ACT_VM_RELOAD) then return end
    self:SetReloading(true)
    self:SetIronsights(false)
    self:SetHoldType(self.HoldType)
    self:GetOwner():SetAnimation(PLAYER_RELOAD)
    self:SetReloadEndTime(CurTime() + 2)
    self:SetTotalUsedMagCount(self:GetTotalUsedMagCount() + 1)
end

function SWEP:PrimaryAttack()
    self.Primary.Automatic = self:GetFireMode() == "auto"

    if self:GetBurstBulletNum() == 0 and (self:GetLastNonBurst() or 0) > CurTime() - 0.6 then return end

    if self.MultiMode and self:GetOwner():KeyDown(IN_USE) then
        if self:GetFireMode() == "semi" then
            self:SetFireMode("burst")
            self.Primary.Automatic = false
            self:GetOwner():PrintMessage(HUD_PRINTCENTER, DarkRP.getPhrase("switched_burst"))
        elseif self:GetFireMode() == "burst" then
            self:SetFireMode("auto")
            self.Primary.Automatic = true
            self:GetOwner():PrintMessage(HUD_PRINTCENTER, DarkRP.getPhrase("switched_fully_auto"))
        elseif self:GetFireMode() == "auto" then
            self:SetFireMode("semi")
            self.Primary.Automatic = false
            self:GetOwner():PrintMessage(HUD_PRINTCENTER, DarkRP.getPhrase("switched_semi_auto"))
        end
        self:SetNextPrimaryFire(CurTime() + 0.5)
        self:SetNextSecondaryFire(CurTime() + 0.5)
        return
    end

    if self:GetHoldType() == "normal" and not GAMEMODE.Config.ironshoot then
        self:SetHoldType(self.HoldType)
    end

    if self:GetFireMode() ~= "burst" then
        self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
    end

    self:SetNextSecondaryFire(CurTime() + self.Primary.Delay)

    if self:Clip1() <= 0 then
        self:EmitSound("weapons/clipempty_rifle.wav")
        self:SetNextPrimaryFire(CurTime() + 2)
        return
    end

    if not self:CanPrimaryAttack() then self:SetIronsights(false) return end
    if not self:GetIronsights() and GAMEMODE.Config.ironshoot then return end
    -- Play shoot sound
    self:EmitSound(self.Primary.Sound)

    -- Shoot the bullet
    self:CSShootBullet(self.Primary.Damage, self.Primary.Recoil + 3, self.Primary.NumShots, self.Primary.Cone + .05)

    if self:GetFireMode() == "burst" then
        self:SetBurstBulletNum(self:GetBurstBulletNum() + 1)
        if self:GetBurstBulletNum() == 1 then
            self:SetLastNonBurst(CurTime())
        end
        if self:GetBurstBulletNum() == 3 then
            self:SetBurstTime(0)
            self:SetBurstBulletNum(0)
        else
            self:SetBurstTime(CurTime() + 0.1)
        end
    end

    -- Remove 1 bullet from our clip
    self:TakePrimaryAmmo(1)

    self:SetLastPrimaryAttack(CurTime())

    if self:GetOwner():IsNPC() then return end

    -- Punch the player's view
    self:GetOwner():ViewPunch(Angle(util.SharedRandom("DarkRP_CSBase" .. self:EntIndex() .. "Mag" .. self:GetTotalUsedMagCount() .. "p" .. self:Clip1(), -1.2, -1.1) * self.Primary.Recoil, util.SharedRandom("DarkRP_CSBase" .. self:EntIndex() .. "Mag" .. self:GetTotalUsedMagCount() .. "y" .. self:Clip1(), -1.1, 1.1) * self.Primary.Recoil, 0))
end

function SWEP:CSShootBullet(dmg, recoil, numbul, cone)
    if not IsValid(self:GetOwner()) then return end
    numbul = numbul or 1
    cone = cone or 0.01

    local bullet = {}
    bullet.Num = numbul or 1
    bullet.Src = self:GetOwner():GetShootPos()  -- Source
    bullet.Dir = (self:GetOwner():GetAimVector():Angle() + self:GetOwner():GetViewPunchAngles()):Forward() -- Dir of bullet
    bullet.Spread = Vector(cone, cone, 0)       -- Aim Cone
    bullet.Tracer = 4                           -- Show a tracer on every x bullets
    bullet.Force = 5                            -- Amount of force to give to phys objects
    bullet.Damage = dmg

    self:GetOwner():FireBullets(bullet)
    self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)      -- View model animation
    self:GetOwner():MuzzleFlash()        -- Crappy muzzle light
    self:GetOwner():SetAnimation(PLAYER_ATTACK1)       -- 3rd Person Animation

    if self:GetOwner():IsNPC() then return end

    -- Part of workaround, different viewmodel position if shots have been fired
    if CLIENT then self.hasShot = true end
end

function SWEP:DrawWeaponSelection(x, y, wide, tall, alpha)
    if self.IconLetter and string.find(self.IconLetter, "^[0-9a-wA-Z]$") then
        draw.DrawNonParsedSimpleText(self.IconLetter, "CSSelectIcons", x + wide / 2, y + tall * 0.2, Color(255, 210, 0, 255), TEXT_ALIGN_CENTER)

        -- try to fool them into thinking they're playing a Tony Hawks game
        draw.DrawNonParsedSimpleText(self.IconLetter, "CSSelectIcons", x + wide / 2 + math.Rand(-4, 4), y + tall * 0.2 + math.Rand(-14, 14), Color(255, 210, 0, math.Rand(10, 120)), TEXT_ALIGN_CENTER)
        draw.DrawNonParsedSimpleText(self.IconLetter, "CSSelectIcons", x + wide / 2 + math.Rand(-4, 4), y + tall * 0.2 + math.Rand(-9, 9), Color(255, 210, 0, math.Rand(10, 120)), TEXT_ALIGN_CENTER)
    else
        -- Set us up the texture
        surface.SetDrawColor(255, 255, 255, alpha)
        surface.SetTexture(self.WepSelectIcon)

        -- Lets get a sin wave to make it bounce
        local fsin = 0

        if self.BounceWeaponIcon then
            fsin = math.sin(CurTime() * 10) * 5
        end

        -- Borders
        y = y + 10
        x = x + 10
        wide = wide - 20

        -- Draw that motherfucker
        surface.DrawTexturedRect(x + fsin, y - fsin, wide - fsin * 2, (wide / 2) + fsin)

        -- Draw weapon info box
        self:PrintWeaponInfo(x + wide + 20, y + tall * 0.95, alpha)
    end
end

local IRONSIGHT_TIME = 0.25

function SWEP:GetViewModelPosition(pos, ang)
    if not self.IronSightsPos then return pos, ang end

    local bIron = self:GetIronsights()

    if bIron ~= self.bLastIron then
        self.bLastIron = bIron
        self.fIronTime = CurTime()

        if bIron then
            self.SwayScale  = 0.3
            self.BobScale   = 0.1
        else
            self.SwayScale  = 1.0
            self.BobScale   = 1.0
        end
    end

    local fIronTime = self.fIronTime or 0

    pos = pos + ang:Forward() * -5
    if GAMEMODE.Config.ironshoot then
        ang:RotateAroundAxis(ang:Right(), -15)
    end

    if not bIron and fIronTime < CurTime() - IRONSIGHT_TIME then
        return pos, ang
    end

    local Mul = 1.0

    if fIronTime > CurTime() - IRONSIGHT_TIME then
        Mul = math.Clamp((CurTime() - fIronTime) / IRONSIGHT_TIME, 0, 1)

        if not bIron then Mul = 1 - Mul end
    end

    local Offset    = self.IronSightsPos

    if self.IronSightsAng then
        ang = ang * 1
        ang:RotateAroundAxis(ang:Right(),   self.IronSightsAng.x * Mul)
        ang:RotateAroundAxis(ang:Up(),      self.IronSightsAng.y * Mul)
        ang:RotateAroundAxis(ang:Forward(), self.IronSightsAng.z * Mul)
    end

    if GAMEMODE.Config.ironshoot then
        ang:RotateAroundAxis(ang:Right(), Mul * 15)
    else
        ang:RotateAroundAxis(ang:Right(), Mul)
    end

    local Right     = ang:Right()
    local Up        = ang:Up()
    local Forward   = ang:Forward()

    pos = pos + Offset.x * Right * Mul
    pos = pos + Offset.y * Forward * Mul
    pos = pos + Offset.z * Up * Mul

    if not self.hasShot then
        if self.IronSightsAngAfterShootingAdjustment then
            ang:RotateAroundAxis(ang:Right(),   self.IronSightsAngAfterShootingAdjustment.x * Mul)
            ang:RotateAroundAxis(ang:Up(),      self.IronSightsAngAfterShootingAdjustment.y * Mul)
            ang:RotateAroundAxis(ang:Forward(), self.IronSightsAngAfterShootingAdjustment.z * Mul)
        end

        if self.IronSightsPosAfterShootingAdjustment then
            Offset = self.IronSightsPosAfterShootingAdjustment
            Right = ang:Right()
            Up = ang:Up()
            Forward = ang:Forward()

            pos = pos + Offset.x * Right * Mul
            pos = pos + Offset.y * Forward * Mul
            pos = pos + Offset.z * Up * Mul
        end
    end

    return pos, ang
end


function SWEP:IronsightsChanged(b)
    self:SetHoldType(b and self.HoldType or "normal")
end

function SWEP:SecondaryAttack()
    if not self.IronSightsPos then return end

    if self:GetReloading() then return end

    self:SetIronsights(not self:GetIronsights())

    self:SetNextSecondaryFire(CurTime() + 0.3)
end

function SWEP:OnRestore()
    self:SetNextSecondaryFire(0)
    self:SetIronsights(false)
end

function SWEP:OnDrop()
    self.PrimaryClipLeft = self:Clip1()
    self.SecondaryClipLeft = self:Clip2()

    if not IsValid(self:GetLastOwner()) then return end
    self.PrimaryAmmoLeft = self:GetLastOwner():GetAmmoCount(self:GetPrimaryAmmoType())
    self.SecondaryAmmoLeft = self:GetLastOwner():GetAmmoCount(self:GetSecondaryAmmoType())
    self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE_DEBRIS)
end

function SWEP:Equip(NewOwner)
    if self.PrimaryClipLeft and self.SecondaryClipLeft and self.PrimaryAmmoLeft and self.SecondaryAmmoLeft then
        NewOwner:SetAmmo(self.PrimaryAmmoLeft, self:GetPrimaryAmmoType())
        NewOwner:SetAmmo(self.SecondaryAmmoLeft, self:GetSecondaryAmmoType())

        self:SetClip1(self.PrimaryClipLeft)
        self:SetClip2(self.SecondaryClipLeft)
    end
end

function SWEP:Think()
    if self.Primary.ClipSize ~= -1 and not self:GetReloading() and not self:GetIronsights() and self:GetLastPrimaryAttack() + 1 < CurTime() and self:GetHoldType() == self.HoldType then
        self:SetHoldType("normal")
    end
    if self:GetReloadEndTime() ~= 0 and CurTime() >= self:GetReloadEndTime() then
        self:SetReloadEndTime(0)
        self:SetReloading(false)
        self:SetHoldType("normal")
        if CLIENT then self.hasShot = false end
    end
    if self:GetBurstTime() ~= 0 and CurTime() >= self:GetBurstTime() then
        self:PrimaryAttack()
    end
end

if CLIENT then
    function SWEP:ViewModelDrawn(vm)
        if self.DarkRPViewModelBoneManipulations and not self:GetReloading() then
            self:UpdateDarkRPBones(vm, self.DarkRPViewModelBoneManipulations)
        else
            self:ResetDarkRPBones(vm)
        end
    end

    function SWEP:UpdateDarkRPBones(vm, manipulations)
        if not IsValid(vm) or not vm:GetBoneCount() then return end

        -- Fill in missing bone names. Things fuck up when we workaround the scale bug and bones are missing.
        local bones = {}
        for i = 0, vm:GetBoneCount() - 1 do
            local bonename = vm:GetBoneName(i)
            if manipulations[bonename] then
                bones[bonename] = manipulations[bonename]
            else
                bones[bonename] = {
                    scale = Vector(1,1,1),
                    pos = Vector(0,0,0),
                    angle = Angle(0,0,0)
                }
            end
        end

        for k, v in pairs(bones) do
            local bone = vm:LookupBone(k)
            if not bone then continue end

            -- Bone scaling seems to be buggy. Workaround.
            local scale = Vector(v.scale.x, v.scale.y, v.scale.z)
            local ms = Vector(1,1,1)
            local cur = vm:GetBoneParent(bone)
            while cur >= 0 do
                local pscale = bones[vm:GetBoneName(cur)].scale
                ms = ms * pscale
                cur = vm:GetBoneParent(cur)
            end
            scale = scale * ms

            if vm:GetManipulateBoneScale(bone) ~= scale then
                vm:ManipulateBoneScale(bone, scale)
            end
            if vm:GetManipulateBonePosition(bone) ~= v.pos then
                vm:ManipulateBonePosition(bone, v.pos)
            end
            if vm:GetManipulateBoneAngles(bone) ~= v.angle then
                vm:ManipulateBoneAngles(bone, v.angle)
            end
        end
    end

    function SWEP:ResetDarkRPBones(vm)
        if not IsValid(vm) or not vm:GetBoneCount() then return end
        for i = 0, vm:GetBoneCount() - 1 do
            vm:ManipulateBoneScale(i, Vector(1, 1, 1))
            vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
            vm:ManipulateBonePosition(i, Vector(0, 0, 0))
        end
    end
end
--[[ 
hook.Add("SetupMove", "DarkRP_WeaponSpeed", function(ply, mv)
    local wep = ply:GetActiveWeapon()
    if not wep:IsValid() or not wep.DarkRPBased or not wep.GetIronsights or not wep:GetIronsights() then return end

    mv:SetMaxClientSpeed(mv:GetMaxClientSpeed() / 3)
end)
--]] 
--addons/weapon_cuffs/lua/weapons/weapon_cuff_base.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_base.lua     SHARED --
--                                 --
-- Base swep for handcuffs.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.Category = "Запрещено"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Связать"},
}

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 5
SWEP.PrintName = "UnnamedHandcuff"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/props_junk/cardboard_box004a.mdl"
SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 0.25

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "slam"

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/metalfloor_2-3"
SWEP.CuffRope = "cable/cable2"

SWEP.CuffStrength = 1
SWEP.CuffRegen = 1
SWEP.RopeLength = 0

SWEP.CuffReusable = false // Can reuse (ie, not removed on use)
SWEP.CuffRecharge = 5 // Time before re-use

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0 // Randomise strangth
SWEP.CuffRegenVariance = 0 // Randomise regen

//
// Network Vars
function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "IsCuffing" )
	self:NetworkVar( "Entity", 0, "Cuffing" )
	self:NetworkVar( "Float", 0, "CuffTime" )
end

//
// Standard SWEP functions
function SWEP:PrimaryAttack()
	if self:GetIsCuffing() then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if CLIENT then return end
	if self:GetCuffTime()>CurTime() then return end // On cooldown
	
	local tr = self:TargetTrace()
	if not tr then return end
	
	if InSpawn(tr.Entity) then 
        return
    end

	if tr.Entity:GetVehicle():IsValid() then 
        tr.Entity:ExitVehicle()
    end

	if self:GetOwner().StartDelay then
		self:GetOwner():StartDelay('handcuffs_cuff', 'Связывание', self.CuffTime, function(s, ply)
			self:SetIsCuffing( false )
			self:SetCuffTime( CurTime() + self.CuffRecharge )
			self:DoHandcuff( self:GetCuffing() )
		end, function(s, ply)
			if not IsValid(self) then return false end
			local tr = self:TargetTrace()
			if (not tr) or tr.Entity~=self:GetCuffing() then return false end
		end, function(s, ply)
			if IsValid(self) then
				self:SetIsCuffing(false)
				self:SetCuffTime( 0 )
			end
		end)
	end
	
	self:SetCuffTime( CurTime() + self.CuffTime )
	self:SetIsCuffing( true )
	self:SetCuffing( tr.Entity )
	
	sound.Play( self.CuffSound, self:GetOwner():GetShootPos(), 75, 100, 1 )
end
function SWEP:SecondaryAttack()
end
function SWEP:Reload()
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	
	if engine.ActiveGamemode()=="dayz" then self.CuffReusable = false end
end
function SWEP:Holster()
	if CLIENT and IsValid(self:GetOwner()) and self:GetOwner()==LocalPlayer() then
		local vm = self:GetOwner():GetViewModel()
		if not IsValid(vm) then return end
		
		vm:SetMaterial( "" )
	end
	if IsValid(self.cmdl_RightCuff) then self.cmdl_RightCuff:Remove() end
	if IsValid(self.cmdl_LeftCuff) then self.cmdl_LeftCuff:Remove() end
	
	return true
end
SWEP.OnRemove = SWEP.Holster

//
// Handcuff
function SWEP:DoHandcuff( target )
	if not (target and IsValid(target)) then return end
	if target:IsHandcuffed() then return end
	if not IsValid(self:GetOwner()) then return end
	
	local cuff = target:Give( "weapon_handcuffed" )
	cuff:SetCuffStrength( self.CuffStrength + (math.Rand(-self.CuffStrengthVariance,self.CuffStrengthVariance)) )
	cuff:SetCuffRegen( self.CuffRegen + (math.Rand(-self.CuffRegenVariance,self.CuffRegenVariance)) )
	
	cuff:SetCuffMaterial( self.CuffMaterial )
	cuff:SetRopeMaterial( self.CuffRope )
	
	cuff:SetKidnapper( self:GetOwner() )
	cuff:SetRopeLength( self.RopeLength )
	
	cuff:SetCanBlind( self.CuffBlindfold )
	cuff:SetCanGag( self.CuffGag )
	
	cuff.CuffType = self:GetClass() or ""
	
	hook.Call( "OnHandcuffed", GAMEMODE, self:GetOwner(), target, cuff )
	
	if not self.CuffReusable then
		if IsValid(self:GetOwner()) then self:GetOwner():ConCommand( "lastinv" ) end
		self:Remove()
	end
end

//
// Get Target
function SWEP:TargetTrace()
	if not IsValid(self:GetOwner()) then return end
	
	local tr = util.TraceLine( {start=self:GetOwner():GetShootPos(), endpos=(self:GetOwner():GetShootPos() + (self:GetOwner():GetAimVector()*50)), filter={self, self:GetOwner()}} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity~=self:GetOwner() and not tr.Entity:IsHandcuffed() then
		if hook.Run( "CuffsCanHandcuff", self:GetOwner(), tr.Entity )==false then return end
		return tr
	end
end

function SWEP:Think()

end

//
// HUD
local Col = {
	Text = Color(255,255,255), TextShadow = Color(0,0,0),
	
	BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
}
local matGrad = Material( "gui/gradient" )
function SWEP:DrawHUD()
	if not self:GetIsCuffing() then
		if self:GetCuffTime()<=CurTime() then return end
		
		local w,h = (ScrW()/2), (ScrH()/2)
		
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, h+55, 200, 20 )
		
		local CuffingPercent = math.Clamp( ((self:GetCuffTime()-CurTime())/self.CuffRecharge), 0, 1 )
		render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,h+55, 200,20 )
			
			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,h+55, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )
		
		return
	end

	/*
	local w,h = (ScrW()/2), (ScrH()/2)
	
	draw.SimpleText( "Restraining target...", "HandcuffsText", w+1, h+31, Col.TextShadow, TEXT_ALIGN_CENTER )
	draw.SimpleText( "Restraining target...", "HandcuffsText", w, h+30, Col.Text, TEXT_ALIGN_CENTER )
	
	surface.SetDrawColor( Col.BoxOutline )
	surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
	surface.SetDrawColor( Col.BoxBackground )
	surface.DrawRect( w-100, h+55, 200, 20 )
	
	local CuffingPercent = math.Clamp( 1-((self:GetCuffTime()-CurTime())/self.CuffTime), 0, 1 )
	
	render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )
		surface.SetDrawColor( Col.BoxRight )
		surface.DrawRect( w-100,h+55, 200,20 )
		
		surface.SetMaterial( matGrad )
		surface.SetDrawColor( Col.BoxLeft )
		surface.DrawTexturedRect( w-100,h+55, 200,20 )
	render.SetScissorRect( 0,0,0,0, false )
	*/
end

//
// Rendering
local renderpos = {
	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(3.2,2.1,0.4), ang=Angle(-2,0,80), scale = Vector(0.045,0.045,0.03)},
	rope = {l = Vector(0,0,2.0), r = Vector(2.3,-1.9,2.7)},
}
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local RopeCol = Color(255,255,255)
function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end
	
	vm:SetMaterial( "engine/occlusionproxy" )
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
		
		renderpos.left.pos = self:GetOwner():GetPos()
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end
	
	-- local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )
	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )
	if not (rpos and rang) then return end
	
	// Right
	local fixed_rpos = rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z)
	self.cmdl_RightCuff:SetPos( fixed_rpos )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()
	
	// Left
	if CurTime()>(renderpos.left.NextThink or 0) then
		local dist = renderpos.left.pos:DistToSqr( fixed_rpos )
		if dist>10000 then
			renderpos.left.pos = fixed_rpos
			renderpos.left.vel = Vector(0,0,0)
		elseif dist > 100 then
			local target = (fixed_rpos - renderpos.left.pos)*0.3
			renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, target.x, 1 )
			renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, target.y, 1 )
			renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, target.z, 3 )
		end
		
		renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, 0, 0.5 )
		renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, 0, 0.5 )
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, 0, 0.5 )
		-- if renderpos.left.vel:Length()>10 then renderpos.left.vel:Mul(0.1) end
		
		local targetZ = ((fixed_rpos.z - 10) - renderpos.left.pos.z) * renderpos.left.gravity
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, targetZ, 3 )
		
		renderpos.left.pos:Add( renderpos.left.vel )
		
		-- renderpos.left.NextThink = CurTime()+0.01
	end
	
	self.cmdl_LeftCuff:SetPos( renderpos.left.pos )
	self.cmdl_LeftCuff:SetAngles( renderpos.left.ang )
	
	-- self.cmdl_LeftCuff:SetAngles( rang )
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_LeftCuff:DrawModel()
	
	// Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( renderpos.left.pos + renderpos.rope.l,
		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),
		0.7, 0, 5, RopeCol )
end

SWEP.wrender = {
	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(2.95,2.5,-0.2), ang=Angle(30,0,90), scale = Vector(0.044,0.044,0.044)},
	rope = {l = Vector(0,0,2), r = Vector(3,-1.65,1)},
}
function SWEP:DrawWorldModel()
	if not IsValid(self:GetOwner()) then return end
	local wrender = self.wrender
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
	end
	
	local rpos, rang = self:GetBonePos( wrender.right.bone, self:GetOwner() )
	if not (rpos and rang) then return end
	
	// Right
	local fixed_rpos = rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z)
	self.cmdl_RightCuff:SetPos( fixed_rpos )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()
	
	// Left
	if CurTime()>(wrender.left.NextThink or 0) then
		local dist = wrender.left.pos:DistToSqr( fixed_rpos )
		if dist>10000 then
			wrender.left.pos = fixed_rpos
			wrender.left.vel = Vector(0,0,0)
		elseif dist > 100 then
			local target = (fixed_rpos - wrender.left.pos)*0.3
			wrender.left.vel.x = math.Approach( wrender.left.vel.x, target.x, 1 )
			wrender.left.vel.y = math.Approach( wrender.left.vel.y, target.y, 1 )
			wrender.left.vel.z = math.Approach( wrender.left.vel.z, target.z, 3 )
		end
		
		wrender.left.vel.x = math.Approach( wrender.left.vel.x, 0, 0.5 )
		wrender.left.vel.y = math.Approach( wrender.left.vel.y, 0, 0.5 )
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, 0, 0.5 )
		-- if wrender.left.vel:Length()>10 then wrender.left.vel:Mul(0.1) end
		
		local targetZ = ((fixed_rpos.z - 10) - wrender.left.pos.z) * wrender.left.gravity
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, targetZ, 3 )
		
		wrender.left.pos:Add( wrender.left.vel )
		
		-- wrender.left.NextThink = CurTime()+0
	end
	
	self.cmdl_LeftCuff:SetPos( wrender.left.pos )
	self.cmdl_LeftCuff:SetAngles( wrender.left.ang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_LeftCuff:DrawModel()
	
	// Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( wrender.left.pos + wrender.rope.l,
		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),
		0.7, 0, 5, RopeCol )
end

//
// Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )
	if not bone then return end
	
	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )
	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end
	
	if self.ViewModelFlip then ang.r = -ang.r end
	
	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end
	return pos, ang
end

--addons/weapon_cuffs/lua/weapons/weapon_cuff_police.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_police.lua   SHARED --
--                                 --
-- Strong police handcuffs.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Запрещено"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Крепкие металлические наручники"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.PrintName = "Наручники"

//
// Handcuff Vars
SWEP.CuffTime = 0.3 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/gear"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 1.4
SWEP.CuffRegen = 1.4
SWEP.RopeLength = 100
SWEP.CuffReusable = true

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1 // Randomise strangth
SWEP.CuffRegenVariance = 0.1 // Randomise regen

--addons/weapon_cuffs/lua/weapons/weapon_handcuffed.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_handcuffed.lua    SHARED --
--                                 --
-- Handcuffed. Limits what         --
-- equipping player can do.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.Category = "Запрещено"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.Slot = 5
SWEP.PrintName = "В наручниках"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_arms_citizen.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "duel"

SWEP.IsHandcuffs = true
SWEP.CuffType = ""

CreateConVar( "cuffs_allowbreakout", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE,FCVAR_REPLICATED,FCVAR_NOTIFY} )

// For anything that might try to drop this
SWEP.CanDrop = false
SWEP.PreventDrop = true
-- Missing anything?

//
// DataTables
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Kidnapper" )
	self:NetworkVar( "Entity", 1, "FriendBreaking" )

	self:NetworkVar( "Float", 0, "RopeLength" )
	self:NetworkVar( "Float", 1, "CuffBroken" )
	self:NetworkVar( "Float", 2, "CuffStrength" )
	self:NetworkVar( "Float", 3, "CuffRegen" )

	self:NetworkVar( "String", 0, "RopeMaterial" )
	self:NetworkVar( "String", 1, "CuffMaterial" )

	self:NetworkVar( "Bool", 0, "CanGag" )
	self:NetworkVar( "Bool", 1, "IsGagged" )

	self:NetworkVar( "Bool", 2, "CanBlind" )
	self:NetworkVar( "Bool", 3, "IsBlind" )
end

//
// Initialize
function SWEP:Initialize()
	hook.Add( "canDropWeapon", self, function(self, ply, wep)
		if wep==self then return false, 'Твои руки связаны' end
	end) -- Thank you DarkRP, your code is terrible

	if self:GetCuffStrength()<=0 then self:SetCuffStrength(1) end
	if self:GetCuffRegen()<=0 then self:SetCuffRegen(1) end
	self:SetCuffBroken( 0 )

	self:SetHoldType( self.HoldType )
end

//
// Standard SWEP functions
function SWEP:PrimaryAttack()
	if SERVER then self:AttemptBreak() end
end
function SWEP:SecondaryAttack() end
function SWEP:Reload() end

//
// Equip and Holster
function SWEP:Equip( newOwner )
	newOwner:DropObject()	
	newOwner:SelectWeapon( self:GetClass() )

	timer.Simple( 0.1, function() // Fucking FA:S
		if IsValid(self) and  IsValid(newOwner) and newOwner:GetActiveWeapon()~=self then
			local wep = newOwner:GetActiveWeapon()
			if not IsValid(wep) then return end

			local oHolster = wep.Holster
			wep.Holster = function() return true end
			newOwner:SetActiveWeapon( self )
			wep.Holster = oHolster
		end
	end)

	return true
end
function SWEP:Holster()
	return false
end

//
// Deploy
function SWEP:Deploy()
	local viewModel = self:GetOwner():GetViewModel()
	viewModel:SendViewModelMatchingSequence( viewModel:LookupSequence("fists_idle_01") )

	return true
end
function SWEP:PreDrawViewModel( viewModel ) // Fixes visible base hands
	viewModel:SetMaterial( "engine/occlusionproxy" )
end
function SWEP:OnRemove() // Fixes invisible other weapons
	if IsValid(self:GetOwner()) then
		local viewModel = self:GetOwner():GetViewModel()
		if IsValid(viewModel) then viewModel:SetMaterial("") end
	end
	if IsValid( self.cmdl_LeftCuff ) then self.cmdl_LeftCuff:Remove() end
	if IsValid( self.cmdl_RightCuff ) then self.cmdl_RightCuff:Remove() end
	return true
end

//
// Release
function SWEP:Uncuff()
	local ply = IsValid(self:GetOwner()) and self:GetOwner()

	self:Remove()

	if ply then ply:ConCommand( "lastinv" ) end
end

//
// Breakout
if SERVER then
	local BreakSound = Sound( "physics/metal/metal_barrel_impact_soft4.wav" )
	function SWEP:Breakout()
		if IsValid(self:GetOwner()) then
			sound.Play( BreakSound, self:GetOwner():GetShootPos(), 75, 100, 1 )
			if IsValid( self:GetFriendBreaking() ) then
				hook.Call( "OnHandcuffBreak", GAMEMODE, self:GetOwner(), self, self:GetFriendBreaking() )
			else
				hook.Call( "OnHandcuffBreak", GAMEMODE, self:GetOwner(), self )
			end
		end

		self:Uncuff()
	end
	function SWEP:AttemptBreak()
		if not cvars.Bool( "cuffs_allowbreakout" ) then return end
		if hook.Run('CanBreakCuffs', self:GetOwner(), self) == false then return end

		self:SetCuffBroken( self:GetCuffBroken() + math.abs(4/self:GetCuffStrength()) )

		if self:GetCuffBroken()>=100 then
			self:Breakout()
		end
	end

	local function GetTrace( ply )
		local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
		if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
			local cuffed,wep = tr.Entity:IsHandcuffed()
			if cuffed then return tr,wep end
		end
	end
	function SWEP:Think()
		if (self.NextRegen or 0)<=CurTime() then
			local regen = self:GetCuffRegen()
			local friend = self:GetFriendBreaking()
			if IsValid(friend) and friend:IsPlayer() then
				local tr = GetTrace(friend)
				if tr and tr.Entity==self:GetOwner() then
					regen = (regen*0.5) - (2/self:GetCuffStrength())
				else
					self:SetFriendBreaking( nil )
				end
			end

			self:SetCuffBroken( math.Approach( self:GetCuffBroken(), regen<0 and 100 or 0, math.abs(regen) ) )
			self.NextRegen = CurTime()+0.05

			if self:GetCuffBroken()>=100 then self:Breakout() end
		end
		if IsValid(self:GetKidnapper()) and (self:GetKidnapper():IsPlayer() and not self:GetKidnapper():Alive()) then
			self:SetKidnapper( nil )
		end
		if IsValid(self:GetOwner()) then
			self:GetOwner().KnockoutTimer = CurTime()+10 // Fucking DarkRP
		end
	end
end

//
// UI
if CLIENT then
	surface.CreateFont( "HandcuffsText", {
		font = "Arial",
		size = 20,
		weight = 700,
	})
	local Col = {
		Text = Color(255,255,255), TextShadow = Color(0,0,0),

		BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),

		Blind = Color(0,0,0, 253), Blind2 = Color(0,0,0, 255),
	}
	local matGrad = Material( "gui/gradient" )
	function SWEP:DrawHUD()
		local w,h = (ScrW()/2), (ScrH()/2)

		local TextPos = h+30
		local str = string.format( "Ты связан" )

		draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
		draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )

		if self:GetIsBlind() then
			TextPos = TextPos+20
			draw.SimpleText( "Тебе завязали глаза", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "Тебе завязали глаза", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end
		if self:GetIsGagged() then
			TextPos = TextPos+20
			draw.SimpleText( "У тебя во рту кляп", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "У тебя во рту кляп", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end

		if cvars.Bool( "cuffs_allowbreakout" ) then
			TextPos = TextPos+20
			str = string.format("%s — вырываться", ("ЛКМ"):upper())
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end

		TextPos = TextPos+25
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, TextPos, 200, 20 )

		render.SetScissorRect( w-100, TextPos, (w-100)+((self:GetCuffBroken()/100)*200), TextPos+20, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,TextPos, 200,20 )

			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,TextPos, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )
	end
	function SWEP:DrawHUDBackground()
		if self:GetIsBlind() then
			surface.SetDrawColor( Col.Blind )
			surface.DrawRect( 0,0, ScrW(), ScrH() )

			surface.SetDrawColor( Col.Blind2 )
			for i=1,ScrH(),5 do
				surface.DrawRect( 0,i, ScrW(), 4 )
			end
			for i=1,ScrW(),5 do
				surface.DrawRect( i,0, 4,ScrH() )
			end
		end
	end
end

//
// Rendering
local renderpos = {
	left = {bone = "ValveBiped.Bip01_L_Wrist", pos=Vector(0.4,-0.15,-0.45), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.015)},
	right = {bone = "ValveBiped.Bip01_R_Wrist", pos=Vector(0.2,-0.15,0.35), ang=Angle(100,0,0), scale = Vector(0.035,0.035,0.015)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local DefaultRope = "cable/cable2"
local RopeCol = Color(255,255,255)
function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end

	local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )
	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )
	if not (lpos and rpos and lang and rang) then return end

	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*renderpos.left.pos.x) + (lang:Right()*renderpos.left.pos.y) + (lang:Up()*renderpos.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, renderpos.left.ang.y )
	lang:RotateAroundAxis( r, renderpos.left.ang.p )
	lang:RotateAroundAxis( f, renderpos.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )

	local matrix = Matrix()
	matrix:Scale( renderpos.left.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )

	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()

	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )

	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )

	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()

	// Rope
	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end

	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*renderpos.rope.l.x) + (lang:Right()*renderpos.rope.l.y) + (lang:Up()*renderpos.rope.l.z),
		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),
		0.7, 0, 5, RopeCol )
end

local wrender = {
	left = {bone = "ValveBiped.Bip01_L_Hand", pos=Vector(0,0,0), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(0.2,0,0), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
function SWEP:DrawWorldModel()
	if not IsValid(self:GetOwner()) then return end

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		-- self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		-- self.cmdl_RightCuff:SetParent( vm )
	end

	local lpos, lang = self:GetBonePos( wrender.left.bone, self:GetOwner() )
	local rpos, rang = self:GetBonePos( wrender.right.bone, self:GetOwner() )
	if not (lpos and rpos and lang and rang) then return end

	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*wrender.left.pos.x) + (lang:Right()*wrender.left.pos.y) + (lang:Up()*wrender.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, wrender.left.ang.y )
	lang:RotateAroundAxis( r, wrender.left.ang.p )
	lang:RotateAroundAxis( f, wrender.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )

	local matrix = Matrix()
	matrix:Scale( wrender.left.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )

	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()

	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )

	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )

	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()

	// Rope
	if (lpos.x==0 and lpos.y==0 and lpos.z==0) or (rpos.x==0 and rpos.y==0 and rpos.z==0) then return end // Rope accross half the map...

	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end

	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*wrender.rope.l.x) + (lang:Right()*wrender.rope.l.y) + (lang:Up()*wrender.rope.l.z),
		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),
		0.7, 0, 5, RopeCol )
end

//
// Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )
	if not bone then return end

	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )
	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end

	if self.ViewModelFlip then ang.r = -ang.r end

	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end
	return pos, ang
end

--addons/weapon_melee/lua/weapons/weapon_hl2brokenbottle/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Разбитая бутылка"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack:  Stab"
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_brokenbottle.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_brokenbottle.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 64
SWEP.HitRadius			= 6
SWEP.HitPushback		= 0
SWEP.HitRate			= 0.50
SWEP.MinDamage			= 35
SWEP.MaxDamage			= 55

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "knife" )
	self:SetVar("restricted_to_drop", true)
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()

	return true	
end

function SWEP:OnDrop()
	
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/weapon_melee/lua/weapons/weapon_hl2katana/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Катана"
SWEP.Author					= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing -  Secondary attack : Push (Pulls instead of pushing back on primary attack)"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Удар с рывком"},
	{key = KEY_R, desc = "Удар с прыжком"},
}
SWEP.Category				= "Запрещено"

SWEP.Slot					= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/c_hiltless.mdl" )
SWEP.WorldModel				= Model( "models/weapons/w_hiltless.mdl" )
SWEP.ViewModelFOV			= 95
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.DrawAmmo				= false

SWEP.HitDistance			= 80
SWEP.HitRadius				= 16
SWEP.HitPushback			= -1000
SWEP.HitRate				= 0.60
SWEP.MinDamage				= 65
SWEP.MaxDamage				= 75

SWEP.NextReload                 = 0
SWEP.Combo 					= 1

local SwingSound = Sound( "weapons/jackssword/sj_sword_swing.wav" )
local HitSoundBody = Sound( "weapons/hiltiless/hit1.mp3", "weapons/hiltiless/hit2.mp3", "weapons/hiltiless/hit3.mp3" )
local HitSoundWorld = Sound( "weapons/hiltiless/hit1.mp3", "weapons/hiltiless/hit2.mp3", "weapons/hiltiless/hit3.mp3" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

local anims = {
	[1] = ACT_VM_PRIMARYATTACK,
	[2] = ACT_VM_MISSLEFT,
	[3] = ACT_VM_SECONDARYATTACK,
	[4] = ACT_VM_HITLEFT,
}

local punch = {
	[1] = Angle(5, 0, 0),
	[2] = Angle(5, 0, 0),
	[3] = Angle(0, 5, 0),
	[4] = Angle(-5, 0, 0),
}

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()
	if self.Combo > 2 then self.Combo = 1 end

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	self:SendWeaponAnim(anims[self.Combo])

	
	self:EmitSound( SwingSound, 65, math.random(80, 105))
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	self:Hitscan(self.Combo)

	self.Combo = self.Combo + 1

end

function SWEP:SecondaryAttack()

	local ply = self:GetOwner()
	local boost = ply:Team() == TEAM_NOBLOOD and not ply:GetNetVar('duelSystem.OnDuel')

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 2.1 )

	self:EmitSound( SwingSound )

	ply:SetAnimation( PLAYER_ATTACK1 )
	self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)

	if boost then 
		ply:SetVelocity(Vector(0,0,250))
		
		local effectdata = EffectData()
		effectdata:SetOrigin( ply:EyePos() )
		effectdata:SetStart( ply:EyePos() )
		effectdata:SetEntity(ply)
		util.Effect( "darkclouds", effectdata )
		ply:EmitSound("darkcloud.wav",25,80)
	end
	
	ply:SetLocalVelocity(ply:GetAimVector() * (boost and 700 or 400))

	self:Hitscan(3)

end

function SWEP:Reload()
	if CurTime() < self.NextReload then return end 

	local ply = self:GetOwner()
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound, 65, math.random(95, 105))

	ply:SetAnimation( PLAYER_ATTACK1 )
	self:SendWeaponAnim(ACT_VM_HITLEFT)

	self:Hitscan(4)

	ply:SetLocalVelocity(Vector(0,0,400))
	self.NextReload = CurTime() + 4
end

function SWEP:OnDrop()

end

function SWEP:Hitscan(combo)
	local ply = self:GetOwner()
	ply:ViewPunch(punch[combo])
	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)


		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:GetOwner():EmitSound(SwingSound, 65, math.random(80, 105))

		if hithuman then
			self:EmitSound("weapons/tfa_makato/makato_hitflesh"..math.random(1, 4)..".wav", 65, math.random(95, 105))
			hitent:SetVelocity(self:GetOwner():GetAimVector()  * 250)
			if combo == 4 then
				hitent:SetVelocity(Vector(0,0,300))
				hitent:EmitSound("physics/body/body_medium_break"..math.random(2, 4)..".wav")
				self:GetOwner():SetLocalVelocity(Vector(0,0,400))
			end
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/weapon_melee/lua/weapons/weapon_hl2pan/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Сковорода"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack:  Swing"
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pan.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pan.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 64
SWEP.HitRadius			= 16
SWEP.HitPushback		= 300
SWEP.HitRate			= 1.00
SWEP.MinDamage			= 20
SWEP.MaxDamage			= 35

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Metal_Box.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()
	
	return true
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/weapon_melee/lua/weapons/weapon_hl2pot/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Ковш"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack:  Swing"
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pot.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pot.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 64
SWEP.HitRadius			= 12
SWEP.HitPushback		= 200
SWEP.HitRate			= 0.90
SWEP.MinDamage			= 35
SWEP.MaxDamage			= 50

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Metal_Box.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()
	return true
end

function SWEP:OnDrop()
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/weapon_melee/lua/weapons/weapon_hl2shovel/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Лопата"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack:  Swing - Secondary attack : Push"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Толкнуть"},
}
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_shovel.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_shovel.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 80
SWEP.HitRadius			= 16
SWEP.HitPushback		= 2000
SWEP.HitRate			= 0.7
SWEP.MinDamage			= 70
SWEP.MaxDamage			= 110

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local ply = self:GetOwner()

	local vm = ply:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*50,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		self:EmitSound(PushSoundBody)

		if hithuman then
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * 500)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:OnDrop()
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/_smallscripts/lua/weapons/weapon_nalog.lua:
AddCSLuaFile()

SWEP.Base				= "weapon_base"

SWEP.PrintName			= "Бланк "		
SWEP.ClassName			= "weapon_nalog"
SWEP.Author				= "WayZer"
SWEP.Category 			= "Запрещено"
SWEP.Instructions		= "ЛКМ - Списать налог ПКМ - Посмотреть кол-во денег"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Списать налог"},
	{key = MOUSE_RIGHT, desc = "Проверить кошелек"},
}
SWEP.Slot				= 1
SWEP.SlotPos			= 0
		
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= false

SWEP.Primary.ClipSize 	= -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Spawnable			= false
SWEP.AdminOnly			= true

SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/wayzer/c_petition.mdl")
SWEP.UseHands = true
SWEP.WorldModel = Model("models/wayzer/clipboard.mdl")

local PlayersUsed = {}

if SERVER then
    
hook.Add('Think', 'clear_used', function()
    hook.Remove('Think', 'clear_used')
    timer.Create('clear_used_nalog', 3600, 0, function()
        PlayersUsed = {}
        for k,v in player.Iterator() do
            DarkRP.notify(v, 2, 3, 'Налоговая база очищена! Стартовал повторный сбор налогов.')
        end
    end)
end)

end


function SWEP:Initialize()
	self:SetHoldType( "slam" )
end

function SWEP:PrimaryAttack()
    self:SetHoldType("slam")

	self:GetOwner():SetAnimation( PLAYER_IDLE )
   	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
    
    if SERVER then
	
		local trace = self:GetOwner():GetEyeTrace()
		local victim = trace.Entity
		local ply = self:GetOwner()

		if not IsValid(victim) or not victim:IsPlayer() or victim:GetPos():DistToSqr(ply:GetPos()) > 10000 then
			return
		end

		if InSpawn(self:GetOwner()) or InSpawn(victim) then return end
		if ply:Team() ~= TEAM_NALOG then self:Remove() return end
		if (victim:Team() == TEAM_ADMIN or victim:Team() == TEAM_MAYOR) then DarkRP.notify(ply, 1, 5, 'Ты не можешь списывать с него налог!') return end
		if not victim:canAfford(100000) then DarkRP.notify(ply, 1, 5, victim:DisplayName()..' находится в списке малоимущих! С него нельзя списать налог.') return end

		local donenalog = PlayersUsed[ victim:SteamID() ]

		if donenalog then DarkRP.notify(ply, 1, 5, victim:DisplayName()..' уже оплатил налог!') return end
		
		ply:EmitSound("npc/combine_soldier/gear4.wav", 50, 100)
			
		local percent = math.Clamp(math.floor(victim:GetNetVar("money") / 100 * 1), 500, 150000)
		local result = math.floor(percent / 4)

		ply:StartDelay('nalog', 'Списание налога', 10, function(s, ply)
			local donenalog = PlayersUsed[ victim:SteamID() ]

			if donenalog then DarkRP.notify(ply, 1, 5, victim:DisplayName()..' уже оплатил налог!') return end

			victim:addMoney(-percent)
			DarkRP.notify(victim, 1, 5, "С вас списали налог в размере "..DarkRP.formatMoney(percent)..", с этой суммы 25% уходит сотруднику")
			
			self:GetOwner():addMoney(result)
			DarkRP.notify(ply, 0, 5, "Ты списал с "..victim:DisplayName().." налог в размере "..DarkRP.formatMoney(percent).." ваша прибыль "..DarkRP.formatMoney(result))
			
			self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
			self:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
			-- WayPass

			hook.Call('BPNalog', nil, ply, victim)


			if #team.GetPlayers(TEAM_MAYOR) == 1 then
				for k,v in pairs(team.GetPlayers(TEAM_MAYOR)) do
					v:addMoney(result)
					DarkRP.notify(v, 0, 10, "[Налоговая инспекция] Вы получили "..DarkRP.formatMoney(result).." с налоговой декларации "..victim:DisplayName())
					break
				end
			end

			PlayersUsed[ victim:SteamID() ] = true
		end, function(s, ply)
			if not IsValid(victim) then return false end
			if not victim:canAfford(100000) then return false end
			if victim:GetPos():DistToSqr(ply:GetPos()) > 10000 then return false end
		end, nil, {
			targetEnt = ent,
		}):CreateTimer(1, function(self)
			ply:DoAnimationEvent(ACT_GMOD_GESTURE_ITEM_PLACE)
		end)

	end
end

function SWEP:SecondaryAttack()
	local ply = self:GetOwner()
	ply:SetAnimation( PLAYER_IDLE )
   	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

    if SERVER then
    self:SetNextSecondaryFire( CurTime() + 2 )
	
	local trace = ply:GetEyeTrace()
	local target = trace.Entity
	if not IsValid(target) or not target:IsPlayer() or target:GetPos():DistToSqr(ply:GetPos()) > 10000 then
		return
	end
	
	local donenalog = PlayersUsed[ target:SteamID() ]

	DarkRP.notify(ply, 1, 5, 'Отчет о налогах: '..(donenalog and 'Оплачено' or 'Не оплачено'))
    DarkRP.notify(ply, 0, 5, 'Баланс: '..DarkRP.formatMoney(target:GetNetVar("money")))
    end
end

function SWEP:Reload()
end
--addons/_smallscripts/lua/weapons/weapon_spiderfists.lua:

AddCSLuaFile()

SWEP.PrintName = "Супер кулаки"
SWEP.Author = "WayZer"
SWEP.Purpose = "Кулаки SpiderMan'a."
SWEP.Controls = {
	{key = KEY_R, desc = "Взрыв", check = function(wep) return LocalPlayer():Team() == TEAM_BLACKSS end},
	{key = MOUSE_RIGHT, desc = "Полет", check = function(wep) return LocalPlayer():Team() == TEAM_HOMELANDER end},
	{key = KEY_R, desc = "Лазеры из глаз", check = function(wep) return LocalPlayer():Team() == TEAM_HOMELANDER end},
}
SWEP.Category = "Запрещено"
SWEP.Slot = 2
SWEP.SlotPos = 0

SWEP.Spawnable = true

SWEP.ViewModel = Model( "models/weapons/c_arms.mdl" )
SWEP.WorldModel = ""
SWEP.ViewModelFOV = 54
SWEP.UseHands = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false

SWEP.HitDistance = 48

SWEP.isReloading = false

local SwingSound = Sound( "WeaponFrag.Throw" )
local HitSound = Sound( "Flesh.ImpactHard" )

local function lookingAtLockable(ply, ent)
    local eyepos = ply:EyePos()
    if not IsValid(ent) then return false end
	
	if ent:IsDoor() then
		if eyepos:DistToSqr(ent:GetPos()) < 4225 then return true end
	elseif ent:IsVehicle() then
		if eyepos:DistToSqr(ent:NearestPoint(eyepos)) < 10000 then return true end
	end

	return false
end

function SWEP:Initialize()

	self:SetHoldType( "fist" )

end

function SWEP:SetupDataTables()

	self:NetworkVar( "Float", 0, "NextMeleeAttack" )
	self:NetworkVar( "Float", 1, "NextIdle" )
	self:NetworkVar( "Int", 0, "Combo" )
	self:NetworkVar( "Int", 1, "NextExplode" )

end

function SWEP:UpdateNextIdle()

	local vm = self:GetOwner():GetViewModel()
	self:SetNextIdle( CurTime() + vm:SequenceDuration() / vm:GetPlaybackRate() )

end

function SWEP:PrimaryAttack( right )

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local anim = "fists_left"
	if ( right ) then anim = "fists_right" end
	if ( self:GetCombo() >= 2 ) then
		anim = "fists_uppercut"
	end

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( anim ) )

	self:EmitSound( SwingSound )

	self:UpdateNextIdle()
	self:SetNextMeleeAttack( CurTime() + 0.2 )

	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )

	if CLIENT then return end
	
	local job = {
		[TEAM_SHAZAM] = true,
		[TEAM_BLACKSS] = true,
		[TEAM_BANTANK] = true,
		[TEAM_NOBLOOD] = true,
		[TEAM_HOMELANDER] = true,
	}

	local ent = self:GetOwner():GetEyeTrace().Entity
	
	if ent:GetClass() == "prop_door_rotating" and job[self:GetOwner():Team()] then
		
		if ent:GetPos():DistToSqr(self:GetOwner():GetShootPos()) > 10000 then return end
		ent:SetKeyValue("Speed", "500")
		ent:SetKeyValue("Open Direction", "Both directions")
		ent:SetKeyValue("opendir", "0")
		ent:Fire("unlock", "", .01)
		ent:Fire("openawayfrom", "bashingpl" .. self:GetOwner():EntIndex(), .01)
		ent:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))

		timer.Simple(0.3, function()
			if IsValid(ent) then
				ent:SetKeyValue("Speed", "100")
			end
		end)
	end

	--[[
    if not lookingAtLockable(self:GetOwner(), trace.Entity) then return end

    self:SetNextSecondaryFire(CurTime() + 0.3)

    if CLIENT then return end

    if self:GetOwner():canKeysUnlock(trace.Entity) then
        trace.Entity:keysUnLock()
    elseif trace.Entity:IsVehicle() then
        DarkRP.notify(self:GetOwner(), 1, 3, DarkRP.getPhrase("do_not_own_ent"))
    end
	]]
end

function SWEP:Holster()
	local ply = self:GetOwner()
	
	if ply:Team() == TEAM_HOMELANDER then
		ply:SetMoveType(MOVETYPE_WALK)
	end

	return true
end

function SWEP:SecondaryAttack()
	local ply = self:GetOwner()

	if ply:Team() == TEAM_HOMELANDER and SERVER then
		if ply:GetMoveType() ~= MOVETYPE_FLY then
			ply:SetFOV(ply:GetFOV() + 25, 1)
			ply:SetMoveType(MOVETYPE_FLY)
			ply:EmitSound("homelander.mp3")
			ParticleEffect( "explosion_huge_d", ply:GetPos(), Angle( 0, 0, 0 ) )
			self:SetNextSecondaryFire(CurTime() + 1)
		else
			ply:SetFOV(ply:GetFOV() - 25, 1)
			ply:SetMoveType(MOVETYPE_WALK)
			self:SetNextSecondaryFire(CurTime() + 1)
		end
	end
	
	if ply:Team() ~= TEAM_HOMELANDER then
		self:PrimaryAttack( true )
	end
end

function SWEP:DealDamage()

	local anim = self:GetSequenceName(self:GetOwner():GetViewModel():GetSequence())

	self:GetOwner():LagCompensation( true )

	local tr = util.TraceLine( {
		start = self:GetOwner():GetShootPos(),
		endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * self.HitDistance,
		filter = self:GetOwner(),
		mask = MASK_SHOT_HULL
	} )

	if ( !IsValid( tr.Entity ) ) then
		tr = util.TraceHull( {
			start = self:GetOwner():GetShootPos(),
			endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * self.HitDistance,
			filter = self:GetOwner(),
			mins = Vector( -10, -10, -8 ),
			maxs = Vector( 10, 10, 8 ),
			mask = MASK_SHOT_HULL
		} )
	end

	-- We need the second part for single player because SWEP:Think is ran shared in SP
	if ( tr.Hit && !( game.SinglePlayer() && CLIENT ) ) then
		self:EmitSound( HitSound )
	end

	local hit = false

	if ( SERVER && IsValid( tr.Entity ) && ( tr.Entity:IsNPC() || tr.Entity:IsPlayer() || tr.Entity:Health() > 0 ) ) then
		local dmginfo = DamageInfo()

		local attacker = self:GetOwner()
		if ( !IsValid( attacker ) ) then attacker = self end
		dmginfo:SetAttacker( attacker )

		dmginfo:SetInflictor( self )
		dmginfo:SetDamage( math.random( 100, 150 ) )

		if ( anim == "fists_left" ) then
			dmginfo:SetDamageForce( self:GetOwner():GetRight() * 4912 + self:GetOwner():GetForward() * 9998 ) -- Yes we need those specific numbers
		elseif ( anim == "fists_right" ) then
			dmginfo:SetDamageForce( self:GetOwner():GetRight() * -4912 + self:GetOwner():GetForward() * 9989 )
		elseif ( anim == "fists_uppercut" ) then
			dmginfo:SetDamageForce( self:GetOwner():GetUp() * 5158 + self:GetOwner():GetForward() * 10012 )
			dmginfo:SetDamage( math.random( 100, 150 ) )
		end

		tr.Entity:TakeDamageInfo( dmginfo )
		hit = true

	end

	if ( SERVER && IsValid( tr.Entity ) ) then
		local phys = tr.Entity:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:ApplyForceOffset( self:GetOwner():GetAimVector() * 80 * phys:GetMass(), tr.HitPos )
		end
	end

	if ( SERVER ) then
		if ( hit && anim != "fists_uppercut" ) then
			self:SetCombo( self:GetCombo() + 1 )
		else
			self:SetCombo( 0 )
		end
	end

	self:GetOwner():LagCompensation( false )

end

function SWEP:OnDrop()

	self:Remove() -- You can't drop fists

end

function SWEP:Deploy()

	local speed = GetConVarNumber( "sv_defaultdeployspeed" )

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_draw" ) )
	vm:SetPlaybackRate( speed )

	self:SetNextPrimaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:SetNextSecondaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:UpdateNextIdle()

	if ( SERVER ) then
		self:SetCombo( 0 )
	end

	return true

end

function SWEP:Initialize()
	self:SetHoldType( "fist" )
end

function SWEP:Think()

	local ply = self:GetOwner()
	local vm = ply:GetViewModel()
	local curtime = CurTime()
	local idletime = self:GetNextIdle()

	if ( idletime > 0 && CurTime() > idletime ) then

		vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_idle_0" .. math.random( 1, 2 ) ) )

		self:UpdateNextIdle()

	end

	local meleetime = self:GetNextMeleeAttack()

	if ( meleetime > 0 && CurTime() > meleetime ) then

		self:DealDamage()

		self:SetNextMeleeAttack( 0 )

	end

	if ( SERVER && CurTime() > self:GetNextPrimaryFire() + 0.1 ) then

		self:SetCombo( 0 )

	end

	if SERVER and ply:Team() == TEAM_HOMELANDER then

		self:LaserProcess()

	end
end

if (SERVER) then
	function SWEP:Reload()
		local ply = self:GetOwner()
		if ply:Team() == TEAM_BLACKSS then
			if self:GetNextExplode() > CurTime() then return end
			local pos = ply:GetPos()

			util.BlastDamage(ply,self,pos,300,50)
	    	ParticleEffect('explosion_huge_g', pos, Angle(0,0,0))
		
			ply:EmitSound("ambient/explosions/explode_"..math.random(7,8)..".wav")

			self:SetNextExplode(CurTime() + 20)
		end

		if ply:Team() == TEAM_HOMELANDER then
			self:SetNWBool("isReloading", true)
			self.isReloading = true
		end
	end

	function SWEP:LaserProcess()
		if self.isReloading == true then
			self:FireBeam()
			self.isReloading = false
			self:SetNWBool("isReloading", false)
		end
	end

	function SWEP:FireBeam()
		local ply = self:GetOwner()
		if InSpawn(ply) then return end
		ply:SetVelocity( ply:GetForward() * - (math.random(1,5)) )
		ply:EmitSound("ambient/energy/weld2.wav", 30)

		local tr = ply:GetEyeTrace()
		util.Decal("FadingScorch",  tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
		sound.Play("ambient/energy/spark"..tostring(math.random(1,4))..".wav", tr.HitPos, 100, 100)
		util.BlastDamage( self, self:GetOwner(), tr.HitPos, 80, 2 )
		if tr.Entity:IsValid() or tr.Entity:IsWorld() then
			self:FlareDamage(tr.Entity)
		end
	end

	function SWEP:FlareDamage(entity)
		if entity:IsPlayer() or entity:IsNPC() then
			entity:Ignite(5, 0)
		end
	end
end

if CLIENT then
	local icon = Material('icon72/boom.png')
	local background = Color( 0, 0, 0, 125 )
	local progress = Color( 233, 133, 110, 255 )

	function SWEP:DrawHUD()
		if LocalPlayer():Team() ~= TEAM_BLACKSS then return end
		local remaining = (self:GetNextExplode() or 0) - CurTime()
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, background )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 116*math.Clamp((20-remaining)/20, 0, 1), 20, progress )
		draw.DrawText("Взрыв", "DermaLarge", (ScrW()/2), ScrH()-84, color_white, TEXT_ALIGN_CENTER )
	
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(icon)
		surface.DrawTexturedRect(ScrW() / 2 + 70, ScrH() - 45, 24, 24)
	end

	local lasermat = Material("cable/redlaser")
	local laserDistance = 1000
	local laserColor = Color(255, 0, 0)
	local leftEyeOffset = Vector(-2, -2, 0)
	local rightEyeOffset = Vector(2, -2, 0)

	local function homelanderEye(ply)
	    local eyePos = ply:EyePos()
	    local eyeAng = ply:EyeAngles()

	    local leftEyePos = eyePos + leftEyeOffset
	    local rightEyePos = eyePos + rightEyeOffset
	    local laserEndPos = eyePos + eyeAng:Forward() * laserDistance

	    render.SetMaterial(lasermat)
	    render.DrawBeam(leftEyePos, laserEndPos, 5, 0, 1, laserColor)
	    render.DrawBeam(rightEyePos, laserEndPos, 5, 0, 1, laserColor)
	end

	hook.Add("PostPlayerDraw", "DrawDoubleEyeLasers", function(ply)
	    if ply:Team() ~= TEAM_HOMELANDER then return end
	    local wep = ply:GetActiveWeapon()
	    if not IsValid(wep) then return end
	    if wep:GetClass() ~= "weapon_spiderfists" then return end
	    if not wep:GetNWBool("isReloading") then return end

	    homelanderEye(ply)
	end)

	function SWEP:PostDrawViewModel(_, _, ply)
	    if not self:GetNWBool("isReloading") then return end

	    homelanderEye(ply)
	end
end

hook.Add('EntityTakeDamage', 'ignorefiredamage', function(ent, dmg)
	
	if not IsValid(ent) then return end
	if not ent:IsPlayer() then return end
	if ent:Team() ~= TEAM_BLACKSS then return end
	
	if dmg:IsDamageType(64) or dmg:IsDamageType(8) then
		return true
	end

end)

hook.Add('CuffsCanHandcuff', 'blacksscooldown', function(ply, target)
	if ply:isCP() then return end
	if ply:Team() == TEAM_MANUAK then return end
	if ply:Team() == TEAM_SHAZAM then return end
	if ply:Team() == TEAM_HOMELANDER then return end
	if ply.blacksscooldown and ply.blacksscooldown > CurTime() then
		local t = string.FormattedTime(ply.blacksscooldown - CurTime())
		DarkRP.notify(ply, 1, 8, ('Ты сможешь взять следующего заложника через %s мин %s сек.'):format(t.m, t.s))
		return false
	end
end)

hook.Add('OnHandcuffed', 'blacksscooldown', function(ply, target, cuffs)
	if ply:isCP() then return end
	if ply:Team() == TEAM_MANUAK then return end

	ply.blacksscooldown = CurTime() + 900 -- 15 минут
end)
--addons/_smallscripts/lua/weapons/weapon_svechenik.lua:
AddCSLuaFile()

SWEP.Base				= "weapon_base"

SWEP.PrintName			= "Священная книжка"		
SWEP.ClassName			= "weapon_svechenik"
SWEP.Author				= "Slade Xanthas"
SWEP.Category 			= "Запрещено"
SWEP.Instructions		= "ПКМ - Полет | ЛКМ - Священный удар"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Просвятить"},
	{key = MOUSE_RIGHT, desc = "Полет"},
	{key = KEY_R, desc = "Поджечь"},
}
SWEP.Slot				= 1
SWEP.SlotPos			= 0
		
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true

SWEP.Spawnable			= true
SWEP.AdminOnly			= false

SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.Primary.Delay				= 3
SWEP.Primary.ClipSize			= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic			= true
SWEP.Primary.Ammo				= "none"

SWEP.Secondary.Delay			= 10
SWEP.Secondary.ClipSize			= -1
SWEP.Secondary.DefaultClip		= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo				= "none"

SWEP.HoldType = "slam"
SWEP.ThrownHoldType = "normal"
SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_bible.mdl"
SWEP.WorldModel = "models/weapons/W_bible.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

SWEP.HealSound = "weapons/blessedbook/miracle.wav"

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack()
	local ply = self:GetOwner()
	if InSpawn(ply) then return end

	ply:SetAnimation(PLAYER_ATTACK1)
	if SERVER then ply:EmitSound("weapons/iceaxe/iceaxe_swing1.wav") end
	self:SendWeaponAnim(ACT_VM_HITCENTER)
	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

	ply:LagCompensation(true)

	local tr = {}
	tr.start = ply:GetShootPos()
	tr.endpos = ply:GetShootPos() + ply:GetAimVector() * 50
	tr.filter = ply
	tr.mins = Vector(-10, -10, -8)
	tr.maxs = Vector(10, 10, 8)
	tr.mask = MASK_SHOT_HULL
	
	local res = util.TraceLine(tr)
	
	if not IsValid(res.Entity) then
		res = util.TraceHull(tr)
	end
	
	if res.Hit then
		local ent = res.Entity
		
		if IsValid(ent) and ent:IsPlayer() and not InSpawn(ent) then
			if SERVER then
				local dmg = DamageInfo()
				local Force = Vector(math.Rand(0, 10000), math.Rand(0, 10000), math.Rand(0, 10000))

				if IsValid(ply) then 
					dmg:SetAttacker(ply)
				else
					dmg:SetAttacker(self)
				end
				
				dmg:SetDamage(0)
				dmg:SetDamageType(DMG_DROWN)
				dmg:SetDamageForce(Force)
				ent:TakeDamageInfo(dmg)
				ent:SetVelocity(Force)

				ent:SetHealth(150)
				ent:EmitSound("jesus.wav")

				if plogs then
					plogs.PlayerLog(ply, 'Damage', ply:NameID()..' ударил '..ent:NameID()..' книгой священника', {
						['Жертва: Ник'] = ent:LogsName(),
						['Жертва: SteamID']	= ent:LogsSteamID(),
						['Напавший: Ник'] = ply:LogsName(),
						['Напавший: SteamID'] = ply:LogsSteamID(),
					}, {
						{
							name = 'Напавший',
							pos = ply:GetPos(),
							ang = ply:GetAngles(),
						},
						{
							name = 'Жертва',
							pos = ent:GetPos(),
							ang = ent:GetAngles(),
						},
					})
				end
			end
		
			local vecSub = res.HitPos-ply:GetShootPos()
			local vecFinal = vecSub:GetNormalized()*5000
			local phys = ent:GetPhysicsObject()	
			
			if IsValid(phys) then
				phys:ApplyForceOffset(vecFinal,res.HitPos)
			else
				ent:SetVelocity(vecFinal)
			end

		end
		
	end
	
	ply:LagCompensation(false)

end

function SWEP:SecondaryAttack()
	local ply = self:GetOwner()
	if InSpawn(ply) then return end
	ply:SetAnimation(PLAYER_ATTACK1)
   	self:SendWeaponAnim( ACT_VM_HOLSTER )
	self:SetNextSecondaryFire(CurTime() + 10)
	self:EmitSound("jesus.wav")
	ply:SetMoveType(MOVETYPE_FLY)
	timer.Simple(5, function()
		if IsValid(ply) then 
			ply:SetMoveType(MOVETYPE_WALK)
			if ply:GetActiveWeapon() ~= self then return end
			self:SendWeaponAnim( ACT_VM_IDLE )
		end
	end)
end



local delay = 3
local lastOccurance = -delay

function SWEP:Reload()
	if CLIENT then return end
	local ply = self:GetOwner()
	local tr = ply:GetEyeTrace()
	local ent = tr.Entity

	if not IsValid(ent) or InSpawn(ent) or InSpawn(ply) then return end

	local timeElapsed = CurTime() - lastOccurance

	if ent:GetClass() == "player" and timeElapsed > delay  then
		if ent:GetPos():DistToSqr(ply:GetShootPos()) > 40000 then return end
		ent:Ignite(5, 1)
		DarkRP.notify(ent, 1, 5, "Тебя поджег священник."..ply:DisplayName().." ("..ply:SteamID()..") ")

		lastOccurance = CurTime()

		if plogs then
			plogs.PlayerLog(ply, 'Damage', ply:NameID()..' поджег '..ent:NameID(), {
				['Жертва: Ник'] = ent:Name(),
				['Жертва: SteamID']	= ent:SteamID(),
				['Напавший: Ник'] = ply:Name(),
				['Напавший: SteamID'] = ply:SteamID(),
			}, {
				{
					name = 'Напавший',
					pos = ply:GetPos(),
					ang = ply:GetAngles(),
				},
				{
					name = 'Жертва',
					pos = ent:GetPos(),
					ang = ent:GetAngles(),
				},
			})
		end
	end
end
--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/weapon_vape/lua/weapons/weapon_vape_hallucinogenic.lua:
-- weapon_vape_hallucinogenic.lua
-- Defines a vape which makes hallucinogenic effects on the user's screen

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Hallucinogenic Vape"
SWEP.Category  = "Разрешено"
SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis juice contains hallucinogens (don't worry, they're healthy and all-natural)"

SWEP.VapeAccentColor = Vector(0.5,1,0)
SWEP.VapeTankColor = Vector(-1,-1,-1)

SWEP.VapeID = 5
--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--addons/module_css2/lua/weapons/wrp_weapon_crimson/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.CrosshairEnabled = true
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = false
	
	SWEP.AimPos = Vector(-5.35, -5, 1.45)

	SWEP.AimAng = Vector(-0.18, 0.03, 0)
	
	SWEP.SprintPos = Vector(1.185, -15.796, -14.254)
	SWEP.SprintAng = Vector(64.567, 0, 0)
	
	SWEP.ZoomAmount = 30
	
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "f"
	killicon.AddFont("swb_357", "SWB_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	--SWEP.PosBasedMuz = true
end

SWEP.PrintName = "Crimson"

SWEP.FadeCrosshairOnAim = true

SWEP.SpeedDec = 12
SWEP.BulletDiameter = 9.1
SWEP.CaseLength = 33

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_revolver_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "revolver"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"double"}
SWEP.Base = "swb_base"
SWEP.Category = "Премиум"

SWEP.Author			= "kenzou power"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV = 60

SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/CrimsonHC/c_crimson.mdl"
SWEP.WorldModel		= "models/weapons/CrimsonHC/w_crimson.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 8
SWEP.Primary.DefaultClip	= 24
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.FireDelay = 0.4
SWEP.FireSound = Sound("weapons/crimsonfire.wav")
SWEP.Recoil = 2
SWEP.Chamberable = false

SWEP.HipSpread = 0.03
SWEP.AimSpread = 0.004
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 80
SWEP.DeployTime = 1




hook.Add('ScalePlayerDamage', 'crimson_headshot', function(target, hitgroup, info)
    if not target:IsPlayer() then return end
    
    local attacker = info:GetAttacker()
    if not attacker:IsPlayer() then return end
    if attacker:GetActiveWeapon():GetClass() ~= 'wrp_weapon_crimson' then return end

    if attacker:Health() < attacker:GetMaxHealth() then
    	attacker:SetHealth(attacker:Health() + 15)
        ParticleEffectAttach("env_embers_small_spread", 1, attacker, 1)
        timer.Simple(2, function() if IsValid(attacker) then attacker:StopParticles() end end)
    end

    if hitgroup ~= HITGROUP_HEAD then return end
    info:ScaleDamage(1.25)

    local effectData = EffectData()
    effectData:SetOrigin(target:GetShootPos() + target:EyeAngles():Forward())
    effectData:SetNormal(target:EyeAngles():Forward())
    util.Effect("StunstickImpact", effectData)
end)
--addons/module_css2/lua/weapons/wrp_weapon_grizzly/shared.lua:

-----------------------------------------------------
AddCSLuaFile()

if CLIENT then
	SWEP.CrosshairEnabled = true
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5, 1, 0)
	SWEP.AimAng = Vector(0, 0, 0)
	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ZoomAmount = 60
	SWEP.ViewModelMovementScale = 0.85
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	SWEP.Shell = "smallshell"

	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 40
	SWEP.MaxZoom = 85
	
	SWEP.IconLetter = "z"
	
	SWEP.MuzzleEffect = false
	SWEP.InvertShellEjectAngle = true

end

SWEP.PrintName = "LAR Grizzly .50"

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = false

SWEP.CanPenetrate = true

SWEP.SpeedDec = 40
SWEP.BulletDiameter = 12.7
SWEP.CaseLength = 80

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_revolver_ttt"

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"bolt"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author			= "kenzou power"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 60
SWEP.ViewModelFlip	= false
SWEP.ViewModel        = "models/weapons/sniper/c_sniper.mdl"
SWEP.WorldModel        = "models/weapons/sniper/w_sniper.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 1
SWEP.Primary.DefaultClip	= 6
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.5
SWEP.FireSound = Sound("weapons/sniperrifle/sniperrifle_fire.wav")
SWEP.Recoil = 8
SWEP.Chamberable = false

SWEP.HipSpread = 0.1
SWEP.AimSpread = 0.0001
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 250
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/wrp_weapon_spas12/shared.lua:

-----------------------------------------------------
AddCSLuaFile()

if CLIENT then
	SWEP.CrosshairEnabled = true
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector (-8.9203, -4.7091, 1.7697)
	SWEP.AimAng = Vector (3.0659, 0.0913, 0)
	SWEP.BulletDisplay = 0
	SWEP.SprintPos = Vector (3, 0, 2.5)
	SWEP.SprintAng = Vector (-13, 27, 0)
	
	SWEP.ZoomAmount = 20
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "shotshell"
	SWEP.ShellOnEvent = true
	
	SWEP.IconLetter = "b"
	SWEP.IconFont = "WeaponIcons"
	
	SWEP.MuzzleEffect = "swb_shotgun"
end

SWEP.PrintName = "Franchi SPAS12"

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.BulletDisplay = 0

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_box_buckshot_ttt"

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author			= "kenzou power"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 50
SWEP.ViewModel			= "models/weapons/c_shotgun.mdl"
SWEP.WorldModel			= "models/weapons/w_shotgun.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 8
SWEP.Primary.Reload		= Sound("Weapon_SHOTGUN.Reload")
SWEP.Primary.Special		= Sound("Weapon_SHOTGUN.Special1")
SWEP.Primary.Double		= Sound("Weapon_SHOTGUN.Double")
SWEP.Primary.DefaultClip	= 24
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "buckshot"

SWEP.FireDelay = 0.2
SWEP.FireSound = Sound("Weapon_SHOTGUN.Single")	
SWEP.Recoil = 2.0
SWEP.ShotgunReload = true
SWEP.ReloadStartWait = 0.4
SWEP.ReloadFinishWait = 0.4
SWEP.ReloadShellInsertWait = 0.4
SWEP.Chamberable = false

SWEP.HipSpread = 0.036
SWEP.AimSpread = 0.006
SWEP.ClumpSpread = 0.04
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 10
SWEP.Damage = 12
SWEP.DeployTime = 1
--addons/ent_bitcoinpc/lua/entities/bit_case/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Desktop Case"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
	self:NetworkVar( "Int", 1, "PowerSupply" )
	self:NetworkVar( "Int", 2, "ReqPowerSupply" )
	self:NetworkVar( "Int", 3, "Graphiccard" )	
	self:NetworkVar( "Int", 4, "Harddisk" )		
	self:NetworkVar( "Int", 5, "Ram" )		
	self:NetworkVar( "Int", 6, "BitCoin" )	
	self:NetworkVar( "Int", 7, "GBused" )
	self:NetworkVar( "Int", 8, "Load" )	
	self:NetworkVar( "Bool", 0, "Motherboard" )	
	self:NetworkVar( "Bool", 1, "CPU" )	
	self:NetworkVar( "Bool", 2, "Cornet" )	
	self:NetworkVar( "Bool", 3, "Window" )	
end

--addons/ent_bitcoinpc/lua/entities/bit_graphiccard/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/ent_bitcoinpc/lua/entities/bit_ram/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_bitminers2_extras/lua/entities/bm2_base/cl_init.lua:
include("shared.lua")
--addons/module_bitminers2_extras/lua/entities/bm2_extra_fuel_line/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"

ENT.PrintName = "Fuel Line"
ENT.Spawnable = true
ENT.Category = "Запрещено"
--addons/module_bitminers2_extras/lua/entities/bm2_extra_fuel_otherend/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end  

--addons/module_bitminers2/lua/entities/bm2_generator/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Generator"
ENT.Spawnable = true
ENT.Category = "Запрещено"

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "IsOn" )
	self:NetworkVar( "Bool", 2, "ShowToMuchPowerWarning")
	self:NetworkVar( "Bool", 3, "ShowNoFuelWarning")
	self:NetworkVar( "Int", 1, "FuelLevel")
	self:NetworkVar( "Float", 2, "PowerConsumpsion")
end
--addons/module_bitminers2_extras/lua/entities/bm2_large_fuel/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"

ENT.PrintName = "Large Fuel"
ENT.Spawnable = true
ENT.Category = "Запрещено"


--addons/module_bitminers2_extras/lua/entities/bm2_solar_cable/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end  

--addons/module_bitminers2_extras/lua/entities/bm2_solar_panel/cl_init.lua:
include("shared.lua")

local warningMaterial = Material("materials/bitminers2/ui/warning.png", "noclamp smooth")

function ENT:DrawTranslucent()
	self:DrawModel()

	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 122500 then
		if self.cam2d3dAng == nil then
			self.cam2d3dAng = Angle(0,LocalPlayer():GetAngles().y - 90,90)
		else
			self.cam2d3dAng = LerpAngle(7 * FrameTime(),self.cam2d3dAng, Angle(0,LocalPlayer():GetAngles().y - 90,90))
		end
		--Cam 2D3D for drawing infomation
		local ang = self:GetAngles()
		local pos = self:GetPos() + Vector(0,0,40) - (ang:Forward() * 5) + (ang:Up() * 20)

		local alpha = 1 - math.Clamp((LocalPlayer():GetPos():Distance(self:GetPos()) / 350) * 1.1, 0, 1)

		cam.Start3D2D(pos, self.cam2d3dAng, 0.05)
			if not self:GetHasLight() then
				surface.SetMaterial(warningMaterial)
				surface.SetDrawColor(Color(255,255,255, 255))
				surface.DrawTexturedRect(-80, -20, 160, 160)

				draw.SimpleText("No sunlight!", "BM2GeneratorFont", 0, 170, Color(0,0,0, 255), 1, 1)
				draw.SimpleText("No sunlight!", "BM2GeneratorFont", -1, 170 - 1, Color(255,255,255, 255), 1, 1)

				draw.SimpleText("The solar panel needs direct sight of the skybox.", "BM2GeneratorFont", 0, 170 + 35, Color(0,0,0, 255), 1, 1)
				draw.SimpleText("The solar panel needs direct sight of the skybox.", "BM2GeneratorFont", -1, 170 - 1 + 35, Color(255,255,255, 255), 1, 1)

			end
		cam.End3D2D()
	end
end
--addons/ent_ammobox/lua/entities/box_ammo/cl_init.lua:
include("shared.lua")

function ENT:Draw()

    local ply = LocalPlayer()
    local distSqr = 160000
    
    if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end

	self:DrawModel()

end
--addons/module_bank/lua/entities/clicker_safe/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Хранилище кликеров'
ENT.Author = 'WayZer\'s Role Play'
ENT.Category = 'Запрещено'
ENT.Freeze = true
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar('Bool', 0, 'Opened')
end

function ENT:IsOpened()
    return self:GetOpened() or false
end

function ENT:IsOwnedBy(ply)
    return self:CPPIGetOwner() == ply
end

function ENT:GetClickers()
    return self:GetNetVar('SafeClickers', {})
end

nw.Register('SafeClickers')
    :Write(function(d)
        net.WriteUInt(#d, 2)
        for _, v in ipairs(d) do
            net.WriteEntity(v)
        end
    end)
    :Read(function()
        local res = {}
        for i=1, net.ReadUInt(2) do
            res[#res+1] = net.ReadEntity()
        end
        return res
    end)
--addons/_smallscripts/lua/entities/donation_box/cl_init.lua:
include("shared.lua")

local color_bright = Color(236, 113, 71, 255)
local color_dark = Color( 43, 49, 54, 255 )
local color_other = Color(77, 75, 77 , 70)
local scale = 0.1
local da = Angle(0,90,75)
local dx = Vector(-19,-10,30)

function ENT:Draw()

   self:DrawModel()

   if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 22500 then return end

   local owner = self:Getowning_ent():Nick()
   local revalue = DarkRP.formatMoney(self:GetMoney())
   local MValue = self:GetMoney()

   cam.Start3D2D(self:LocalToWorld(dx), self:LocalToWorldAngles(da), scale)
    draw.RoundedBox(0,-130,10,460,215,color_bright)
    draw.RoundedBox( 0,-130,10,460,28, color_dark )
    
    surface.SetDrawColor( color_other )
    surface.DrawOutlinedRect( -130,10,460,215 )
    
    draw.SimpleText( "Пожертвование для "..owner, "Trebuchet24", -125, 23, color_white, 0, 1 )
    draw.SimpleText( 'Нажми E для внесения 5000$ в ящик', "Trebuchet24", 100, 180, color_white, TEXT_ALIGN_CENTER )
    draw.SimpleText( "Собрано:", "Trebuchet48", 100, 50, color_white, TEXT_ALIGN_CENTER)
    draw.SimpleText( revalue, "Trebuchet48", 100, 100, color_white, TEXT_ALIGN_CENTER)
   cam.End3D2D()

end
--addons/ent_drugz/lua/entities/durgz_fireammo/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Зажигательная смесь"
ENT.Category = "Запрещено"
ENT.Model = "models/jaanus/aspbtl.mdl"
ENT.UseTime = 10
--addons/ent_drugz/lua/entities/durgz_pcp/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "PCP"
ENT.Category = "Запрещено"
ENT.Model = "models/cocn.mdl"
--addons/ent_drugz/lua/entities/durgz_weed/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Марихуана"
ENT.Category = "Запрещено"
ENT.Model = "models/katharsmodels/contraband/zak_wiet/zak_wiet.mdl"
--addons/module_meth/lua/entities/eml_buyer_text/shared.lua:
ENT.Base = "base_gmodentity";
ENT.Type = "anim";

ENT.PrintName		= "Текст скупщика мета";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--addons/module_meth/lua/entities/eml_macid/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end
	
	local ang = self:GetAngles()

	local macidColor = EML_MuriaticAcid_Color;
	
	if (self:GetMethAmount()>0) then
		macidColor = EML_MuriaticAcid_Color;
	else
		macidColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos+ang:Up()*4.8, ang, 0.1)
			draw.SimpleTextOutlined("Соляная", "methFont", 0, 0, macidColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Кислота", "methFont", 0, 24, macidColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetMethAmount().." литра", "methFont", 0, 48, macidColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*5, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-100, -8, 128, 16);
			
			surface.SetDrawColor(EML_MuriaticAcid_Color);
			surface.DrawRect(-98, -6, math.Round((self:GetMethAmount()*124)/self:GetMaxAmount()), 12);				
		cam.End3D2D();
	end;
		
end;
--addons/module_meth/lua/entities/eml_meth/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Кристализированный мет";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
    self:NetworkVar("Int", 2, "Value")
    self:NetworkVar("Int", 3, "ValueMod")
end
--addons/module_meth/lua/entities/eml_sulfur/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	local sulfurColor = EML_Sulfur_Color;
	
	if (self:GetMethAmount()>0) then
		sulfurColor = EML_Sulfur_Color;
	else
		sulfurColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.07)
			draw.SimpleTextOutlined("Жидкий", "methFont", 0, -14, sulfurColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Сульфур", "methFont", 0, 10, sulfurColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetMethAmount().."l", "methFont", 0, 34, sulfurColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-40, -8, 64, 16);
			
			surface.SetDrawColor(EML_Sulfur_Color);
			surface.DrawRect(-38, -6, math.Round((self:GetMethAmount()*60)/self:GetMaxAmount()), 12);				
		cam.End3D2D();
	end;
end;

-- maxAmount = 60
-- amount = x


--addons/module_css2/lua/entities/ent_explosivegrenade/cl_init.lua:
include('shared.lua')

/*---------------------------------------------------------
Draw
---------------------------------------------------------*/
function ENT:Draw()
	self.Entity:DrawModel()
end


/*---------------------------------------------------------
IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end



--addons/weapon_shield/lua/entities/ent_fridge_shield/cl_init.lua:
include('shared.lua')
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()  
    self:DrawModel()
end
--addons/weapon_shield/lua/entities/ent_fridge_shield/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Fridge Shield'
ENT.Category = ''

ENT.Spawnable = false
ENT.DisableDuplicator = true
--addons/weapon_paint/lua/entities/ent_graffiti/shared.lua:
AddCSLuaFile()
ENT.Type = 'anim'
ENT.PrintName = 'Графити'
ENT.Author = '\\sqdAva'
ENT.Base = 'base_anim'
ENT.Category = 'Запрещено'
-- ENT.PressE = falseАС
ENT.Spawnable = false

function ENT:SharedInit()
    self.mins = Vector(-48, 0, -48)
    self.maxs = Vector(48, .1, 48)
end

function ENT:GetCanvas()
    return self.canvas
end

function ENT:Initialize()
    self:SetModel('models/hunter/plates/plate2x2.mdl')
    self:SetSolid(SOLID_VPHYSICS)
    self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
    self:SetMoveType(MOVETYPE_NONE)
    self:SetUseType(SIMPLE_USE)
    self:DrawShadow(false)
end
--addons/weapon_hatshook/lua/entities/ent_realistic_hook.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.Spawnable = false
ENT.AdminSpawnable = true

ENT.Model = "models/props_c17/TrapPropeller_Lever.mdl"
ENT.HitSound = Sound( "physics/metal/metal_barrel_impact_hard7.wav" )

local ServerConvarFlags = {FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE}
CreateConVar( "hatshook_hookplayers", "0", ServerConvarFlags, "Allows the Grappling Hook to grab players" )
CreateConVar( "hatshook_physics", "1", ServerConvarFlags, "Grappling hook is launched as a projectile" )
CreateConVar( "hatshook_speed", "1500", ServerConvarFlags, "Launch velocity of the grappling hook (Max range for non-physics hooks)" )

CreateConVar( "hatshook_breakpower", "3", ServerConvarFlags, "Strength of each breakout attempt" )
CreateConVar( "hatshook_breakregen", "1", ServerConvarFlags, "Breakout depletion rate" )

CreateConVar( "hatshook_ammo", "-1", ServerConvarFlags, "Number of uses each grappling hook has. -1 is infinite." )

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "HasHit" )
	
	self:NetworkVar( "Entity", 0, "Wep" )
	self:NetworkVar( "Entity", 1, "TargetEnt" )
	
	self:NetworkVar( "Int", 0, "Dist" )
	self:NetworkVar( "Int", 1, "Durability" )
	
	self:NetworkVar( "Int", 2, "FollowBone" )
	self:NetworkVar( "Vector", 1, "FollowOffset" )
	self:NetworkVar( "Angle", 0, "FollowAngle" )
	
	self:NetworkVar( "Vector", 0, "ShootDir" )
end

function ENT:Initialize()
	self:SetModel( self.Model )
	
	--self:SetMoveType( MOVETYPE_VPHYSICS )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetCollisionGroup( COLLISION_GROUP_NPC )
	
	self:PhysWake()
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		if SERVER then
			self:SetShootDir( self:GetOwner():GetAimVector() * cvars.Number( "hatshook_speed" ) )
		end
		phys:SetVelocity( self:GetShootDir() )
	end
	
	self.HookHealth = 100
	
	hook.Add( "AllowPlayerPickup", self, self.AllowPlayerPickup )
	if CLIENT then hook.Add( "HUDPaint", self, self.HUDPaint ) end
	
	if SERVER then
		local timerName = tostring(self).." Hook Durability Restore"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetDurability( math.Approach(self:GetDurability(), 0, cvars.Number("hatshook_breakregen") ) )
		end)
		hook.Add( "KeyPress", self, self.PlayerKeyPress )
	end
end

function ENT:Destroyed( NoCooldown )
	if CLIENT then return end
	
	local ef = EffectData()
	ef:SetStart( self:GetPos() )
	ef:SetOrigin( self:GetPos() )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	ef:SetMagnitude( 1 )
	ef:SetNormal( self:GetRight() )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, self:GetPos(), 75, 100 )
	
	if IsValid( self:GetWep() ) and self:GetWep().SetCooldown then
		self:GetWep():SetCooldown( NoCooldown and self:GetWep():GetCooldown()+10 or 100 )
	end
	
	self:Remove()
end
function ENT:OnTakeDamage( DmgInfo )
	self.HookHealth = (self.HookHealth or 0) - DmgInfo:GetDamage()
	if self.HookHealth<=0 then
		self:Destroyed()
	end
end

function ENT:DoParent( target, obj )
	if IsValid( target ) and target~=self and target~=self:GetOwner() and (not (target:IsWeapon() and target:GetOwner()==self:GetOwner())) then
		self:SetParent( target )
		
		if target:GetClass():sub(1,5)~="func_" then
			for i=0,target:GetPhysicsObjectCount()-1 do
				local p = target:GetPhysicsObjectNum( i )
				if p==obj then
					--self:SetParentPhysNum( target:TranslatePhysBoneToBone(i) )
					--self:FollowBone( target, target:TranslatePhysBoneToBone(i) )
					--print(i,target:TranslatePhysBoneToBone(i))
					
					self:SetFollowBone( target:TranslatePhysBoneToBone(i) )
					local pos, ang = target:GetBonePosition( self:GetFollowBone() )
					if pos and ang then
						self:SetFollowOffset( self:GetPos() - pos )
						self:SetFollowAngle( self:GetAngles()-ang )
					end
					break
				end
			end
		end
		
		self:SetTargetEnt( target )
	end
end

local NoHitEnts = { ["func_breakable_surf"] = true, ["ent_realistic_hook"] = true, } // This is stuff we shouldn't attach to, glitches out
function ENT:PhysicsCollide( data, phys )
	if self:GetHasHit() then return end // Already hit
	
	if IsValid(data.HitEntity) and NoHitEnts[data.HitEntity:GetClass()] then // Something that'll bug out, eg a window
		self:Destroyed( true )
		return
	end
	if not IsValid(self:GetWep()) and IsValid(self:GetWep().Owner) and self:GetWep().Owner:IsPlayer() then self:Destroyed( true ) return end
	
	local tr = util.TraceLine( {start = (data.HitPos - (data.HitNormal*10)), endpos = (data.HitPos+data.HitNormal*10), filter = self} )
	if tr.HitSky then return end
	
	timer.Simple(0,function()
		if not IsValid(self) then return end
		if not (IsValid(self:GetWep()) and IsValid(self:GetWep().Owner)) then self:Destroyed( true ) return end
		
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self:SetPos( data.HitPos )
		local ang = data.HitNormal:Angle()
		ang:RotateAroundAxis( ang:Up(), 90 )
		self:SetAngles( ang )
		self:SetMoveType( MOVETYPE_NONE )
		
		self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
		self:DoParent( data.HitEntity, data.HitObject )
	end)
	
	self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
	
	local ef = EffectData()
	ef:SetOrigin( data.HitPos )
	ef:SetNormal( data.HitNormal )
	ef:SetStart( data.HitPos )
	ef:SetMagnitude( 2 )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, data.HitPos, 75, 100 )
	
	self:SetHasHit( true )
end

-- Misc hooks --
----------------
function ENT:Think()
	if SERVER and (not (IsValid(self:GetWep()) and self:GetWep()==self:GetOwner():GetActiveWeapon()) ) then self:Remove() return end
	
	local phys = self:GetPhysicsObject()
	if IsValid(phys) and self:GetHasHit() then // This stuff doesn't work in the collision hook
		phys:EnableMotion( false )
		phys:SetPos( self:GetPos() )
		phys:SetAngles( self:GetAngles() )
	end
end

function ENT:AllowPlayerPickup( ply, ent )
	if ply==self:GetOwner() then return false end // They're currently hooked to something, if we let them pick it up they can exploit and fly
end

-- 3D Drawing --
----------------
local HookCable = Material( "cable/cable2" )
function ENT:Draw()
	if IsValid( self:GetTargetEnt() ) then
		local bpos, bang = self:GetTargetEnt():GetBonePosition( self:GetFollowBone() )
		local npos, nang = self:GetFollowOffset(), self:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			self:SetPos( npos )
			self:SetAngles( nang )
		end
	end
	
	self:DrawModel()
	
	// We'll draw the beam from both the weapon and the hook, less likely to move out of rendering when it should be visible
	if not IsValid( self:GetWep() ) then return end
	if self:GetOwner()==LocalPlayer() and not hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self:GetOwner()) then return end // Badly aligned, the rope will always be visible from the ViewModel draw anyway
	
	if IsValid(self:GetOwner()) then
		local att = self:GetWep():GetAttachment( 1 )
		
		render.SetMaterial( HookCable )
		if att and att.Pos then
			render.DrawBeam( self:GetPos(), att.Pos, 1, 0, 2, Color(255,255,255,255) )
		else
			render.DrawBeam( self:GetPos(), self:GetWep():GetPos(), 1, 0, 2, Color(255,255,255,255) )
		end
	end
end

-- HUD stuff --
---------------
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
local function ShadowText( txt, x, y, col )
	draw.DrawText( txt, "Default", x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, "Default", x, y, col or Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
function ENT:HUDPaint()
	if not (LocalPlayer()==self:GetTargetEnt()) then return end
	
	ShadowText( "Rope length: "..tostring(self:GetDist()), ScrW()/2, ScrH()/2-60 )
	ShadowText( "You have been hooked!", ScrW()/2, ScrH()/2-75, Color(255,100,100) )
	ShadowText( (input.LookupBinding("+use") or "[USE]"):upper() .. " - Break free", ScrW()/2, ScrH()/2-40 )
	DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)-20, 140, 15, self:GetDurability() )
end

if SERVER then
	function ENT:PlayerKeyPress( ply, key )
		if (ply~=self:GetTargetEnt() or key~=IN_USE) then return end
		
		self:SetDurability( self:GetDurability()+cvars.Number("hatshook_breakpower") )
		if self:GetDurability()>=100 then self:Destroyed() end
	end
end

--addons/ent_bomb/lua/entities/ent_timebomb/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Бомба"
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.Category = "Other"
ENT.Author = "WayZer"
ENT.Contact = "wayzerroleplay@gmail.com"
ENT.Purpose = "Самое время чтобы что-нибудь жахнуть!"
ENT.Model = "models/weapons/w_c4_planted.mdl"

function ENT:SetupDataTables() 
	self:NetworkVar( "Bool", 0, "StartBomb");
end


nw.Register 'ExplodeTime'
	:Write(net.WriteFloat)
	:Read(net.ReadFloat)

nw.Register('EquippedBomb')
	:Write(net.WriteEntity)
	:Read(net.ReadEntity)
	:SetPlayer()
	:SetHook('EquippedBomb')
--addons/_smallscripts/lua/entities/entity_rachia/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Entity Radio"
ENT.Author = "WayZer's Role Play"
ENT.Category = "Запрещено"
ENT.Spawnable = false
--gamemodes/darkrp/entities/entities/fadmin_jail/cl_init.lua:
include("shared.lua")

function ENT:Draw()
self:DrawModel()
end

--gamemodes/darkrp/entities/entities/fadmin_jail/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "fadmin_jail"
ENT.Author = "FPtje"
ENT.Spawnable = false

function ENT:CanTool()
    return false
end

function ENT:PhysgunPickup(ply)
    return false
end

--gamemodes/darkrp/entities/entities/gmod_button.lua:

AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.PrintName = "Button"
ENT.Editable = true

function ENT:SetupDataTables()

	self:NetworkVar( "Int", 0, "Key" )
	self:NetworkVar( "Bool", 0, "On" )
	self:NetworkVar( "Bool", 1, "IsToggle", { KeyName = "tg", Edit = { type = "Boolean", order = 1, title = "#tool.button.toggle" } } )
	self:NetworkVar( "String", 0, "Label", { KeyName = "lbl", Edit = { type = "Generic", order = 2, title = "#tool.button.text" } } )

	if ( SERVER ) then
		self:SetOn( false )
		self:SetIsToggle( false )
	end

end

function ENT:Initialize()

	if ( SERVER ) then

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( ONOFF_USE )

	else

		self.PosePosition = 0

	end

end

function ENT:Use( activator, caller, type, value )

	if ( !activator:IsPlayer() ) then return end -- Who the frig is pressing this shit!?

	if ( self:GetIsToggle() ) then

		if ( type == USE_ON ) then
			self:Toggle( !self:GetOn(), activator )
		end
		return

	end

	if ( IsValid( self.LastUser ) ) then return end -- Someone is already using this button

	--
	-- Switch off
	--
	if ( self:GetOn() ) then
		self:Toggle( false, activator )
		return
	end

	--
	-- Switch on
	--
	self:Toggle( true, activator )
	self:NextThink( CurTime() )
	self.LastUser = activator

end

function ENT:Think()
	
	if ( CLIENT ) then
	
		self:UpdateLever()
	
	end
	--
	-- If the player looks away while holding down use it will stay on
	-- Lets fix that..
	--
	if ( SERVER && self:GetOn() && !self:GetIsToggle() ) then

		if ( !IsValid( self.LastUser ) || !self.LastUser:KeyDown( IN_USE ) ) then

			self:Toggle( false, self.LastUser )
			self.LastUser = nil

		end

		self:NextThink( CurTime() )

	end

end

--
-- Makes the button trigger the keys
--
function ENT:Toggle( bEnable, ply )

	-- If a button has a valid player on it, use that, if not, use activator
	local targetPly = self:CPPIGetOwner()
	if ( !IsValid( targetPly ) ) then targetPly = ply end

	if ( bEnable ) then

		numpad.Activate( targetPly, self:GetKey(), true )
		self:SetOn( true )

	else

		numpad.Deactivate( targetPly, self:GetKey(), true )
		self:SetOn( false )

	end

end

--
-- Update the lever animation
--
function ENT:UpdateLever()

	local TargetPos = 0.0
	if ( self:GetOn() ) then TargetPos = 1.0 end

	self.PosePosition = math.Approach( self.PosePosition, TargetPos, FrameTime() * 5.0 )

	self:SetPoseParameter( "switch", self.PosePosition )
	self:InvalidateBoneCache()

end

--addons/tool_duplicator/lua/entities/gmod_contr_spawner/shared.lua:
ENT.Type 			= "anim"
ENT.Base			= "base_anim"
ENT.PrintName		= "Contraption Spawner"
ENT.Author			= "TB"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--addons/module_itemstore/lua/entities/itemstore_item.lua:
ENT.Type = "anim"
ENT.CanBeUsed = true
--ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetItem( item )
	self.Item = item

	if SERVER then
		self:Sync()
	end
end

function ENT:GetItem()
	return self.Item
end

if SERVER then
	AddCSLuaFile()

	function ENT:Initialize()
		local item = self:GetItem()
		if not item then self:Remove() end

		self:SetModel( item:GetModel() )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:SetUseType( SIMPLE_USE )

		self:SetColor( item:GetColor() or color_white )
		self:SetMaterial( item:GetMaterial() )

		local phys = self:GetPhysicsObject()
		if not IsValid( phys ) then
			self:PhysicsInitSphere( 16, "default" )
			phys = self:GetPhysicsObject()
		end

		phys:Wake()
	end

	function ENT:Use( pl )
		if not IsValid( pl ) then return end

		local item = self:GetItem()
		if not item then return end

		if pl.Inventory:AddItem( item ) then
			pl:DoAnimationEvent(ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND)
			pl:EmitSound( "items/itempickup.wav" )
			self:Remove()
		else
			pl:SendError( "Your inventory is full." )
		end
	end

	function ENT:Sync( pl )
		local item = self:GetItem()
		if not item then return end

		net.Start( "ItemStoreSyncItem" )
			net.WriteEntity( self )
			net.WriteString( item.Class )
			net.WriteTable( item.Data )
		net.Send( pl or player.GetAll() )
	end

	util.AddNetworkString( "ItemStoreSyncItem" )
	net.Receive( "ItemStoreSyncItem", function( len, pl )
		if pl.ItemStoreTimeout and pl.ItemStoreTimeout > CurTime() then return end

		local ent = net.ReadEntity()
		if not IsValid( ent ) or ent:GetClass() ~= "itemstore_item" then return end

		ent:Sync( pl )

		pl.ItemStoreTimeout = CurTime() + ITEMSTORE_TIMEOUT
	end )
else
	function ENT:Initialize()
		net.Start( "ItemStoreSyncItem" )
			net.WriteEntity( self )
		net.SendToServer()
	end

	function ENT:DrawTranslucent()
		local item = self:GetItem()
		if not item then return end

		item:PreRender( self )
			self:DrawModel()
		item:PostRender( self )
	end

	net.Receive( "ItemStoreSyncItem", function()
		local ent = net.ReadEntity()
		
		if not IsValid( ent ) then return end
		if not ent.SetItem then return end

		local class = net.ReadString()
		local data = net.ReadTable()

		ent:SetItem( itemstore.Item( class, data ) )
	end )
end

--gamemodes/darkrp/entities/entities/letter/cl_init.lua:
include("shared.lua")

local frame
local SignButton

function ENT:Draw()
    self:DrawModel()
end

local function KillLetter()
    hook.Remove("HUDPaint", "ShowLetter")
    frame:Remove()
end
net.Receive("KillLetter", KillLetter)

local function ShowLetter()
    if frame then
        frame:Remove()
    end

    local LetterMsg = ""
    local Letter = net.ReadEntity()
    local LetterType = net.ReadUInt(16)
    local LetterPos = net.ReadVector()
    local sectionCount = net.ReadUInt(16)
    local LetterY = ScrH() / 2 - 300
    local LetterAlpha = 255

    Letter:CallOnRemove("Kill letter HUD on remove", KillLetter)

    for k = 1, sectionCount, 1 do
        LetterMsg = LetterMsg .. net.ReadString()
    end

    frame = vgui.Create("DFrame")
    frame:SetTitle("")
    frame:ShowCloseButton(false)

    SignButton = vgui.Create("DButton", frame)
    SignButton:SetText(DarkRP.getPhrase("sign_this_letter"))
    frame:SetPos(ScrW() - 256, ScrH() - 256)
    SignButton:SetSize(256, 256)
    frame:SetSize(256, 256)
    SignButton:SetSkin(GAMEMODE.Config.DarkRPSkin)
    frame:SizeToContents()
    frame:MakePopup()
    frame:SetKeyboardInputEnabled(false)

    function SignButton:DoClick()
        RunConsoleCommand("_DarkRP_SignLetter", Letter:EntIndex())
        SignButton:SetDisabled(true)
    end
    SignButton:SetDisabled(IsValid(Letter:Getsigned()))

    hook.Add("HUDPaint", "ShowLetter", function()
        if not Letter.dt then KillLetter() return end
        if LetterAlpha < 255 then
            LetterAlpha = math.Clamp(LetterAlpha + 400 * FrameTime(), 0, 255)
        end

        local font = (LetterType == 1 and "AckBarWriting") or "Default"

        draw.RoundedBox(2, ScrW() * .2, LetterY, ScrW() * .8 - (ScrW() * .2), ScrH(), Color(255, 255, 255, math.Clamp(LetterAlpha, 0, 200)))
        draw.DrawNonParsedText(LetterMsg .. "\n\n\n" .. DarkRP.getPhrase("signed", IsValid(Letter:Getsigned()) and Letter:Getsigned():Nick() or DarkRP.getPhrase("no_one")), font, ScrW() * .25 + 20, LetterY + 80, Color(0, 0, 0, LetterAlpha), 0)

        if LocalPlayer():GetPos():DistToSqr(LetterPos) > 10000 then
            LetterY = Lerp(0.1, LetterY, ScrH())
            LetterAlpha = Lerp(0.1, LetterAlpha, 0)
            if frame and frame.Close then frame:Close() end
            if math.Round(LetterAlpha) <= 10 then
                KillLetter()
            end
        end
    end)
end
net.Receive("ShowLetter", ShowLetter)

--addons/module_samogon/lua/entities/mn_ccorn/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Урожай кукурузы"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/module_samogon/lua/entities/mn_distillery/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Самогонный аппарат"
ENT.Author = "Mikael#"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()	
	self:NetworkVar("Int", 0, "dist_degree")
	self:NetworkVar("Int", 1, "dist_health")
	self:NetworkVar("Int", 2, "dist_ran")
	self:NetworkVar("Int", 3, "dist_water")
	self:NetworkVar("Int", 4, "dist_grain")	
	self:NetworkVar("Int", 5, "dist_corn")
	self:NetworkVar("Int", 6, "dist_moonshine")		
	self:NetworkVar("Bool", 0, "dist_start")	
	self:NetworkVar("Bool", 1, "dist_cooling")
	self:NetworkVar("Entity", 0, "owning_ent")
end

distl_ = {}
distl_ = {
	dist_pos1 = Vector(0.081380, 23.782152, -5.586264),
	dist_pos2 = Vector(7.613694, 29.782200, -2.946632), 
	dist_pos3 = Vector(0.061730, 23.782143, -8.348092),
	dist_pos4 = Vector(7.506984, 29.782160, -5.794388),
	dist_pos5 = Vector(-10.278522, 15.009351, 19.051284),
	dist_pos6 = Vector(16.5782699, 22.009408, 25.699184),
	dist_pos7 = Vector(-10.452580, 15.009344, 9.3267765),
	dist_pos8 = Vector(16.4374122, 22.009351, 15.636435)
}

--addons/module_samogon/lua/entities/mn_grain/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Пшеница"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/module_samogon/lua/entities/mn_pot/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Горшок"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "dist_harvest")
	self:NetworkVar("Int", 0, "dist_crop")
	self:NetworkVar("Entity", 0, "owning_ent")
end

--addons/module_samogon/lua/entities/mn_water/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_water/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Вода"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/weapon_hover/lua/entities/modulus_hoverboard/cl_init.lua:

include( "shared.lua" )

ENT.RenderGroup = RENDERGROUP_BOTH

local glow = Material( "modulus_hoverboard/glow" )
local trail = Material( "modulus_hoverboard/trail" )

local g_HoverEffects = {}

local effectfiles = file.Find( "entities/modulus_hoverboard/effects/*.lua", "LUA" )
for _, filename in pairs( effectfiles ) do

	local old_effect = EFFECT

	EFFECT = {}

	function EFFECT:new()

		local obj = {}
		setmetatable( obj, self )
		self.__index = self

		return obj

	end

	include( "effects/".. filename )

	local _, _, effectname = string.find( filename, "([%w_]*)%.lua" ) -- store

	g_HoverEffects[ effectname ] = EFFECT

	EFFECT = old_effect -- restore

end

function ENT:Initialize()

	-- hover sound
	self.HoverSoundFile = "weapons/gauss/chargeloop.wav"
	self.HoverSound = CreateSound( self.Entity, self.HoverSoundFile )
	self.HoverSoundPlaying = false

	-- grind soud
	self.GrindSoundFile = "physics/metal/metal_grenade_scrape_smooth_loop1.wav"
	self.GrindSound = CreateSound( self.Entity, self.GrindSoundFile )
	self.GrindSoundPlaying = false
	self.GrindSoundTime = 0

	-- boost sound
	self.BoostOffSoundFile = "npc/scanner/scanner_nearmiss1.wav"
	self.BoostOnSoundFile = "npc/scanner/scanner_nearmiss2.wav"
	self.BoostSoundFile = "ambient/levels/labs/teleport_rings_loop2.wav"
	self.BoostSound = CreateSound( self.Entity, self.BoostSoundFile )
	self:SetNetworkedVarProxy( "Boosting", self.BoostStateChanged )

	-- effects list
	self.Effects = {}
	self.EffectsInitailized = false

	-- setup
	--self:SetShouldDrawInViewMode( true ) FIXME
	self:SetRenderBounds( Vector( -24, -8, -16 ), Vector( 24, 8, 16 ) )

end

function ENT:BoostStateChanged( name, oldvalue, newvalue )
	if !IsValid( self ) then return end

	-- check value
	if ( oldvalue == newvalue ) then return newvalue end

	-- handle t
	if ( newvalue ) then

		-- start sounds
		self.BoostSound:Play()
		self:EmitSound( self.BoostOnSoundFile )

	else

		-- stop sounds
		self.BoostSound:Stop()
		self:EmitSound( self.BoostOffSoundFile )

	end

	return newvalue

end

function ENT:OnRemove()

	self.HoverSound:Stop()
	self.GrindSound:Stop()
	self.BoostSound:Stop()

end

function ENT:Think()

	-- check grind time
	if ( self:GetNetworkedFloat( "GrindSoundTime" ) > CurTime() ) then

		-- not playing
		if ( !self.GrindSoundPlaying ) then

			-- play it
			self.GrindSound:Play()
			self.GrindSoundPlaying = true

		end

	else

		-- still playing
		if ( self.GrindSoundPlaying ) then

			-- stop
			self.GrindSound:Stop()
			self.GrindSoundPlaying = false

		end

	end

	-- check sound is playing
	if ( !self.HoverSoundPlaying && !self:IsGrinding() ) then

		-- setup sound
		self.HoverSound:SetSoundLevel( 60 )
		self.HoverSound:Play()
		self.HoverSoundPlaying = true

	elseif ( self.HoverSoundPlaying && self:IsGrinding() ) then

		-- stop playing
		self.HoverSound:Stop()
		self.HoverSoundPlaying = false

	else

		if ( self:WaterLevel() == 0 ) then

			-- current speed
			local speed = self:GetBoardVelocity()

			-- fractional speed
			speed = speed / 700

			-- calculate speed sound
			local soundspeed = math.Clamp( 80 + ( speed * 55 ), 80, 160 )

			-- update
			self.HoverSound:ChangePitch( soundspeed, 0 )

		else

			self.HoverSound:ChangePitch( 0, 0 )

		end

	end

	-- check sound
	if ( self.HoverSoundPlaying && self:GetUp().z < 0.33 ) then

		-- stop sound
		self.HoverSound:Stop()
		self.HoverSoundPlaying = false

	end

	-- received my effects?
	if ( !self.EffectsInitailized && tonumber( self:GetEffectCount() ) ) then

		-- all done?
		local done = true

		-- initialize each effect
		for i = 1, tonumber( self:GetEffectCount() ) do

			-- was this effect initialized?
			if ( !self.Effects[ i ] ) then

				-- have all the attributes of it?
				if ( !self:GetNWString( "Effect" .. i, false ) || !self:GetNWVector( "EffectPos" .. i, false ) ||
					!self:GetNWVector( "EffectNormal" .. i, false ) || !self:GetNWFloat( "EffectScale" .. i, false ) ) then

					-- not done, this effect isn't here yet
					done = false

				else

					-- get the effect name
					local effectname = self:GetNWString( "Effect" .. i )
					if ( !g_HoverEffects[ effectname ] ) then error( "Couldn't init effect " .. effectname ) return end
					-- load a new effect
					local effect = g_HoverEffects[ effectname ]:new()

					-- init
					effect.Board = self
					effect:Init(
						self:GetNWVector( "EffectPos" .. i ),
						self:GetNWVector( "EffectNormal" .. i ),
						self:GetNWFloat( "EffectScale" .. i )
					)

					-- add
					self.Effects[ i ] = effect

				end

			end

		end

		-- say we inited the effects
		self.EffectsInitailized = done

	end

	-- run effect think
	for _, effect in pairs( self.Effects ) do effect:Think( _ ) end

	-- think
	self:NextThink( UnPredictedCurTime() )
	return true

end

function ENT:Draw()
	
	self:DrawModel()

end

function ENT:DrawTranslucent()

	self:Draw()

end

hook.Add( "PlayerBindPress", "Hoverboard_PlayerBindPress", function( pl, bind, pressed )

	local board = pl:GetNWEntity( "ScriptedVehicle" )

	-- make sure they are using the hoverboard
	if ( !IsValid( board ) || board:GetClass() != "modulus_hoverboard" ) then return end

	-- list to block
	local blocked = {
		"phys_swap",
		"slot",
		"invnext",
		"invprev",
		"lastinv",
		"gmod_tool",
		"gmod_toolmode"
	}

	-- loop
	for _, block in pairs( blocked ) do

		-- found?
		if ( bind:find( block ) ) then return true /* block */ end

	end

end )

hook.Add( "HUDPaint", "Hoverboard_HUDPaint", function()

	-- check developer
	if ( GetConVarNumber( "cl_hoverboard_developer" ) == 1 ) then

		-- trace
		local tr = LocalPlayer():GetEyeTrace()

		-- check for board
		if ( IsValid( tr.Entity ) && tr.Entity:GetClass() == "modulus_hoverboard" ) then


			local pos = tr.Entity:WorldToLocal( tr.HitPos ) -- get coordinates
			local text = ("Coords: %s"):format( tostring( pos ) ) -- build string

			-- draw text
			draw.SimpleText( text, "Default",
				( ScrW() * 0.5 ), ( ScrH() * 0.5 ) + 100,
				Color( 255, 255, 255, 255 ),
				TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER
			)

		end

	end

end )

--addons/weapon_hover/lua/entities/modulus_hoverboard/effects/heatwave.lua:

local glow = Material( "modulus_hoverboard/glow" )

function EFFECT:Init( pos, normal, scale )

	self.Position = pos
	self.Scale = scale
	self.Normal = normal:Angle()

	self.Emitter = ParticleEmitter( self.Board:GetPos() )

end

function EFFECT:ShouldRender()
	if ( self.Board:IsGrinding() || self.Board:GetUp().z < 0.33 || self.Board:WaterLevel() > 0 ) then
		return false
	end

	return true
end

function EFFECT:Think()

	if( !self:ShouldRender() ) then return end

	local particle = self.Emitter:Add( "sprites/heatwave", self.Board:LocalToWorld( self.Position ) )
	particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
	particle:SetColor( 255, 255, 255 )
	particle:SetStartSize( 8 * self.Scale )
	particle:SetEndSize( math.Rand( 4, 8 ) * self.Scale )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 255 )
	particle:SetVelocity( self.Board:WorldToLocalAngles( self.Normal ):Forward() * math.Rand( 50, 150 ) + VectorRand() * math.Rand( 10, 25 ) )
	particle:SetRollDelta( math.Rand( -2, 2 ) )
	particle:SetCollide( true )
	particle:SetBounce( 0.2 )

end

function EFFECT:Render()

	if( !self:ShouldRender() ) then return end

	local timer = math.max( 0, math.sin( UnPredictedCurTime() ) )
	local timer2 = math.max( 0, math.sin( UnPredictedCurTime() * 2 ) )
	local anchor = self.Board:LocalToWorld( self.Position )

	render.SetMaterial( glow )
	render.DrawSprite( anchor, 48 * self.Scale, 48 * self.Scale, Color( 255, 128, 0, 60 ) )

	render.DrawSprite( anchor, 48 * timer, 48 * timer, Color( 255, 128, 0, 20 ) )

	render.DrawSprite( anchor, 32 * timer2, 32 * timer2, Color( 255, 128, 0, 20 ) )

end

--addons/weapon_hover/lua/entities/modulus_hoverboard/effects/trail.lua:

local glow = Material( "modulus_hoverboard/glow" )
local trail = Material( "modulus_hoverboard/trail" )

function EFFECT:RemapValClamped( value, a, b, c, d )

	local v = math.Clamp( ( value - a ) / ( b - a ), 0, 1 ) -- clamp to 0/1

	return c + ( d - c ) * v -- remap

end

function EFFECT:Init( pos, normal, scale )

	self.Position = pos -- pos and scale are the only things that interest us

	-- trail points
	self.Points = {}
	self.NextPoint = UnPredictedCurTime() + 0.05

end

function EFFECT:Think( id )
	self.ID = id

	-- time to update?
	if ( self.NextPoint > UnPredictedCurTime() || self.Board:GetBoardVelocity() < 150 || self.Board:IsGrinding() ) then return end

	-- add new trail points
	self.Points[ #self.Points + 1 ] = {
		Position = self.Board:LocalToWorld( self.Position ),
		DieTime = UnPredictedCurTime() + 0.5,
	}

	-- destroy dead trail segments
	for i = #self.Points, 1, -1 do

		if ( self.Points[ i ].DieTime <= UnPredictedCurTime() ) then
			table.remove( self.Points, i ) -- die?
		end

	end

	self.NextPoint = UnPredictedCurTime() + 0.05 -- next update

end

function EFFECT:Render( )

	local count = #self.Points;

	-- not enough points to draw the trail
	if(  self.Board:IsGrinding() || self.Board:WaterLevel() > 0 ) then return end

	-- alpha
	local alpha = self:RemapValClamped( self.Board:GetBoardVelocity(), 150, 1000, 0, 255 )

	-- get trail color
	local color_vec = self.Board:GetTrailColor()
	local color = Color( color_vec.x, color_vec.y, color_vec.z, 255 )

	local recharge_color_vec = self.Board:GetTrailRechargeColor();
	local recharge_color = Color( recharge_color_vec.x, recharge_color_vec.y, recharge_color_vec.z, 255 )

	local boost_color_vec = self.Board:GetTrailBoostColor()
	local boost_color = Color( boost_color_vec.x, boost_color_vec.y, boost_color_vec.z, 255 )

	if ( self.Board:IsBoosting() ) then

		local percent = ( 100 - self.Board:Boost() ) / 100

		color = Color( Lerp( percent, boost_color.r, recharge_color.r ), Lerp( percent, boost_color.g, recharge_color.g ), Lerp( percent, boost_color.b, recharge_color.b ), 255 )

	elseif ( !self.Board:IsBoosting() && self.Board:Boost() < 100 ) then

		local percent = self.Board:Boost() / 100

		color = Color( Lerp( percent, recharge_color.r, color.r ), Lerp( percent, recharge_color.g, color.g ), Lerp( percent, recharge_color.b, color.b ), 255 )

	end

	local anchor = self.Board:LocalToWorld( self.Position )

	render.SetMaterial( glow )
	render.DrawSprite( anchor, 24 * self.Board:GetTrailScale(), 24 * self.Board:GetTrailScale(), Color( color.r, color.g, color.b, alpha * 0.5 ) )

	render.DrawSprite( anchor, math.Rand( 8, 10 ) * self.Board:GetTrailScale(), math.Rand( 8, 10 ) * self.Board:GetTrailScale(), Color( color.r, color.g, color.b, alpha ) )

	render.SetMaterial( trail )
	render.StartBeam( count + 1 )

	for i = 1, count do

		local seg = self.Points[ i ]
		local coord = ( 1 / count ) * ( i - 1 )
		local percent = math.Clamp( ( seg.DieTime - UnPredictedCurTime() ) / 0.5, 0, 1 )

		render.AddBeam( seg.Position, 12 * self.Board:GetTrailScale(), coord, Color( color.r, color.g, color.b, alpha * percent ) )

	end

	render.AddBeam( anchor, 12 * self.Board:GetTrailScale(), 1, Color( color.r, color.g, color.b, alpha ) )

	render.EndBeam()

	if ( GetConVarNumber( "hoverboard_lights" ) == 0 ) then return end

	local SaberLight = DynamicLight( self.Board:EntIndex() + self.ID + 566 ) -- 655 is used on lightsabers
	if ( SaberLight ) then
		local ent = self.Board
		SaberLight.Pos = anchor
		SaberLight.r = color.r
		SaberLight.g = color.g
		SaberLight.b = color.b
		SaberLight.Brightness = 1
		SaberLight.Size = 256
		SaberLight.Decay = 0
		SaberLight.DieTime = CurTime() + 0.1
	end

end

--addons/weapon_hover/lua/entities/modulus_hoverboard_avatar/cl_init.lua:

include( "shared.lua" )

function ENT:Draw()

	if ( !IsValid( self:GetNWEntity( "Board" ) ) || !IsValid( self:GetNWEntity( "Board" ):GetDriver() ) || !IsValid( self:GetNWEntity( "Player" ) ) ) then return end

	local ply = self:GetNWEntity( "Player" )

	self.GetPlayerColor = function()
		if ( IsValid( ply ) && ply.GetPlayerColor ) then
			return ply:GetPlayerColor()
		else
			return Vector( 1, 1, 1 )
		end
	end

	self:DrawModel()

end

function ENT:DrawTranslucent()

	self:Draw()

end

--addons/ent_moneyclickers/lua/entities/money_clicker/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Money Clicker"
ENT.Author = "Metamist"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Money Clickers"
ENT.IsMoneyClicker = true

DEFINE_BASECLASS("base_anim")

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Entity", 1, "ClickerOwner")
    self:NetworkVar("Entity", 2, "Safe")

    self:NetworkVar("String", 0, "ClickerName")
    self:NetworkVar("String", 1, "OwnerName")

    self:NetworkVar("Int", 0, "Points")
    self:NetworkVar("Int", 1, "Money")
    self:NetworkVar("Int", 2, "StoredXP")

    self:NetworkVar("Int", 3, "UpgradeAutoClick")
    self:NetworkVar("Int", 4, "UpgradeClickPower")
    self:NetworkVar("Int", 5, "UpgradeCooling")
    self:NetworkVar("Int", 6, "UpgradeStorage")

    self:NetworkVar("Bool", 0, "Broken")
    self:NetworkVar("Bool", 1, "LookAway")
    self:NetworkVar("Bool", 2, "Overheating")

    self:NetworkVar("Float", 0, "RepairWaitTime")
    self:NetworkVar("Float", 1, "ProgressInternal")
    self:NetworkVar("Float", 2, "HeatInternal")

    if SERVER then
    	self:SetMoney(0)
        self:SetPoints(0)
        self:SetStoredXP(0)
        self:SetClickerName("Money Clicker")
        self:SetBroken(false)
        self:SetLookAway(false)

        self:SetUpgradeAutoClick(1)
        self:SetUpgradeClickPower(1)
        self:SetUpgradeCooling(1)
        self:SetUpgradeStorage(1)
    end
end

function ENT:GetProgress()
    return self:GetProgressInternal()
end

function ENT:GetHeat()
    return self:GetHeatInternal()
end

function ENT:GetUpgradeData(upgrade)
    if not self.info then return end

    local data = self.info.upgrades[upgrade]
    if data then
        return data
    else
        MsgC("Missing upgrade ", upgrade, " in config\n")
        return
    end
end

function ENT:GetUpgradeLevel(upgrade)
    if upgrade == "autoClick" then
        return self:GetUpgradeAutoClick()
    elseif upgrade == "clickPower" then
        return self:GetUpgradeClickPower()
    elseif upgrade == "cooling" then
        return self:GetUpgradeCooling()
    elseif upgrade == "storage" then
        return self:GetUpgradeStorage()
    else
        MsgC("Missing upgrade ", upgrade, " in config\n")
        return
    end
end

function ENT:InSafe()
    return IsValid(self:GetSafe())
end

function ENT:IsUsable()
    if self:InSafe() and not self:GetSafe():IsOpened() then return false end

    return true
end

hook.Add('PhysgunPickup', 'money_clickers', function(ply, ent)
    if ent:GetClass() == 'money_clicker' and ent:InSafe() then return false end
end)
--addons/_smallscripts/lua/entities/npc_waydealer/cl_init.lua:
include('shared.lua')

local color_bright = Color(236, 113, 71)
local color_dark = Color(43, 49, 54)
local color_other = Color(150, 150, 150)
local color_line = Color(77, 75, 77)
local logo = Material('data/wimages/wlogo.png')

function ENT:Draw()
    self:DrawModel()
    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then return end
    local ang = LocalPlayer():EyeAngles()
    local pos = self:GetPos() + Vector(0,0,self:OBBMaxs().z + 15)

    ang:RotateAroundAxis(ang:Forward(), 90)
    ang:RotateAroundAxis(ang:Right(), 90)

    cam.Start3D2D(pos, Angle(ang.x, ang.y, ang.z), 0.15)
        draw.RoundedBox(0,-130,10,260,60,color_bright)
        draw.RoundedBox( 0,-130,10,260,28, color_dark )
        surface.SetDrawColor( color_other )
        surface.SetMaterial( logo ) 
        surface.DrawTexturedRect( -125, 13, 23, 23 )  
        draw.SimpleText( " WayZer's Role Play", "Trebuchet24", -103, 23, color_white, 0, 1 )
        draw.SimpleText( 'Скупщик', "Trebuchet24", -120, 51, color_white, 0, 1 )
        surface.SetDrawColor( color_line )
        surface.DrawOutlinedRect( -130,10,260,60 )
    cam.End3D2D()
end

ENT.VoiceLines = {
    ['init'] = {
        'Ну, что у тебя там?',
        'Давай, выкладывай свое добро',
    },
    ['sell_success'] = {
        'С тобой приятно иметь дело',
        'Заглядывай почаще, дружище!',
    },
    ['sell_illegal'] = {
        'Представим, что я этого не видел',
        'Что за херню ты мне впарил?',
        'Эй, полиция!',
        'Я не хочу в тюрьму, мужик',
    },
    ['not_buying'] = {
        'Такое не покупаю',
        'Что это за бред?',
        'Ты издеваешься?',
        'Чел...',
    }
}

function ENT:ExecuteVoiceLine(type, force)
    if not govorilka then return end
    if not force and self.talk_cooldown and self.talk_cooldown > CurTime() then return end
    self.talk_cooldown = CurTime() + 1

    local line = self.VoiceLines[type][math.random(1, #self.VoiceLines[type])]

    govorilka('zahar', line, {
        flags = '3d',
        pos = self:GetPos(),
        dist = 250,
    })
end

local color_cansell = Color(46, 204, 113)
local color_cantsell = Color(210, 0, 0)
local function setcolors(dealer, slots)
    for _, v in pairs(slots) do
        local item = v:GetItem()
        if not item then continue end

        v:SetHighlightColor(dealer:CanBuy(item) and color_cansell or color_cantsell)
    end
end


net.Receive('waydealer_sell', function()
    local dealer = net.ReadEntity()
	local id = net.ReadUInt(32)

    dealer:ExecuteVoiceLine('init')

	local con = itemstore.containers.Get(id)
	if not con then return end

    local panel = vgui.Create('DFrame')
    panel:SetTitle('Скупщик')
    panel:MakePopup()
    panel:SetSkin('itemstore')
    panel.Price = 0

    panel.Container = vgui.Create('ItemStoreContainer', panel)
    panel.Container:Dock(TOP)
	panel.Container:SizeToContents()

    local bottom = vgui.Create('DPanel', panel)
    bottom:Dock(TOP)
    bottom:SetTall(25)
    bottom:SetPaintBackground(false)
    
    local btn = vgui.Create('DButton', bottom)
    btn:Dock(RIGHT)
    btn:DockMargin(4,2,4,2)
    btn:SetWide(50)
    btn:SetText('Продать')
    btn.DoClick = function()
        if panel.Price == 0 then return end

        local illegal = false
        for _, v in pairs(con:GetItems()) do
            if v.IsIllegal then illegal = true break end
        end

        net.Start('waydealer_sell')
        net.WriteEntity(dealer)
        net.SendToServer()

        dealer:ExecuteVoiceLine(illegal and 'sell_illegal' or 'sell_success', true)
    end

    local text = vgui.Create('DLabel', bottom)
    text:Dock(FILL)
    text:SetAutoStretchVertical(true)
    text:SetFont('Trebuchet24')
    text:SetColor(Color(0,200,0))
    text:SetText(DarkRP.formatMoney(panel.Price))

    local refresh = panel.Container.Refresh
    panel.Container.Refresh = function(self)
        refresh(self)
        setcolors(dealer, self.Slots)
        
        con = itemstore.containers.Get(id)
        if not con then return end

        panel.Price = 0
        for _, v in pairs(con:GetItems()) do
            if not dealer:CanBuy(v) then continue end
            panel.Price = panel.Price + dealer:GetSellCost(LocalPlayer(), v)
        end
        text:SetText(DarkRP.formatMoney(panel.Price))
    end
	panel.Container:SetContainerID(id)

    panel:SetSize(panel.Container:GetWide() + 10, panel.Container:GetTall() + 32 + 25)

    panel:Center()

	if not hideinv then
		local inv = vgui.Create( "ItemStoreContainerWindow" )
		inv:SetContainerID( LocalPlayer().InventoryID )
		inv:SetTitle( itemstore.Translate( "inventory" ) )
		inv:ShowCloseButton( false )
		inv:MakePopup()
		inv:InvalidateLayout( true )

        local refresh = inv.Container.Refresh
        inv.Container.Refresh = function(self)
            refresh(self)
            setcolors(dealer, self.Slots)
        end
        inv.Container:Refresh()

        for _, v in ipairs(inv.Container.Slots) do
            local old = v.DoClick or wlib.func.blank
            v.DoClick = function(self)
                if not input.IsKeyDown(KEY_LSHIFT) then return old(self) end

                local con_id = self:GetContainerID()
                local slot = self:GetSlot()
                local item = self:GetItem()
    
                if not con_id then return end
                if not slot then return end
                if not item then return end

                local inventory = itemstore.containers.Get(id)

                local psize = inventory:GetPageSize()
                local page
                for k, v in ipairs(inv.Container:GetItems()) do
                    if v.Tab:IsActive() then page = k break end
                end

                local fempty
                for i=psize*(page-1)+1, psize*page do
                    local merge_item = inventory:GetItem(i)

                    if not merge_item then
                        fempty = fempty or i
                    elseif merge_item:CanMerge(item) then
                        LocalPlayer():MergeItem(con_id, slot, inventory:GetID(), i)
                        return
                    end
                end

                LocalPlayer():MoveItem(con_id, slot, inventory:GetID(), fempty)
            end
        end

		local think = inv.Think
		function inv:Think()
			think( self )

			local x, y = panel:GetPos()
			inv:SetPos( panel:GetPos() + ( panel:GetWide() / 2 - inv:GetWide() / 2 ),
				 y + panel:GetTall() + 10 )
		end

		function panel:OnClose()
			inv:Close()
		end
	end
end)
--addons/module_picture/lua/entities/painting_2.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Большая длинная рамка"
ENT.Category = "Fun + Games"
ENT.Author = "xyester"

ENT.Spawnable = true
ENT.DoNotDuplicate = true
ENT.Owned = false

if SERVER then
	function ENT:Use(caller)
    	if caller == self:Getowning_ent() then
    		net.Start("URLPaint Menu")
    			net.WriteEntity(self)
    		net.Send(caller)
    	end
	end

	function ENT:Initialize()
		self:SetModel("models/props_c17/Frame002a.mdl")
		self:SetModelScale(2)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)

		self:SetUseType(SIMPLE_USE)
		self:CPPISetOwner(self:Getowning_ent())
		self:Activate()
	end

	function ENT:OnRemove()
		if URLPaint.List[self] then
			URLPaint.List[self] = nil
		end
    end

    function ENT:OnTakeDamage(damageInfo)
        if damageInfo:GetAttacker() == self:Getowning_ent() then
            self:Remove()
        end
    end
else
	function ENT:Initialize()
		self:SetModel("models/props_c17/Frame002a.mdl")
		self:SetModelScale(2)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:Activate()
	end

	local distSqr = 202500
	
	function ENT:Draw()
	    
        local ply = LocalPlayer()
        local png = self.image
        
		self:DrawModel()
		
        if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
	    

		if GetConVar('urlpaint_enabled'):GetInt() <= 0 then return end
		
		if self:GetPicID() == "" then
			return
		end

		if png == nil then return end

		if png:IsError() then return end

		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 90)
		ang:RotateAroundAxis(ang:Forward(), 90)

		cam.Start3D2D(self:GetPos() + (self:GetUp() * 26) + (self:GetRight() * (self:OBBMaxs().y - 9)), ang, 0.0995)
			surface.SetDrawColor(color_white)
			surface.SetMaterial(png)
			surface.DrawTexturedRect(0, 0, 370, 524)
		cam.End3D2D()
	end
end

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("String", 0, "PicURL")
    self:NetworkVar("String", 1, "PicID")
end
--addons/module_picture/lua/entities/painting_4.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Большая квадратная рамка"
ENT.Category = "Fun + Games"
ENT.Author = "xyester"

ENT.Spawnable = true
ENT.DoNotDuplicate = true
ENT.Owned = false

if SERVER then
	function ENT:Use(caller)
    	if caller == self:Getowning_ent() then
    		net.Start("URLPaint Menu")
    			net.WriteEntity(self)
    		net.Send(caller)
    	end
	end

	function ENT:Initialize()
		self:SetModel("models/props/cs_office/offcertificatea.mdl")
		self:SetModelScale(3)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)

		self:SetUseType(SIMPLE_USE)
		self:CPPISetOwner(self:Getowning_ent())
		self:Activate()
	end

	function ENT:OnRemove()
		if URLPaint.List[self] then
			URLPaint.List[self] = nil
		end
	end

    function ENT:OnTakeDamage(damageInfo)
        if damageInfo:GetAttacker() == self:Getowning_ent() then
            self:Remove()
        end
    end
else
	function ENT:Initialize()
		self:SetModel("models/props/cs_office/offcertificatea.mdl")
		self:SetModelScale(3)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:Activate()
	end

	local distSqr = 202500

	function ENT:Draw()
	    
        local ply = LocalPlayer()
        local png = self.image
        
		self:DrawModel()
		
        if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
	    

		if GetConVar('urlpaint_enabled'):GetInt() <= 0 then return end
		
		if self:GetPicID() == "" then
			return
		end

		if png == nil then return end

		if png:IsError() then return end

		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 180)
		ang:RotateAroundAxis(ang:Forward(), 90)

		cam.Start3D2D(self:GetPos() + (self:GetUp() * 32.5) + (self:GetRight() * (self:OBBMaxs().y - 5)), ang, 0.0585)
			surface.SetDrawColor(color_white)
			surface.SetMaterial(png)
			surface.DrawTexturedRect(-560, 0, 1118, 1110)
		cam.End3D2D()
	end
end

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("String", 0, "PicURL")
    self:NetworkVar("String", 1, "PicID")
end
--addons/tool_permaprop/lua/entities/pp_prop_effect.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.PrintName		= ""
ENT.Author			= ""
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Spawnable		= false
ENT.AdminOnly		= false

--[[---------------------------------------------------------
	Name: Initialize
-----------------------------------------------------------]]
function ENT:Initialize()

	local Radius = 6
	local min = Vector( 1, 1, 1 ) * Radius * -0.5
	local max = Vector( 1, 1, 1 ) * Radius * 0.5

	if ( SERVER ) then

		self.AttachedEntity = ents.Create( "prop_dynamic" )
		self.AttachedEntity:SetModel( self:GetModel() )
		self.AttachedEntity:SetAngles( self:GetAngles() )
		self.AttachedEntity:SetPos( self:GetPos() )
		self.AttachedEntity:SetSkin( self:GetSkin() )
		self.AttachedEntity:Spawn()
		self.AttachedEntity:SetParent( self.Entity )
		self.AttachedEntity:DrawShadow( false )

		self:SetModel( "models/props_junk/watermelon01.mdl" )

		self:DeleteOnRemove( self.AttachedEntity )

		-- Don't use the model's physics - create a box instead
		self:PhysicsInitBox( min, max )

		-- Set up our physics object here
		local phys = self:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:Wake()
			phys:EnableGravity( false )
			phys:EnableDrag( false )
		end

		self:DrawShadow( false )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )

	else

		self.GripMaterial = Material( "sprites/grip" )

		-- Get the attached entity so that clientside functions like properties can interact with it
		local tab = ents.FindByClassAndParent( "prop_dynamic", self )
		if ( tab && IsValid( tab[ 1 ] ) ) then self.AttachedEntity = tab[ 1 ] end

	end

	-- Set collision bounds exactly
	self:SetCollisionBounds( min, max )

end


--[[---------------------------------------------------------
	Name: Draw
-----------------------------------------------------------]]
function ENT:Draw()

	render.SetMaterial( self.GripMaterial )

end


--[[---------------------------------------------------------
	Name: PhysicsUpdate
-----------------------------------------------------------]]
function ENT:PhysicsUpdate( physobj )

	if ( CLIENT ) then return end

	-- Don't do anything if the player isn't holding us
	if ( !self:IsPlayerHolding() && !self:IsConstrained() ) then

		physobj:SetVelocity( Vector( 0, 0, 0 ) )
		physobj:Sleep()

	end

end


--[[---------------------------------------------------------
	Name: Called after entity 'copy'
-----------------------------------------------------------]]
function ENT:OnEntityCopyTableFinish( tab )

	-- We need to store the model of the attached entity
	-- Not the one we have here.
	tab.Model = self.AttachedEntity:GetModel()

	-- Store the attached entity's table so we can restore it after being pasted
	tab.AttachedEntityInfo = table.Copy( duplicator.CopyEntTable( self.AttachedEntity ) )
	tab.AttachedEntityInfo.Pos = nil -- Don't even save angles and position, we are a parented entity
	tab.AttachedEntityInfo.Angle = nil

	-- Do NOT store the attached entity itself in our table!
	-- Otherwise, if we copy-paste the prop with the duplicator, its AttachedEntity value will point towards the original prop's attached entity instead, and that'll break stuff
	tab.AttachedEntity = nil

end


--[[---------------------------------------------------------
	Name: PostEntityPaste
-----------------------------------------------------------]]
function ENT:PostEntityPaste( ply )

	-- Restore the attached entity using the information we've saved
	if ( IsValid( self.AttachedEntity ) ) and ( self.AttachedEntityInfo ) then

		-- Apply skin, bodygroups, bone manipulator, etc.
		duplicator.DoGeneric( self.AttachedEntity, self.AttachedEntityInfo )

		if ( self.AttachedEntityInfo.EntityMods ) then
			self.AttachedEntity.EntityMods = table.Copy( self.AttachedEntityInfo.EntityMods )
			duplicator.ApplyEntityModifiers( ply, self.AttachedEntity )
		end

		if ( self.AttachedEntityInfo.BoneMods ) then
			self.AttachedEntity.BoneMods = table.Copy( self.AttachedEntityInfo.BoneMods )
			duplicator.ApplyBoneModifiers( ply, self.AttachedEntity )
		end

		self.AttachedEntityInfo = nil

	end

end

--addons/weapon_spiderswep/lua/entities/rope/shared.lua:
ENT.Type = "anim"


/*---------------------------------------------------------
---------------------------------------------------------*/
function ENT:SetEndPos( endpos )

	self.Entity:SetNetworkedVector( 0, endpos )	
	self.Entity:SetCollisionBoundsWS( self.Entity:GetPos(), endpos, Vector() * 0.25 )
	
end


/*---------------------------------------------------------
---------------------------------------------------------*/
function ENT:GetEndPos()
	return self.Entity:GetNetworkedVector( 0 )
end

--addons/module_weed/lua/entities/sent_battery.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"

ENT.Size = Vector(10,10,20)
ENT.PrintName		= "Батарейка"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"
ENT.Spawnable 		= false
ENT.AdminOnly 		= false

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/battery.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    self:SetCharge(100)
	    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
	end
end

function ENT:SetBattery(x)
  self:SetDisposable(Either(x==1,true,false))
end

ENT.NextDelete = 0
function ENT:Think()
  if(SERVER and self:GetCharge() == 0) then
    if(self.NextDelete == 0) then self.NextDelete = CurTime() + 60 end
    if(self.NextDelete < CurTime()) then
      self:Remove()
    end
  end
end

if CLIENT then

  local rope = Material("gui/rope")
  local water = surface.GetTextureID("gui/light")
  local hl = {Color(231, 76, 60),Color(230, 126, 34),Color(241, 196, 15),Color(46, 204, 113)}
  local x,_ = 0,0;

  function ENT:DoInfo()

    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
      return
    end

    surface.SetDrawColor(50,50,50,150)
    surface.DrawRect(12,-32,math.Clamp(x+48,268,999),128)
    x,_ = draw.SimpleTextOutlined(self.PrintName,"MainWeedFont",36,-2,Color(255,255,255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
    surface.SetMaterial(rope)
  	surface.SetDrawColor(255,255,255,255)
    surface.DrawTexturedRectUV( 12, -32, 4, 128, 0, 0, 1, 1 )
    surface.DrawTexturedRectUVRotated(12+math.Clamp(x+48,268,999), 30, 4, 128, 0, 0, 1, 1 ,180)
    surface.DrawTexturedRectUVRotated(12+math.Clamp(x+48,268,999)/2, -32, 4, math.Clamp(x+48,268,999), 0, 0, 1, 2 ,90)
    surface.DrawTexturedRectUVRotated(12+math.Clamp(x+48,268,999)/2, -32+128, 4, math.Clamp(x+48,268,999), 0, 0, 1, 2 ,90)

    surface.SetTexture(water)
  	surface.SetDrawColor(hl[math.Clamp(math.Round((self:GetCharge())/25),1,4)])
  	surface.DrawTexturedRect(30,22,64,64)

    draw.SimpleTextOutlined((self:GetCharge()).."%","MainWeedFont",math.Clamp(x+48,268,999),56,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))

  end
end

function ENT:SetupDataTables()
  self:NetworkVar("Int", 0, "Charge")
  self:NetworkVar("Bool", 0, "Disposable")
end
--addons/module_weed/lua/entities/sent_charger.lua:
 AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

if SERVER then
  util.AddNetworkString("UpdateBatteries")
end

ENT.Base = "sent_base_gonzo"

ENT.Linkable = true
ENT.Size = Vector(10,40,30)
ENT.PrintName		= "Зарядка"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"
ENT.Spawnable 		= false
ENT.AdminOnly 		= false

ENT.Batteries = {}
ENT.Filter = {}

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/charger.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
	    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
    self.Batteries = {}
	end
end

ENT.SN = 0

function ENT:Touch(entity)
  for k,v in pairs(self.Batteries) do
    if(v == NULL) then
      table.RemoveByValue(self.Batteries,v)
    end
  end
  if(entity:GetClass() == "sent_battery" && #self.Batteries < 2 && entity:GetCharge() < 100 && !(entity.Charging or false) && !entity:GetDisposable()) then
    entity.Charging = true
    self.SN = self.SN + 1
    for k,v in pairs(self.Filter) do
      if(v[1] == entity && v[2] == entity:GetCharge()) then
        return
      elseif(v[2] != entity:GetCharge()) then
        table.RemoveByValue(self.Filter,v)
      end
    end
    entity:SetParent(self)
    entity:SetLocalPos(Vector(0,0,0))
    entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    if(#self.Batteries == 0) then
      entity:SetLocalAngles(Angle(0,0,0))
      self:SetBat_A(entity)
    else
      entity:SetLocalAngles(Angle(0,0,60))
      self:SetBat_B(entity)
    end
    table.insert(self.Batteries,entity)
  end
end

function ENT:Use(ply)
  if(#self.Batteries > 0 && self.SN > 0) then
    self.SN = self.SN - 1

    local bat
    if IsValid(self.Batteries[2]) and self.Batteries[1]:GetCharge() > self.Batteries[2]:GetCharge() then
      bat = self.Batteries[1]
    else
      bat = self.Batteries[2]
    end
    
    local ent = ents.Create("sent_battery")
    ent:SetPos(self:GetPos() + Vector(0,0,30))
    ent.Charging = false
    ent:Spawn()
    ent.weed_owner = ply
    ent.SID = ply.SID
    if(ent.Setowning_ent) then
      ent:Setowning_ent(ply)
    end
    ent:CPPISetOwner(ply)
    ent:SetCharge(bat:GetCharge())
    undo.ReplaceEntity(v,ent)
    self.Batteries = {Either(self.Batteries[1] == bat,self.Batteries[2],self.Batteries[1])}
    table.insert(self.Filter,{ent,ent:GetCharge()})
    bat:Remove()
  end

end

function ENT:Think()
  if SERVER then
    if(#self.Batteries > 0) then
      for k,v in pairs(self.Batteries) do
        if(v:GetCharge() >= 100 && (v.Charging or false)) then
          local ent = ents.Create("sent_battery")
          ent:SetPos(self:GetPos() + Vector(0,0,30))
          ent.Charging = false
          ent:Spawn()
		      ent.weed_owner = self.weed_owner
          ent.SID = self.weed_owner.SID
          ent:CPPISetOwner(self.weed_owner)
          ent:SetCharge(100)
          undo.ReplaceEntity(v,ent)
          v:Remove()
        else
          v:SetCharge(math.Clamp(v:GetCharge()+1,0,100))
        end
      end
    end
    self:NextThink(WEED_CONFIG.ReloadRate + CurTime())
    return true
  end
end

function ENT:SetupDataTables()
  self:NetworkVar("Entity", 0, "Bat_A")
  self:NetworkVar("Entity", 1, "Bat_B")
end

if CLIENT then

  local rope = Material("gui/rope")
  local light = surface.GetTextureID("gui/light")

  function ENT:DoInfo()

    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
      return
    end

    surface.SetDrawColor(50,50,50,150)
    surface.DrawRect(12,-32,268,196)
    draw.SimpleTextOutlined(self.PrintName,"MainWeedFont_med",36,-2,Color(255,255,255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
    surface.SetMaterial(rope)
  	surface.SetDrawColor(255,255,255,255)
    surface.DrawTexturedRectUV( 12, -32, 4, 196, 0, 0, 1, 1 )
    surface.DrawTexturedRectUVRotated(12+268, 64, 4, 196, 0, 0, 1, 1 ,180)
    surface.DrawTexturedRectUVRotated(12+268/2, -32, 4, 268, 0, 0, 1, 2 ,90)
    surface.DrawTexturedRectUVRotated(12+268/2, -32+196, 4, 268, 0, 0, 1, 2 ,90)

    surface.SetTexture(light)

    if(IsValid(self:GetBat_A())) then
      surface.SetDrawColor(255,255,255)
      draw.SimpleTextOutlined(self:GetBat_A():GetCharge().."%","MainWeedFont",268,56,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
    else
      surface.SetDrawColor(255,255,255,50)
      draw.SimpleTextOutlined("Пусто","MainWeedFont",268,56,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
    end

    surface.DrawTexturedRect(30,24,64,64)

    if(IsValid(self:GetBat_B())) then
      surface.SetDrawColor(255,255,255)
      draw.SimpleTextOutlined(self:GetBat_B():GetCharge().."%","MainWeedFont",268,56+64,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
    else
      surface.SetDrawColor(255,255,255,50)
      draw.SimpleTextOutlined("Пусто","MainWeedFont",268,56+64,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
    end

    surface.DrawTexturedRect(30,24+64,64,64)

  end

end
--addons/module_weed/lua/entities/sent_magazine.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"

if SERVER then
  util.AddNetworkString("ShowManual")
end

ENT.Size = Vector(5,20,20)
ENT.PrintName		= "Все про гровинг №101"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"
ENT.Spawnable 		= false
ENT.AdminOnly 		= false

ENT.Seed = 1

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/props_lab/bindergreenlabel.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
	 	self:SetModelScale(1,0)
    self:SetUseType(SIMPLE_USE)
	    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
	end
end

function ENT:Use(act)
  if(SERVER) then
    net.Start("ShowManual")
    net.Send(act)
  end
end

--addons/module_weed/lua/entities/sent_seed.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"

ENT.PrintName		= "Семя"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"
ENT.Spawnable 		= false
ENT.AdminOnly 		= false

ENT.Seed = 1

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/props_junk/watermelon01.mdl" )
        self:SetModelScale(0.6,0)
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
        self:SetMaterial("models/gonzo/weed/weed")
	 	self:SetHealth(99999)
	 	self:SetColor(Color(75,75,75))

	    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
	end
end

ENT.Waterizer = 0
ENT.Extra = 0

function ENT:SetSeed(x)
	self:SetColor(Color(150,150,150))
	if(x==1) then
		self.Waterizer = 0
		self.Extra = 0
    self.Quality = 50
    self:SetHUDName("Amnesia Haze")
	elseif(x==2) then
		self.Waterizer = -30
		self.Extra = 2
    self:SetColor(Color(255,175,75))
    self.Quality = 75
    self:SetHUDName("Bubble Kush")
	elseif(x==3) then
		self.Waterizer = 30
		self.Extra = -5
    self.Quality = 100
    self:SetColor(Color(75,150,75))
    self:SetHUDName("O.G. Kush")
  elseif(x==4) then
    self.Waterizer = -40
    self.Extra = 5
    self.Quality = 35
    self:SetColor(Color(255,75,255))
    self:SetHUDName("Haze Berry")
	end
end

function ENT:SetupDataTables()
  self:NetworkVar("String", 0, "HUDName")
end
--addons/module_slotmachine/lua/entities/slot_double/cl_init.lua:
include("shared.lua")
include('bdon_config.lua')

local new_material = CreateMaterial("MyMaterial","UnlitGeneric",params);

local screenOverlay = Material( "materials/bluesdoubleornothing/screen_overlay.png" )
local screenBackground = Material( "materials/bluesdoubleornothing/screen_background.png" )
local startMaterial = Material("materials/bluesdoubleornothing/start.png")
local cashoutMaterial = Material("materials/bluesdoubleornothing/cashout.png")
local jackpotMaterial = Material("materials/bluesdoubleornothing/jackpot.png")
local bsodMaterial = Material("materials/bluesdoubleornothing/bsod.png")

local numberMaterials = {}
for i = 0 , 10 do
	numberMaterials[i] = Material("materials/bluesdoubleornothing/x"..i..".png")
end

local lowEndColor = Color(130,130,210)
local highEndColor = Color(255,58,58)

--Lerps between colors instead of single values
local function LerpColor(t, col1, col2)
	local newCol = Color(0,0,0,0)

	newCol.r = Lerp(t, col1.r, col2.r)
	newCol.g = Lerp(t, col1.g, col2.g)
	newCol.b = Lerp(t, col1.b, col2.b)
	newCol.a = Lerp(t, col1.a, col2.a)

	return newCol
end

surface.CreateFont( "BDON_SMALL", {
	font = "Roboto",
	extended = false,
	size = 50,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false, 
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BDON_MEDIAM", {
	font = "Roboto",
	extended = false,
	size = 85,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BDON_LARGE", {
	font = "Roboto",
	extended = false,
	size = 150,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

--Localise some vars

local surface = surface
local CurTime = CurTime
local math = math
local Color = Color
local draw = draw
local FrameTime = FrameTime
local oldLocalPlayer = LocalPlayer
local LocalPlayer = LocalPlayer
local Matrix = Matrix

if isfunction(LocalPlayer) and LocalPlayer():IsValid() then
	LocalPlayer = LocalPlayer()
end

hook.Add("InitPostEntity", "bdon:setuplocalplayer", function()
	LocalPlayer = oldLocalPlayer()
end)

local screenDisabled = false

local function comma_value(amount)
 	local formatted = amount
 	while true do   
    	formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
    	if (k==0) then
    		break 
    	end
  	end
	return formatted
end

function ENT:Initialize()
	self.screenMaterial = CreateMaterial("bdn_machinescreenmat_"..self:EntIndex(), "UnlitGeneric", {})
	self.renderTarget = GetRenderTarget("bdn_machinescreen_"..self:EntIndex(), 2048, 2048, false)
	self.color = Color(math.random(0, 255), math.random(0, 255), math.random(0, 255))

	self.ScreenZoom = 1
	self.ScreenRotation = 0
	self.textRotation = 0

	self.cashOutSelected = false

	--This is frames used to draw the jackpot page, 0 means disabled.
	self.jackpotFrame = 0

	self.overrideGlitchMulti = false
	self.glitchMulti = 0

	self.screenMaterial:SetTexture('$basetexture', self.renderTarget)
end

--Stores draw frames for jackpots
local jackpotFrames = {}

--bsof screen
jackpotFrames[1] = function(ScrW, ScrH, ent)
	ent.ScreenZoom = 1 --Set instantly

	surface.SetDrawColor(Color(255,255,255,255))
	surface.SetMaterial(bsodMaterial) 
	surface.DrawTexturedRect(0, 0, ScrW, ScrH) 
end

--Dont worry
jackpotFrames[2] = function(ScrW, ScrH)
	draw.SimpleText("Не волнуйтесь", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5, Color(60,60,60,255), 1, 0)
	draw.SimpleText("Не волнуйтесь", "BDON_MEDIAM", ScrW/2, ScrH / 2, Color(255,255,255,255), 1, 0)
end

--This isnt a glitch
jackpotFrames[3] = function(ScrW, ScrH)
	draw.SimpleText("Это не глюк", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5, Color(60,60,60,255), 1, 0)
	draw.SimpleText("Это не глюк", "BDON_MEDIAM", ScrW/2, ScrH / 2, Color(255,255,255,255), 1, 0)
end

--I'v got something to tell you
jackpotFrames[4] = function(ScrW, ScrH)
	draw.SimpleText("Мне нужно", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5, Color(60,60,60,255), 1, 0)
	draw.SimpleText("Мне нужно", "BDON_MEDIAM", ScrW/2, ScrH / 2, Color(255,255,255,255), 1, 0)

	draw.SimpleText("вам кое-что сказать", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5 + 75, Color(60,60,60,255), 1, 0)
	draw.SimpleText("вам кое-что сказать", "BDON_MEDIAM", ScrW/2, ScrH / 2 + 75, Color(255,255,255,255), 1, 0)
end

--Something important
jackpotFrames[5] = function(ScrW, ScrH, ent)
	draw.SimpleText("Что-то важное", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5, Color(60,60,60,255), 1, 0)
	draw.SimpleText("Что-то важное", "BDON_MEDIAM", ScrW/2, ScrH / 2, Color(255,255,255,255), 1, 0)
end

--Congratulations player
jackpotFrames[6] = function(ScrW, ScrH, ent)
	draw.SimpleText("Поздравляем", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5, Color(60,60,60,255), 1, 0)
	draw.SimpleText("Поздравляем", "BDON_MEDIAM", ScrW/2, ScrH / 2, Color(255,255,255,255), 1, 0)

	draw.SimpleText(ent:GetUserName(), "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5 + 75, Color(60,60,60,255), 1, 0)
	draw.SimpleText(ent:GetUserName(), "BDON_MEDIAM", ScrW/2, ScrH / 2 + 75, Color(255,255,255,255), 1, 0)
end

--You've just won the...
jackpotFrames[7] = function(ScrW, ScrH, ent)
	draw.SimpleText("Вы только что", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5, Color(60,60,60,255), 1, 0)
	draw.SimpleText("Вы только что", "BDON_MEDIAM", ScrW/2, ScrH / 2, Color(255,255,255,255), 1, 0)

	draw.SimpleText("выиграли...", "BDON_MEDIAM", ScrW/2 + 5, ScrH / 2 + 5 + 75, Color(60,60,60,255), 1, 0)
	draw.SimpleText("выиграли...", "BDON_MEDIAM", ScrW/2, ScrH / 2 + 75, Color(255,255,255,255), 1, 0)	
end

--You've just won the...
jackpotFrames[8] = function(ScrW, ScrH, ent)
	surface.SetDrawColor(LerpColor(math.sin((CurTime() * 22) + 1) / 2,Color(255,215,100), Color(255 * 0.6,215 * 0.6, 100)))
	surface.SetMaterial(screenBackground)
	surface.DrawTexturedRectRotated(ScrW /2, ScrH /2 , 2350, 2350, (CurTime() * 60) % 360)

	surface.SetDrawColor(Color(255,255,255))
	surface.SetMaterial(jackpotMaterial) 
	surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 1024 * 1.5, 512 * 1.5, ent.textRotation)	

	--draw.SimpleText("YOU WON!", "BDON_LARGE", ScrW/2 + 5, 350 + 5 - 30, Color(60,60,60,255), 1, 0)
	--draw.SimpleText("YOU WON!", "BDON_LARGE", ScrW/2, 350 - 30, Color(255,255,255,255), 1, 0)

	--draw.SimpleText("$"..comma_value(self:GetCashOutAmount()), "BDON_LARGE", ScrW/2 + 5, 350 + 5 + 75, Color(60,60,60,255), 1, 0)
	--draw.SimpleText("$"..comma_value(self:GetCashOutAmount()), "BDON_LARGE", ScrW/2, 350 + 75, Color(255,255,255,255), 1, 0)

	surface.SetDrawColor(Color(255,255,255,255))
	surface.SetMaterial(screenOverlay) 
	surface.DrawTexturedRect(0 - 50, 0 - 50, ScrW + 100, ScrH + 100) 
end

jackpotFrames[9] = function(ScrW, ScrH, ent)
	surface.SetDrawColor(LerpColor(math.sin((CurTime() * 22) + 1) / 2,Color(255,215,100), Color(255 * 0.6,215 * 0.6, 100)))
	surface.SetMaterial(screenBackground)
	surface.DrawTexturedRectRotated(ScrW /2, ScrH /2 , 2350, 2350, (CurTime() * 60) % 360)

	surface.SetDrawColor(Color(255,255,255))
	surface.SetMaterial(jackpotMaterial) 
	surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 1024 * 1.5, 512 * 1.5, ent.textRotation)	

	draw.SimpleText("ВАШ ПРИЗ", "BDON_LARGE", ScrW/2 + 5, 450 + 5 - 30, Color(60,60,60,255), 1, 0)
	draw.SimpleText("ВАШ ПРИЗ", "BDON_LARGE", ScrW/2, 450 - 30, Color(255,255,255, 255), 1, 0)
 
	draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(ent:GetJackpot()), "BDON_LARGE", ScrW/2 + 5, 450 + 5 + 75, Color(60,60,60,255), 1, 0)
	draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(ent:GetJackpot()), "BDON_LARGE", ScrW/2, 450 + 75, Color(255,255,255,255), 1, 0)

	surface.SetDrawColor(Color(255,255,255,255))
	surface.SetMaterial(screenOverlay) 
	surface.DrawTexturedRect(0 - 50, 0 - 50, ScrW + 100, ScrH + 100) 
end

jackpotFrames[10] = function(ScrW, ScrH, ent)
	surface.SetDrawColor(LerpColor(math.sin((CurTime() * 22) + 1) / 2,Color(255,215,100), Color(255 * 0.6,215 * 0.6, 100)))
	surface.SetMaterial(screenBackground)
	surface.DrawTexturedRectRotated(ScrW /2, ScrH /2 , 2350, 2350, (CurTime() * 60) % 360)

	surface.SetDrawColor(Color(255,255,255))
	surface.SetMaterial(jackpotMaterial) 
	surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 1024 * 1.5, 512 * 1.5, ent.textRotation)	

	draw.SimpleText("ВАШ ПРИЗ", "BDON_LARGE", ScrW/2 + 5, 450 + 5 - 30, Color(60,60,60,255), 1, 0)
	draw.SimpleText("ВАШ ПРИЗ", "BDON_LARGE", ScrW/2, 450 - 30, Color(255,255,255, 255), 1, 0)

	local prizeLerpValue = math.Clamp((ent.jackpotCountdown - CurTime()) / 13.97, 0, 1)
 
	local prizeValue = math.floor(Lerp(1 - prizeLerpValue, ent:GetJackpot(), 0))

	draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(prizeValue), "BDON_LARGE", ScrW/2 + 5, 450 + 5 + 75, Color(60,60,60,255), 1, 0)
	draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(prizeValue), "BDON_LARGE", ScrW/2, 450 + 75, Color(255,255,255,255), 1, 0)

	surface.SetDrawColor(Color(255,255,255,255))
	surface.SetMaterial(screenOverlay) 
	surface.DrawTexturedRect(0 - 50, 0 - 50, ScrW + 100, ScrH + 100) 
end



--Called when ever the screen should draw
function ENT:DrawScreen(ScrW, ScrH)
	local multiplier = self:GetMultiplier() -- out of 10
 
	--Do we override with the jackpot?
	if self.jackpotFrame ~= 0 then
		jackpotFrames[self.jackpotFrame](ScrW, ScrH, self)
		return --Dont draw anything else
	end

	--Draw cashout screen
	if self:GetCashOutAmount() > 0 then
		surface.SetDrawColor(LerpColor(math.sin((CurTime() * 8) + 1) / 2,Color(83,255,136), Color(83 * 0.6,255 * 0.6,136 * 0.6)))
		surface.SetMaterial(screenBackground)
		surface.DrawTexturedRectRotated(ScrW /2, ScrH /2 , 2350, 2350, (CurTime() * 10) % 360)

		surface.SetDrawColor(Color(255,255,255))
		surface.SetMaterial(cashoutMaterial) 
		surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 1024 * 1.3, 512 * 1.3, self.textRotation)	

		draw.SimpleText("ВЫ ВЫИГРАЛИ!", "BDON_LARGE", ScrW/2 + 5, 350 + 5 - 30, Color(60,60,60,255), 1, 0)
		draw.SimpleText("ВЫ ВЫИГРАЛИ!", "BDON_LARGE", ScrW/2, 350 - 30, Color(255,255,255,255), 1, 0)

		draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(self:GetCashOutAmount()), "BDON_LARGE", ScrW/2 + 5, 350 + 5 + 75, Color(60,60,60,255), 1, 0)
		draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(self:GetCashOutAmount()), "BDON_LARGE", ScrW/2, 350 + 75, Color(255,255,255,255), 1, 0)

		--Draw the current user 
		local textToDisplay = "Выплата: "
		if math.ceil((self:GetUserLastInteract() + 10) - CurTime()) > 0 then
			textToDisplay = textToDisplay.." "..math.abs(math.ceil((self:GetUserLastInteract() + 10) - CurTime())).." сек"
		end
		draw.SimpleText(textToDisplay, "BDON_LARGE", ScrW /2 + 5, ScrH - 200, Color(60,60,60,255), 1, 0)
		draw.SimpleText(textToDisplay, "BDON_LARGE", ScrW /2, ScrH - 200, Color(255,255,255,255), 1, 0)

		surface.SetDrawColor(Color(255,255,255,255))
		surface.SetMaterial(screenOverlay) 
		surface.DrawTexturedRect(0, 0, ScrW, ScrH) 

		return --Prevent rest from drawing
	end

	--Draw start screen stuff
	if self:GetGameStarted() == false then
		surface.SetDrawColor(LerpColor(math.sin((CurTime() * 3) + 1) / 2,Color(83,255,136), Color(83,192,255)))
		surface.SetMaterial(screenBackground)
		surface.DrawTexturedRectRotated(ScrW /2, ScrH /2 , 2350, 2350, (CurTime() * 10) % 360)

		surface.SetDrawColor(Color(255,255,255))
		surface.SetMaterial(startMaterial) 
		surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 1150, 512, self.textRotation)	

		draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(BDON_CONFIG.bet).." ЗА ИГРУ", "BDON_LARGE", ScrW/2 + 5, 350 + 5, Color(60,60,60,255), 1, 0)
		draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(BDON_CONFIG.bet).." ЗА ИГРУ", "BDON_LARGE", ScrW/2, 350, Color(255,255,255,255), 1, 0)

		draw.SimpleText("Джекпот: "..BDON_CONFIG.CurrenyPrefix..comma_value(self:GetJackpot()), "BDON_MEDIAM", ScrW/2 + 5, ScrH - 450 + 5, Color(60,60,60,255), 1, 0)
		draw.SimpleText("Джекпот: "..BDON_CONFIG.CurrenyPrefix..comma_value(self:GetJackpot()), "BDON_MEDIAM", ScrW/2, ScrH - 450, Color(255,255,255,255), 1, 0)
		    
		--Draw the current user 
		local textToDisplay = "Выплата: "
		if math.ceil((self:GetUserLastInteract() + 10) - CurTime()) > 0 then
			textToDisplay = textToDisplay.." "..math.abs(math.ceil((self:GetUserLastInteract() + 10) - CurTime())).." сек"
		end
		draw.SimpleText(textToDisplay, "BDON_LARGE", ScrW /2 + 5, ScrH - 200, Color(60,60,60,255), 1, 0)
		draw.SimpleText(textToDisplay, "BDON_LARGE", ScrW /2, ScrH - 200, Color(255,255,255,255), 1, 0)

		surface.SetDrawColor(Color(255,255,255,255))
		surface.SetMaterial(screenOverlay) 
		surface.DrawTexturedRect(0, 0, ScrW, ScrH) 

		return --Prevent the rest from drawin
	end

	--Draw in game stuff

	--Draw the background surface
	if multiplier ~= 0 then
		surface.SetDrawColor(LerpColor(multiplier/10, lowEndColor, highEndColor))
		surface.SetMaterial(screenBackground)
		surface.DrawTexturedRectRotated(ScrW /2, ScrH /2 , 2350, 2350, (CurTime() * self:GetMultiplier() * 10) % 360)
	else
		surface.SetDrawColor(LerpColor(math.sin((CurTime() * 10) + 1) / 2, Color(160,0,0), Color(255,0,0)))
		surface.SetMaterial(screenBackground)
		surface.DrawTexturedRectRotated(ScrW /2, ScrH /2 , 2350, 2350, (CurTime() * 10) % 360)	
	end

	if multiplier ~= 0 then
		--Draw multiplier
		surface.SetDrawColor(LerpColor(1 - (multiplier/10), lowEndColor, highEndColor))
		surface.SetMaterial(numberMaterials[self:GetMultiplier()])
		surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 1024, 1024, self.textRotation)
	else
		surface.SetDrawColor(Color(255,90,90))
		surface.SetMaterial(numberMaterials[0])
		surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 1024, 512, self.textRotation)	
	end

	local bet = BDON_CONFIG.bet

	for i = 1 , self:GetMultiplier() - 1 do
		bet = bet * 2
	end

	--Draw winning amount so far
	draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(bet), "BDON_LARGE", ScrW/2 + 5, 350 + 5, Color(60,60,60,255), 1, 0)
	draw.SimpleText(BDON_CONFIG.CurrenyPrefix..comma_value(bet), "BDON_LARGE", ScrW/2, 350, Color(255,255,255,255), 1, 0)


	--Draw the current user 
	local textToDisplay = "Выплата: "
	if math.ceil((self:GetUserLastInteract() + 10) - CurTime()) > 0 then
		textToDisplay = textToDisplay.." "..math.abs(math.ceil((self:GetUserLastInteract() + 10) - CurTime())).." сек"
	end
	draw.SimpleText(textToDisplay, "BDON_LARGE", ScrW /2 + 5, ScrH - 200, Color(60,60,60,255), 1, 0)
	draw.SimpleText(textToDisplay, "BDON_LARGE", ScrW /2, ScrH - 200, Color(255,255,255,255), 1, 0)

	--Draw overlay 
	surface.SetDrawColor(Color(255,255,255,255))
	surface.SetMaterial(screenOverlay) 
	surface.DrawTexturedRect(0, 0, ScrW, ScrH) 
end

local screenX = 2050
local screenY = 2050

local xShake = 0
local yShake = 0

function ENT:Draw()

	if self:GetPos():DistToSqr(LocalPlayer:GetPos()) < 15000 then

		self.ScreenZoom = Lerp((10 - self:GetMultiplier()) * FrameTime(), self.ScreenZoom, 1)
		self.textRotation = Lerp((10 - self:GetMultiplier()) * FrameTime(), self.textRotation, 0)

		if self.overrideGlitchMulti then
			self.ScreenZoom = Lerp(3 * FrameTime(), self.ScreenZoom, 1)
			self.textRotation = Lerp(3 * FrameTime(), self.textRotation, 0)		 
		end

		xShake = 0
		yShake = 0

		local mat = Matrix()
		if self.ScreenZoom > 1 then
			if self:GetMultiplier() > 3 and not self.overrideGlitchMulti then
				xShake = Lerp((self.ScreenZoom - 1) / 2.5, 0, math.random(-75, 75))
				yShake = Lerp((self.ScreenZoom - 1) / 2.5, 0, math.random(-75, 75))
			else
				xShake = Lerp(((self.ScreenZoom - 1) * self.glitchMulti) / 2.5, 0, math.random(-75, 75))
				yShake = Lerp(((self.ScreenZoom - 1) * self.glitchMulti) / 2.5, 0, math.random(-75, 75))		
			end

			mat:SetTranslation(Vector((0 + (self.ScreenZoom * (screenX/2))) - (screenX / 2) + xShake, (0 + (self.ScreenZoom * (screenY/2))) - (screenY / 2) + yShake) * -1)
			mat:Scale( Vector( 1, 1, 1 ) * self.ScreenZoom) 
		end

		--Draw the screen
		render.PushRenderTarget(self.renderTarget)
			render.Clear(0,0,0,255, true, true)
			render.OverrideAlphaWriteEnable(true, true)
			cam.Start2D()
				cam.PushModelMatrix(mat)
					self:DrawScreen(screenX, screenY)
				cam.PopModelMatrix()
			cam.End2D()
		render.PopRenderTarget()

		--Update material texture
		--self.screenMaterial:SetTexture('$basetexture', self.renderTarget)
		self:SetSubMaterial(10, "!bdn_machinescreenmat_"..self:EntIndex())
	end

	--Draw the final result
	self:DrawModel()
end

function ENT:Think()
	if self.inJackpot then
		self:JackpotThink()
	end
end

--Update for the jackpot
function ENT:JackpotThink()

end

local jackpotTimers = {
	{timer = 3.69, func = function() end},
	{timer = 5.76, func = function() end},
	{timer = 7.61, func = function() end},
	{timer = 9.48, func = function() end},
	{timer = 11.35, func = function() end},
	{timer = 13.21, func = function() end}, 
	{timer = 15.09, func = function(ent) 
		ent.glitchMulti = 2
		timer.Create("jackpot_bounce_"..ent:EntIndex(), 468.75 / 1000, 0, function()
			ent.ScreenZoom = (1 + (3 / 4))
			ent.textRotation = math.random( -3 * 4, 3 * 4)	
		end) 
	end},
	{timer = 30.09, func = function(ent) ent.glitchMulti = 1 end},
	{timer = 45.09, func = function(ent) 
		ent.jackpotCountdown = CurTime() + 13.97
	end}, 
	{timer = 58, noframeAdvance = true, func = function(ent) --Reset
		timer.Destroy("jackpot_bounce_"..ent:EntIndex())
	end}, 
	{timer = 59, func = function(ent) --Reset
		ent.jackpotFrame = 0 
		ent.overrideGlitchMulti = false
	end}, 
} 

--Triggers the jackpot
function ENT:PlayJackpot()
	--Set up a bunch of timers (I know its ugly but honestly who really cares, amirite)

	self.jackpotStartTime = CurTime()

	self.jackpotFrame = 1 --Begin drawing
	self.overrideGlitchMulti = true

	self.overrideGlitchMulti = true
	self.glitchMulti = 2

	--Emit the audio
	self:EmitSound("bdon_jackpot")
	--Set up the timers
	for k, v in pairs(jackpotTimers) do
		timer.Simple(v.timer, function() 
		    if not IsValid(self) then return end
			if not v.noframeAdvance then 
				self.jackpotFrame = self.jackpotFrame + 1	
			end
			v.func(self)	
		end)
	end 
end

--Trigger light effect
net.Receive("bdon:updateScreenEffect",function()
	local e = net.ReadEntity()
	local power = net.ReadFloat()

	if e == nil or not e:IsValid() then return end

	if power < 1 then power = (1 + (e:GetMultiplier() / 4)) end
	if e ~= nil and e:IsValid() then
		e.ScreenZoom = power
		e.textRotation = math.random( -3 * e:GetMultiplier(), 3 * e:GetMultiplier())
	end
end)

net.Receive("bdn:beginjackpot", function()
	local e = net.ReadEntity()
	if e == nil or not e:IsValid() then return end

	--Trigger the jackpot
	e:PlayJackpot()
end)
--Sound related stuff

sound.Add( {
	name = "bdon_jackpot",
	channel = CHAN_AUTO,
	volume = 1.0,
	level = 75 * BDON_CONFIG.Volume,
	pitch = {100},
	sound = "doubleornothing/jackpot.mp3"
} )

util.PrecacheSound("doubleornothing/jackpot.mp3")
util.PrecacheSound("bdon_jackpot")

concommand.Add("bdor_disable_screens", function() 
	screenDisabled = true
end)

concommand.Add("bdor_enable_screens", function() 
	screenDisabled = false
end)
--addons/_smallscripts/lua/entities/trash_dumpster/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Мусорный ящик'
ENT.Author = 'WayZer\'s Role Play'
ENT.Category = 'Запрещено'
ENT.Freeze = true
ENT.Spawnable = true
ENT.AdminSpawnable = true
--addons/tool_textscreen/lua/entities/wrp_text/cl_init.lua:
include("shared.lua")

function ENT:Draw()
end

for i=30, 100 do
	surface.CreateFont("WRP.TextPlacements.Font."..i, {
		font = "Calibri",
		size = i,
		weight = 100
	})
end

local function drawText(text, size, posx, posy, color, align1, align2)
	return draw.SimpleText(text or "Sample Text", "WRP.TextPlacements.Font."..(size or 30), posx or 0, posy or 0, color or color_black, align1 or TEXT_ALIGN_CENTER, align2 or TEXT_ALIGN_CENTER)
end

local toDraw = {}

timer.Create("textscreen_cache", 1, 0, function()
	local ply = LocalPlayer()
	if IsValid(ply) then
		local count = 0
		toDraw = {}

	    for k,v in ipairs(ents.FindInSphere(ply:GetPos(), 500)) do
	    	if v:GetClass() == "wrp_text" then
	    		count = count + 1
	        	toDraw[count] = v
	    	end
	    end
	end
end)

hook.Add( "PostDrawTranslucentRenderables", "WRP_TextDraw", function()
	for k, self in ipairs(toDraw) do
		if (not self.data) and (not self.requested) then
			self.requested = true
			net.Start("Tool.TextPlacements.RequestData")
				net.WriteEntity(self)
			net.SendToServer()

			return
		elseif (not self.data) then
			return
		end

	    local ang = self:GetAngles()

	    for i=1, 2 do
			cam.Start3D2D(self:GetPos(), ang, 0.17)
				for k, v in pairs(self.data.text) do
					local space = 70*#self.data.text
					local startingPos = 0-(space/2)+(70/2)
					drawText(v, self.data.size[k] or 50, 0, startingPos+((k-1)*70), self.data.color[k], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end
			cam.End3D2D()

			ang:RotateAroundAxis(ang:Right(), 180*i)
	    end
	end
end)

net.Receive("Tool.TextPlacements.RespondData", function()
	local ent = net.ReadEntity()
	if not ent then return end

	ent.data = net.ReadTable()

	ent.requested = false
end)
--addons/module_hits/lua/entities/zhits_phone.lua:
AddCSLuaFile()

ENT.Type                = 'anim'
ENT.Base                = 'base_anim'

if CLIENT then
      ENT.PrintName           = 'Телефон'
      ENT.Category            = 'Разрешено'
end

ENT.Spawnable           = true

if SERVER then
      function ENT:Initialize()
            self:SetModel 'models/props_trainstation/payphone001a.mdl'
            self:PhysicsInit(SOLID_VPHYSICS)
            self:SetMoveType(MOVETYPE_VPHYSICS)
            self:SetSolid(SOLID_VPHYSICS)
            self:SetUseType(SIMPLE_USE)

            local phys = self:GetPhysicsObject()

            if IsValid(phys) then
                  phys:Wake()
            end
      end

      function ENT:Use(cal)
            if IsValid(cal) then
                  cal:ConCommand('PlaceHit')
            end
      end
end

if CLIENT then
      surface.CreateFont("WayZFont", {
        size = 48,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Arial",
    })
      local LocalPlayer = LocalPlayer
      local Vector = Vector
      local Angle = Angle
      local math = math
      local cam = cam

      local logo = Material('data/wimages/wlogo.png')
      local color_bright = Color(236, 113, 71)
      local color_dark = Color(43, 49, 54)
      local color_other = Color(150, 150, 150)
      local color_line = Color(77, 75, 77)
      
      function ENT:Draw()
        self:DrawModel()

        if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then return end

        local ang = LocalPlayer():EyeAngles()
        local pos = self:GetPos() + Vector(0,0,self:OBBMaxs().z + 15)

        ang:RotateAroundAxis(ang:Forward(), 90)
        ang:RotateAroundAxis(ang:Right(), 90)

        cam.Start3D2D(pos, Angle(ang.x, ang.y, ang.z), 0.15)
          draw.RoundedBox(0,-130,10,260,60, color_bright)
          draw.RoundedBox( 0,-130,10,260,28, color_dark )
          surface.SetDrawColor( color_other )
          surface.SetMaterial( logo ) 
          surface.DrawTexturedRect( -125, 13, 23, 23 )  
          draw.SimpleText( " WayZer's Role Play", "Trebuchet24", -103, 23, color_white, 0, 1 )
          draw.SimpleText( 'Телефон', "Trebuchet24", -120, 51, color_white, 0, 1 )
          surface.SetDrawColor( color_line )
          surface.DrawOutlinedRect( -130,10,260,60 )
        cam.End3D2D()
      end
end
--addons/ent_drugz/lua/effects/durgz_weed_smoke/init.lua:
local function randn(x)
	return math.Rand(-x, x);
end
function EFFECT:Init(data)
	local e = ParticleEmitter( data:GetOrigin() );
		for i=1, 10 do
			--declare variablez
			local smokesize = 1;
			local pos = Vector(randn(1), randn(1), randn(smokesize) + 60);
			local p = e:Add( "particle/particle_smokegrenade", data:GetOrigin() + pos );
			if (p) then
				local gravsideways = randn(0.1);
				local shade = math.random(220,240);
				--set the stuff
				p:SetVelocity(VectorRand() * math.Rand(2000,2300));
				
				p:SetLifeTime(0);
				p:SetDieTime(math.Rand(3,4));
				
				p:SetColor(shade,shade,shade);
				p:SetStartAlpha(math.Rand(160,180));
				p:SetEndAlpha(0);
				
				p:SetStartSize(math.Rand(20,25));
				p:SetEndSize(math.Rand(10, 15));
				
				p:SetRoll(math.Rand(-180, 180));
				p:SetRollDelta(math.Rand(-0.2,0.2));
				
				p:SetAirResistance(math.Rand(520,620));
				p:SetGravity(   Vector( gravsideways, gravsideways, math.Rand(-60, -80) )    );

				p:SetCollide( true );
				p:SetBounce( 0.42 );

				p:SetLighting(1);
			end
		end
		
	e:Finish()
	
end

function EFFECT:Think( )
	return false
end
function EFFECT:Render()
end


--addons/module_itemstore/lua/itemstore/items/food.lua:
ITEM.Name = itemstore.Translate( "food_name" )
ITEM.Description = itemstore.Translate( "microwavefood_desc" )
ITEM.Model = "models/props_junk/garbage_takeoutcarton001a.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Consumables
ITEM.Base = "base_darkrp"
ITEM.Stackable = true

function ITEM:Use( pl )
	pl:SetNetVar( "Energy", 100 )
	umsg.Start( "AteFoodIcon", pl ) umsg.End()

	return self:TakeOne()
end

function ITEM:SaveData( ent )
	self:SetData( "Owner", ent:Getowning_ent() )
end

function ITEM:LoadData( ent )
	ent:Setowning_ent( self:GetData( "Owner" ) )
end
--addons/module_itemstore/lua/itemstore/items/lucid_choc_chocolate.lua:
ITEM.Name = 'Плитка шоколада'
ITEM.Description = 'Выглядит очень вкусно. Скупщику наверняка она понравится'
ITEM.Model = 'models/hunter/plates/plate05x075.mdl'
ITEM.Color = Color(85,37,37,255)
ITEM.Base = 'base_entity'

ITEM:CreateMutator('Price')
ITEM.Price = 22500
--addons/module_itemstore/lua/itemstore/items/spawned_shipment.lua:
ITEM.Name = itemstore.Translate( "shipment_name" )
ITEM.Description = itemstore.Translate( "shipment_desc" )
ITEM.Model = "models/Items/item_item_crate.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Shipments
ITEM.Stackable = true
ITEM.DropStack = true
ITEM.Base = "base_darkrp"

-- Because all of you feel the need to fuck with your shipments on a daily basis.

function ITEM:Initialize()
	if not SERVER then return end
	if not self:GetData( "Class" ) then return end

	local shipment = CustomShipments[ self:GetData( "Contents" ) ]
	if shipment and shipment.entity == self:GetData( "class" ) then return end

	for k, v in ipairs( CustomShipments ) do
		if v.entity == self:GetData( "Class" ) then
			self:SetData( "Contents", k )
			return
		end
	end
end

local multiplier = 0.35 -- Процент от цены за который предметы будет скупать барыга

function ITEM:GetPrice()
	local ship = CustomShipments[self:GetData("Contents")]
	if not ship then return end

	local cost = ship.getPrice and ship.getPrice(ply, ship.price)/ship.amount or ship.price/ship.amount

	return math.floor((cost or 0) * multiplier)
end

function ITEM:GetDescription()
	local shipment = CustomShipments[ self:GetData( "Contents" ) ]

	local str = itemstore.Translate( "shipment_invalid" )
	if shipment then
		str = string.format( self.Description, shipment.name )
	end

	return self:GetData( "Description", str )
end

function ITEM:CanMerge( item )
	return self.Stackable and self:GetClass() == item:GetClass() and
		self:GetData( "Contents" ) == item:GetData( "Contents" ) and
		self:GetMaxStack() >= ( item:GetAmount() + self:GetAmount() )
end

function ITEM:SaveData( ent )
	self:SetData( "Owner", ent:Getowning_ent() )
	self:SetData( "Contents", ent:Getcontents() )
	self:SetData( "Amount", ent:Getcount() )

	self:SetData( "Class", CustomShipments[ ent:Getcontents() ].entity )

	self:SetData( "Ammo", ent.ammoadd )
	self:SetData( "Clip1", ent.clip1 )
	self:SetData( "Clip2", ent.clip2 )
end

function ITEM:CanPickup( pl, ent )
	return self:GetMaxStack() >= ent:Getcount() and not ent.locked
end

function ITEM:Pickup( pl, con, slot, ent )
	timer.Destroy( ent:EntIndex() .. "crate" )
	--ent.locked = false
	ent.sparking = false
end

-- 76561198136465722

function ITEM:LoadData( ent )
	ent:Setcontents( self:GetData( "Contents" ) )
	ent:Setcount( self:GetData( "Amount" ) )
	ent:Setowning_ent( self:GetData( "Owner" ) )

	ent.ammoadd = self:GetData( "Ammo" )
	ent.clip1 = self:GetData( "Clip1" )
	ent.clip2 = self:GetData( "Clip2" )
end

function ITEM:Use( pl )
	if not CustomShipments[ self:GetData( "Contents" ) ] then return end
	if pl:isArrested() then return end

	local class = CustomShipments[ self:GetData( "Contents" ) ].entity

	local wep_table = weapons.Get( class )
	local ammo, ammo_type

	if wep_table then
		ammo_type = wep_table.Primary.Ammo

		if ammo_type then
			ammo = pl:GetAmmoCount( ammo_type )
		end
	end

	local wep = pl:Give( class )

	if ammo and ammo_type then
		pl:SetAmmo( ammo, ammo_type )
	end

	local weapon_exists = false

	if not IsValid( wep ) then
		wep = pl:GetWeapon( class )
		weapon_exists = IsValid( wep )
	end

	if IsValid( wep ) and wep:IsWeapon() then
		if self:GetData( "Clip1" ) then
			if weapon_exists then
				pl:GiveAmmo( self:GetData( "Clip1" ), wep:GetPrimaryAmmoType() )
			else
				wep:SetClip1( self:GetData( "Clip1" ) )
			end
		end

		if self:GetData( "Clip2" ) then
			if weapon_exists then
				pl:GiveAmmo( self:GetData( "Clip2" ), wep:GetSecondaryAmmoType() )
			else
				wep:SetClip2( self:GetData( "Clip2" ) )
			end
		end

		if self:GetData( "Ammo" ) then
			pl:GiveAmmo( self:GetData( "Ammo" ), wep:GetPrimaryAmmoType() )
		elseif wep.Primary and wep.Primary.DefaultClip then
			pl:GiveAmmo( wep.Primary.DefaultClip, wep:GetPrimaryAmmoType() )
		end
	end

	return self:TakeOne()
end

--addons/module_itemstore/lua/itemstore/crafts.lua:
itemstore.crafts = itemstore.crafts or {}
itemstore.crafts.list = itemstore.crafts.list or {}

--[[
    table containers
    table items:
        string item,
        int amount,
        function check(item)
    function callback (ply, item)
    string name
    string menu_name
    string desc
    string model
]]
function itemstore.crafts.Register(id, class, data)
	if not itemstore.items.Exists(class) then return end
	
    data.id = id
    data.class = class
    data.item = itemstore.Item(class)
    itemstore.crafts.list[id] = data
end

function itemstore.crafts.Get(id)
    return itemstore.crafts.list[id]
end

function itemstore.crafts.GetItemAmount(con, itemtable)
    local amount = 0

    for _, item in pairs(con:GetItems()) do
        if item:GetClass() == itemtable.item then
            if itemtable.check and itemtable.check(item) == false then continue end
            
            amount = amount + item:GetAmount()
        end
    end

    return amount
end

function itemstore.crafts.CanCraft(ply, con, craft)
    if craft.containers and not table.HasValue(craft.containers, con:GetName()) then return false, 'Это нельзя скрафтить здесь' end
    if con.RestrictCraft then return false, 'Это нельзя скрафтить здесь' end

    if SERVER and con:RunCallbacks('craft', ply, craft) == false then return false, 'Это нельзя скрафтить здесь' end

    local res, err = hook.Run('ItemStoreCanCraft', ply, con, craft)
    if res == false then return res, err end

    local res, err = true, 'Ошибка'
    for _, v in ipairs(craft.items) do
        local amount = itemstore.crafts.GetItemAmount(con, v)

        if amount < v.amount then
            res = false
            err = ('Недостаточно %q (%s/%s)'):format(v.name or itemstore.Item(v.item):GetName(), amount, v.amount)
            break
        end
    end

    if res == false then return false, err end

    return true
end

hook.Add('ItemStoreCanCraft', 'restrict_lazy', function(ply, con, craft)
	if SERVER and con ~= ply.Inventory then return false, 'Это нельзя скрафтить здесь' end
end)

function itemstore.crafts.ParseAvailableCrafts(ply, con)
    local a = {}

    for id, craft in pairs(itemstore.crafts.list) do
        local err = itemstore.crafts.CanCraft(ply, con, craft)
        if err == false then continue end

        table.insert(a, craft)
    end

    return a
end

function itemstore.crafts.GetProgress(con, craft)
    local need = 0
    local has = 0

    for _, v in ipairs(craft.items) do
        need = need + v.amount
        has = has + math.Clamp(itemstore.crafts.GetItemAmount(con, v), 0, v.amount)
    end

    if need == 0 then return 0 end
    return has/need
end

-- МЕТАЛЛОЛОМ
local scrap_items = {
	['Банка'] = 2,
	['Неизвестное устройство'] = 1,
	['Сервер'] = 1,
	['Поварешка'] = 2,
	['Тесак'] = 2,
	['Кастрюля'] = 1,
}

i = 1
for name, amount in pairs(scrap_items) do
	itemstore.crafts.Register('scrap_'..i, 'craft_scrap', {
		menu_name = name,
		time = 5,
		items = {
			{
				item = 'hobo_trash',
				name = name,
				amount = amount,
				check = function(item)
					return item:GetData('Name') == name
				end,
			},
		},
	})
	i = i + 1
end


-- ЭЛЕКТРОНИКА
local electronics_items = {
	['JBL Flip 6'] = 1,
	['Неизвестное устройство'] = 1,
	['Сервер'] = 1,
	['Sony HDC-5500'] = 1,
	['Xbox 360 White Edition'] = 1,
	['Клавиатура Razer'] = 1,
	['Настенные часы'] = 1,
}

i = 1
for name, amount in pairs(electronics_items) do
	itemstore.crafts.Register('electronics_'..i, 'craft_electronics', {
		menu_name = name,
		time = 5,
		items = {
			{
				item = 'hobo_trash',
				name = name,
				amount = amount,
				check = function(item)
					return item:GetData('Name') == name
				end,
			},
		},
	})
	i = i + 1
end

-- ПРОЧЕЕ

itemstore.crafts.Register('fake_license', 'fake_license', {
	time = 10,
	items = {
		{
			item = 'hobo_trash',
			name = 'Блокнот',
			amount = 1,
			check = function(item)
				return item:GetData('Name') == 'Блокнот'
			end,
		},
	}
})

itemstore.crafts.Register('durgz_fireammo', 'durgz_fireammo', {
	model = 'models/props_junk/garbage_glassbottle003a.mdl',
	time = 10,
	items = {
		{
			item = 'hobo_trash',
			name = 'Канистра с бензином',
			amount = 1,
			check = function(item)
				return item:GetData('Name') == 'Канистра с бензином'
			end,
		},
		{
			item = 'hobo_trash',
			name = 'Пустая бутылка',
			amount = 1,
			check = function(item)
				return item:GetData('Name') == 'Пустая бутылка'
			end,
		},
	},
	callback = function(ply, item)
		item:SetData('Model', 'models/jaanus/aspbtl.mdl')
	end,
})

-- ОРУЖИЕ

itemstore.crafts.Register('wrp_weapon_mp7', 'spawned_weapon', {
	name = 'HK MP7',
	model = 'models/weapons/w_smg1.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'HK MP5',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_mp5'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 3,
		},
        {
			item = 'craft_electronics',
			name = 'Электроника',
			amount = 2,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_mp7')
		item:SetData('Model', 'models/weapons/w_smg1.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_grizzly', 'spawned_weapon', {
	name = 'LAR Grizzly .50',
	model = 'models/weapons/sniper/w_sniper.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'AWP',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_awp'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 3,
		},
        {
			item = 'craft_electronics',
			name = 'Электроника',
			amount = 2,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_grizzly')
		item:SetData('Model', 'models/weapons/sniper/w_sniper.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_spas12', 'spawned_weapon', {
	name = 'Franchi SPAS12',
	model = 'models/weapons/w_shotgun.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'XM1014',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_autoshotgun'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 3,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_spas12')
		item:SetData('Model', 'models/weapons/w_shotgun.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_ar2', 'spawned_weapon', {
	name = 'S-LAR AR2',
	model = 'models/weapons/oicw/w_oicw.mdl',
	time = 15,
	items = { 
        {
			item = 'spawned_weapon',
			name = 'AK-47',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_ak47'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 3,
		},
        {
			item = 'craft_electronics',
			name = 'Электроника',
			amount = 1,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_ar2')
		item:SetData('Model', 'models/weapons/oicw/w_oicw.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_dbshotgun', 'spawned_weapon', {
	name = 'Двуствольный дробовик',
	model = 'models/tak/f3/w_double-barrel_shotgun.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'Benelli M3 Super 90',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_pumpshotgun'
            end,
		},
        {
			item = 'spawned_weapon',
			name = 'Труба',
			amount = 2,
            check = function(item)
                return item:GetData('Class') == 'weapon_hl2pipe'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 3,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_dbshotgun')
		item:SetData('Model', 'models/tak/f3/w_double-barrel_shotgun.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_huntrifle', 'spawned_weapon', {
	name = 'Охотничья винтовка',
	model = 'models/tak/f3/w_double-barrel_shotgun.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'Steyr Scout',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_scout'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 4,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_huntrifle')
		item:SetData('Model', 'models/tak/f3/w_double-barrel_shotgun.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_nailgun', 'spawned_weapon', {
	name = 'Гвоздомёт',
	model = 'models/tak/f3/w_10mm_smg.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'FN Five-seveN',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_fiveseven'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 2,
		},
        {
			item = 'craft_electronics',
			name = 'Электроника',
			amount = 1,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_nailgun')
		item:SetData('Model', 'models/tak/f3/w_10mm_smg.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_csg', 'spawned_weapon', {
	name = 'CSG-12 Drum',
	model = 'models/tak/f3/w_combat_shotgun.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'XM1014',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_autoshotgun'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 3,
		},
        {
			item = 'spawned_weapon',
			name = 'Сковорода',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'weapon_hl2pan'
            end,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_csg')
		item:SetData('Model', 'models/tak/f3/w_combat_shotgun.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_fal', 'spawned_weapon', {
	name = 'FN Fal',
	model = 'models/tak/f3/w_r91.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'IMI Galil',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_galil'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 3,
		},
        {
			item = 'craft_electronics',
			name = 'Электроника',
			amount = 1,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_fal')
		item:SetData('Model', 'models/tak/f3/w_r91.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_python', 'spawned_weapon', {
	name = 'Colt Python',
	model = 'models/tak/f3/w_44magnum.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'Desert Eagle',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_deagle'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 2,
		},
        {
			item = 'craft_electronics',
			name = 'Электроника',
			amount = 2,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_python')
		item:SetData('Model', 'models/tak/f3/w_44magnum.mdl')
	end,
})


itemstore.crafts.Register('wrp_weapon_thompson', 'spawned_weapon', {
	name = 'M1A1 Thompson',
	model = 'models/weapons/w_thompson.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'HK UMP',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_ump45'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 2,
		},
        {
			item = 'spawned_weapon',
			name = 'Топор',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'weapon_hl2axe'
            end,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_thompson')
		item:SetData('Model', 'models/weapons/w_thompson.mdl')
	end,
})

itemstore.crafts.Register('wrp_weapon_hk21', 'spawned_weapon', {
	name = 'HK21',
	model = 'models/weapons/w_gr9.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'M249 SAW',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_para'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 4,
		},
        {
			item = 'craft_electronics',
			name = 'Электроника',
			amount = 2,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_hk21')
		item:SetData('Model', 'models/weapons/w_gr9.mdl')
	end,
})


itemstore.crafts.Register('wrp_weapon_mauser', 'spawned_weapon', {
	name = 'C96 Mauser',
	model = 'models/tak/f3/w_mauser.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'Glock 17',
			amount = 1,
            check = function(item)
                return item:GetData('Class') == 'ptp_cs_glock'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 2,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'wrp_weapon_mauser')
		item:SetData('Model', 'models/tak/f3/w_mauser.mdl')
	end,
})


itemstore.crafts.Register('weapon_hl2katana', 'spawned_weapon', {
	name = 'Катана',
	model = 'models/weapons/w_hiltless.mdl',
	time = 15,
	items = {
        {
			item = 'spawned_weapon',
			name = 'Нож',
			amount = 2,
            check = function(item)
                return item:GetData('Class') == 'csgo_bayonet'
            end,
		},
        {
			item = 'craft_scrap',
			name = 'Металлолом',
			amount = 4,
		},
	},
	callback = function(ply, item)
		item:SetData('Class', 'weapon_hl2katana')
		item:SetData('Model', 'models/weapons/w_hiltless.mdl')
	end,
})
--addons/module_itemstore/lua/itemstore/containers.lua:
itemstore.containers = {}
itemstore.containers.Active = {}

local Container = {}

AccessorFunc( Container, "Owner", "Owner" )
AccessorFunc( Container, "Name", "Name" )
AccessorFunc( Container, "Suppressed", "Suppressed", FORCE_BOOL )
AccessorFunc( Container, "Width", "Width", FORCE_NUMBER )
AccessorFunc( Container, "Height", "Height", FORCE_NUMBER )
AccessorFunc( Container, "Pages", "Pages", FORCE_NUMBER )

function Container:GetID()
	return self.ID
end

function Container:IsValid()
	return self:GetID() and itemstore.containers.Active[ self:GetID() ] == self
end

function Container:Remove()
	itemstore.containers.Remove( self:GetID() )
end

function Container:GetPageSize()
	return self:GetWidth() * self:GetHeight()
end

function Container:GetPageFromSlot( slot )
	return math.ceil( slot / self:GetPageSize() )
end

function Container:GetSize()
	return self:GetPageSize() * self:GetPages()
end

function Container:SetSize( w, h, pages )
	self:SetWidth( w )
	self:SetHeight( h )
	self:SetPages( pages )

	self:QueueSync()
end

function Container:CoordsToSlot( x, y, p )
	return ( ( p - 1 ) * self:GetPageSize() ) + ( ( y - 1 ) * self:GetWidth() + x )
end

function Container:GetItems()
	return self.Items
end

function Container:GetItem( slot )
	return self.Items[ slot ]
end

function Container:SetItem( slot, item )
	if item and not item:IsValid() then return end

	slot = math.floor( slot )

	if slot >= 1 and slot <= self:GetSize() then
		if self:RunCallbacks( "set", slot, item ) == false then return end

		self.Items[ slot ] = item

		if item then
			item.Container = self
			item.Slot = slot
		end

		if SERVER then self:QueueSync() end
	end
end

function Container:FirstEmptySlot()
	for i = 1, self:GetSize() do
		if not self:GetItem( i ) then
			return i
		end
	end

	return false
end

function Container:CanFit( item )
	for i = 1, self:GetSize() do
		local merge_item = self:GetItem( i )

		if merge_item and merge_item:CanMerge( item ) then
			return true
		end
	end

	return self:FirstEmptySlot() ~= false
end

function Container:AddItem( item, dontmerge )
	if not dontmerge then
		for i = 1, self:GetSize() do
			local merge_item = self:GetItem( i )

			if merge_item and merge_item:CanMerge( item ) then
				merge_item:Merge( item )
				self:QueueSync()

				return i, merge_item
			end
		end
	end

	local slot = self:FirstEmptySlot()

	if slot then
		self:SetItem( slot, item )
		return slot
	end

	return false
end

function Container:HasItem( item_class )
	for k, v in pairs( self:GetItems() ) do
		if v:GetClass() == item_class then
			return k
		end
	end

	return false
end

function Container:CountItems( item_class )
	local amount = 0

	for _, item in pairs( self:GetItems() ) do
		if item:GetClass() == item_class then
			amount = amount + item:GetAmount()
		end
	end

	return amount
end

-- 76561198136465722

function Container:TakeItems( item_class, amount )
	local amount_taken = 0

	self:Suppress( function()
		for k, v in pairs( self:GetItems() ) do
			if v:GetClass() == item_class then
				local amount_to_take = v:GetAmount()
				amount_to_take = math.Clamp( amount_to_take, 0, amount )

				v:SetAmount( v:GetAmount() - amount_to_take )

				if v:GetAmount() <= 0 then
					self:SetItem( k, nil )
				end

				amount_taken = amount_taken + amount_to_take
				amount = amount - amount_to_take
			end
		end

		return true
	end )

	return amount_taken
end

function Container:GetDefaultPermissions()
	return self.DefaultPermissions
end

function Container:GetPermissions( pl )
	return self.Permissions[ pl ] or self:GetDefaultPermissions()
end

function Container:SetDefaultPermissions( read, write )
	self.DefaultPermissions = { Read = read, Write = write }
end

function Container:SetPermissions( pl, read, write )
	self.Permissions[ pl ] = { Read = read, Write = write }
end

function Container:CanRead( pl, ... )
	local res = hook.Call( "ItemStoreCanRead", nil, self, pl, ... )
	if res ~= nil then
		return res
	end

	if self.Permissions[ pl ] then
		return self.Permissions[ pl ].Read
	end

	local res = self:RunCallbacks( "read", pl, ... )
	if res ~= nil then
		return res
	end

	return self.DefaultPermissions.Read
end

function Container:CanWrite( pl, action, ... )
	local res = hook.Call( "ItemStoreCanWrite", nil, self, pl, action, ... )
	if res ~= nil then
		return res
	end

	if self.Permissions[ pl ] then
		return self.Permissions[ pl ].Write
	end

	local res = self:RunCallbacks( "write", pl, action, ... )
	if res ~= nil then
		return res
	end

	return self.DefaultPermissions.Write
end

function Container:AddCallback( name, func )
	if not self.Callbacks[ name ] then
		self.Callbacks[ name ] = {}
	end

	return table.insert( self.Callbacks[ name ], func )
end

function Container:RemoveCallback( name, id )
	if self.Callbacks[ name ] then
		self.Callbacks[ name ][ id ] = nil
	end
end

function Container:RunCallbacks( name, ... )
	if self.Callbacks[ name ] then
		for _, func in pairs( self.Callbacks[ name ] ) do
			local res = func( self, ... )

			if res ~= nil then
				return res
			end
		end
	end
end

function Container:Craft(craft_id)
	net.Start('ItemStoreCraft')
	net.WriteUInt(self:GetID(), 32)
	net.WriteString(craft_id)
	net.SendToServer()
end

function Container:GetSyncTargets()
	players = {}

	for _, pl in player.Iterator() do
		if self:CanRead( pl ) then
			table.insert( players, pl )
		end
	end

	return players
end

function Container:Suppress( func )
	self:SetSuppressed( true )
		local sync = func()
	self:SetSuppressed( false )

	if sync then self:QueueSync() end
end

function Container:QueueSync()
	self.ShouldSync = true
end

function Container:Sync( pl )
	if SERVER then itemstore.containers.Sync( self:GetID(), pl ) end
end

function itemstore.Container( w, h, pages, dontnetwork, name )
	local con = {
		Name = name,
		ShouldSync = false,

		Width = w or 4,
		Height = h or 4,
		Pages = pages or 1,

		Owner = nil,
		Callbacks = {},
		Permissions = {},
		DefaultPermissions = { Read = false, Write = false },

		Items = {}
	}

	setmetatable( con, { __index = Container } )

	if not dontnetwork then
		con.ID = table.insert( itemstore.containers.Active, con )
		con:Sync()
	end

	return con
end

function itemstore.containers.Get( id )
	return itemstore.containers.Active[ id ]
end

function itemstore.containers.Remove( id )
	itemstore.containers.Active[ id ] = nil
end

if SERVER then
	AddCSLuaFile()

	util.AddNetworkString( "ItemStoreSync" )
	function itemstore.containers.Sync( id, pl )
		local con = itemstore.containers.Active[ id ]

		if not con then return end
		if con:GetSuppressed() then return end

		-- No longer using WriteTable! Net usage has been cut to less than half
		-- This is still pretty damn unoptimized though
		-- Ideally we send only the item that's changing...
		-- But unfortunately it's a bit more complicated than that due to
		-- an item's ability to modify other slots in a container
		net.Start( "ItemStoreSync" )
			net.WriteUInt( con:GetID(), 32 )

			net.WriteUInt( con:GetWidth(), 8 )
			net.WriteUInt( con:GetHeight(), 8 )
			net.WriteUInt( con:GetPages(), 8 )

			net.WriteUInt( table.Count( con.Items ), 8 )

			for k, v in pairs( con.Items ) do
				net.WriteUInt( k, 8 )

				local id = util.NetworkStringToID( v.Class )

				if id == 0 then
					if v.Class then
						error( string.format( "[ItemStore] Tried to send data for unnetworked item %s", v.Class ) )
					else
						error( "[ItemStore] Tried to send data for a classless item" )
					end
				end

				net.WriteUInt( id, 16 )
				v:WriteNetworkData()
			end
		net.Send( pl or con:GetSyncTargets() )
	end

	hook.Add( "Tick", "ItemStoreSyncContainers", function()
		for k, v in pairs( itemstore.containers.Active ) do
			if v.ShouldSync then
				v.ShouldSync = false
				v:Sync()
			end
		end
	end )
else
	itemstore.containers.Panels = {}

	function itemstore.containers.UpdatePanels( id )
		for k, v in pairs( itemstore.containers.Panels ) do
			if IsValid( v ) then
				if v:GetContainerID() == id then
					v:Refresh()
					hook.Run("ItemStoreSync", id, v)
				end
			else
				itemstore.containers.Panels[ k ] = nil
			end
		end
	end

	net.Receive( "ItemStoreSync", function()
		local id = net.ReadUInt( 32 )
		local w, h = net.ReadUInt( 8 ), net.ReadUInt( 8 )
		local pages = net.ReadUInt( 8 )

		local con = itemstore.Container( w, h, pages, true )

		for i = 1, net.ReadUInt( 8 ) do
			local slot = net.ReadUInt( 8 )

			local class = util.NetworkIDToString( net.ReadUInt( 16 ) )
			local item = itemstore.Item( class )

			item:ReadNetworkData()

			con:SetItem( slot, item )
		end

		con.ID = id
		itemstore.containers.Active[ id ] = con

		itemstore.containers.UpdatePanels( id )
	end )
end

--addons/module_itemstore/lua/itemstore/skins/flat.lua:
local SKIN = {}

SKIN.GradientUp = Material( "gui/gradient_up" )
SKIN.GradientDown = Material( "gui/gradient_down" )
SKIN.Blur = Material( "pp/blurscreen" )

function SKIN:PaintFrame( panel, w, h )

--	local x, y = panel:LocalToScreen( 0, 0 )

--	surface.SetDrawColor( 255, 255, 255 )
--	surface.SetMaterial( self.Blur )
--	surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )

--	surface.SetDrawColor( C )
	draw.RoundedBox( 0, 0, 22, w, h - 22, Color( 30, 30, 30, 200 ))
	draw.RoundedBox( 0, 0, 0, w, 22, Color(47, 52, 57))
	
	panel.lblTitle:SetColor(color_white)
end

function SKIN:PaintButton( panel, w, h )
	surface.SetDrawColor( Color( 200, 200, 200 ) )
	surface.DrawRect( 0, 0, w, h )

	if not panel.Disabled then
		surface.SetMaterial( panel.Depressed and self.GradientUp or self.GradientDown )
		surface.SetDrawColor( panel.Hovered and Color( 240, 240, 240 ) or Color( 230, 230, 230 ) )
		surface.DrawTexturedRect( 0, 0, w, h )
	end

	surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
	surface.DrawOutlinedRect( 0, 0, w, h )
end

function SKIN:PaintTab( panel, w, h )
	if panel:IsActive() then
		draw.RoundedBoxEx( 6, 2, 0, w - 5, h - 8, Color( 0, 0, 0, 200 ),
			true, true, false, false )
	else
		draw.RoundedBoxEx( 6, 2, 0, w - 5, h, Color( 0, 0, 0, 150 ),
			true, true, false, false )
	end
end

function SKIN:PaintPropertySheet( panel, w, h )
	surface.SetDrawColor( Color( 0, 0, 0, 200 ) )
	surface.DrawRect( 0, 20, w, h )
end

function SKIN:PaintCategoryList( panel, w, h )
end

function SKIN:PaintCollapsibleCategory( panel, w, h )
	surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
	surface.DrawRect( 0, 0, w, 20 )

	surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
	surface.DrawRect( 0, 0, w, h )
end

function SKIN:PaintWindowCloseButton( panel, w, h )
	local col = Color( 0, 0, 0, 50 )

	if not panel:GetDisabled() and panel.Hovered then
		if panel:IsDown() then
			col = Color( 192, 57, 43 )
		else
			col = Color( 231, 76, 60 )
		end
	end

	draw.RoundedBoxEx( 6, 0, 2, w, 18, col, true, true, true, true )
	draw.SimpleText( "r", "Marlett", w / 2, 11, color_white,
		TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

function SKIN:PaintWindowMaximizeButton( panel, w, h )
	if panel:GetDisabled() then return end

	local col = Color( 0, 0, 0, 50 )

	if panel.Hovered then
		if panel:IsDown() then
			col = Color( 41, 128, 185 )
		else
			col = Color( 52, 152, 219 )
		end
	end

	draw.RoundedBoxEx( 6, 0, 2, w, 18, col, false, false, false, false )
	draw.SimpleText( "1", "Marlett", w / 2, 11, color_white,
		TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

function SKIN:PaintWindowMinimizeButton( panel, w, h )
	if true then return end

	local col = Color( 0, 0, 0, 50 )

	if panel.Hovered then
		if panel:IsDown() then
			col = Color( 41, 128, 185 )
		else
			col = Color( 52, 152, 219 )
		end
	end

	draw.RoundedBoxEx( 6, 0, 2, w, 18, col, true, false, true, false )
	draw.SimpleText( "0", "Marlett", w / 2, 11, color_white,
		TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

derma.DefineSkin( "itemstore", "Flat skin for ItemStore", SKIN )

--addons/module_itemstore/lua/itemstore/vgui/craft.lua:
surface.CreateFont('crafts.title', {
	font = 'Roboto',
	size = 22,
	weight = 500,
	extended = true,
})

surface.CreateFont('crafts.items', {
	font = 'Roboto',
	size = 16,
	weight = 500,
	extended = true,
})

local color_green = Color(0,200,0)
local color_background = Color(0, 60, 120)
local color_grid = Color(120, 120, 120, 120)
local grip_wide = 20

local PANEL = {}

function PANEL:Init()
    self.name = vgui.Create('DLabel', self)
    self.name:SetFont('crafts.title')
    self.name:SetColor(color_white)
    self.name:SetAutoStretchVertical(true)

    self.desc = vgui.Create('DLabel', self)
    self.desc:SetFont('crafts.title')
    self.desc:SetColor(color_white)
    self.desc:SetWrap(true)
    self.desc:SetAutoStretchVertical(true)
    self.desc:SetVisible(false)

    self.model = vgui.Create('DModelPanel', self)
    self.model:Dock(FILL)
    --self.model:SetFOV(90)
    --self.model.LayoutEntity = wlib.func.blank

    self.button = vgui.Create('DButton', self)
    self.button:SetText('Изготовить')
    self.button:SetFont('crafts.items')
    self.button:SetSize(120, 30)
    self.button:SetEnabled(false)
    self.button:SetTextColor(color_white)
    self.button.DoClick = function()
        self:GetContainer():Craft(self:GetCraft().id)
    end
    self.button.Paint = function(s,w,h)
        draw.Grid(0,0,w,h,w-1,h-1,s:IsEnabled() and color_white or color_grid)
    end
end

wlib.accessor(PANEL, 'cid', 'ContainerID')
wlib.accessor(PANEL, 'craft', 'Craft')
wlib.accessor(PANEL, 'itemsText', 'ItemsText')
function PANEL:GetContainer()
    return itemstore.containers.Get(self:GetContainerID())
end

function PANEL:SetCraft(craft)
    self.craft = craft
    local con = self:GetContainer()

    self.name:SetText(craft.name or craft.item:GetName() or '')
    self.desc:SetText(craft.desc or '')

    self.model:SetModel(craft.model or craft.item:GetModel())
    --self.model:SetColor(craft.item:GetColor() or color_white)
    local ent = self.model:GetEntity()
    ent:SetMaterial('models/wireframe')

    local min, max = ent:GetRenderBounds()
    self.model:SetCamPos(Vector(0.85, 0.85, 0.85) * min:Distance(max))
    self.model:SetLookAt(( min + max ) / 2)

    local itemsText = {}

    for _, v in ipairs(craft.items) do
        local curcount = itemstore.crafts.GetItemAmount(con, v)
        itemsText[#itemsText+1] = (v.name or itemstore.Item(v.item):GetName())..' ('..curcount..'/'..v.amount..')'
    end

    self:SetItemsText(table.concat(itemsText, '\n'))

    self.button:SetEnabled(itemstore.crafts.CanCraft(LocalPlayer(), con, craft))
end

function PANEL:PerformLayout(w,h)
    local gw, gh = w-w%grip_wide, h-h%grip_wide

    self.name:SetPos((w-gw)/2+4, (h-gh)/2+4)
    self.desc:SetPos(self.name:GetX(), self.name:GetY()+36)

    self.name:SetWide(w)
    self.desc:SetWide(w)
    
    --self.button:SetPos(w/2-self.button:GetWide()/2, h-self.button:GetTall())
    self.button:SetPos((w-gw)/2+4, gh-self.button:GetTall())
end

local blur = wlib.Circles.New(CIRCLE_FILLED, 60, ScrW()/2, ScrH()/2, 3, 10)
blur:SetMaterial(true)
blur:SetColor(Color(43,49,54, 245))

local progress = wlib.Circles.New(CIRCLE_FILLED, 60, ScrW()/2, ScrH()/2)
progress:SetMaterial(true)
progress:SetColor(Color(236,113,71))
progress:SetStartAngle(-90)

function PANEL:Paint(w,h)
    draw.RoundedBox(0,0,0,w,h,color_background)

    local gw, gh = w-w%grip_wide, h-h%grip_wide
    draw.Grid((w-gw)/2, (h-gh)/2, gw, gh, grip_wide, grip_wide, color_grid)

    if self:GetItemsText() then
        draw.SimpleText('Компоненты:', 'crafts.title', w-(w-gw)/2-4, (h-gh)/2+4, color_white, TEXT_ALIGN_RIGHT)
        draw.DrawText(self:GetItemsText(), 'crafts.items', w-(w-gw)/2-4, (h-gh)/2+4+24, color_white, TEXT_ALIGN_RIGHT)
    end

    local crafting = LocalPlayer():GetDelay('craft')
    if crafting then
        local elapsed = CurTime()-crafting.start
        blur:SetPos(w/2, h/2)
        blur()

        progress:SetPos(w/2, h/2)
        progress:SetEndAngle(360*(elapsed/crafting.duration) - 90)
        progress()
    end
end

function PANEL:Think()
    local crafting = LocalPlayer():GetDelay('craft')
    
    self.model:SetVisible(not crafting)
    self.button:SetEnabled(not crafting)
end

vgui.Register('ItemStoreCraft', PANEL, 'DPanel')
--addons/module_itemstore/lua/itemstore/vgui/traderequest.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSkin( "itemstore" )
	self:SetTitle( itemstore.Translate( "trade_request" ) )

	self:ShowCloseButton( false )

	self.Label = vgui.Create( "DLabel", self )

	self.Accept = vgui.Create( "DButton", self )
	self.Accept:SetText( itemstore.Translate( "accept" ) )

	function self.Accept.DoClick()
		itemstore.trading.Panel = vgui.Create( "ItemStoreTrade" )
		itemstore.trading.Panel:Refresh()
		itemstore.trading.Panel:Center()
		itemstore.trading.Panel:MakePopup()

		self:Remove()
	end

	self.Deny = vgui.Create( "DButton", self )
	self.Deny:SetText( itemstore.Translate( "deny" ) )
	
	function self.Deny.DoClick()
		net.Start( "ItemStoreCloseTrade" ) net.SendToServer()
		self:Remove()
	end
end

function PANEL:Refresh()
	self.Label:SetText( itemstore.Translate( "wants_to_trade",
		LocalPlayer().Trade.Left.Player:Name() ) )
end

function PANEL:PerformLayout()
	self.BaseClass.PerformLayout( self )

	self.Label:SizeToContents()
	self.Label:SetPos( self:GetWide() / 2 - self.Label:GetWide() / 2, 30 )

	self.Accept:SetSize( 75, 30 )
	self.Accept:SetPos( self:GetWide() / 2 - self.Accept:GetWide() - 15, self:GetTall() / 2 + 10 )

	self.Deny:SetSize( 75, 30 )
	self.Deny:SetPos( self:GetWide() / 2 + 15, self:GetTall() / 2 + 10 )
end

vgui.Register( "ItemStoreTradeRequest", PANEL, "DFrame" )

--addons/module_logs/lua/plogs_hooks/bans.lua:
plogs.Register('Bans', false)

plogs.AddHook('Bans', 'FAdmin_StoreBan', function(steamid, name, time, reason, admin_name, admin_steamid)
    local admin = player.GetBySteamID(admin_steamid)
    local target = player.GetBySteamID(steamid)

    time = tonumber(time) or 0

    local copy = {
        ['Админ: Ник'] = admin_name,
        ['Админ: SteamID'] = admin_steamid,
        ['Забаненный: Ник'] = name,
        ['Забаненный: SteamID'] = steamid,
        ['Причина бана'] = reason,
    }

    time = string.FormattedTime(time * 60)
    local formattedTime
    if time.h and time.h > 0 then
        formattedTime = string.format('%s ч. %s мин.', time.h, time.m)
    else
        formattedTime = string.format('%s мин.', time.m)
    end

    local str
    if FAdmin.BANS[steamid] then
        str = ('%s перебанил %s на %s по причине %q'):format(IsValid(admin) and admin:NameID() or 'Сервер', IsValid(target) and target:NameID() or steamid, formattedTime, reason)
    else
        str = ('%s забанил %s на %s по причине %q'):format(IsValid(admin) and admin:NameID() or 'Сервер', IsValid(target) and target:NameID() or steamid, formattedTime, reason)
    end

    if IsValid(admin) and admin:IsPlayer() then
        plogs.PlayerLog(admin, 'Bans', str, copy)
    else
        plogs.Log('Bans', str, copy)
    end
end)

plogs.AddHook('Bans', 'FAdmin_UnBan', function (ply, id)
    local pl = player.GetBySteamID(id)
    
    local copy = {
        ['Админ: Ник'] = ply:IsPlayer() and ply:LogsName() or 'Сервер',
        ['Админ: SteamID'] = ply:IsPlayer() and ply:LogsSteamID() or 'Сервер',
        ['Разбаненный: Ник'] = IsValid(pl) and pl:LogsName(),
        ['Разбаненный: SteamID'] = id,
    }

    local str = string.format('%s разбанил %s', ply:IsPlayer() and ply:NameID() or 'Сервер', IsValid(pl) and pl:NameID() or id)

    if ply:IsPlayer() then
        plogs.PlayerLog(ply, 'Bans', str, copy)
    else
        plogs.Log('Bans', str, copy)
    end
end)

plogs.AddHook('Bans', 'WayBan.ban', function(ply, steamid, reason)
    local target = player.GetBySteamID(steamid)

    local copy = {
        ['Админ: Ник'] = ply:IsPlayer() and ply:LogsName() or 'Сервер',
        ['Админ: SteamID'] = ply:IsPlayer() and ply:LogsSteamID() or 'Сервер',
        ['Забаненный: SteamID'] = steamid,
        ['Причина бана'] = reason,
    }
    if IsValid(target) then
        copy['Забаненный: Ник'] = target:Name()
    end

    plogs.PlayerLog(ply, 'Bans', ('%s забанил %s навсегда по причине %q'):format(ply:IsPlayer() and ply:NameID() or 'Сервер', IsValid(target) and target:NameID() or steamid, reason), copy)
end)
--addons/module_logs/lua/plogs_hooks/connections.lua:
plogs.Register('Connections', true, Color(0,255,0))

plogs.AddHook('Connections', 'PlayerInitialSpawn', function(pl)
	plogs.PlayerLog(pl, 'Connections', pl:NameID() .. ' подключился к серверу', {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID()
	})

	if plogs.cfg.EnableMySQL then
		plogs.sql.LogIP(pl:SteamID64(), pl:IPAddress())
	end
end)

plogs.AddHook('Connections', 'PlayerDisconnected', function(pl)
	local session = string.FormattedTime(pl:GetUTimeSessionTime())
	local total = string.FormattedTime(pl:GetUTimeTotalTime())

	local sessionstr = session.h > 0 and ('%02i:%02i:%02i'):format(session.h, session.m, session.s) or ('%02i:%02i'):format(session.m, session.s)
	local totalstr = ('%02i:%02i:%02i'):format(total.h, total.m, total.s)

	local str = ('%s вышел с сервера. Онлайн за сессию: %s. Общий онлайн: %s'):format(pl:NameID(), sessionstr, totalstr)
	plogs.PlayerLog(pl, 'Connections', str, {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID()
	})
end)
--addons/module_logs/lua/plogs_hooks/hits.lua:
plogs.Register('Hits', false)

plogs.AddHook('Hits', 'HitPlaced', function(ply, type, target, price)
    local copy = {
        ['Заказчик: Ник'] = ply:LogsName(),
        ['Заказчик: SteamID'] = ply:LogsSteamID(),
        ['Жертва: Ник'] = target:LogsName(),
        ['Жертва: SteamID'] = target:LogsSteamID(),
    }

    plogs.PlayerLog(ply, 'Hits', ('%s заказал %s %s за %s'):format(ply:NameID(), hitSystem.Config.types[type].name, target:NameID(), DarkRP.formatMoney(price)), copy)
end)

plogs.AddHook('Hits', 'CompleteHit', function(hitman, target, type)
    local copy = {
        ['Наемник: Ник'] = hitman:LogsName(),
        ['Наемник: SteamID'] = hitman:LogsSteamID(),
        ['Жертва: Ник'] = target:LogsName(),
        ['Жертва: SteamID'] = target:LogsSteamID(),
    }

    plogs.PlayerLog(hitman, 'Hits', ('%s выполнил заказ на %s игрока %s'):format(hitman:NameID(), hitSystem.Config.types[type].name, target:NameID()), copy)
end)
--addons/module_logs/lua/plogs_hooks/mayor.lua:
plogs.Register('Mayor', false)

local function checkLkd(ply)
    if lockdown then return lockdown.canStart(ply) end
    return ply:isMayor()
end

local cmds = {
    ['broadcast'] = function(ply, cmd, arg)
        if not ply:isMayor() then return false end
        return ('%s написал оповещение: %q'):format(ply:NameID(), arg)
    end,
    ['lkd'] = function(ply, cmd, arg)
        if not checkLkd(ply) then return false end
        return ('%s запустил Ком. Час по причине %q'):format(ply:NameID(), arg)
    end,
    ['unlkd'] = function(ply, cmd, arg)
        if not checkLkd(ply) then return false end
        return ('%s завершил Ком. Час/ВП'):format(ply:NameID(), arg)
    end,
    --[[
    ['addlaw'] = function(ply, cmd, arg)
        if not ply:isMayor() then return false end
        return ('%s добавил закон №%s: %q'):format(ply:NameID(), #DarkRP.getLaws(), arg)
    end,
    ['removelaw'] = function(ply, cmd, arg)
        if not ply:isMayor() then return false end
        return ('%s отменил закон №%s'):format(ply:NameID(), arg)
    end,
    ]]
    ['vp'] = function(ply, cmd, arg)
        if not checkLkd(ply) then return false end
        return ('%s запустил военное положение'):format(ply:NameID())
    end,
}

plogs.AddHook('Mayor', 'onChatCommand', function(mayor, cmd, arg)
    if not cmds[cmd] then return end

    local str = cmds[cmd](mayor, cmd, arg)
    if not str then return end

    plogs.PlayerLog(mayor, 'Mayor', str, {
        ['Ник'] = IsValid(mayor) and mayor:LogsName(),
        ['SteamID'] = IsValid(mayor) and mayor:LogsSteamID(),
    })
end)

plogs.AddHook('Mayor', 'addLaw', function(mayor, num, text)
    local str = ('%s добавил закон №%s: %q'):format(mayor:NameID(), num, text)
    plogs.PlayerLog(mayor, 'Mayor', str, {
        ['Ник'] = IsValid(mayor) and mayor:LogsName(),
        ['SteamID'] = IsValid(mayor) and mayor:LogsSteamID(),
        ['Текст закона'] = text,
    })
end)

plogs.AddHook('Mayor', 'removeLaw', function(mayor, removed)
    local str = ('%s удалил законы: %s'):format(mayor:NameID(), table.concat(removed, ', '))
    plogs.PlayerLog(mayor, 'Mayor', str, {
        ['Ник'] = IsValid(mayor) and mayor:LogsName(),
        ['SteamID'] = IsValid(mayor) and mayor:LogsSteamID(),
    })
end)

plogs.AddHook('Mayor', 'resetLaws', function(mayor)
    local str = ('%s удалил все законы'):format(mayor:NameID())
    plogs.PlayerLog(mayor, 'Mayor', str, {
        ['Ник'] = IsValid(mayor) and mayor:LogsName(),
        ['SteamID'] = IsValid(mayor) and mayor:LogsSteamID(),
    })
end)

plogs.AddHook('Mayor', 'editLaw', function(mayor, num, text)
    local str = ('%s изменил закон №%s. Новый текст: %q'):format(mayor:NameID(), num, text)
    plogs.PlayerLog(mayor, 'Mayor', str, {
        ['Ник'] = IsValid(mayor) and mayor:LogsName(),
        ['SteamID'] = IsValid(mayor) and mayor:LogsSteamID(),
        ['Новый текст закона'] = text,
    })
end)