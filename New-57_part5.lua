--Stealed clientside server code by exechack.cc
--Hostname: üßø New Era - Solo Leveling | .gg/nwsl - Part 5/10 - 08/04/2025


--PATH addons/sl_util_accessory/lua/advanced_accessories/languages/sh_language_de.lua:
AAS = AAS or {}
AAS.Language = AAS.Language  or {}

AAS.Language["de"] = {
    ["cancel"] = "Abbrechen",
    ["save"] = "Speichern",
    ["name"] = "Name",
    ["model"] = "Model",
    ["itemPrice"] = "Preis",
    ["itemPos"] = "Position",
    ["itemStat"] = "Statistiken",
    ["itemJob"] = "Job Beschr√§nkung",
    ["itemName"] = "Name des Items",
    ["customCharacter"] = "PASSE DEINEN CHARAKTER AN",
    ["adminDashboard"] = "Adminstrator Dashboard",
    ["welcomeText"] = "WILLKOMMEN, WAS WILLST DU KAUFEN?",
    ["position"] = "Position",
    ["rotation"] = "Rotation",
    ["scale"] = "Skalierung",
    ["description"] = "Beschreibung des Items...",
    ["search"] = "  Suche...",
    ["sell"] = "Verkaufen",
    ["buy"] = "Kaufen",
    ["buyaccessory"] = "Kaufe das Item",
    ["sellaccessory"] = "Verkaufe das Item",
    ["sure"] = "Bist du sicher, dass du das tun willst?",
    ["activate"] = "Aktivieren",
    ["desactivate"] = "Deaktivieren",
    ["modifypos"] = "Position bearbeiten",
    ["edititem"] = "Bearbeiten",
    ["appearance"] = "Aussehen",
    ["skin"] = "Skin",
    ["desc"] = "Beschreibung",
    ["titleactivate"] = "Aktiviere / Deaktivier Item",
    ["choosecategory"] = "Kategorie w√§hlen",
    ["chooseskin"] = "Skin w√§hlen",
    ["additem"] = "Hinzuf√ºgen",
    ["adminname"] = "Der Name des Items ist nicht korrekt!",
    ["faildesc"] = "Deine Beschreibung ist nicht korrekt!",
    ["failprice"] = "Der Preis ist nicht korrekt!",
    ["choosemodel"] = "Du musst ein Model ausw√§hlen!",
    ["failcategory"] = "Du musst eine Kategorie ausw√§hlen!",
    ["updateItem"] = "You have updated",
    ["deleteItem"] = "You deleted the item",
    ["ownedItem"] = "Du besitzt dieses Item bereits!",
    ["notEnoughtMoney"] = "Du hast nicht genug Geld!",
    ["notRank"] = "Du hast nicht den ben√∂tigten Rang!",
    ["itemDesactivate"] = "Dieses Item ist deaktiviert!",
    ["sellItem"] = "Du hast das Item verkauft f√ºr",
    ["cantEquip"] = "Du kannst dieses Item nicht ausr√ºsten!",
    ["itemVip"] = "Dieses Item ist ist f√ºr VIP¬¥s reserviert!",
    ["jobProblem"] = "Du hast nicht den richtigen Job um dies zu tun!",
    ["exploitArmory"] = "Du bist zu weit vom Kleiderschrank entfernt um diese Aktion durchzuf√ºhren!",
    ["exploitNpc"] = "Du bist zu weit vom NPC entfernt um diese Aktion durchzuf√ºhren!",
    ["saveBodygroup"] = "Du hast gerade das Aussehen deines Charakters gespeichert!",
    ["addItem"] = "Du hast gerade ein Item hinzugef√ºgt",
    ["buyItem"] = "Du hast gerade ein Item gekauft",
    ["for"] = "f√ºr",
    ["noItems"] = "Aktuell gibt es keine Items im Shop! \n Bitte kontaktiere einen Administrator f√ºr mehr Details!",
    ["yourInventory"] = "DEIN INVENTAR",
    ["emptyInventory"] = "Du hast keine Items in deinem Inventar!",
    ["changeInv"] = "Du kannst deine ",
    ["clickingHere"] = "√§ndern wenn du hier klickst!",
    ["upHere"] = "Was willst du heute ausw√§hlen?",
    ["equipItem"] = "Du hast gerade ein Item ausger√ºstet",
    ["deequipedItem"] = "Du hast gerade ein Item abgelegt!",
    ["equipModel"] = "Du hast dein Aussehen ge√§ndert!",
    ["saveModel"] = "Speichern",
    ["toomany"] = "Du hast nicht genug Platz in deinem Rucksack zum dieses Item zu kaufen!",
    ["backpack"] = "Rucksack",
    ["bought"] = "Gekauft",
    ["comboskin"] = "W√§hle einen Skin",
    ["combocategory"] = "W√§hle eine Kategorie",
    ["waitItem"] = "Bitte warte einen Moment bevor du den n√§chsten Gegenstand ausr√ºstetest.",
    ["waitEquip"] = "Anziehen des Items...",
    ["swepcantgo"] = "Du kannst mit diesem SWEP nicht den Shop √∂ffnen!",
    ["iconPos"] = "Position des Icons anpassen",
    ["iconFov"] = "FOV des Icons √§ndern",
    ["itemUniqueId"] = "UniqueId des Items",
    ["adjustAccessory"] = "Item Anpassen",
    ["adjust"] = "Anpassen",
    ["adjustText"] = "Willst du dieses Item anpassen?",
    ["notOwned"] = "Du besitzt dieses Item nicht!",
    ["rankBlackList"] = "Rang Schwarze Liste",

    ["titleGingerBread"] = "Lebkuchen",
    ["titleCap"] = "Kappe",
    ["titleHeadphones"] = "Kopfh√∂rer",
    ["titleHawkMask"] = "Falkenmaske",
    ["titleBeret"] = "Baskenm√ºtze",
    ["titleBandMask"] = "Banden-Maske",
    ["titlePinguin"] = "Pinguin-Maske",
    ["titleMummyMask"] = "Mumien Maske",
    ["titleBandana"] = "Bandana",
    ["titleBag"] = "Tasche",
    ["titleMonkeyMask"] = "Affen Maske",
    ["titleNinjaMask"] = "Ninja Mask",
    ["titleZombieMask"] = "Zombie Maske",
    ["titlePleaseStop"] = "Stopp Schild",
    ["titleSkullMask"] = "Maske",
    ["titleGentlemanshat"] = "Gentleman's Hat",
    ["titleMaskDoctor"] = "Arzt Maske",
    ["titleOrangeHat"] = "Orangen Hut",
    ["titleBlackBagPack"] = "Rucksack",
    ["titlePigHat"] = "Schweine Kopf",
    ["titleCap2"] = "Kappe 2",
    ["titleBigBagpack"] = "Rucksack",
    ["titleSchoolBagPack"] = "Schul Rucksack",
    ["titleBeerHat"] = "Bier Hut",
    ["titleArmor"] = "R√ºstung",
    ["titleMaskDuck"] = "Duck Maske",
    ["titleGlasses"] = "Brillen",
    ["titleGlasses2"] = "Brillen 2",
    ["titleAfro"] = "Afro",
    ["titleMarioHat"] = "Mario Hut",
    ["titleGlasses3"] = "Brillen 3",
    ["titleLuigiHat"] = "Luigi Hut",
    ["titleGlasses4"] = "Brillen 4",
    ["titleGlasses5"] = "Brillen 5",
    ["titleToadHat"] = "Kr√∂ten Hut",
    ["titleServboHead"] = "Servbo Kopf",
    ["titleCatHat"] = "Katzten Hut",
    ["titleStrawHat"] = "Stroh Hut",
    ["titleRabbitEar"] = "Hasen Ohr",
    ["titleSunHat"] = "Sonnen Hut",
    ["title3DGlasses"] = "3D Brillen",
    ["titleCatsEars"] = "Katzten Ohren",
    ["titleCatHat2"] = "Katzten Hut 2",
    ["titleJasonMask"] = "Jason Mask",
    ["titleMustache"] = "Mustache",
    ["titleCowboyHat"] = "Cowboy Hut",
    ["titleDeadmau5"] = "Deadmau5",
    ["titleFrogHat"] = "Frosch Hut",
    ["titleHeartBand"] = "Herzband",
    ["titlePumpkinHead"] = "K√ºrbiskopf",
    ["titleChristmasHat"] = "Weihnachtsm√ºtze",
    ["titleStarHeadband"] = "Stern-Stirnband",
    ["titleThomasHat"] = "Thomas Hut",
    ["titleSombrero"] = "Sombrero",
    ["titleHeadphones2"] = "Kopfh√∂rer 2",
    ["titleSnowGoggles"] = "Schnee-Schutzbrille",
    ["titleCap3"] = "Kappe 3",
    ["titleHat"] = "Schwarzer Hut",
    ["titleGlasses6"] = "Brillen 6",
    ["titleCap4"] = "Kappe 4",
    ["titleDrinkCap"] = "Drink Kappe",
    ["titleStarGlasses"] = "Sternen Brille",
    ["titleCatEars"] = "Katzten Ohren",
    ["titleHat2"] = "Hut 2",
    ["titleBabyRhino"] = "Baby Rhino",
    ["titleArnoldMask"] = "Arnold Maske",
    ["titleChuckMask"] = "Chuck Maske",
    ["titleDeerMask"] = "Deer Maske",
    ["titlePandaMask"] = "Panda Maske",
    ["titleMonkeyMask2"] = "Monkey Maske 2",
    ["titleBearMask"] = "Bear Maske",
    ["titlePigMask"] = "Schweine Maske",
    ["titlePolishBeret"] = "Baskenm√ºtze",
    ["titlePolishBeret2"] = "Baskenm√ºtze 2",
    ["titlePolishBeret3"] = "Baskenm√ºtze 3",
    ["titleBikeHelmet"] = "Fahrradhelm",
    ["titleBikeHelmet2"] = "Fahrradhelm 2",
    ["titleBikeHelmet3"] = "Fahrradhelm 3",
    ["titleBikeHelmet4"] = "Fahrradhelm 4",
    ["titleBikeHelmet5"] = "Fahrradhelm 5",
    ["titleBikeHelmet6"] = "Fahrradhelm 6",
    ["titleBikeHelmet7"] = "Fahrradhelm 7",
    ["titleBikeHelmet8"] = "Fahrradhelm 8",
    ["titleBikeHelmet9"] = "Fahrradhelm 9",
    ["titleBikeHelmet10"] = "Fahrradhelm 10",
    ["titleBikeHelmet11"] = "Fahrradhelm 11",
    ["titleBikeHelmet12"] = "Fahrradhelm 12",
    ["titleBikeHelmet13"] = "Fahrradhelm 13",
    ["titleBikeHelmet14"] = "Fahrradhelm 14",
    ["titleBikeHelmet15"] = "Fahrradhelm 15",
    ["titlePumpkinMask"] = "K√ºrbis-Maske",
    ["titleHorseMask"] = "Pferde Maske",
    ["titleHorseMask2"] = "Pferde Maske 2",
    ["titleHorseMask3"] = "Pferde Maske 3",
    ["titleRussianHat"] = "Russenhut",

    ["descGingerBread"] = "Ein wundersch√∂ner Lebkuchen",
    ["descCap"] = "Eine M√ºtze, wenn dir kalt ist!",
    ["descHeadphones"] = "Zu viel L√§rm - dieses Item ist f√ºr dich gemacht",
    ["descHawkMask"] = "Eine sch√∂ne Falkenmaske",
    ["descBeret"] = "Wow! Es steht dir gro√üartig",
    ["descBandMask"] = "Beste Verbrechensmaske",
    ["descPinguin"] = "Eine Pinguin-Maske",
    ["descMummyMask"] = "Jetzt bist du Anubis' Freund",
    ["descBandana"] = "Ein sch√∂nes Kopftuch Bandana",
    ["descBag"] = "Ihre Lieblings-Einkaufstasche!",
    ["descMonkeyMask"] = "Eine sch√∂ne Affenmaske",
    ["descNinjaMask"] = "Dein Shinobi-Pass!",
    ["descZombieMask"] = "Perfekt f√ºr deine Reise in den Tod!",
    ["descPleaseStop"] = "Eine sch√∂ne Maske!",
    ["descSkullMask"] = "Beste Maske f√ºr deine Halloween-Streiche",
    ["descGentlemanshat"] = "Der Hut eines Gentleman",
    ["descMaskDoctor"] = "Eine Arztmaske",
    ["descOrangeHat"] = "A Orangefarbener Hut",
    ["descBlackBagPack"] = "Ein schwarzer Rucksack",
    ["descPigHat"] = "Liebst du Schweine?",
    ["descCap2"] = "Zum Schutz vor der Sonne!",
    ["descBigBagpack"] = "Ein gro√ües Gep√§ckst√ºck",
    ["descSchoolBagPack"] = "Ein Schulrucksack",
    ["descBeerHat"] = "Ein Bierhut",
    ["descArmor"] = "R√ºstung",
    ["descMaskDuck"] = "Ein lustiger Entenhut",
    ["descGlasses"] = "Tun dir die Augen weh? Dann sind sie wie f√ºr dich gemacht",
    ["descGlasses2"] = "Tun dir die Augen weh? Dann sind sie wie f√ºr dich gemacht",
    ["descAfro"] = "Sie wollen gut aussehen?",
    ["descMarioHat"] = "Wenn Sie ein Mario-Fan sind!",
    ["descGlasses3"] = "Tun dir die Augen weh? Dann sind sie wie f√ºr dich gemacht",
    ["descLuigiHat"] = "Wenn Sie ein Luigi-Fan sind!",
    ["descGlasses4"] = "Tun dir die Augen weh? Dann sind sie wie f√ºr dich gemacht",
    ["descGlasses5"] = "Tun dir die Augen weh? Dann sind sie wie f√ºr dich gemacht",
    ["descToadHat"] = "Wenn Sie ein Kr√∂ten-Fan sind!",
    ["descServboHead"] = "Ich liebe das Leben!",
    ["descCatHat"] = "Ein wundersch√∂ner Katzenhut.",
    ["descStrawHat"] = "Ein sch√∂ner Strohhut!",
    ["descRabbitEar"] = "Sehr sch√∂ne Kaninchenohren",
    ["descSunHat"] = "Um eine gute Zeit auf Reisen haben",
    ["desc3DGlasses"] = "Um eine gute Zeit im Kino zu haben!",
    ["descCatsEars"] = "F√ºhl dich wie eine Katze.",
    ["descCatHat2"] = "Ein wundersch√∂ner Katzenhut.",
    ["descJasonMask"] = "Die Maske aus deinem Lieblingshorrorfilm",
    ["descMustache"] = "Ein sch√∂ner Schnurrbart!",
    ["descCowboyHat"] = "Haben Sie schon immer davon getr√§umt, ein Cowboy zu werden?",
    ["descDeadmau5"] = "Hast du jemals davon getr√§umt, Deadmau5 zu sein?",
    ["descFrogHat"] = "Ein sch√∂ner Froschhut.",
    ["descHeartBand"] = "Ein Stirnband mit Herz.",
    ["descPumpkinHead"] = "Die perfekte Gesichtsmaske f√ºr deine Halloween-Pranks.",
    ["descChristmasHat"] = "Wir w√ºnschen dir ein frohes Weihnachtsfest.",
    ["descStarHeadband"] = "Werde ein Star mit diesem Stirnband.",
    ["descThomasHat"] = "Liebst du Musik?",
    ["descSombrero"] = "Ein sch√∂ner mexikanischer Hut!",
    ["descHeadphones2"] = "Mit diesen Kopfh√∂rern h√∂rst du hochwertige Musik",
    ["descSnowGoggles"] = "Skifahren in absoluter Sicherheit!",
    ["descCap3"] = "Eine gute M√ºtze.",
    ["descHat"] = "Ein luxuri√∂ser schwarzer Hut.",
    ["descGlasses6"] = "Eine luxuri√∂se Brille.",
    ["descCap4"] = "Eine einfache M√ºtze.",
    ["descDrinkCap"] = "Ein sch√∂ner Trinkerhut f√ºr einen Trunkenbold!",
    ["descStarGlasses"] = "Wenn du davon tr√§umst, ein Star zu werden!",
    ["descCatEars"] = "Sch√∂ne Katzenohren, um NEKO UWU werden.",
    ["descHat2"] = "Ein guter, einfacher schwarzer Hut.",
    ["descBabyRhino"] = "Wenn du Rhino liebst.",
    ["descArnoldMask"] = "Arnold-Maske, aber sie macht dich nicht zu Arnold Schwarzenegger.",
    ["descChuckMask"] = "Chuck Maske",
    ["descDeerMask"] = "Eine sch√∂ne Hirschmaske!",
    ["descPandaMask"] = "Eine coole Panda-Maske! F√ºr hei√üe N√§chte mit deiner Freundin",
    ["descMonkeyMask2"] = "Die beste Affenmaske auf dem Markt!",
    ["descBearMask"] = "Eine einfache B√§renmaske. Nicht in die N√§he von Tierf√§ngern kommen",
    ["descPigMask"] = "Du siehst aus wie eine Wildkatze... Nein, warte, du siehst aus wie ein Schwein",
    ["descPolishBeret"] = "Eine sch√∂ne polnische Baskenm√ºtze",
    ["descPolishBeret2"] = "Eine sch√∂ne polnische Baskenm√ºtze",
    ["descPolishBeret3"] = "Eine sch√∂ne polnische Baskenm√ºtze",
    ["descBikeHelmet"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet2"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet3"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet4"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet5"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet6"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet7"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet8"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet9"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet10"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet11"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet12"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet13"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet14"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descBikeHelmet15"] = "Setze den Helm auf, oder die Polizei wird dich anhalten!",
    ["descPumpkinMask"] = "F√ºr ein besseres Halloween",
    ["descHorseMask"] = "ICH BIN EIN PFERD UWUWUWU",
    ["descHorseMask2"] = "ICH BIN EIN PFERD UWUWUWU",
    ["descHorseMask3"] = "ICH BIN EIN PFERD UWUWUWU",
    ["descRussianHat"] = "Hardbass f√ºr immer epta!",
}
// 76561198442896680
--PATH addons/sl_util_accessory/lua/advanced_accessories/languages/sh_language_fr.lua:
AAS = AAS or {}
AAS.Language = AAS.Language  or {}

AAS.Language["fr"] = {
    ["cancel"] = "Annuler",
    ["save"] = "Sauvegarder",
    ["name"] = "Nom",
    ["model"] = "Model",
    ["itemPrice"] = "Prix",
    ["itemPos"] = "Position",
    ["itemStat"] = "Statistiques",
    ["itemJob"] = "Exculsif au m√©tier",
    ["itemName"] = "Nom de l'item",
    ["customCharacter"] = "Customiser votre personnage",
    ["adminDashboard"] = "PANNEAU D'ADMINISTRATION",
    ["welcomeText"] = "BIENVENUE, QUE VOULEZ VOUS ACHETER ?",
    ["position"] = "POSITION",
    ["rotation"] = "ROTATION",
    ["scale"] = "TAILLE",
    ["description"] = "Une courte description de votre accessoire",
    ["search"] = "  Rechercher...",
    ["sell"] = "Vendre",
    ["buy"] = "Acheter",
    ["buyaccessory"] = "Acheter l'accessoire",
    ["sellaccessory"] = "Vendre l'accessoire",
    ["sure"] = "√ätes-vous sur de vouloir faire ceci ?",
    ["activate"] = "Activer",
    ["desactivate"] = "D√©sactiver",
    ["modifypos"] = "Modifier la position",
    ["edititem"] = "Editer l'item",
    ["appearance"] = "Apparence",
    ["skin"] = "Skin",
    ["desc"] = "Description",
    ["titleactivate"] = "Activer / D√©sactiver l'accessoire",
    ["choosecategory"] = "Choisir une cat√©gorie",
    ["chooseskin"] = "Choisir le skin",
    ["additem"] = "Add Item",
    ["adminname"] = "Le nom de l'accessoire n'est pas correct !",
    ["faildesc"] = "La description n'est pas correcte !",
    ["failprice"] = "Le prix n'est pas correct !",
    ["choosemodel"] = "Veuillez choisir un model",
    ["failcategory"] = "Vous devez choisir une cat√©gorie",
    ["updateItem"] = "Accessoire mis-√†-jour",
    ["deleteItem"] = "Accessoire supprim√©",
    ["ownedItem"] = "Vous poss√©dez d√©j√† cet accessoire",
    ["notEnoughtMoney"] = "Vous n'avez pas assez d'argent !",
    ["notRank"] = "Vous n'avez pas les permissions n√©cessaires !",
    ["itemDesactivate"] = "Cet accessoire est actuellement d√©sactiv√© !",
    ["sellItem"] = "Vous avez vendu cet accessoire pour",
    ["cantEquip"] = "Vous ne pouvez pas √©quiper cet accessoire !",
    ["itemVip"] = "Cet accessoire est r√©serv√© aux membres privil√©gi√©s",
    ["jobProblem"] = "Votre m√©tier actuel ne vous permet pas de faire ceci !",
    ["exploitArmory"] = "Vous √™tes trop √©loign√© de l'armoir pour faire ceci !",
    ["exploitNpc"] = "Vous √™tes trop loin du PNJ pour faire ceci !",
    ["saveBodygroup"] = "Apparence du personnage sauvegard√©e !",
    ["addItem"] = "Accessoire ajout√©",
    ["buyItem"] = "Accessoire achet√©",
    ["for"] = "pour",
    ["noItems"] = "Il n'y a pas d'accessoire en vente \n Veuillez contacter un responsable du serveur !",
    ["yourInventory"] = "VOTRE INVENTAIRE",
    ["emptyInventory"] = "Vous n'avez pas d'accessoires disponible",
    ["changeInv"] = "Vous pouvez changer votre",
    ["clickingHere"] = "en cliquant ici !",
    ["upHere"] = "Que souhaitez-vous choisir aujourd'hui ?",
    ["equipItem"] = "Vous venez d'√©quiper l'accessoire !",
    ["deequipedItem"] = "Vous venez de d√©s√©quip√© l'accessoire !",
    ["equipModel"] = "Apparence modifi√©e !",
    ["saveModel"] = "Sauvegarder le model",
    ["toomany"] = "Vous n'avez plus assez de place dans votre sac-√†-dos pour acheter ceci.",
    ["backpack"] = "Sac-√†-dos",
    ["bought"] = "Poss√©d√©",
    ["comboskin"] = "Choisissez un skin",
    ["combocategory"] = "Choisissez une cat√©gorie",
    ["waitItem"] = "Veuillez patienter avant d'√©quiper un autre accessoire.",
    ["waitEquip"] = "Vous √©quipez l'accessoire..",
    ["swepcantgo"] = "Vous ne pouvez pas acc√©der au menu avec le SWEP en main !",
    ["iconPos"] = "Modifier la position de l'icone",
    ["iconFov"] = "Modifier le FOV de l'icone",
    ["itemUniqueId"] = "Item UniqueId",
    ["adjustAccessory"] = "Ajuster l'item",
    ["adjust"] = "Ajuster",
    ["adjustText"] = "Voulez vous ajuster l'item ?",
    ["notOwned"] = "Vous n'avez pas achet√© l'item !",
    ["rankBlackList"] = "Rang sur la liste noire",

    ["titleGingerBread"] = "Pain d'√©pice",
    ["titleCap"] = "Casquette",
    ["titleHeadphones"] = "Casque",
    ["titleHawkMask"] = "Masque",
    ["titleBeret"] = "B√©ret",
    ["titleBandMask"] = "Couvre-chef",
    ["titlePinguin"] = "Masque pingouin",
    ["titleMummyMask"] = "Masque momie",
    ["titleBandana"] = "Bandana",
    ["titleBag"] = "Sac",
    ["titleMonkeyMask"] = "Masque singe",
    ["titleNinjaMask"] = "Masque ninja",
    ["titleZombieMask"] = "Masque zombie",
    ["titlePleaseStop"] = "Masque stop",
    ["titleSkullMask"] = "Masque",
    ["titleGentlemanshat"] = "Chapeau",
    ["titleMaskDoctor"] = "Masque docteur",
    ["titleOrangeHat"] = "Chapeau orange",
    ["titleBlackBagPack"] = "Sac-√†-dos",
    ["titlePigHat"] = "Chapeau cochon",
    ["titleCap2"] = "Casquette",
    ["titleBigBagpack"] = "Sac-√†-dos",
    ["titleSchoolBagPack"] = "Sac-√†-dos",
    ["titleBeerHat"] = "Casque biere",
    ["titleArmor"] = "Gillet pare-balle",
    ["titleMaskDuck"] = "Masque canard",
    ["titleGlasses"] = "Lunettes",
    ["titleGlasses2"] = "Lunettes",
    ["titleAfro"] = "Afro",
    ["titleMarioHat"] = "Chapeau Mario",
    ["titleGlasses3"] = "Lunettes",
    ["titleLuigiHat"] = "Chapeau Luigi",
    ["titleGlasses4"] = "Lunettes",
    ["titleGlasses5"] = "Lunettes",
    ["titleToadHat"] = "Chapeau Toad",
    ["titleServboHead"] = "T√™te Servbot",
    ["titleCatHat"] = "Chapeau chat",
    ["titleStrawHat"] = "Chapeau",
    ["titleRabbitEar"] = "Oreilles de chat",
    ["titleSunHat"] = "Chapeau",
    ["title3DGlasses"] = "Lunettes 3D",
    ["titleCatsEars"] = "Oreilles de chat",
    ["titleCatHat2"] = "Chapeau chat",
    ["titleJasonMask"] = "Masque Jason",
    ["titleMustache"] = "Moustache",
    ["titleCowboyHat"] = "Chapeau cowboy",
    ["titleDeadmau5"] = "Masque",
    ["titleFrogHat"] = "Chapeau",
    ["titleHeartBand"] = "Bandeau coeur",
    ["titlePumpkinHead"] = "T√™te de citrouille",
    ["titleChristmasHat"] = "Chapeau no√´l",
    ["titleStarHeadband"] = "Bandeau √©toil√©",
    ["titleThomasHat"] = "Chapeau Thomas",
    ["titleSombrero"] = "Sombrero",
    ["titleHeadphones2"] = "Casque",
    ["titleSnowGoggles"] = "Lunettes",
    ["titleCap3"] = "Casquette",
    ["titleHat"] = "Chapeau noir",
    ["titleGlasses6"] = "Lunettes",
    ["titleCap4"] = "Casquette",
    ["titleDrinkCap"] = "Chapeau boisson",
    ["titleStarGlasses"] = "Lunettes",
    ["titleCatEars"] = "Oreilles de chat",
    ["titleHat2"] = "Chapeau",
    ["titleBabyRhino"] = "B√©b√© Rhino",
    ["titleArnoldMask"] = "Masque d'Arnold",
    ["titleChuckMask"] = "Masque Chuck",
    ["titleDeerMask"] = "Masque biche",
    ["titlePandaMask"] = "Masque panda",
    ["titleMonkeyMask2"] = "Masque singe",
    ["titleBearMask"] = "Masque d'ours",
    ["titlePigMask"] = "Masque cochon",
    ["titlePolishBeret"] = "Beret millitaire",
    ["titlePolishBeret2"] = "Beret millitaire",
    ["titlePolishBeret3"] = "Beret millitaire",
    ["titleBikeHelmet"] = "Casque de moto",
    ["titleBikeHelmet2"] = "Casque de moto",
    ["titleBikeHelmet3"] = "Casque de moto",
    ["titleBikeHelmet4"] = "Casque de moto",
    ["titleBikeHelmet5"] = "Casque de moto",
    ["titleBikeHelmet6"] = "Casque de moto",
    ["titleBikeHelmet7"] = "Casque de moto",
    ["titleBikeHelmet8"] = "Casque de moto",
    ["titleBikeHelmet9"] = "Casque de moto",
    ["titleBikeHelmet10"] = "Casque de moto",
    ["titleBikeHelmet11"] = "Casque de moto",
    ["titleBikeHelmet12"] = "Casque de moto",
    ["titleBikeHelmet13"] = "Casque de moto",
    ["titleBikeHelmet14"] = "Casque de moto",
    ["titleBikeHelmet15"] = "Casque de moto",
    ["titlePumpkinMask"] = "Masque citrouille",
    ["titleHorseMask"] = "Masque cheval",
    ["titleHorseMask2"] = "Masque cheval",
    ["titleHorseMask3"] = "Masque cheval",
    ["titleRussianHat"] = "Chapeau russe",

    ["descGingerBread"] = "Un beau pain d'√©pice",
    ["descCap"] = "Une casquette pour vous prot√©ger du soleil",
    ["descHeadphones"] = "S'il y a trop de bruit, ce casque est fait pour vous",
    ["descHawkMask"] = "Un beau masque de faucon",
    ["descBeret"] = "Wow, sa vous va bien",
    ["descBandMask"] = "Un masque pour le meilleur des crimes",
    ["descPinguin"] = "Un masque de pingouin pour vous glisser parmis vos cong√©naires",
    ["descMummyMask"] = "Vous √™tes d√©sormais un amis d'Anubis",
    ["descBandana"] = "Un beau bandana",
    ["descBag"] = "Votre meilleur sac pour faire vos courses",
    ["descMonkeyMask"] = "Un magnifique masque de singe",
    ["descNinjaMask"] = "Votre pass pour Shinobi",
    ["descZombieMask"] = "Parfait pour votre nuit sanglante",
    ["descPleaseStop"] = "Un masque d'une baut√©e rarissime",
    ["descSkullMask"] = "Le meilleur masque pour aller r√©clamer les bonbons d'halloween",
    ["descGentlemanshat"] = "Vous vous sentirez comme un boss",
    ["descMaskDoctor"] = "Jouer a docteur maboul ce n'est pas votre genre visiblement",
    ["descOrangeHat"] = "Un chapeau orange, rien de plus banal",
    ["descBlackBagPack"] = "Un sac noir",
    ["descPigHat"] = "Vous aimez le rose",
    ["descCap2"] = "Pour taper vos meilleures bronzettes",
    ["descBigBagpack"] = "Un √©norme sac",
    ["descSchoolBagPack"] = "Un sac pour aller √† l'√©cole",
    ["descBeerHat"] = "Pour boire une bi√®re sans le moindre effort. Faignant !",
    ["descArmor"] = "De ce qu'on dit il resiste m√™me aux tirs d'obus",
    ["descMaskDuck"] = "Un masque de canard",
    ["descGlasses"] = "Vos yeux vous font mal ? Alors elles sont fa√Ætes pour vous",
    ["descGlasses2"] = "Vos yeux vous font mal ? Alors elles sont fa√Ætes pour vous",
    ["descAfro"] = "Vous voulez avoir la classe ?",
    ["descMarioHat"] = "Vous √™tes visiblement un fan de Mario",
    ["descGlasses3"] = "Vos yeux vous font mal ? Alors elles sont fa√Ætes pour vous",
    ["descLuigiHat"] = "Vous √™tes visiblement un fan de Luigi",
    ["descGlasses4"] = "Vos yeux vous font mal ? Alors elles sont fa√Ætes pour vous",
    ["descGlasses5"] = "Vos yeux vous font mal ? Alors elles sont fa√Ætes pour vous",
    ["descToadHat"] = "Vous √™tes visiblement un fan de Toad",
    ["descServboHead"] = "J'aime la vie",
    ["descCatHat"] = "Pour avoir l'ouie d'un chat",
    ["descStrawHat"] = "Pour vous sentir comme en vacances",
    ["descRabbitEar"] = "De belles oreilles de lapin",
    ["descSunHat"] = "Pour avoir l'air cool sur la plage",
    ["desc3DGlasses"] = "Pour passer un bon moment au cin√©ma, s'ils s'ont ouverts bien-s√ªr :(",
    ["descCatsEars"] = "Avoir l'ouie d'un chat ? Sa doit √™tre cool nan ?",
    ["descCatHat2"] = "Pour ressembler comme deux gouttes d'eau √† un chat",
    ["descJasonMask"] = "Le masque de vos meilleurs films d'horreur",
    ["descMustache"] = "Une belle moustache digne du plus grand barbier",
    ["descCowboyHat"] = "Afin de vous immaginer dans Lucky Luke",
    ["descDeadmau5"] = "Avez vous d√©j√† fanstasm√© √† l'id√©e d'√™tre Deadmau5 ?",
    ["descFrogHat"] = "Un beau chapeau de grenouille",
    ["descHeartBand"] = "Un maginifique bandeau muni d'un coeur",
    ["descPumpkinHead"] = "Le meilleur masque pour vos sorties Halloween",
    ["descChristmasHat"] = "Nous vous souhaitons un joyeux no√´l",
    ["descStarHeadband"] = "Devenez une star gr√¢ce √† ce bandeau",
    ["descThomasHat"] = "Vous aimez la musique ?",
    ["descSombrero"] = "Un beau chapeau venant tout droit du Mexique",
    ["descHeadphones2"] = "Avec ce casque, √©coutez vos meilleurs sons",
    ["descSnowGoggles"] = "Ne pas avoir de neige dans les yeux sa doit s√ªrement √™tre bien",
    ["descCap3"] = "Une casquette de bonne qualit√©",
    ["descHat"] = "Un chapeau noir de luxe",
    ["descGlasses6"] = "Une paire de lunettes luxieuse",
    ["descCap4"] = "Une casquette assez banale",
    ["descDrinkCap"] = "Afin de boire une binouze entre ami sans le moindre effort",
    ["descStarGlasses"] = "Si vous r√©vez de devenir une star",
    ["descCatEars"] = "Que de belles oreilles de chat",
    ["descHat2"] = "Un casque noir basique... Simple",
    ["descBabyRhino"] = "Si vous adorez Rhino",
    ["descArnoldMask"] = "Un beau masque d'Arnold en revanche vous ne devenez pas Arnold Schwarzenegger",
    ["descChuckMask"] = "Masque de Chuck",
    ["descDeerMask"] = "Pour vous balader en for√™t avec vos amis",
    ["descPandaMask"] = "Un masque de panda pour les nuits chaudes avec votre copine :)",
    ["descMonkeyMask2"] = "Il parra√Æt qu'en le mettant vous ressemblerez √† nos anc√®tres",
    ["descBearMask"] = "Un simple masque d'ours effrayant",
    ["descPigMask"] = "Fa√Ætes gaffe √† ne pas vous faire confondre avec un cochon √©chapp√© de la porcherie",
    ["descPolishBeret"] = "Un beau b√©ret millitaire",
    ["descPolishBeret2"] = "Un beau b√©ret millitaire",
    ["descPolishBeret3"] = "Un beau b√©ret millitaire",
    ["descBikeHelmet"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet2"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet3"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet4"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet5"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet6"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet7"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet8"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet9"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet10"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet11"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet12"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet13"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet14"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descBikeHelmet15"] = "Mettez ce casque ou alors la police vous attrapera !",
    ["descPumpkinMask"] = "Pour un meilleur halloween",
    ["descHorseMask"] = "Je suis un cheval UWUWUWU",
    ["descHorseMask2"] = "Je suis un cheval UWUWUWU",
    ["descHorseMask3"] = "Je suis un cheval UWUWUWU",
    ["descRussianHat"] = "Vodka et tecktonick pour toujours",
}
--76561198442896680
--PATH addons/sl_aphone/lua/aphone/_libs/panels/cl_msg.lua:
local PANEL = {}
local clr_green = Color(46,139,87)

function PANEL:InitPly(ply)
    local main_x, main_y = aphone.MainDerma:GetSize()
    local clr_black3 = aphone:Color("Black3")
    local clr_black2 = aphone:Color("Black2")
    local clr_black1 = aphone:Color("Black1")
    local clr_white120 = aphone:Color("Text_White120")
    local font_mediumheader = aphone:GetFont("MediumHeader")
    local connected = ply and isentity(ply) and ply:IsPlayer()
    local id = connected and ply:aphone_GetID() or ply
    local name = aphone.GetName(ply)
    local pnl = self

    self:SetPaintBackground(false)

    self:SetSize(aphone.MainDerma:GetSize())

    local message_panel = vgui.Create("DPanel", self)
    message_panel:SetSize(main_x, main_y)
    message_panel:SetPos(main_x, 0)
    message_panel:MoveTo(0, 0, 0.25, 0, 0.5)

    local message_writing = vgui.Create("DPanel", message_panel)
    message_writing:Dock(BOTTOM)
    message_writing:DockMargin(main_x * 0.04, main_y * 0.025, main_x * 0.04, main_y * 0.025)
    message_writing:SetTall(main_y * 0.07)

    local perfect_h = main_y * 0.035

    function message_writing:Paint(w, h)
        draw.RoundedBox(perfect_h, 0, 0, w, h, clr_black1)
    end

    surface.SetFont(aphone:GetFont("SVG_30"))
    local msg_writingtall = message_writing:GetTall()

    local message_send = vgui.Create("DLabel", message_writing)
    message_send:Dock(RIGHT)
    message_send:DockMargin(0, 0, msg_writingtall / 4, 0)
    message_send:SetWide(select(1, surface.GetTextSize("i")))
    message_send:SetFont(aphone:GetFont("SVG_30"))
    message_send:SetText("i")
    message_send:SetTextColor(clr_white120)
    message_send:SetMouseInputEnabled(true)

    // aphone_OnlinePictureList
    local messages_pic = vgui.Create("DLabel", message_writing)
    messages_pic:Dock(RIGHT)
    messages_pic:DockMargin(0, 0, msg_writingtall / 4, 0)
    messages_pic:SetWide(select(1, surface.GetTextSize("m")))
    messages_pic:SetFont(aphone:GetFont("SVG_30"))
    messages_pic:SetText("m")
    messages_pic:SetTextColor(clr_white120)
    messages_pic:SetMouseInputEnabled(true)
    messages_pic:Phone_AlphaHover()

    local message_writingEntry = vgui.Create("DLabel", message_writing)
    message_writingEntry:Dock(FILL)
    message_writingEntry:DockMargin(msg_writingtall / 2, 0, msg_writingtall / 2, 0)
    message_writingEntry:SetFont(font_mediumheader)
    message_writingEntry:SetText(aphone.L("Type_Message"))
    message_writingEntry:SetTextColor(clr_white120)
    message_writingEntry:SetMouseInputEnabled(true)
    message_writingEntry:Phone_AlphaHover()

    -- Create a panel to select online pictures, then set the dlabel text to the link
    function messages_pic:DoClick()
        local messages_picmain = vgui.Create("aphone_OnlinePictureList", pnl)
        function messages_picmain:OnSelected(imgur_url)
            aphone.InsertNewMessage(LocalPlayer(), "imgur://" .. imgur_url)
            aphone.Contacts.Send(id, "imgur://" .. imgur_url)
        end
    end

    local placeholder = aphone.L("Type_Message")
    function message_writingEntry:DoClick()
        self:Phone_AskTextEntry(message_writingEntry:GetText() == placeholder and "" or self:GetText(), 140, message_writing, (main_x*0.92 - msg_writingtall*1.25 - messages_pic:GetWide() - message_send:GetWide()))
    end

    function message_writingEntry:textEnd(clean_txt, wrapped_txt)
        self:SetText(wrapped_txt)
        self.goodtext = clean_txt
    end

    surface.SetFont(aphone:GetFont("Roboto45_700"))
    local title_x, title_y = surface.GetTextSize(name)

    local top_name = vgui.Create("DPanel", message_panel)
    top_name:Dock(TOP)
    top_name:DockMargin(main_x * 0.12, main_y * 0.05, 0, main_y * 0.05)
    top_name:SetTall(title_y)
    top_name:SetPaintBackground(false)

    local top_back = vgui.Create("DButton", top_name)
    top_back:Dock(RIGHT)
    top_back:SetWide(title_y)
    top_back:SetFont(aphone:GetFont("SVG_30"))
    top_back:SetText("l")
    top_back:SetPaintBackground(false)
    top_back:Phone_AlphaHover()
    top_back:SetTextColor(clr_white120)
    top_back:DockMargin(0, 0, top_back:GetWide(), 0)

    function top_back:DoClick()
        message_panel:MoveTo(main_x, 0, 0.5, 0, 0.5, function()
            pnl:Remove()
        end)
    end

    // Disconnected, hide call button
    if connected then
        surface.SetFont(aphone:GetFont("SVG_30"))
        local top_call = vgui.Create("DButton", top_name)
        top_call:Dock(RIGHT)
        top_call:SetWide(select(1, surface.GetTextSize("o")))
        top_call:SetFont(aphone:GetFont("SVG_30"))
        top_call:SetText("o")
        top_call:Phone_AlphaHover()
        top_call:SetTextColor(clr_white120)
        top_call:SetPaintBackground(false)

        function top_call:DoClick()
            net.Start("aphone_Phone")
                net.WriteUInt(1, 4)
                net.WriteEntity(ply)
            net.SendToServer()
        end
    end

    local title_sub = vgui.Create("DLabel", top_name)
    title_sub:SetFont(aphone:GetFont("Roboto40_700"))
    title_sub:SetTextColor(aphone:Color("Text_White"))
    title_sub:SetText(name)
    title_sub:Dock(FILL)
    title_sub:SetWide(title_x + 10)

    local message_scroll = vgui.Create("DScrollPanel", message_panel)
    message_scroll:Dock(FILL)
    message_scroll:aphone_PaintScroll()

    local is_empty = true

    // Ghetto but work and won't make optimisation issues searching the dscrollpanel from the main panel etc
    local last_msgpanel
    function aphone.InsertNewMessage(userid, body)
        if IsValid(message_scroll) then
            local ext = false

            if isbool(userid) then
                ext = userid
            elseif isentity(userid) and userid == LocalPlayer() then
                ext = true
            elseif isnumber(userid) and userid == LocalPlayer():aphone_GetID() then
                ext = true
            end

            is_empty = false

            if string.StartWith(body, "imgur://") then
                local sub_messagepnl = message_scroll:Add("aphone_MessageImage")
                sub_messagepnl:Dock(TOP)
                sub_messagepnl:DockMargin(0, main_x * 0.025, 0, main_x * 0.025)
                sub_messagepnl:Left_Avatar(ext)
                sub_messagepnl:SetImgur(body)
                sub_messagepnl:SetTall(main_x * 0.35)

                function sub_messagepnl:DoClick()
                    local show_pic = vgui.Create("aphone_ShowImage", pnl)
                    show_pic:SetMat(aphone.GetImgurMat(body))
                end

                last_msgpanel = sub_messagepnl
                return sub_messagepnl
            else
                if !IsValid(last_msgpanel) or last_msgpanel:GetName() != "aphone_Message" or last_msgpanel.revert != ext then
                    local sub_messagepnl = message_scroll:Add("aphone_Message")
                    sub_messagepnl:Dock(TOP)
                    sub_messagepnl:DockMargin(main_x * 0.05, main_x * 0.025, main_x * 0.05, main_x * 0.025)
                    sub_messagepnl:Left_Avatar(ext)
                    sub_messagepnl:SetText(body)
                    sub_messagepnl:SetBackgroundColor(ext and clr_green or clr_black2)

                    if !connected then
                        sub_messagepnl:KillAvatar()
                    else
                        sub_messagepnl:SetAvatar(userid, 184)
                    end

                    last_msgpanel = sub_messagepnl
                    return sub_messagepnl
                else
                    last_msgpanel:SetText(last_msgpanel:GetText() .. "\n" .. body)
                end
            end
        end
    end

    function message_send:DoClick()
        if !message_writingEntry.goodtext then return end

        aphone.Contacts.Send(id, message_writingEntry.goodtext)

        self:GetParent():SetTall(main_y * 0.07)
        aphone.InsertNewMessage(LocalPlayer(), message_writingEntry.goodtext)

        message_writingEntry.goodtext = nil
        message_writingEntry:SetText(aphone.L("Type_Message"))
    end

    // Let's not load ALL messages. Imagine if he got a lot of messages
    local msg_tbl = sql.Query("SELECT * FROM aphone_Messages WHERE user = " .. id .. " AND ip = '" .. game.GetIPAddress() .. "' AND timestamp > " .. os.time() - 604800) or {}

    local pnl
    for k, v in ipairs(msg_tbl) do
        if connected then
            pnl = aphone.InsertNewMessage(tonumber(v.local_sender) == 1 and LocalPlayer() or ply, v.body)
        else
            pnl = aphone.InsertNewMessage(tonumber(v.local_sender) == 1, v.body)
        end
    end

    if IsValid(pnl) then
        timer.Simple(0.33, function()
            message_scroll:ScrollToChild(pnl)
        end)
    end

    function message_panel:Paint(w, h)
        surface.SetDrawColor(clr_black3)
        surface.DrawRect(0,0,w,h)

        if is_empty then
            local _, txt_y = draw.SimpleText("U", aphone:GetFont("SVG_76"), w / 2, h / 4, clr_white120, 1)
            draw.DrawText(aphone.L("First_Message"), font_mediumheader, w / 2, h / 4 + txt_y + 10, clr_white120, 1)
        end
    end

    self:aphone_RemoveCursor()
end

vgui.Register("aphone_Msg", PANEL, "DPanel")
--PATH addons/sl_aphone/lua/aphone/apps/gallery/cl_main.lua:
local APP = {}

APP.name = aphone.L("Gallery")
APP.icon = "akulla/aphone/app_gallery.png"

local last_closedpic
local stencil_clr = Color(1, 1, 1, 1)

function APP:Open(main, main_x, main_y, screenmode)
    local clr_white = aphone:Color("White")
    local clr_orange = aphone:Color("Text_Orange")
    local clr_black = aphone:Color("Black3")
    local font_svg = aphone:GetFont("SVG_16")

    local margin = screenmode and main_y * 0.1 or main_x * 0.1
    function main:Paint(w,h)
        surface.SetDrawColor(clr_white)
        surface.DrawRect(0,0,w,h)
    end

    surface.SetFont(aphone:GetFont("Roboto40_700"))
    local _, title_y = surface.GetTextSize(aphone.L("Offline_Pictures"))

    local title = vgui.Create("DLabel", main)
    title:Dock(TOP)
    title:SetContentAlignment(5)
    title:DockMargin(0, screenmode and main_x * 0.03 or main_y * 0.05, 0, 0)
    title:SetTall(title_y)
    title:SetFont(aphone:GetFont("Roboto40_700"))
    title:SetTextColor(clr_black)
    title:SetText(aphone.L("Offline_Pictures"))

    local s = vgui.Create( "DScrollPanel", main )
    s:Dock( FILL )
    s:DockMargin(margin, margin, margin, margin)
    s:aphone_PaintScroll()

    local l = vgui.Create("DIconLayout")
    s:AddItem(l)
    l:SetSpaceX(10)
    l:SetSpaceY(10)
    l:Dock(FILL)

    // 19 = 5*3 margin between pictures
    local perfect_iconsize = ((screenmode and main_y or main_x) - margin * 2 - l:GetSpaceX() * 2 - s:GetVBar():GetWide()) / 3
    local cache_poly = aphone.GUI.RoundedBox(0, 0, perfect_iconsize, perfect_iconsize, 8)

    for k,v in SortedPairs(aphone.Pictures) do
        local but = l:Add("DButton")
        but:SetText("")
        but:SetSize(perfect_iconsize, perfect_iconsize)
        but:TDLib()
        but:ClearPaint()

        local frac = 0
        local last_check = CurTime()
        local is_hovered

        function but:Paint(w, h)
            if frac != 0 or is_hovered then
                if is_hovered then
                    frac = frac + (CurTime() - last_check) * 4
                else
                    frac = frac - (CurTime() - last_check) * 4
                end
                last_check = CurTime()

                // Math.clamp kill my fprofiler I dunno why
                if frac > 1 then
                    frac = 1
                elseif frac < 0 then
                    frac = 0
                end
            end

            aphone.Stencils.Start()
                surface.SetDrawColor(stencil_clr)
                surface.DrawPoly(cache_poly)
            aphone.Stencils.AfterMask(false)
                if frac != 0 then
                    render.SetStencilPassOperation(STENCIL_KEEP)

                    surface.SetMaterial(v)
                    surface.SetDrawColor(color_white)
                    surface.DrawTexturedRect(0, 0, w, h)

                    draw.NoTexture()
                    surface.SetDrawColor(clr_orange.r, clr_orange.g, clr_orange.b, frac * 120)
                    surface.DrawPoly(aphone.GUI.GenerateCircle(w / 2, h / 2, (h / 2 + w / 2) * frac))

                    render.SetStencilReferenceValue(1)
                    render.SetStencilPassOperation(STENCIL_REPLACE)
                    render.SetStencilCompareFunction(STENCIL_ALWAYS)
                        surface.SetDrawColor(stencil_clr)
                        surface.DrawRect(0, 0, w, h)
                else
                    surface.SetMaterial(v)
                    surface.SetDrawColor(color_white)
                    surface.DrawTexturedRect(0, 0, w, h)
                end
            aphone.Stencils.End()
        end

        function but:DoClick()
            local p = vgui.Create("aphone_ShowImage", main)
            p:SetMat(v)
            p:SetDir(string.Replace(v:GetName(), "../data/", "") .. ".jpg")
            p.skipanim = (last_closedpic == v)

            last_closedpic = v

            function p.onclose()
                last_closedpic = nil
            end
        end

        if last_closedpic == v then
            but:DoClick()
        end

        local delete = vgui.Create("DButton", but)
        delete:SetPos(perfect_iconsize * 0.75, perfect_iconsize*0.05)
        delete:SetText("S")
        delete:SetFont(font_svg)
        delete:SetSize(perfect_iconsize*0.2, perfect_iconsize*0.2)
        delete:Phone_AlphaHover()
        delete:SetPaintBackground(false)
        delete:SetVisible(false)

        function delete:DoClick()
            but:Remove()
            file.Delete(string.sub(v:GetName() .. ".jpg", 9))
            aphone.Pictures[k] = nil
        end

        function but:OnCursorEntered()
            is_hovered = true
            delete:SetVisible(true)
        end

        function but:OnCursorExited()
            is_hovered = false
            delete:SetVisible(false)
        end
    end
    main:aphone_RemoveCursor()
end

function APP:Open2D(main, main_x, main_y)
    self:Open(main, main_x, main_y, true)
end

function APP:OnClose()
    last_closedpic = nil
end

aphone.RegisterApp(APP)
--PATH addons/sl_utils/lua/autorun/darkrp_translation_fr.lua:
local hl = GetConVar( "gmod_language" ):GetString()

local function PreGamemodeLoaded()
	if hl=="fr" then
		local ListWeapon = list.GetForEdit( "Weapon" )
		local function TranslateWeaponName( class, PrintName )
			local SWEP = weapons.GetStored( class )
			if SWEP then
				SWEP.PrintName = PrintName
				weapons.Register( SWEP, class )
			elseif ListWeapon[class] then
				ListWeapon[class].PrintName = PrintName
			end
		end
		local ListEntity = list.GetForEdit( "SpawnableEntities" )
		local function TranslateEntityName( class, PrintName )
			local ENT = scripted_ents.GetStored( class )
			if ENT then
				ENT = ENT.t
				ENT.PrintName = PrintName
				scripted_ents.Register( ENT, class )
			elseif ListEntity[class] then
				ListEntity[class].PrintName = PrintName
			end
		end
		local ListVehicle = list.GetForEdit( "Vehicles" )
		local function TranslateVehicleName( identifier, PrintName )
			if ListVehicle[identifier] then
				ListVehicle[identifier].Name = PrintName
			end
		end
		-- DarkRP
		TranslateWeaponName( "arrest_stick", "B√¢ton d'arrestation" )
		TranslateWeaponName( "door_ram", "B√©lier" )
		TranslateWeaponName( "keys", "Cl√©s" )
		TranslateWeaponName( "lockpick", "Crochet de serrurier" )
		TranslateWeaponName( "ls_sniper", "Sniper silencieux" )
		TranslateWeaponName( "med_kit", "√âquipement m√©dical" )
		TranslateWeaponName( "pocket", "Poche" )
		TranslateWeaponName( "stunstick", "Matraque √©lectrique" )
		TranslateWeaponName( "unarrest_stick", "B√¢ton de lib√©ration" )
		TranslateWeaponName( "weapon_keypadchecker", "Contr√¥leur de Clavier d'Admin" )
		TranslateWeaponName( "weapon_pumpshotgun2", "Fusil √† pompe" )
		TranslateWeaponName( "weaponchecker", "Contr√¥leur d'Armes" )
		-- Sandbox
		TranslateWeaponName( "gmod_tool", "Pistolet d'Outil" )
		TranslateWeaponName( "gmod_camera", "Appareil photo" )
		TranslateWeaponName( "manhack_welder", "Pistolet √† Manhacks" )
		TranslateEntityName( "edit_sun", "√âditeur de Soleil" )
		TranslateEntityName( "edit_sky", "√âditeur de Ciel" )
		TranslateEntityName( "edit_fog", "√âditeur de Brouillard" )
		-- Garry's Mod
		TranslateEntityName( "sent_ball", "Boule Rebondissante" )
		TranslateWeaponName( "weapon_physgun", "Pistolet Physique" )
		TranslateWeaponName( "weapon_fists", "Poings" )
		TranslateWeaponName( "weapon_medkit", "√âquipement M√©dical" )
		TranslateWeaponName( "weapon_flechettegun", "Pistolet √† Fl√©chettes" )
		TranslateVehicleName( "Jeep", "Buggy" )
		TranslateVehicleName( "Airboat", "Hydroglisseur" )
		TranslateVehicleName( "Pod", "Capsule" )
		TranslateVehicleName( "Jalopy", "Guimbarde" )
		TranslateVehicleName( "Chair_Wood", "Chaise de Bois" )
		TranslateVehicleName( "Chair_Plastic", "Chaise de Plastique" )
		TranslateVehicleName( "Seat_Jeep", "Si√®ge de Buggy" )
		TranslateVehicleName( "Seat_Airboat", "Si√®ge d'Hydroglisseur" )
		TranslateVehicleName( "Chair_Office1", "Chaise de Bureau" )
		TranslateVehicleName( "Chair_Office2", "Grande Chaise de Bureau" )
		TranslateVehicleName( "Seat_Jalopy", "Si√®ge de Guimbarde" )
		TranslateVehicleName( "phx_seat", "Si√®ge de Voiture" )
		TranslateVehicleName( "phx_seat2", "Si√®ge de Voiture 2" )
		TranslateVehicleName( "phx_seat3", "Si√®ge de Voiture 3" )
		-- Half-Life 2
		TranslateWeaponName( "weapon_357", "Magnum¬†357" )
		TranslateWeaponName( "weapon_ar2", "Fusil √† Impulsion" )
		TranslateWeaponName( "weapon_bugbait", "Ph√©ropode" )
		TranslateWeaponName( "weapon_crossbow", "Arbal√®te" )
		TranslateWeaponName( "weapon_crowbar", "Pied-de-biche" )
		TranslateWeaponName( "weapon_physcannon", "Pistolet Anti-Gravit√©" )
		TranslateWeaponName( "weapon_frag", "Grenade √† Fragmentation" )
		TranslateWeaponName( "weapon_pistol", "Pistolet 9mm" )
		TranslateWeaponName( "weapon_rpg", "Lance-Roquettes" )
		TranslateWeaponName( "weapon_shotgun", "Fusil √† Pompe" )
		TranslateWeaponName( "weapon_slam", "Mine T√©l√©command√©e" )
		TranslateWeaponName( "weapon_smg1", "Fusil Mitrailleur" )
		TranslateWeaponName( "weapon_stunstick", "Matraque √©lectrique" )
		TranslateEntityName( "item_ammo_ar2", "Munitions d'Impulsion" )
		TranslateEntityName( "item_ammo_pistol", "Munitions de Pistolet" )
		TranslateEntityName( "item_box_buckshot", "Munitions de Fusil √† Pompe" )
		TranslateEntityName( "item_ammo_357", "Munitions 357" )
		TranslateEntityName( "item_ammo_smg1", "Munitions de FM" )
		TranslateEntityName( "item_ammo_ar2_altfire", "Boule de Combine" )
		TranslateEntityName( "item_ammo_crossbow", "Rouleaux d'Arbal√®te" )
		TranslateEntityName( "item_ammo_smg1_grenade", "Grenade de FM" )
		TranslateEntityName( "item_rpg_round", "Roquette" )
		TranslateEntityName( "item_battery", "Batterie de Combinaison" )
		TranslateEntityName( "item_healthvial", "Fiole de Sant√©" )
		TranslateEntityName( "item_healthkit", "√âquipement de Sant√©" )
		TranslateEntityName( "item_suitcharger", "Chargeur de Combinaison" )
		TranslateEntityName( "item_healthcharger", "Chargeur de Sant√©" )
		TranslateEntityName( "item_suit", "Combinaison" )
		TranslateEntityName( "prop_thumper", "Frappeur violent" )
		TranslateEntityName( "combine_mine", "Mine de Combine" )
		TranslateEntityName( "grenade_helicopter", "Grenade d'H√©licopt√®re" )
		TranslateEntityName( "npc_grenade_frag", "Grenade de Zombine" )
		TranslateEntityName( "weapon_striderbuster", "Magnusson" )
	end
end
hook.Add( "PreGamemodeLoaded", "darkrp_translation_fr", PreGamemodeLoaded )

local function InitPostEntity()
	if DarkRP then
		if hl=="fr" and DarkRP.getChatCommands and DarkRP.getChatCommandDescription and DarkRP.addChatCommandsLanguage then
			local translated
			local len
			for command,tbl in pairs( DarkRP.getChatCommands() ) do
				translated = DarkRP.getChatCommandDescription( command )
				if tbl.description and ( not translated or tbl.description==translated ) then
					if string.sub( tbl.description, 1, 7 )=="Become " then
						len = string.len( tbl.description )
						if string.sub( tbl.description, len-18, len )~=" and skip the vote." then
							translated = "Devenir "..string.sub( tbl.description, 8 )
						else
							translated = "Devenir "..string.sub( tbl.description, 8, len-19 ).." et passer le vote."
						end
						DarkRP.addChatCommandsLanguage( "fr", {[command]=translated} )
					elseif string.sub( tbl.description, 1, 15 )=="Vote to become " then
						translated = "Voter pour devenir "..string.sub( tbl.description, 16 )
						DarkRP.addChatCommandsLanguage( "fr", {[command]=translated} )
					end
				end
			end
		end
	end
end
hook.Add( "InitPostEntity", "darkrp_translation_fr", InitPostEntity )

local loading = false
hook.Add( "OnReloaded", "darkrp_translation_fr", function()
	if not loading then
		loading = true -- prevent multiple reloads (only accept 2nd OnReloaded event)
	else
		loading = false
		DarkRPFinishedLoading()
		InitPostEntity()
	end
end )

--PATH lua/drgbase/spawners.lua:

-- Registry --

function DrGBase.AddSpawner(ENT)
	local class = string.Replace(ENT.Folder, "entities/", "")
	if ENT.PrintName == nil or ENT.Category == nil then return false end
	if SERVER then resource.AddFile("materials/entities/"..class..".png")
	else language.Add(class, ENT.PrintName) end
	local spawner = {
		Name = ENT.PrintName,
		Class = class,
		Category = ENT.Category
	}
	if ENT.Spawnable ~= false then
		list.Set("NPC", class, spawner)
		list.Set("DrGBaseSpawners", class, spawner)
	end
	DrGBase.Print("Spawner '"..class.."': loaded.")
	return true
end

hook.Add("PopulateDrGBaseSpawnmenu", "AddDrGBaseSpawners", function(pnlContent, tree, node)
	local list = list.Get("DrGBaseSpawners")
	local categories = {}
	for class, ent in pairs(list) do
		local category = ent.Category or "Other"
		local tab = categories[category] or {}
		tab[class] = ent
		categories[category] = tab
	end
	local nextbotsTree = tree:AddNode("Spawners", "icon16/box.png")
	for categoryName, category in SortedPairs(categories) do
		local icon = DrGBase.GetIcon(categoryName) or "icon16/box.png"
		if categoryName == "DrGBase" then icon = DrGBase.Icon end
		local node = nextbotsTree:AddNode(categoryName, icon)
		node.DoPopulate = function(self)
			if self.PropPanel then return end
			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)
			self.PropPanel:SetTriggerSpawnlistChange(false)
			for class, ent in SortedPairsByMemberValue(category, "Name") do
				spawnmenu.CreateContentIcon("npc", self.PropPanel, {
					nicename	= ent.Name or class,
					spawnname	= class,
					material = "entities/"..class..".png",
					admin	= ent.AdminOnly or false
				})
			end
		end
		node.DoClick = function(self)
			self:DoPopulate()
			pnlContent:SwitchPanel(self.PropPanel)
		end
	end
	local firstNode = tree:Root():GetChildNode(0)
	if IsValid(firstNode) then
		firstNode:InternalDoClick()
	end
end)

if SERVER then

	function DrGBase.CreateSpawner(pos, tospawn, radius, quantity, class)
		local spawner = ents.Create(class or "spwn_drg_default")
		if not IsValid(spawner) then return NULL end
		if isvector(pos) then spawner:SetPos(pos) end
		spawner:Spawn()
		spawner:SetRadius(radius)
		spawner:SetQuantity(quantity)
		if istable(tospawn) then
			for class, nb in pairs(tospawn) do
				spawner:AddToSpawn(class, nb)
			end
		else spawner:AddToSpawn(tospawn) end
		return spawner
	end

end

--PATH lua/drgbase/modules/coroutine.lua:

local INCR_ID = 0
local COROUTINES = {}
hook.Add("Think", "DrGBaseCoroutines", function()
	for id, todo in pairs(COROUTINES) do
		local status = coroutine.status(todo.cor)
		if status == "suspended" then
			local ok, args = coroutine.resume(todo.cor)
			if coroutine.status(todo.cor) == "dead" and
			isfunction(todo.call) then
				todo.call(ok, args)
			end
		elseif status == "dead" then
			coroutine.DrG_Remove(id)
		end
	end
end)

function coroutine.DrG_Create(todo, call)
	local cor = coroutine.create(todo)
	local id = INCR_ID
	INCR_ID = INCR_ID+1
	COROUTINES[id] = {
		cor = cor, call = call
	}
	return cor, id
end
function coroutine.DrG_Remove(id)
	COROUTINES[id] = nil
end

--PATH lua/drgbase/modules/math.lua:
-- Misc --

function math.DrG_Cycle(min, max, rate, offset)
	if not isnumber(min) then min = 0 end
	if not isnumber(max) then max = min+1 end
	if min > max then return math.DrG_Cycle(max, min, rate, offset) end
	local pi2 = math.pi*2
	return (((math.sin(((CurTime()-(offset or 0))*pi2*(rate or 1))%pi2)+1)/2)*(max-min))+min
end

--PATH lua/drgbase/modules/string.lua:

function string.DrG_Number(nb, size)
	nb = tostring(nb)
	while #nb < size do
		nb = "0"..nb
	end
	return nb
end

--PATH addons/sm_weapon_selector/lua/autorun/eliteswephud_loader.lua:
--[[
    Addon : EliteWeaponSelector
    By : Esteb
	Support : !Esteb.#6666
	Version : 2.0
--]]

--[[
‚ïî‚ïê‚ïó‚ïî‚ïê‚ïó‚ïî‚ïê‚ïó  ‚ïî‚ï¶‚ïó‚ïî‚ïê‚ïó  ‚ïî‚ïê‚ïó‚ïî‚ïê‚ïó‚ïî‚ïó‚ïî‚ïî‚ïê‚ïó‚ï¶‚ïî‚ïê‚ïó  ‚ï¶‚ïî‚ïê‚ïó‚ï¶
‚ï†‚ïê‚ïù‚ï†‚ïê‚ï£‚ïö‚ïê‚ïó   ‚ïë‚ïë‚ïë‚ï£   ‚ïë  ‚ïë ‚ïë‚ïë‚ïë‚ïë‚ï†‚ï£ ‚ïë‚ïë ‚ï¶  ‚ïë‚ïë  ‚ïë
‚ï©  ‚ï© ‚ï©‚ïö‚ïê‚ïù  ‚ïê‚ï©‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïù‚ïö‚ïù‚ïö  ‚ï©‚ïö‚ïê‚ïù  ‚ï©‚ïö‚ïê‚ïù‚ï©
--]]

include("eliteswephud/sh_config.lua");

if (SERVER) then 

	AddCSLuaFile("eliteswephud/sh_config.lua");
	AddCSLuaFile("eliteswephud/cl_hud.lua");
else 

	include("eliteswephud/cl_hud.lua");
end
--PATH lua/gmodadminsuite/modules/commands/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Command Manager",

		no_permission = "D√©sol√©, mais vous n'avez pas la permission d'utiliser cette commande.",
		commands = "Commandes",
		command = "Commande",
		action = "Action",
		help = "Aide",
		new_command = "+ Nouvelle Commande",
		wiki = "Wiki",
		run_command = "Executer Commande",
		edit_command = "Modifier Commande",
		form_help = "Texte d'Assistance... (facultatif)",
		form_help_tip = "C'est le texte qui sera affich√© dans le menu des commandes, dans le colonne \"Aide\".",
		select_action = "Selectionnez une Action...",
		hide_in_chat = "Masquer dans le chat ?",
		hide_in_chat_tip = "Si coch√©, le commande ne sera pas affich√© dans le chat lorsque quelqu'un l'√©crira.",
		finished = "Termin√©",
		commands_case_insensitive = "Toutes les commandes ne sont pas sensibles aux majuscules.",
		ok = "OK",
		cannot_create_command = "Impossible de cr√©er la commande !",
		cancel = "Annuler",
		delete_command = "Supprimer Commander",
		copy_command = "Copier Commande",
		permissions = "Permissions",
		permissions_editor = "Ouvrir l'Editeur de Permissions",
		permissions_tip = "Vous autorise √† whitelister et blacklister les groupes d'utilisateurs et les √©quipes/m√©tiers.",
		can_access_command = "Peu acc√©der √† la commande",
		teams = "Equipes",
		usergroups = "Groupes d'Utilisateurs",
		anyone_can_access = "N'importe qui peut acc√©der √† cette commande",
		whitelisted_only = "Seuls les membres whitelist√©s peuvent acc√©der √† cette commande",
		non_blacklisted_only = "Seuls les membres non-blacklist√©s peuvent acc√©der √† cette commande",
		whitelisted_and_blacklisted = "Seuls les membres whitelist√©s (except√© les blacklist√©s) peuvent acc√©der √† cette commande",
		custom_usergroup = "+ Groupe d'Utilisateurs Custom",
		custom_usergroup_text = "Entrez groupe d'utilisateurs",
		custom_usergroup_placeholder = "Groupe d'Utilisateurs...",
		reason_usergroup_blacklisted = "Votre groupe d'utilisateurs est blacklist√© sur cette commande.",
		reason_usergroup_not_whitelisted = "Votre group d'utilisateur n'est pas whitelist√© sur cette commande.",
		reason_team_blacklisted = "Votre √©quipe est blacklist√©e sur cette commande.",
		reason_team_not_whitelisted = "Votre √©quipe n'est pas whitelist√©e sur cette commande.",
		saved_exclamation = "Sauvegard√© !",
		set_position = "D√©finir Position",
		position_set = "Position D√©finie !",
		set_position_instruction = "Go to the desired position and face in the desired direction",
		set_position_instruction_2 = "When finished, unpin the menu and the position and angle will then be saved",

		action_open_commands_menu = "Ouvrir le menu des commandes",
		action_command = "Executer commande console",
		action_chat = "Envoyer un message textuel",
		action_website = "Ouvrir Site Web",
		action_lua_function_sv = "Fonction Lua Client",
		action_lua_function_cl = "Fonction Lua Serveur",
		action_gas_module = "Ouvrir Module GAS",
		action_teleport = "T√©l√©portation",

		form_action_command = "Commande console √† √©x√©cuter",
		form_action_chat = "Message textuel √† envoyer",
		form_action_website = "Site Web √† ouvrir",
		form_action_lua_function_sv = "Fonction Lua √† √©x√©cuter\nC√¥t√© Serveur",
		form_action_lua_function_cl = "Fonction Lua √† √©x√©cuter\nC√¥t√© Client",
		form_action_gas_module = "Module GAS √† ouvrir",
		form_action_teleport = "T√©l√©portation",

		error_command_exists = "Une commande avec ce nom existe d√©j√† !",
		error_no_command = "Vous n'avez entr√© aucune commande.",
		error_no_command_execute = "Vous n'avez pas entr√© la commande √† √©x√©cuter.",
		error_no_action = "Vous n'avez pas s√©l√©ctionn√© d'action pour cette commande.",
		error_invalid_website = "Le site web sp√©cifi√© n'est pas une adresse valide.",
		error_no_lua_function = "Vous n'avez pas s√©l√©ctionn√© de Fonction Lua √† √©x√©cuter.",
		error_no_gas_module = "Vous n'avez pas s√©l√©ctionn√© de module GAS √† ouvrir.",
		error_no_position_set = "Vous n'avez pas sp√©cifi√© de position et d'angle pour cette t√©l√©portation.",

} end }
--PATH lua/gmodadminsuite/modules/playerdatabase/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Player Database",

		right_click_to_focus    = "Right click to focus",
		steamid                 = "SteamID",
		name                    = "Name",
		usergroup               = "Usergroup",
		ip_address              = "IP Address",
		last_seen               = "Last Seen",
		copy_steamid            = "Copy SteamID",
		copy_steamid64          = "Copy SteamID64",
		copy_usergroup          = "Copy Usergroup",
		copy_ip_address         = "Copy IP Address",
		copy_name               = "Copy Name",
		copy_steam_profile_link = "Copy Steam Profile Link",
		search                  = "Search",
		country                 = "Country",
		copy_country            = "Copy Country",
		search_usergroup        = "Search Usergroup",
		search_ip_address       = "Search IP Address",
		search_country          = "Search Country",
		search_name             = "Search Name",
		none                    = "< none >",
		cancel                  = "Cancel",
		steamid                 = "SteamID",

} end }
--PATH lua/gmodadminsuite/modules/commands/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Command Manager",
	Category = GAS.MODULE_CATEGORY_UTILITIES,
	OperatorOnly = true,
	Wiki = "https://gmodsto.re/gmodadminsuite-commands-wiki",
	Icon = "icon16/script_gear.png",
}
--PATH lua/gmodadminsuite/modules/fpsbooster/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("cl_menu.lua")
else
	GAS:hook("gmodadminsuite:LoadModule:fpsbooster", "LoadModule:fpsbooster", function()
		include("gmodadminsuite/modules/fpsbooster/cl_menu.lua")
	end)
end
--PATH lua/gmodadminsuite/cl_selection_prompts.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.SelectionPrompts = {}

function GAS.SelectionPrompts:PromptTeam(callback, _menu, muted)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()

	if (DarkRP) then
		local categories = {}
		for i,c in ipairs(DarkRP.getCategories().jobs) do
			if (GAS:table_IsEmpty(c.members)) then continue end
			table.insert(categories, {members = c.members, name = c.name, color = c.color})
		end
		table.SortByMember(categories, "name", true)
		for i,v in ipairs(categories) do
			local submenu, _submenu = menu:AddSubMenu(v.name)
			bVGUI_DermaMenuOption_ColorIcon(_submenu, v.color)

			local teams = {}
			for i,t in ipairs(v.members) do
				table.insert(teams, {index = t.team, name = t.name})
			end
			table.SortByMember(teams, "name", true)
			for i,v in ipairs(teams) do
				bVGUI_DermaMenuOption_ColorIcon(submenu:AddOption(v.name, function()
					callback(v.index)
					if (not muted) then GAS:PlaySound("btn_heavy") end
				end), team.GetColor(v.index))
			end
		end
	else
		local teams = {}
		for i,t in ipairs(team.GetAllTeams()) do
			table.insert(teams, {index = i, name = t.Name})
		end
		table.SortByMember(teams, "name", true)
		for i,v in ipairs(teams) do
			bVGUI_DermaMenuOption_ColorIcon(menu:AddOption(v.name, function()
				callback(v.index)
				if (not muted) then GAS:PlaySound("btn_heavy") end
			end), team.GetColor(v.index))
		end
	end

	if (not _menu) then	menu:Open() end
end

function GAS.SelectionPrompts:PromptLuaFunction(callback, _menu, muted)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()
	local lua_function_names = table.GetKeys(GAS.LuaFunctions)
	table.sort(lua_function_names)
	for i,lua_function_name in ipairs(lua_function_names) do
		bVGUI_DermaMenuOption_GreenToRed(i, #lua_function_names, menu:AddOption(lua_function_name, function()
			callback(lua_function_name, GAS.LuaFunctions[lua_function_name])
			if (not muted) then GAS:PlaySound("btn_heavy") end
		end))
	end
	if (not _menu) then	menu:Open() end
end

function GAS.SelectionPrompts:PromptUsergroup(callback, _menu, muted)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()
	menu:AddOption(L"custom_ellipsis", function()
		bVGUI.StringQuery(L"add_usergroup", nil, L"usergroup_ellipsis", function(usergroup)
			callback(usergroup)
		end)
	end):SetIcon("icon16/pencil.png")
	menu:AddSpacer()
	local usergroups = {}
	for _,ply in ipairs(player.GetHumans()) do
		for v in pairs(OpenPermissions:GetUserGroups(ply)) do
			usergroups[v] = true
		end
	end
	usergroups = table.GetKeys(usergroups)
	table.sort(usergroups)
	for i,v in ipairs(usergroups) do
		bVGUI_DermaMenuOption_GreenToRed(i, #usergroups, menu:AddOption(v, function()
			callback(v)
			if (not muted) then GAS:PlaySound("btn_heavy") end
		end))
	end
	if (not _menu) then	menu:Open() end
end

function GAS.SelectionPrompts:PromptSteamID64(callback, _menu, muted)
	print("PromptSteamID64 is deprecated")
	GAS.SelectionPrompts:PromptAccountID(function(account_id, ...)
		callback(GAS:AccountIDToSteamID64(account_id, ...))
	end, _menu, play_sound)
end

function GAS.SelectionPrompts:PromptAccountID(callback, _menu, muted, filter)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()
	menu:AddOption(L"steamid_ellipsis", function()
		bVGUI.StringQuery(L"add_steamid", L("add_steamid_help", LocalPlayer():SteamID(), LocalPlayer():SteamID64()), L"enter_steamid_ellipsis", function(text)
			if (text:find("^STEAM_%d:%d:%d+$")) then
				local ply = player.GetBySteamID(text)
				if (IsValid(ply)) then
					callback(GAS:SteamIDToAccountID(text), ply)
				else
					callback(GAS:SteamIDToAccountID(text))
				end
			elseif (text:find("^7656119%d+$")) then
				local ply = player.GetBySteamID64(text)
				if (IsValid(ply)) then
					callback(GAS:SteamID64ToAccountID(text), ply)
				else
					callback(GAS:SteamID64ToAccountID(text))
				end
			end
		end, function(text)
			if (text:find("^STEAM_%d:%d:%d+$") or text:find("^7656119%d+$")) then
				return true
			end
		end)
	end):SetIcon("materials/gmodadminsuite/steam.png")
	menu:AddSpacer()

	local distance_submenu, pnl = menu:AddSubMenu(L"by_distance") pnl:SetIcon("icon16/world.png")
	local usergroups_submenu, pnl = menu:AddSubMenu(L"by_usergroup") pnl:SetIcon("icon16/group.png")
	local jobs_submenu, pnl = menu:AddSubMenu(L"by_team") pnl:SetIcon("icon16/user_suit.png")
	local players_submenu, pnl = menu:AddSubMenu(L"by_name") pnl:SetIcon("icon16/emoticon_grin.png")

	local stuff_to_add = {
		usergroups = {},
		jobs = {},
		players = {},
		distances = {}
	}
	for _,ply in ipairs(player.GetHumans()) do
		if (filter and filter[ply]) then continue end
		
		table.insert(stuff_to_add.players, {account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})
		table.insert(stuff_to_add.distances, {distance = ply:GetPos():DistToSqr(LocalPlayer():GetPos()), account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})

		local team_name = team.GetName(ply:Team())
		stuff_to_add.jobs[team_name] = stuff_to_add.jobs[team_name] or {}
		table.insert(stuff_to_add.jobs[team_name], {account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})

		for v in pairs(OpenPermissions:GetUserGroups(ply)) do
			stuff_to_add.usergroups[v] = stuff_to_add.usergroups[v] or {}
			table.insert(stuff_to_add.usergroups[v], {account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})
		end
	end

	local usergroups = table.GetKeys(stuff_to_add.usergroups)
	table.sort(usergroups)
	local jobs = table.GetKeys(stuff_to_add.jobs)
	table.sort(jobs)
	local players = stuff_to_add.players
	table.SortByMember(players, "nick")
	local distances = stuff_to_add.distances
	table.SortByMember(distances, "distance")

	local function PlayerInfoOverlay(option, ply)
		function option:OnCursorEntered()
			if (not IsValid(ply)) then return end
			bVGUI.PlayerTooltip.Create({
				canfocus = false,
				player = ply,
				copiedphrase = L"copied",
				focustip = L"right_click_to_focus",
				creator = self
			})
		end
		function option:OnCursorExited()
			bVGUI.PlayerTooltip.Close()
		end
		option.OnMouseReleased_Old = option.OnMouseReleased
		function option:OnMouseReleased(mouse)
			if (mouse == MOUSE_RIGHT) then
				bVGUI.PlayerTooltip.Focus()
			end
			option:OnMouseReleased_Old(mouse)
		end
	end
	for _,ply in ipairs(distances) do
		local option = distance_submenu:AddOption(ply.nick, function()
			if (not muted) then GAS:PlaySound("btn_heavy") end
			callback(ply.account_id, ply.ply)
		end)
		bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
		PlayerInfoOverlay(option, ply.ply)
	end
	for _,ply in ipairs(players) do
		local option = players_submenu:AddOption(ply.nick, function()
			if (not muted) then GAS:PlaySound("btn_heavy") end
			callback(ply.account_id, ply.ply)
		end)
		bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
		PlayerInfoOverlay(option, ply.ply)
	end
	for i,usergroup in ipairs(usergroups) do
		local submenu, _ = usergroups_submenu:AddSubMenu(usergroup)
		bVGUI_DermaMenuOption_GreenToRed(i, #usergroups, _)
		table.SortByMember(stuff_to_add.usergroups[usergroup], "nick")
		for _,ply in ipairs(stuff_to_add.usergroups[usergroup]) do
			local option = submenu:AddOption(ply.nick, function()
				if (not muted) then GAS:PlaySound("btn_heavy") end
				callback(ply.account_id, ply.ply)
			end)
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
			PlayerInfoOverlay(option, ply.ply)
		end
	end
	for _,job in ipairs(jobs) do
		local submenu, submenu_option = jobs_submenu:AddSubMenu(job)
		bVGUI_DermaMenuOption_ColorIcon(submenu_option, team.GetColor(GAS:TeamFromName(job)))
		table.SortByMember(stuff_to_add.jobs[job], "nick")
		for _,ply in ipairs(stuff_to_add.jobs[job]) do
			local option = submenu:AddOption(ply.nick, function()
				if (not muted) then GAS:PlaySound("btn_heavy") end
				callback(ply.account_id, ply.ply)
			end)
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
			PlayerInfoOverlay(option, ply.ply)
		end
	end

	if (not _menu) then	menu:Open() end
end
--PATH lua/gmodadminsuite/cl_menu.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.LocalConfig = GAS:GetLocalConfig("gas", {
	AllowVoiceChat = true,
	DefaultModule = false,
	ClosePlayerPopups = false
})

GAS:netReceive("menu_nopermission", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_nopermission", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_unknown_module", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_unknown_module", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_disabled_module", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_disabled_module", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_module_nopermission", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_module_nopermission", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)

concommand.Add("gmodadminsuite", function(_, __, args)
	if (#args == 0) then
		GAS:netStart("menu_open")
			net.WriteString("")
		net.SendToServer()
	else
		if (args[1] == "reload") then
			GAS:Init()
		elseif (args[1] == "screenclicker") then
			gui.EnableScreenClicker(true)
		else
			GAS:netStart("menu_open")
				net.WriteString(args[1])
			net.SendToServer()
		end
	end
end, function(cmd, args)
	local arg = string.TrimLeft(args)
	local tbl = {}
	local is_operator = OpenPermissions:IsOperator(LocalPlayer())
	for module_name, module_data in pairs(GAS.Modules.Info) do
		if (module_data.OperatorOnly and not is_operator) then continue end
		if (arg and #string.Trim(arg) > 0) then
			if (not module_name:lower():find(string.Trim(arg):lower())) then
				continue
			end
		end
		table.insert(tbl, cmd .. " " .. module_name)
	end
	table.sort(tbl)
	table.insert(tbl, 1, cmd .. " reload")
	table.insert(tbl, 2, cmd .. " screenclicker")
	return tbl
end)

function GAS:OpenModuleFrame(module_name)
	if (IsValid(GAS.ModuleFrame)) then
		GAS.ModuleFrame:Close()
	end

	if (IsValid(GAS.Menu)) then
		if (GAS.Menu.Modules.IndexedItems[module_name]) then
			GAS.Menu.Modules.IndexedItems[module_name]:SetActive(true)
		end
	end

	GAS.ModuleFrame = vgui.Create("bVGUI.Frame")
	GAS.ModuleFrame.ModuleName = module_name
	local w, h = 1200, 700
	if (ScrW() < w or ScrH() < h) then
		w = ScrW()
		h = ScrH()
	end
	GAS.ModuleFrame:SetSize(w,h)
	GAS.ModuleFrame:MakePopup()
	GAS.ModuleFrame:SetTitle(GAS.Modules:GetFriendlyName(module_name))
	GAS.ModuleFrame:SetVisible(false)

	GAS.ModuleFrame.DragThink = GAS.ModuleFrame.Think
	function GAS.ModuleFrame:Think()
		self:DragThink()
		if (IsValid(GAS.Menu)) then
			self.bVGUI_FullscreenButton.OffsetX = 200

			local x_1, y_1, w_1, h_1 = self:GetBounds()
			GAS.Menu:SetPos(x_1 - 200 + 1, y_1)
			GAS.Menu:SetSize(200, h_1)
		else
			self.bVGUI_FullscreenButton.OffsetX = nil
		end
	end

	function GAS.ModuleFrame:OnClose()
		local x, y = self:GetPos()
		cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_x_" .. ScrW(), x)
		cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_y_" .. ScrH(), y)
	end

	function GAS.ModuleFrame:DermaMenuOptions(menu)
		if (not IsValid(GAS.Menu)) then
			menu:AddOption(L"open_gas", function()
				GAS:PlaySound("jump")
				GAS:OpenMenu()
			end):SetIcon("icon16/application_home.png")
		end

		menu:AddOption(L"close", function()
			if IsValid(self) then
				GAS.ModuleFrame:Remove()
			end
		end):SetIcon("icon16/cancel.png")

		menu:AddOption(L"module_shortcut", function()
			GAS:PlaySound("flash")
			bVGUI.RichMessage({
				title = L"module_shortcut",
				button = "OK",
				textCallback = function(richtext)
					local highlight_col = {0,255,255,255}
					local phrase = string.Explode("%s", GAS:Phrase("module_shortcut_info"))
					richtext:AppendText(phrase[1])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("gmodadminsuite " .. module_name)

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[2])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText(GAS.Config.ChatCommand .. " " .. module_name)

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[3])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("bind KEY \"gmodadminsuite " .. module_name .. "\"")

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[4])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("https://developer.valvesoftware.com/wiki/Bind#Special_Keys")
				end
			})
		end):SetIcon("icon16/star.png")

		menu:AddOption(L"module_reset_data", function()
			GAS:PlaySound("flash")
			if IsValid(self) then
				self:SetSize(self.RealSize[1], self.RealSize[2])
				self:Center()
				local x, y = self:GetPos()
				cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_x_" .. ScrW(), x)
				cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_y_" .. ScrH(), y)
				cookie.Set("gmodadminsuite_module_" .. module_name .. "_w", self:GetWide())
				cookie.Set("gmodadminsuite_module_" .. module_name .. "_h", self:GetTall())
			end
		end):SetIcon("icon16/arrow_rotate_clockwise.png")

		if (GAS.Modules.Info[module_name].ScriptPage) then
			menu:AddOption(L"script_page", function()
				GAS:OpenURL(GAS.Modules.Info[module_name].ScriptPage)
			end):SetIcon("icon16/page_code.png")
		end

		if (GAS.Modules.Info[module_name].Wiki) then
			menu:AddOption(L"wiki", function()
				GAS:OpenURL(GAS.Modules.Info[module_name].Wiki)
			end):SetIcon("icon16/book.png")
		end

		if (GAS.ModuleFrame.Extra_DermaMenuOptions) then
			GAS.ModuleFrame:Extra_DermaMenuOptions(menu)
		end
	end

	-- would use file.IsDir, but: https://github.com/Facepunch/garrysmod-issues/issues/3592
	local _,d = file.Find("gmodadminsuite/modules/*", "LUA")
	if (table.HasValue(d, module_name) and not GAS.Modules:IsModuleLoaded(module_name)) then
		GAS.Modules:LoadModule(module_name)
	end

	local real_w, real_h = hook.Run("gmodadminsuite:ModuleSize:" .. module_name)

	w = math.min(cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_w", real_w), ScrW())
	h = math.min(cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_h", real_h), ScrH())

	GAS.ModuleFrame:SetSize(w,h)
	GAS.ModuleFrame:SetMinimumSize(real_w, real_h)
	GAS.ModuleFrame:Center()
	GAS.ModuleFrame:SetVisible(true)

	local new_x = cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_x_" .. ScrW(), false)
	local new_y = cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_y_" .. ScrH(), false)
	local cur_x, cur_y = GAS.ModuleFrame:GetPos()

	GAS.ModuleFrame:SetPos(new_x or cur_x, new_y or cur_y)

	GAS.ModuleFrame.OpenModule = module_name
	GAS.ModuleFrame.RealSize = {
		real_w,
		real_h
	}

	hook.Run("gmodadminsuite:ModuleFrame:" .. module_name, GAS.ModuleFrame)

	GAS.ModuleFrame:EnableUserResize()

	function GAS.ModuleFrame:OnResize(new_w, new_h)
		cookie.Set("gmodadminsuite_module_" .. module_name .. "_w", new_w)
		cookie.Set("gmodadminsuite_module_" .. module_name .. "_h", new_h)
	end

	return GAS.ModuleFrame
end

local logo_mat = Material("gmodadminsuite/gmodadminsuite.vtf")
local function OpenMenu()
	local is_operator = OpenPermissions:IsOperator(LocalPlayer())

	GAS.Menu = vgui.Create("bVGUI.Frame")
	GAS.Menu:ShowFullscreenButton(false)
	GAS.Menu:SetSize(800,500)
	GAS.Menu:SetTitle("GmodAdminSuite " .. GAS.Version)
	GAS.Menu:Center()
	GAS.Menu:MakePopup()

	if (IsValid(GAS.ModuleFrame) and GAS.ModuleFrame.Fullscreened) then
		GAS.ModuleFrame.bVGUI_FullscreenButton.OffsetX = 200
		GAS.ModuleFrame:Stop()
		GAS.ModuleFrame:SizeTo(ScrW() - 200, ScrH(), 0.5, 0, 0.5)
		GAS.ModuleFrame:MoveTo(200,0, 0.5, 0, 0.5)
	end
	function GAS.Menu:OnClose()
		if (IsValid(GAS.ModuleFrame) and GAS.ModuleFrame.Fullscreened) then
			GAS.ModuleFrame:Stop()
			GAS.ModuleFrame:SizeTo(ScrW(), ScrH(), 0.5, 0, 0.5)
			GAS.ModuleFrame:MoveTo(0, 0, 0.5, 0, 0.5)
		end
	end

	GAS.Menu.Modules = vgui.Create("bVGUI.Categories", GAS.Menu)
	GAS.Menu.Modules:Dock(LEFT)
	GAS.Menu.Modules:SetWide(200)
	GAS.Menu.Modules:SetDrawBackground(false)
	GAS.Menu.Modules.IndexedItems = {}

	GAS.Menu.Content = vgui.Create("bVGUI.BlankPanel", GAS.Menu)
	GAS.Menu.Content:Dock(FILL)
	function GAS.Menu.Content:PaintOver(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
		surface.DrawTexturedRect(0,0,10,h)
	end

	GAS.Menu.DragThink = GAS.Menu.Think
	function GAS.Menu:Think()
		self:DragThink()
		if (IsValid(GAS.ModuleFrame)) then
			self:SetTall(GAS.ModuleFrame:GetTall())
			if (self.Dragging) then
				local x,y = self:GetPos()
				GAS.ModuleFrame:SetPos(x + self:GetWide() - 1, y)
			end
		elseif (GAS.Menu:GetWide() ~= 800 or GAS.Menu:GetTall() ~= 500) then
			GAS.Menu:SetSize(800,500)
			GAS.Menu:Center()
			GAS.Menu.Modules:ClearActive()
		end
	end

	function GAS.Menu:DermaMenuOptions(menu)
		menu:AddOption(L"close", function()
			GAS.Menu:Close()
		end):SetIcon("icon16/cancel.png")
		menu:AddOption(L"website", function()
			GAS:OpenURL("https://gmodadminsuite.com")
		end):SetIcon("icon16/monitor.png")
		menu:AddOption(L"wiki", function()
			GAS:OpenURL("https://gmodsto.re/gmodadminsuite-wiki")
		end):SetIcon("icon16/book.png")
		-- menu:AddOption("Discord", function()
		-- 	GAS:OpenURL("https://gmodsto.re/gmodadminsuite-discord")
		-- end):SetIcon("materials/gmodadminsuite/discord.png")
	end

	local function SizeAndPosition(size_w, size_h, pos_x, pos_y)
		size_w = size_w + 200
		size_h = size_h + 24

		GAS.Menu:Stop()

		local anim = GAS.Menu:NewAnimation(0.5)
		anim.Size  = Vector(size_w, size_h, 0)
		anim.Think = function(anim, panel, fraction)
			if (not anim.StartSize) then
				local w, h = panel:GetSize()
				anim.StartSize = Vector(w, h, 0)
			end

			local size = LerpVector(fraction, anim.StartSize, anim.Size)
			panel:SetSize(size.x, size.y)
		end

		local anim = GAS.Menu:NewAnimation(0.5)
		anim.Pos   = Vector(pos_x or ((ScrW() / 2) - (size_w / 2)), pos_y or ((ScrH() / 2) - (size_h / 2)))
		anim.Think = function(anim, panel, fraction)
			if (not anim.StartPos) then
				local w, h = panel:GetPos()
				anim.StartPos = Vector(w, h, 0)
			end

			local size = LerpVector(fraction, anim.StartPos, anim.Pos)
			panel:SetPos(size.x, size.y)
		end
	end

	GAS.Menu.Tabs = vgui.Create("bVGUI.Tabs", GAS.Menu.Content)
	GAS.Menu.Tabs:Dock(TOP)
	GAS.Menu.Tabs:SetTall(40)

	local welcome_content = GAS.Menu.Tabs:AddTab(L"welcome", Color(76,216,76))

	GAS.Menu.Info = vgui.Create("bVGUI.BlankPanel", welcome_content)
	GAS.Menu.Info:Dock(FILL)

	GAS.Menu.Info.Logo = vgui.Create("DImage", GAS.Menu.Info)
	GAS.Menu.Info.Logo:SetMaterial(logo_mat)
	GAS.Menu.Info.Logo:SetSize(256,256)

	GAS.Menu.Info.ButtonContainer = vgui.Create("bVGUI.BlankPanel", GAS.Menu.Info)
	GAS.Menu.Info.ButtonContainer:SetSize(150,(30 * 3) + (10 * 2))

	local btn1 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn1:Dock(TOP)
	btn1:DockMargin(0,0,0,10)
	btn1:SetColor(bVGUI.BUTTON_COLOR_RED)
	btn1:SetText(L"website")
	function btn1:DoClick()
		GAS:OpenURL("https://gmodadminsuite.com")
	end

	local btn2 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn2:Dock(TOP)
	btn2:DockMargin(0,0,0,10)
	btn2:SetColor(bVGUI.BUTTON_COLOR_GREEN)
	btn2:SetText(L"wiki")
	function btn2:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-wiki")
	end

	local btn3 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn3:Dock(TOP)
	btn3:SetColor(Color(114, 137, 218))
	btn3:SetText("Discord")
	function btn3:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-discord")
	end

	GAS.Menu.Info.Copyright = vgui.Create("DLabel", GAS.Menu.Info)
	GAS.Menu.Info.Copyright:SetText("Copyright ¬© " .. os.date("%Y") .. " Billy Venner")
	GAS.Menu.Info.Copyright:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	GAS.Menu.Info.Copyright:SizeToContents()
	GAS.Menu.Info.Copyright:SetMouseInputEnabled(true)
	GAS.Menu.Info.Copyright:SetCursor("hand")
	GAS.Menu.Info.Copyright:SetTextColor(Color(255,255,255,10))
	function GAS.Menu.Info.Copyright:DoClick()
		GAS:OpenURL("https://steamcommunity.com/profiles/76561198040894045")
	end

	function GAS.Menu.Info:PerformLayout()
		self.Logo:SetPos(self:GetWide() / 2 - self.Logo:GetWide() / 2, self:GetTall() / 2 - self.Logo:GetTall() / 2 - 150 / 2 - 5)
		self.ButtonContainer:SetPos(self:GetWide() / 2 - self.ButtonContainer:GetWide() / 2, self:GetTall() / 2 + 5)
		self.Copyright:CenterHorizontal()
		self.Copyright:AlignBottom(10)
	end

	local settings_content, settings_tab = GAS.Menu.Tabs:AddTab(L"settings", Color(76,76,216))
	settings_tab:SetFunction(function()
		if (settings_content.Content) then
			PrintTable(settings_content.Content)
			for _,v in ipairs(settings_content.Content) do
				v:Remove()
			end
			settings_content.Content = {}
		else
			settings_content.Content = {}
		end

		local tabs = vgui.Create("bVGUI.Tabs", settings_content)
		tabs:Dock(TOP)
		tabs:SetTall(40)
		table.insert(settings_content.Content, tabs)

		local general_settings = tabs:AddTab(L"general", Color(216,76,76))
		local language_settings = tabs:AddTab(L"localization", Color(76,216,76))

		local general_settings_form = vgui.Create("bVGUI.Form", general_settings)
		general_settings_form:Dock(FILL)
		general_settings_form:DockMargin(15,15,15,15)
		general_settings_form:SetPaddings(15,15)

		local _,combobox = general_settings_form:AddComboBox(L"setting_default_module", nil, L"setting_default_module_tip", function(index, val, data)
			GAS.LocalConfig.DefaultModule = data
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)
		combobox:SetSortItems(false)
		combobox:AddChoice(L"none", false, not GAS.LocalConfig.DefaultModule, "icon16/cross.png")

		general_settings_form:AddSwitch(L"setting_menu_voicechat", GAS.LocalConfig.AllowVoiceChat, L"setting_menu_voicechat_tip", function(val)
			GAS.LocalConfig.AllowVoiceChat = val
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)

		general_settings_form:AddSwitch(L"settings_player_popup_close", GAS.LocalConfig.ClosePlayerPopups, L"settings_player_popup_close_tip", function(val)
			GAS.LocalConfig.ClosePlayerPopups = val
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)

		local language_settings_form = vgui.Create("bVGUI.Form", language_settings)
		language_settings_form:Dock(FILL)
		language_settings_form:DockMargin(15,15,15,15)
		language_settings_form:SetPaddings(15,15)

		language_settings_form:AddTextEntry(L"short_date_format", GAS.Languages.Config.ShortDateFormat or "", L"short_date_format_tip", function(val)
			if (#val == 0) then
				GAS.Languages.Config.ShortDateFormat = false
			else
				GAS.Languages.Config.ShortDateFormat = val
			end
		end, nil, L"default_format")

		language_settings_form:AddTextEntry(L"long_date_format", GAS.Languages.Config.LongDateFormat or "", L"long_date_format_tip", function(val)
			if (#val == 0) then
				GAS.Languages.Config.LongDateFormat = false
			else
				GAS.Languages.Config.LongDateFormat = val
			end
		end, nil, L"default_format")

		language_settings_form:AddSpacing(15)

		local function create_language_setting(module_name, info)
			local _,language_combobox = language_settings_form:AddComboBox(info.Name, nil, "", function(index, value, data)
				if (not data) then
					GAS.Languages.Config.SelectedLanguages[module_name] = nil
				else
					GAS.Languages.Config.SelectedLanguages[module_name] = data
				end
				GAS:SaveLocalConfig("languages", GAS.Languages.Config)
			end, info.Icon)
			language_combobox:SetSortItems(false)
			if (module_name ~= "GAS") then
				language_combobox:AddChoice(L"use_gas_language", false, GAS.Languages.Config.SelectedLanguages[module_name] == nil, "icon16/wand.png")
			end
			for language_name, language_info in pairs(GAS.Languages.LanguageData[module_name]) do
				local selected = false
				if (GAS.Languages.Config.SelectedLanguages[module_name] and GAS.Languages.Config.SelectedLanguages[module_name] == language_name) then
					selected = true
				end
				language_combobox:AddChoice(language_info.Name, language_name, selected, language_info.Flag)
			end
		end
		create_language_setting("GAS", {
			Name = "GmodAdminSuite",
			Icon = "icon16/shield.png",
		})
		for module_name, info in pairs(GAS.Modules.Info) do
			if (info.NoMenu or info.Hidden) then continue end
			combobox:AddChoice(info.Name, module_name, GAS.LocalConfig.DefaultModule == module_name, info.Icon)
			create_language_setting(module_name, info)
		end
	end)

	if (is_operator) then
		local operator_content = GAS.Menu.Tabs:AddTab(L"operator", Color(216,76,76))

		local operator_tabs = vgui.Create("bVGUI.Tabs", operator_content)
		operator_tabs:Dock(TOP)
		operator_tabs:SetTall(40)

		local modules_tab_content = operator_tabs:AddTab(L"modules", Color(76,216,76))
		function modules_tab_content:PaintOver(w,h)
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
			surface.DrawTexturedRect(175,0,10,h)
		end

		local modules_categories = vgui.Create("bVGUI.Categories", modules_tab_content)
		modules_categories:Dock(LEFT)
		modules_categories:SetWide(175)

		local modules_content

		modules_categories:AddItem(L"permissions", function()
			if (IsValid(modules_content)) then
				modules_content:Remove()
			end
			modules_content = vgui.Create("bVGUI.BlankPanel", modules_tab_content)
			modules_content:Dock(FILL)

			local permissions_btn_c = vgui.Create("bVGUI.ButtonContainer", modules_content)
			permissions_btn_c:DockMargin(10,10,10,10)
			permissions_btn_c:Dock(TOP)
			permissions_btn_c:SetTall(25)

			local permissions_btn = permissions_btn_c.Button
			permissions_btn:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
			permissions_btn:SetText("OpenPermissions")
			permissions_btn:SetSize(150,25)
			function permissions_btn:DoClick()
				GAS:PlaySound("flash")
				RunConsoleCommand("openpermissions", "gmodadminsuite")
			end

			local text = vgui.Create("DLabel", modules_content)
			text:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
			text:Dock(FILL)
			text:SetContentAlignment(8)
			text:DockMargin(10,0,10,10)
			text:SetTextColor(bVGUI.COLOR_WHITE)
			text:SetText(L"permissions_help")
			text:SetWrap(true)
		end, Color(255,150,50))

		for category, modules in pairs(GAS.Modules.Organised) do
			local category_vgui
			local category_col
			if (category == GAS.MODULE_CATEGORY_ADMINISTRATION) then
				category_col = Color(255,35,35)
				category_vgui = modules_categories:AddCategory(L"administration", category_col)
			elseif (category == GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT) then
				category_col = Color(0,130,255)
				category_vgui = modules_categories:AddCategory(L"player_management", category_col)
			elseif (category == GAS.MODULE_CATEGORY_UTILITIES) then
				category_col = Color(255,75,0)
				category_vgui = modules_categories:AddCategory(L"utilities", category_col)
			elseif (category == GAS.MODULE_CATEGORY_FUN) then
				category_col = Color(190,0,255)
				category_vgui = modules_categories:AddCategory(L"fun", category_col)
			end
			for module_name, info in pairs(modules) do
				local icon = "icon16/delete.png"
				if (GAS.Modules.Config.Enabled[module_name]) then
					icon = "icon16/accept.png"
				end
				local friendly_name = GAS.Modules:GetFriendlyName(module_name)
				local module_item
				module_item = category_vgui:AddItem(friendly_name, function()
					if (IsValid(modules_content)) then
						modules_content:Remove()
					end
					modules_content = vgui.Create("bVGUI.BlankPanel", modules_tab_content)
					modules_content:Dock(FILL)

					local header = vgui.Create("bVGUI.Header", modules_content)
					header:Dock(TOP)
					header:SetText(friendly_name)
					header:SetColor(category_col)
					header:DockMargin(0,0,0,10)

					if (info.Icon) then
						local icon1 = vgui.Create("DImage", header)
						icon1:SetSize(16,16)
						icon1:SetImage(info.Icon)

						local icon2 = vgui.Create("DImage", header)
						icon2:SetSize(16,16)
						icon2:SetImage(info.Icon)

						function header:PerformLayout()
							icon1:AlignLeft(5)
							icon1:CenterVertical()

							icon2:AlignRight(5)
							icon2:CenterVertical()
						end
					end

					local switch_container = vgui.Create("bVGUI.BlankPanel", modules_content)
					switch_container:Dock(TOP)
					switch_container:SetTall(40)
					switch_container:DockMargin(0,0,0,10)

					local switch = vgui.Create("bVGUI.Switch", switch_container)
					switch:SetChecked(GAS.Modules.Config.Enabled[module_name] or false)
					switch:SetText(L"enabled")
					function switch:OnChange()
						if (self:GetChecked()) then
							module_item:SetIcon("icon16/accept.png")
						else
							module_item:SetIcon("icon16/delete.png")
						end
						GAS.Modules.Config.Enabled[module_name] = self:GetChecked() or nil
						GAS:netStart("SetModuleEnabled")
							net.WriteString(module_name)
							net.WriteBool(self:GetChecked())
						net.SendToServer()
					end
					bVGUI.AttachTooltip(switch.ClickableArea, {Text = L"module_enable_switch_tip"})

					function switch_container:PerformLayout()
						switch:Center()
					end

					local script_buttons_container
					local script_buttons = {}
					if (info.GmodStore or info.CridentStore) then
						script_buttons_container = vgui.Create("bVGUI.BlankPanel", modules_content)
						script_buttons_container:Dock(TOP)
						script_buttons_container:SetTall(25)
						script_buttons_container:DockMargin(0,0,0,10)
						function script_buttons_container:PerformLayout(_w)
							local w = (_w - (#script_buttons * (125 + 10)) + 10) / 2
							for i,v in ipairs(script_buttons) do
								v:AlignLeft(w + ((i - 1) * (10 + 125)))
							end
						end
					end

					if (info.GmodStore) then
						local gms = vgui.Create("bVGUI.Button", script_buttons_container)
						table.insert(script_buttons, gms)
						gms:SetSize(125,25)
						gms:SetColor(Color(0,152,234))
						gms:SetText("GmodStore")
						function gms:DoClick()
							GAS:OpenURL("https://gmodstore.com/market/view/" .. info.GmodStore)
						end
					end

					if (info.CridentStore) then
						local crs = vgui.Create("bVGUI.Button", script_buttons_container)
						table.insert(script_buttons, crs)
						crs:SetSize(125,25)
						crs:SetColor(Color(255,40,0))
						crs:SetText("Crident Store")
						function crs:DoClick()
							GAS:OpenURL("https://crident.store/market/products/" .. info.CridentStore)
						end
					end

					if (info.Wiki) then
						local wiki_c = vgui.Create("bVGUI.ButtonContainer", modules_content)
						wiki_c:Dock(TOP)
						wiki_c:SetTall(25)
						wiki_c:DockMargin(0,0,0,10)

						wiki_c.Button:SetColor(bVGUI.BUTTON_COLOR_GREEN)
						wiki_c.Button:SetText(L"wiki")
						wiki_c.Button:SetSize(125,25)
						function wiki_c.Button:DoClick()
							GAS:OpenURL(info.Wiki)
						end
					end
				end, nil, icon)
			end
		end
	end

	local created_anything = false
	for category, modules in pairs(GAS.Modules.Organised) do
		local category_vgui
		for module_name, info in pairs(modules) do
			if (info.NoMenu or info.Hidden) then continue end
			if (info.DarkRP == true and DarkRP == nil) then continue end
			if (GAS.Modules:IsModuleEnabled(module_name) ~= GAS.Modules.MODULE_ENABLED) then continue end
			if (info.OperatorOnly and not is_operator) then continue end
			if (not is_operator and not OpenPermissions:HasPermission(LocalPlayer(), "gmodadminsuite/" .. module_name)) then continue end
			created_anything = true
			if (not category_vgui) then
				if (category == GAS.MODULE_CATEGORY_ADMINISTRATION) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"administration", Color(255,35,35))
				elseif (category == GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"player_management", Color(0,130,255))
				elseif (category == GAS.MODULE_CATEGORY_UTILITIES) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"utilities", Color(255,75,0))
				elseif (category == GAS.MODULE_CATEGORY_FUN) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"fun", Color(190,0,255))
				end
			end
			local item = category_vgui:AddItem(GAS.Modules:GetFriendlyName(module_name), function()
				GAS.Menu.ModuleOpen = module_name

				GAS:OpenModuleFrame(module_name)
				
				GAS.Menu.Fullscreened = false

				local _,h = GAS.ModuleFrame:GetSize()
				GAS.Menu:SetTall(h)
			end, nil, info.Icon)
			if (IsValid(GAS.ModuleFrame)) then
				if (GAS.ModuleFrame.ModuleName == module_name) then
					item:SetActive(true)
				end
			elseif (GAS.LocalConfig.DefaultModule == module_name) then
				item:OnMouseReleased(MOUSE_LEFT)
			end

			GAS.Menu.Modules.IndexedItems[module_name] = item
		end
	end
	if (not created_anything) then
		if (not is_operator) then
			GAS:PlaySound("error")
			bVGUI.RichMessage({
				title = L"no_modules_available",
				text = L"no_modules_available_info",
				button = "OK"
			})
			GAS.Menu:Close()
		else
			GAS.Menu.Modules:SetWide(0)
		end
	else
		GAS.Menu:SetVisible(true)
	end
end

function GAS:OpenMenu()
	if (not GAS_InitPostEntity) then GAS:InitPostEntity_Run() end
	if (IsValid(GAS.Menu)) then GAS.Menu:Close() end

	if (not GAS.Modules.Config) then
		GAS:GetConfig("modules", function(config)
			GAS.Modules.Config = config
			for module_name, enabled in pairs(GAS.Modules.Config.Enabled) do
				if (not enabled) then continue end
				GAS.Modules:LoadModule(module_name, true)
			end
			OpenMenu()
		end)
	else
		OpenMenu()
	end
end

GAS:netReceive("menu", function()
	local selected_module = net.ReadString()
	if (#selected_module == 0) then
		selected_module = false
	end
	if (not selected_module or not hook.Run("gmodadminsuite:ModuleMenu:" .. selected_module)) then
		if (selected_module) then
			GAS:OpenModuleFrame(selected_module)
		else
			GAS:OpenMenu()
		end
	end
end)
--PATH addons/sl_utils/lua/vgui/stackerdnumslider.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local math = math
local vgui = vgui
local tonumber = tonumber

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:SetValue( string, boolean )
--
--]]--
function PANEL:SetValue( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )

	if ( val == nil ) then return end
	if ( self:GetValue() == val ) then return end

	self.Scratch:SetFloatValue( val )
	self:ValueChanged( self:GetValue(), bSuppress )
end

--[[--------------------------------------------------------------------------
--
--	PANEL:ValueChanged( string, value)
--
--]]--
function PANEL:ValueChanged( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )
	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )	
	if ( self.TextArea ~= vgui.GetKeyboardFocus() ) then
		self.TextArea:SetValue( self.Scratch:GetTextValue() )
	end
	if ( not bSuppress ) then
		self:OnValueChanged( val )
	end
end

vgui.Register( "StackerDNumSlider", PANEL, "DNumSlider" )
--PATH addons/rogue_scoreboard/lua/roguescoreboard/cl_rogue.lua:
local Configuration = RogueScoreboard.Configuration

hook.Add("InitPostEntity", "InitFadminRemove", function()
    hook.Remove("ScoreboardShow", "FAdmin_scoreboard")
    hook.Remove("ScoreboardHide", "FAdmin_scoreboard")
end)

surface.CreateFont("RogueTitle", {font = "Quicksand Regular", size = 48, extended = true, antialias = true,})
surface.CreateFont("Rogue30", {font = "Quicksand Regular", size = 30, extended = true})
surface.CreateFont("Rogue24", {font = "Quicksand Regular", size = 24, extended = true})
surface.CreateFont("Rogue20", {font = "Quicksand Regular", size = 20, extended = true})
surface.CreateFont("Rogue19", {font = "Quicksand Regular", size = 19, extended = true})
surface.CreateFont("Numbers", {font = "Quicksand Regular", size = 22, extended = true})

if IsValid(RogueScoreboard.Main) then
	RogueScoreboard.Main:Close()
	RogueScoreboard.Main = nil
end

hook.Add("Initialize", "RogueScoreboard.RemoveGamemodeFunctions", function()
	GAMEMODE.ScoreboardShow = nil
	GAMEMODE.ScoreboardHide = nil
end)

local PanelWidth = ScrW() > 1280 and 1300 or 1100

function RogueSteamFriendCheck( ply )
	return ply:GetFriendStatus() == "friend"
end

local function lerpColor(t, a, b)
	local newCol = Color(255, 255, 255, 255)
	newCol.r = Lerp(t, a.r, b.r)
	newCol.g = Lerp(t, a.g, b.g)
	newCol.b = Lerp(t, a.b, b.b)
	newCol.a = Lerp(t, a.a, b.a)
	return newCol
end

RogueScoreboard.CachedMaterials = RogueScoreboard.CachedMaterials or {}

function RogueScoreboard.Material(name, ...)
	if Scoreboard.CachedMaterials[name] then
		return Scoreboard.CachedMaterials[name]
	else
		local newMat = Material(name, ...)
		Scoreboard.CachedMaterials[name] = newMat
		return newMat
	end
end



local CmdGoto = Material( "materials/roguescoreboard/roguegoto.png" )
local CmdBring = Material( "materials/roguescoreboard/rogueteleport.png" )
local CmdSpectate = Material( "materials/roguescoreboard/roguespectate.png" )
local CmdBFreeze = Material( "materials/roguescoreboard/roguefreeze.png" )
local CmdKick = Material( "materials/roguescoreboard/roguekick.png" )
local CmdBan = Material( "materials/roguescoreboard/rogueban.png" )
local CmdInfo = Material( "materials/roguescoreboard/roguehelp.png" )

local FakeAvatar = Material( "materials/roguescoreboard/roguefakeavatar1.png" )
local Incognito = Material( "materials/roguescoreboard/rogueincognito.png" )
local HideIcon = Material( "materials/roguescoreboard/roguehide.png" )
local PingBars1 = Material( "materials/roguescoreboard/1bar.png" )
local PingBars2 = Material( "materials/roguescoreboard/2bar.png" )
local PingBars3 = Material( "materials/roguescoreboard/3bar.png" )
local PingBarsFull = Material( "materials/roguescoreboard/fullping.png" )
local TagIcon = Material( "materials/roguescoreboard/roguetag.png" )
local HelpIcon = Material( "materials/roguescoreboard/roguehelp.png" )
local PropsIcon = Material( "materials/roguescoreboard/rogueprops.png" )
local ReportIcon = Material( "materials/roguescoreboard/warn.png" )
local FriendIcon = Material( "materials/roguescoreboard/steamfriend.png" )
local MuteIcon = Material( "materials/roguescoreboard/mute.png" )

local PropAllowed = false

local MainBG = Configuration.MainBackground
local PanelBG =	Configuration.PanelBackground

local NameHover = Configuration.NameHover
local FriendCol = Configuration.Friends

local MutedCol =  Configuration.Muted
local ClearPCol = Configuration.ClearProps
local ClearPHov = Configuration.ClearPropsHover
local IconsDark = Configuration.IconsDarkColor
local PingFullCol = Configuration.PingFull
local Ping3Col = Configuration.Ping3
local Ping2Col = Configuration.Ping2
local PingCrit = Configuration.PingCritical
local UnderCol = Configuration.UndercoverIcon
local ReportCol = Configuration.ReportColor
local ReportColHover = Configuration.ReportHoverColor
local UnderCoverCol = Configuration.IsUndercoverIcon

local Zero = Color( 0,0,0,0 )
local White = Color( 255,255,255 )
local Grey = Color( 31,113,194,200)

local LightGrey = Color( 121,122,123 )
local MoneyColor = Color( 0,255,140 )
local SubMenuBaseColor = Color( 14,15,16,50 )
local LightText = Color( 255,255,255,100 )
local DarkText = Color( 20,20,20,150 )

local emptyFunction = function() end

local function initCommandTable()
	local CommandTable = {}

	if IsValid(LocalPlayer()) and ( table.HasValue( Configuration.MenuAccess, LocalPlayer():GetUserGroup()) ) then

		if !Configuration.SeperateAccess or (Configuration.SeperateAccess and table.HasValue( Configuration.AllowedGoto, LocalPlayer():GetUserGroup())) then
			table.insert(CommandTable, {
				CommandName = Configuration.CommandGoto,
				CommandIcon = CmdGoto,
				Func = function(cmdPly)

					if cmdPly == LocalPlayer() then LocalPlayer():ChatPrint( Configuration.TargetSelfCheck  ) return end
					Configuration.Administration[Configuration.AdministrationMod].goto( cmdPly )

				end
			})
		end
		if !Configuration.SeperateAccess or (Configuration.SeperateAccess and table.HasValue( Configuration.AllowedBring, LocalPlayer():GetUserGroup())) then
			table.insert(CommandTable, {
				CommandName = Configuration.CommandBring,
				CommandIcon = CmdBring,
				Func = function(cmdPly)
					if cmdPly == LocalPlayer() then LocalPlayer():ChatPrint( Configuration.TargetSelfCheck  ) return end
					Configuration.Administration[Configuration.AdministrationMod].bring( cmdPly )
				end
			})
		end
		if !Configuration.SeperateAccess or (Configuration.SeperateAccess and table.HasValue( Configuration.AllowedFreeze, LocalPlayer():GetUserGroup())) then
			table.insert(CommandTable, {
				CommandName = Configuration.CommandBringFreeze,
				CommandIcon = CmdBFreeze,
				Func = function(cmdPly)

					if cmdPly == LocalPlayer() then LocalPlayer():ChatPrint( Configuration.TargetSelfCheck  ) return end
					if !cmdPly:IsFrozen() then

						Configuration.Administration[Configuration.AdministrationMod].freeze( cmdPly )

					elseif cmdPly:IsFrozen() then

						Configuration.Administration[Configuration.AdministrationMod].unfreeze( cmdPly )
						Configuration.Administration[Configuration.AdministrationMod].send( cmdPly )

					end

				end
			})
		end

		if !Configuration.SeperateAccess or (Configuration.SeperateAccess and table.HasValue( Configuration.AllowedSpectate, LocalPlayer():GetUserGroup())) then
			table.insert(CommandTable, {
				CommandName = Configuration.CommandSpectate,
				CommandIcon = CmdSpectate,
				Func = function(cmdPly)

					if cmdPly == LocalPlayer() then LocalPlayer():ChatPrint( Configuration.TargetSelfCheck  ) return end
					Configuration.Administration[Configuration.AdministrationMod].spectate( cmdPly )

				end
			})
		end

		table.insert(CommandTable, {
			CommandName = Configuration.CommandCopy,
			CommandIcon = CmdInfo,
			Func = function(cmdPly)
				if IsValid(cmdPly) and !cmdPly:IsBot() then

					SetClipboardText(cmdPly:Nick() .. " SteamID [ " .. cmdPly:SteamID() .. " ]  SteamID64 [ " .. cmdPly:SteamID64() .. " ]" .. " Steam Name [ " .. cmdPly:Name() .. " ]")
					LocalPlayer():ChatPrint( "Copied " .. cmdPly:Nick() .. "s information" )

				end
			end
		})

		if !Configuration.SeperateAccess or (Configuration.SeperateAccess and table.HasValue( Configuration.AllowedKick, LocalPlayer():GetUserGroup())) then
			table.insert(CommandTable, {
				CommandName = Configuration.CommandKick,
				CommandIcon = CmdKick,
				Func = function(cmdPly)
					if cmdPly == LocalPlayer() then LocalPlayer():ChatPrint( Configuration.TargetSelfCheck  ) return end

					Configuration.Administration[Configuration.AdministrationMod].kick( cmdPly, Configuration.CommandKickReason )

				end
			})
		end
		if !Configuration.SeperateAccess or (Configuration.SeperateAccess and table.HasValue( Configuration.AllowedBan, LocalPlayer():GetUserGroup())) then
			table.insert(CommandTable, {
				CommandName = Configuration.CommandBan,
				CommandIcon = CmdBan,
				Func = function(cmdPly)

					if cmdPly == LocalPlayer() then LocalPlayer():ChatPrint( Configuration.TargetSelfCheck  ) return end
					Configuration.Administration[Configuration.AdministrationMod].ban( cmdPly,Configuration.CommandBanTime, string.format( Configuration.CommandBanReason, Configuration.CommandBanTime) )

				end
			})
		end
	else
		table.insert(CommandTable, {
			CommandName = Configuration.CommandCopy,
			CommandIcon = CmdInfo,
			Func = function(cmdPly)
				if IsValid(cmdPly) and !cmdPly:IsBot() then
					SetClipboardText(cmdPly:Nick() .. " SteamID [ " .. cmdPly:SteamID() .. " ]  SteamID64 [ " .. cmdPly:SteamID64() .. " ]" .. " Steam Name [ " .. cmdPly:Name() .. " ]")
					LocalPlayer():ChatPrint( "Copied " .. cmdPly:Nick() .. "s information" )
				end
			end
		})
	end

	return CommandTable
end

function RogueRandomNameGeneration( ply )
	if ply:GetRogueNetBool("Incognito", false) and !ply.RandomName then
	  	ply.RandomName = table.Random( Configuration.UndercoverNames )
	  	ply.RandomMoney = math.random( Configuration.LowestMoney, Configuration.HighestMoney )
	  	ply.RandomKills = math.random( Configuration.LowestKills, Configuration.HighestKills )
	  	ply.RandomDeaths = math.random( Configuration.LowestDeaths, Configuration.HighestDeaths )
	elseif !ply:GetRogueNetBool("Incognito", false) and ply.RandomName then
	 	ply.RandomName = nil
	  	ply.RandomMoney = nil
	  	ply.RandomKills = nil
	  	ply.RandomDeaths = nil
	end
end

local function mainPaint(self, w, h)
	local ply = self.Player

	if !IsValid(ply) and IsValid(RogueScoreboard.Main) then RogueScoreboard.Main:Update() return end

	local RandName = ply.RandomName or ply:Nick()
	local Randkill = ply.RandomKills or ply:Frags()
	local RandDeath = ply.RandomDeaths or ply:Deaths()

	surface.SetDrawColor( Color(255,255,255) )
	surface.DrawRect( W(40), 0, w/1.25, h )
	surface.SetDrawColor( Color(34,47,66) )
	surface.DrawRect( W(41), 1, w/1.25-2, h-2 )

	-- draw.RoundedBox( 16, 1, 2, 3, 36, Color(0, 112, 247, 255))
	local nextColor
	if self.Hovered or self.Opened then
		nextColor = NameHover
	else
		nextColor = White
	end

	draw.DrawText( RandName, "Rogue24", 94, 7, self.Color, TEXT_ALIGN_LEFT)

	self.Color = lerpColor(FrameTime() * 8, self.Color, nextColor)

	-- local DisplaySetting =  Configuration.RankDisplay[ply:GetNWString("usergroup", "")]
	local DisplayName = DisplaySetting and DisplaySetting.DisplayName or ""


	if Configuration.DarkRP && Configuration.ShowTeam then
		draw.DrawText( team.GetName(ply:Team()), "Rogue24", w / 2, 7, White, TEXT_ALIGN_CENTER)
	end
	
	if Configuration.ShowName then
		if ply:GetRogueNetBool("Incognito") then
			if Configuration.UseCustomIcon then
				surface.SetDrawColor( White )
				surface.SetMaterial( FakeAvatar )
				surface.DrawTexturedRect( 46, 4, 32,32 )
			end

			if IsValid(LocalPlayer()) and table.HasValue( Configuration.IncognitoVision, LocalPlayer():GetUserGroup()) then
				surface.SetDrawColor( UnderCol )
				surface.SetMaterial( Incognito )
				surface.DrawTexturedRect( w - w / 4 - 95 - 12, 8, 24, 24 )
			end
			draw.DrawText( "", "Rogue24", w / 2 + w / 4 - 95, 7, DisplayColor, TEXT_ALIGN_CENTER)
		else
			draw.DrawText( DisplayName, "Rogue24", w / 2, 7, DisplayColor, TEXT_ALIGN_CENTER)
		end
	end
	draw.RoundedBox( 10, w - 205, H(5), W(30), H(30), Color(78, 151, 241))
	draw.RoundedBox( 10, w - 155, H(5), W(30), H(30), Color(78, 151, 241, 255))

	draw.DrawText( RandDeath, "Numbers", w - 140, 7, White, TEXT_ALIGN_CENTER)
	draw.DrawText( Randkill, "Numbers", w - 190, 7, White, TEXT_ALIGN_CENTER)

	if ply:Ping() > 4 then
		draw.DrawText( ply:Ping(), "Numbers", w - 75, 7, White, TEXT_ALIGN_CENTER)
	else
		draw.DrawText( "!", "Numbers", w - 75, 7, PingCrit, TEXT_ALIGN_CENTER)
	end

	local PColor, PMaterial
	if ply:Ping() > 259 then
		PColor = PingCrit
		PMaterial = PingBars1
	elseif ply:Ping() > 170 then
		PColor = Ping2Col
		PMaterial = PingBars2
	elseif ply:Ping() > 100 then
		PColor = Ping3Col
		PMaterial = PingBars3
	elseif ply:Ping() >= 5 then
		PColor = PingFullCol
		PMaterial = PingBarsFull
	else
		PColor = Color( 255,100,0 )
		PMaterial = PingBars1
	end

	surface.SetDrawColor( Grey )
	surface.SetMaterial( PingBarsFull )
	surface.DrawTexturedRect( w - 110, 12, 20, 21 )

	surface.SetDrawColor( PColor )
	surface.SetMaterial( PMaterial )
	surface.DrawTexturedRect( w - 110, 12, 20, 21 )
end

local function createSubMenu(self)
	local ply = self.Player
	local SubMenu = vgui.Create( "Panel", self )
	SubMenu:SetSize( self:GetWide(), 80)
	SubMenu:SetPos( 0, 40)
	SubMenu:SetPlayer( ply )
	SubMenu.Color = Zero
	SubMenu.NextColor = Zero
	SubMenu.Color2 = Zero
	SubMenu.NextColor2 = Zero
	SubMenu.Color3 = Zero
	SubMenu.NextColor3 = Zero
	SubMenu.Color4 = LightGrey
	SubMenu.NextColor4 = ClearPCol
	SubMenu.CommandHoverText = ""

	local DisplaySetting = Configuration.RankDisplay[ply:GetNWString("usergroup", "")]
	local DisplayTag = DisplaySetting and DisplaySetting.TagName or ""
	local DisplayTagCol = DisplaySetting and DisplaySetting.TagColor or LightGrey

	local CustomTag = Configuration.CustomUserTag[ply:SteamID()]
	local PlayerTag = CustomTag and CustomTag.Tag or ""
	local CustomTagCol = CustomTag and CustomTag.TagColor or LightGrey

	local SandboxPos = 0

	local MuteButton = vgui.Create("DButton", SubMenu)
	MuteButton:SetSize( 24, 24)
	MuteButton:SetPos( SubMenu:GetWide() - 250, 8)
	MuteButton:SetPlayer( ply )
	MuteButton:SetText("")
	MuteButton:SetFont("Rogue20")
	MuteButton.Image = MuteIcon
	MuteButton.Color = Grey
	MuteButton.NextColor = Zero

	if Configuration.DarkRP then
		SandboxPos = 0
	else
		SandboxPos = 140
	end

	if Configuration.ReportEnabled then
		local ReportButton = vgui.Create("DButton", SubMenu)
		ReportButton:SetSize( 24, 24)
		ReportButton:SetPos( SubMenu:GetWide() - 250, SubMenu:GetTall() - 32)
		ReportButton:SetPlayer( ply )
		ReportButton:SetText("")
		ReportButton:SetFont("Rogue20")
		ReportButton.Color = Grey
		ReportButton.NextColor = White

		function ReportButton:Paint( w, h )
			if self.Hovered then
				self.NextColor = ReportColHover
			else
				self.NextColor = ReportCol
			end

			surface.SetDrawColor(self.Color)
			surface.SetMaterial( ReportIcon )
			surface.DrawTexturedRect( 0, 0, 24, 24 )

			self.Color = lerpColor(FrameTime() * 8, self.Color, self.NextColor)
		end

		ReportButton.DoClick = function()
			if IsValid(ply) and !ply:IsBot() then
				if Configuration.UsingReportAddon then

					RunConsoleCommand( "say", Configuration.ReportAddonPrefix )

				else
					if Configuration.UsingReportSite then
						gui.OpenURL(Configuration.ReportURL)
					else
						RunConsoleCommand( "say", Configuration.ReportPrefix  .. Configuration.ReportedText .. " " .. ply:Nick() .. " " .. ply:SteamID() )
					end
				end
			end
		end
	end

	if table.HasValue( Configuration.PropAccess, LocalPlayer():GetUserGroup()) then
		local ClearPropButton = vgui.Create("DButton", SubMenu)
		ClearPropButton:SetSize( 24, 24)
		ClearPropButton:SetPos( 280 - SandboxPos, SubMenu:GetTall() - 32)
		ClearPropButton:SetPlayer( ply )
		ClearPropButton:SetText("")
		ClearPropButton:SetFont("Rogue20")
		ClearPropButton.Color = ClearPCol
		ClearPropButton.NextColor = Zero

		function ClearPropButton:Paint( w, h )
			if !IsValid(ply) then return end
			if self.Hovered then
				self.NextColor = ClearPHov
			else
				self.NextColor = ClearPCol
			end
			surface.SetDrawColor( self.Color )
			surface.SetMaterial( PropsIcon )
			surface.DrawTexturedRect( 0, 0, 24, 24)

			self.Color = lerpColor(FrameTime() * 8, self.Color, self.NextColor)

		end
		ClearPropButton.DoClick = function() RunConsoleCommand("FPP_Cleanup", ply:UserID()) end
	end
	
	local RandMoney

	if Configuration.DarkRP then
		RandMoney = ply.RandomMoney or ply:getDarkRPVar("money")
	end

	function SubMenu:Paint( w, h )
		surface.SetDrawColor( SubMenuBaseColor )
		surface.DrawRect(0, 0, w, h)
		if !IsValid(ply) then return end

		if ply:GetRogueNetBool("Incognito") then
			draw.DrawText( "USER" , "Rogue20", 50, 8, IconsDark, TEXT_ALIGN_LEFT)
		else
			if Configuration.CustomUserTag[ply:SteamID()] then
				draw.DrawText( PlayerTag , "Rogue20", 50, 8, CustomTagCol, TEXT_ALIGN_LEFT)
			else
				draw.DrawText( DisplayTag , "Rogue20", 50, 8, DisplayTagCol, TEXT_ALIGN_LEFT)
			end
		end

		-- surface.SetDrawColor( Grey )
		-- surface.SetMaterial( TagIcon )
		-- surface.DrawTexturedRect( 10, 8, 24, 24 )

		self.NextColor2 = IconsDark

		if Configuration.ReportEnabled then
			draw.DrawText( Configuration.ReportText , "Rogue20", w - 255, h - 32, self.Color2, TEXT_ALIGN_RIGHT)
		end

		self.NextColor3 = IconsDark

		draw.DrawText( ply:IsMuted() and Configuration.UnMuteText or Configuration.MuteText, "Rogue20", w - 255, 8, self.Color3, TEXT_ALIGN_RIGHT)


		if table.HasValue( Configuration.PropAccess, LocalPlayer():GetUserGroup()) then
			draw.DrawText(  Configuration.ClearPropText, "Rogue20", 50 + 280 - SandboxPos, h  - 32, IconsDark, TEXT_ALIGN_LEFT)
		end

		if Configuration.InformationViewAll then
			if Configuration.DarkRP then
				-- surface.SetDrawColor( Grey )
				-- surface.SetMaterial( HelpIcon )
				-- surface.DrawTexturedRect( 10, h - 32, 24, 24 )
				draw.DrawText( formatMoney(  RandMoney ), "Rogue20", 50, h  - 32, MoneyColor, TEXT_ALIGN_LEFT)
			end

			surface.SetDrawColor( Grey )
			surface.SetMaterial( PropsIcon )
			surface.DrawTexturedRect( 10 + 140 - SandboxPos, h - 32, 24, 24 )

			draw.DrawText(  ply:GetCount( "props" ) .. " " .. Configuration.PropText, "Rogue20", 50 + 140 - SandboxPos, h  - 32, IconsDark, TEXT_ALIGN_LEFT)

		end

		if !Configuration.InformationViewAll and (table.HasValue( Configuration.InformationView, LocalPlayer():GetUserGroup())) then

			if Configuration.DarkRP then

				surface.SetDrawColor( Grey )
				surface.SetMaterial( HelpIcon )
				surface.DrawTexturedRect( 10, h - 32, 24, 24 )

				draw.DrawText( formatMoney( RandMoney ) , "Rogue20", 50, h  - 32, MoneyColor, TEXT_ALIGN_LEFT)

			end

			surface.SetDrawColor( Grey )
			surface.SetMaterial( HelpIcon )
			surface.DrawTexturedRect( 10 + 140 - SandboxPos, h - 32, 24, 24 )


			draw.DrawText(  ply:GetCount( "props" ) .. " " .. Configuration.PropText, "Rogue20", 50 + 140 - SandboxPos, h  - 32, IconsDark, TEXT_ALIGN_LEFT)

		end

		self.Color = lerpColor(FrameTime() * 8, self.Color, self.NextColor)
		self.Color2 = lerpColor(FrameTime() * 8, self.Color2, self.NextColor2)
		self.Color3 = lerpColor(FrameTime() * 8, self.Color3, self.NextColor3)

	end

	local CommandBase = vgui.Create("Panel", SubMenu)
	CommandBase:SetPos( SubMenu:GetWide() / 2 - SubMenu:GetWide() / 4, SubMenu:GetTall() / 2 - 16 )
	CommandBase:SetSize( SubMenu:GetWide() / 2, 60 )
	CommandBase.Color = Grey
	CommandBase.NextColor = White
	CommandBase.CommandHoverText = ""

	local CommandList = vgui.Create("DPanelList", CommandBase)
	CommandList:SetSize( 600, CommandBase:GetTall() )
	CommandList:SetPos( CommandBase:GetWide() / 2 - 300, 0 )
	CommandList:SetAlpha(0)
	CommandList:AlphaTo(252, 1)
	CommandList:EnableHorizontal( true )
	CommandList:EnableVerticalScrollbar( true )

	local vbar = CommandList.VBar
	vbar:SetHideButtons( true )

	function vbar.btnUp:Paint( w, h ) end
	function vbar:Paint( w, h ) end
	function vbar.btnGrip:Paint( w, h ) end

	local numofTables

	for k, v in pairs(self.commandTable) do

		numofTables = k

		local CommandMain = vgui.Create( "DButton", CommandList )
		CommandMain:SetTall( 26 )
		CommandMain:SetText( "" )
		CommandMain:SetFont( "Rogue30" )
		CommandMain:SetTextColor( LightText )
		CommandMain.Color = White

		function CommandMain:Paint( w, h )
			CommandList:SetWide( 24 * numofTables * 2, 26 )
			CommandList:SetPos( CommandBase:GetWide() / 2 - 24 * numofTables * 2 / 2, 0 )

			if self.Hovered then
				self.NextColor = White
				surface.SetDrawColor( self.Color )
				surface.SetMaterial( v.CommandIcon )
				surface.DrawTexturedRect( w / 2 - 12 , h / 2 - 12, 24, 24 )
			else
				self.NextColor = IconsDark
				surface.SetDrawColor( self.Color )
				surface.SetMaterial( v.CommandIcon )
				surface.DrawTexturedRect( w / 2 - 12 , h / 2 - 10, 24, 24 )
			end
			self:SetSize(  CommandList:GetWide() / numofTables, 26 )

			self.Color = lerpColor(FrameTime() * 8, self.Color, self.NextColor)
		end

		CommandList:AddItem(CommandMain)

		CommandMain.DoClick = function()
			v.Func(ply)
		end

		local CommandTitle = vgui.Create("Panel", CommandBase)
		CommandTitle:SetPos( CommandBase:GetWide() / 2 - 125, CommandBase:GetTall() - 24 - 10 )
		CommandTitle:SetSize( 250, 24 )
		CommandTitle.Color = Grey
		CommandTitle.NextColor = White
		CommandTitle.CommandHoverText = ""

		function CommandTitle:Paint( w, h )
			if CommandMain:IsHovered() then
				self.NextColor = IconsDark
				draw.DrawText( v.CommandName, "Rogue20", w / 2, 0, self.Color, TEXT_ALIGN_CENTER)
			else
				self.NextColor = Zero
			end
			self.Color = lerpColor(FrameTime() * 8, self.Color, self.NextColor)
		end
	end

	function MuteButton:Paint( w, h )

		if !IsValid(ply) then return end

		self.NextColor = (self.Hovered or ply:IsMuted()) and MutedCol or Grey

		surface.SetDrawColor(self.Color)
		surface.SetMaterial(self.Image )
		surface.DrawTexturedRect( 0, 0, 24, 24 )

		self.Color = lerpColor(FrameTime() * 8, self.Color, self.NextColor)
	end

	MuteButton.DoClick = function() if !ply:IsMuted() then ply:SetMuted( true ) else ply:SetMuted( false ) end end

	return SubMenu
end

local function playerButtonDoClick(self)

	if self.Opened then
		return
	end

	local ply = self.Player

	self.Opened = true
	self:SizeTo( self:GetWide(), 120, 0.3, 0, - 1 )

	local CloseButton = vgui.Create("DButton", self)
	CloseButton:SetSize( PanelWidth, 40)
	CloseButton:SetPos( 40, 0)
	CloseButton:SetPlayer( ply )
	CloseButton:SetText("")
	CloseButton:SetFont("Rogue20")
	CloseButton.Paint = emptyFunction

	local SubMenu = createSubMenu(self)

	CloseButton.DoClick = function()
		self:SizeTo( self:GetWide(), 40, 0.3, 0, - 1 )
		SubMenu:Remove()
		CloseButton:Remove()
		self.Opened = false
	end

end

local cadreAvatar = Material("cadreAvatar.png")

local function PlayerPanel( ply )
	local PlayerMain = vgui.Create("DButton")

	PlayerMain:SetSize( PanelWidth, 40)
	PlayerMain.commandTable = initCommandTable()
	PlayerMain:SetPlayer( ply )
	PlayerMain.Player = ply
	PlayerMain:SetText("")
	PlayerMain:SetFont("Rogue20")
	PlayerMain.Color = White
	PlayerMain.Opened = false
	PlayerMain.PlayerName = ply:Nick()

	RogueRandomNameGeneration(ply)

	PlayerMain.Paint = mainPaint

	PlayerMain.DoClick = playerButtonDoClick

	if !ply:GetRogueNetBool("Incognito") or ( !Configuration.UseCustomIcon && ply:GetRogueNetBool("Incognito") ) then
		surface.SetDrawColor( Color(255,255,255) )
		surface.SetMaterial( cadreAvatar )
		surface.DrawTexturedRect( 44, 2, 34,34 )
		local avatar = PlayerMain:Add("AvatarImage")
		avatar:SetSize(32, 32)
		avatar:SetPos(46, 4)
		avatar:SetPlayer(ply)
		avatar:SetMouseInputEnabled(false)

		avatar.PaintOver = function(self, w, h)
			surface.SetDrawColor( DarkText )
			surface.DrawOutlinedRect(0, 0, w, h)
		end
	end

	return PlayerMain
end
local fraude = Material("Solo Leveling.png")
local function createScoreboard()
	local Main = vgui.Create("DFrame")
	Main:SetSize( ScrW(), ScrH() )
	Main:SetAlpha( 0 )
	Main:AlphaTo( 255, 0.1 )
	Main:Center()
	Main:SetTitle("")
	Main:ShowCloseButton( false )
	Main:SetDraggable( false )

	function Main:Paint( w, h )
		surface.SetDrawColor( MainBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( Color(255,255,255) )
		surface.SetMaterial( fraude )
		surface.DrawTexturedRect( w / 2 - 200, h / 2 - 450, W(330), H(178) )
		-- draw.DrawText(  Configuration.ServerTitle , "RogueTitle", w / 2, 140, Configuration.ServerTitleColor, TEXT_ALIGN_CENTER)

		if Configuration.ShowOnlineCount then

			local Pcount = table.Count( player.GetAll() )
			draw.DrawText(  Configuration.CurrentPlayersText .. " " .. Pcount, "Rogue30", w / 2, h - 114, White, TEXT_ALIGN_CENTER)

		end

	end

	local InformationBar = vgui.Create("Panel", Main)
	InformationBar:SetSize( PanelWidth, 30 )
	InformationBar:SetPos( Main:GetWide() / 2 - PanelWidth / 2, 266 )
	function InformationBar:Paint( w, h )

		if Configuration.InformationBar == false then return end
		if Configuration.InformationBackground then

			surface.SetDrawColor( PanelBG )
			surface.DrawRect( 0,0,w,h )

		end

		draw.DrawText(  Configuration.NameText, "Rogue24", 94, h / 2 - 12, White, TEXT_ALIGN_LEFT)
		if Configuration.DarkRP then
			draw.DrawText(  Configuration.JobText, "Rogue24", w / 2, h / 2 - 12, White, TEXT_ALIGN_CENTER)
		end
		draw.DrawText(  Configuration.KillsText, "Rogue24", w - 190, h / 2 - 12, White, TEXT_ALIGN_CENTER)
		draw.DrawText(  Configuration.DeathsText, "Rogue24", w - 140, h / 2 - 12, White, TEXT_ALIGN_CENTER)

	end

	local ScrollMain = Main:Add("DScrollPanel")
	ScrollMain:Center()
	ScrollMain:SetPos( ScrW() / 2 - PanelWidth / 2, 300)
	ScrollMain:SetSize( PanelWidth, Main:GetTall() - 420)

	ScrollMain.VBar:SetHideButtons(true)
	ScrollMain.VBar.Paint = function() end

	ScrollMain.VBar:SetWide(0)
	ScrollMain.VBar.btnUp.Paint = ScrollMain.VBar.Paint
	ScrollMain.VBar.btnDown.Paint = ScrollMain.VBar.Paint
	ScrollMain.VBar.btnGrip.Paint = function(self, w, h) end


	Main.Update = function()

		ScrollMain:Clear()

		if Configuration.DarkRP then
			local Categories = DarkRP.getCategories().jobs
			for k,category in pairs( Categories ) do
				local Validation = table.Count( category.members ) > 0

				if Validation then
					if Configuration.SortByCategories then
						local shouldRemove = true

						local CategorySort = vgui.Create("DCollapsibleCategory", ScrollMain)
						CategorySort.Header:SetTall(40)
						CategorySort:SetLabel("")
						function CategorySort:Paint( w, h ) end
						function CategorySort.Header:Paint( w, h )

							surface.SetDrawColor( White )
							surface.SetMaterial( FriendIcon )
							surface.DrawTexturedRect( 10, 8, 24, 24 )

							draw.SimpleText(category.name, "Rogue24", 48, h / 2, category.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
						end
						ScrollMain:AddItem(CategorySort)
						CategorySort:DockMargin( 0, 0, 0, 0 )
						CategorySort:Dock(TOP)

						local ListContents = vgui.Create("DPanelList", CategorySort)
						ListContents:SetPadding(0)
						ListContents:SetSpacing(4)
						ListContents:Dock(FILL)
						local oldValidate = ListContents.PerformLayout
						function ListContents:PerformLayout(...)
							self:InvalidateParent()
							oldValidate(self, ...)
						end
						CategorySort:SetContents(ListContents)

						for _,v in pairs(category.members) do
							local count = team.NumPlayers(v.team)
							if count > 0 then
								shouldRemove = false
								local plys = team.GetPlayers(v.team)
								for _, ply in pairs(plys) do
									local plyPanel = PlayerPanel(ply)
									plyPanel:DockMargin( 0, 0, 0, 4 )
									plyPanel:Dock(TOP)
									ListContents:AddItem(plyPanel)
								end
							end
						end

						CategorySort:Dock(TOP)
						if shouldRemove then
							CategorySort:Remove()
						end
					else
						for _, member in pairs(category.members) do
							local count = team.NumPlayers(member.team)
							if count > 0 then
								local plys = table.Copy(team.GetPlayers(member.team))
								table.sort(plys, function(a, b) return a:Nick() < b:Nick() end)
								for _, ply in pairs(plys) do
									local plyPanel = PlayerPanel(ply)
									ScrollMain:AddItem(plyPanel)
									plyPanel:DockMargin(0, 0, 0, 4)
									plyPanel:Dock(TOP)
								end
							end
						end

					end
				end
			end
		else
			for k, v in pairs(player.GetAll()) do
				local plyPanel = PlayerPanel(v)
				ScrollMain:AddItem(plyPanel)
				plyPanel:DockMargin(0, 0, 0, 4)
				plyPanel:Dock(TOP)
			end
		end
	end
	Main:Update()
	return Main
end

hook.Add("ScoreboardShow", "RogueScoreboard.Activate", function()
	hook.Remove("ScoreboardHide", "FAdmin_scoreboard")
	hook.Remove("ScoreboardShow", "FAdmin_scoreboard")
	local Main = RogueScoreboard.Main
	gui.EnableScreenClicker(true) 
	if IsValid(Main) && Main:IsVisible() then
		Main:Update()
		Main:SetVisible(true)
		Main:SetAlpha(0)
		Main:AlphaTo(252, 0.3)
	else
		RogueScoreboard.Main = createScoreboard()
	end
end)

hook.Add( "ScoreboardHide", "RogueScoreboard.Hide", function()
	local Main = RogueScoreboard.Main
	
	gui.EnableScreenClicker(false)

	if IsValid(Main) then			
		Main:AlphaTo( 0, 0.15, 0,
		function()
			Main:SetVisible( false )
		end)
	end
end)

--PATH addons/mc_quests/lua/autorun/mqs_autorun.lua:
-- ‚ïî‚ïê‚ïó‚ïî‚ïê‚ï¶‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïó‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- ‚ïë‚ïë‚ïö‚ïù‚ïë‚ïë‚ïî‚ïê‚ïó‚ïë‚ïî‚ïê‚ïó‚ïë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- ‚ïë‚ïî‚ïó‚ïî‚ïó‚ïë‚ïë‚îÄ‚ïë‚ïë‚ïö‚ïê‚ïê‚ïó‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- ‚ïë‚ïë‚ïë‚ïë‚ïë‚ïë‚ïë‚îÄ‚ïë‚ï†‚ïê‚ïê‚ïó‚ïë‚îÄ‚îÄBy MacTavish <3‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- ‚ïë‚ïë‚ïë‚ïë‚ïë‚ïë‚ïö‚ïê‚ïù‚ïë‚ïö‚ïê‚ïù‚ïë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- ‚ïö‚ïù‚ïö‚ïù‚ïö‚ï©‚ïê‚ïê‚ïó‚ï†‚ïê‚ïê‚ïê‚ïù‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïö‚ïù‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

MQS = {}
MQS.Config = {}

MQS.Quests = {}
MQS.Rewards = {}
MQS.Events = {}

MQS.TaskCount = {}
MQS.TaskQueue = {}
MQS.ActiveTask = {}

MQS.Version = "1.5.0"
MQS.ServerID = "MQS77656119820149711101ID"
MQS.MainUserID = "76561198201497111"
MQS.DB = {}

if SERVER then
	util.AddNetworkString( "MQS.Notify" )
	util.AddNetworkString( "MQS.TaskNotify" )
	util.AddNetworkString( "MQS.SetPData" )
	util.AddNetworkString( "MQS.GetBigData" )
	util.AddNetworkString( "MQS.DataShare" )
	util.AddNetworkString( "MQS.ReQuest" )
	util.AddNetworkString( "MQS.FixPickUP" )
	util.AddNetworkString( "MQS.GetPData" )
	util.AddNetworkString( "MQS.GetOtherQuests" )
	util.AddNetworkString( "MQS.OpenEditor" )
	util.AddNetworkString( "MQS.GetConfigData" )
	util.AddNetworkString( "MQS.SaveConfig" )
	util.AddNetworkString( "MQS.QuestRemove" )
	util.AddNetworkString( "MQS.QuestSubmit" )
	--util.AddNetworkString( "MQS.QuestUpdate" )
	util.AddNetworkString( "MQS.QuestStatus" )
	util.AddNetworkString( "MQS.CreateNPC" )
	util.AddNetworkString( "MQS.UpdateNPC" )
	util.AddNetworkString( "MQS.StartTask" )
	util.AddNetworkString( "MQS.UIEffect" )
	util.AddNetworkString( "MQS.GetPlayersQuests" )
	util.AddNetworkString( "MQS.SavePlayerQuestList" )

	resource.AddWorkshop( "2486994157" )
end

function MQS.Load()

	MsgC( Color(0, 255, 0), "[MQS] Initialization started\n" )
	if !MSD then
		MsgC( Color(255, 0, 0), "[MQS] FAILED To locate MSD module!\nPlease install MSD before using the addon\nLink: https://github.com/the-mactavish/MSD\n" )
	end

	if !file.Exists(MQS.ServerID, "DATA") then
		file.CreateDir(MQS.ServerID)
		MsgC( Color(0, 255, 0), "[MQS] Server DATA Dir created \n" )
	end

	if SERVER then
		MsgC( Color(0, 255, 0), "[MQS] Loading server files\n" )
		include("mqs/sh_config.lua")
		AddCSLuaFile("mqs/sh_config.lua")
		local core = file.Find( "mqs/core/*", "LUA" )
		for k,v in ipairs( core ) do
			if string.StartWith( v, "sh_" ) then
				include( "mqs/core/" .. v )
				AddCSLuaFile( "mqs/core/" .. v )
			elseif string.StartWith( v, "sv_" ) then
				include( "mqs/core/" .. v )
			elseif string.StartWith( v, "cl_" ) then
				AddCSLuaFile( "mqs/core/" .. v )
			end
		end

		local ui = file.Find( "mqs/ui/*", "LUA" )
		for k,v in ipairs( ui ) do
			AddCSLuaFile( "mqs/ui/" .. v )
		end

	else
		MsgC( Color(0, 255, 0), "[MQS] Loading client files\n" )
		include("mqs/sh_config.lua")

		local core = file.Find( "mqs/core/*", "LUA" )
		for k,v in ipairs( core ) do
			if string.StartWith( v, "sh_" ) then
				include( "mqs/core/" .. v )
			elseif string.StartWith( v, "cl_" ) then
				include( "mqs/core/" .. v )
			end
		end

		local ui = file.Find( "mqs/ui/*", "LUA" )
		for k,v in ipairs( ui ) do
			include( "mqs/ui/" .. v )
		end
	end

	MsgC( Color(0, 255, 0), "[MQS] Initialization done\n" )
end

if SERVER then
	MQS.Load()
	hook.Add("PostGamemodeLoaded", "MQS.Load.SV", function() MQS.Load() end)
else
	hook.Add("InitPostEntity", "MQS.Load.CL", function() MQS.Load() end)
end

if GAMEMODE then
	MQS.Load()
end
--PATH addons/msd_ui/lua/msd/language/fr.lua:
MSD.Language["fr"] = {

	-- UI

	lang_name = "French",

	ok = "OK",
	map = "Map",
	off = "Off",
	on = "On",
	time_add = "Il est temps d'ajouter",
	type = "Taper",
	delay = "Retard",
	cancel = "Annuler",
	enable = "Activ√©",
	model = "Model",
	name = "Nom",
	settings = "Param√®tre",
	editor = "√âditeur",
	red = "Rouge",
	green = "Vert",
	blue = "Bleu",
	admin_menu = "Menu d'administration",
	ui_settings = "Param√®tres de l'interface",
	active = "Actif",
	inactive = "Inactif",
	disabled = "D√©sactiv√©e",
	warning = "Avertissement!",
	remove = "Supprimer",
	theme = "Th√®me",
	dark_theme = "Th√®me sombre",
	payment = "Paiement",
	load_autosave = "Charger la derni√®re sauvegarde automatique?",
	load_save = "Chargement de la sauvegarde",
	create_new = "Cr√©er un nouveau",
	enable_option = "Activer l'option",
	main_opt = "Options principales",
	copy_data = "Copier des donn√©es",
	save_chng = "Sauvegarder les modifications",
	enter_name = "Entrez le nom",
	enter_id = "Entrez l'ID",
	confirm_action = "Veuillez confirmer vos actions",
	check_fpr_errors = "Rechercher les erreurs",
	enter_description = "Entrez la description",
	cooldown_ok = "Temps de recharge en cas de succ√®s",
	cooldown_fail = "Temps de recharge en cas d'√©chec",
	s_team_whitelist = "Configuration de la TEAM Whitelist",
	whitelist_blacklist = "La liste blanche est une liste noire",
	custom_val = "D√©finir une valeur personnalis√©e",
	set_hp_full = "D√©finir les HP complets",
	dist_to_close = "Distance au plus proche",

	e_text = "Entrez du texte",
	e_number = "Entrez un nombre",
	e_class = "Entrer une classe",
	e_value = "Entrez une valeur",
	e_blank_dis = "Laisser vide pour d√©sactiver",
	e_blank_default = "Laissez le noir pour utiliser la valeur par d√©faut",
	e_url = "Entrer une URL",
	e_model = "Entrez le chemin du mod√®le",
	e_material = "Entrez le chemin du mat√©riau",
	e_wep_class = "Entrez la classe d'une arme",
	e_ent_class = "Entrez la classe de l'entit√©",
	e_veh_class = "Entrez la classe du v√©hicule",
	e_npc_class = "Entrez la classe du NPC",

	select_ammo = "Munitions s√©lectionn√©es",
	amount_ammo = "Montant des munitions",
	disable_phys = "D√©sactiver la physique",
	none = "Rien",
	custom_icon = "D√©finir une ic√¥ne personnalis√©e",
	weapon_name = "Nom de l'arme",
	moveup = "d√©placer vers le haut",
	movedown = "d√©placer vers le bas",
	movepoint = "D√©placer le point",
	swap = "√âchanger",
	swapmod = "Swap mod activ√©. Cliquez pour d√©sactiver",
	copy_from_ent = "Copier de l'entit√© recherch√©e",
	set_pos_self = "R√©glez votre position",
	set_pos_aim = "D√©finir le point de recherche",
	spawn_point = "Point d'apparition",
	spawn_ang = "Angle d'apparition",
	mark_area = "Marquer la zone",
	time_wait = "Il est temps d'attendre",
	map_marker = "S√©lectionnez un marqueur de map",
	in_sec = "en secondes",
	def_units = "D√©faut %s unit√©s", -- "350 unit√©s par d√©faut" laisser %s tel quel
	def_seconds = "D√©faut %s secondes", -- "Par d√©faut, 10 secondes" laisser %s comme si
	ent_show_pointer = "Montrer poiter au-dessus de l'entit√©",
	ent_arcade_style = "Apparence d'entit√© de style arcade",
	ent_stnd_style = "Apparence d'entit√© standard",
	custom_color = "Activer la couleur personnalis√©e",
	mat_default = "Laisser vide pour le mat√©riau par d√©faut",

	set_ui = "Param√®tres de l'interface utilisateur",
	set_hud = "Param√®tres du HUD",
	set_hud_pos = "Position du HUD de qu√™te",
	set_hud_themes = "Th√®mes HUD",
	set_server = "Param√®tres du serveur",
	set_ui_blur = "Arri√®re-plan flou",
	set_ui_mono = "Fond monochrome",
	set_ui_vignette = "Effet de vignette pour l'arri√®re-plan",
	set_ui_brightness = "Luminosit√© d'arri√®re-plan",
	set_ui_color = "S√©lectionnez la couleur principale",
	set_ui_align_left = "Alignement horizontal vers la gauche",
	set_ui_align_right = "Alignement horizontal vers la droite",
	set_ui_align_top = "Alignement vertical vers le haut",
	set_ui_align_bottom = "Alignement vertical vers le bas",
	set_ui_offset_h = "D√©calage horizontal",
	set_ui_offset_v = "D√©calage vertical",

	upl_changes = "T√©l√©charger les modifications sur le serveur",
	res_changes = "Restaurer les modifications",

	-- Joueur

	dead = "Restaurer les modifications",
	time_ex = "Le temps est √©coul√©",
	vehicle_bum = "Votre v√©hicule est d√©truit",
	left_area = "Vous avez quitt√© la zone",
	m_blew = "Vous avez fait sauter la mission",
	m_failed = "Mission √©chou√©e",
	m_success = "Succ√®s de la mission",
	m_loop = "Mise √† jour de la mission",

	-- Erreurs

	inv_quest = "Qu√™te invalide",
	team_bl = "Votre √©quipe est sur liste noire",
	no_players = "Le serveur a besoin de plus de joueurs pour √™tre en ligne avant de pouvoir le faire",
	no_players_team = "Le serveur a besoin de plus de joueurs pour que des TEAM sp√©cifiques soient en ligne avant que vous puissiez le faire",
	need_admin = "Seuls les administrateurs peuvent effectuer cette action",

	-- Qu√™te

	active_quest = "Vous avez une qu√™te active",
	inactive_quest = "Vous ne pouvez pas jouer √† cette qu√™te",
	quest_editor = "√âditeur de qu√™te",
	quest_list = "Liste des qu√™tes",
	quests = "Qu√™tes",
	leave_pnt = "Quitter le point",

	q_editobj = "Modifier les objectifs",
	q_incvobj = "Objectif invalide",
	q_setobj = "Param√®tres d'objectifs",
	q_newobj = "Ajouter un nouvel objectif",
	q_editrwd = "Modifier les r√©compenses",
	q_rwdeditor = "√âditeur de r√©compenses",
	q_rwdlist = "Liste de r√©compenses",
	q_rwdsets = "Param√®tres de r√©compense",
	q_findmap = "Trouver une qu√™te sur d'autres cartes",
	q_obj_des = "Description de l'objectif",
	q_dist_point = "Distance au point",
	q_dist_from_point = "Distance du point",
	q_ignore_veh = "Ignorer le v√©hicule de qu√™te",
	q_timer_show = "Montrez le chronom√®tre au joueur",
	q_area_stay = "Le joueur doit rester dans la zone",
	q_start = "D√©marrer la qu√™te",
	q_new = "Nouvelle qu√™te",
	q_submit = "Soumettre la qu√™te",
	q_addnew = "Ajouter une nouvelle qu√™te",
	q_remove = "Supprimer la qu√™te",
	q_id_unique = "L'ID doit √™tre unique pour chaque qu√™te",
	q_complete_msg = "Message complet de la qu√™te",
	q_dotime = "Message complet de la qu√™te",
	q_dotime_ok = "R√©ussir la qu√™te √† la fin du temps",
	q_dotime_fail = "√âchec de la qu√™te √† la fin du temps",
	q_death_fail = "√âchec de la qu√™te √† la mort du joueur",
	q_loop = "T√¢ches de qu√™te en boucle",
	q_loop_reward = "R√©compensez le joueur sur chaque boucle",
	q_enable = "Activer la qu√™te",
	q_events = "√âv√©nements",
	q_eventadd = "Ajouter un √©v√®nement",
	q_eventedit = "Modification d'√©v√©nement",
	q_eventremove = "Supprimer l'√©v√©nement",
	q_in_progress = "Qu√™te en cours",
	q_time_left = "Temps restant",
	q_ply_limit = "Limite de joueurs pour la qu√™te",
	q_ply_team_limit = "Limites de l'√©quipe de configuration",
	q_ply_team_need = "Joueurs d'√©quipe n√©cessaires",
	q_ply_need = "Quantit√© de joueur n√©cessaire pour commencer",
	q_play_limit = "Il y a une limite au nombre de joueurs pouvant jouer √† cette qu√™te",
	q_must_stay_area = "Vous devez rester dans cette zone, sinon la qu√™te √©chouera",
	q_time_wait = "Vous devez attendre avant de rejouer cette qu√™te",
	q_dotime_reset = "R√©initialiser le temps de la qu√™te",
	q_dotime_add = "Ajouter une qu√™te √† faire",
	q_noreplay = "Vous ne pouvez pas rejouer cette qu√™te",
	q_dis_replay = "D√©sactiver la relecture de qu√™te",
	q_needquest = "Vous devez d'abord terminer une autre qu√™te",
	q_needquest_menu = "Requiert une qu√™te termin√©e",
	q_enterror = "Les entit√©s de qu√™te ne sont pas apparues, v√©rifiez la configuration de la qu√™te",
	q_get = "Vous pouvez obtenir une qu√™te de ces PNJ",
	q_noquests = "Il n'y a pas encore moyen de jouer des qu√™tes :(",
	q_ent_draw = "Distance de tirage de l'entit√© de qu√™te",
	q_loop_stop_key = "Cl√© d'arr√™t de qu√™te en boucle",
	q_hold_key_stop = "Pour arr√™ter la suspension de qu√™te [%s] ", -- Pour arr√™ter la suspension de qu√™te [P]
	q_enter_veh = "Entrez votre v√©hicule",
	q_npc_link = "Lier la qu√™te √† un PNJ",
	q_icon68 = "Entrez l'URL de l'ic√¥ne .PNG 68 x 68 px",
	q_ent_pos_show = "Afficher l'emplacement des entit√©s au joueur",
	q_area_size = "Taille de la zone",
	q_area_pos = "Position de la zone",
	q_s_area_size = "Taille de la zone de recherche",
	q_s_area_pos = "Position de la zone de recherche",
	q_npc_answer_ok = "R√©ponse positive du joueur",
	q_npc_answer_no = "R√©ponse n√©gative du joueur",
	q_npc_answer_noq = "R√©ponse du joueur si aucune qu√™te",
	q_npc_quest_no = "Discours des PNJ si aucune qu√™te",
	q_money_give = "De l'argent √† donner",

	-- Simple NPCs

	npc_editor = "√âditeur de PNJ",
	npc_new = "Nouveau PNJ",
	npc_select = "S√©lectionnez un PNJ",
	npc_e_speech = "Entrez le discours du PNJ",
	npc_submit = "Confirmer la cr√©ation du PNJ",
	npc_update = "Mettre √† jour le PNJ",
	npc_remove = "Supprimer un PNJ",
	npc_q_enable = "Activer les PNJ de qu√™te",
	npc_did_open = "ID de bo√Æte de dialogue √† ouvrir",
	npc_q_target = "NPC est une cible objective",
	npc_hostile = "PNJ hostile",

	-- Update 1.1.0

	cam_start = "Param√®tres de d√©part de la cam√©ra",
	cam_end = "Param√®tres de fin de la cam√©ra",
	cam_pos = "Position de la cam√©ra",
	cam_ang = "Angle de cam√©ra",
	cam_fov = "FOV de cam√©ra",
	cam_effect = "Effet d'obturateur de cam√©ra",
	q_open_target = "Autoriser les joueurs √† tuer les autres NPC",
	q_npc_mind = "Distance min. au NPC",
	not_spawned = "non apparu",
	dis_text = "Texte affich√©",
	cam_speed = "Vitesse de mouvement de la cam√©ra (nombre bas - mouvement lent)",
	fov_speed = "Vitesse du FOV de la cam√©ra (nombre bas - mouvement lent)",
	category_des = "Cat√©gorie de qu√™tes, utilis√© pour trier les qu√™tes",
	sortquests_cat = "Trier les qu√™tes par cat√©gorie",
	search_q = "Rechercher des qu√™tes",
	quest_tools = "Outils de qu√™te",
	set_anim = "Mettre une animation",
	s_quest_blacklist = "Configurer une liste noire de qu√™te", -- In France, we can say blacklist too 
	s_quest_blacklist_desc = "S√©lectionnez les qu√™tes qui vont se bloquer si elles sont jou√©es",
	hold_use = "Maintener la touche [%s]",
	duplicate = "Duplic√©",
	unsorted = "Non-tri√©",
	search = "Recherche",
	duration = "Dur√©e",
	category = "Cat√©gorie",
	blacklist = "Liste noire",


	--  Update 1.2.0

	restore_wep = "Restorer les armes √† la fin de la qu√™te",
	e_cmd = "Entrer une commande console",
	e_args = "Entrer des commandes d'arguments",
	hint_cmd = "Autoremplissage de raccourcis : \n$uid - IDJoueur, \n$sid - SteamID,  \n$s64 - SteamID 64, \n$n - No du joueur",
	youaretracked = "Votre position est compromise par d'autres joueurs !",
	border_rounded = "Design de bordure ronde",
	border_square = "Design de bordure carr√©e",
	access_settings = "Acc√®s au menu",
	compact_obj = "Compacter la liste des objectifs pour les qu√™tes",
	e_usergroup = "Entrer un groupe d'utilisateurs",
	ug_isanadmin = "Ce groupe d'utilisateur √† d√©j√† des pleins acc√®s",
	find_player_id32 = "Trouver un joueur par le SteamID 32",
	user_data = "√âditeur de donn√©es",
	access_editors = "Acc√®s √† configurer l'√©diteur de qu√™tes",
	access_admins = "Mettre des acc√®s complets",
	add_usergroup = "Ajouter un utilisateur au groupe",
	edit_objmod = "√âditer les objectifs du mode",
	editmod = "√âditer des modes",
	move = "D√©placer",
	q_errorloop = "Qu√™te dans une loupe infinie",
	q_cooldow_perply = "Compteur de temps public",
	q_cooldow_publick = "Compteur de temps par joueur",
	q_stop_anytime = "Autoriser manuellement l'abandon de qu√™tes",
	quest_abandon = "Vous avez abandonn√© la qu√™te",
	q_dotime_set = "Configurer la fin de qu√™te √† la fin d'un temps",


	-- Ranks

	enter_path_or_url = "Entrer l'emplacement ou l'URL",
	rank_edit = "Configuration des grades",
	rank_list = "Liste de grades",
	group_list = "Liste des groupes",
	group_addnew = "Ajouter un nouveau groupe",
	blank = "Blanc",
	mrs_show_all = "Montrer les grades √† tous les joueurs",
	mrs_show_team = "Montrer les grades uniquement au groupe",
	mrs_use_sn = "Afficher des noms de grade courts",
	use_url = "Utiliser une URL",
	enter_srt_name = "Entrer un nom court",
	srt_name = "Nom court",
	mrs_prom_demote = "Les prochaines 2 options affectent uniquement les grades les plus bas. Les joueurs ne pourront pas promotionner les autres joueurs les hauts grades ou le m√™me grade.",
	mrs_whilelist = "Si vous s√©lectionnez un grade requis pour un job, le joueur pourra jouer avec le job que si il a le grade d√©fini ou plus.",
	can_promote = "Peut promotionner le grade d'un joueur",
	can_demote = "Peut r√©trograder le grade d'un joueur",
	edit_player_model = "√âditer le playermodel personnalis√©",
	enable_player_model = "Activer le playermodel personnalis√©",
	disable_player_model = "D√©sactiver le playermodel personnalis√©",
	edit_custom_stats = "√âditer les stats personnalis√©s du joueur",
	autoprom = "Auto-promotionner au prochain grade",
	in_min = "en minutes",
	mrs_promoted = "Vous avez √©t√© promotionn√©",
	mrs_demoted = "Vous avez √©t√© r√©trograd√©",
	mrs_job_smallrank = "Vous devez √™tre %s ou plus pour jouer en tant que %s",
	show_group = "Montrer uniquement le nom du grade",
	hide_rank = "Montrer uniquement l'icone du grade",
	mrs_hud_follow = "Rotatationner l'UI autour du joueur d√©pendant de la vue de l'angle",
	set_overhead = "UI de l'information du joueur",
	offline_users = "Utilisateurs hors-ligne",
	mrs_noranks = "Votre m√©tier actuel n'a pas de grades",
	mrs_nopower = "Votre grade actuel n'a pas plus de permissions",
	promotion = "Promotion",
	on_duty = "En service",
	other_players = "Autres joueurs",
	mrs_change_jobname = "Changer le job au nom du grade",
	mrs_set_prefix = "Ajouter le nom du grade au pr√©fix du nom du m√©tier",
}

-- Other phrases
local lng = "fr"

MSD.Language[lng]["Move to point"] = "D√©placer vers le point"
MSD.Language[lng]["Leave area"] = "Quitter la zone"
MSD.Language[lng]["Kill NPC"] = "Tuer un NPC"
MSD.Language[lng]["Collect quest ents"] = "Collecter les ents de qu√™te"
MSD.Language[lng]["Talk to NPC"] = "Parler √† NPC"
MSD.Language[lng]["Wait time"] = "Temps d'attente"

MSD.Language[lng]["There is no quests avalible"] = "Il n'y a pas de qu√™tes disponibles"

MSD.Language[lng]["Give weapon"] = "Donner une arme"
MSD.Language[lng]["Give ammo"] = "Donner des munitions"
MSD.Language[lng]["Strip Weapon"] = "Arme de bande"
MSD.Language[lng]["Spawn quest entity"] = "Entit√© de qu√™te d'apparition"
MSD.Language[lng]["Spawn entity"] = "Entit√© d'apparition"
MSD.Language[lng]["Spawn npc"] = "Apparition du npc"
MSD.Language[lng]["Manage do time"] = "G√©rer le temps de travail"
MSD.Language[lng]["Spawn vehicle"] = "Apparition du v√©hicule"
MSD.Language[lng]["Remove vehicle"] = "Retirer le v√©hicule"
MSD.Language[lng]["Remove all entites"] = "Supprimer toutes les entit√©s"
MSD.Language[lng]["Set HP"] = "D√©finir HP"
MSD.Language[lng]["Set Armor"] = "D√©finir l'armure"

MSD.Language[lng]["DarkRP Money"] = "Argent DarkRP"

MSD.Language[lng]["Quest NPCs are disabled"] = "Les PNJ de qu√™te sont d√©sactiv√©s"
MSD.Language[lng]["You can enable them in settings"] = "Vous pouvez les activer dans les param√®tres"
--PATH addons/msd_ui/lua/msd/ui/msdframe.lua:
local PANEL = {}
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDraggable", "Draggable", FORCE_BOOL)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_bScreenLock", "ScreenLock", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDeleteOnClose", "DeleteOnClose", FORCE_BOOL)
AccessorFunc(PANEL, "m_bPaintShadow", "PaintShadow", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

function PANEL:Init()
	self:SetFocusTopLevel(true)
	self:SetPaintShadow(true)
	self:SetDraggable(true)
	self:SetSizable(false)
	self:SetScreenLock(false)
	self:SetDeleteOnClose(true)
	self:SetMinWidth(50)
	self:SetMinHeight(50)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self.m_fCreateTime = SysTime()

	self.WorkSpace = {
		x = 0,
		y = 52,
		w = 0,
		h = 0
	}

	self.WorkComponents = {}
end

function PANEL:Close()
	self:SetVisible(false)

	if (self:GetDeleteOnClose()) then
		self:Remove()
	end

	self:OnClose()
end

function PANEL:OnClose()
end

function PANEL:Center()
	self:InvalidateLayout(true)
	self:CenterVertical()
	self:CenterHorizontal()
end

function PANEL:IsActive()
	if (self:HasFocus()) then return true end
	if (vgui.FocusedHasParent(self)) then return true end

	return false
end

function PANEL:Think()
	local mousex = math.Clamp(gui.MouseX(), 1, ScrW() - 1)
	local mousey = math.Clamp(gui.MouseY(), 1, ScrH() - 1)

	if (self.Dragging) then
		local x = mousex - self.Dragging[1]
		local y = mousey - self.Dragging[2]

		-- Lock to screen bounds if screenlock is enabled
		if (self:GetScreenLock()) then
			x = math.Clamp(x, 0, ScrW() - self:GetWide())
			y = math.Clamp(y, 0, ScrH() - self:GetTall())
		end

		self:SetPos(x, y)
	end

	if (self.Sizing) then
		local x = mousex - self.Sizing[1]
		local y = mousey - self.Sizing[2]
		local px, py = self:GetPos()

		if (x < self.m_iMinWidth) then
			x = self.m_iMinWidth
		elseif (x > ScrW() - px and self:GetScreenLock()) then
			x = ScrW() - px
		end

		if (y < self.m_iMinHeight) then
			y = self.m_iMinHeight
		elseif (y > ScrH() - py and self:GetScreenLock()) then
			y = ScrH() - py
		end

		self:SetSize(x, y)
		self:SetCursor("sizenwse")

		return
	end

	local screenX, screenY = self:LocalToScreen(0, 0)

	if (self.Hovered and self.m_bSizable and mousex > (screenX + self:GetWide() - 20) and mousey > (screenY + self:GetTall() - 20)) then
		self:SetCursor("sizenwse")

		return
	end

	if (self.Hovered and self:GetDraggable() and mousey < (screenY + 24)) then
		self:SetCursor("sizeall")

		return
	end

	self:SetCursor("arrow")

	-- Don't allow the frame to go higher than 0
	if (self.y < 0) then
		self:SetPos(self.x, 0)
	end
end

function PANEL:AddToWorkSpace(panel)
	panel:SetParent(self)
	panel:SetSize(self.WorkSpace.w, self.WorkSpace.h)
	panel:SetPos(self.WorkSpace.x, self.WorkSpace.y)
	local id = table.insert(self.WorkComponents, panel)

	panel.OnRemove = function()
		self.WorkComponents[id] = nil
	end
end

function PANEL:Paint(w, h)
	return true
end

function PANEL:OnMousePressed()
	local screenX, screenY = self:LocalToScreen(0, 0)

	if (self.m_bSizable and gui.MouseX() > (screenX + self:GetWide() - 20) and gui.MouseY() > (screenY + self:GetTall() - 20)) then
		self.Sizing = {gui.MouseX() - self:GetWide(), gui.MouseY() - self:GetTall()}

		self:MouseCapture(true)

		return
	end

	if (self:GetDraggable() and gui.MouseY() < (screenY + 24)) then
		self.Dragging = {gui.MouseX() - self.x, gui.MouseY() - self.y}

		self:MouseCapture(true)

		return
	end
end

function PANEL:OnMouseReleased()
	self.Dragging = nil
	self.Sizing = nil
	self:MouseCapture(false)
end

function PANEL:PerformLayout()
	local Wide = self:GetWide()
	local Tall = self:GetTall()

	self.WorkSpace = {
		x = 0,
		y = 52,
		w = Wide,
		h = Tall - 52
	}

	if self.WorkComponents and #self.WorkComponents > 0 then
		for i = 1, #self.WorkComponents do
			local panel = self.WorkComponents[i]

			if panel and IsValid(panel) then
				panel:SetSize(self.WorkSpace.w, self.WorkSpace.h)
				panel:SetPos(self.WorkSpace.x, self.WorkSpace.y)
				panel:InvalidateLayout()
			end
		end
	end
end

derma.DefineControl("MSDSimpleFrame", "A simple window for msd", PANEL, "EditablePanel")
--PATH addons/msd_ui/lua/msd/ui/msdmenu.lua:
if SERVER then return end
local tblOpenMenus = {}

function RegisterDermaMenuForClose(dmenu)
	table.insert(tblOpenMenus, dmenu)
end

function MSD.MenuOpen(parentmenu, parent, bg)
	if (not parentmenu) then
		CloseDermaMenus()
	end

	local dmenu = vgui.Create("MSD.DMenu", parent)
	dmenu.ShadowStatic = 0
	dmenu.ShadowInt = 1

	dmenu.Paint = function(self, w, h)
		if bg then
			draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["d_na"])
		else
			MSD.Blur(self, 1, 2, 255, 55, w, h)
			draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["d"])
		end
	end

	return dmenu
end

function CloseDermaMenus()
	for k, dmenu in pairs(tblOpenMenus) do
		if (IsValid(dmenu)) then
			dmenu:SetVisible(false)

			if (dmenu:GetDeleteSelf()) then
				dmenu:Remove()
			end
		end
	end

	tblOpenMenus = {}
	hook.Run("CloseDermaMenus")
end

local function DermaDetectMenuFocus(panel, mousecode)
	if (IsValid(panel)) then
		if (panel.m_bIsMenuComponent) then return end

		return DermaDetectMenuFocus(panel:GetParent(), mousecode)
	end

	CloseDermaMenus()
end

hook.Add("VGUIMousePressed", "MatDMenuDetectMenuFocus", DermaDetectMenuFocus)
local PANEL = {}
AccessorFunc(PANEL, "m_bBorder", "DrawBorder")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_bDrawColumn", "DrawColumn")
AccessorFunc(PANEL, "m_iMaxHeight", "MaxHeight")
AccessorFunc(PANEL, "m_pOpenSubMenu", "OpenSubMenu")

function PANEL:Init()
	self:SetIsMenu(true)
	self:SetDrawBorder(true)
	self:SetPaintBackground(true)
	self:SetMinimumWidth(100)
	self:SetDrawOnTop(true)
	self:SetMaxHeight(ScrH() * 0.9)
	self:SetDeleteSelf(true)
	self:SetPadding(0)
	RegisterDermaMenuForClose(self)
end

function PANEL:AddOption(strText, funcFunction, icon, check)
	if check and not check() then return end

	local pnl = vgui.Create("MSD.DMenuOption", self)
	pnl:SetMenu(self)
	pnl:SetText(strText)
	if icon then
		pnl.icon = icon
		pnl:SetTextInset(38, 0)
	end

	if (funcFunction) then
		pnl.DoClick = funcFunction
	end

	self:AddPanel(pnl)

	return pnl
end

function PANEL:AddSubMenu(strText, funcFunction)
	local pnl = vgui.Create("MSD.DMenuOption", self)
	local SubMenu = pnl:AddSubMenu(strText, funcFunction)
	pnl:SetText(strText)

	if (funcFunction) then
		pnl.DoClick = funcFunction
	end

	self:AddPanel(pnl)

	return SubMenu, pnl
end

derma.DefineControl("MSD.DMenu", "A Menu 2", PANEL, "DMenu")

PANEL = {}
AccessorFunc(PANEL, "m_pMenu", "Menu")
AccessorFunc(PANEL, "m_bChecked", "Checked")
AccessorFunc(PANEL, "m_bCheckable", "IsCheckable")

function PANEL:Init()
	self:SetContentAlignment(4)
	self:SetTextInset(10, 0)
	self:SetFont("MSDFont.16")
	self:SetTextColor(MSD.Text["s"])
	self:SetChecked(false)
	self.ChangeCC = true
	self.ColorText = MSD.Text["s"]
end

function PANEL:OnCursorEntered()
	self.ColorText = MSD.Config.MainColor["p"]
	self.ChangeCC = true

	if (IsValid(self.ParentMenu)) then
		self.ParentMenu:OpenSubMenu(self, self.SubMenu)

		return
	end

	self:GetParent():OpenSubMenu(self, self.SubMenu)
end

function PANEL:OnCursorExited()
	self.ColorText = MSD.Text["l"]
	self.ChangeCC = true
end

function PANEL:AddSubMenu()
	local SubMenu = MSD.MenuOpen(true, self)
	SubMenu:SetVisible(false)
	SubMenu:SetParent(self)
	self:SetSubMenu(SubMenu)

	return SubMenu
end

function PANEL:Paint(w, h)
	if self.ChangeCC then
		self:SetTextColor(self.ColorText)
		self.ChangeCC = nil
	end

	if self.icon then
		local ih = h - 6
		MSD.DrawTexturedRect(5, 3, ih, ih, self.icon, self.ColorText)
	end
end

function PANEL:PerformLayout( w, h )

	self:SizeToContents()
	self:SetWide( self:GetWide() + 30 )

	w = math.max( self:GetParent():GetWide(), self:GetWide() )

	self:SetSize( w, self.icon and 30 or 22 )

	if ( IsValid( self.SubMenuArrow ) ) then

		self.SubMenuArrow:SetSize( 15, 15 )
		self.SubMenuArrow:CenterVertical()
		self.SubMenuArrow:AlignRight( 4 )

	end

	DButton.PerformLayout( self, w, h )

end

derma.DefineControl("MSD.DMenuOption", "Menu Option Line 2", PANEL, "DMenuOption")
--PATH addons/sl_utils/lua/autorun/netstream.lua:
--A net extension which allows sending large streams of data without overflowing the reliable channel
--Keep it in lua/autorun so it will be shared between addons
AddCSLuaFile()

net.Stream = {}
net.Stream.SendSize = 20000 --This is the size of each packet to send
net.Stream.Timeout = 10 --How long to wait for client response before cleaning up
net.Stream.MaxWriteStreams = 1024 --The maximum number of write data items to store
net.Stream.MaxReadStreams = 128 --The maximum number of queued read data items to store
net.Stream.MaxChunks = 3200 --Maximum number of pieces the stream can send to the server. 64 MB
net.Stream.MaxSize = net.Stream.SendSize*net.Stream.MaxChunks
net.Stream.MaxTries = 3 --Maximum times the client may retry downloading the whole data

local WriteStreamQueue = {
	__index = {
		Add = function(self, stream)
			local identifier = self.curidentifier
			local startid = identifier
			while self.queue[identifier] do
				identifier = identifier % net.Stream.MaxWriteStreams + 1
				if identifier == startid then
					ErrorNoHalt("Netstream is full of WriteStreams!")
					net.WriteUInt(0, 32)
					return
				end
			end
			self.curidentifier = identifier % net.Stream.MaxWriteStreams + 1

			if next(self.queue)==nil then
				self.activitytimeout = CurTime()+net.Stream.Timeout
				timer.Create("netstream_queueclean", 5, 0, function() self:Clean() end)
			end
			self.queue[identifier] = stream
			stream.identifier = identifier
			return stream
		end,

		Write = function(self, ply)
			local identifier = net.ReadUInt(32)
			local chunkidx = net.ReadUInt(32)
			local stream = self.queue[identifier]
			--print("Got request", identifier, chunkidx, stream)
			if stream then
				if stream:Write(ply, chunkidx) then
					self.activitytimeout = CurTime()+net.Stream.Timeout
					stream.timeout = CurTime()+net.Stream.Timeout
				end
			else
				-- Tell them the stream doesn't exist
				net.Start("NetStreamRead")
				net.WriteUInt(identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(ply) else net.SendToServer() end
			end
		end,

		Clean = function(self)
			local t = CurTime()
			for k, stream in pairs(self.queue) do
				if (next(stream.clients)~=nil and t >= stream.timeout) or t >= self.activitytimeout then
					stream:Remove()
					self.queue[k] = nil
				end
			end
			if next(self.queue)==nil then
				timer.Remove("netstream_queueclean")
			end
		end,
	},
	__call = function(t)
		return setmetatable({
			activitytimeout = CurTime()+net.Stream.Timeout,
			curidentifier = 1,
			queue = {}
		}, t)
	end
}
setmetatable(WriteStreamQueue, WriteStreamQueue)
net.Stream.WriteStreams = WriteStreamQueue()

local ReadStreamQueue = {
	__index = {
		Add = function(self, stream)
			local queue = self.queues[stream.player]

			if #queue == net.Stream.MaxReadStreams then
				ErrorNoHalt("Receiving too many ReadStream requests!")
				return
			end
			
			for _, v in ipairs(queue) do
				if v.identifier == stream.identifier then
					ErrorNoHalt("Tried to start a new ReadStream for an already existing stream!")
					return
				end
			end

			queue[#queue+1] = stream
			if #queue == 1 then
				stream:Request()
			end
			return stream
		end,

		Remove = function(self, stream)
			local queue = rawget(self.queues, stream.player)
			if queue then
				if stream == queue[1] then
					table.remove(queue, 1)
					local nextInQueue = queue[1]
					if nextInQueue then
						nextInQueue:Request()
					else
						self.queues[stream.player] = nil
					end
				else
					for k, v in ipairs(queue) do
						if v == stream then
							table.remove(queue, k)
							break
						end
					end
				end
			end
		end,

		Read = function(self, ply)
			local identifier = net.ReadUInt(32)
			local queue = rawget(self.queues, ply)
			if queue and queue[1] then
				queue[1]:Read(identifier)
			end
		end
	},
	__call = function(t)
		return setmetatable({
			queues = setmetatable({}, {__index = function(t,k) local r={} t[k]=r return r end})
		}, t)
	end
}
setmetatable(ReadStreamQueue, ReadStreamQueue)
net.Stream.ReadStreams = ReadStreamQueue()


local WritingDataItem = {
	__index = {
		Write = function(self, ply, chunkidx)
			local client = self.clients[ply]
			if client.finished then return false end
			if chunkidx == #self.chunks+1 then self:Finished(ply) return true end

			if client.downloads+#self.chunks-client.progress >= net.Stream.MaxTries * #self.chunks then self:Finished(ply) return false end
			client.downloads = client.downloads + 1

			local chunk = self.chunks[chunkidx]
			if not chunk then return false end

			client.progress = chunkidx

			--print("Sending", "NetStreamRead", self.identifier, #chunk.data, chunkidx, chunk.crc)
			net.Start("NetStreamRead")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#chunk.data, 32)
			net.WriteUInt(chunkidx, 32)
			net.WriteString(chunk.crc)
			net.WriteData(chunk.data, #chunk.data)
			if CLIENT then net.SendToServer() else net.Send(ply) end
			return true
		end,

		Finished = function(self, ply)
			self.clients[ply].finished = true
			if self.callback then
				local ok, err = xpcall(self.callback, debug.traceback, ply)
				if not ok then ErrorNoHalt(err) end
			end
		end,

		GetProgress = function(self, ply)
			return self.clients[ply].progress / #self.chunks
		end,

		Remove = function(self)
			local sendTo = {}
			for ply, client in pairs(self.clients) do
				if not client.finished then
					client.finished = true
					if CLIENT or ply:IsValid() then sendTo[#sendTo+1] = ply end
				end
			end

			if next(sendTo)~=nil then
				--print("Sending", "NetStreamRead", self.identifier, 0)
				net.Start("NetStreamRead")
				net.WriteUInt(self.identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(sendTo) else net.SendToServer() end
			end
		end

	},
	__call = function(t, data, callback)
		local chunks = {}
		for i=1, math.ceil(#data / net.Stream.SendSize) do
			local datachunk = string.sub(data, (i - 1) * net.Stream.SendSize + 1, i * net.Stream.SendSize)
			chunks[i] = { data = datachunk, crc = util.CRC(datachunk) }
		end

		return setmetatable({
			timeout = CurTime()+net.Stream.Timeout,
			chunks = chunks,
			callback = callback,
			lasttouched = 0,
			clients = setmetatable({},{__index = function(t,k)
				local r = {
					finished = false,
					downloads = 0,
					progress = 0,
				} t[k]=r return r
			end})
		}, t)
	end
}
setmetatable(WritingDataItem, WritingDataItem)

local ReadingDataItem = {
	__index = {
		Request = function(self)
			if self.downloads+self.numchunks-#self.chunks >= net.Stream.MaxTries*self.numchunks then self:Remove() return end
			self.downloads = self.downloads + 1
			timer.Create("NetStreamReadTimeout" .. self.identifier, net.Stream.Timeout*0.5, 1, function() self:Request() end)
			self:WriteRequest()
		end,

		WriteRequest = function(self)
			--print("Requesting", self.identifier, #self.chunks)
			net.Start("NetStreamWrite")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#self.chunks+1, 32)
			if CLIENT then net.SendToServer() else net.Send(self.player) end
		end,

		Read = function(self, identifier)
			if self.identifier ~= identifier then self:Request() return end

			local size = net.ReadUInt(32)
			if size == 0 then self:Remove() return end

			local chunkidx = net.ReadUInt(32)
			if chunkidx ~= #self.chunks+1 then self:Request() return end

			local crc = net.ReadString()
			local data = net.ReadData(size)

			if crc ~= util.CRC(data) then self:Request() return end

			self.chunks[chunkidx] = data
			if #self.chunks == self.numchunks then self:Remove(true) return end

			self:Request()
		end,

		GetProgress = function(self)
			return #self.chunks/self.numchunks
		end,

		Remove = function(self, finished)
			timer.Remove("NetStreamReadTimeout" .. self.identifier)

			local data
			if finished then
				data = table.concat(self.chunks)
				if self.compressed then
					data = util.Decompress(data, net.Stream.MaxSize)
				end
				self:WriteRequest() -- Notify we finished
			end

			local ok, err = xpcall(self.callback, debug.traceback, data)
			if not ok then ErrorNoHalt(err) end

			net.Stream.ReadStreams:Remove(self)
		end
	},
	__call = function(t, ply, callback, numchunks, identifier, compressed)
		return setmetatable({
			identifier = identifier,
			chunks = {},
			compressed = compressed,
			numchunks = numchunks,
			callback = callback,
			player = ply,
			downloads = 0
		}, t)
	end
}
setmetatable(ReadingDataItem, ReadingDataItem)


function net.WriteStream(data, callback, dontcompress)
	if not isstring(data) then
		error("bad argument #1 to 'WriteStream' (string expected, got " .. type(data) .. ")", 2)
	end
	if callback ~= nil and not isfunction(callback) then
		error("bad argument #2 to 'WriteStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local compressed = not dontcompress
	if compressed then
		data = util.Compress(data) or ""
	end

	if #data == 0 then
		net.WriteUInt(0, 32)
		return
	end

	if #data > net.Stream.MaxSize then
		ErrorNoHalt("net.WriteStream request is too large! ", #data/1048576, "MiB")
		net.WriteUInt(0, 32)
		return
	end

	local stream = net.Stream.WriteStreams:Add(WritingDataItem(data, callback, compressed))
	if not stream then return end
	
	--print("WriteStream", #stream.chunks, stream.identifier, compressed)
	net.WriteUInt(#stream.chunks, 32)
	net.WriteUInt(stream.identifier, 32)
	net.WriteBool(compressed)

	return stream
end

--If the receiver is a player then add it to a queue.
--If the receiver is the server then add it to a queue for each individual player
function net.ReadStream(ply, callback)
	if CLIENT then
		ply = NULL
	else
		if type(ply) ~= "Player" then
			error("bad argument #1 to 'ReadStream' (Player expected, got " .. type(ply) .. ")", 2)
		elseif not ply:IsValid() then
			error("bad argument #1 to 'ReadStream' (Tried to use a NULL entity!)", 2)
		end
	end
	if not isfunction(callback) then
		error("bad argument #2 to 'ReadStream' (function expected, got " .. type(callback) .. ")", 2)
	end
	
	local numchunks = net.ReadUInt(32)
	if numchunks == nil then
		return
	elseif numchunks == 0 then
		local ok, err = xpcall(callback, debug.traceback, "")
		if not ok then ErrorNoHalt(err) end
		return
	end

	local identifier = net.ReadUInt(32)
	local compressed = net.ReadBool()

	if numchunks > net.Stream.MaxChunks then
		ErrorNoHalt("ReadStream requests from ", ply, " is too large! ", numchunks * net.Stream.SendSize / 1048576, "MiB")
		return
	end

	--print("ReadStream", numchunks, identifier, compressed)

	return net.Stream.ReadStreams:Add(ReadingDataItem(ply, callback, numchunks, identifier, compressed))
end

if SERVER then
	util.AddNetworkString("NetStreamWrite")
	util.AddNetworkString("NetStreamRead")
end

--Send requested stream data
net.Receive("NetStreamWrite", function(len, ply)
	net.Stream.WriteStreams:Write(ply or NULL)
end)

--Download the sent stream data
net.Receive("NetStreamRead", function(len, ply)
	net.Stream.ReadStreams:Read(ply or NULL)
end)

--PATH addons/pcasino/lua/perfectcasino/derma/cl_elements.lua:
-- Function Cache
local color = Color
local draw_roundedbox = draw.RoundedBox
local draw_simpletext = draw.SimpleText
local draw_notexture = draw.NoTexture
local surface_setdrawcolor = surface.SetDrawColor
-- Color cache
local inputBlack = color(100, 100, 100)
local mainRed = color(155, 50, 50)
local mainBlack = color(38, 38, 38)
local textWhite = color(220, 220, 220)

-- Text Entry
local PANEL = {}
function PANEL:Init()
	self:DockMargin(5, 5, 5, 5)
	self:SetFont("pCasino.Textbox.Static")
	self:SetText("")
	self:SetDisplayText("Input")
end

function PANEL:SetDisplayText(text)
	self.placeholder = text
end

function PANEL:Paint(w, h)
	draw_roundedbox(3, 0, 0, w, h, mainRed)
	draw_roundedbox(3, 1, 1, w - 2, h - 2, mainBlack)

	self:DrawTextEntryText(textWhite, mainRed, mainRed)

	if(self:GetText() == "") and not self:HasFocus() then
		draw_simpletext(self.placeholder, "pCasino.Textbox.Static", 5, h/2, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
end
vgui.Register('pCasinoEntry', PANEL, 'DTextEntry')

-- Switch
-- Created by Livaco, edited by Owain.
local PANEL = {}
function PANEL:Init()
	self:SetText("")
	self.toggle = true

	self.lerp = 0.2
end
function PANEL:DoClick()
	self:Toggle()
end
function PANEL:Toggle()
	self:SetToggle(not self:GetToggle())
end
function PANEL:GetToggle()
	return self.toggle
end
function PANEL:SetToggle(value)
	self.toggle = value
end
function PANEL:Paint(w, h)
	draw_roundedbox(3, w*0.05, h*0.3, w*0.9, h*0.4, inputBlack)

	if self:GetToggle() then
		self.lerp = Lerp(0.1, self.lerp, 0.8)
	else
		self.lerp = Lerp(0.1, self.lerp, 0.2)
	end

	draw_notexture()
	surface_setdrawcolor(200-(200*self.lerp), 0+(200*self.lerp), 0, 255)
	PerfectCasino.UI.DrawCircle(w*self.lerp, h*0.5, h*0.35, 1)
end
vgui.Register('pCasinoSwitch', PANEL, 'DButton')


-- Circle Function
-- Created by Ben.
local sinCache = {}
local cosCache = {}
for i = 0, 360 do
	sinCache[i] = math.sin(math.rad(i))
	cosCache[i] = math.cos(math.rad(i))
end
function PerfectCasino.UI.DrawCircle(x, y, r, step)
    local positions = {}

    for i = 0, 360, step do
        table.insert(positions, {
            x = x + cosCache[i] * r,
            y = y + sinCache[i] * r
        })
    end

    return surface.DrawPoly(positions)
end

-- Rotate around point
-- Taken from wiki: https://wiki.facepunch.com/gmod/surface.DrawTexturedRectRotated
function PerfectCasino.UI.DrawTexturedRectRotatedPoint(x, y, w, h, rot, x0, y0)
	local c = math.cos(math.rad(rot))
	local s = math.sin(math.rad(rot))
	
	local newx = y0 * s - x0 * c
	local newy = y0 * c + x0 * s
	
	surface.DrawTexturedRectRotated(x + newx, y + newy, w, h, rot)
end

-- Rotate text
-- Taken from wiki: https://wiki.facepunch.com/gmod/cam.PushModelMatrix
function PerfectCasino.UI.TextRotated(text, x, y, color, font, ang, shift)
	local mat = Matrix()
	mat:Rotate(Angle(0, ang, 0))
	mat:SetTranslation(Vector(x, y, shift or 0))
	
	cam.PushModelMatrix(mat, true)
	    draw_simpletext(text, font, 0, 0, color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	cam.PopModelMatrix()    
end

-- Apply st, nd, rd, th to a number. This only works to 20, but there will never be an internal usecase past 20
-- Taken from xSits: A custom addon written by Owain
function PerfectCasino.UI.NumberSuffix(i)
	if i == 1 then
		return i.."st"
	elseif i == 2 then
		return i.."nd"
	elseif i == 3 then
		return i.."rd"
	end

	return i.."th"
end

-- Wrap text
-- Taken from XYZUI: A custom UI library written by Owain
function PerfectCasino.UI.WrapText(text, wrap, font, posx, posy, color, align1, align2)
	text = string.Explode("", text)

	local newText = {}
	for i=1, math.ceil(#text/wrap) do
		newText[i] = ""
		for p=1 + ((i-1)*wrap), i*wrap do
			if not text[p] then break end

			newText[i] = newText[i]..text[p]
		end
	end

	text = newText

	local space = 30*#text
	local startingPos = posy-(space/2)+(30/2)

	for k, v in pairs(text) do
		draw_simpletext(v, font, posx, startingPos+((k-1)*30), color or color_white, align1, align2)
	end
end

--PATH lua/autorun/rppropsextanded_init.lua:
local cvar = CreateConVar("rppropsex_hide", -1, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Show Roleplay Props Extended in the spawnmenu")

if SERVER then

	if (cvar:GetInt() == -1) then -- Default convars don't seem to be sent to clients
		cvar:SetInt(0)
	end

else

	local models = {
		["–ì–æ—Å—Ç–∏–Ω–∞—è"] = {
			"models/U4Lab/tv_monitor_plasma.mdl",
			"models/gmod_tower/suitetv.mdl",
			"models/scenery/furniture/coffeetable1/vestbl.mdl",
			"models/props_interiors/chairlobby01.mdl",
			"models/props_warehouse/office_furniture_couch.mdl",
			"models/props_vtmb/armchair.mdl",
			"models/props_vtmb/sofa.mdl",
			"models/props_interiors/sofa01.mdl",
			"models/props_interiors/sofa02.mdl",
			"models/props_interiors/sofa_chair02.mdl",
			"models/props_interiors/ottoman01.mdl",
			"models/env/furniture/decosofa_wood/decosofa_wood_dou.mdl",
			"models/Highrise/lobby_chair_01.mdl",
			"models/Highrise/lobby_chair_02.mdl",
			"models/props_interiors/desk_motel.mdl",
			"models/props_furniture/piano.mdl",
			"models/props_furniture/piano_bench.mdl",
			"models/props_interiors/painting_landscape01.mdl",
			"models/props_interiors/painting_portrait01.mdl",
			"models/props_furniture/picture_frame8.mdl",
			"models/props_urban/hotel_curtain001.mdl",
			"models/props_plants/plantairport01.mdl",
			"models/Highrise/potted_plant_05.mdl",
			"models/env/decor/tall_plant_b/tall_plant_b.mdl",
			"models/env/decor/plant_decofern/plant_decofern.mdl",
			"models/sunabouzu/theater_table.mdl",
			"models/testmodels/apple_display.mdl",
			"models/testmodels/coffee_table_long.mdl",
			"models/testmodels/macbook_pro.mdl",
			"models/testmodels/sofa_double.mdl",
			"models/testmodels/sofa_single.mdl",
			"models/splayn/rp/lr/chair.mdl",
			"models/splayn/rp/lr/couch.mdl",
			"models/props/slow/glass_table_low/slow_glass_table_low.mdl",
			"models/sunabouzu/lobby_chair.mdl",
			"models/sunabouzu/lobby_poster.mdl",
			"models/sunabouzu/lobby_poster_small.mdl",
			"models/props/cs_office/table_coffee.mdl",
			"models/props/cs_office/sofa.mdl",
			"models/props/cs_office/sofa_chair.mdl",
			"models/props/de_tides/patio_chair.mdl",
			"models/chairs/armchair.mdl",
			"models/props/cs_militia/couch.mdl",
			"models/props/de_inferno/tableantique.mdl",
			
			},
		["–ö—É—Ö–Ω—è"] = {
			"models/props_interiors/refrigerator03.mdl",
			"models/sickness/fridge_01.mdl",
			"models/sickness/stove_01.mdl",
			"models/props_interiors/sink_kitchen.mdl",
			"models/props_interiors/coffee_maker.mdl",
			"models/props_interiors/chair01.mdl",
			"models/props_interiors/chair_cafeteria.mdl",
			"models/props_interiors/dining_table_round.mdl",
			"models/props_interiors/dinning_table_oval.mdl",
			"models/props_interiors/trashcankitchen01.mdl",
			"models/props_unique/showercurtain01.mdl",
			"models/props/cs_office/microwave.mdl",
			},
		["–í–∞–Ω–Ω–∞—è"] = {
			"models/env/furniture/wc_double_cupboard/wc_double_cupboard.mdl",
			"models/env/furniture/square_sink/sink_double.mdl",
			"models/env/furniture/square_sink/sink_merged_b.mdl",
			"models/env/furniture/showerbase/showerbase.mdl",
			"models/env/furniture/shower/shower.mdl",
			"models/props_interiors/bathtub01.mdl",
			"models/env/furniture/ensuite1_toilet/ensuite1_toilet.mdl",
			"models/env/furniture/ensuite1_toilet/ensuite1_toilet_b.mdl",
			"models/env/furniture/ensuite1_sink/ensuite1_sink.mdl",
			"models/props_interiors/soap_dispenser.mdl",
			"models/props_interiors/toiletpaperdispenser_residential.mdl",
			"models/props_interiors/toiletpaperroll.mdl",
			"models/env/furniture/ensuite1_bath/ensuite1_bath.mdl",
			"models/props_interiors/urinal01.mdl",
			},
		["–°–ø–∞–ª—å–Ω—è"] = {
			"models/props_interiors/bed_motel.mdl",
			"models/props_downtown/bed_motel01.mdl",
			"models/env/furniture/bed_secondclass/beddouble_group.mdl",
			"models/env/furniture/bed_andrea/bed_andrea_1st.mdl",
			"models/props_interiors/side_table_square.mdl",
			"models/env/furniture/bed_naronic/bed_naronic_1st.mdl",
		},
		["–û—Ñ–∏—Å"] = {
			"models/U4Lab/chair_office_a.mdl",
			"models/U4Lab/desk_office_a.mdl",
			"models/props_warehouse/office_furniture_coffee_table.mdl",
			"models/props_warehouse/office_furniture_desk.mdl",
			"models/props_warehouse/office_furniture_desk_corner.mdl",
			"models/props_office/desk_01.mdl",
			"models/props_interiors/desk_executive.mdl",
			"models/env/furniture/largedesk/largedesk.mdl",
			"models/props_office/file_cabinet_03.mdl",
			"models/Highrise/cubicle_monitor_01.mdl",
			"models/props_interiors/copymachine01.mdl",
			"models/props_interiors/printer.mdl",
			"models/props_interiors/paper_tray.mdl",
			"models/props_interiors/water_cooler.mdl",
			"models/props_interiors/corkboardverticle01.mdl",
			"models/props_interiors/magazine_rack.mdl",	
			"models/props/cs_office/chair_office.mdl",
			"models/props/cs_office/computer.mdl",
			"models/props_interiors/chair_office2.mdl",
			"models/props_interiors/chair_thonet.mdl",
			"models/props_interiors/closet_clothes.mdl",
			"models/props/cs_office/trash_can_p.mdl",
			"models/props/cs_office/table_meeting.mdl",
			"models/props/cs_office/file_box.mdl",
			"models/props/cs_office/offcorkboarda.mdl",
			},
		["–£–ª–∏—Ü–∞"] = {
			"models/props_unique/spawn_apartment/coffeeammo.mdl",
			"models/props_downtown/sign_donotenter.mdl",
			"models/props_waterfront/awning01.mdl",
			"models/props_c17/awning001a.mdl",
			"models/props_c17/awning002a.mdl",
			"models/props_street/awning_department_store.mdl",
			"models/props/de_tides/planter.mdl",
			"models/props_urban/bench001.mdl",
			"models/props_interiors/table_picnic.mdl",
			"models/props_urban/plastic_chair001.mdl",
			"models/props_interiors/patio_chair2_white.mdl",
			"models/props/de_tides/patio_chair2.mdl",
			"models/props/de_tides/patio_table2.mdl",
			"models/env/furniture/pool_recliner/pool_recliner.mdl",
			"models/props/de_piranesi/pi_bench.mdl",
			"models/props/de_piranesi/pi_sundial.mdl",
			"models/props/de_inferno/bench_concrete.mdl",
			"models/props/de_inferno/fountain.mdl",
			"models/props/de_inferno/lattice.mdl",
			"models/props_unique/firepit_campground.mdl",
			"models/props_equipment/sleeping_bag1.mdl",
			"models/props_equipment/sleeping_bag2.mdl",
			"models/props_urban/outhouse001.mdl",
			"models/props_junk/trashcluster01a_corner.mdl",
			"models/trees/pi_tree1.mdl",
			"models/trees/pi_tree3.mdl",
			"models/trees/pi_tree4.mdl",
			"models/trees/pi_tree5.mdl",
			"models/gm_forest/tree_alder.mdl",
			"models/props_foliage/r_maple1.mdl",
			"models/props_foliage/maple_001_l.mdl",
			"models/props_foliage/tree_springers_01a.mdl",
			"models/props/cs_militia/tree_large_militia.mdl",
			"models/sickness/parkinglotlight.mdl",
			"models/props_junk/dumpster.mdl",
			"models/props/de_inferno/bench_wood.mdl",
			"models/props_silo/camera.mdl",
			"models/props/cs_italy/it_mkt_table3.mdl",
			"models/props/cs_militia/table_shed.mdl",
			"models/props/cs_militia/table_kitchen.mdl",
			"models/props/cs_militia/logpile2.mdl",
			"models/props/cs_militia/bar01.mdl",
			"models/props/cs_militia/barstool01.mdl",
			"models/props/de_piranesi/pi_orrery.mdl",
			"models/props/de_tides/tides_streetlight.mdl",
			"models/natalya/furniture/patio_table.mdl",
			"models/props/de_tides/vending_cart.mdl",
			},
		["–ö–æ–º–º–µ—Ä—á–∏—Å–∫–∏–π"] = {
			"models/props_equipment/phone_booth.mdl",
			"models/Highrise/trashcanashtray_01.mdl",
			"models/Highrise/trash_can_03.mdl",
			"models/props_interiors/trashcan01.mdl",
			"models/props_interiors/cashregister01.mdl",
			"models/props_interiors/magazine_rack.mdl",
			"models/props_interiors/shelvinggrocery01.mdl",
			"models/props_interiors/shelvingstore01.mdl",
			"models/props_equipment/fountain_drinks.mdl",
			"models/props_downtown/bar_long.mdl",
			"models/props_downtown/bar_long_endcorner.mdl",
			"models/scenery/structural/vesuvius/bartap.mdl",
			"models/env/furniture/bstoolred/bstoolred.mdl",
			"models/props_furniture/cafe_barstool1.mdl",
			"models/props_downtown/pooltable.mdl",
			"models/de_vegas/card_table.mdl",
			"models/props_equipment/security_desk1.mdl",
			"models/sickness/bk_booth2.mdl",
			"models/props_downtown/booth01.mdl",
			"models/props_downtown/booth02.mdl",
			"models/props_downtown/booth_table.mdl",
			"models/props_interiors/table_cafeteria.mdl",
			"models/props_warehouse/table_01.mdl",
			"models/props_interiors/chairs_airport.mdl",
			"models/props_warehouse/toolbox.mdl",
			"models/props_vtmb/turntable.mdl",
			"models/props_unique/wheelchair01.mdl",
			"models/props_unique/hospital/exam_table.mdl",
			"models/props_unique/hospital/gurney.mdl",
			"models/props_equipment/surgicaltray_01.mdl",
			"models/props_unique/hospital/hospital_bed.mdl",
			"models/props_unique/hospital/iv_pole.mdl",
			"models/props_unique/hospital/surgery_lamp.mdl",
			"models/props_interiors/medicalcabinet02.mdl",
			"models/props/slow/glass_table_high/slow_glass_table_high.mdl",
			"models/props/slow/hocker/slow_hocker.mdl",
			"models/pg_props/pg_hospital/pg_optable.mdl",
			"models/props_equipment/snack_machine.mdl",
			"models/env/decor/gents_display/gents_display.mdl",
			"models/env/decor/vous_display/vous_display.mdl",
			"models/maxib123/pooltable.mdl",
			"models/props_interiors/phone.mdl",
			"models/props_unique/coffeemachine01.mdl",
			"models/props/cs_office/tv_plasma.mdl",
			"models/props/cs_office/bookshelf1.mdl",
			"models/props/de_tides/menu_stand.mdl",
		},
		["–ò–Ω–¥—É—Å—Ç—Ä–∏–∞–ª—å–Ω—ã–π"] = {
			"models/props_industrial/warehouse_shelf001.mdl",
			"models/props_industrial/warehouse_shelf002.mdl",
			"models/props_industrial/warehouse_shelf003.mdl",
			"models/props_industrial/warehouse_shelf004.mdl",
			"models/props/cs_assault/moneypallete.mdl",
			"models/props/cs_assault/moneypallet03.mdl",
			"models/props/cs_assault/handtruck.mdl",
			"models/props/cs_assault/forklift.mdl",
			"models/props/cs_office/paperbox_pile_01.mdl",
			"models/props/cs_office/cardboard_box03.mdl",
			"models/props/de_dust/stoneblock01a.mdl",
		},
		["–°–≤–µ—Ç"] = {
			"models/props_unique/spawn_apartment/lantern.mdl",	
			"models/env/lighting/lamp_trumpet/lamp_trumpet_tall.mdl",
			"models/env/lighting/jelly_lamp/jellylamp.mdl",
			"models/env/lighting/corridor_ceil_lamp/corridor_ceil_lamp.mdl",
			"models/env/lighting/corridorlamp/corridorlamp.mdl",
			"models/props_urban/light_fixture01.mdl",
			"models/Highrise/tall_lamp_01.mdl",
			"models/U4Lab/track_lighting_a.mdl",
			"models/Highrise/sconce_01.mdl",
			"models/wilderness/lamp6.mdl",
			"models/props_interiors/lamp_table02.mdl",	
			"models/env/lighting/dance_spots/dance_spots.mdl",
			"models/props/cs_assault/light_shop2.mdl",
		},
		["–ö–∞—Ä—Ç–∏–Ω—ã"] = {
			"models/props/cs_office/offinspa.mdl",
			"models/props/cs_office/offinspb.mdl",
			"models/props/cs_office/offinspc.mdl",
			"models/props/cs_office/offinspd.mdl",
			"models/props/cs_office/offinspf.mdl",
			"models/props/cs_office/offinspg.mdl",
			"models/props/cs_office/offpaintinga.mdl",
			"models/props/cs_office/offpaintingb.mdl",
			"models/props/cs_office/offpaintingd.mdl",
			"models/props/cs_office/offpaintinge.mdl",
			"models/props/cs_office/offpaintingf.mdl",
			"models/props/cs_office/offpaintingg.mdl",
			"models/props/cs_office/offpaintingh.mdl",
			"models/props/cs_office/offpaintingi.mdl",
			"models/props/cs_office/offpaintingj.mdl",
			"models/props/cs_office/offpaintingk.mdl",
			"models/props/cs_office/offpaintingl.mdl",
			"models/props/cs_office/offpaintingm.mdl",
			"models/props/cs_office/offpaintingo.mdl",
		},
	}


	hook.Add("PopulateContent", "RoleplayPropsExtended", function(pnlContent, tree)
	
		local cvar = GetConVar("rppropsex_hide")
		if cvar and (cvar:GetInt() == 1) then return end -- The server doesn't want it in the client spawn menu

		local RootNode = tree:AddNode("Roleplay Props Extended", "icon16/rpprops.png")

		local ViewPanel = vgui.Create("ContentContainer", pnlContent)
		ViewPanel:SetVisible(false)
		
		RootNode.DoClick = function()
		
			ViewPanel:Clear(true)
			
			for name, tbl in SortedPairs(models) do
			
				local label = vgui.Create("ContentHeader", container)
				label:SetText(name)

				ViewPanel:Add(label)
			
				for _, v in ipairs(tbl) do
				
					local mdlicon = spawnmenu.GetContentType("model")
					if mdlicon then
						mdlicon(ViewPanel, {model = v})
					end

				end
				
			end
			
			pnlContent:SwitchPanel(ViewPanel)
			
		end

	end)
	
end

--PATH lua/autorun/rscpck_pcf_precache.lua:
-- Dark Souls --
game.AddParticles("particles/Dark_Souls/ds3_sister_friede.pcf")
game.AddParticles("particles/Dark_Souls/ds_artorias_fx.pcf")
game.AddParticles("particles/Dark_Souls/ds_ornstein_fx.pcf")
game.AddParticles("particles/Dark_Souls/ds3_fx.pcf")
game.AddParticles("particles/Dark_Souls/abyss_watcher.pcf")
game.AddParticles("particles/Dark_Souls/cinder_fx_ds3.pcf")
game.AddParticles("particles/Dark_Souls/danksouls.pcf")
game.AddParticles("particles/Dark_Souls/ds3_bosssteps.pcf")
game.AddParticles("particles/Dark_Souls/gael.pcf")
game.AddParticles("particles/Dark_Souls/gael_smoke.pcf")
game.AddParticles("particles/Dark_Souls/gael_dirt2.pcf")
game.AddParticles("particles/Dark_Souls/nking_1.pcf")
game.AddParticles("particles/Dark_Souls/nking_2.pcf")
game.AddParticles("particles/Dark_Souls/nking_3.pcf")

-- Day of Infamy --
game.AddParticles("particles/Day_Of_Infamy/doi_destructible_fx.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_b.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_c.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_grenade.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_new.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosions_smoke.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_impact_fx.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_weapon_fx.pcf")

-- Insurgency --
game.AddParticles("particles/Insurgency/ammo_cache_ins.pcf")
game.AddParticles("particles/Insurgency/blood_fx.pcf")
game.AddParticles("particles/Insurgency/footstep_fx.pcf")
game.AddParticles("particles/Insurgency/ins_burning_fx.pcf")
game.AddParticles("particles/Insurgency/ins_rockettrail.pcf")
game.AddParticles("particles/Insurgency/ins_smokegrenade.pcf")
game.AddParticles("particles/Insurgency/weapon_fx_ins.pcf")
game.AddParticles("particles/Insurgency/weapon_fx_ins_b.pcf")
game.AddParticles("particles/Insurgency/world_fx_ins.pcf")

-- CoD --
game.AddParticles("particles/CoD/blackops3zombies_fx.pcf")
game.AddParticles("particles/CoD/hound.pcf")

-- Half-Life Alyx --
game.AddParticles("particles/Half-Life_Alyx/hla_antlion_blue_fx.pcf")
game.AddParticles("particles/Half-Life_Alyx/hla_antlion_orange_fx.pcf")
game.AddParticles("particles/Half-Life_Alyx/AntlionFX.pcf")

-- Horror --
game.AddParticles("particles/Horror/bloodsplosion.pcf")

-- Doom 3 --
game.AddParticles("particles/DOOM/doom_fx.pcf")

-- Armor --
game.AddParticles( "particles/npcarmor.pcf" )
PrecacheParticleSystem( "npcarmor_break" )
PrecacheParticleSystem( "npcarmor_hit" )
PrecacheParticleSystem( "eml_generic_shock" )

-- Starship Troopers --
game.AddParticles("particles/Starship_Troopers/arach_drool.pcf")
game.AddParticles("particles/Starship_Troopers/sst_acidbug_fx.pcf")

-- Fallout --
game.AddParticles("particles/Fallout/centaur_spit.pcf")
game.AddParticles("particles/Fallout/glowingone.pcf")
game.AddParticles("particles/Fallout/goregrenade.pcf")
game.AddParticles("particles/Fallout/magmalurk_flame.pcf")
game.AddParticles("particles/Fallout/fo3_radiation_shockwave.pcf")
game.AddParticles("particles/Fallout/spore1.pcf")
game.AddParticles("particles/Fallout/sporecarrier_glow.pcf")
game.AddParticles("particles/Fallout/sporecarrier_radiation.pcf")
game.AddParticles("particles/Fallout/fo3_fx.pcf")

-- Halo --
game.AddParticles("particles/Halo/main_effects.pcf")
game.AddParticles("particles/Halo/halo_beam.pcf")
game.AddParticles("particles/FlexParticles.pcf")

-- Monster Hunter --
game.AddParticles("particles/mh_scream.pcf")

-- Mass Effect --
game.AddParticles("particles/Mass_Effect/thresher_fx.pcf")
local particlename = {
------------------------------------------------------------------------------------------------------------------------------------
--// Dark Souls Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Friede Particle Effects --
-- phase 2 --
"ds3_friede_bf_flameblast",			-- Single
"ds3_friede_bf_scythe",				-- Continuous
"ds3_friede_bf_super",				-- Single

-- phase 1 --
"ds3_friede_icecast",				-- Single
"ds3_friede_icecastlarge",			-- Single
"ds3_friede_icewave_base",			-- Single
"ds3_friede_icecrystal_spawn",		-- Single
"ds3_friede_icewave_flareup",		-- Single
"ds3_friede_jump",
"ds3_friede_leftdodge",
"ds3_friede_rightdodge",
"ds3_friede_leftcloak",
"ds3_friede_rightcloak",
"ds3_friede_scythe_charge",			-- Continuous
"ds3_friede_scythe_charged",		-- Single
"ds3_friede_scythe_hit",			-- Single
"ds3_friede_scythe_metalhit",		-- Single
"ds3_friede_scythe_idle",			-- Continuous
"ds3_friede_scythe_scrape",			-- Continuous
"ds3_friede_scythe_slam",			-- Single
"ds3_friede_scythe_swing",			-- Continuous
"ds3_friede_sprint",
---------------------------------
-- Shared Particle Effects --
"dskart_death",
"ds3_basil_breath",
"ds3_basil_hit",
"ds3_dw_mist",
"ds3_dw_mist_a",
"ds3_boss_dissolve",
"ds3_boss_dissolve_cheap",
"ds3_gundyr_eyes",
"ds3_eyes_red",
"ds3_eyes_blue",
"ds3_eyes_gold",
"dsorn_electric",
"ornstein_hit",
"ornstein_tracer",
"ds3_bloodsword_swing_left",
"ds3_bloodsword_swing_right",
"ds3_bloodsword_left_em",
"ds3_bloodsword_right_em",
"ds3_bs_left_em_med",
"ds3_bs_right_em_med",
"ds3_bs_left_em_lrg",
"ds3_bs_right_em_lrg",
"ds3_bs_swing_left_med",
"ds3_bs_swing_right_med",
"ds3_bs_swing_left_lrg",
"ds3_bs_swing_right_lrg",
"ds3_maria_fire_impact",
"ds3_maria_impact",
"ds3_maria_blood",
"ds3_flamesword_swing",
"ds3_flamesword_swing_left",
"ds3_flamesword_swing_right",
---------------------------------
-- Footstep Particle Effects --
"ds3_bossfs_land",
"ds3_bossfs_water",
"ds3_bossfs_water_nowarp",
---------------------------------
-- Abyss Watcher Particle Effects --
"ds3_watcher_dirt_circular",
"ds3_watcher_dirt_kickup",
"ds3_watcher_fire_circular",
"ds3_watcher_fire_impact",
"ds3_watcher_fire_pillar",
"ds3_watcher_impact",
"ds3_watcher_sword_flame",
"ds3_watcher_thrust",
---------------------------------
-- Soul of Cinder Particle Effects --
"ds3_cinder_bless",
"ds3_cinder_bless_cast",
"ds3_cinder_buffedaura",
"ds3_cinder_buffedblast",
"ds3_cinder_buffedsword",
"ds3_cinder_death",
"ds3_cinder_heal",
"ds3_cinder_heal_aura",
"ds3_cinder_heal_cast",
"ds3_cinder_innerpower",
"ds3_cinder_magicblast_trail",
"ds3_cinder_magicbolt_hit",
"ds3_cinder_magicbolt_trail",
"ds3_cinder_poisonbreath",
"ds3_poison_mist_cloud",
"ds3_cinder_power_aura",
"ds3_cinder_power_cast",
"ds3_cinder_spear_bigasslightning",
"ds3_cinder_spear_core",
"ds3_cinder_spear_hit",
"ds3_cinder_spear_impact",
"ds3_cinder_spear_lightning",
"ds3_cinder_spear_trail",
"soc_sword_embers",
---------------------------------
-- Gael Particle Effects --
"gael_sword_skulls",
"gael_dirt_kickup",
"gael_dirt_kickup_dir_bck",
"gael_dirt_kickup_dir_fwd",
"gael_dirt_kickup_dir_lft",
"gael_dirt_kickup_dir_rit",
"gael_dirt_land",
"gael_smoke_impact_small",
"gael_smoke_impact_large",
"gael_smoke_impact_continuous",
"gael_sword_impact_att10",
"gael_sword_impact_large",
"gael_sword_impact_small",

------------------------------------------------------------------------------------------------------------------------------------
--// Day Of Infamy Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"doi_artillery_explosion_OLD",
"doi_grenade_explosionOLD",
"doi_WParty_explosion",
"doi_WPgrenade_explosion",
"doi_WProcket_explosion",
"doi_generic_crater_smoke",
"doi_generic_crater_smoke_big",
"doi_compB_explosionOLD",
"doi_frag_explosionOLD",
"doi_mortar_explosionOLD",
"doi_flak88_explosion",
"doi_petrol_explosion",
"doi_petrol_leak",
"doi_ceilingDust_large",
"doi_ceilingDust_small",
"doi_frag_explosion",
"doi_grenade_explosion",
"doi_mortar_explosion",
"doi_splinter_explosion",
"doi_artillery_explosion",
"doi_compB_explosion",
"doi_gunrun_impact",
"doi_stuka_explosion",
"doi_smoke_artillery",
"doi_muzzleflash_bar_3p",
"doi_muzzleflash_garand_3p",
"doi_muzzleflash_ithica_3p",
"doi_muzzleflash_k98_3p",
"doi_muzzleflash_mg42_3p",
"doi_muzzleflash_mp40_3p",
"doi_muzzleflash_smoke_large_linger",
"doi_muzzleflash_smoke_medium_linger",
"doi_muzzleflash_smoke_medium_variant_1",
"doi_muzzleflash_smoke_small_variant_1",
"doi_muzzleflash_smoke_small_variant_2",
"doi_muzzleflash_smoke_small_variant_3",
"doi_muzzleflash_smoke_small_variant_4",
"doi_muzzleflash_smoke_small_variant_5",
"doi_muzzleflash_smoke_tiny",
"doi_muzzleflash_sten_3p",
"doi_muzzleflash_stg44_3p",
"doi_muzzleflash_thompson_3p",
"doi_weapon_compB_fuse",
"doi_weapon_muzzle_smoke",

------------------------------------------------------------------------------------------------------------------------------------
--// Insurgency Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"ins_blood_dismember_limb",
"ins_blood_impact_generic",
"ins_blood_impact_headshot",
"ins_blood_incapacitated",
"ins_footstep_dirt",
"ins_footstep_grass",
"ins_footstep_mud",
"ins_footstep_puddle",
"ins_footstep_wet",
"ins_slide_dirt",
"ins_burning_character_large",
"ins_burning_character",
"ins_rockettrail",
"ins_m203_smokegrenade",
"ins_smokegrenade",
"ins_weapon_at4_frontblast",
"ins_weapon_rpg_backblast",
"ins_weapon_rpg_frontblast",
"ins_molotov_rag",
"ins_molotov_lighter",
"ins_molotov_trail",
"ins_muzzleflash_akm_3rd",
"ins_muzzleflash_fal_3rd",
"ins_muzzleflash_m14_3rd",
"ins_muzzleflash_m16_3rd",
"ins_muzzleflash_m249_3rd",
"ins_muzzleflash_m590_3rd",
"ins_muzzleflash_m9_3rd",
"ins_muzzleflash_makarov_3rd",
"ins_muzzleflash_mp40_3rd",
"ins_muzzleflash_mp5_3rd",
"ins_muzzleflash_sks_3rd",
"ins_muzzleflash_toz_3rd",
"ins_muzzleflash_ump_3rd",
"ins_muzzleflash_ak74_3rd",
"ins_flame_jet",
"ins_sprinkler",
"ins_steam_spray",
"ins_water_spray",
"ins_water_spray_impact",
"ins_water_spray_big",
"ins_water_spray_big_impact",
"ins_whirlwind",

------------------------------------------------------------------------------------------------------------------------------------
--// Black Ops 3 Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Cosmonaut FX --
"bo3_astronaut_incoming",
"bo3_astronaut_pulse",
---------------------------------
-- Hellhound FX --
"bo3_hellhound_aura",
---------------------------------
-- RAZ Unit FX --
"bo3_mangler_blast",
"bo3_mangler_charge",
"bo3_mangler_pulse",
---------------------------------
-- Margwa FX --
"bo3_margwa_death",
"bo3_margwa_slam",
---------------------------------
-- Nova 6 Crawler FX --
"bo3_n6crawler_aura",
---------------------------------
-- Napalm Zombie FX --
"bo3_napalm_explosion",
"bo3_napalm_fs",
---------------------------------
-- Panzer FX --
"bo3_panzer_elec_blast",
"bo3_panzer_elec_nade",
"bo3_panzer_engine",
"bo3_panzer_explosion",
"bo3_panzer_flame",
"bo3_panzer_landing",
---------------------------------
-- Shrieker FX --
"bo3_shrieker_scream",
---------------------------------
-- Spider FX --
"bo3_spider_impact",
"bo3_spider_projectile",
"bo3_spider_spit",
---------------------------------
-- Thrasher FX --
"bo3_thrasher_aura",
"bo3_thrasher_blood",
---------------------------------
-- Base Zombie FX --
"bo3_zombie_spawn",
"bo3_zombie_eyeglow_orange",
"bo3_zombie_eyeglow_red",
"bo3_zombie_eyeglow_white",

------------------------------------------------------------------------------------------------------------------------------------
--// Half-Life: Alyx - Antlion Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Antlion FX Orange --
"spit_impact_orange",
"spit_trail_orange",
"splat_orange",
"splat_nophys_orange",
---------------------------------
-- Antlion FX Blue --
"spit_impact_blue",
"spit_trail_blue",
"splat_blue",
"splat_nophys_blue",
---------------------------------
-- Antlion FX --
"AntlionFX_UnBurrow",
"AntlionFX_Burrow",
"AntlionFX_UndGroundMov",

------------------------------------------------------------------------------------------------------------------------------------
--// Horror Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Horror Death FX --
"horror_bloodgibs",
"horror_bloodsplosion",

------------------------------------------------------------------------------------------------------------------------------------
--// Doom 3 Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Shared --
"doom_dissolve",
"doom_dissolve_flameburst",
"doom_hellunit_aura",
"doom_hellunit_spawn_large",
"doom_hellunit_spawn_medium",
"doom_hellunit_spawn_small",
---------------------------------
-- BFG --
"doom_bfg_explosion",
"doom_bfg_explosion_hq",
"doom_bfg_projectile",
"doom_bfg_projectile_hq",
---------------------------------
-- Arch Vile --
"doom_avile_hand",
"doom_avile_blast",
"doom_avile_wave",
"doom_avile_spitfire",
---------------------------------
-- Caco Demon --
"doom_caco_blast",
"doom_caco_blaze",
"doom_caco_nade",
---------------------------------
-- Cyber Demon --
"doom_cyberdemon_breath",
"doom_cyberdemon_jet",
---------------------------------
-- Hellknight --
"doom_hknight_blast",
"doom_hknight_pball",
---------------------------------
-- Imp --
"doom_imp_fireball",
"doom_imp_fireball_cheap",
"doom_imp_fireblast",
---------------------------------
-- Lost Soul --
"doom_lostsoul",
"doom_lostsoul_death",
---------------------------------
-- Mancubus --
"doom_mancu_blast",
"doom_mancu_muzzle",
"doom_mancu_nade",
---------------------------------
-- Revenant --
"doom_rev_missile_blast",
"doom_rev_missile_trail",
"doom_rev_muzzle",
---------------------------------
-- Wraith --
"doom_wraith_postdeath_mist",
"doom_wraith_teleport",

------------------------------------------------------------------------------------------------------------------------------------
--// Arachnid Remade Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Shared FX --
"arach_drool_lower",
"arach_drool_upper",
---------------------------------
-- Acid FX --
"acidbug_spit_impact",
"acidbug_spit_impact_lowperf",
"acidbug_spit_trail",
"acidbug_splat",
"acidbug_splat_nophys",

------------------------------------------------------------------------------------------------------------------------------------
--// Fallout Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Centaur --
"centaur_spit",
---------------------------------
-- Feral Ghoul --
"glowingone_testA",
"glowingone_testB",
"glowingone_testC",
"goregrenade_splash",
"radiation_shockwave",
"radiation_shockwave_debris",
"radiation_shockwave_ring",
"radswave",
---------------------------------
-- Mirelurk --
"magmalurk_flame",
"magmalurk_flame_pilot",
"fo3_mirelurk_charge",
"fo3_mirelurk_pulse",
"fo3_mirelurk_hybrid",
---------------------------------
-- Spore Carrier --
"spore_splash",
"spore_splash_02",
"spore_splash_03",
"spore_splash_05",
"spore_splash_player",
"spore_splash_player_splat",
"spore_trail",
"sporecarrier_glow",
"sporecarrier_radiation",
"sporecarrier_radiation_debris",
"sporecarrier_radiation_ring",
------------------------------------------------------------------------------------------------------------------------------------
--// Thresher Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"tm_ground",
"tm_ground_inf",

------------------------------------------------------------------------------------------------------------------------------------
--// Halo Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Shield FX --
"hcea_shield_impact",
"hcea_shield_recharged",
"hcea_shield_enabled",
"hcea_shield_disperse",
---------------------------------
-- Hunter AB FX --
"hcea_hunter_ab_charge",
"hcea_hunter_ab_explode",
"hcea_hunter_ab_muzzle",
"hcea_hunter_ab_proj",
---------------------------------
-- Hunter FRG FX --
"hcea_hunter_frg_charge",
"hcea_hunter_frg_explode",
"hcea_hunter_frg_muzzle",
"hcea_hunter_frg_proj",
"hcea_hunter_frg_proj_lightning_trcr_e",
---------------------------------
-- Hunter Shade Cannon FX --
"hcea_hunter_shade_cannon_trigger_muzzle",
"hcea_hunter_shade_cannon_proj",
"hcea_hunter_shade_cannon_explode_ground",
"hcea_hunter_shade_cannon_explode_air",
---------------------------------
-- Hunter Canister FX --
"hcea_hunter_canister_green",
"hcea_hunter_canister_purple",
"hcea_hunter_canister_orange",
---------------------------------
-- Flood FX --
"hcea_flood_carrier_death",
"hcea_flood_infected_death",
"hcea_flood_runner_death",
---------------------------------
-- Hunter FX --
"hcea_hunter_particle_carbine",
"hcea_hunter_particle_carbine_impact",
"hcea_hunter_needler_muzzle",
"hcea_hunter_needler_proj",
"hcea_hunter_needler_pistol_impact",
"hcea_hunter_plasma_rifle_fire",
"hcea_hunter_plasma_rifle_proj",
"hcea_hunter_plasma_rifle_impact",
"hcea_hunter_plasma_pistol_fire",
"hcea_hunter_plasma_pistol_proj",
"hcea_hunter_plasma_pistol_impact",
---------------------------------
-- Beam FX --
"halo_beam_main",
"halo_beam_trail_1",
"halo_beam_trail_2",
"halo_beam_trail_3",
"halo_beam_trail_glow_1",
"halo_beam_trail_glow_2",
"halo_beam_trail_glow_3",
---------------------------------
-- Flood FX --
"hcea_flood_car_death",
"hcea_flood_car_death_core",
"hcea_flood_car_death_dirt",
"hcea_flood_car_death_frag",
"hcea_flood_car_death_frag_2",
"hcea_flood_car_death_gibs",
"hcea_flood_car_death_smoke",
"hcea_flood_car_death_smoke_2",
"hcea_flood_car_death_splat",
"hcea_flood_car_death_splat_2",
"hcea_flood_car_death_splatter",
"hcea_flood_car_death_swave_xy",
"hcea_flood_car_death_swave_xz",
"hcea_flood_inf_death",
"hcea_flood_inf_death_core",
"hcea_flood_inf_death_gibs",
"hcea_flood_inf_death_largesplat",
---------------------------------
-- Hunter Shared FX --
"hcea_gold_hunter_charge",
"hcea_red_hunter_charge",
"hcea_purple_hunter_charge",
"hcea_hunter_charge",
"hcea_hunter_frnade_hit",
"hcea_hunter_frnade_nade",
"hcea_red_hunter_nade",
"hcea_hunter_cannister",
"hcea_gold_hunter_cannister",
"hcea_red_hunter_cannister",
"hcea_purple_hunter_cannister",
"hcea_hunter_impact_generic",
"hcea_red_hunter_muzzle",
"hcea_gold_hunter_muzzle",
"hcea_red_hunter_hit",
"hcea_gold_hunter_hit",
---------------------------------
-- Plasma Pistol FX --
"hcea_t25p_charge",
"hcea_t25p_charge_core",
"hcea_t25p_charge_glow",
"hcea_t25p_hit",
"hcea_t25p_hit_blitz",
"hcea_t25p_hit_collide",
"hcea_t25p_hit_flicker",
"hcea_t25p_hit_glow",
"hcea_t25p_muzzle",
"hcea_t25p_muzzle_charged",
"hcea_t25p_muzzle_charged_core",
"hcea_t25p_muzzle_core",
"hcea_t25p_muzzle_core_2",
"hcea_t25p_muzzle_embers",
"hcea_t25p_muzzle_flames",
"hcea_t25p_muzzle_glow",
"hcea_t25p_muzzle_heat",
"hcea_t25p_muzzle_lghtning",
"hcea_t25p_tracer",
"hcea_t25p_tracer_charged",
"hcea_t25p_tracer_charged_fadeglow",
"hcea_t25p_tracer_charged_sparks",
"hcea_t25p_tracer_fadeglow",
"hcea_t25p_tracer_line",
---------------------------------
-- Plasma Rifle FX --
"hcea_t25r_core",
"hcea_t25r_core_2",
"hcea_t25r_embers",
"hcea_t25r_flames",
"hcea_t25r_flames_0a",
"hcea_t25r_flames_2",
"hcea_t25r_glow",
"hcea_t25r_lghtning",
"hcea_t25r_muzzle",
"hcea_t25r_tracer",
"hcea_t25r_tracer_fadeglow",
"hcea_t25r_tracer_halo_nopunintended",
"hcea_t25r_tracer_line",
------------------------------------------------------------------------------------------------------------------------------------
--// Monster Hunter Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Roar --
"mh_monster_scream_large",
}
for _,v in ipairs(particlename) do PrecacheParticleSystem(v) end
--PATH lua/effect/trail.bone_set.lua:
WeaponTrail.BoneSet = {}

function WeaponTrail:AddBone(data)
	WeaponTrail.BoneSet[data.Number] = data
end

local bone = {
	Number = 0,
	BoneName = "ValveBiped.Bip01_R_Hand",
	AddAngle = Angle(0,0,0),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.1 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 1,
	BoneName = "R_Weapon",
	AddAngle = Angle(0,0,0),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 2,
	BoneName = "R_Weapon001",
	AddAngle = Angle(0,0,0),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.5 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 3,
	BoneName = "R_Weapon",
	AddAngle = Angle(0,0,0),
	AngleType = 1, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 4,
	BoneName = "L_Weapon001",
	AddAngle = Angle(0,0,180),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.5 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 5,
	BoneName = "R_Weapon",
	AddAngle = Angle(180,0,0),
	AngleType = 2, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 6,
	BoneName = "R_Weapon",
	AddAngle = Angle(0,0,180),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 7,
	BoneName = "Weapon_00",
	AddAngle = Angle(180,0,0),
	AngleType = 2, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 8,
	BoneName = "Weapon_02",
	AddAngle = Angle(180,0,0),
	AngleType = 2, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.1 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)

--PATH addons/sam-157/lua/sam/command/arguments/map.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("map")
	:OnExecute(function(argument, input, ply, _, result)
		local map_name = sam.is_valid_map(input)
		if not map_name and not (argument.optional and input == "None") then
			ply:sam_send_message("invalid", {
				S = "map", S_2 = input
			})
			return false
		end

		table.insert(result, map_name)
	end)

	:Menu(function(set_result, _, buttons, argument)
		local maps = buttons:Add("SAM.ComboBox")
		maps:SetTall(25)

		if argument.optional then
			maps:AddChoice("None", nil, true)
		end

		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if not (argument.exclude_current and map_name == game.GetMap()) then
				maps:AddChoice(map_name)
			end
		end

		function maps:OnSelect(_, value)
			set_result(value)
		end

		local value = argument.optional and "None" or maps:GetOptionText(1)
		maps:SetValue(value)
		maps:OnSelect(nil, value)

		return maps
	end)

	:AutoComplete(function(_, result, name)
		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if map_name:lower():find(name, 1, true) then
				table.insert(result, map_name)
			end
		end
	end)
:End()

--PATH addons/sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--PATH addons/sam-157/lua/sam/menu/tabs/bans.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_bans", nil, "superadmin")

local get_pages_count = function(bans_count)
	bans_count = bans_count / 35
	local i2 = math.floor(bans_count)
	return bans_count ~= i2 and i2 + 1 or bans_count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_bans") and ply:sam_check_cooldown("MenuManageBans", 0.1)
	end

	local limit = 35

	local get_page_count = function(res, callback, page, order_by, keyword)
		local current_time = os.time()
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_bans`
			WHERE
				(`unban_date` >= %d OR `unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		SQL.Query(query, callback, true, {res, page, order_by, keyword, current_time})
	end

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_bans = function(count_data, arguments)
		local res, page, order_by, keyword, current_time = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`sam_bans`.*,
				IFNULL(`p1`.`name`, '') AS `name`,
				IFNULL(`p2`.`name`, '') AS `admin_name`
			FROM
				`sam_bans`
			LEFT OUTER JOIN
				`sam_players` AS `p1`
			ON
				`sam_bans`.`steamid` = `p1`.`steamid`
			LEFT OUTER JOIN
				`sam_players` AS `p2`
			ON
				`sam_bans`.`admin` = `p2`.`steamid`
			WHERE
				(`sam_bans`.`unban_date` >= %d OR `sam_bans`.`unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `sam_bans`.`steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		local offset = math.abs(limit * (page - 1))
		query = query .. ([[
			ORDER BY
				`sam_bans`.`id` %s
			LIMIT
				%d OFFSET %d]]):format(order_by, limit, offset)

		SQL.Query(query, resolve_promise, nil, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetBans", function(res, ply, page, order_by, keyword)
		if not isnumber(page) then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(res, get_bans, page, order_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/ban-user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_order, keyword = nil, "DESC", nil

	local bans_body = column_sheet:Add("Panel")
	bans_body:Dock(FILL)
	bans_body:DockMargin(0, 1, 0, 0)
	bans_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(bans_body)

	local title = bans_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Bans")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = bans_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total bans")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	do
		local container = bans_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter()
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				refresh()
			end
		end
	end

	Line(bans_body, nil, -5, 15, -5, 0)

	do
		local columns = bans_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local time_left = columns:Add("SAM.Label")
		time_left:Dock(LEFT)
		time_left:DockMargin(-4, 0, 0, 0)
		time_left:SetFont(COLUMN_FONT)
		time_left:SetText("Time Left")
		time_left:SetTextColor(GetColor("player_list_titles"))
		time_left:SetWide(SUI.Scale(180))
		time_left:SizeToContentsY(3)

		local reason = columns:Add("SAM.Label")
		reason:Dock(LEFT)
		reason:DockMargin(-4, 0, 0, 0)
		reason:SetFont(COLUMN_FONT)
		reason:SetText("Reason")
		reason:SetTextColor(GetColor("player_list_titles"))
		reason:SetWide(SUI.Scale(280))
		reason:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = bans_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local bans, bans_count, current_page_2 = unpack(data)
		total:SetText(bans_count .. " total bans")

		pages = get_pages_count(bans_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(bans) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			local admin_name = v.admin_name ~= "" and v.admin_name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = admin_name or (v.admin == "Console" and "Console"),
				rank_bg = not admin_name and GetColor("player_list_console")
			})

			local unban_date = tonumber(v.unban_date)
			local time_left = line:Add("SAM.Label")
			time_left:Dock(LEFT)
			time_left:DockMargin(-3, 0, 0, 0)
			time_left:SetFont(LINE_FONT)
			time_left:SetText(unban_date == 0 and "Never" or sam.reverse_parse_length((unban_date - os.time()) / 60))
			time_left:SetTextColor(GetColor("player_list_data"))
			time_left:SetContentAlignment(4)
			time_left:SetWide(SUI.Scale(180))

			local reason = line:Add("SAM.Label")
			reason:Dock(LEFT)
			reason:DockMargin(4, 0, 0, 0)
			reason:SetFont(LINE_FONT)
			reason:SetText(v.reason)
			reason:SetTextColor(GetColor("player_list_data"))
			reason:SetContentAlignment(4)
			reason:SetWrap(true)
			reason:SetWide(SUI.Scale(200))

			local old_tall = line.size
			function reason:PerformLayout()
				local _, h = self:GetTextSize()
				if old_tall < h then
					line:SetTall(h)
				end
			end

			local but = line:Actions()
			but:On("DoClick", function()
				local dmenu = vgui.Create("SAM.Menu")
				dmenu:SetInternal(but)
				if name then
					dmenu:AddOption("Copy Name", function()
						SetClipboardText(name)
					end)
				end
				dmenu:AddOption("Copy SteamID", function()
					SetClipboardText(v.steamid)
				end)
				dmenu:AddOption("Copy Reason", function()
					SetClipboardText(v.reason)
				end)
				dmenu:AddOption("Copy Time Left", function()
					SetClipboardText(time_left:GetText())
				end)

				if v.admin ~= "Console" then
					dmenu:AddSpacer()

					if admin_name then
						dmenu:AddOption("Copy Admin Name", function()
							SetClipboardText(admin_name)
						end)
					end

					dmenu:AddOption("Copy Admin SteamID", function()
						SetClipboardText(v.admin)
					end)
				end

				if LocalPlayer():HasPermission("unban") then
					dmenu:AddSpacer()
					dmenu:AddOption("Unban", function()
						local user = name and ("%s (%s)"):format(name, v.steamid) or v.steamid
						local querybox = vgui.Create("SAM.QueryBox")
						querybox:SetWide(350)
						querybox:SetTitle(user)

						local check = querybox:Add("SAM.Label")
						check:SetText(sui.wrap_text("Are you sure that you want to unban\n" .. user, LINE_FONT, SUI.Scale(350)))
						check:SetFont(LINE_FONT)
						check:SizeToContents()

						querybox:Done()
						querybox.save:SetEnabled(true)
						querybox.save:SetText("UNBAN")

						querybox.save:SetContained(false)
						querybox.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

						querybox.cancel:SetContained(true)
						querybox.cancel:SetColors()

						querybox:SetCallback(function()
							RunConsoleCommand("sam", "unban", v.steamid)
						end)
					end)
				end
				dmenu:Open()
			end)

			body:Line()
		end

		body:InvalidateLayout(true)
		body:GetCanvas():InvalidateLayout(true)
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_bans") then
			local refresh_query = netstream.async.Start("SAM.GetBans", toggle_loading, current_page.i, current_order, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = bans_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	for k, v in ipairs({"SAM.BannedPlayer", "SAM.BannedSteamID", "SAM.EditedBan", "SAM.UnbannedSteamID"}) do
		hook.Add(v, "SAM.MenuBans", function()
			if IsValid(body) then
				refresh()
			end
		end)
	end

	refresh()

	return bans_body
end, function()
	return LocalPlayer():HasPermission("manage_bans")
end, 4)
--PATH addons/sam-157/lua/sam/sh_motd.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config
local command = sam.command

if CLIENT then
	config.add_menu_setting("MOTD URL (Leave empty for no MOTD)", function()
		local entry = vgui.Create("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetNoBar(true)
		entry:SetConfig("MOTDURL", "")

		return entry
	end)
end

local motd
local load_motd = function()
	local url = config.get("MOTDURL", "")
	if url == "" then
		command.remove_command("motd")
		hook.Remove("HUDPaint", "SAM.OpenMOTD")
		return
	end

	if IsValid(motd) then
		motd:Remove()
	end

	command.set_category("Menus")

	command.new("motd")
		:Help("Open MOTD menu")
		:OnExecute(function(ply)
			sam.netstream.Start(ply, "OpenMOTD")
		end)
	:End()

	if CLIENT then
		function sam.menu.open_motd()
			if IsValid(motd) then
				motd:Remove()
			end

			motd = vgui.Create("SAM.Frame")
			motd:Dock(FILL)
			motd:DockMargin(40, 40, 40, 40)
			motd:MakePopup()

			function motd.close.DoClick()
				motd:Remove()
			end

			local html = motd:Add("DHTML")
			html:Dock(FILL)
			html:OpenURL(url)
		end

		sam.netstream.Hook("OpenMOTD", function()
			sam.menu.open_motd()
		end)

		hook.Add("HUDPaint", "SAM.OpenMOTD", function()
			sam.menu.open_motd()
			hook.Remove("HUDPaint", "SAM.OpenMOTD")
		end)
	end
end
config.hook({"MOTDURL"}, load_motd)
--PATH addons/sam-157/lua/sam/modules/cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ‚ö† **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ‚ö† **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ‚Ñπ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ‚ö† **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ‚ö† **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ‚ö† **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ‚Ñπ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ‚Ñπ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH addons/sam-157/lua/sam/reports/cl_reports.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream
local SUI = sam.SUI

local config = sam.config

local Trim = string.Trim

local muted_var = CreateClientConVar("sam_mute_reports", "0", false, false, "", 0, 1)

local position = config.get_updated("Reports.Position", "Left")
local max_reports = config.get_updated("Reports.MaxReports", 4)
local always_show = config.get_updated("Reports.AlwaysShow", true)
local pad_x = config.get_updated("Reports.XPadding", 5)
local pad_y = config.get_updated("Reports.YPadding", 5)

local duty_jobs = {}
config.hook({"Reports.DutyJobs"}, function()
	local jobs = config.get("Reports.DutyJobs", ""):Split(",")
	for i = #jobs, 1, -1 do
		local v = Trim(jobs[i])
		if v ~= "" then
			jobs[v] = true
		end
		jobs[i] = nil
	end
	duty_jobs = jobs
end)

local commands = {}
config.hook({"Reports.Commands"}, function()
	local cmds = config.get("Reports.Commands", ""):Split(",")
	for i = 1, #cmds do
		local v = Trim(cmds[i])
		if v ~= "" then
			cmds[i] = {
				name = v,
				func = function(_, ply)
					if IsValid(ply) then
						RunConsoleCommand("sam", v, "#" .. ply:EntIndex())
					end
				end
			}
		end
	end
	commands = cmds
end)

local reports = {}
local queued_reports = {}

local new_report, remove_report, check_queued, get_report, append_report

get_report = function(ply, index)
	for i = 1, #reports do
		local v = reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v end
	end

	for i = 1, #queued_reports do
		local v = queued_reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v, i end
	end
end

remove_report = function(ply)
	local report, delayed_i = get_report(ply)

	if delayed_i then
		return table.remove(queued_reports, delayed_i)
	end

	local panel = report.panel
	panel:MoveToNewX(position.value == "Right" and ScrW() or -panel:GetWide(), function()
		for i = report.pos + 1, #reports do
			local v = reports[i]
			v.pos = v.pos - 1
			v.panel:MoveToNewY(v.panel:GetY())
		end

		panel:Remove()
		table.remove(reports, report.pos)

		check_queued()
	end)
end

check_queued = function()
	while (max_reports.value - #reports > 0 and #queued_reports > 0) do
		new_report(table.remove(queued_reports, 1))
	end
end

append_report = function(ply, text)
	local report, delayed = get_report(ply)
	if delayed then
		table.insert(report.comments, text)
	else
		report.panel:AddComment(text)
	end
end

new_report = function(report)
	if #reports >= max_reports.value then
		return table.insert(queued_reports, report)
	end

	report.pos = table.insert(reports, report)

	local panel = vgui.Create("SAM.Report")
	panel:SetReport(report)

	for k, v in ipairs(commands) do
		panel:AddButton(v.name:gsub("^%l", string.upper), v.func)
	end

	local claim = panel:AddButton("Claim", function(self, ply)
		if panel:HasReport() then
			return LocalPlayer():sam_send_message("You have an active case, close it first.")
		end

		self.DoClick = function()
		end

		local claim_query = netstream.async.Start("ClaimReport", nil, ply)
		claim_query:done(function(claimed)
			if not IsValid(panel) then return end

			if claimed then
				panel:SetHasReport(ply)

				self:SetText("Close")

				self.background = Color(231, 76, 60, 200)
				self.hover = Color(255, 255, 255, 25)

				panel:FixWide()

				for k, v in ipairs(panel:GetChildren()[3]:GetChildren()) do
					v:SetDisabled(false)
					v:SetCursor("hand")
				end

				self.DoClick = function()
					panel:Close()
				end
			else
				panel:SetClaimed()
			end
		end)
	end)

	panel.claim = claim

	claim:SetCursor("hand")
	claim:SetDisabled(false)

	claim.background = Color(39, 174, 96, 200)
	claim.hover = Color(255, 255, 255, 25)

	panel:FixWide()

	local x = pad_x.value
	if position.value == "Right" then
		x = (ScrW() - panel:GetWide()) - x
	end

	panel:MoveToNewX(x)
	panel:MoveToNewY(panel:GetY())

	panel.new = true
	for k, v in ipairs(report.comments) do
		panel:AddComment(v)
	end
	panel.new = nil
end

netstream.Hook("Report", function(ply, comment)
	if not IsValid(ply) then return end

	if muted_var:GetBool() then return end

	local report = get_report(ply)
	if not report then
		report = {
			ply = ply,
			index = ply:EntIndex(),
			comments = {comment}
		}

		if not always_show.value and not duty_jobs[team.GetName(LocalPlayer():Team())] then
			LocalPlayer():sam_send_message("({S Blue}) {S_2 Red}: {S_3}", {
				S = "Report", S_2 = ply:Name(), S_3 = comment
			})
		else
			new_report(report)
		end
	else
		append_report(ply, comment)
	end
end)

netstream.Hook("ReportClaimed", function(ply)
	local report, delayed = get_report(ply)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClaimed()
	end
end)

netstream.Hook("ReportClosed", function(index)
	local report, delayed = get_report(index, true)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClosed()
	end
end)

do
	local REPORTS_HEADER = SUI.CreateFont("ReportHeader", "Roboto", 14, 540)
	local REPORT_COMMENT = SUI.CreateFont("ReportComment", "Roboto", 13, 540)
	local REPORT_BUTTONS = SUI.CreateFont("ReportButtons", "Roboto", 13, 550)

	local Panel = {}

	function Panel:Init()
		sui.TDLib.Start()

		self:Blur()
			:Background(Color(30, 30, 30, 240))

		local p_w, p_h = SUI.Scale(300), SUI.Scale(125)
		self:SetSize(p_w, p_h)

		local x = p_w * 2

		if position.value == "Right" then
			x = ScrW() + x
		else
			x = -x
		end

		self:SetPos(x, -p_h)

		local top_panel = self:Add("Panel")
		top_panel:Dock(TOP)
		top_panel:SetTall(SUI.Scale(24))
		top_panel:Background(Color(60, 60, 60, 200))

		local ply_name = top_panel:Add("DLabel")
		ply_name:Dock(LEFT)
		ply_name:DockMargin(5, 0, 0, 0)
		ply_name:SetTextColor(Color(200, 200, 200))
		ply_name:SetFont(REPORTS_HEADER)
		self.ply_name = ply_name

		local scroll = self:Add("SAM.ScrollPanel")
		scroll:Dock(FILL)
		scroll:DockMargin(5, 5, 5, 5)
		scroll.Paint = nil
		self.scroll = scroll

		local comment = scroll:Add("DLabel")
		comment:Dock(TOP)
		comment:SetText("")
		comment:SetTextColor(Color(200, 200, 200))
		comment:SetFont(REPORT_COMMENT)
		comment:SetMultiline(true)
		comment:SetWrap(true)
		comment:SetAutoStretchVertical(true)
		self.comment = comment

		local bottom = self:Add("Panel")
		bottom:Dock(BOTTOM)
		bottom:SetTall(SUI.Scale(24))
		self.bottom = bottom

		sui.TDLib.End()
	end

	function Panel:GetY()
		return (self:GetTall() + 5) * (self.report.pos - 1) + pad_y.value
	end

	function Panel:Close()
		remove_report(self.report.ply)
	end

	local change_state = function(self, text)
		self.claim:SetText(text)
		self.claim.DoClick = function() end

		self.claim:SUI_TDLib()
			:Background(Color(41, 128, 185, 200))

		timer.Simple(5, function()
			if IsValid(self) then
				self:Close()
			end
		end)

		if self:HasReport() == self.report.ply then
			self:SetHasReport()
		end

		self:FixWide()
	end

	function Panel:SetClaimed()
		change_state(self, "Case clamied!")
	end

	function Panel:SetClosed()
		change_state(self, "Case closed!")
	end

	function Panel:SetReport(report)
		surface.PlaySound("garrysmod/balloon_pop_cute.wav")

		report.panel = self

		self.report = report
		self.ply_name:SetText(report.ply:Name())
		self.ply_name:SetWide(self:GetWide())
	end

	local disabled = Color(60, 60, 60, 200)
	local click = Color(255, 255, 255, 30)
	local button_paint = function(self, w, h)
		draw.RoundedBox(0, 0, 0, w, h, self.background)

		if self:GetDisabled() then
			draw.RoundedBox(0, 0, 0, w, h, disabled)
		else
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0, w, h, self.hover)
			end

			if self.Depressed then
				draw.RoundedBox(0, 0, 0, w, h, click)
			end
		end
	end

	local button_click = function(self)
		self.cb(self, self.report.ply)
	end

	local background = Color(60, 60, 60, 200)
	local hover = Color(14, 134, 204, 100)
	function Panel:AddButton(text, cb)
		local button = self.bottom:Add("DButton")
		button:Dock(LEFT)
		button:SetText(text)
		button:SetTextColor(Color(200, 200, 200))
		button:SetFont(REPORT_BUTTONS)
		button:SetDisabled(true)
		button:SetCursor("arrow")

		button.Paint = button_paint
		button.DoClick = button_click

		button.background = background
		button.hover = hover

		button.cb = cb
		button.report = self.report

		return button
	end

	function Panel:FixWide()
		local wide = 0

		for _, v in ipairs(self.bottom:GetChildren()) do
			v:SizeToContents()
			v:SetWide(v:GetWide() + 6)
			wide = wide + v:GetWide()
		end

		self:SetWide(wide)

		return wide
	end

	function Panel:OnRemove()
		local reporter = self:HasReport()
		if reporter then
			netstream.Start("CloseReport", reporter)
			self:SetHasReport()
		end
	end

	function Panel:AddComment(text)
		local comment = self.comment

		local old_text = comment:GetText()
		if old_text ~= "" then
			old_text = old_text .. "\n"
		end

		if not self.new then
			surface.PlaySound("ambient/water/drip4.wav")
		end

		comment:SetText(old_text .. "- " .. text)
		comment:SizeToContents()

		self.scroll:ScrollToBottom()
	end

	function Panel:HasReport()
		return LocalPlayer().sam_has_report
	end

	function Panel:SetHasReport(v)
		LocalPlayer().sam_has_report = v
	end

	local new_animation = function(panel, name)
		local new_name = "anim_" .. name
		panel["MoveToNew" .. name:upper()] = function(self, new, cb)
			if self[new_name] then
				table.RemoveByValue(self.m_AnimList, self[new_name])
			end

			self[new_name] = self:NewAnimation(0.2, 0, -1, function()
				self[new_name] = nil
				if cb then cb() end
			end)

			self[new_name].Think = function(_, _, frac)
				self[name] = Lerp(frac, self[name], new)
			end
		end
	end

	new_animation(Panel, "x")
	new_animation(Panel, "y")

	vgui.Register("SAM.Report", Panel, "EditablePanel")
end
--PATH addons/sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--PATH addons/sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--PATH addons/realistichandcuffs/lua/tbfy_rhandcuffs/cl_rhandcuffs_npc.lua:

net.Receive("RHC_Jailer_Menu", function()
	local PlayerToJail = net.ReadEntity()

	local JailerMenu = vgui.Create("rhc_jailernpc_menu")
	JailerMenu:SetAPlayer(PlayerToJail)
end)

net.Receive("RHC_Bailer_Menu", function()
	vgui.Create("rhc_bailernpc_menu")
end)

net.Receive("rhc_sendjailtime", function()
	local Player, Arrester, Time = net.ReadEntity(), net.ReadString(), net.ReadFloat()
	
	Player.HCArrestedBy = Arrester
	Player.ArrestTime = Time
end)

surface.CreateFont( "rhc_bailer_pheader", {
	font = "trebuchet18",
	size = 18,
	weight = 1000,
	antialias = true,
})

surface.CreateFont( "rhc_npc_text", {
	font = "Verdana",
	size = 50,
	weight = 500,
	antialias = true,
})

local MainPanelColor = Color(50,50,50,200)
local MainPanelOutline = Color(0,0,0,200)
local HeaderH = 25
local HeaderColor = Color(0,0,0,200)
local HeaderOutline = Color(0,0,0,200)
local ButtonColor = Color(50,50,50,200)
local ButtonColorHovering = Color(75,75,75,200)
local ButtonColorPressed = Color(150,150,150,200)
local ButtonOutline = Color(0,0,0,200)
local BailerPlayerColor = Color(35,35,35,255)

local PANEL = {}

function PANEL:Init()
	self.ButtonText = ""
	self.BColor = ButtonColor
	self:SetText("")
end

function PANEL:UpdateColours()

	if self:IsDown() or self.m_bSelected then self.BColor = ButtonColorPressed return end
	if self.Hovered then self.BColor = ButtonColorHovering return end

	self.BColor = ButtonColor
	return
end

function PANEL:SetBText(Text)
	self.ButtonText = Text
end

function PANEL:Paint(W,H)
	surface.SetDrawColor(self.BColor)
	surface.DrawRect( 0, 0, W, H)
	surface.SetDrawColor(ButtonOutline)
	surface.DrawOutlinedRect( 0, 0, W, H ) 
	draw.SimpleText(self.ButtonText, "Trebuchet18", W/2, H/2, Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )   
end
vgui.Register( "rhc_button", PANEL, "DButton")

local PANEL = {}

function PANEL:Init()	
	self:ShowCloseButton(false)
	self:SetTitle("")   
	self:MakePopup()
	self.JailNick = "You need to be dragging a player"
	
    self.TopDPanel = vgui.Create("DPanel", self)
	self.TopDPanel.Paint = function(selfp, W,H) 
		surface.SetDrawColor(HeaderColor)
		surface.DrawRect( 0, 0, W, H)
		surface.SetDrawColor(HeaderOutline)
		surface.DrawOutlinedRect( 0, 0, W, H )
		draw.SimpleText("Jailer NPC", "Trebuchet18", W/2, H/2, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
	end	

	self.JailSlider = vgui.Create( "DNumSlider", self )
	self.JailSlider:SetText("Years Amount")
	self.JailSlider:SetMin(1)
	self.JailSlider:SetMax(RHandcuffsConfig.MaxJailYears)
	self.JailSlider:SetDecimals(0)	
	self.JailSlider:SetValue(1)	
	self.JailSlider.Scratch.OnMousePressed = function() end
	self.JailSlider.Scratch.OnMouseReleased = function() end
	self.JailSlider.Scratch:SetCursor("none")

	self.JailButton = vgui.Create("rhc_button", self)
	self.JailButton:SetBText("Put in jail")
	self.JailButton.DoClick = function() net.Start("RHC_jail_player") net.WriteEntity(self.APlayer) net.WriteFloat(self.JailSlider:GetValue()) net.WriteString(self.JailReason:GetValue()) net.SendToServer() self:Remove() end		
	
	self.JailReason = vgui.Create("DTextEntry", self)	
	
	self.CloseButton = vgui.Create("rhc_button", self)
	self.CloseButton:SetBText("X")
	self.CloseButton.DoClick = function() self:Remove() end	
end

function PANEL:SetAPlayer(Player)
	if !IsValid(Player) and !Player:IsPlayer() then return end
	self.JailNick = "Player: " .. Player:Nick()
	self.APlayer = Player
end

function PANEL:Paint(W,H)
    surface.SetDrawColor(MainPanelColor)
	surface.DrawRect( 0, 0, W, H)
	surface.SetDrawColor(MainPanelOutline)
	surface.DrawOutlinedRect( 0, 0, W, H )
	
	draw.SimpleText(self.JailNick, "Trebuchet18", W/2, HeaderH+5, Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	draw.SimpleText("Reason:", "Trebuchet18", 5, HeaderH+55, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
end

local Width, Height = 200, 140
function PANEL:PerformLayout()
	self:SetPos(ScrW()/2-Width/2, ScrH()/2-Height/2)
	self:SetSize(Width, Height)
	
    self.TopDPanel:SetPos(0,0)
	self.TopDPanel:SetSize(Width,HeaderH+2)	

	self.JailSlider:SetPos(5,HeaderH+25)
	self.JailSlider:SetSize(Width-10,25)
	
	self.JailReason:SetPos(50, HeaderH+55)
	self.JailReason:SetSize(Width-60, 20)
	
	self.JailButton:SetPos(Width/2-37.5,Height-30)
	self.JailButton:SetSize(75,25)	
	
	self.CloseButton:SetPos(Width-HeaderH/2-7.5,HeaderH/2-7.5)
	self.CloseButton:SetSize(15, 15)	
end

vgui.Register("rhc_jailernpc_menu", PANEL, "DFrame")

local PANEL = {}

function PANEL:Init()	
	self.BailNick = ""
	self.Time = 0
	self.BailPrice = 0
	self.BailPlayer = nil
	self.ArrestedBy = ""
	
	self.Avatar = vgui.Create("AvatarImage", self)

	self.BailPButton = vgui.Create("rhc_button", self)
	self.BailPButton:SetBText("Bail Player")	
	self.BailPButton.DoClick = function()
		if !LocalPlayer():canAfford(self.BailPrice) then LocalPlayer():ChatPrint("You can't afford that!") return end
		net.Start("RHC_bail_player")
			net.WriteEntity(self.BailPlayer)
		net.SendToServer()
		
		local MainP = self.MainPanel
		MainP.BailPlayers[self.TID] = nil
		self:Remove()
		MainP:PerformLayout()		
	end
end

function PANEL:SetBailPlayer(Player)
	self.BailPlayer = Player
	self.BailNick = Player:Nick()
	if Player.ArrestTime and Player.HCArrestedBy then
		local Time = Player.ArrestTime/60
		self.Time = Time
		self.ArrestedBy  = Player.HCArrestedBy
		self.BailPrice = Time*RHandcuffsConfig.BailPricePerYear
	end
	self.Avatar:SetPlayer(Player, 128)		
end

function PANEL:Paint(W,H)
    surface.SetDrawColor(BailerPlayerColor)
	surface.DrawRect( 0, 0, W, H)
	surface.SetDrawColor(HeaderOutline)
	surface.DrawOutlinedRect( 0, 0, W, H )
	
	draw.SimpleText(self.BailNick, "rhc_bailer_pheader", W/2, 0, Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP ) 
	
	local TextStartW = H
	
	draw.SimpleText("Arrested by: " .. self.ArrestedBy, "Trebuchet18", TextStartW, 30, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) 
	draw.SimpleText("Jail Time: " .. self.Time .. " years", "Trebuchet18", TextStartW, 45, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) 
	draw.SimpleText("Bail Price: $" .. self.BailPrice, "Trebuchet18", TextStartW, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) 
end

function PANEL:PerformLayout(W,H)
	self.BailPButton:SetPos(W-105, H-30)
	self.BailPButton:SetSize(100,25)
	
	local AH = H - 10
	self.Avatar:SetPos(5,5)
	self.Avatar:SetSize(AH,AH)	
end

vgui.Register("rhc_bailernpc_player", PANEL)

local PANEL = {}

function PANEL:Init()	
	self:ShowCloseButton(false)
	self:SetTitle("")   
	self:MakePopup()
	
    self.TopDPanel = vgui.Create("DPanel", self)
	self.TopDPanel.Paint = function(selfp, W,H) 
		surface.SetDrawColor(HeaderColor)
		surface.DrawRect( 0, 0, W, H)
		surface.SetDrawColor(HeaderOutline)
		surface.DrawOutlinedRect( 0, 0, W, H )
		draw.SimpleText("Bailer NPC", "Trebuchet18", W/2, H/2, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
	end	

	self.BailerList = vgui.Create("DScrollPanel", self)
	self.BailerList.Paint = function(selfp, W, H)
	end
	
	self.BailerList.VBar.Paint = function() end
	self.BailerList.VBar.btnUp.Paint = function() end
    self.BailerList.VBar.btnDown.Paint = function() end	
	self.BailerList.VBar.btnGrip.Paint = function() end		
	
	self.BailPlayers = {}
	for k,v in pairs(player.GetAll()) do
		if v:isArrested() then
			local BailP = vgui.Create("rhc_bailernpc_player", self.BailerList)
			BailP:SetBailPlayer(v)
			BailP.MainPanel = self
			BailP.TID = k
			self.BailPlayers[k] = BailP
		end	
	end
	
	self.CloseButton = vgui.Create("rhc_button", self)
	self.CloseButton:SetBText("X")
	self.CloseButton.DoClick = function() self:Remove() end	
end

function PANEL:Paint(W,H)
    surface.SetDrawColor(MainPanelColor)
	surface.DrawRect( 0, 0, W, H)
	surface.SetDrawColor(MainPanelOutline)
	surface.DrawOutlinedRect( 0, 0, W, H )
end

local Width, Height = 350, 392
function PANEL:PerformLayout()
	self:SetPos(ScrW()/2-Width/2, ScrH()/2-Height/2)
	self:SetSize(Width, Height)
	
	local HeaderH = 25	
	
    self.TopDPanel:SetPos(0,0)
	self.TopDPanel:SetSize(Width,HeaderH+2)	
	
	self.BailerList:SetPos(5,HeaderH+5)
	self.BailerList:SetSize(Width+5, Height-HeaderH-10)
	
	local BW = self.BailerList:GetWide()-15
	local SBH = 0
	for k,v in pairs(self.BailPlayers) do
		v:SetPos(0,SBH)
		v:SetSize(BW,90)
		SBH = SBH + 89
	end
	
	self.CloseButton:SetPos(Width-HeaderH/2-7.5,HeaderH/2-7.5)
	self.CloseButton:SetSize(15, 15)	
end

vgui.Register("rhc_bailernpc_menu", PANEL, "DFrame")
--PATH addons/tlib/lua/tlib/shared/util.lua:
--[[

    IsMaterial

]]--

function IsMaterial( xObject )
    return ( type( xObject ) == "IMaterial" )
end

--[[

    TLib:BitsToUInt
        - Desc: Converts a unsigned bitcount to it's maximal value
        - Params: Unsigned bitcount (number)
        - Return: Max value (number)

]]--

function TLib:BitsToNumber( iBitCount )
    return ( ( 2 ^ iBitCount ) - 1 )
end

--[[

    TLib:StringifyKeys
        - Desc: Converts all keys of an array to strings (only works with uni-dimensional arrays)
        - Params: tTarget (table)
        - Return: "Stringified" array (table)

]]--

function TLib:StringifyKeys( tTarget )
    local tArray = {}
    for k, v in pairs( tTarget ) do
        tArray[ tostring( k ) ] = v
    end

    return tArray
end

--[[

    TLib:C
        - Params: ID (number)
        - Return: Color object (color)

]]--

function TLib:C( iID )
    return self.Cfg.Colors[ iID ]
end

--[[

    TLib:SetBrightness
        - Desc: Changes the brightness of a color
        - Params: Color object (color), New brightness level (number)
        - Return: Color object (color)

]]--

function TLib:SetBrightness( tCol, iLevel )
    if ( iLevel == 100 ) then
        return tCol
    end

    local i = ( iLevel * .01 )
    return Color( ( tCol.r * i ), ( tCol.g * i ), ( tCol.b * i ), ( tCol.a or 255 ) )
end

--[[

    TLib:ForceNumeric
        Args: Input (any type)[, Value returned on fail {default: 0} (number)]
        Return: Numerical value (number)

]]--

function TLib:ForceNumeric( xValue, iFail )
    local iFail = ( iFail or 0 )
    if not xValue then
        return iFail
    end

    if isnumber( xValue ) then
        return xValue
    end

    if istable( xValue ) then
        local iMin, iMax = false, false
        for k, v in ipairs( table.ClearKeys( xValue ) ) do
            if isnumber( v ) then
                iMin = math.min( ( iMin or v ), v )
                iMax = math.max( ( iMax or v ), v )
            end
        end

        if not iMin or not iMax then
            return iFail
        end

        return math.random( iMin, iMax )
    end

    return iFail
end

--[[

    TLib:LerpColor
        - Desc: Run interpolations between two colors
        - Params: Time (number), Starting color (color), Target color (color)
        - Return: Lerps result (color)

]]--

function TLib:LerpColor( fTime, tFrom, tTo )
    return Color(
        Lerp( fTime, tFrom.r, tTo.r ),
        Lerp( fTime, tFrom.g, tTo.g ),
        Lerp( fTime, tFrom.b, tTo.b ),
        Lerp( fTime, tFrom.a, tTo.a )
    )
end

--PATH addons/sl_main_system/lua/autorun/sl_config_classe.lua:
-- sh

util.PrecacheModel( "models/mad_models/mad_sl_male_armor7.mdl" )
util.PrecacheModel( "models/mad_models/mad_sl_male_armor21.mdl" )
util.PrecacheModel( "models/mad_models/mad_sl_male_armor22.mdl" )
util.PrecacheModel( "models/mad_models/mad_sl_male_armor6.mdl" )
util.PrecacheModel( "models/mad_models/mad_sl_male_armor2.mdl" )
util.PrecacheModel( "models/mad_models/mad_sl_male_armor4.mdl" )
util.PrecacheModel( "models/mad_models/mad_sl_male_armor14.mdl" )
util.PrecacheModel( "models/mad_models/mad_sl_male_armor25.mdl" )
CLASSES_SL = {
    ["tank"] = {
        name = "Tank",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor1.mdl",
        rarete = "commun",
        boost_hp = 50,
        boost_vitesse = 1,
    },
    ["guerrier"] = {
        name = "Guerrier",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor21.mdl",
        rarete = "commun",
        boost_hp = 20,
        boost_vitesse = 1,
    },
    -- ["archer"] = {
    --     name = "Archer",
    --     swep = "",
    --     mdl = "models/mad_models/mad_sl_male_armor7.mdl",
    --     rarete = "rare",
    --     boost_hp = 1,
    --     boost_vitesse = 1,
    -- },
    ["guerrier_lourd"] = {
        name = "Guerrier Lourd",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor21.mdl",
        rarete = "rare",
        boost_hp = 20,
        boost_vitesse = 1,
    },
    ["healer"] = {
        name = "Healer",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor7.mdl",
        rarete = "rare",
        boost_hp = 20,
        boost_vitesse = 1,
    },
    --- EPIQUE
    ["assassin"] = {
        name = "Assassin",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor6.mdl",
        rarete = "epique",
        boost_hp = 10,
        boost_vitesse = 60,
    },
    ["gardien"] = {
        name = "Gardien",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor6.mdl",
        rarete = "epique",
        boost_hp = 80,
        boost_vitesse = 1,
    },
    ["pretre"] = {
        name = "Pr√™tre",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor6.mdl",
        rarete = "epique",
        boost_hp = 30,
        boost_vitesse = 20,
    },
    --- LEGENDAIRE
    ["mage"] = {
        name = "Mage",
        swep = "",
        useMagie = true,
        mdl = "models/mad_models/mad_sl_male_armor4.mdl",
        rarete = "legendaire",
        boost_hp = 50,
        boost_vitesse = 25,
    },
    
    ["ex√©cuteur"] = {
        name = "Ex√©cuteur",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor6.mdl",
        rarete = "legendaire",
        boost_hp = 75,
        boost_vitesse = 75,
    },
    ["chevalier"] = {
        name = "Chevalier",
        swep = "",
        mdl = "models/mad_models",
        rarete = "rare",
        boost_hp = 120,
        boost_vitesse = 50,
    }, 
    --- mythique   
    ["sage"] = {
        name = "Sage",
        swep = "",
        useMagie = true,
        mdl = "models/mad_models/mad_sl_male_armor24.mdl",
        rarete = "mythique",
        boost_hp = 150,
        boost_vitesse = 100,
    },
    ["moine"] = {
        name = "Moine",
        swep = "mad_corpsacorps",
        mdl = "models/mad_models/mad_sl_male_armor24.mdl",
        rarete = "mythique",
        boost_hp = 150,
        boost_vitesse = 100,
    },
    ---unique
    ["archi_mage"] = {
        name = "Archi Mage",
        swep = "",
        useMagie = true,
        mdl = "models/mad_models/mad_sl_male_armor24.mdl",
        rarete = "unique",
        boost_hp = 200,
        boost_vitesse = 151,
    },
    ["bestial"] = {
        name = "Bestial",
        swep = "mad_corpsacorps",
        mdl = "models/mad_models/mad_sl_male_transfo2.mdl",
        rarete = "unique",
        boost_hp = 200,
        boost_vitesse = 151,
    },
    ["vampire"] = {
        name = "Vampire",
        swep = "",
        mdl = "models/mad_models/mad_sl_male_armor17.mdl",
        rarete = "unique",
        boost_hp = 200,
        boost_vitesse = 151,
    },
}
--PATH addons/sl_main_system/lua/autorun/sl_config_magie.lua:
-- sh

MAGIE_SL = {
    
    ["feu"] = {
        name = "Feu",
        rarete = "commun",
        color = Color(99,252,146),
    },

    ["eau"] = {
        name = "Eau",
        rarete = "commun",
        color = Color(99,252,146),
    },

    ["terre"] = {
        name = "Terre",
        rarete = "commun",
        color = Color(99,252,146),
    },

    ["air"] = {
        name = "Air",
        rarete = "commun",
        color = Color(99,252,146),
    },

    ["foudre"] = {
        name = "Foudre",
        rarete = "rare",
        color = Color(99,247,252),
    },

    ["glace"] = {
        name = "Glace",
        rarete = "rare",
        color = Color(99,247,252),
    },

    ["lumiere"] = {
        name = "Lumi√®re",
        rarete = "legendaire",
        color = Color(252,250,99),
    },

    ["tenebre"] = {
        name = "T√©n√®bres",
        rarete = "legendaire",
        color = Color(252,250,99),
    },

}
--PATH addons/slib_stromic_s_library/lua/autorun/slib_loader.lua:
local function slibInit()
    print("[slib] Loading")

    if SERVER then
        AddCSLuaFile("slib/sh_util.lua")
        include("slib/sv_storage.lua")
        include("slib/sh_util.lua")
    else
        include("slib/sh_util.lua")
    end
end

hook.Add("slib:loadBase", "slib.loadVGUI", function()
    slib.loadFolder("slib/vgui/", false, {{"slib/vgui/", "cl_sframe.lua"}})
end)

slibInit()
--PATH addons/slib_stromic_s_library/lua/slib/vgui/cl_slistview.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 15)
local textcolor, maincolor_7, linecol, neutralcolor, margin = slib.getTheme("textcolor"), slib.getTheme("maincolor", 7), Color(24,24,24,160), slib.getTheme("neutralcolor"), slib.getTheme("margin")

function PANEL:Init()
    self.Columns = self.Columns or {}
    self.Lines = self.Lines or {}

    self.columniteration = 0
    self.lineiteration = 0
    
    self.assortment = self.assortment or {}

    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
	slib.wrapFunction(self, "MakePopup", nil, function() return self end, true)
end

function PANEL:getColumnPos(col)
    local result = self.Columns[col]:GetPos()
    return select(1, result)
end

function PANEL:getColumnWide(col)
    return self.Columns[col]:GetWide()
end

local function differenciate(a, b)
    if isfunction(a) then a = a() end
    if isfunction(b) then b = b() end
    if isnumber(tonumber(a)) and isnumber(tonumber(b)) then return tonumber(a), tonumber(b) end

    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

function PANEL:addColumn(name)
    if !IsValid(self.topbar) then
        self.topbar = vgui.Create("EditablePanel", self)
        self.topbar:Dock(TOP)
        self.topbar:SetZPos(-32768)
        self.topbar:SetTall(slib.getScaledSize(25, "y"))

        self.topbar.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(linecol)
            surface.DrawRect(0, h - 1, w - 1, 1)
        end
    end

    self.columniteration = self.columniteration + 1

    local iteration = self.columniteration
    local ignoreWidth = false


    if istable(name) then
        if name[2] then
            ignoreWidth = name[2]
        end
        name = name[1]
    end

    self.Columns[iteration] = vgui.Create("DButton", self.topbar)
    self.Columns[iteration]:Dock(LEFT)
    self.Columns[iteration]:SetWide(self:GetWide() / #self.Columns)
    self.Columns[iteration].Width = self:GetWide() / #self.Columns
    self.Columns[iteration]:SetText("")
    self.Columns[iteration].name = name
    self.Columns[iteration].iteration = iteration
    self.Columns[iteration].ignoreWidth = ignoreWidth

    self.Columns[iteration].DoClick = function()
        if self.assortment.iteration == iteration then
            self.assortment.ascending = !self.assortment.ascending
        else
            self.assortment.iteration = iteration
            self.assortment.ascending = true
        end
        
        local basictable = {}
        local cleantable = {}

        for i=1,#self.Lines do
            local tbl = self.Columns[iteration]["lines"][i]
            local sortvalue = istable(tbl) and (tbl.sortvalue or tbl.text) or tbl

            table.insert(basictable, sortvalue)
        end
        
        if self.assortment.ascending then
            table.sort(basictable, function(a, b) a, b = differenciate(a, b) return a > b end)
        else
            table.sort(basictable, function(a, b) a, b = differenciate(a, b) return a < b end)
        end

        for i, z in pairs(basictable) do
            cleantable[z] = i
        end
        
        for i=1,#self.Lines do
            local tbl = self.Columns[iteration]["lines"][i]
            local final = istable(tbl) and (tbl.sortvalue or tbl.text) or tbl

            if !IsValid(self.Lines[i]) then continue end

            self.Lines[i]:SetZPos(cleantable[final])
        end
    end

    self.Columns[iteration].Paint = function(s,w,h)
        draw.SimpleText(name, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    return self
end

function PANEL:addColumns(...)
    local args = {...}

    for k,v in pairs(args) do
        self:addColumn(v)
    end

    return self
end

function PANEL:addLine(...)
    local args = {...}
    if !IsValid(self.frame) then
        self.frame = vgui.Create("SScrollPanel", self)
        self.frame:Dock(FILL)
        self.frame:SetTall(slib.getScaledSize(25, "y"))
    end

    self.lineiteration = self.lineiteration + 1

    local iteration = self.lineiteration

    for k,v in ipairs(args) do
        local display = istable(v) and v[1] or v
        local sortingvalue

        if istable(v) and v[2] then
            sortingvalue = v[2]
        end

        self.Columns[k]["lines"] = self.Columns[k]["lines"] or {}
        self.Columns[k]["lines"][iteration] = self.Columns[k]["lines"][iteration] or {}
        
        self.Columns[k]["lines"][iteration]["text"] = display
        
        if sortingvalue then
            self.Columns[k]["lines"][iteration]["sortvalue"] = sortingvalue
        end
    end

    self.Lines[iteration] = vgui.Create("DButton", self)
    self.Lines[iteration]:Dock(TOP)
    self.Lines[iteration]:SetTall(slib.getScaledSize(25, "y"))
    self.Lines[iteration]:SetText("")
    self.Lines[iteration].InitDoClick = self.Lines[iteration].DoClick

    self.Lines[iteration].Think = function()
        self.Lines[iteration]:SetMouseInputEnabled(self.Lines[iteration].DoClick ~= self.Lines[iteration].InitDoClick)
    end

    self.Lines[iteration].Paint = function(s,w,h)
        local wantedcolor = neutralcolor

        if !s:IsHovered() then
            wantedcolor = table.Copy(wantedcolor)
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)
        
        for i = 1,#self.Columns do
            local display = self.Columns[i]["lines"][iteration].text

            if isfunction(display) then
                display = display()
            end

            local x,y = self:getColumnPos(i), h * .5
            local w = self:getColumnWide(i)

            if w < (self:getTextWidth(display, self.Columns[i].maxTxtLen) + margin * 2) then self:resizeColumns() end
            if i == 1 then
                s.name = display
            end

            if self.Columns[i].ignoreWidth or self.Columns[i].maxTxtLen then
                surface.SetFont(font)
                local txt_h = select(2, surface.GetTextSize(display))
                local screen_x, screen_y = s:LocalToScreen(0,0)

                render.SetScissorRect(screen_x + x, screen_y, screen_x + x + self.Columns[i]:GetWide() - margin, screen_y + h, true)
                draw.SimpleText(display, font, x + slib.getTheme("margin"), y, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                render.SetScissorRect(0, 0, 0, 0, false)
            else

                if self.Columns[i].customRender and self.Columns[i].customRender(x, 0, w, h, s) == true then return end

                draw.SimpleText(display, font, x + slib.getTheme("margin"), y, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            end
        end
    end

    self:resizeColumns()

    return self, self.Lines[iteration]
end

function PANEL:getTextWidth(txt, max)
    txt = tostring(txt)

    if max then
        txt = string.sub(txt, 1, max)
    end

    surface.SetFont(font)

    return surface.GetTextSize(txt)
end

function PANEL:resizeColumns()
    local columnsizes = {}
    local fullwidth = self:GetWide()
    local spaceleft = 0

    for k, v in pairs(self.Columns) do
        local ignoreWidth = self.Columns[k].ignoreWidth
        surface.SetFont(font)

        local longest = self:getTextWidth(self.Columns[k].name)
        if ignoreWidth then columnsizes[k] = isstring(ignoreWidth) and self:getTextWidth(ignoreWidth) or longest continue end
        if !self.Columns[k]["lines"] then continue end
        for i, z in pairs(self.Columns[k]["lines"]) do
            local compare = isfunction(z.text) and z.text() or z.text
            local width = self:getTextWidth(compare, self.Columns[k].maxTxtLen) + (slib.getTheme("margin") * 10)
            if longest < width then longest = width end
        end

        columnsizes[k] = longest
    end

    local occupiedspace = 0
    for k,v in pairs(columnsizes) do
        occupiedspace = occupiedspace + v
    end

    for k,v in pairs(self.Columns) do
        local v = columnsizes[k] or 0

        local gapadd = (fullwidth - occupiedspace) / #self.Columns
        self.Columns[k]:SetWide(v + gapadd)
    end
end

function PANEL:OnSizeChanged()
    self:resizeColumns()
end

function PANEL:PaintOver(w,h)
    for k,v in pairs(self.Columns) do
        if k >= #self.Columns then break end
        local x,y = self:getColumnPos(k), h * .5
        local w = self:getColumnWide(k)
        surface.SetDrawColor(linecol)
        surface.DrawRect(x + w - 1, 0, 1, h)
    end
end

vgui.Register("SListView", PANEL, "SScrollPanel")
--PATH addons/gprotect_1.15.101/lua/g_protect/sh_gprotect_baseconfig.lua:
------------------------------------------------------                                   
-- NO NOT TOUCH ANYTHING IN HERE!!!!!!!!!                                                  
------------------------------------------------------                  
                  
gProtect = gProtect or {}                        
gProtect.config = gProtect.config or {}
gProtect.config.modules = gProtect.config.modules or {}

gProtect.config.modules.general = {
	["blacklist"] = {                   
		["prop_physics"] = true,
		["prop_physics_multiplayer"] = true
	},
	["remDiscPlyEnt"] = 120,
	["remDiscPlyEntSpecific"] = {},
	["remOutOfBounds"] = 120,
	["remOutOfBoundsWhitelist"] = {},
	["protectedFrozenEnts"] = {
		["prop_physics"] = true,
		["prop_physics_multiplayer"] = true
	},
	["protectedFrozenGroup"] = COLLISION_GROUP_INTERACTIVE_DEBRIS
}

gProtect.config.modules.ghosting = {
	["enabled"] = true,
	["ghostColor"] = Color(66, 135, 40, 120),
	["antiObscuring"] = {["player"] = true},
	["obscureOffset"] = 10,
	["entities"] = {},
	["onPhysgun"] = true,
	["forceUnfrozen"] = false,
	["forceUnfrozenEntities"] = {["prop_physics"] = true},
	["useBlacklist"] = true,
	["enableMotion"] = false,
}

gProtect.config.modules.damage = {
	["enabled"] = true,
	["useBlacklist"] = true,
	["vehiclePlayerDamage"] = false,
	["blacklistedEntPlayerDamage"] = true,
	["worldPlayerDamage"] = true,
	["entities"] = {},
	["immortalEntities"] = {},
	["bypassGroups"] = {},
	["canDamageWorldEntities"] = {["*"] = true}
}

gProtect.config.modules.anticollide = {
	["enabled"] = true,
	["notifyStaff"] = true,
	["protectDarkRPEntities"] = 1,
	["DRPentitiesThreshold"] = 125,
	["DRPentitiesException"] = 1,
	["protectSpawnedEntities"] = 1,
	["entitiesThreshold"] = 75,
	["entitiesException"] = 1,
	["protectSpawnedProps"] = 3,
	["propsThreshold"] = 45,
	["propsException"] = 1,
	["playerPropAction"] = 4,
	["playerPropThreshold"] = 500,
	["specificEntities"] = {},
	["squaredPhysicsMaxSize"] = 0,
	["squaredPhysicsEnts"] = {}
}

gProtect.config.modules.spamprotection = {
	["enabled"] = true,
	["threshold"] = 3,
	["delay"] = 1,
	["action"] = 1,
	["notifyStaff"] = true,
	["protectProps"] = true,
	["protectEntities"] = true
}

gProtect.config.modules.spawnrestriction = {
	["enabled"] = true,

	["propSpawnPermission"] = {["*"] = true},
	["SENTSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["SWEPSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["vehicleSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["NPCSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["ragdollSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["effectSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["blockedEntities"] = {},
	["blockedModels"] = {},
	["blockedModelsisBlacklist"] = true,
	["blockedModelsVehicleBypass"] = true,
	["blockedEntitiesIsBlacklist"] = true,
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true},
	["maxPropModelComplexity"] = 10,
	["maxModelSize"] = 3000
}

gProtect.config.modules.toolgunsettings = {
	["enabled"] = true,            
	["targetWorld"] = {},
	["targetPlayerOwned"] =  {},     
	["targetPlayerOwnedProps"] = {},
	["targetVehiclePermission"] = {["superadmin"] = true},
	["restrictTools"] = {["rope"] = true},
	["groupToolRestrictions"] = {             
		["superadmin"] = {
			isBlacklist = true,
			list = {}
		}
	},
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true},
	["entityTargetability"] = {
		isBlacklist = true,
		list = {["sammyservers_textscreen"] = true, ["player"] = true},
	},
	["bypassTargetabilityTools"] = {["remover"] = true},
	["bypassTargetabilityGroups"] = {["owner"] = true, ["superadmin"] = true},
	["antiSpam"] = {}
}

gProtect.config.modules.physgunsettings = {                    
	["enabled"] = true,
	["targetWorld"] = {},
	["targetPlayerOwned"] = {},
	["targetPlayerOwnedProps"] = {},
	["targetPlayerOwnedPropsGroupLevel"] = {},
	["DisableReloadUnfreeze"] = true,          
	["PickupVehiclePermission"] = {["superadmin"] = true},
	["StopMotionOnDrop"] = true,
	["blockMultiplePhysgunning"] = true,
	["maxDropObstructs"] = 3,               
	["maxDropObstructsAction"] = 1,
	["preventPropClimbing"] = true,
	["preventPropClimbingThreshold"] = 5,
	["preventPropClimbingAction"] = 1,
	["blockedEntities"] = {},
	["bypassGroups"] = {}
}

gProtect.config.modules.gravitygunsettings = {                   
	["enabled"] = true,
	["targetWorld"] = {["*"] = true},
	["targetPlayerOwned"] = {["*"] = true},
	["targetPlayerOwnedProps"] = {["*"] = true},
	["DisableGravityGunPunting"] = true,
	["blockedEntities"] = {},
	["bypassGroups"] = {}
}

gProtect.config.modules.canpropertysettings = {
	["enabled"] = true,
	["targetWorld"] = {},
	["targetPlayerOwned"] = {},
	["targetPlayerOwnedProps"] = {},
	["blockedProperties"] = {},
	["blockedPropertiesisBlacklist"] = true,
	["blockedEntities"] = {},
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true}
}

gProtect.config.modules.canusesettings = {
	["enabled"] = true,
	["targetWorld"] = {["*"] = true},
	["targetPlayerOwned"] = {["*"] = true},
	["targetPlayerOwnedProps"] = {["*"] = true},
	["blockedEntities"] = {},
	["blockedEntitiesisBlacklist"] = true,
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true}
}

gProtect.config.modules.advdupe2 = {
	["enabled"] = true,
	["notifyStaff"] = true,
	["PreventRopes"] = 1,
	["PreventScaling"] = 1,
	["PreventNoGravity"] = 1,
	["PreventTrail"] = 1,
	["PreventUnreasonableValues"] = true,
	["PreventUnfreezeAll"] = true,
 	["BlacklistedCollisionGroups"] = {[COLLISION_GROUP_IN_VEHICLE] = true, [COLLISION_GROUP_PROJECTILE] = true},
	["WhitelistedConstraints"] = {
		["weld"] = true
	},
	["whitelistedClasses"] = {["gmod_button"] = true},
	["DelayBetweenUse"] = 2
}

gProtect.config.modules.miscs = {
	["enabled"] = true,
	["ClearDecals"] = 120,
	["blacklistedFadingDoorMats_punishment"] = 1,
	["blacklistedFadingDoorMats"] = {["pp/copy"] = true, ["dev/upscale"] = true},
	["FadingDoorLag"] = true,
	["DisableMotion"] = false,
	["DisableMotionEntities"] = {["prop_physics"] = true},
	["freezeOnSpawn"] = true,
	["preventFadingDoorAbuse"] = true,
	["precisionMoveFix"] = true,
	["preventSpawnNearbyPlayer"] = 10,
	["DRPEntForceOwnership"] = {},
	["DRPMaxObstructsOnPurchaseEnts"] = 3,
	["DRPObstructsFilter"] = 1
}

------------------------------------------------------           
-- NO NOT TOUCH ANYTHING IN HERE!!!!!!!!!                                                  
------------------------------------------------------
--PATH addons/gprotect_1.15.101/lua/g_protect/client/cl_gprotect.lua:
gProtect = gProtect or {}
gProtect.TouchPermission = gProtect.TouchPermission or {}
gProtect.LoadedModules = gProtect.LoadedModules or {}
gProtect.CachedPlayers = gProtect.CachedPlayers or {}
gProtect.NetworkOwnershipQueue = gProtect.NetworkOwnershipQueue or {}

local highLighted = {}
local highlightedPlys = {}

local function doPlayerAction(ply, channel, int)
	net.Start("gP:Networking")
	net.WriteUInt(1, 2)
	net.WriteUInt(channel, 2)
	net.WriteUInt(int, 3)
	if ply then
		net.WriteEntity(ply)
	end
	net.SendToServer()
end

local generalActions = {
	["ghost-everyones-props"] = {zpos = -99, option = function() doPlayerAction(nil, 2, 1) end},
	["freeze-everyones-props"] = {zpos = -98, option = function() doPlayerAction(nil, 2, 2) end},
	["remove-disconnected-entities"] = {zpos = -97, option = function() doPlayerAction(nil, 2, 3) end}
}

local cmds = {
	["gprotect_ghostprops"] = function() doPlayerAction(nil, 2, 1) end,
	["gprotect_freezeprops"] = function() doPlayerAction(nil, 2, 2) end,
	["gprotect_removedisc_props"] = function() doPlayerAction(nil, 2, 3) end,
}

for k,v in pairs(cmds) do
	concommand.Add(k, v)
end

local playerActions = {
	[1] = {name = "ghost-props", option = function(ply) doPlayerAction(ply, 1, 3) end},
	[2] = {name = "freeze-props", option = function(ply) doPlayerAction(ply, 1, 1) end},
	[3] = {name = "remove-props", option = function(ply) doPlayerAction(ply, 1, 2) end},
	[4] = {name = "remove-entities", option = function(ply) doPlayerAction(ply, 1, 4) end}
}

local function openSettingsMenu()
	local gprotect_menu = vgui.Create("SFrame")
	:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "title"))
	:SetSize(slib.getScaledSize(gProtect.config.FrameSize.x, "x"),slib.getScaledSize(gProtect.config.FrameSize.y, "y"))
    :Center()
    :addCloseButton()
	:MakePopup()

	for k, v in pairs(gProtect.config.modules) do
		local _, tab = gprotect_menu:addTab(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k), "gprotect/tabs/"..k..".png")
		tab:SetZPos(gProtect.config.ModuleCoordination[k])

		if isfunction(gProtect.config.ModuleShouldDisplay[k]) and gProtect.config.ModuleShouldDisplay[k]() == false then
			tab:SetVisible(false)
		end
		
		local scroller = vgui.Create("SScrollPanel", tab:getFrame())
		:Dock(FILL)

		scroller:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

		for option, data in pairs(v) do

			if gProtect.LoadedModules[k] and gProtect.LoadedModules[k][option] ~= nil then
				data = gProtect.LoadedModules[k][option]
			else
				data = gProtect.config.modules[k][option]
			end

			if data == nil then continue end
			if isbool(gProtect.config.modules[k][option]) then data = tobool(data) end
			local setting = vgui.Create("SStatement", scroller)
            local _, element = setting:SetZPos(gProtect.config.sortOrders[k][option])
			:addStatement(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k.."_"..option), data)

			local statement = slib.getStatement(data)

			if statement == "int" then
				if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] and gProtect.config.valueRules[k][option].intLimit then
					element:SetMin(gProtect.config.valueRules[k][option].intLimit.min)
					element:SetMax(gProtect.config.valueRules[k][option].intLimit.max)
				end
			end

			if statement == "table" then
					element.onElementOpen = function(s)
						if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then slib.notify(gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "insufficient-permission")) s:Remove() return end
						local tbl
						if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] and gProtect.config.valueRules[k][option].tableAlternatives then
							tbl = gProtect.config.valueRules[k][option].tableAlternatives
							if isfunction(gProtect.config.valueRules[k][option].tableAlternatives) then
								tbl = gProtect.config.valueRules[k][option].tableAlternatives()
							end
						end

						s:addSuggestions(tbl)
						s:sortValues(s.viewer)
						s:sortValues(s.suggestions)
						s:addEntry()
						s:addSearch(s.viewbox, s.viewer)
						s:addSearch(s.suggestionbox, s.suggestions)
						s:setIdentifiers(k, option)
						if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] then
							if gProtect.config.valueRules[k][option].toggleableValue then
								s:setToggleable(k, option, gProtect.config.valueRules[k][option].toggleableValue)
							end

							if gProtect.config.valueRules[k][option].onlymodifytable then
								s:setOnlyModifyTable(true)
							end

							if gProtect.config.valueRules[k][option].undeleteableTable then
								s:setundeleteableTable(k, option, gProtect.config.valueRules[k][option].undeleteableTable)
							end

							if gProtect.config.valueRules[k][option].addRules then
								s:setAddRules(gProtect.config.valueRules[k][option].addRules)
							end

							if gProtect.config.valueRules[k][option].tableDeletable then
								s:setTableDeletable(true)
							end

							if gProtect.config.valueRules[k][option].customTable == "int" then
								s:setCustomValues(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "submit"), slib.getLang("gprotect", gProtect.config.SelectedLanguage, "input_number"), true)
							end
						end

						s.OnRemove = function()
							if s.modified then
								element.onValueChange(s.viewer.tbl)
							end
						end
					end

			end
			
			element.onValueChange = function(value)
				if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then slib.notify(gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "insufficient-permission")) return false end

				net.Start("gP:Networking")
				net.WriteUInt(3, 2)
				net.WriteString(k)
				net.WriteString(option)

				local statement = slib.getStatement(value)

				if statement == "bool" then
					net.WriteBool(value)
				elseif statement == "int" then
					net.WriteInt(value, 18)
				elseif statement == "color" or statement == "table" then
					value = util.Compress(util.TableToJSON(value))
					net.WriteUInt(#value, 32)
					net.WriteData(value, #value)
				end
				
				net.SendToServer()
			end

			local tooltip = slib.getLang("gprotect", gProtect.config.SelectedLanguage, k.."_"..option.."_tooltip")

			if tooltip then
				slib.createTooltip(tooltip, setting)
			end
		end
		
		if k ~= "general" then
			local search = vgui.Create("SSearchBar", tab:getFrame())
			search:addIcon()
			
			search.entry.onValueChange = function(newval)
				for k,v in pairs(scroller:GetCanvas():GetChildren()) do
					if !v.name then continue end
					if !string.find(string.lower(v.name), string.lower(newval)) then
						v:SetVisible(false)
					else
						v:SetVisible(true)
					end
		
					scroller:GetCanvas():InvalidateLayout(true)
				end
			end
		end
	end

	gprotect_menu:setActiveTab(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "general"))

	local generalScroller = gprotect_menu.tab[slib.getLang("gprotect", gProtect.config.SelectedLanguage, "general")]:GetChildren()[1]

	local player_list = vgui.Create("SListPanel", generalScroller)
	player_list:SetZPos(-100)
    player_list:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "player-list"))
    :addSearchbar()
	:SetZPos(-200)

	for k, v in ipairs(playerActions) do
		player_list:addButton(slib.getLang("gprotect", gProtect.config.SelectedLanguage, v.name), function(s)
			if !s.selected or !IsValid(s.selected) then return end
			v.option(s.selected)
		end)
	end

	player_list:addButton(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents"), function(s)
		if !s.selected or !IsValid(s.selected) then return end
		highlightedPlys[s.selected] = !highlightedPlys[s.selected]
		for k,v in pairs(ents.GetAll()) do
			if gProtect.GetOwner(v) == s.selected then
				if highlightedPlys[s.selected] then
					table.insert(highLighted, v)
				else
					table.RemoveByValue(highLighted, v)
				end
			end
		end
	end,
    function(s, bttn)
        if !s.selected or !IsValid(s.selected) then
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents"))    
        return end
		if highlightedPlys[s.selected] then 
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "unhighlight-ents")) 
        else 
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents")) 
        end
    end)

    for k,v in ipairs(player.GetAll()) do
        if v:IsBot() then continue end
        player_list:addEntry(v)
	end
	
	for k,v in pairs(generalActions) do
		local action = vgui.Create("SStatement", generalScroller)
		local _, element = action:SetZPos(v.zpos)
		:addStatement(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k), v.option)
	end
end

local ent

timer.Create("gP:updateLookAt", .05, 0, function()
	local ply = LocalPlayer()
	if !IsValid(ply) then return end

	local detected

	local trace = ply:GetEyeTraceNoCursor()
	local foundent = trace and trace.Entity

	if foundent and IsValid(foundent) and !foundent:IsPlayer() then
		detected = foundent
	elseif !gProtect.config.DisableOwnershipRayDetection then
		local raytrace = ents.FindAlongRay(trace.StartPos, trace.HitPos)
		if raytrace then
			for k, v in ipairs(raytrace) do
				if !IsValid(v) or v:IsWeapon() or v:IsPlayer() or gProtect.config.IgnoreEntitiesHUD[v] then continue end
				
				detected = v
			end
		end
	end

	ent = detected
end)

hook.Add("OnEntityCreated", "gP:CachePlayerNames", function(ent)
	if ent:IsPlayer() then
		gProtect.CachedPlayers[ent:SteamID()] = ent:Nick()
	end

	timer.Simple(.1, function()
		if highlightedPlys[gProtect.GetOwner(ent)] then
			table.insert(highLighted, ent)
		end
	end)
end )

local permissionColor = slib.getTheme("successcolor")

hook.Add("HUDPaint", "gP:EntInfo", function()
	if !gProtect.config.EnableOwnershipHUD or !ent or !IsValid(ent) then return end
	local ply = LocalPlayer()
	
	local info = gProtect.GetOwner(ent)
	if !info then
		local result = gProtect.GetOwnerString(ent)
		info = string.sub(result, 1, 5) == "STEAM" and "Disconnected" or "World"
	end

	if isstring(info) then
		local translation = slib.getLang("gprotect", gProtect.config.SelectedLanguage, string.lower(info))
		if !translation then return end
		info = translation
		local cachedPly = gProtect.CachedPlayers[gProtect.GetOwnerString(ent)]

		if cachedPly then
			info = info.." ("..cachedPly..")"
		end
	end

	local wantedcolor = gProtect.HandlePermissions(ply, ent) and slib.getTheme("successcolor", -60) or slib.getTheme("failcolor", -60)
	draw.SimpleTextOutlined( !isstring(info) and info:Nick() or info, slib.createFont("Roboto", 16), slib.getTheme("margin"), ScrH() * .5, slib.getTheme("textcolor"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, slib.lerpColor("gP:PermissionDisplay", wantedcolor))
end)

net.Receive("gP:Networking", function()
	local action = net.ReadUInt(2)

	if action == 0 then
		local data = net.ReadString()
		data = util.JSONToTable(data)
	
		local exclusive = net.ReadString()

		gProtect.TouchPermission[exclusive] = data
	elseif action == 1 then
		local len = net.ReadUInt(32)
		local data = net.ReadData(len)
		local module = net.ReadString()
		
		data = util.JSONToTable(util.Decompress(data))
		if module and module ~= "" then
			gProtect.LoadedModules[module] = gProtect.LoadedModules[module] or {}

			for k,v in pairs(data) do
				gProtect.LoadedModules[module][k] = v
			end
		else
			gProtect.LoadedModules = data
		end

		hook.Run("gP:ConfigUpdated", module)
	elseif action == 2 then
		local entIndex = net.ReadUInt(14)
		local owner = net.ReadString()

		owner = owner != "" and owner or nil

		local ent = Entity(entIndex)

		if IsValid(ent) then
			ent.gPOwner = owner
			gProtect.NetworkOwnershipQueue[entIndex] = nil
		else
			gProtect.NetworkOwnershipQueue[entIndex] = owner
		end	
	end
end)

hook.Add("OnEntityCreated", "gP:EntOwnershipQueue", function(ent)
	if !IsValid(ent) then return end

	local entIndex = ent:EntIndex()
	local owner = gProtect.NetworkOwnershipQueue[entIndex]

	if owner then
		ent.gPOwner = owner

		gProtect.NetworkOwnershipQueue[entIndex] = nil
	end
end)

local grn_col = Color(0, 200, 0)

hook.Add("PreDrawHalos", "gP:HighLightPlyEnts", function()
	halo.Add(highLighted, grn_col, 5, 5, 2)
end)

concommand.Add("gprotect_settings", function( ply, cmd, args )
	if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") and !gProtect.HasPermission(LocalPlayer(), "gProtect_DashboardAccess") then return end
	if !gProtect.InitialLoaded then gProtect.InitialLoaded = true RunConsoleCommand("say", "!gprotect") return end

    openSettingsMenu()
end)
--PATH addons/eprotect_1.4.22/lua/e_protect/sh_config.lua:
eProtect = eProtect or {}

eProtect.config = eProtect.config or {}

eProtect.config["language"] = "fr"

eProtect.config["prefix"] = ""

eProtect.config["storage_type"] = "sql_local"-- (sql_local or mysql)

eProtect.config["disablehttplogging"] = false -- If a DRM is ran after eProtect it could break if they check for HTTP modifications! If so make this true.

eProtect.config["ignoreDRM"] = false

eProtect.config["scURL"] = "https://stromic.dev/eprotect/img.php" -- This is the URL used to handle screenshots, can be self hosted here: https://github.com/Stromic/eprotect-web

eProtect.config["punishMaliciousIntent"] = true

eProtect.config["disabledModules"] = {
    ["identifier"] = false,
    ["detection_log"] = false,
    ["net_limiter"] = false,
    ["net_logger"] = false,
    ["exploit_patcher"] = false,
    ["exploit_finder"] = false,
    ["fake_exploits"] = false,
    ["data_snooper"] = false
}

eProtect.config["permission"] = {
    ["owner"] = true,
    ["superadmin"] = true
}
--PATH addons/eprotect_1.4.22/lua/e_protect/client/cl_eprotect.lua:
eProtect = eProtect or {}
eProtect.data = eProtect.data or {}

local margin = slib.getTheme("margin")
local maincolor_7, maincolor_10, hovercolor, linecol, textcolor_min50 = slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("hovercolor"), Color(0,0,0,160), slib.getTheme("textcolor", -50)
local arrow_ico = Material("slib/down-arrow.png", "smooth noclamp")

local function networkData(data, ...)
    local args = {...}

    net.Start("eP:Handeler")
    net.WriteBit(1)
    net.WriteUInt(1, 2)
    net.WriteUInt(#args, 3)
    
    for k,v in pairs(args) do
        net.WriteString(v)
    end

    local statement = slib.getStatement(data)

    if statement == "bool" then
        net.WriteUInt(1, 2)
        net.WriteBool(data)
    elseif statement == "int" then
        net.WriteUInt(2, 2)
        net.WriteInt(data, 32)
    elseif statement == "table" or statement == "color" then
        net.WriteUInt(3, 2)

        data = table.Copy(data)
        
        local converted_tbl = {}

        for k,v in pairs(data) do
            local isSID = util.SteamIDFrom64(k) != "STEAM_0:0:0"

            if isSID then
                converted_tbl["sid64_"..k] = v
            else
                converted_tbl[k] = v
            end
        end

        data = converted_tbl
        
        data = util.Compress(util.TableToJSON(data))
        net.WriteUInt(#data, 32)
        net.WriteData(data, #data)
    end

    net.SendToServer()
end

local convertedTbl

convertedTbl = function(tbl)
    local converted_tbl = {}

    for k, v in pairs(tbl) do
        if istable(v) then v = convertedTbl(v) end

        if string.sub(k, 1, 6) == "sid64_" then
            local sid64 = string.sub(k, 7, #k)

            if util.SteamIDFrom64(sid64) != "STEAM_0:0:0" then
                k = sid64
            end
        end

        converted_tbl[k] = v
    end

    return converted_tbl
end

local function openScreenshot(ply, id)
    if !IsValid(ply) then return end
    local nick = ply:Nick()

    http.Fetch(eProtect.config["scURL"].."?id="..id, function(result)
        local sc_frame = vgui.Create("SFrame")
        sc_frame:SetSize(slib.getScaledSize(960, "x"), slib.getScaledSize(540 + 25, "y"))
        :setTitle(slib.getLang("eprotect", eProtect.config["language"], "sc-preview")..nick)
        :MakePopup()
        :addCloseButton()
        :Center()
        :SetBG(true, true, nil, true)
        :setBlur(true)
    
        local display = vgui.Create("HTML", sc_frame.frame)
        display:Dock(FILL)
        display:SetHTML([[<img src="data:image/jpeg;base64,]] ..result.. [[" style="height:]]..(sc_frame.frame:GetTall())..[[px;width:]]..(sc_frame.frame:GetWide())..[[px;position:fixed;top:0px;left:0px">]])
    end)
end

local function sid64format(sid64)
    return slib.findName(sid64).." ("..sid64..")"
end

local function showAlts(ply, json)
    local font, sid_font = slib.createFont("Roboto", 16), slib.createFont("Roboto", 12)
    local alts = util.JSONToTable(json)

    local show_alts = vgui.Create("SFrame")
    show_alts:SetSize(slib.getScaledSize(470, "x"), slib.getScaledSize(360, "y"))
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "show-alts", ply))
    :MakePopup()
    :addCloseButton()
    :Center()
    :SetBG(true, true, nil, true)
    :setBlur(true)

    local alts_scroll = vgui.Create("SScrollPanel", show_alts.frame)
    alts_scroll:Dock(FILL)
    alts_scroll:DockMargin(0,margin,0,0)

    for k,v in ipairs(alts) do
        local alt = vgui.Create("EditablePanel", alts_scroll)
        alt:Dock(TOP)
        alt:DockMargin(margin,0,margin,margin)
        alt:SetTall(slib.getScaledSize(26, "y"))
        alt.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0,0,w,h)

            surface.SetFont(font)

            local name = slib.findName(v)
            local txt_w = surface.GetTextSize(name or "")
            
            draw.SimpleText(name, font, h + margin * 2, h * .5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText("[ "..v.." ]", sid_font, (h + margin * 3) + txt_w, h * .5, textcolor_min50, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        local avatar = vgui.Create("EditablePanel", alt)
        avatar:SetSize(alt:GetTall(), alt:GetTall())
        avatar.Paint = function(s,w,h)
            surface.SetDrawColor(color_white)
            surface.SetMaterial(slib.findAvatar(v, true))
            surface.DrawTexturedRect(0,0,w,h)
        end

        local open_profile_h = slib.getScaledSize(22, "y")
        local gap_top_bottom = (alt:GetTall() - open_profile_h) / 2

        local open_profile = vgui.Create("SButton", alt)
        open_profile:setTitle(slib.getLang("eprotect", eProtect.config["language"], "open-profile"))
        open_profile:SetTall(open_profile_h)
        open_profile:Dock(RIGHT)
        open_profile:DockMargin(0,gap_top_bottom,margin,gap_top_bottom)

        open_profile.DoClick = function()
            gui.OpenURL("http://steamcommunity.com/profiles/"..v)
        end
    end
end

local function fillCleanData(index, tbl)
    local files, directories = file.Find(index, "DATA")

    if files then
        for k,v in pairs(files) do
            tbl[v] = true
        end
    end
	
	if index == "*" then index = "" end
	local attribute = !index and "/" or ""

    if directories then
        for k,v in pairs(directories) do
            tbl[v] = tbl[v] or {}

           fillCleanData(index..attribute..v.."/*", tbl[v])
        end
    end
end

local createPaginator = function(parent)
    local font = slib.createFont("Roboto", 16)
    local paginator_tall = slib.getScaledSize(25, "y")
    local paginator = vgui.Create("EditablePanel", parent)
    paginator:Dock(BOTTOM)
    paginator:DockPadding(margin,margin,margin,margin)
    paginator:SetTall(paginator_tall)
    paginator.page = 1
    paginator.maxpage = 5

    paginator.Paint = function(s,w,h)
        surface.SetDrawColor(linecol)
        surface.DrawRect(0,0,w,1)

        draw.SimpleText(slib.getLang("eprotect", eProtect.config["language"], "page_of_page", s.page, s.maxpage), font, w * .5, h * .5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    surface.SetFont(font)
    local prev_w = select(1, surface.GetTextSize(slib.getLang("eprotect", eProtect.config["language"], "previous")))
    local next_w = select(1, surface.GetTextSize(slib.getLang("eprotect", eProtect.config["language"], "next")))

    local left = vgui.Create("SButton", paginator)
    :Dock(LEFT)
    :SetWide(paginator_tall + prev_w)

    local ico_size = paginator:GetTall() * .5

    left.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_7)
        surface.DrawRect(0,0,w,h)

        local hover = s:IsHovered()
        local curCol = slib.lerpColor(s, hover and hovercolor or color_white)

        s.move = s.move or 1
        s.move = math.Clamp(hover and s.move + .05 or s.move - .05, 0, 2)

        surface.SetDrawColor(curCol)
        surface.SetMaterial(arrow_ico)
        surface.DrawTexturedRectRotated(h * .5 - s.move, h * .5,ico_size ,ico_size, -90)

        draw.SimpleText(slib.getLang("eprotect", eProtect.config["language"], "previous"), font, w - margin, h * .5, curCol, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
    end

    left.DoClick = function()
        if paginator.page <= 1 then return end
        local nextpage = paginator.page - 1

        paginator.onPageChanged(nextpage)
    end

    local right = vgui.Create("SButton", paginator)
    :Dock(RIGHT)
    :SetWide(paginator_tall + next_w)

    right.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_7)
        surface.DrawRect(0,0,w,h)

        local hover = s:IsHovered()
        local curCol = slib.lerpColor(s, hover and hovercolor or color_white)

        s.move = s.move or 1
        s.move = math.Clamp(hover and s.move + .05 or s.move - .05, 0, 2)

        surface.SetDrawColor(curCol)
        surface.SetMaterial(arrow_ico)
        surface.DrawTexturedRectRotated(w - (h * .5 - s.move), h * .5,ico_size ,ico_size, 90)

        draw.SimpleText(slib.getLang("eprotect", eProtect.config["language"], "next"), font, margin, h * .5, curCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    right.DoClick = function()
        if paginator.page >= paginator.maxpage then return end
        local nextpage = paginator.page + 1

        paginator.onPageChanged(nextpage)
    end

    return paginator
end

local function showID(ply, id)
    id = util.JSONToTable(util.Base64Decode(id))
    if !id or !istable(id) then slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "ply-sent-invalid-data")) return end

    local id_list = vgui.Create("SFrame")
    id_list:SetSize(slib.getScaledSize(500, "x"),slib.getScaledSize(330, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "id-info")..ply:Nick(), slib.createFont("Roboto", 17))
    :setBlur(true)

    local id_details = vgui.Create("SListView", id_list.frame)
    id_details:Dock(FILL)
    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "date"))
    
    for i, z in pairs(id) do
        local sid64 = util.SteamIDTo64(i)

        local _, line = id_details:addLine(function() return sid64format(sid64) end, {os.date("%H:%M:%S - %d/%m/%Y", z), z})
        line.DoClick = function()
            gui.OpenURL("http://steamcommunity.com/profiles/"..sid64)
        end

        line:SetZPos(z)
    end
end

local function showCorrelation(ply, data)
    data = util.JSONToTable(util.Base64Decode(data))
    if !data or !istable(data) then return end

    local correlation_list = vgui.Create("SFrame")
    correlation_list:SetSize(slib.getScaledSize(450, "x"),slib.getScaledSize(330, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "ip-correlation")..ply:Nick(), slib.createFont("Roboto", 17))
    :setBlur(true)

    local correlation_details = vgui.Create("SListView", correlation_list.frame)
    correlation_details:Dock(FILL)
    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "ip"))

    for k, v in ipairs(data) do  
        if !v.sid64 then continue end
        
        local _, line = correlation_details:addLine(function() return sid64format(v.sid64) end, v.ip)
        line.DoClick = function()
            gui.OpenURL("http://steamcommunity.com/profiles/"..v.sid64)
        end

        line:SetZPos(z)
    end
end

local function showIPs(ply, data)
    data = util.JSONToTable(util.Base64Decode(data))
    if !data or !istable(data) then return end

    local ip_list = vgui.Create("SFrame")
    ip_list:SetSize(slib.getScaledSize(400, "x"),slib.getScaledSize(280, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "ip-info")..ply:Nick(), slib.createFont("Roboto", 17))
    :setBlur(true)

    local ip_details = vgui.Create("SListView", ip_list.frame)
    ip_details:Dock(FILL)
    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "country-code"), slib.getLang("eprotect", eProtect.config["language"], "ip"), slib.getLang("eprotect", eProtect.config["language"], "date"))

    for k, v in pairs(data) do
        local _, line = ip_details:addLine(v.country, v.ip, {os.date("%H:%M:%S - %d/%m/%Y", v.logged_time), v.logged_time})
        line.DoClick = function()
            gui.OpenURL("https://whatismyipaddress.com/ip/"..v.ip)
        end

        line:SetZPos(v.logged_time)
    end
end

local requestLogData = function(id, page, search)
    net.Start("eP:Handeler")
    net.WriteBit(1)
    net.WriteUInt(0, 2)
    net.WriteUInt(id, 1)
    net.WriteUInt(page, 15)
    net.WriteString(search)
    net.SendToServer()
end

local eprotect_menu

local function openMenu()
    eprotect_menu = vgui.Create("SFrame")
    eprotect_menu:SetSize(slib.getScaledSize(720, "x"),slib.getScaledSize(530, "y"))
    :setTitle("eProtect")
    :Center()
    :addCloseButton()
    :MakePopup()
    :addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-general"), "eprotect/tabs/general.png")

    if !eProtect.config["disabledModules"]["identifier"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-identifier"), "eprotect/tabs/identifier.png")
    end

    if !eProtect.config["disabledModules"]["detection_log"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog"), "eprotect/tabs/detectionlog.png")
    end

    if !eProtect.config["disabledModules"]["net_limiter"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-netlimiter"),"eprotect/tabs/netlimit.png")
    end

    if !eProtect.config["disabledModules"]["net_logger"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-netlogger"), "eprotect/tabs/netlog.png")
    end

    if !eProtect.config["disablehttplogging"] and ((!VC and !XEON and !mLib) or eProtect.config["ignoreDRM"]) then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger"), "eprotect/tabs/httplog.png")
    end

    if !eProtect.config["disabledModules"]["exploit_patcher"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-exploitpatcher"), "eprotect/tabs/exploitpatcher.png")
    end

    if !eProtect.config["disabledModules"]["exploit_finder"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-exploitfinder"), "eprotect/tabs/exploitfinder.png")
    end

    if !eProtect.config["disabledModules"]["fake_exploits"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-fakeexploits"), "eprotect/tabs/fakeexploit.png")
    end

    
    if !eProtect.config["disabledModules"]["data_snooper"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-datasnooper"), "eprotect/tabs/datasnooper.png")
    end

    eprotect_menu:setActiveTab(slib.getLang("eprotect", eProtect.config["language"], "tab-general"))

    local generalscroller = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-general")])
    generalscroller:Dock(FILL)
    generalscroller:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

    local player_list = vgui.Create("SListPanel", generalscroller)
    player_list:setTitle(slib.getLang("eprotect", eProtect.config["language"], "player-list"))
    :addSearchbar()
    :SetZPos(-200)
    :addButton(slib.getLang("eprotect", eProtect.config["language"], "disable-networking"), 
    function(s)
        if !s.selected or !IsValid(s.selected) then return end
        local sid = s.selected:SteamID()
        eProtect.data.disabled[sid] = !eProtect.data.disabled[sid]

        net.Start("eP:Handeler")
        net.WriteBit(1)
        net.WriteUInt(2, 2)
        net.WriteUInt(1, 3)
        net.WriteUInt(s.selected:EntIndex(), 14)
        net.WriteBool(eProtect.data.disabled[sid])
        net.SendToServer()
    end,
    function(s, bttn)
        if !s.selected or !IsValid(s.selected) then 
            bttn:setTitle(slib.getLang("eprotect", eProtect.config["language"], "disable-networking"))    
        return end

        if eProtect.data.disabled[s.selected:SteamID()] then 
            bttn:setTitle(slib.getLang("eprotect", eProtect.config["language"], "enable-networking")) 
        else 
            bttn:setTitle(slib.getLang("eprotect", eProtect.config["language"], "disable-networking")) 
        end
    end)
    :addButton(slib.getLang("eprotect", eProtect.config["language"], "capture"), function(s)
        if !s.selected or !IsValid(s.selected) then return end

        net.Start("eP:Handeler")
        net.WriteBit(1)
        net.WriteUInt(2, 2)
        net.WriteUInt(2, 3)
        net.WriteUInt(s.selected:EntIndex(), 14)
        net.WriteUInt(1, 2)
        net.SendToServer()
    end)
    :addButton(slib.getLang("eprotect", eProtect.config["language"], "check-ips"), function(s)
        if !s.selected or !IsValid(s.selected) then return end

        net.Start("eP:Handeler")
        net.WriteBit(1)
        net.WriteUInt(2, 2)
        net.WriteUInt(3, 3)
        net.WriteUInt(s.selected:EntIndex(), 14)
        net.WriteBit(0)
        net.SendToServer()
    end)

    for k,v in pairs(player.GetAll()) do
        if v:IsBot() then continue end
        player_list:addEntry(v)
    end

    if eProtect.data.general then
        for k,v in pairs(eProtect.data.general) do
            local type = slib.getStatement(eProtect.BaseConfig[k][1])
            local cur_type =  slib.getStatement(v)
            if type ~= cur_type then v = eProtect.BaseConfig[k][1] end
            local option = vgui.Create("SStatement", generalscroller)
            local _, element = option:SetZPos(eProtect.BaseConfig[k][2])
            :addStatement(slib.getLang("eprotect", eProtect.config["language"], k), v)

            if type == "int" then
                element:SetMin(eProtect.BaseConfig[k][3].min)
                element:SetMax(eProtect.BaseConfig[k][3].max)
            elseif type == "table" then
                element.onElementOpen = function(s)
                    s.title = slib.getLang("eprotect", eProtect.config["language"], k)
                    s:SetSize(slib.getScaledSize(850, "x"), slib.getScaledSize(350, "y"))
                    s:Center()
                    s:addEntry()
                    s:addSuggestions(isfunction(eProtect.BaseConfig[k][3]) and eProtect.BaseConfig[k][3]() or {})
                    s:addSearch(s.viewbox, s.viewer)
                    s:addSearch(s.suggestionbox, s.suggestions)
                    
                    s.OnRemove = function()
                        if s.modified then
                            element.onValueChange(s.viewer.tbl)
                        end
                    end
                end
            end

            element.onValueChange = function(value)
                networkData(value, "general", k)
            end

            slib.createTooltip(slib.getLang("eprotect", eProtect.config["language"], k.."-tooltip"), option)
        end
    end

    -- Identifier tab
    if !eProtect.config["disabledModules"]["identifier"] then
        local search_id = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-identifier")])
        search_id:DockMargin(0,0,0,0)
        :addIcon()

        search_id.bg = maincolor_10

        local identifier = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-identifier")])
        identifier:Dock(FILL)
        identifier:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

        search_id.entry.onValueChange = function(newval)
            for k,v in pairs(identifier:GetCanvas():GetChildren()) do
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                identifier:GetCanvas():InvalidateLayout(true)
            end
        end

        for k,v in pairs(player.GetAll()) do
            if v:IsBot() then continue end
            local ply = vgui.Create("SPlayerPanel", identifier)
            ply:setPlayer(v)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "check-ids"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(2, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.WriteUInt(2, 2)
                net.SendToServer()
            end)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "correlate-ip"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(3, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.WriteBit(1)
                net.SendToServer()
            end)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "family-share-check"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(4, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.SendToServer()
            end)
        end
    end


    -- Punishment log
    if !eProtect.config["disabledModules"]["detection_log"] then
        local search_punishments = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog")])
        search_punishments:DockMargin(0,0,0,2)
        :addIcon()

        search_punishments.bg = maincolor_10

        search_punishments.entry.onValueChange = function(newval)
            requestLogData(1, 1, newval)
        end

        local punishment_log = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog")])
        punishment_log:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "reason"), slib.getLang("eprotect", eProtect.config["language"], "info"), slib.getLang("eprotect", eProtect.config["language"], "type"))

        local typeToLang = {
            [1] = "kicked",
            [2] = "banned",
            [3] = "notified"
        }

        local detections_paginator = createPaginator(eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog")])
        detections_paginator.onPageChanged = function(page)
            local val = search_punishments.entry:GetValue()

            requestLogData(1, page, val == search_punishments.entry.placeholder and "" or val)
        end

        detections_paginator.onPageChanged(1)

        punishment_log.paginator = detections_paginator

        punishment_log.rebuild = function()
            for k,v in ipairs(punishment_log:GetCanvas():GetChildren()) do
                if !v.isLine then continue end
                v:Remove()
            end

            local tbl_detections = eProtect.data["requestedDetections"] and eProtect.data["requestedDetections"].result or {}
            
            detections_paginator.page, detections_paginator.maxpage = eProtect.data["requestedDetections"].page, eProtect.data["requestedDetections"].pageCount

            for k,v in ipairs(tbl_detections) do
                local _, line = punishment_log:addLine(v.name, function() return slib.getLang("eprotect", eProtect.config["language"], v.reason) end, v.info, function() return slib.getLang("eprotect", eProtect.config["language"], typeToLang[tonumber(v.type)]) end)
                line.isLine = true

                line.DoClick = function()
                    local dropdown = vgui.Create("SDropDown")
                    dropdown.buttonh = slib.getScaledSize(20, "y")
                    dropdown.buttonfont = slib.createFont("Roboto", 15)
                    dropdown.buttonbg = maincolor_10
                    dropdown.buttoncol = maincolor_min35
                    dropdown:addOption( slib.getLang("eprotect", eProtect.config["language"], "open-profile"))
                    :addOption( slib.getLang("eprotect", eProtect.config["language"], "copy_name"))
                    :addOption( slib.getLang("eprotect", eProtect.config["language"], "copy_steamid"))
                    :addOption( slib.getLang("eprotect", eProtect.config["language"], "copy_steamid64"))
    
                    if v.reason == "alt-detection" and v.additional_info and v.additional_info != "NULL" and v.additional_info != "" then
                        dropdown:addOption( slib.getLang("eprotect", eProtect.config["language"], "show_alts"))
                    end

                    dropdown.onValueChange = function(val)
                        if val ==  slib.getLang("eprotect", eProtect.config["language"], "open-profile") then
                            gui.OpenURL("https://steamcommunity.com/profiles/"..v.sid64)
                        elseif val ==  slib.getLang("eprotect", eProtect.config["language"], "copy_name") then
                            SetClipboardText(v.name)
                            slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                        elseif val ==  slib.getLang("eprotect", eProtect.config["language"], "copy_steamid") then
                            SetClipboardText(util.SteamIDFrom64(v.sid64))
                            slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                        elseif val ==  slib.getLang("eprotect", eProtect.config["language"], "copy_steamid64") then
                            SetClipboardText(v.sid64)
                            slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                        elseif val == slib.getLang("eprotect", eProtect.config["language"], "show_alts") then
                            showAlts(v.name, v.additional_info)
                        end
                    end
        
                    dropdown:popupAlone()
                end
            end

            punishment_log:GetCanvas():SetTall(punishment_log:GetTall())
        end

        eprotect_menu.punishment_log = punishment_log
    end

    -- Net limitation
    if eProtect.data.netLimitation and !eProtect.config["disabledModules"]["net_limiter"] then
        local search = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlimiter")])
        search:DockMargin(0,0,0,0)
        :addIcon()

        search.bg = maincolor_10


        local scroller = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlimiter")])
        scroller:Dock(FILL)
        scroller:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))


        search.entry.onValueChange = function(newval)
            for k,v in pairs(scroller:GetCanvas():GetChildren()) do
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                scroller:GetCanvas():InvalidateLayout(true)
            end
        end


        for k,v in pairs(eProtect.data.netLimitation) do
            if eProtect.data.fakeNets and eProtect.data.fakeNets[k] or !util.NetworkStringToID(k) then continue end

            local netstring = vgui.Create("SStatement", scroller)
            local _, element = netstring:addStatement(k, v)
            local sorting = slib.sortAlphabeticallyByKeyValues(eProtect.data.netLimitation, true)
            
            netstring:SetZPos(sorting[k])

            element:SetMin(-1)
            element:SetMax(999999)

            element.onValueChange = function(value)
                networkData(value, "netLimitation", k)
            end

            slib.createTooltip(slib.getLang("eprotect", eProtect.config["language"], "net-limit-desc"), netstring)
        end
    end

    -- Net logger tab
    if !eProtect.config["disabledModules"]["net_logger"] then
        local net_log_search = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlogger")])
        :DockMargin(0,0,0,2)
        :addIcon()

        net_log_search.bg = maincolor_10

        local net_logging = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlogger")])
        net_logging:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "called"), slib.getLang("eprotect", eProtect.config["language"], "len"))
        
        net_logging.Columns[1].maxTxtLen = 56
        
        net_log_search.entry.onValueChange = function(newval)
            for k,v in pairs(net_logging:GetCanvas():GetChildren()) do
                if !v.name or v:GetZPos() < 0 then continue end
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                net_logging:GetCanvas():InvalidateLayout(true)
            end
        end

        if eProtect.data.netLogging then
            for k,v in pairs(eProtect.data.netLogging) do
                if !v or !istable(v) then continue end
                local _, button = net_logging:addLine(k, v.called, v.len)
                button.DoClick = function()
                    if IsValid(button.Menu) then button.Menu:Remove() end

                    button.Menu = vgui.Create("SFrame")
                    button.Menu:SetSize(slib.getScaledSize(450, "x"),slib.getScaledSize(320, "y"))
                    :Center()
                    :MakePopup()
                    :addCloseButton()
                    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "net-info")..k, slib.createFont("Roboto", 17))
                    :setBlur(true)

                    local player_details = vgui.Create("SListView", button.Menu.frame)
                    player_details:Dock(FILL)
                    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "called"))
                    
                    for i, z in pairs(v.playercalls) do
                        local sid64 = util.SteamIDTo64(i)
                        local _, line = player_details:addLine(function() return sid64format(sid64) end, z)

                        line.DoClick = function()
                            gui.OpenURL("http://steamcommunity.com/profiles/"..sid64)
                        end
                    end
                end
            end
        end
    end

    -- Http logger tab
    if !eProtect.config["disablehttplogging"] and ((!VC and !XEON and !mLib) or eProtect.config["ignoreDRM"]) then
        local search_http = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger")])
        search_http:DockMargin(0,0,0,2)
        :addIcon()

        search_http.bg = maincolor_10

        local http_logging = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger")])
        http_logging:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "url"), slib.getLang("eprotect", eProtect.config["language"], "called"), slib.getLang("eprotect", eProtect.config["language"], "type"))

        http_logging.Columns[1].maxTxtLen = 64

        search_http.entry.onValueChange = function(newval)
            requestLogData(0, 1, newval)
        end

        local http_paginator = createPaginator(eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger")])
        http_paginator.onPageChanged = function(page)
            local val = search_http.entry:GetValue()

            requestLogData(0, page, val == search_http.entry.placeholder and "" or val)
        end

        http_logging.paginator = http_paginator

        http_logging.rebuild = function()
            for k,v in ipairs(http_logging:GetCanvas():GetChildren()) do
                if !v.isLine then continue end
                v:Remove()
            end

            local tbl_http = eProtect.data["requestedHTTP"] and eProtect.data["requestedHTTP"].result or {}
            
            http_paginator.page, http_paginator.maxpage = eProtect.data["requestedHTTP"].page, eProtect.data["requestedHTTP"].pageCount

            for k,v in ipairs(tbl_http) do
                local _, line = http_logging:addLine(v.link, v.called, v.type)
                line.isLine = true

                line.DoClick = function()
                    SetClipboardText(v.link)
                    slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                end
            end

            http_logging:GetCanvas():SetTall(http_logging:GetTall())
        end

        eprotect_menu.http_logger = http_logging

        requestLogData(0, 1, "")
    end
    
    -- Exploit patcher tab
    if !eProtect.config["disabledModules"]["exploit_patcher"] then
        local exploit_patcher = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-exploitpatcher")])
        exploit_patcher:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "secure"))

        if eProtect.data.exploitPatcher then
            for k,v in pairs(eProtect.data.exploitPatcher) do
                exploit_patcher:addLine(k, v)
            end
        end
    end

    -- Exploit finder tab
    if !eProtect.config["disabledModules"]["exploit_finder"] then
        local exploit_finder = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-exploitfinder")])
        exploit_finder:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "type"), slib.getLang("eprotect", eProtect.config["language"], "status"))

        if eProtect.data.badNets then
            for k,v in pairs(eProtect.data.badNets) do
                local validateNet = tobool(util.NetworkStringToID(k))

                if !validateNet or (validateNet and eProtect.data and eProtect.data.fakeNets[k] and eProtect.data.fakeNets[k].enabled) then continue end

                local fixed = slib.getLang("eprotect", eProtect.config["language"], "unknown")

                if eProtect.data and eProtect.data.exploitPatcher and eProtect.data.exploitPatcher[k] then
                    fixed = slib.getLang("eprotect", eProtect.config["language"], "secured")
                end

                exploit_finder:addLine(k, v.type, fixed)
            end
        end
    end

    -- Fake exploits tab
    if !eProtect.config["disabledModules"]["fake_exploits"] then
        local fake_nets = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-fakeexploits")])
        fake_nets:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "type"), slib.getLang("eprotect", eProtect.config["language"], "activated"))

        if eProtect.data.fakeNets then
            for k,v in pairs(eProtect.data.fakeNets) do
                fake_nets:addLine(k, v.type, v.enabled)
            end
        end
    end


    -- Data snooper tab
    if !eProtect.config["disabledModules"]["data_snooper"] then
        local search_ds = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-datasnooper")])
        search_ds:DockMargin(0,0,0,0)
        :addIcon()

        search_ds.bg = maincolor_10

        local data_snooper = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-datasnooper")])
        data_snooper:Dock(FILL)
        data_snooper:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

        search_ds.entry.onValueChange = function(newval)
            for k,v in pairs(identifier:GetCanvas():GetChildren()) do
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                identifier:GetCanvas():InvalidateLayout(true)
            end
        end

        for k,v in pairs(player.GetAll()) do
            if v:IsBot() then continue end
            local ply = vgui.Create("SPlayerPanel", data_snooper)
            ply:setPlayer(v)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "fetch-data"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(2, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.WriteUInt(3, 2)
                net.SendToServer()
            end)
        end
    end
end

concommand.Add("eprotect_menu", function() RunConsoleCommand("say", "!eprotect") end)

net.Receive("eP:Handeler", function()
    local action = net.ReadUInt(3)
    if action == 1 then
        local chunk = net.ReadUInt(32)
        local json = util.Decompress(net.ReadData(chunk))
        if !json then return end
        local data = util.JSONToTable(json)
        local specific = net.ReadString()

        if !specific then
            eProtect.data = convertedTbl(data)
        else
            eProtect.data[specific] = convertedTbl(data)
        end
    elseif action == 2 then
        openMenu()
    elseif action == 3 then
        local subaction = net.ReadUInt(2)
        local target = net.ReadUInt(14)
        target = Entity(target)
        local open = net.ReadBool()
        local data

        if open then
            if subaction == 3 then
                local chunk = net.ReadUInt(32)
                data = net.ReadData(chunk)
                data = util.Decompress(data)
            else
                data = net.ReadString()
            end
        end

        if data == "Failed" or data == "" then slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "ply-failed-retrieving-data", target:Nick())) return end

        if subaction == 1 then
            if open then
                openScreenshot(target, data)
            else
                eProtect.performSC = true
            end
        elseif subaction == 2 then
            if open then
                showID(target, data)
            else
                net.Start("eP:Handeler")
                net.WriteBit(0)
                net.WriteUInt(1, 2)
                net.WriteUInt(2, 2)
                net.WriteString(file.Read("eid.txt", "DATA") or "")
                net.SendToServer()
            end
        elseif subaction == 3 then
            if open then                
                data = util.JSONToTable(data)
                
                local display_data = vgui.Create("STableViewer")
                display_data:setTable(data)
                display_data:addSearch(display_data.viewbox, display_data.viewer)
                display_data.viewOnly = true
            else
                local requestedData = {}

                fillCleanData("*", requestedData)

                requestedData = util.TableToJSON(requestedData)
                requestedData = util.Compress(requestedData)

                if string.len(requestedData) >= 65533 then requestedData = util.Compress("Failed") end

                local chunk = #requestedData

                net.Start("eP:Handeler")
                net.WriteBit(0)
                net.WriteUInt(1, 2)
                net.WriteUInt(3, 2)
                net.WriteUInt(chunk, 32)
                net.WriteData(requestedData, chunk)
                net.SendToServer()
            end
        end
    elseif action == 4 then
        local target = net.ReadUInt(14)
        local ids = net.ReadString()
        local bit = net.ReadBit()

        if tobool(bit) then
            showCorrelation(Entity(target), ids)
        else
            showIPs(Entity(target), ids)
        end
    elseif action == 5 then
        local id = net.ReadUInt(1)
        local chunk = net.ReadUInt(32)
        local data = net.ReadData(chunk)

        data = util.Decompress(data)

        if !data then return end

        data = util.JSONToTable(data)

        if id == 0 then
            eProtect.data["requestedHTTP"] = data

            if IsValid(eprotect_menu) and IsValid(eprotect_menu.http_logger) then
                eprotect_menu.http_logger.rebuild()
            end
        elseif id == 1 then
            eProtect.data["requestedDetections"] = data

            if IsValid(eprotect_menu) and IsValid(eprotect_menu.punishment_log) then
                eprotect_menu.punishment_log.rebuild()
            end
        end
    end
end)
--PATH addons/sl_utils/lua/textscreens_config.lua:
textscreenFonts = {}

local function addFont(font, t)
	if CLIENT then
		t.size = 100
		surface.CreateFont(font, t)
		t.size = 50
		surface.CreateFont(font .. "_MENU", t)
	end

	table.insert(textscreenFonts, font)
end

--[[
---------------------------------------------------------------------------
Custom fonts - requires server restart to take affect -- "Screens_" will be removed from the font name in spawnmenu
---------------------------------------------------------------------------
--]]

-- Default textscreens font
addFont("Coolvetica outlined", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Coolvetica", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- Trebuchet
addFont("Screens_Trebuchet outlined", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Trebuchet", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = false
})

-- Arial
addFont("Screens_Arial outlined", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = true
})

addFont("Screens_Arial", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = false
})

-- Roboto Bk
addFont("Screens_Roboto outlined", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Roboto", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = false
})

-- Helvetica
addFont("Screens_Helvetica outlined", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Helvetica", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- akbar
addFont("Screens_Akbar outlined", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Akbar", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = false
})

-- csd
addFont("Screens_csd outlined", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_csd", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = false
})

if CLIENT then

	local function addFonts(path)
		local files, folders = file.Find("resource/fonts/" .. path .. "*", "MOD")

		for k, v in ipairs(files) do
			if string.GetExtensionFromFilename(v) == "ttf" then
				local font = string.StripExtension(v)
				if table.HasValue(textscreenFonts, "Screens_" .. font) then continue end
print("-- "  .. font .. "\n" .. [[
addFont("Screens_ ]] .. font .. [[", {
	font = font,
	weight = 400,
	antialias = false,
	outline = true
})
				]])
			end
		end

		for k, v in ipairs(folders) do
			addFonts(path .. v .. "/")
		end
	end

	concommand.Add("get_fonts", function(ply)
		addFonts("")
	end)

end

--PATH addons/simple_thirdperson/lua/autorun/thirdperson.lua:
/*                                                                                                             
 ,---. ,--.              ,--.          ,--------,--.    ,--.        ,--,------.                                 
'   .-'`--,--,--,--.,---.|  |,---.     '--.  .--|  ,---.`--,--.--.,-|  |  .--. ',---.,--.--.,---. ,---.,--,--,  
`.  `-.,--|        | .-. |  | .-. :       |  |  |  .-.  ,--|  .--' .-. |  '--' | .-. |  .--(  .-'| .-. |      \ 
.-'    |  |  |  |  | '-' |  \   --.       |  |  |  | |  |  |  |  \ `-' |  | --'\   --|  |  .-'  `' '-' |  ||  | 
`-----'`--`--`--`--|  |-'`--'`----'       `--'  `--' `--`--`--'   `---'`--'     `----`--'  `----' `---'`--''--'
By FailCake :D (edunad)
A simple Thirdperson Addon. Press C (context menu) then Thirdperson 
*/

// SHARED
CreateConVar("simple_thirdperson_maxdistance", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxpitch", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max pitch the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max right the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxyaw", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max yaw the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min up the player can go (0 = disabled)")

CreateConVar("simple_thirdperson_mindistance", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minpitch", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min pitch the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min right the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minyaw", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min yaw the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min up the player can go (0 = disabled)")

CreateConVar("simple_thirdperson_shoulder_maxdist", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max shoulder distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_mindist", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min shoulder distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_maxup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max shoulder up the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_minup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min shoulder up the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_maxright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max shoulder right the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_minright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min shoulder right the player can go (0 = disabled)")

CreateConVar("simple_thirdperson_forcecollide", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Forces the player to use collide or not (0 = disabled,1 = on,2 = off)")
CreateConVar("simple_thirdperson_forceshoulder", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE} , "Forces the player to use shoulder view or not (0 = disabled,1 = on,2 = off)")
CreateConVar("simple_thirdperson_forcesmooth", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Forces the player to use smooth view or not (0 = disabled,1 = on,2 = off)")

if CLIENT then	

	CreateClientConVar( "simple_thirdperson_enabled", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_smooth", "1", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_mult_x", "0.3", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_mult_y", "0.3", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_mult_z", "0.3", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_delay", "10", true, false )
	
	CreateClientConVar( "simple_thirdperson_collision", "1", true, false )
	CreateClientConVar( "simple_thirdperson_cam_distance", "100", true, false )
	CreateClientConVar( "simple_thirdperson_cam_right", "0", true, false )
	CreateClientConVar( "simple_thirdperson_cam_up", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_cam_pitch", "0", true, false )
	CreateClientConVar( "simple_thirdperson_cam_yaw", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_shoulderview_dist", "50", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview_up", "0", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview_right", "40", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview", "0", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview_bump", "1", true, false )
	
	CreateClientConVar( "simple_thirdperson_fov_smooth", "1", true, false )
	CreateClientConVar( "simple_thirdperson_fov_smooth_mult", "0.3", true, false )
	
	CreateClientConVar( "simple_thirdperson_hide_crosshair", "0", true, false )
	CreateClientConVar( "simple_thirdperson_enable_custom_crosshair", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_custom_crosshair_r", "255", true, false )
	CreateClientConVar( "simple_thirdperson_custom_crosshair_g", "230", true, false )
	CreateClientConVar( "simple_thirdperson_custom_crosshair_b", "0", true, false )
	CreateClientConVar( "simple_thirdperson_custom_crosshair_a", "240", true, false )
	
	local Editor = {}

	Editor.DelayPos = nil
	Editor.ViewPos = nil
	
	Editor.ShoulderToggle = GetConVar( "simple_thirdperson_shoulderview" ):GetBool() or false
	Editor.EnableToggle = GetConVar( "simple_thirdperson_enabled" ):GetBool() or false
	Editor.CollisionToggle = GetConVar( "simple_thirdperson_collision" ):GetBool() or false
	Editor.FOVToggle = GetConVar( "simple_thirdperson_fov_smooth" ):GetBool() or false
	Editor.SmoothToggle = GetConVar( "simple_thirdperson_smooth" ):GetBool() or true
	Editor.ShoulderBumpToggle = GetConVar( "simple_thirdperson_shoulderview_bump" ):GetBool() or false
	
	Editor.CustomCrossToggle = GetConVar( "simple_thirdperson_enable_custom_crosshair" ):GetBool() or false
	Editor.CrossToggle = GetConVar( "simple_thirdperson_hide_crosshair" ):GetBool() or false
	
	list.Set(
		"DesktopWindows", 
		"ThirdPerson",
		{
			title = "Simple ThirdPerson",
			icon = "icon32/zoom_extend.png",
			width = 300,
			height = 170,
			onewindow = true,
			init = function(icn, pnl)
				BuildMenu(pnl)
			end
		}
	)
	
	function BuildMenu(PNL)
	
		if Editor.PANEL != nil then
			Editor.PANEL:Remove()
		end
		
		if PNL == nil then	
			PNL = vgui.Create( "DFrame" )
			PNL:SetSize( 300, 170 )
			PNL:SetTitle( "Simple ThirdPerson" )
			PNL:SetVisible( true )
			PNL:SetDraggable( true )
			PNL:ShowCloseButton( true )
			PNL:MakePopup()
		end

		Editor.PANEL = PNL
		Editor.PANEL:SetPos(ScrW() - 310,40)
		
		Editor.PANEL.Sheet = Editor.PANEL:Add( "DPropertySheet" )
		Editor.PANEL.Sheet:Dock(LEFT)
		Editor.PANEL.Sheet:SetSize( 290, 0 )
		Editor.PANEL.Sheet:SetPos(5,0)
		
		Editor.PANEL.Settings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Settings", Editor.PANEL.Settings, "icon16/cog_edit.png" )
		
		Editor.PANEL.CameraSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Camera", Editor.PANEL.CameraSettings, "icon16/camera_edit.png" )
		
		Editor.PANEL.SmoothSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Smooth", Editor.PANEL.SmoothSettings, "icon16/chart_line.png" )
		
		Editor.PANEL.ShoulderSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Shoulder", Editor.PANEL.ShoulderSettings, "icon16/camera_go.png" )
		
		Editor.PANEL.CrossSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Crosshair", Editor.PANEL.CrossSettings, "icon16/collision_on.png" )
		
		Editor.PANEL.CreditsSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Credits :D", Editor.PANEL.CreditsSettings, "icon16/star.png" )
		
		Editor.PANEL.EnableThrd = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.EnableThrd:SizeToContents()
		
		if Editor.EnableToggle then
			Editor.PANEL.EnableThrd:SetText("Disable ThirdPerson")
			Editor.PANEL.EnableThrd:SetTextColor(Color(150,0,0))
		else
			Editor.PANEL.EnableThrd:SetText("Enable ThirdPerson")
			Editor.PANEL.EnableThrd:SetTextColor(Color(0,150,0))
		end
		
		Editor.PANEL.EnableThrd:SetPos(10,6)
		Editor.PANEL.EnableThrd:SetSize(250,20)
		Editor.PANEL.EnableThrd.DoClick = function()

			Editor.EnableToggle = !Editor.EnableToggle
			RunConsoleCommand("simple_thirdperson_enabled",BoolToInt(Editor.EnableToggle))
			
			if Editor.EnableToggle then
				Editor.PANEL.EnableThrd:SetText("Disable ThirdPerson")
				Editor.PANEL.EnableThrd:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.EnableThrd:SetText("Enable ThirdPerson")
				Editor.PANEL.EnableThrd:SetTextColor(Color(0,150,0))
			end
					
		end

		Editor.PANEL.Lbl_SPLIT = Editor.PANEL.Settings:Add("DLabel")
		Editor.PANEL.Lbl_SPLIT:SetPos(20,29)
		Editor.PANEL.Lbl_SPLIT:SetText("------------------------ RESETS ------------------------")
		Editor.PANEL.Lbl_SPLIT:SizeToContents() 
	
		Editor.PANEL.ResetCam = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetCam:SizeToContents()
		Editor.PANEL.ResetCam:SetText("Camera Reset")
		Editor.PANEL.ResetCam:SetPos(10,46)
		Editor.PANEL.ResetCam:SetSize(120,20)
		Editor.PANEL.ResetCam.DoClick = function()
			RunConsoleCommand("simple_thirdperson_cam_distance",100)
			RunConsoleCommand("simple_thirdperson_cam_right",0)
			RunConsoleCommand("simple_thirdperson_cam_up",0)
			RunConsoleCommand("simple_thirdperson_cam_yaw",0)
			RunConsoleCommand("simple_thirdperson_cam_pitch",0)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] Camera Reset !")
			Editor.PANEL:Close()
		end
		
		Editor.PANEL.ResetShoulder = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetShoulder:SizeToContents()
		Editor.PANEL.ResetShoulder:SetText("ShoulderView Reset")
		Editor.PANEL.ResetShoulder:SetPos(140,46)
		Editor.PANEL.ResetShoulder:SetSize(120,20)
		Editor.PANEL.ResetShoulder.DoClick = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_dist",50)
			RunConsoleCommand("simple_thirdperson_shoulderview_up",0)
			RunConsoleCommand("simple_thirdperson_shoulderview_right",40)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] ShoulderView Reset !")
			Editor.PANEL:Close()
		end
		
		Editor.PANEL.ResetSmooth = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetSmooth:SizeToContents()
		Editor.PANEL.ResetSmooth:SetText("Smooth Settings Reset")
		Editor.PANEL.ResetSmooth:SetPos(10,76)
		Editor.PANEL.ResetSmooth:SetSize(130,20)
		Editor.PANEL.ResetSmooth.DoClick = function()
			RunConsoleCommand("simple_thirdperson_smooth",1)
			RunConsoleCommand("simple_thirdperson_smooth_mult_x",0.3)
			RunConsoleCommand("simple_thirdperson_smooth_mult_y",0.3)
			RunConsoleCommand("simple_thirdperson_smooth_mult_z",0.3)
			RunConsoleCommand("simple_thirdperson_smooth_delay",10)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] Smooth Reset !")
			Editor.PANEL:Close()
		end
		
		Editor.PANEL.ResetFOV = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetFOV:SizeToContents()
		Editor.PANEL.ResetFOV:SetText("FOV Settings Reset")
		Editor.PANEL.ResetFOV:SetPos(145,76)
		Editor.PANEL.ResetFOV:SetSize(115,20)
		Editor.PANEL.ResetFOV.DoClick = function()
			RunConsoleCommand("simple_thirdperson_fov_smooth",1)
			RunConsoleCommand("simple_thirdperson_fov_smooth_mult",0.3)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] FOV Reset !")
			Editor.PANEL:Close()
		end
		
		
		// ---------------- PANEL CAMERA ---------------- //
		
		Editor.PANEL.CollisionButton = Editor.PANEL.CameraSettings:Add( "DButton" )
		Editor.PANEL.CollisionButton:SizeToContents()
		
			if Editor.CollisionToggle then
				Editor.PANEL.CollisionButton:SetText("Disable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CollisionButton:SetText("Enable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(0,150,0))
			end
			
		Editor.PANEL.CollisionButton:SetText("Toggle Camera Collision")
		Editor.PANEL.CollisionButton:SetPos(10,6)
		Editor.PANEL.CollisionButton:SetSize(250,20)
		Editor.PANEL.CollisionButton.DoClick = function()
		
			Editor.CollisionToggle = !Editor.CollisionToggle
			RunConsoleCommand("simple_thirdperson_collision",BoolToInt(Editor.CollisionToggle))	
			
			if Editor.CollisionToggle then
				Editor.PANEL.CollisionButton:SetText("Disable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CollisionButton:SetText("Enable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(0,150,0))
			end
								
		end
		
		Editor.PANEL.CamDistanceTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamDistanceTxt:SetPos(10,35)
		Editor.PANEL.CamDistanceTxt:SetText("Camera Distance : ")
		Editor.PANEL.CamDistanceTxt:SizeToContents() 
		
		Editor.PANEL.CamDistanceLb = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamDistanceLb:SetPos(110,30)
		Editor.PANEL.CamDistanceLb:SetValue(GetConVar( "simple_thirdperson_cam_distance" ):GetFloat())
		Editor.PANEL.CamDistanceLb:SetSize(40,20)
		Editor.PANEL.CamDistanceLb:SetNumeric(true)	
		Editor.PANEL.CamDistanceLb:SetUpdateOnType( true )
		
		Editor.PANEL.CamDistanceLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_distance",Editor.PANEL.CamDistanceLb:GetValue())
			Editor.PANEL.CamDistance_PRF:SetValue(Editor.PANEL.CamDistanceLb:GetValue())
		end
		
		Editor.PANEL.CamDistance_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamDistance_PRF:SetPos(155,32)
		Editor.PANEL.CamDistance_PRF:SetValue(GetConVar( "simple_thirdperson_cam_distance" ):GetFloat())
		Editor.PANEL.CamDistance_PRF:SetMin( -100 )
		Editor.PANEL.CamDistance_PRF:SetMax( 1000 )
		Editor.PANEL.CamDistance_PRF.OnValueChanged  = function()
			Editor.PANEL.CamDistanceLb:SetValue(Editor.PANEL.CamDistance_PRF:GetTextValue())
			RunConsoleCommand("simple_thirdperson_cam_distance",Editor.PANEL.CamDistance_PRF:GetTextValue())
		end
		
		
		Editor.PANEL.CamYawTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamYawTxt:SetPos(150,62)
		Editor.PANEL.CamYawTxt:SetText("| Yaw : ")
		Editor.PANEL.CamYawTxt:SizeToContents() 
		
		Editor.PANEL.CamYawLb = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamYawLb:SetPos(190,57)
		Editor.PANEL.CamYawLb:SetValue(GetConVar( "simple_thirdperson_cam_yaw" ):GetFloat())
		Editor.PANEL.CamYawLb:SetSize(40,20)
		Editor.PANEL.CamYawLb:SetNumeric(true)
		Editor.PANEL.CamYawLb:SetUpdateOnType( true )
		Editor.PANEL.CamYawLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_yaw",Editor.PANEL.CamYawLb:GetValue())
			Editor.PANEL.CamYawLb_PRF:SetValue(Editor.PANEL.CamYawLb:GetValue())
		end
		
		Editor.PANEL.CamYawLb_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamYawLb_PRF:SetPos(235,59)
		Editor.PANEL.CamYawLb_PRF:SetValue(GetConVar( "simple_thirdperson_cam_yaw" ):GetFloat())
		Editor.PANEL.CamYawLb_PRF:SetMin( 0 )
		Editor.PANEL.CamYawLb_PRF:SetMax( 360 )
		Editor.PANEL.CamYawLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_yaw",Editor.PANEL.CamYawLb_PRF:GetTextValue())
			Editor.PANEL.CamYawLb:SetValue(Editor.PANEL.CamYawLb_PRF:GetTextValue())	
		end
		

		Editor.PANEL.CamPitchTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamPitchTxt:SetPos(160,85)
		Editor.PANEL.CamPitchTxt:SetText("| Pitch : ")
		Editor.PANEL.CamPitchTxt:SizeToContents() 
		
		Editor.PANEL.CamPitchLb = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamPitchLb:SetPos(200,80)
		Editor.PANEL.CamPitchLb:SetValue(GetConVar( "simple_thirdperson_cam_pitch" ):GetFloat())
		Editor.PANEL.CamPitchLb:SetSize(40,20)
		Editor.PANEL.CamPitchLb:SetNumeric(true)
		Editor.PANEL.CamPitchLb:SetUpdateOnType( true )
		Editor.PANEL.CamPitchLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_pitch",Editor.PANEL.CamPitchLb:GetValue())
			Editor.PANEL.CamPitchLb_PRF:SetValue(Editor.PANEL.CamPitchLb:GetValue())
		end
		
		Editor.PANEL.CamPitchLb_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamPitchLb_PRF:SetPos(245,82)
		Editor.PANEL.CamPitchLb_PRF:SetValue(GetConVar( "simple_thirdperson_cam_pitch" ):GetFloat())
		Editor.PANEL.CamPitchLb_PRF:SetMin( 0 )
		Editor.PANEL.CamPitchLb_PRF:SetMax( 360 )
		Editor.PANEL.CamPitchLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_pitch",Editor.PANEL.CamPitchLb_PRF:GetTextValue())
			Editor.PANEL.CamPitchLb:SetValue(Editor.PANEL.CamPitchLb_PRF:GetTextValue())
		end
		
		Editor.PANEL.CamUpTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamUpTxt:SetPos(10,62)
		Editor.PANEL.CamUpTxt:SetText("Camera Up : ")
		Editor.PANEL.CamUpTxt:SizeToContents() 
		
		Editor.PANEL.CamUpTxtLB = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamUpTxtLB:SetPos(80,57)
		Editor.PANEL.CamUpTxtLB:SetValue(GetConVar( "simple_thirdperson_cam_up" ):GetFloat())
		Editor.PANEL.CamUpTxtLB:SetSize(40,20)
		Editor.PANEL.CamUpTxtLB:SetNumeric(true)
		Editor.PANEL.CamUpTxtLB:SetUpdateOnType( true )
		Editor.PANEL.CamUpTxtLB.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_up",Editor.PANEL.CamUpTxtLB:GetValue())
			Editor.PANEL.CamUpTxtLB_PRF:SetValue(Editor.PANEL.CamUpTxtLB:GetValue())
		end
		
		Editor.PANEL.CamUpTxtLB_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamUpTxtLB_PRF:SetPos(125,59)
		Editor.PANEL.CamUpTxtLB_PRF:SetValue(GetConVar( "simple_thirdperson_cam_up" ):GetFloat())
		Editor.PANEL.CamUpTxtLB_PRF:SetMin( -1000 )
		Editor.PANEL.CamUpTxtLB_PRF:SetMax( 1000 )
		Editor.PANEL.CamUpTxtLB_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_up",Editor.PANEL.CamUpTxtLB_PRF:GetTextValue())
			Editor.PANEL.CamUpTxtLB:SetValue(Editor.PANEL.CamUpTxtLB_PRF:GetTextValue())	
		end
		
		Editor.PANEL.CamLeftTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamLeftTxt:SetPos(10,85)
		Editor.PANEL.CamLeftTxt:SetText("Camera Right : ")
		Editor.PANEL.CamLeftTxt:SizeToContents() 
		
		Editor.PANEL.CamLeftTxtLB = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamLeftTxtLB:SetPos(90,80)
		Editor.PANEL.CamLeftTxtLB:SetValue(GetConVar( "simple_thirdperson_cam_right" ):GetFloat())
		Editor.PANEL.CamLeftTxtLB:SetSize(40,20)
		Editor.PANEL.CamLeftTxtLB:SetNumeric(true)
		Editor.PANEL.CamLeftTxtLB:SetUpdateOnType( true )
		Editor.PANEL.CamLeftTxtLB.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_right",Editor.PANEL.CamLeftTxtLB:GetValue())
			Editor.PANEL.CamLeftTxtLB_PRF:SetValue(Editor.PANEL.CamLeftTxtLB:GetValue())
		end
		
		Editor.PANEL.CamLeftTxtLB_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")	
		Editor.PANEL.CamLeftTxtLB_PRF:SetPos(135,82)
		Editor.PANEL.CamLeftTxtLB_PRF:SetValue(GetConVar( "simple_thirdperson_cam_right" ):GetFloat())
		Editor.PANEL.CamLeftTxtLB_PRF:SetMin( -1000 )
		Editor.PANEL.CamLeftTxtLB_PRF:SetMax( 1000 )
		Editor.PANEL.CamLeftTxtLB_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_right",Editor.PANEL.CamLeftTxtLB_PRF:GetTextValue())
			Editor.PANEL.CamLeftTxtLB:SetValue(Editor.PANEL.CamLeftTxtLB_PRF:GetTextValue())	
		end
		
		// ---------------- PANEL SMOOTH ---------------- //
		
		Editor.PANEL.SmoothButton = Editor.PANEL.SmoothSettings:Add( "DButton" )
		Editor.PANEL.SmoothButton:SizeToContents()
		
		if Editor.SmoothToggle then
			Editor.PANEL.SmoothButton:SetText("Disable Camera Smoothing")
			Editor.PANEL.SmoothButton:SetTextColor(Color(150,0,0))
		else
			Editor.PANEL.SmoothButton:SetText("Enable Camera Smoothing")
			Editor.PANEL.SmoothButton:SetTextColor(Color(0,150,0))
		end

		Editor.PANEL.SmoothButton:SetPos(10,6)
		Editor.PANEL.SmoothButton:SetSize(250,20)
		Editor.PANEL.SmoothButton.DoClick = function()
			Editor.SmoothToggle = !Editor.SmoothToggle
			RunConsoleCommand("simple_thirdperson_smooth",BoolToInt(Editor.SmoothToggle))	

			if Editor.SmoothToggle then
				Editor.PANEL.SmoothButton:SetText("Disable Camera Smoothing")
				Editor.PANEL.SmoothButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.SmoothButton:SetText("Enable Camera Smoothing")
				Editor.PANEL.SmoothButton:SetTextColor(Color(0,150,0))
			end					
		end
		
		Editor.PANEL.SmoothFOVButton = Editor.PANEL.SmoothSettings:Add( "DButton" )
		Editor.PANEL.SmoothFOVButton:SizeToContents()
		
		if Editor.FOVToggle then
			Editor.PANEL.SmoothFOVButton:SetText("Disable FOV Smoothing")
			Editor.PANEL.SmoothFOVButton:SetTextColor(Color(150,0,0))
		else
			Editor.PANEL.SmoothFOVButton:SetText("Enable FOV Smoothing")
			Editor.PANEL.SmoothFOVButton:SetTextColor(Color(0,150,0))
		end
		
		Editor.PANEL.SmoothFOVButton:SetPos(10,30)
		Editor.PANEL.SmoothFOVButton:SetSize(250,20)
		Editor.PANEL.SmoothFOVButton.DoClick = function()
			Editor.FOVToggle = !Editor.FOVToggle
			RunConsoleCommand("simple_thirdperson_fov_smooth",BoolToInt(Editor.FOVToggle))

			if Editor.FOVToggle then
				Editor.PANEL.SmoothFOVButton:SetText("Disable FOV Smoothing")
				Editor.PANEL.SmoothFOVButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.SmoothFOVButton:SetText("Enable FOV Smoothing")
				Editor.PANEL.SmoothFOVButton:SetTextColor(Color(0,150,0))
			end					
		end
		
		Editor.PANEL.CamSmoothDeTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothDeTxt:SetPos(10,60)
		Editor.PANEL.CamSmoothDeTxt:SetText("Smooth Delay : ")
		Editor.PANEL.CamSmoothDeTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoDelayLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoDelayLb:SetPos(90,55)
		Editor.PANEL.CamSmoDelayLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_delay" ):GetFloat(),2))
		Editor.PANEL.CamSmoDelayLb:SetSize(40,20)
		Editor.PANEL.CamSmoDelayLb:SetNumeric(true)
		Editor.PANEL.CamSmoDelayLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoDelayLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_delay",Editor.PANEL.CamSmoDelayLb:GetValue())
			Editor.PANEL.CamSmoDelayLb_PRF:SetValue(Editor.PANEL.CamSmoDelayLb:GetValue())
		end
		
		Editor.PANEL.CamSmoDelayLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoDelayLb_PRF:SetPos(135,57)
		Editor.PANEL.CamSmoDelayLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_delay" ):GetFloat(),2))
		Editor.PANEL.CamSmoDelayLb_PRF:SetMin( 1 )
		Editor.PANEL.CamSmoDelayLb_PRF:SetMax( 100 )
		Editor.PANEL.CamSmoDelayLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_delay",Editor.PANEL.CamSmoDelayLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoDelayLb:SetValue(Editor.PANEL.CamSmoDelayLb_PRF:GetTextValue())	
		end
		
		
		Editor.PANEL.CamSmoothMultXTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothMultXTxt:SetPos(160,60)
		Editor.PANEL.CamSmoothMultXTxt:SetText("| Mult X : ")
		Editor.PANEL.CamSmoothMultXTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoothMultXTxtLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoothMultXTxtLb:SetPos(210,55)
		Editor.PANEL.CamSmoothMultXTxtLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_x" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultXTxtLb:SetSize(40,20)
		Editor.PANEL.CamSmoothMultXTxtLb:SetNumeric(true)
		Editor.PANEL.CamSmoothMultXTxtLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoothMultXTxtLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_x",Editor.PANEL.CamSmoothMultXTxtLb:GetValue())
			Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetValue(Editor.PANEL.CamSmoothMultXTxtLb:GetValue())
		end
		
		Editor.PANEL.CamSmoothMultXTxtLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetPos(255,57)
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_x" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetMin( 0.01 )
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetMax( 1 )
		Editor.PANEL.CamSmoothMultXTxtLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_x",Editor.PANEL.CamSmoothMultXTxtLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoothMultXTxtLb:SetValue(Editor.PANEL.CamSmoothMultXTxtLb_PRF:GetTextValue())
		end
		
		
		Editor.PANEL.CamSmoothMultYTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothMultYTxt:SetPos(10,85)
		Editor.PANEL.CamSmoothMultYTxt:SetText("Mult Y : ")
		Editor.PANEL.CamSmoothMultYTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoothMultYTxtLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoothMultYTxtLb:SetPos(50,80)
		Editor.PANEL.CamSmoothMultYTxtLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_y" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultYTxtLb:SetSize(40,20)
		Editor.PANEL.CamSmoothMultYTxtLb:SetNumeric(true)
		Editor.PANEL.CamSmoothMultYTxtLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoothMultYTxtLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_y",Editor.PANEL.CamSmoothMultYTxtLb:GetValue())
			Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetValue(Editor.PANEL.CamSmoothMultYTxtLb:GetValue())
		end
		
		Editor.PANEL.CamSmoothMultYTxtLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetPos(95,82)
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_y" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetMin( 0.01 )
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetMax( 1 )
		Editor.PANEL.CamSmoothMultYTxtLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_y",Editor.PANEL.CamSmoothMultYTxtLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoothMultYTxtLb:SetValue(Editor.PANEL.CamSmoothMultYTxtLb_PRF:GetTextValue())
		end
		
		Editor.PANEL.CamSmoothMultZTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothMultZTxt:SetPos(120,85)
		Editor.PANEL.CamSmoothMultZTxt:SetText("| Mult Z : ")
		Editor.PANEL.CamSmoothMultZTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoothMultZTxtLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoothMultZTxtLb:SetPos(170,80)
		Editor.PANEL.CamSmoothMultZTxtLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_z" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultZTxtLb:SetSize(40,20)
		Editor.PANEL.CamSmoothMultZTxtLb:SetNumeric(true)
		Editor.PANEL.CamSmoothMultZTxtLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoothMultZTxtLb.OnTextChanged  = function()
			Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetValue(Editor.PANEL.CamSmoothMultZTxtLb:GetValue())
			RunConsoleCommand("simple_thirdperson_smooth_mult_z",Editor.PANEL.CamSmoothMultZTxtLb:GetValue())
		end
		
		Editor.PANEL.CamSmoothMultZTxtLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetPos(215,82)
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_z" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetMin( 0.01 )
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetMax( 1 )
		Editor.PANEL.CamSmoothMultZTxtLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_z",Editor.PANEL.CamSmoothMultZTxtLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoothMultZTxtLb:SetValue(Editor.PANEL.CamSmoothMultZTxtLb_PRF:GetTextValue())
		end
		
		// ---------------- PANEL SHOULDERVIEW ---------------- //
		
		Editor.PANEL.ShoulderButton = Editor.PANEL.ShoulderSettings:Add( "DButton" )
		Editor.PANEL.ShoulderButton:SizeToContents()
		
		if Editor.ShoulderToggle then
				Editor.PANEL.ShoulderButton:SetText("Disable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.ShoulderButton:SetText("Enable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(0,150,0))
		end		
		
		Editor.PANEL.ShoulderButton:SetPos(10,6)
		Editor.PANEL.ShoulderButton:SetSize(250,20)
		Editor.PANEL.ShoulderButton.DoClick = function()
			Editor.ShoulderToggle = !Editor.ShoulderToggle
			RunConsoleCommand("simple_thirdperson_shoulderview",BoolToInt(Editor.ShoulderToggle))
			if Editor.ShoulderToggle then
				Editor.PANEL.ShoulderButton:SetText("Disable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.ShoulderButton:SetText("Enable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		Editor.PANEL.ShoulderBumpButton = Editor.PANEL.ShoulderSettings:Add( "DButton" )
		Editor.PANEL.ShoulderBumpButton:SizeToContents()
		
		if Editor.ShoulderBumpToggle then
				Editor.PANEL.ShoulderBumpButton:SetText("Disable ShoulderView Bump")
				Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(150,0,0))
		else
				Editor.PANEL.ShoulderBumpButton:SetText("Enable ShoulderView Bump")
				Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(0,150,0))
		end	
		
		Editor.PANEL.ShoulderBumpButton:SetPos(10,30)
		Editor.PANEL.ShoulderBumpButton:SetSize(250,20)
		Editor.PANEL.ShoulderBumpButton.DoClick = function()
			Editor.ShoulderBumpToggle = !Editor.ShoulderBumpToggle
			RunConsoleCommand("simple_thirdperson_shoulderview_bump",BoolToInt(Editor.ShoulderBumpToggle))	
			if Editor.ShoulderBumpToggle then
					Editor.PANEL.ShoulderBumpButton:SetText("Disable ShoulderView Bump")
					Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(150,0,0))
			else
					Editor.PANEL.ShoulderBumpButton:SetText("Enable ShoulderView Bump")
					Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		Editor.PANEL.ShoulderDistTxt = Editor.PANEL.ShoulderSettings:Add("DLabel")
		Editor.PANEL.ShoulderDistTxt:SetPos(10,60)
		Editor.PANEL.ShoulderDistTxt:SetText("Shoulder Dist : ")
		Editor.PANEL.ShoulderDistTxt:SizeToContents() 
		
		Editor.PANEL.ShoulderDistLb = Editor.PANEL.ShoulderSettings:Add("DTextEntry")
		Editor.PANEL.ShoulderDistLb:SetPos(90,55)
		Editor.PANEL.ShoulderDistLb:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_dist" ):GetFloat(),2))
		Editor.PANEL.ShoulderDistLb:SetSize(40,20)
		Editor.PANEL.ShoulderDistLb:SetNumeric(true)
		Editor.PANEL.ShoulderDistLb:SetUpdateOnType( true )
		Editor.PANEL.ShoulderDistLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_dist",Editor.PANEL.ShoulderDistLb:GetValue())
				Editor.PANEL.ShoulderDistLb_PRF:SetValue(Editor.PANEL.ShoulderDistLb:GetValue())
		end
		
		Editor.PANEL.ShoulderDistLb_PRF = Editor.PANEL.ShoulderSettings:Add("DNumberScratch")
		Editor.PANEL.ShoulderDistLb_PRF:SetPos(135,57)
		Editor.PANEL.ShoulderDistLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_dist" ):GetFloat(),2))
		Editor.PANEL.ShoulderDistLb_PRF:SetMin( -100 )
		Editor.PANEL.ShoulderDistLb_PRF:SetMax( 1000 )
		Editor.PANEL.ShoulderDistLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_dist",Editor.PANEL.ShoulderDistLb_PRF:GetTextValue())
			Editor.PANEL.ShoulderDistLb:SetValue(Editor.PANEL.ShoulderDistLb_PRF:GetTextValue())
		end
		
		
		Editor.PANEL.ShoulderUPTxt = Editor.PANEL.ShoulderSettings:Add("DLabel")
		Editor.PANEL.ShoulderUPTxt:SetPos(10,85)
		Editor.PANEL.ShoulderUPTxt:SetText("Shoulder Up : ")
		Editor.PANEL.ShoulderUPTxt:SizeToContents() 
		
		Editor.PANEL.ShoulderUpLb = Editor.PANEL.ShoulderSettings:Add("DTextEntry")
		Editor.PANEL.ShoulderUpLb:SetPos(80,80)
		Editor.PANEL.ShoulderUpLb:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_up" ):GetFloat(),2))
		Editor.PANEL.ShoulderUpLb:SetSize(40,20)
		Editor.PANEL.ShoulderUpLb:SetNumeric(true)
		Editor.PANEL.ShoulderUpLb:SetUpdateOnType( true )
		Editor.PANEL.ShoulderUpLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_up",Editor.PANEL.ShoulderUpLb:GetValue())
			Editor.PANEL.ShoulderUpLb_PRF:SetValue(Editor.PANEL.ShoulderUpLb:GetValue())
		end
		
		
		Editor.PANEL.ShoulderUpLb_PRF = Editor.PANEL.ShoulderSettings:Add("DNumberScratch")
		Editor.PANEL.ShoulderUpLb_PRF:SetPos(125,82)
		Editor.PANEL.ShoulderUpLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_up" ):GetFloat(),2))
		Editor.PANEL.ShoulderUpLb_PRF:SetMin( -1000 )
		Editor.PANEL.ShoulderUpLb_PRF:SetMax( 1000 )
		Editor.PANEL.ShoulderUpLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_up",Editor.PANEL.ShoulderUpLb_PRF:GetTextValue())
			Editor.PANEL.ShoulderUpLb:SetValue(Editor.PANEL.ShoulderUpLb_PRF:GetTextValue())
		end
		
		Editor.PANEL.ShoulderRIGTxt = Editor.PANEL.ShoulderSettings:Add("DLabel")
		Editor.PANEL.ShoulderRIGTxt:SetPos(180,60)
		Editor.PANEL.ShoulderRIGTxt:SetText("Shoulder Right")
		Editor.PANEL.ShoulderRIGTxt:SizeToContents() 
		
		Editor.PANEL.ShoulderRIGLb = Editor.PANEL.ShoulderSettings:Add("DTextEntry")
		Editor.PANEL.ShoulderRIGLb:SetPos(182,80)
		Editor.PANEL.ShoulderRIGLb:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_right" ):GetFloat(),2))
		Editor.PANEL.ShoulderRIGLb:SetSize(40,20)
		Editor.PANEL.ShoulderRIGLb:SetNumeric(true)
		Editor.PANEL.ShoulderRIGLb:SetUpdateOnType( true )
		Editor.PANEL.ShoulderRIGLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_right",Editor.PANEL.ShoulderRIGLb:GetValue())
			Editor.PANEL.ShoulderRIGLb_PRF:SetValue(Editor.PANEL.ShoulderRIGLb:GetValue())
		end
		
		Editor.PANEL.ShoulderRIGLb_PRF = Editor.PANEL.ShoulderSettings:Add("DNumberScratch")
		Editor.PANEL.ShoulderRIGLb_PRF:SetPos(227,82)
		Editor.PANEL.ShoulderRIGLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_right" ):GetFloat(),2))
		Editor.PANEL.ShoulderRIGLb_PRF:SetMin( -1000 )
		Editor.PANEL.ShoulderRIGLb_PRF:SetMax( 1000 )
		Editor.PANEL.ShoulderRIGLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_right",Editor.PANEL.ShoulderRIGLb_PRF:GetTextValue())
			Editor.PANEL.ShoulderRIGLb:SetValue(Editor.PANEL.ShoulderRIGLb_PRF:GetTextValue())
		end
		
		
		// ---------------- CROSSHAIR CAMERA ---------------- //
		
		Editor.PANEL.CustomCrossButton = Editor.PANEL.CrossSettings:Add( "DButton" )
		Editor.PANEL.CustomCrossButton:SizeToContents()
		
		if Editor.CustomCrossToggle then
				Editor.PANEL.CustomCrossButton:SetText("Disable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CustomCrossButton:SetText("Enable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(0,150,0))
		end		
		
		Editor.PANEL.CustomCrossButton:SetPos(10,6)
		Editor.PANEL.CustomCrossButton:SetSize(250,20)
		Editor.PANEL.CustomCrossButton.DoClick = function()
			Editor.CustomCrossToggle = !Editor.CustomCrossToggle
			RunConsoleCommand("simple_thirdperson_enable_custom_crosshair",BoolToInt(Editor.CustomCrossToggle))
			if Editor.CustomCrossToggle then
				Editor.PANEL.CustomCrossButton:SetText("Disable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CustomCrossButton:SetText("Enable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		Editor.PANEL.CrossButton = Editor.PANEL.CrossSettings:Add( "DButton" )
		Editor.PANEL.CrossButton:SizeToContents()
		
		if Editor.CrossToggle then
				Editor.PANEL.CrossButton:SetText("Hide Default Crosshair")
				Editor.PANEL.CrossButton:SetTextColor(Color(150,0,0))
		else
				Editor.PANEL.CrossButton:SetText("Show Default Crosshair")
				Editor.PANEL.CrossButton:SetTextColor(Color(0,150,0))
		end	
		
		Editor.PANEL.CrossButton:SetPos(10,30)
		Editor.PANEL.CrossButton:SetSize(250,20)
		Editor.PANEL.CrossButton.DoClick = function()
			Editor.CrossToggle = !Editor.CrossToggle
			RunConsoleCommand("simple_thirdperson_hide_crosshair",BoolToInt(Editor.CrossToggle))	
			if Editor.CrossToggle then
					Editor.PANEL.CrossButton:SetText("Hide Default Crosshair")
					Editor.PANEL.CrossButton:SetTextColor(Color(150,0,0))
			else
					Editor.PANEL.CrossButton:SetText("Show Default Crosshair")
					Editor.PANEL.CrossButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		
		
		Editor.PANEL.RCrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.RCrossTxt:SetPos(10,60)
		Editor.PANEL.RCrossTxt:SetText("Red : ")
		Editor.PANEL.RCrossTxt:SizeToContents() 
		
		Editor.PANEL.RCrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.RCrossTxtLb:SetPos(50,55)
		Editor.PANEL.RCrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_r" ):GetInt()))
		Editor.PANEL.RCrossTxtLb:SizeToContents()
		Editor.PANEL.RCrossTxtLb:SetNumeric(true)
		Editor.PANEL.RCrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.RCrossTxtLb.OnTextChanged  = function()
			local RValue = tonumber(Editor.PANEL.RCrossTxtLb:GetValue())
			if RValue == nil then return end
			local RVal = math.abs(RValue)
			if RVal > 255 then RVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_r",tostring(RVal))
		end
		
		Editor.PANEL.GCrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.GCrossTxt:SetPos(120,60)
		Editor.PANEL.GCrossTxt:SetText("| Green : ")
		Editor.PANEL.GCrossTxt:SizeToContents() 
		
		Editor.PANEL.GCrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.GCrossTxtLb:SetPos(170,55)
		Editor.PANEL.GCrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_g" ):GetInt()))
		Editor.PANEL.GCrossTxtLb:SizeToContents()
		Editor.PANEL.GCrossTxtLb:SetNumeric(true)
		Editor.PANEL.GCrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.GCrossTxtLb.OnTextChanged  = function()
			local GValue = tonumber(Editor.PANEL.GCrossTxtLb:GetValue())
			if GValue == nil then return end
			local GVal = math.abs(GValue)
			if GVal > 255 then GVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_g",tostring(GVal))
		end
		
		Editor.PANEL.BCrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.BCrossTxt:SetPos(10,85)
		Editor.PANEL.BCrossTxt:SetText("Blue : ")
		Editor.PANEL.BCrossTxt:SizeToContents() 
		
		Editor.PANEL.BCrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.BCrossTxtLb:SetPos(50,80)
		Editor.PANEL.BCrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_b" ):GetInt()))
		Editor.PANEL.BCrossTxtLb:SizeToContents()
		Editor.PANEL.BCrossTxtLb:SetNumeric(true)
		Editor.PANEL.BCrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.BCrossTxtLb.OnTextChanged  = function()
			local BValue = tonumber(Editor.PANEL.BCrossTxtLb:GetValue())
			if BValue == nil then return end
			local BVal = math.abs(BValue)
			if BVal > 255 then BVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_b",tostring(BVal))
		end
		
		Editor.PANEL.ACrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.ACrossTxt:SetPos(120,85)
		Editor.PANEL.ACrossTxt:SetText("| Alpha : ")
		Editor.PANEL.ACrossTxt:SizeToContents() 
		
		Editor.PANEL.ACrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.ACrossTxtLb:SetPos(170,80)
		Editor.PANEL.ACrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_a" ):GetInt()))
		Editor.PANEL.ACrossTxtLb:SizeToContents()
		Editor.PANEL.ACrossTxtLb:SetNumeric(true)
		Editor.PANEL.ACrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.ACrossTxtLb.OnTextChanged  = function()
			local AValue = tonumber(Editor.PANEL.ACrossTxtLb:GetValue())
			if AValue == nil then return end
			local AVal = math.abs(AValue)
			if AVal > 255 then AVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_a",tostring(AVal))
		end
		
		
		// ---------------- Credits CAMERA ---------------- //
		Editor.PANEL.CreedTxt = Editor.PANEL.CreditsSettings:Add("DLabel")
		Editor.PANEL.CreedTxt:SetPos(98,80)
		Editor.PANEL.CreedTxt:SetText("By FailCake :D")
		Editor.PANEL.CreedTxt:SizeToContents() 
		
		Editor.PANEL.CreedImg = Editor.PANEL.CreditsSettings:Add("DImageButton")
		Editor.PANEL.CreedImg:SetPos( 100, 10 )
		Editor.PANEL.CreedImg:SetSize( 64, 64 )
		Editor.PANEL.CreedImg:SetImage( "icon32/zoom_extend.png" )
		Editor.PANEL.CreedImg.DoClick = function()
			gui.OpenURL("http://steamcommunity.com/id/edunad")
		end
	end
	
	function ServerBool(cmd_server,cmd_client)
		
		local srv_shoulder = GetConVar(cmd_server):GetInt()
		
		if srv_shoulder == 0 then
			return IntToBool(GetConVar( cmd_client ):GetInt())
		elseif srv_shoulder == 1 then
			return true
		elseif srv_shoulder == 2 then
			return false
		end
	end
	
	function ServerNumber(cmd_server_max,cmd_server_min,cmd_client,default)
	
		local value = default
		
		local SrvMax = GetConVar( cmd_server_max ):GetFloat() or 0
		local SrvMin = GetConVar( cmd_server_min ):GetFloat() or 0
		
		local ClnVal = GetConVar( cmd_client ):GetFloat() or default
		
		if SrvMax != 0 and SrvMin != 0 then
			if SrvMin > SrvMax then return ClnVal end
			
			if ClnVal <= SrvMax and ClnVal >= SrvMin then
				value = ClnVal
			else
				value = SrvMax
			end
		else
			value = ClnVal
		end
		
		return value
	end
	
	function IntToBool(it)
		if it == 1 then
			return true
		else
			return false
		end
	end
	
	function BoolToInt(bol)
		if bol then
			return 1
		else
			return 0
		end
	end
	
	concommand.Add( "simple_thirdperson_shoulder_toggle", function()
		Editor.ShoulderToggle = !Editor.ShoulderToggle
		RunConsoleCommand("simple_thirdperson_shoulderview",BoolToInt(Editor.ShoulderToggle))
	end)
	
	concommand.Add( "simple_thirdperson_crosshair_toggle", function()
		Editor.CrossToggle = !Editor.CrossToggle
		RunConsoleCommand("simple_thirdperson_hide_crosshair",BoolToInt(Editor.CrossToggle))
	end)
	
	concommand.Add( "simple_thirdperson_custom_crosshair_toggle", function()
		Editor.CustomCrossToggle = !Editor.CustomCrossToggle
		RunConsoleCommand("simple_thirdperson_enable_custom_crosshair",BoolToInt(Editor.CustomCrossToggle))
	end)
	
	concommand.Add( "simple_thirdperson_enable_toggle", function()
		Editor.EnableToggle = !Editor.EnableToggle
		RunConsoleCommand("simple_thirdperson_enabled",BoolToInt(Editor.EnableToggle))
	end)
	
	concommand.Add( "stp", function()
		Editor.EnableToggle = !Editor.EnableToggle
		RunConsoleCommand("simple_thirdperson_enabled",BoolToInt(Editor.EnableToggle))
	end)
	
	hook.Add("ShouldDrawLocalPlayer", "SimpleTP.ShouldDraw", function(ply)
		if GetConVar( "simple_thirdperson_enabled" ):GetBool() then
			return true
		end
	end)

	hook.Add("HUDShouldDraw", "SimpleTP.HUDShouldDraw", function(name)
		if GetConVar( "simple_thirdperson_enabled" ):GetBool() and GetConVar( "simple_thirdperson_enable_custom_crosshair" ):GetBool() or GetConVar( "simple_thirdperson_hide_crosshair" ):GetBool() then
			if name == "CHudCrosshair" then
				return false
			end
		end
	end)
	
	hook.Add("HUDPaint", "SimpleTP.HUDPaint", function()
	
		if !GetConVar( "simple_thirdperson_enable_custom_crosshair" ):GetBool() then return end
	
		local ply = LocalPlayer()
		
		local t = {}
		t.start = ply:GetShootPos()
		t.endpos = t.start + ply:GetAimVector() * 9000
		t.filter = ply
		
		local tr = util.TraceLine(t)
		local pos = tr.HitPos:ToScreen()
		
		local dist = (tr.HitPos - t.start):Length()

		if dist < 3500 then
		
			local R = GetConVar( "simple_thirdperson_custom_crosshair_r" ):GetInt()
			local G = GetConVar( "simple_thirdperson_custom_crosshair_g" ):GetInt()
			local B = GetConVar( "simple_thirdperson_custom_crosshair_b" ):GetInt()
			local A = GetConVar( "simple_thirdperson_custom_crosshair_a" ):GetInt()
			surface.SetDrawColor(R, G, B, A)
			
			surface.DrawLine(pos.x - 5, pos.y, pos.x - 8, pos.y)
			surface.DrawLine(pos.x + 5, pos.y, pos.x + 8, pos.y)
	
			surface.DrawLine(pos.x, pos.y - 5, pos.x, pos.y - 8)
			surface.DrawLine(pos.x, pos.y + 5, pos.x, pos.y + 8)
			
		end
		
	end)
	
	hook.Add("CalcView","SimpleTP.Camera.View",function(ply, pos, angles, fov)
		local isEnabled = GetConVar( "simple_thirdperson_enabled" ):GetBool() or false
		
		if isEnabled and IsValid(ply) then
		
			if Editor.DelayPos == nil then
				Editor.DelayPos = ply:EyePos()
			end
			
			if Editor.ViewPos == nil then
				Editor.ViewPos = ply:EyePos()
			end
			

			Editor.DelayFov = fov
			
			local view = {}
		
			local Forward = ServerNumber("simple_thirdperson_maxdistance","simple_thirdperson_mindistance","simple_thirdperson_cam_distance")
			
			local Up = ServerNumber("simple_thirdperson_maxup","simple_thirdperson_minup","simple_thirdperson_cam_up")
			local Right = ServerNumber("simple_thirdperson_maxright","simple_thirdperson_minright","simple_thirdperson_cam_right")
			
			local Pitch = ServerNumber("simple_thirdperson_maxpitch","simple_thirdperson_minpitch","simple_thirdperson_cam_pitch")
			local Yaw = ServerNumber("simple_thirdperson_maxyaw","simple_thirdperson_minyaw","simple_thirdperson_cam_yaw")
			
			if ServerBool("simple_thirdperson_forceshoulder","simple_thirdperson_shoulderview") then
			
				if GetConVar( "simple_thirdperson_shoulderview_bump" ):GetBool() and ply:GetMoveType() != MOVETYPE_NOCLIP then
					angles.pitch = angles.pitch + (ply:GetVelocity():Length() / 300) * math.sin(CurTime() * 10)
					angles.roll = angles.roll + (ply:GetVelocity():Length() / 300) * math.cos(CurTime() * 10)
				end
				
				Forward = ServerNumber("simple_thirdperson_shoulder_maxdist","simple_thirdperson_shoulder_mindist","simple_thirdperson_shoulderview_dist")
				Up = ServerNumber("simple_thirdperson_shoulder_maxup","simple_thirdperson_shoulder_minup","simple_thirdperson_shoulderview_up")
				Right = ServerNumber("simple_thirdperson_shoulder_maxright","simple_thirdperson_shoulder_minright","simple_thirdperson_shoulderview_right")
			else
			
				angles.p = angles.p + Pitch
				angles.y = angles.y + Yaw
			
			end
			
			if ServerBool("simple_thirdperson_forcesmooth","simple_thirdperson_smooth") then
			
				Editor.DelayPos = Editor.DelayPos + (ply:GetVelocity() * (FrameTime() / GetConVar( "simple_thirdperson_smooth_delay" ):GetFloat()))
				Editor.DelayPos.x = math.Approach(Editor.DelayPos.x, pos.x, math.abs(Editor.DelayPos.x - pos.x) * GetConVar( "simple_thirdperson_smooth_mult_x" ):GetFloat())
				Editor.DelayPos.y = math.Approach(Editor.DelayPos.y, pos.y, math.abs(Editor.DelayPos.y - pos.y) * GetConVar( "simple_thirdperson_smooth_mult_y" ):GetFloat())
				Editor.DelayPos.z = math.Approach(Editor.DelayPos.z, pos.z, math.abs(Editor.DelayPos.z - pos.z) * GetConVar( "simple_thirdperson_smooth_mult_z" ):GetFloat())

			else
				Editor.DelayPos = pos
			end
			
			if GetConVar( "simple_thirdperson_fov_smooth" ):GetBool() then
				Editor.DelayFov = Editor.DelayFov + 20
				fov = math.Approach(fov, Editor.DelayFov, math.abs(Editor.DelayFov - fov) * GetConVar( "simple_thirdperson_fov_smooth_mult" ):GetFloat())
			else
				fov = Editor.DelayFov
			end
			
			if ServerBool("simple_thirdperson_forcecollide","simple_thirdperson_collision") then
			
				local traceData = {}
				traceData.start = Editor.DelayPos
				traceData.endpos = traceData.start + angles:Forward() * -Forward
				traceData.endpos = traceData.endpos + angles:Right() * Right
				traceData.endpos = traceData.endpos + angles:Up() * Up
				traceData.filter = ply
				
				local trace = util.TraceLine(traceData)
				
				pos = trace.HitPos
				
				if trace.Fraction < 1.0 then
					pos = pos + trace.HitNormal * 5
				end
				
				view.origin = pos
			else
			
				local View = Editor.DelayPos + ( angles:Forward()* -Forward )
				View = View + ( angles:Right() * Right )
				View = View + ( angles:Up() * Up )
				
				view.origin = View
				
			end

			view.angles = angles
			view.fov = fov
		 
			return view
		end
	end)

	concommand.Add( "simple_thirdperson	_menu",function() BuildMenu(nil) end)
	concommand.Add( "simple_thirdperson_dumpHook",function()
	print("====== Simple ThirdPerson Dump ======")
		for k,v in pairs(hook.GetTable()) do
			if k == "CalcView" or k == "ShouldDrawLocalPlayer" or k == "HUDShouldDraw" then
				print("\n------- ".. k .. " -------\n")
				for k2,v2 in pairs(v) do
					PrintTable(debug.getinfo(v2))
					print("#####--#####")
				end
			end
		end
	print("\n====== +++++++++++++++++++++++ ======")
	end)
	
	print("[SimpleThirdPerson] Addon Loaded")
end
--PATH addons/the_perfect_training_system/lua/diablos_training/languages/training_french.lua:
Diablos.TS.Languages.AvailableLanguages["french"] = {

	-- Global data
	lbs = "lbs",
	kg = "kg",
	yes = "OUI",
	no = "NON",
	andStr = "et",
	active = "ACTUEL",
	training = "ENTRAINEMENT",
	beginning = "D√©but:",
	ending = "Termine:",
	leaveTraining = "Quitter entra√Ænement",
	second = "seconde",
	seconds = "secondes",
	minute = "minute",
	minutes = "minutes",
	hour = "heure",
	hours = "heures",
	day = "jour",
	days = "jours",
	week = "semaine",
	weeks = "semaines",
	month = "mois",
	months = "mois",
	year = "ann√©e",
	years = "ann√©es",
	key = "touche",
	keys = "touches",
	free = "GRATUIT",

	-- Home tips
	home = "Accueil",
	trainingStatistics = "STATISTIQUES D'ENTRAINEMENT",
	levelProgression = "Level progression",
	captionFine = "Muscle en repos",
	captionShouldTrain = "Devrait s'entra√Æner",
	captionMuscleLoss = "Perte de muscle",
	staminaBenefit = "Dur√©e de vitesse maximale",
	staminaMuscle = "Cuisse",
	runningspeedBenefit = "Vitesse de course maximale",
	runningspeedMuscle = "Mollet",
	strengthBenefit = "Force d'attaque",
	strengthMuscle = "√âpaule, Trap√®ze & Haut du bras",
	attackspeedBenefit = "Vitesse d'attaque",
	attackspeedMuscle = "Avant bras",


	-- Personal statistics

	currentLevel = "Niveau %u",
	xpPoint = "XP: %u",

	-- Global statistics

	globalStatistics = "Statistiques globales",
	onlineStatistics = "Statistiques pour les joueurs en ligne",
	updateSelection = "METTRE √Ä JOUR (%u s√©lectionn√©)",
	resetPlayerData = "R√âINITIALISER DONN√âES JOUEUR",
	resetEntityData = "R√âINITIALISER DONN√âES ENTIT√â",
	peopleSelected = "Personnes s√©lectionn√©es: %s",
	peopleSelectedTip = "Vous pouvez d√©finir certains param√®tres d'entra√Ænement pour les personnes s√©lectionn√©es",


	-- Training times part

	trainingTimes = "HEURES D'ENTRAINEMENT",
	trainingAdv = "Vous avez parfois besoin de mettre vos muscles au repos. Cependant, attendre trop de temps fera perdre des muscles.",
	muscleRest = "Repos musculaire",
	losingMuscle = "Perte de muscle",
	waitUntil = "Vous devriez attendre jusqu'√†",
	secondsRemaining = "%d secondes restantes",
	needTrainBeforeLosingMuscle = "Vous devez vous entra√Æner avant:",
	neverTrained = "Jamais entra√Æn√©",
	freeToWorkout = "Vous √™tes libre de faire travailler ce muscle !",
	currentlyLosing = "Vous √™tes en train de perdre du muscle !",
	yourChoice = "Votre choix",
	trainNow = "Lancer l'entra√Ænement",


	-- XP/Level table

	levels = "Niveaux",
	level = "Niveau",
	xp = "XP",
	percentage = "Pourcentage",
	undefined = "Non d√©fini",
	lastTraining = "Dernier entra√Ænement",

	-- Global trainings

	trainingWillBegin = "L'entra√Ænement va commencer dans %u secondes",
	trainingEndsIn = "L'entra√Ænement finit dans %u secondes",
	currentlyUsingMachine = "Quelqu'un est en train d'utiliser cet appareil",
	leftMachine = "Vous avez arr√™t√© l'entra√Ænement. Vous pouvez r√©essayer d√®s maintenant !",
	farFromMachine = "Vous √™tes trop loin de l'appareil pour vous entra√Æner !",
	notAllowedJob = "Votre travail ne vous permet pas de vous entra√Æner !",

	-- Admin data

	setTo = "Mettre %s √†",
	confirmationBox = "BO√éTE DE CONFIRMATION",
	areYouSure = "√ätes-vous s√ªr de vouloir effectuer ceci ?",

	-- Weigh balance data


	weighBalanceUse = "Appuyez sur USE pour obtenir vos informations",
	weighBalanceCantSee = "Les statistiques sont confidentielles",
	weighBalanceTipL1 = "MERCI DE VOUS PLACER",
	weighBalanceTipL2 = "SUR LA BALANCE",
	weighBalanceTipL3 = "POUR LES STATISTIQUES",

	-- Turnstile data

	turnstileNeedBadge = "Vous devez utiliser votre badge pour l'acc√®s !",

	-- Badge data

	activebadge = "Badge actif",
	neverSubscribed = "Jamais abonn√©",
	badgeSubscription = "Abonnement au badge",
	expirationDate = "Date d'expiration",
	expired = "Expir√©",
	previousSub = "Abonnement pr√©c√©dent",

	-- Stamina data

	stamina = "Endurance",
	runSpeed = "Vitesse de course",
	timeMaxSpeed = "Temps total en vitesse de pointe",

	-- Running speed data

	runningspeed = "Vitesse de course",

	-- Treadmill data

	treadmillDrawLeft = "%u secondes restantes",
	treadmillDrawSomeone = "Quelqu'un s'entra√Æne !",
	treadmillDrawCanUse = "LIBRE D'UTILISATION",
	treadmillCurSpeed = "Vitesse actuelle",
	treadmillFrameTitle = "TAPIS ROULANT",
	treadmillChooseExerciceTip1 = "Marteler la touche pour avancer afin d'augmenter votre vitesse",
	treadmillChooseExerciceTip2 = "Les points gagn√©s d√©pendent de la vitesse √† laquelle vous courez √† la fin",
	quickExerciceSpeed = "Exercice rapide bas√© sur la vitesse",
	longExerciceStamina = "Exercice long bas√© sur l'endurance",
	runningTime = "Temps de course",
	increaseSpeed = "Vitesse d'augmentation",
	decreaseSpeed = "Vitesse de diminution",
	needFasterTreadmill = "Vous devez √™tre plus rapide lorsque vous pressez / rel√¢chez la touche FORWARD",

	-- Strength data

	strength = "Force",

	-- Dumbbell data

	dumbbellDraw = "Halt√®re",
	dumbbellFrameTitle = "HALT√àRE",
	dumbbellChooseExerciceTip1 = "Appuyez sur les bonne touches au bon moment",
	dumbbellChooseExerciceTip2 = "Les points gagn√©s d√©pendent du ratio de touches press√©es au bon moment",

	-- Attack speed data

	attackspeed = "Vitesse d'attaque",

	-- Punching ball data

	punchingHitDamage = "%u points rouges touch√©s",
	punchingFrameTitle = "PUNCHING BALL",
	punchingChooseExerciceTip1 = "Tapez les points rouges sur le punching-ball",
	punchingChooseExerciceTip2 = "Les points gagn√©s d√©pendent du nombre de points rouges touch√©s avec vos poings",

	-- Card reader data

	cardReaderTitle = "LECTEUR DE CARTE",
	approachBadge = "Vous devez approcher votre badge pour utiliser le lecteur de carte !",
	becomeOwner = "Vous √™tes devenu le propri√©taire du terminal !",
	someoneElseOwner = "Quelqu'un d'autre est d√©j√† propri√©taire de ce terminal !",

	cardReaderOwnerAdd = "AJOUTER",
	cardReaderOwnerRemove = "SUPPRIMER",
	cardReaderApply = "APPLIQUER",
	cardReaderBadgePrice = "Prix du badge",
	cardReaderPurchaseSub = "ACHETER UN ABONNEMENT",
	cardReaderPurchaseSubTip1 = "Un abonnement vous permet d'utiliser votre badge sur les tourniquets",
	cardReaderFullyRecharged = "Votre abonnement est recharg√© √† fond ! Expire le %s",

	cardReaderGiveCredit = "DONNER UN CR√âDIT",
	cardReaderGiveCreditTip1 = "Vous vous appr√™tez √† donner un cr√©dit √† la personne en face de vous",
	cardReaderGiveCreditTip2 = "Cela lui permettra d'avoir l'acc√®s √† UN tourniquet",
	cardReaderGiveCreditBtn = "DONNER",
	cardReaderGiveAlreadyCredit = "Vous ne pouvez pas donner un cr√©dit √† quelqu'un qui en a d√©j√† un !",
	cardReaderGiveAlreadySubscribed = "Vous ne pouvez pas donner un cr√©dit √† quelqu'un qui a d√©j√† un abonnement valide !",

	cardReaderEditTerminal = "MODIFIER LE TERMINAL",
	cardReaderEditTerminalTip1 = "Vous pouvez changer le prix d'abonnement et les co-propri√©taires",
	cardReaderEditTerminalTip2 = "Les co-propri√©taires sont ici pour partager l'argent re√ßu issu des abonnements",
	cardReaderEditTerminalSetPrice = "Le prix peut √™tre d√©fini entre %s et %s",


	-- Notify player

	alreadyTrained = "Vous avez r√©cemment entra√Æn√© ces muscles, revenez dans %s",
	needMoreLevel = "Vous devez √™tre au moins niveau %u pour utiliser cet appareil !",
	tooEasy = "Cet appareil est trop facile pour votre niveau !",
	endTraining = "L'entra√Ænement vient de se terminer",
	xpAdded = "Vous avez gagn√© %u points !",
	newLevel = "Vous √™tes d√©sormais niveau %u !",
	lossOfTraining = "Vous avez perdu du muscle par manque d'entra√Ænement de: %s",
	sportBadgeVerified = "Votre abonnement est valide",
	sportBadgeInvalid = "Votre abonnement est invalide",
	subDataUpdated = "Vous avez mis √† jour les informations d'abonnement du badge !",
	subPurchased = "Vous avez re√ßu %s car %s a achet√© un abonnement !",
	subRenewed = "Vous avez renouvel√© votre abonnement !",
	subNotEnoughMoney = "Vous n'avez pas assez d'argent pour acheter un abonnement !",
	creditGiven = "Vous avez donn√© un cr√©dit !",
	creditReceived = "Vous avez re√ßu un cr√©dit !",
	entitiesUpdated = "Les donn√©es des entit√©s d'entra√Ænement ont √©t√© mises √† jour !",
	entitiesRemoved = "Les entit√©s ont √©t√© supprim√©es et les donn√©es r√©initialis√©es !",
	playerDataRemoved = "La base de donn√©es des joueurs a √©t√© supprim√©e !",
	playerDataUpdated = "Donn√©es mises √† jour avec votre valeur !",

}
--PATH addons/the_perfect_training_system/lua/diablos_training/vgui/cl_treadmill.lua:
function Diablos.TS:OpenRunningPanel(ply, ent)

	local frame = vgui.Create("DFrame")
	frame:SetSize(650, 350)
	frame:DockPadding(0, 0, 0, 0)
	frame:Center()
	frame:SetTitle("")
	frame:SetDraggable(false)
	frame:ShowCloseButton(false)
	frame.Paint = function(s, w, h)
		if Diablos.TS.Colors.Blurs then Derma_DrawBackgroundBlur(s, 1) end
		surface.SetDrawColor(Diablos.TS.Colors.Frame) surface.DrawRect(0, 0, w, h)
	end

	frame:MakePopup()

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:DockMargin(0, 0, 0, 0)
	header:SetTall(40)
	header.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.Header) surface.DrawRect(0, h - 4, w, 4)

		draw.SimpleText(Diablos.TS:GetLanguageString("treadmillFrameTitle"), "Diablos:Font:TS:30", 5, (h - 4) / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end


	local closeButton = vgui.Create("DButton", header)
	closeButton:Dock(RIGHT)
	closeButton:SetText("")
	closeButton:SetWide(40)
	closeButton.Paint = function(s, w, h)
		local size = h * 0.8
		local curColor = Diablos.TS:PaintFunctions(s, color_white, Diablos.TS.Label, Diablos.TS.LabelHovered)
		surface.SetDrawColor(curColor)
		surface.SetMaterial(Diablos.TS.Materials.close)
		surface.DrawTexturedRect(w / 2 - size / 2, (h - 4) / 2 - size / 2, size, size)
	end

	closeButton.DoClick = function(s)
		frame:Close()
	end

	local docker = vgui.Create("DPanel", frame)
	docker:Dock(FILL)
	docker:DockPadding(10, 10, 10, 10)
	docker:DockMargin(0, 0, 0, 0)
	docker.Paint = function(s, w, h) end

	local trainingInfo = vgui.Create("DPanel", docker)
	trainingInfo:Dock(TOP)
	trainingInfo:DockPadding(0, 0, 0, 0)
	trainingInfo:DockMargin(0, 0, 0, 10)
	trainingInfo:SetTall(60)
	trainingInfo.Paint = function(s, w, h)
		draw.SimpleText(Diablos.TS:GetLanguageString("treadmillChooseExerciceTip1"), "Diablos:Font:TS:30", w / 2, 0, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(Diablos.TS:GetLanguageString("treadmillChooseExerciceTip2"), "Diablos:Font:TS:25", w / 2, h, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	end

	local SIZE_HEIGHT = 220

	local buttonPanel = vgui.Create("DPanel", docker)
	buttonPanel:Dock(TOP)
	buttonPanel:DockPadding(0, 0, 0, 0)
	buttonPanel:DockMargin(0, 0, 0, 10)
	buttonPanel:SetTall(SIZE_HEIGHT)
	buttonPanel.Paint = function(s, w, h)

	end

	local SIZE_MATERIAL_ICON = 100

	if Diablos.TS.RunningSpeedEnabled then
		local runningSpeedData = Diablos.TS.RunningSpeedEquivalence[ent:GetAngle()]

		local dockButton = LEFT
		if not Diablos.TS.StaminaEnabled then
			dockButton = FILL
		end

		local speedExercice = vgui.Create("DButton", buttonPanel)
		speedExercice:Dock(dockButton)
		speedExercice:DockMargin(0, 0, 0, 0)
		speedExercice:SetText("")
		speedExercice:SetFont("Diablos:Font:TS:35")
		speedExercice:SetWide(310)
		speedExercice.Paint = function(s, w, h)
			local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Colors.bl, Diablos.TS.Colors.bl2, Diablos.TS.Colors.bl3, true)
			surface.SetDrawColor(curColor)
			surface.DrawRect(0, 0, w, h)

			draw.SimpleText(Diablos.TS:GetLanguageString("quickExerciceSpeed"), "Diablos:Font:TS:25", w / 2, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			draw.SimpleText(string.format("%s: %u %s", Diablos.TS:GetLanguageString("runningTime"), runningSpeedData.time, Diablos.TS:GetLanguageString("seconds")), "Diablos:Font:TS:20", w / 2, 40, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)


			draw.SimpleText(string.format("%s: %4.2f %s/%s", Diablos.TS:GetLanguageString("increaseSpeed"), runningSpeedData.speedIncrement, Diablos.TS:GetSpeedText(), Diablos.TS:GetLanguageString("key")), "Diablos:Font:TS:15", w / 2, 70, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			local decrementPerSecond = 1 / runningSpeedData.speedDecrementTime
			local decreaseSpeed = runningSpeedData.speedDecrement * decrementPerSecond
			draw.SimpleText(string.format("%s: %4.2f %s/s", Diablos.TS:GetLanguageString("decreaseSpeed"), decreaseSpeed, Diablos.TS:GetSpeedText()), "Diablos:Font:TS:15", w / 2, 90, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			surface.SetDrawColor(color_white)
			surface.SetMaterial(Diablos.TS.Materials.runningSpeed)
			surface.DrawTexturedRect(w / 2 - SIZE_MATERIAL_ICON / 2, h - SIZE_MATERIAL_ICON - 5, SIZE_MATERIAL_ICON, SIZE_MATERIAL_ICON)
		end
		speedExercice.DoClick = function(s)
			net.Start("TPTSA:BeginTraining")
				net.WriteEntity(ent)
				net.WriteUInt(0, 5) -- type of exercice
			net.SendToServer()
			frame:Close()
		end
	end

	if Diablos.TS.StaminaEnabled then
		local staminaData = Diablos.TS.StaminaEquivalence[ent:GetAngle()]

		local dockButton = RIGHT
		if not Diablos.TS.RunningSpeedEnabled then
			dockButton = FILL
		end

		local staminaExercice = vgui.Create("DButton", buttonPanel)
		staminaExercice:Dock(dockButton)
		staminaExercice:DockMargin(0, 0, 0, 0)
		staminaExercice:SetText("")
		staminaExercice:SetFont("Diablos:Font:TS:35")
		staminaExercice:SetWide(310)
		staminaExercice.Paint = function(s, w, h)
			local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Colors.bl, Diablos.TS.Colors.bl2, Diablos.TS.Colors.bl3, true)
			surface.SetDrawColor(curColor)
			surface.DrawRect(0, 0, w, h)

			draw.SimpleText(Diablos.TS:GetLanguageString("longExerciceStamina"), "Diablos:Font:TS:25", w / 2, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			draw.SimpleText(string.format("%s: %u %s", Diablos.TS:GetLanguageString("runningTime"), staminaData.time, Diablos.TS:GetLanguageString("seconds")), "Diablos:Font:TS:20", w / 2, 40, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)


			draw.SimpleText(string.format("%s: %4.2f %s/%s", Diablos.TS:GetLanguageString("increaseSpeed"), staminaData.speedIncrement, Diablos.TS:GetSpeedText(), Diablos.TS:GetLanguageString("key")), "Diablos:Font:TS:15", w / 2, 70, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			local decrementPerSecond = 1 / staminaData.speedDecrementTime
			local decreaseSpeed = staminaData.speedDecrement * decrementPerSecond

			draw.SimpleText(string.format("%s: %4.2f %s/s", Diablos.TS:GetLanguageString("decreaseSpeed"), decreaseSpeed, Diablos.TS:GetSpeedText()), "Diablos:Font:TS:15", w / 2, 90, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			surface.SetDrawColor(color_white)
			surface.SetMaterial(Diablos.TS.Materials.stamina)
			surface.DrawTexturedRect(w / 2 - SIZE_MATERIAL_ICON / 2, h - SIZE_MATERIAL_ICON - 5, SIZE_MATERIAL_ICON, SIZE_MATERIAL_ICON)
		end
		staminaExercice.DoClick = function()
			net.Start("TPTSA:BeginTraining")
				net.WriteEntity(ent)
				net.WriteUInt(1, 5) -- type of exercice
			net.SendToServer()
			frame:Close()
		end
	end
end
--PATH addons/the_perfect_training_system/lua/diablos_training/shared/sh_stamina.lua:
local meta = FindMetaTable("Player")

/*---------------------------------------------------------------------------
	Get stamina parameters
---------------------------------------------------------------------------*/

Diablos.TS.Parameters.Stamina = {
	Regen = 1.5, -- Time to regen your health
	MaxStamina = 100, -- Maximum stamina
	JumpInvolveStamina = true, -- true = a jump will consume some stamina, so you could be not allowed to jump if not enough stamina
	MinimumToJump = 10, -- if JumpInvolveStamina is set to true, this is the minimum stamina you need to be allowed to jump ; it will consume that value
}

/*---------------------------------------------------------------------------
	Get the current stamina of the player
---------------------------------------------------------------------------*/

function meta:TSGetStamina()
	return self.CurrentStamina or 100
end

/*---------------------------------------------------------------------------
	Get the maximum stamina the player can have (everyone is capped at 100 currently)
---------------------------------------------------------------------------*/

function meta:TSGetMaxStamina()
	self.MaxStamina = self.MaxStamina or Diablos.TS.Parameters.Stamina.MaxStamina
	return self.MaxStamina
end

/*---------------------------------------------------------------------------
	Get the amount of stamina this is decreasing depending on your stamina level
	First level, you're losing MinimumToJump points - last level, you're losing MinimumToJump * 0.25 points
---------------------------------------------------------------------------*/

function meta:TSGetJumpStamina()
	local level = Diablos.TS:GetTrainingLevel("Stamina", self)
	local levels = Diablos.TS:GetTrainingLevelTable("Stamina")

	local ratio = level / #levels
	local pointsToLose = Diablos.TS.Parameters.Stamina.MinimumToJump * (1 - 0.75 * ratio)

	return pointsToLose
end

/*---------------------------------------------------------------------------
	Update the stamina and return it
---------------------------------------------------------------------------*/

function meta:TSUpdateStamina(newStamina)
	local oldStamina = self:TSGetStamina()
	self.CurrentStamina = math.Clamp(newStamina, 0, self:TSGetMaxStamina())

	-- the self.NextRegen field needs to be updated only if you lose some stamina, otherwise it means you're in the regen mode
	if self:TSGetStamina() < oldStamina then
		self.NextRegen = CurTime() + Diablos.TS.Parameters.Stamina.Regen
	end
	return self:TSGetStamina()
end

/*---------------------------------------------------------------------------
	Get if the player is able to jump, meaning:
		* the player has enough stamina
		* the MinimumToJump is set to 0
---------------------------------------------------------------------------*/

function meta:TSCanJump()
	local minimumToJump = Diablos.TS.Parameters.Stamina.MinimumToJump

	return minimumToJump == 0 or self:TSGetStamina() >= minimumToJump
end

/*---------------------------------------------------------------------------
	Get if the player should regen its stamina
---------------------------------------------------------------------------*/

function meta:TSCanRegenStamina()
	return (self.NextRegen != nil) and self.NextRegen < CurTime()
end

/*---------------------------------------------------------------------------
	Get the run speed you should have considering your runspeed level
---------------------------------------------------------------------------*/

function meta:TSGetRealRunSpeed()
	if not self.TS_JOB_RUN_SPEED then
		self.TS_JOB_RUN_SPEED = self:GetRunSpeed()
	end

	return self.TS_JOB_RUN_SPEED + self:TSGetRunningSpeed()
end

/*---------------------------------------------------------------------------
	Update the run speed of the player with the new run speed
---------------------------------------------------------------------------*/

function meta:TSRefreshRunSpeed()
	self.TS_RUN_SPEED_UPD_STAMINA = false
	local realRunSpeed = self:TSGetRealRunSpeed()
	self:SetRunSpeed(realRunSpeed)
	self.TS_RUN_SPEED_UPD_STAMINA = true
end

/*---------------------------------------------------------------------------
	Update the stamina of the player, this will:
		* update the stamina to the maximum

---------------------------------------------------------------------------*/

function meta:TSRefreshStamina()

	if self:TSIsTrainingDataLaunched() then

		self:TSUpdateStamina(self:TSGetMaxStamina())
		self.RegenStamina = 10

		self.DecreaseTime = self:TSGetStaminaTimeDuration() -- in x seconds you lose all your stamina if holding speed

		self.InitStamina = true
	end

end

function Diablos.TS:IsMoving(cmd)
	return cmd:KeyDown(IN_FORWARD) or cmd:KeyDown(IN_BACK) or cmd:KeyDown(IN_MOVELEFT) or cmd:KeyDown(IN_MOVERIGHT)
end



hook.Add( "StartCommand", "TPTSA:StaminaCalc", function(ply, cmd)

	-- Don't calculate stamina is disabled
	if not Diablos.TS:IsTrainingEnabled("stamina") then return end

	if not ply.InitStamina then return end

	local inVehicle = ply:InVehicle()
	local isMoving = Diablos.TS:IsMoving(cmd)

	local frameTime = FrameTime()
	local frameRealism = frameTime * (1 / engine.TickInterval()) / 100

	local curStamina = ply:TSGetStamina()
	local waterLevel = ply:WaterLevel()
	local onGround = ply:OnGround()

	if not inVehicle then
		if cmd:KeyDown(IN_SPEED) and isMoving and ply:GetVelocity():Length() > 100 and (onGround or waterLevel != 0) then
			if curStamina <= 0 then
				cmd:RemoveKey(IN_SPEED)
			else
				curStamina = ply:TSUpdateStamina(curStamina - 100 / ply.DecreaseTime * frameRealism)
			end
		end

		-- Manage the jump feature which is a stamina loss if enabled
		if Diablos.TS.Parameters.Stamina.JumpInvolveStamina then
			if cmd:KeyDown(IN_JUMP) and onGround then
				if not ply:TSCanJump() then
					cmd:RemoveKey(IN_JUMP)
				end
				if ((ply.lastJump or 0) + 0.7 < CurTime()) then
					ply.lastJump = CurTime()

					if ply:TSCanJump() then
						local staminaUpd = 0
						if cmd:KeyDown(IN_SPEED) and isMoving then
							staminaUpd = curStamina - ply:TSGetJumpStamina()
						else
							staminaUpd = curStamina - ply:TSGetJumpStamina() * 0.5
						end
						curStamina = ply:TSUpdateStamina(staminaUpd)
					end
				end
			end
		end
	end

	-- Being inside the water also inducts a stamina loss
	if waterLevel == 3 then
		curStamina = ply:TSUpdateStamina(curStamina - 100 / ply.DecreaseTime * frameRealism)
	end


	if ply:TSCanRegenStamina() then
		local staminaUpd = 0
		if (isMoving and not inVehicle) then
			staminaUpd = curStamina + ( frameTime * 0.1 * ply.RegenStamina )
		else
			staminaUpd = curStamina + ( frameTime * 0.5 * ply.RegenStamina )
		end
		ply:TSUpdateStamina(staminaUpd)
	end
end)
--PATH addons/warning_system/lua/warning_system_7452/languages/es.lua:
WarningSystem7452em.Lang["es"] = {
	tabs = {
		my_warnings = "Mis Advertencias",
		offline_players = "Jugadores Desconectados",
		online_players = "Jugadores En L√≠nea",
		settings = "Ajustes",
		statistics = "Estad√≠sticas",
	},
 
	settings_tabs = {
		preset_reasons = "Razones predefinidas",
		thresholds = "L√≠mites",
		permissions = "Permisos",
		theme = "Tema",
		other = "Otro",
 
		add_this_reason = "Agregar esta raz√≥n",
		penalty_points_to_reach = "Puntos de penalizaci√≥n para alcanzar",
		add_this_threshold = "Agregar este l√≠mite",
		save_those_permissions = "Guardar esos permisos",
		save_this_theme = "Guardar este tema para todos",
		save_this_config = "Guardar esta configuraci√≥n",
	},
 
	webhooks = {
		new_warning = "Nueva Advertencia",
		warning_removed = "Advertencia Removida",
 
		user = "Usuario",
		admin = "Administrador",
		more_info = "M√°s Informaci√≥n",
	},
 
	errors = {
		no_access = "No tienes acceso a esto",
		reason_too_short = "La raz√≥n es demasiado corta",
		reason_too_long = "La raz√≥n es demasiado larga",
		invalid_key = "Tecla inv√°lida",
	},
 
	notifs = {
		success = "√âxito",
		error = "Error",
		warning = "Advertencia",
	},
 
	youve_been_warned = "Se te ha agregado una advertencia",
	player_been_warned = "El jugador fue advertido satisfactoriamente",
	player_been_unwarned = "Se removi√≥ la advertencia satisfactoriamente",
 
	settings_updated = "Ajustes actualizados",
 
	awarn_imported = "¬°Advertencias de AWarn3 importadas!",
 
	by = "Por",
	reason = "Raz√≥n",
	penalty = "Penalizaci√≥n",
	date = "Fecha",
	expiration = "Expiraci√≥n",
	duration = "Duraci√≥n",
	preset = "Predeterminado",
 
	none = "Nada",
 
	warn = "Advertencia",
 
	custom_warning = "Advertencia personalizada",
 
	penalty_points = "Puntos de penalizaci√≥n",
 
	warn_this_player = "Advertir a este jugador",
 
	search_player_sid64 = "Buscar a un jugador por su SteamID x64 (7656...)",
	search_player = "Buscar jugador...",
 
	x_displayed = "%i mostrados",
	x_online_players = "%i Jugadores en l√≠nea",
 
	total_warnings = "Advertencias totales",
	total_penalty_points = "Puntos de penalizaci√≥n totales",
	monthly_warnings = "Advertencias mensuales",
	last_warnings = "√öltimas advertencias",
	most_warned = "Los m√°s advertidos",
	staff_leaderboard = "Clasificaci√≥n del staff",
	active_warnings = "Advertencias activas",
 
	view_more = "Ver m√°s",
 
	joins_with_x = "%s ingres√≥ al servidor con %s advertencias",
 
	set_api_key = "Debes establecer una Steam API key",
 
	months = {"Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"}
}

--PATH addons/warning_system/lua/warning_system_7452/client/vgui/components/dtextentry.lua:
local PANEL = {}

function PANEL:Init()
    self.txt = vgui.Create("DTextEntry", self)
    self.txt:SetDrawLanguageID(false)
    self.txt:SetTextColor(WarningSystem7452em.CFG.theme.Texts)
    self.txt:Dock(FILL)
    self.txt:SetFont("WarningSystem7452em:25M")
    self.txt:DockMargin(8, 8, 8, 8)
    self.txt:SetPlaceholderText("")
    function self.txt:Paint(iW, iH)
        if self:GetText() == "" and self:GetPlaceholderText() ~= "" then
            draw.SimpleText(self:GetPlaceholderText(), self:GetFont(), 3, iH * 0.5, WarningSystem7452em.CFG.theme.Texts2, 0, 1)
        end
        self:DrawTextEntryText(self:GetTextColor(), Color(86, 40, 238), self:GetTextColor())
    end
    function self.txt:OnEnter()
        self:GetParent():OnEnter()
    end
    function self.txt:OnChange()
        if( self:GetParent().OnChange ) then
            self:GetParent():OnChange()
        end
    end
end

function PANEL:GetText() return self.txt:GetText() end
function PANEL:OnEnter() end
function PANEL:SetText(...) return self.txt:SetText(...) end
function PANEL:SetFont(...) return self.txt:SetFont(...) end
function PANEL:SetMultiline(...) return self.txt:SetMultiline(...) end
function PANEL:SetPlaceholderText(...) return self.txt:SetPlaceholderText(...) end

function PANEL:Paint(iW, iH)
    draw.RoundedBox(8, 0, 0, iW, iH, self.txt:HasFocus() and WarningSystem7452em.CFG.theme.Main or WarningSystem7452em.CFG.theme.Secondary)
    draw.RoundedBox(8, 1, 1, iW - 2, iH - 2, WarningSystem7452em.CFG.theme.Tertiary)
end

vgui.Register("WarningSystem7452em:DTextEntry", PANEL, "DPanel")
--PATH lua/wos/anim_extension/core/sh_prone_support.lua:
--[[-------------------------------------------------------------------
	wiltOS Prone Compatability:
		Fixes hold types for Prone Mod
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}

hook.Add("prone.Initialized", "wOS.AnimExtension.AddProneTypes", function()
	for holdtype, data in pairs( wOS.AnimExtension.HoldTypes ) do
		local iseq = prone.GetIdleAnimation( data.BaseHoldType ) 
		local mseq = prone.GetMovingAnimation( data.BaseHoldType ) 
		prone.AddNewHoldTypeAnimation( holdtype, mseq, iseq )
	end
end )


--PATH addons/sl_utils/lua/advdupe2/sh_codec.lua:
--[[
	Title: Adv. Dupe 2 Codec

	Desc: Dupe encoder/decoder.

	Author: emspike

	Version: 2.0
]]

local REVISION = 5
AdvDupe2.CodecRevision = REVISION
AdvDupe2.MaxDupeSize = 32e6 -- 32 MB

include( "sh_codec_legacy.lua" )
AddCSLuaFile( "sh_codec_legacy.lua" )

local pairs = pairs
local type = type
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat
local compress = util.Compress
local decompress = util.Decompress

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local function makeInfo(tbl)
	local info = ""
	for k, v in pairs(tbl) do
		info = concat{info,k,"\1",v,"\1"}
	end
	return info.."\2"
end

local AD2FF = "AD2F%s\n%s\n%s"

local tables, buff

local function noserializer() end

local enc = {}
for i = 1, 255 do enc[i] = noserializer end

local function isArray(tbl)
	local ret = true
	local m = 0

	for k, v in pairs(tbl) do
		m = m + 1
		if k ~= m or enc[TypeID(v)] == noserializer then
			ret = false
			break
		end
	end

	return ret
end

local function write(obj)
	enc[TypeID(obj)](obj)
end

local len, tables, tablesLookup

enc[TYPE_TABLE] = function(obj) --table
	if not tablesLookup[obj] then
		tables = tables + 1
		tablesLookup[obj] = tables
	else
		buff:WriteByte(247)
		buff:WriteShort(tablesLookup[obj])
		return
	end

	if isArray(obj) then
		buff:WriteByte(254)
		for i, v in pairs(obj) do
			write(v)
		end
	else
		buff:WriteByte(255)
		for k, v in pairs(obj) do
			if(enc[TypeID(k)] ~= noserializer and enc[TypeID(v)] ~= noserializer) then
				write(k)
				write(v)
			end
		end
	end
	buff:WriteByte(246)
end

enc[TYPE_BOOL] = function(obj) --boolean
	buff:WriteByte(obj and 253 or 252)
end

enc[TYPE_NUMBER] = function(obj) --number
	buff:WriteByte(251)
	buff:WriteDouble(obj)
end

enc[TYPE_VECTOR] = function(obj) --vector
	buff:WriteByte(250)
	buff:WriteDouble(obj.x)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.z)
end

enc[TYPE_ANGLE] = function(obj) --angle
	buff:WriteByte(249)
	buff:WriteDouble(obj.p)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.r)
end

enc[TYPE_STRING] = function(obj) --string
	len = #obj
	if len < 246 then
		buff:WriteByte(len)
		buff:Write(obj)
	else
		buff:WriteByte(248)
		buff:WriteULong(len)
		buff:Write(obj)
	end
end

local function error_nodeserializer()
	buff:Seek(buff:Tell()-1)
	error(format("Couldn't find deserializer for type {typeid:%d}!", buff:ReadByte()))
end

local reference = 0
local read4, read5

do --Version 4
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		if tt == 0 then
			return nil
		end
		return dec[tt]()
	end
	read4 = read

	dec[255] = function() --table
		local t = {}
		local k
		reference = reference + 1
		local ref = reference
		repeat
			k = read()
			if k ~= nil then
				t[k] = read()
			end
		until (k == nil)
		tables[ref] = t
		return t
	end

	dec[254] = function() --array
		local t = {}
		local k = 0
		local v
		reference = reference + 1
		local ref = reference
		repeat
			k = k + 1
			v = read()
			if(v ~= nil) then
				t[k] = v
			end

		until (v == nil)
		tables[ref] = t
		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() --null-terminated string
		local start = buff:Tell()
		local slen = 0

		while buff:ReadByte() ~= 0 do
			slen = slen + 1
		end

		buff:Seek(start)

		local retv = buff:Read(slen)
		if(not retv) then retv="" end
		buff:ReadByte()

		return retv
	end
	dec[247] = function() --table reference
		reference = reference + 1
		return tables[buff:ReadShort()]
	end

	for i = 1, 246 do dec[i] = function() return buff:Read(i) end end
end

do --Version 5
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		return dec[tt]()
	end
	read5 = read

	dec[255] = function() --table
		local t = {}
		reference = reference + 1
		tables[reference] = t

		for k in read do
			t[k] = read()
		end

		return t
	end

	dec[254] = function() --array
		local t = {}
		reference = reference + 1
		tables[reference] = t

		local k = 1
		for v in read do
			t[k] = v
			k = k + 1
		end

		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() -- Length>246 string
		local slen = buff:ReadULong()
		local retv = buff:Read(slen)
		if(not retv) then retv = "" end
		return retv
	end
	dec[247] = function() --table reference
		return tables[buff:ReadShort()]
	end
	dec[246] = function() --nil
		return
	end

	for i = 1, 245 do dec[i] = function() return buff:Read(i) end end

	dec[0] = function() return "" end
end

local function serialize(tbl)
	tables = 0
	tablesLookup = {}

	buff = file.Open("ad2temp.txt", "wb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	write(tbl)
	buff:Close()

	buff = file.Open("ad2temp.txt","rb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local ret = buff:Read(buff:Size())
	buff:Close()
	return ret
end


local function deserialize(str, read)

	if(str == nil) then
		error("File could not be decompressed!")
		return {}
	end

	tables = {}
	reference = 0
	buff = file.Open("ad2temp.txt","wb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	buff:Write(str)
	buff:Flush()
	buff:Close()

	buff = file.Open("ad2temp.txt","rb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local success, tbl = pcall(read)
	buff:Close()

	if success then
		return tbl
	else
		error(tbl)
	end
end

--[[
	Name:	Encode
	Desc:	Generates the string for a dupe file with the given data.
	Params:	<table> dupe, <table> info, <function> callback, <...> args
	Return:	runs callback(<string> encoded_dupe, <...> args)
]]
function AdvDupe2.Encode(dupe, info, callback, ...)
	local encodedTable = compress(serialize(dupe))
	info.check = "\r\n\t\n"
	info.size = #encodedTable

	callback(AD2FF:format(char(REVISION), makeInfo(info), encodedTable),...)
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("Attempt to read AD2 file with malformed info block!")
	end
	local info = {}
	local ss = str:sub(1, last - 1)
	for k, v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end

	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("Detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)!")
		else
			error("Attempt to read AD2 file with malformed info block!")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[1] = AdvDupe2.LegacyDecoders[1]
versions[2] = AdvDupe2.LegacyDecoders[2]

versions[3] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	return versions[4](encodedDupe)
end

versions[4] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read4), info
end

versions[5] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read5), info
end

function AdvDupe2.CheckValidDupe(dupe, info)
	if not dupe.HeadEnt then return false, "Missing HeadEnt table" end
	if not dupe.Entities then return false, "Missing Entities table" end
	if not dupe.Constraints then return false, "Missing Constraints table" end
	if not dupe.HeadEnt.Z then return false, "Missing HeadEnt.Z" end
	if not dupe.HeadEnt.Pos then return false, "Missing HeadEnt.Pos" end
	if not dupe.HeadEnt.Index then return false, "Missing HeadEnt.Index" end
	if not dupe.Entities[dupe.HeadEnt.Index] then return false, "Missing HeadEnt index ["..dupe.HeadEnt.Index.."] from Entities table" end
	for key, data in pairs(dupe.Entities) do
		if not data.PhysicsObjects then return false, "Missing PhysicsObject table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if not data.PhysicsObjects[0] then return false, "Missing PhysicsObject[0] table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if info.ad1 then -- Advanced Duplicator 1
			if not data.PhysicsObjects[0].LocalPos then return false, "Missing PhysicsObject[0].LocalPos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].LocalAngle then return false, "Missing PhysicsObject[0].LocalAngle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		else -- Advanced Duplicator 2
			if not data.PhysicsObjects[0].Pos then return false, "Missing PhysicsObject[0].Pos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].Angle then return false, "Missing PhysicsObject[0].Angle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		end
	end
	return true, dupe
end

--[[
	Name:	Decode
	Desc:	Generates the table for a dupe from the given string. Inverse of Encode
	Params:	<string> encodedDupe, <function> callback, <...> args
	Return:	runs callback(<boolean> success, <table/string> tbl, <table> info)
]]
function AdvDupe2.Decode(encodedDupe)

	local sig, rev = encodedDupe:match("^(....)(.)")

	if not rev then
		return false, "Malformed dupe (wtf <5 chars long)!"
	end

	rev = rev:byte()

	if sig ~= "AD2F" then
		if sig == "[Inf" then --legacy support, ENGAGE (AD1 dupe detected)
			local success, tbl, info, moreinfo = pcall(AdvDupe2.LegacyDecoders[0], encodedDupe)

			if success then
				info.ad1 = true
				info.size = #encodedDupe
				info.revision = 0

				local index = tonumber(moreinfo.Head) or (istable(tbl.Entities) and next(tbl.Entities))
				if not index then return false, "Missing head index" end
				local pos
				if isstring(moreinfo.StartPos) then
					local spx,spy,spz = moreinfo.StartPos:match("^(.-),(.-),(.+)$")
					pos = Vector(tonumber(spx) or 0, tonumber(spy) or 0, tonumber(spz) or 0)
				else
					pos = Vector()
				end
				local z
				if isstring(moreinfo.HoldPos) then
					z = (tonumber(moreinfo.HoldPos:match("^.-,.-,(.+)$")) or 0)*-1
				else
					z = 0
				end
				tbl.HeadEnt = {
					Index = index,
					Pos = pos,
					Z = z
				}
			else
				ErrorNoHalt(tbl)
			end

			if success then
				success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
			end

			return success, tbl, info, moreinfo
		else
			return false, "Unknown duplication format!"
		end
	elseif rev > REVISION then
		return false, format("Newer codec needed. (have rev %u, need rev %u) Update Advdupe2.",REVISION,rev)
	elseif rev < 1 then
		return false, format("Attempt to use an invalid format revision (rev %d)!", rev)
	else
		local success, tbl, info = pcall(versions[rev], encodedDupe)

		if success then
			success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
		end
		if success then
			info.revision = rev
		end

		return success, tbl, info
	end
end

if CLIENT then

	concommand.Add("advdupe2_to_json", function(_,_,arg)
		if not arg[1] then print("Need AdvDupe2 file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".json"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local ok, tbl = AdvDupe2.Decode(readData)
		local writeFile = file.Open(writeFileName, "wb", "DATA")
		if not writeFile then print("File could not be written! ("..writeFileName..")") return end
		writeFile:Write(util.TableToJSON(tbl))
		writeFile:Close()
		print("File written! ("..writeFileName..")")
	end)

	concommand.Add("advdupe2_from_json", function(_,_,arg)
		if not arg[1] then print("Need json file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".txt"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()

		AdvDupe2.Encode(util.JSONToTable(readData), {}, function(data)
			local writeFile = file.Open(writeFileName, "wb", "DATA")
			if not writeFile then print("File could not be written! ("..writeFileName..")") return end
			writeFile:Write(data)
			writeFile:Close()
			print("File written! ("..writeFileName..")")
		end)
	end)

end



--PATH addons/blues-decals/lua/autorun/client/blues_decals.lua:
BluesDecals = {}

--[[-------------------------------------------------------------------------
This part will cache, load or save materials from the web
---------------------------------------------------------------------------]]
BluesDecals.ImageLoader = {}
BluesDecals.ImageLoader.CachedMaterials = {}
BluesDecals.UI = {}
BluesDecals.UI.Elements = {}
BluesDecals.UI.Materials = {
	refresh = Material("error"),
	loading = Material("error")
}

surface.CreateFont( "BluesDecals_SmallReg", {
	font = "Roboto",
	extended = false,
	size = 16,
	weight = 200,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BluesDecals_SmallBold", {
	font = "Roboto",
	extended = false,
	size = 25,
	weight = 800,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

--This allows you to get a material based on an ID (should be the imgur URL ID)
--Make sure directory exists
file.CreateDir("bluesdecals")

--There is a callback in-case the image is not loaded or isnt finished. The first argument of the callback
--is the material object for that texture, it will return an error texture if the material is not loaded
function BluesDecals.ImageLoader.GetMaterial(id, callback)
	--First check if the ID is cached
	if BluesDecals.ImageLoader.CachedMaterials[id] ~= nil then
		print("Image already loaded, returning material")
		callback(BluesDecals.ImageLoader.CachedMaterials[id])
	else
		--Now check if we have that material file, if so load it as a material and return it
		if file.Exists("bluesdecals/"..id..".png", "DATA") then
			print("File found, loading material then returning")
			--It does exists, so we create the material
			BluesDecals.ImageLoader.CachedMaterials[id] = Material("data/bluesdecals/"..id..".png", "noclamp smooth")
			callback(BluesDecals.ImageLoader.CachedMaterials[id])
		else
			print("Failed to find image, attempting to load from imgur")
			--So the file does not exist, so we need to load it, cache it then return the callback
			http.Fetch("https://i.imgur.com/"..id..".png",function(body)
				print("Loaded Imgur Image : "..id..",png")
				file.Write("bluesdecals/"..id..".png", body)
				BluesDecals.ImageLoader.CachedMaterials[id] = Material("data/bluesdecals/"..id..".png", "noclamp smooth")
				callback(BluesDecals.ImageLoader.CachedMaterials[id])
			end, function()
				callback(false)
			end)
		end
	end
end

--Load the default materials from imgur
BluesDecals.ImageLoader.GetMaterial("Bq1tnt1", function(mat)
	BluesDecals.UI.Materials.loading = mat
end)

BluesDecals.ImageLoader.GetMaterial("wpUNPRi", function(mat)
	BluesDecals.UI.Materials.refresh = mat
end)

--[[-------------------------------------------------------------------------
Some UI elements
---------------------------------------------------------------------------]]
function BluesDecals.UI.Elements.CreateSlider(color, minValue, maxValue, parent, onValueChanged)
	local function drawCircle( x, y, radius, seg ) --Credit to wiki
		local cir = {}

		table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
		for i = 0, seg do
			local a = math.rad( ( i / seg ) * -360 )
			table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
		end

		local a = math.rad( 0 ) -- This is needed for non absolute segment counts
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

		surface.DrawPoly( cir )
	end 

	local p = vgui.Create("DPanel", parent)
	--p:NoClipping(true)
	p.slideAmount = 100 --This is between 0 and 100, regardless of the min and max value as there mapped to it
	p.Paint = function(s, w, h)
		local slideAmountPixel = math.Clamp(w/100 * (s.slideAmount) - h/2, h/2, w - (h/2))

		--Draw background and rounded edges
		draw.RoundedBox(0,h/2,2, w - h, h - 4,Color(40, 40, 45))
		draw.NoTexture()
		surface.SetDrawColor(Color(40, 40, 45))
		drawCircle(w - (h/2), h/2, (h/2) - 2, 16)
		
		--Draw the color section
		draw.RoundedBox(0,h/2,2, slideAmountPixel - (h/2), h - 4,color)
		draw.NoTexture()
		surface.SetDrawColor(color)
		drawCircle((h/2), h/2, (h/2) - 2, 16)

		--Slider end
		surface.SetDrawColor(Color(40, 40, 45))
		drawCircle(slideAmountPixel, h/2, (h/2) + 2, 16)
		surface.SetDrawColor(color)
		drawCircle(slideAmountPixel, h/2, (h/2) - 1, 16)
	end

	p.PerformLayout = function(s, w, h)
		s.sliderButton:SetSize(w, h)
	end

	--Create the slider end button
	local sliderButton = vgui.Create("DButton",p)
	sliderButton:SetText("")
	sliderButton.skipFrames = 0 --Skip frames are used becuase gui uses cached results
	sliderButton.Paint = function() end --Hide button
	sliderButton.OnMousePressed = function(s, keycode)
		if keycode == MOUSE_LEFT then
			s.sliding = true
			s.skipFrames = 1
		end
	end
	sliderButton.Think = function(s)
		if s.skipFrames > 0 then
			s.skipFrames = s.skipFrames - 1
		else
			if not input.IsMouseDown(MOUSE_LEFT) and s.sliding then
				s.sliding = false
				
			end
		end
			
		if s.sliding then
			
			--Work out new slider position
			local x, y = s:ScreenToLocal(gui.MouseX(), gui.MouseY())
			local newSlidePos = (100 / s:GetWide()) * math.Clamp(x + (p:GetTall()/2), 0, p:GetWide()) 

			p.slideAmount = newSlidePos
			onValueChanged(p.slideAmount/100 * maxValue)
		end
	end

	p.sliderButton = sliderButton

	return p
end

function BluesDecals.UI.Elements.CreateImgurEntry(ghostText, parent, onRefresh)

	shouldMakeSmaller = false
	hasCloseButton = true

	local p = vgui.Create("DTextEntry", parent)
	p:SetPaintBackground(false)
	p.lerpValue = 0
	p.canEdit = true
	p.Paint = function(s, w, h)
		if not shouldMakeSmaller then
			s.lerpValue = 1
		end

		local lerpPixelValue = (1 - s.lerpValue) * 125

		draw.RoundedBox(4,lerpPixelValue,0,w - lerpPixelValue,h,Color(40,40,45,255))

		--Draw ghost text
		if s:GetText() == "" and not s:IsEditing() then
			if s.canEdit then
				draw.SimpleText(ghostText, "BluesDecals_SmallReg", lerpPixelValue + 5, (h/2) - 2 , Color(149, 152, 154),  0, 1)
			else
				draw.SimpleText(ghostText, "BluesDecals_SmallReg", lerpPixelValue + 5, (h/2) - 2 , Color(149 * 0.5, 152 * 0.5, 154 * 0.5),  0, 1)
			end
		end

		if s.canEdit then
			s:DrawTextEntryText(Color(149, 152, 154), Color(255, 152, 154), Color(255, 255, 255))
		else
			s:DrawTextEntryText(Color(149 * 0.5, 152 * 0.5, 154 * 0.5), Color(255, 152, 154), Color(255, 255, 255))
		end

		if s:IsHovered() or s:IsEditing() or s:GetText() ~= "" then
			s.lerpValue = Lerp(15 * FrameTime(), s.lerpValue, 1)
		else
			s.lerpValue = Lerp(15 * FrameTime(), s.lerpValue, 0)
		end

	end

	p.AllowInput = function( self, stringValue )
		return not self.canEdit
	end
	
	function p:PerformLayout()
	
	end

	function p:PerformLayout(width, height)
		if hasCloseButton then
			self.b:SetPos(width - height, 0)
			self.b:SetSize(height, height)
		end
		self:SetFontInternal("BluesDecals_SmallReg")
	end

	if hasCloseButton then

		--Now create the clear button
		local b = vgui.Create("DButton", p)
		b:SetText("")
		b.DoClick = function() 
			if p.canEdit then
				onRefresh(p:GetText()) 
			end
		end
		b.Paint = function(s ,  w , h)
			if p.canEdit then
				surface.SetDrawColor(Color(149,152,154))
			else
				surface.SetDrawColor(Color(149 * 0.5,152 * 0.5,154 * 0.5))
			end
			surface.SetMaterial(BluesDecals.UI.Materials.refresh)
			surface.DrawTexturedRect(7,7,w - 14,h - 14)
		end

		p.b = b

	end

	return p
end

function BluesDecals.UI.Elements.CreateStandardButton(text, parent, onClick)
	local p = vgui.Create("DButton", parent)
	p:SetText("")
	p.Paint = function(s, w, h)
		if not s:IsHovered() then
			draw.RoundedBox(4,0,0,w,h,Color(39, 121, 189,255))
		else
			draw.RoundedBox(4,0,0,w,h,Color(39 * 1.1, 121 * 1.1, 189 * 1.1,255))
		end
		--Draw text
		draw.SimpleText(text, "BluesDecals_SmallBold", w/2, h/2, Color(255, 255, 255),  1, 1)
	end
	p.DoClick = onClick

	return p
end

--[[-------------------------------------------------------------------------
This part handles the UI for editing a decal
---------------------------------------------------------------------------]]
function BluesDecals.OpenMenu(entity)
	entity.clientOverride = true
	entity.clientOverrideScale = entity:GetImageScale()
	entity.clientOverrideColor = entity:GetImageColor()
	entity.clientOverrideAlpha = entity:GetImageAlpha()

	local entityData = {
		id = entity:GetImgurID(),
		scale = entity:GetImageScale(),
		color = entity:GetImageColor(),
		alpha = entity:GetImageAlpha()
	}

	--Create the menu
	local frame = vgui.Create("DFrame")
	frame:SetSize(300, 480)
	frame:Center()
	frame:ShowCloseButton(false)
	frame:SetTitle("")
	frame.Paint = function(s , w , h)
		draw.RoundedBox(0,0, 0, w, h, Color(27,27, 30, 255))
		draw.SimpleText("Blue's Decal Editor", "BluesDecals_SmallReg", w/2, 15, Color(90, 90, 90, 255), 1, 1)

		draw.SimpleText("Imgur ID", "BluesDecals_SmallBold", w/2, 50, Color(200, 200, 200, 255), 1, 1)

		draw.SimpleText("Image Color", "BluesDecals_SmallBold", w/2, 140, Color(200, 200, 200, 255), 1, 1)

		draw.SimpleText("Image Scale", "BluesDecals_SmallBold", w/2, 140 + 30 + 23 + 23 + 23 + 23 + 10, Color(200, 200, 200, 255), 1, 1)
	end
	frame.Close = function(s)
		entity.clientOverride = false
		s:Remove()
	end
	frame:MakePopup()

	--Imgur ID entry
	local idEntry = BluesDecals.UI.Elements.CreateImgurEntry("Imgur ID", frame, function(id)
		entity:RefreshMaterial(id)
		entityData.id = id
	end)
	idEntry:SetPos(10, 70)
	idEntry:SetSize(300 - 20, 40)


	--Color stuff
	local rSlider = BluesDecals.UI.Elements.CreateSlider(Color(204,31,26), 0, 255, frame, function(val)
		entity.clientOverrideColor.x = val
		entityData.color.r = val
	end)
	rSlider.slideAmount = (100 / 255) * entityData.color.x
	rSlider:NoClipping(true)
	rSlider:SetPos(10, 160)
	rSlider:SetSize(300 - 20, 14)

	local gSlider = BluesDecals.UI.Elements.CreateSlider(Color(31,157,85), 0, 255, frame, function(val)
		entity.clientOverrideColor.y = val
		entityData.color.g = val
	end)
	gSlider.slideAmount = (100 / 255) * entityData.color.y
	gSlider:NoClipping(true)
	gSlider:SetPos(10, 160 + 23)
	gSlider:SetSize(300 - 20, 14)

	local bSlider = BluesDecals.UI.Elements.CreateSlider(Color(39, 121, 189), 0, 255, frame, function(val)
		entity.clientOverrideColor.z = val
		entityData.color.b = val
	end)
	bSlider.slideAmount = (100 / 255) * entityData.color.b
	bSlider:NoClipping(true)
	bSlider:SetPos(10, 160 + 23 + 23)
	bSlider:SetSize(300 - 20, 14)

	local aSlider = BluesDecals.UI.Elements.CreateSlider(Color(200, 200, 200), 0, 255, frame, function(val)
		entity.clientOverrideAlpha = val
		entityData.alpha = val
	end)
	aSlider.slideAmount = (100 / 255) * entityData.alpha
	aSlider:NoClipping(true)
	aSlider:SetPos(10, 160 + 23 + 23 + 23)
	aSlider:SetSize(300 - 20, 14)

	--Scale stuff
	local xSlider = BluesDecals.UI.Elements.CreateSlider(Color(200, 200, 200), 0, 8000, frame, function(val)
		entity.clientOverrideScale.x = val
		entityData.scale.x = val
	end)
	xSlider.slideAmount = (100 / 8000) * entity.clientOverrideScale.x
	xSlider:NoClipping(true)
	xSlider:SetPos(10, 160 + 23 + 23 + 90)
	xSlider:SetSize(300 - 20, 14)

	local ySlider = BluesDecals.UI.Elements.CreateSlider(Color(200, 200, 200), 0, 8000, frame, function(val)
		entity.clientOverrideScale.y = val
		entityData.scale.y = val
	end)
	ySlider.slideAmount = (100 / 8000) * entity.clientOverrideScale.y
	ySlider:NoClipping(true)
	ySlider:SetPos(10, 160 + 23 + 23 + 23 + 90)
	ySlider:SetSize(300 - 20, 14)

	--Update/Close buttons
	local updateButton = BluesDecals.UI.Elements.CreateStandardButton("Update", frame, function()
		net.Start("BLUESDECALS:UpdateEntityData")
		net.WriteEntity(entity)
		net.WriteTable(entityData)
		net.SendToServer()
	end)
	updateButton:SetPos(10, 160 + 23 + 23 + 23 + 100 + 30)
	updateButton:SetSize(300 - 20, 50)


	local closeButton = BluesDecals.UI.Elements.CreateStandardButton("Close", frame, function()
		frame:Close()
	end)
	closeButton:SetPos(10, 160 + 23 + 23 + 23 + 100 + 30 + 60)
	closeButton:SetSize(300 - 20, 50)

end


--[[-------------------------------------------------------------------------
Networking
---------------------------------------------------------------------------]]

net.Receive("BLUESDECALS:OpenMenu", function()
	local e = net.ReadEntity()
	BluesDecals.OpenMenu(e)
end)
--PATH lua/bricks_server/bricks_server_basecfg_main.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame
    !!WARNING!!
]]--

--[[ MODULES CONFIG ]]--
BRICKS_SERVER.BASECONFIG.MODULES = BRICKS_SERVER.BASECONFIG.MODULES or {}
BRICKS_SERVER.BASECONFIG.MODULES["default"] = { true, {
    ["currencies"] = true
} }

--[[ GENERAL CONFIG ]]--
BRICKS_SERVER.BASECONFIG.GENERAL = BRICKS_SERVER.BASECONFIG.GENERAL or {}
BRICKS_SERVER.BASECONFIG.GENERAL["Donate Link"] = "https://www.blackrockgaming.co.uk/donate"
BRICKS_SERVER.BASECONFIG.GENERAL["Server Name"] = "BRG"
BRICKS_SERVER.BASECONFIG.GENERAL["3D2D Display Distance"] = 500000
BRICKS_SERVER.BASECONFIG.GENERAL["Use Textured Gradients (Better FPS)"] = true
BRICKS_SERVER.BASECONFIG.GENERAL.AdminPermissions = { 
    ["superadmin"] = true, 
    ["founder"] = true, 
    ["owner"] = true 
}
BRICKS_SERVER.BASECONFIG.GENERAL.Groups = {
    [1] = { "Staff", { ["moderator"] = true, ["admin"] = true, ["superadmin"] = true } },
    [2] = { "VIP++", { ["vip++"] = true, ["superadmin"] = true }, Color(201,176,55) },
    [3] = { "VIP+", { ["vip+"] = true, ["vip++"] = true, ["superadmin"] = true }, Color(180,180,180) },
    [4] = { "VIP", { ["vip"] = true, ["vip+"] = true, ["vip++"] = true, ["superadmin"] = true }, Color(173,138,86) },
    [5] = { "User", {}, Color(201, 70, 70), true }
}
BRICKS_SERVER.BASECONFIG.GENERAL.Rarities = {
    [1] = { "Common", "Gradient", { Color( 154, 154, 154 ), Color( 154*1.5, 154*1.5, 154*1.5 ) } },
    [2] = { "Uncommon", "Gradient", { Color( 104, 255, 104 ), Color( 104*1.5, 255*1.5, 104*1.5 ) } },
    [3] = { "Rare", "Gradient", { Color( 42, 133, 219 ),Color( 42*1.5, 133*1.5, 219*1.5 )  } },
    [4] = { "Epic", "Gradient", { Color( 152, 68, 255 ), Color( 152*1.5, 68*1.5, 255*1.5 ) } },
    [5] = { "Legendary", "Gradient", { Color( 253, 162, 77 ), Color( 253*1.5, 162*1.5, 77*1.5 ) } },
    [6] = { "Glitched", "Rainbow" }
}

--[[ LANGUAGE CONFIG ]]--
BRICKS_SERVER.BASECONFIG.LANGUAGE = {}
BRICKS_SERVER.BASECONFIG.LANGUAGE.Language = "english"
BRICKS_SERVER.BASECONFIG.LANGUAGE.Languages = {}

--[[ THEME CONFIG ]]--
BRICKS_SERVER.BASECONFIG.THEME = {}
BRICKS_SERVER.BASECONFIG.THEME[0] = Color(25, 25, 25)
BRICKS_SERVER.BASECONFIG.THEME[1] = Color(40, 40, 40)
BRICKS_SERVER.BASECONFIG.THEME[2] = Color(49, 49, 49)
BRICKS_SERVER.BASECONFIG.THEME[3] = Color(68, 68, 68)
BRICKS_SERVER.BASECONFIG.THEME[4] = Color(181, 50, 50)
BRICKS_SERVER.BASECONFIG.THEME[5] = Color(201, 70, 70)
BRICKS_SERVER.BASECONFIG.THEME[6] = Color(255, 255, 255)

--[[ INVENTORY ]]--
BRICKS_SERVER.BASECONFIG.INVENTORY = BRICKS_SERVER.BASECONFIG.INVENTORY or {}
BRICKS_SERVER.BASECONFIG.INVENTORY.ItemRarities = {
    ["Wood"] = "Uncommon",
    ["Scrap"] = "Uncommon",
    ["Iron"] = "Common",
    ["Plastic"] = "Common",
    ["Ruby"] = "Rare",
    ["Diamond"] = "Epic",
    ["weapon_ak472"] = "Legendary",
    ["weapon_deagle2"] = "Rare",
    ["weapon_fiveseven2"] = "Common",
    ["weapon_glock2"] = "Common",
    ["weapon_p2282"] = "Common",
    ["weapon_m42"] = "Rare",
    ["weapon_mac102"] = "Uncommon",
    ["weapon_mp52"] = "Uncommon",
    ["weapon_pumpshotgun2"] = "Uncommon",
    ["ls_sniper"] = "Epic",
}
BRICKS_SERVER.BASECONFIG.INVENTORY.Whitelist = {
    ["spawned_shipment"] = { true, true },
    ["spawned_weapon"] = { true, true },
    ["bricks_server_ink"] = { false, true },
    ["bricks_server_resource"] = { false, true },
    ["bricks_server_resource_wood"] = { false, true },
    ["bricks_server_resource_scrap"] = { false, true },
    ["bricks_server_resource_iron"] = { false, true },
    ["bricks_server_resource_plastic"] = { false, true },
    ["bricks_server_resource_ruby"] = { false, true },
    ["bricks_server_resource_diamond"] = { false, true }
}

--[[ NPCS ]]--
BRICKS_SERVER.BASECONFIG.NPCS = BRICKS_SERVER.BASECONFIG.NPCS or {}
--PATH lua/bricks_server/bricks_server_devcfg_main.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

BRICKS_SERVER.DEVCONFIG.BaseThemes = {}
BRICKS_SERVER.DEVCONFIG.BaseThemes.Red = Color(201, 70, 70)
BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed = Color(181, 50, 50)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Green = Color(46, 204, 113)
BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen = Color(39, 174, 96)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Gold = Color(201,176,55)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Silver = Color(180,180,180)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Bronze = Color(173,138,86)
BRICKS_SERVER.DEVCONFIG.BaseThemes.White = Color( 255, 255, 255 )
BRICKS_SERVER.DEVCONFIG.BaseThemes.Black = Color( 0, 0, 2505 )

BRICKS_SERVER.DEVCONFIG.AccentThemes = {}
BRICKS_SERVER.DEVCONFIG.AccentThemes["Turquoise"] = { Color(22, 160, 133), Color(26, 188, 156) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Emerald"] = { Color(39, 174, 96), Color(46, 204, 113) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Blue"] = { Color(41, 128, 185), Color(52, 152, 219) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Amethyst"] = { Color(142, 68, 173), Color(155, 89, 182) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Yellow"] = { Color(243, 156, 18), Color(241, 196, 15) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Orange"] = { Color(211, 84, 0), Color(230, 126, 34) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Red"] = { Color(181, 50, 50), Color(201, 70, 70) }

BRICKS_SERVER.DEVCONFIG.BackgroundThemes = {}
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Dark"] = { Color(25, 25, 25), Color(40, 40, 40), Color(49, 49, 49), Color(68, 68, 68), Color( 255, 255, 255 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["DarkBlue"] = { Color(26, 41, 56), Color(36, 51, 66), Color(44, 62, 80), Color(52, 73, 94), Color( 255, 255, 255 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Light"] = { Color(152, 157, 161), Color(170, 177, 182), Color(189, 195, 199), Color(236, 240, 241), Color( 0, 0, 0 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Grey"] = { Color(101, 115, 116), Color(111, 125, 126), Color(127, 140, 141), Color(149, 165, 166), Color( 255, 255, 255 ) }

BRICKS_SERVER.DEVCONFIG.EntityTypes = BRICKS_SERVER.DEVCONFIG.EntityTypes or {}
BRICKS_SERVER.DEVCONFIG.EntityTypes["bricks_server_npc"] = { 
    GetDataFunc = function( entity ) 
        return entity:GetNPCKeyVar() or 0
    end,
    SetDataFunc = function( entity, data ) 
        return entity:SetNPCKey( data or 0 )
    end
}

BRICKS_SERVER.DEVCONFIG.NPCTypes = BRICKS_SERVER.DEVCONFIG.NPCTypes or {}

BRICKS_SERVER.DEVCONFIG.WeaponModels = {
    ["weapon_ar2"] = "models/weapons/w_irifle.mdl",
    ["weapon_bugbait"] = "models/weapons/w_bugbait.mdl",
    ["weapon_crossbow"] = "models/weapons/w_crossbow.mdl",
    ["weapon_crowbar"] = "models/weapons/w_crowbar.mdl",
    ["weapon_frag"] = "models/weapons/w_grenade.mdl",
    ["weapon_physcannon"] = "models/weapons/w_Physics.mdl",
    ["weapon_pistol"] = "models/weapons/w_pistol.mdl",
    ["weapon_rpg"] = "models/weapons/w_rocket_launcher.mdl",
    ["weapon_shotgun"] = "models/weapons/w_shotgun.mdl",
    ["weapon_slam"] = "models/weapons/w_slam.mdl",
    ["weapon_smg1"] = "models/weapons/w_smg1.mdl",
    ["weapon_stunstick"] = "models/weapons/w_stunbaton.mdl",
    ["weapon_medkit"] = "models/weapons/w_medkit.mdl",
    ["weapon_physgun"] = "models/weapons/w_Physics.mdl",
    ["gmod_tool"] = "models/weapons/w_toolgun.mdl",

    ["arrest_stick"] = "models/weapons/w_stunbaton.mdl",
    ["unarrest_stick"] = "models/weapons/w_stunbaton.mdl",
    ["stunstick"] = "models/weapons/w_stunbaton.mdl",
    ["weaponchecker"] = "models/weapons/v_hands.mdl",
}

BRICKS_SERVER.DEVCONFIG.KEY_BINDS = {
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "Numpad 0",
    "Numpad 1",
    "Numpad 2",
    "Numpad 3",
    "Numpad 4",
    "Numpad 5",
    "Numpad 6",
    "Numpad 7",
    "Numpad 8",
    "Numpad 0",
    "Numpad /",
    "Numpad *",
    "Numpad -",
    "Numpad +",
    "Numpad Enter",
    "Numpad .",
    "(",
    ")",
    ";",
    "'",
    "`",
    ",",
    ".",
    "/",
    [[\]],
    "-",
    "=",
    "Enter",
    "Space",
    "Backspace",
    "Tab",
    "Capslock",
    "Numlock",
    "Escape",
    "Scrolllock",
    "Insert",
    "Delete",
    "Home",
    "End",
    "Pageup",
    "Pagedown",
    "Break",
    "Left Shift",
    "Right Shift",
    "Alt",
    "Right Alt",
    "Left Control",
    "Right Control",
    "Left Windows",
    "Right Windows",
    "App",
    "Up",
    "Left",
    "Down",
    "Right",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "F11",
    "F12",
    "Capslock Toggle",
    "Numlock Toggle",
    "Last",
    "Count"
}

-- Inventory --
BRICKS_SERVER.DEVCONFIG.INVENTORY = BRICKS_SERVER.DEVCONFIG.INVENTORY or {}
BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs = {
    GetItemData = function( ent )
        local itemData = { ent:GetClass(), ent:GetModel() }
        
        return itemData, 1
    end,
    OnSpawn = function( ply, pos, itemData )
        local ent = ents.Create( itemData[1] )
        if( not IsValid( ent ) ) then return end
        ent:SetPos( pos )
        ent:SetModel( itemData[2] )
        ent:Spawn()
        if( ent.CPPISetOwner ) then ent:CPPISetOwner( ply ) end
        if( ent.Setowning_ent ) then ent:Setowning_ent( ply ) end
    end,
    ModelDisplay = function( Panel, itemData )
        if( not Panel.Entity or not IsValid( Panel.Entity ) ) then return end

        local mn, mx = Panel.Entity:GetRenderBounds()
        local size = 0
        size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
        size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
        size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

        Panel:SetFOV( 65 )
        Panel:SetCamPos( Vector( size, size, size ) )
        Panel:SetLookAt( (mn + mx) * 0.5 )
    end,
    GetInfo = function( itemData )
        local name = BRICKS_SERVER.Func.GetList( "entities" )[itemData[1] or ""] or (itemData[1] or "Unknown")
        return { name, "Some " .. name .. ".", (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[1] or ""] }
    end,
    GetItemKey = function( itemData )
        return itemData[1]
    end,
    CanCombine = function( itemData1, itemData2 )
        if( itemData1[1] == itemData2[1] ) then
            return true
        end

        return false
    end,
}

BRICKS_SERVER.DEVCONFIG.RarityTypes = {}
BRICKS_SERVER.DEVCONFIG.RarityTypes["SolidColor"] = {
    Title = "Solid Color"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Gradient"] = {
    Title = "Gradient"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Fade"] = {
    Title = "Fade"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Rainbow"] = {
    Title = "Rainbow"
}

BRICKS_SERVER.DEVCONFIG.Currencies = BRICKS_SERVER.DEVCONFIG.Currencies or {}
local function loadCurrencies()
    if( DarkRP ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["darkrp_money"] = {
            Title = "DarkRP Money",
            getFunction = function( ply )
                return ply:getDarkRPVar( "money" )
            end,
            addFunction = function( ply, amount )
                ply:addMoney( amount )
            end,
            formatFunction = function( amount )
                return DarkRP.formatMoney( amount )
            end
        }
    end

    if( BRICKSCREDITSTORE ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["brcs_credits"] = {
            Title = "Credits",
            getFunction = function( ply )
                return ply:GetBRCS_Credits()
            end,
            addFunction = function( ply, amount )
                ply:AddBRCS_Credits( amount )
            end,
            formatFunction = function( amount )
                return BRICKSCREDITSTORE.FormatCredits( amount )
            end
        }
    end

    if( mTokens ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["mtokens"] = {
            Title = "mTokens",
            getFunction = function( ply )
                return ((SERVER and mTokens.GetPlayerTokens(ply)) or (CLIENT and mTokens.PlayerTokens)) or 0
            end,
            addFunction = function( ply, amount )
                if( amount > 0 ) then
                    mTokens.AddPlayerTokens(ply, amount)
                else
                    mTokens.TakePlayerTokens(ply, math.abs(amount))
                end
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Tokens"
            end
        }
    end
    
    BRICKS_SERVER.DEVCONFIG.Currencies["ps2_points"] = {
        Title = "PS2 Points",
        getFunction = function( ply )
            return (ply.PS2_Wallet or {}).points or 0
        end,
        addFunction = function( ply, amount )
            ply:PS2_AddStandardPoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Points"
        end
    }

    BRICKS_SERVER.DEVCONFIG.Currencies["ps2_premium_points"] = {
        Title = "PS2 Premium Points",
        getFunction = function( ply )
            return (ply.PS2_Wallet or {}).premiumPoints or 0
        end,
        addFunction = function( ply, amount )
            ply:PS2_AddPremiumPoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Premium Points"
        end
    }

    BRICKS_SERVER.DEVCONFIG.Currencies["ps1_points"] = {
        Title = "PS1 Points",
        getFunction = function( ply )
            return ply:PS_GetPoints() or 0
        end,
        addFunction = function( ply, amount )
            ply:PS_GivePoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Points"
        end
    }

    if( SH_POINTSHOP ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["sh_points"] = {
            Title = "SH Points",
            getFunction = function( ply )
                return ply:SH_GetStandardPoints()
            end,
            addFunction = function( ply, amount )
                ply:SH_AddStandardPoints( amount )
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Points"
            end
        }

        BRICKS_SERVER.DEVCONFIG.Currencies["sh_premium_points"] = {
            Title = "SH Premium Points",
            getFunction = function( ply )
                return ply:SH_GetPremiumPoints()
            end,
            addFunction = function( ply, amount )
                ply:SH_AddPremiumPoints( amount )
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Premium Points"
            end
        }
    end
end

if( gmod.GetGamemode() ) then
    loadCurrencies()
else
    hook.Add( "OnGamemodeLoaded", "BRS.OnGamemodeLoaded.DevConfig", loadCurrencies )
end
--PATH lua/bricks_server/core/client/cl_main.lua:
net.Receive( "BRS.Net.SendConfig", function( len, ply )
    if( not BRICKS_SERVER.TEMP.Configs ) then
        BRICKS_SERVER.TEMP.Configs = {}
    end

    local uniqueStr = net.ReadString()
    local currentPart = net.ReadUInt( 5 )
    local totalParts = net.ReadUInt( 5 )
    local dataLen = net.ReadUInt( 16 )
    local partData = net.ReadData( dataLen )

    if( currentPart > 1 ) then
        if( BRICKS_SERVER.TEMP.Configs[uniqueStr] ) then
            BRICKS_SERVER.TEMP.Configs[uniqueStr] = BRICKS_SERVER.TEMP.Configs[uniqueStr] .. partData
        end
    else
        BRICKS_SERVER.TEMP.Configs[uniqueStr] = partData
    end

    if( currentPart == totalParts and BRICKS_SERVER.TEMP.Configs[uniqueStr] ) then
        if( totalParts > 1 and not BRICKS_SERVER.TEMP.Configs[uniqueStr] ) then return end

        local configUnCompressed = util.JSONToTable( util.Decompress( BRICKS_SERVER.TEMP.Configs[uniqueStr] ) ) or BRICKS_SERVER.BASECONFIG

        if( not BRICKS_SERVER.CONFIG ) then
            BRICKS_SERVER.CONFIG = table.Copy( configUnCompressed ) or {}
        else
            for k, v in pairs( configUnCompressed ) do
                BRICKS_SERVER.CONFIG[k] = v
            end
        end
    
        if( BRICKS_SERVER.Func.HasAdminAccess and BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
            BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
        end
    
        hook.Run( "BRS.Hooks.ConfigReceived", configUnCompressed )
    
        RunConsoleCommand( "spawnmenu_reload" )
    end
end )

local function GetImageFromURL( url, failFunc )
    local CRC = util.CRC( url )
    local Extension = string.Split( url, "." )
    Extension = Extension[#Extension] or "png"

    if( not file.Exists( "bricks_server/images", "DATA" ) ) then
        file.CreateDir( "bricks_server/images" )
    end
    
    if( file.Exists( "bricks_server/images/" .. CRC .. "." .. Extension, "DATA" ) ) then
        BRICKS_SERVER.CachedMaterials[url] = Material( "data/bricks_server/images/" .. CRC .. "." .. Extension )

        if( failFunc ) then
            failFunc( BRICKS_SERVER.CachedMaterials[url], key )
        end

        return BRICKS_SERVER.CachedMaterials[url], key
    else
        http.Fetch( url, function( body )
            file.Write( "bricks_server/images/" .. CRC .. "." .. Extension, body )
            BRICKS_SERVER.CachedMaterials[url] = Material( "data/bricks_server/images/" .. CRC .. "." .. Extension )

            if( failFunc ) then
                failFunc( BRICKS_SERVER.CachedMaterials[url], key )
            end
        end )
    end
end

BRICKS_SERVER.CachedMaterials = {}

function BRICKS_SERVER.Func.CacheImageFromURL( url, failFunc )
    BRICKS_SERVER.CachedMaterials[url] = false

    if( not BRICKS_SERVER.CachedMaterials[url] ) then
        BRICKS_SERVER.CachedMaterials[url] = GetImageFromURL( url, failFunc )
    end
end

function BRICKS_SERVER.Func.CacheImageFromFile( filePath, fileName )
    BRICKS_SERVER.CachedMaterials[fileName] = Material( filePath )
end

function BRICKS_SERVER.Func.GetImage( key, onGetFunc )
    if( BRICKS_SERVER.CachedMaterials[key] ) then
        if( onGetFunc ) then
            onGetFunc( BRICKS_SERVER.CachedMaterials[key], key )
        else
            return BRICKS_SERVER.CachedMaterials[key], key
        end
    else
        if( string.StartWith( key, "http") ) then
            BRICKS_SERVER.Func.CacheImageFromURL( key, onGetFunc )
        end
    end
end

local files, directories = file.Find( "materials/bricks_server/*", "GAME" )
for k, v in pairs( files ) do
    BRICKS_SERVER.CachedMaterials[v] = Material( "materials/bricks_server/" .. v )
end

net.Receive( "BRS.Net.ProfileAdminSend", function( len, ply )
	local requestedID64 = net.ReadString()
	local profileTable = net.ReadTable()

	if( not requestedID64 or not profileTable ) then return end
	local requestedPly = player.GetBySteamID64( requestedID64 )

	if( IsValid( requestedPly ) ) then
		if( IsValid( BS_ADMIN_PROFILE ) and BS_ADMIN_PROFILE:IsVisible() and BS_ADMIN_PROFILE.RefreshProfile ) then
			BS_ADMIN_PROFILE:RefreshProfile( requestedID64, profileTable )
		end
	else
		notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidPlayerProfile" ), 1, 5 )
	end
end )

function BRICKS_SERVER.Func.ConfigChange( moduleKey )
    if( not BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then return end

    if( (BS_ConfigsChanged or {})[moduleKey] ) then return end

    if( not BS_ConfigsChanged ) then
        BS_ConfigsChanged = {}
    end

    BS_ConfigsChanged[moduleKey] = true
end

function BRICKS_SERVER.Func.LoadClientConfig()
    BRICKS_SERVER.CLIENTCONFIG = BRICKS_SERVER.CLIENTCONFIG or {}

    for k, v in pairs( BRICKS_SERVER.BASECLIENTCONFIG ) do
        local type = v[2] or ""

        if( type == "number" or type == "bind" ) then
            BRICKS_SERVER.CLIENTCONFIG[k] = cookie.GetNumber( "bricks_server_" .. k, v[3] or 0 )
        elseif( type == "bool" ) then
            BRICKS_SERVER.CLIENTCONFIG[k] = tobool( cookie.GetNumber( "bricks_server_" .. k, v[3] or 0 ) )
        else
            BRICKS_SERVER.CLIENTCONFIG[k] = cookie.GetString( "bricks_server_" .. k, v[3] or "" )
        end
    end
end
BRICKS_SERVER.Func.LoadClientConfig()

function BRICKS_SERVER.Func.ChangeClientConfig( key, value )
    if( BRICKS_SERVER.BASECLIENTCONFIG[key] ) then
        BRICKS_SERVER.CLIENTCONFIG = BRICKS_SERVER.CLIENTCONFIG or {}

        if( BRICKS_SERVER.BASECLIENTCONFIG[key][2] and BRICKS_SERVER.BASECLIENTCONFIG[key][2] == "bool" ) then
            BRICKS_SERVER.CLIENTCONFIG[key] = value and 1 or 0
            cookie.Set( "bricks_server_" .. key, (value and 1 or 0) )
        else
            BRICKS_SERVER.CLIENTCONFIG[key] = value
            cookie.Set( "bricks_server_" .. key, value )
        end

        if( BRICKS_SERVER.BASECLIENTCONFIG[key][4] and isfunction( BRICKS_SERVER.BASECLIENTCONFIG[key][4] ) ) then
            BRICKS_SERVER.BASECLIENTCONFIG[key][4]( value )
        end
    end
end

function BRICKS_SERVER.Func.GetClientConfig( key )
    if( not BRICKS_SERVER.BASECLIENTCONFIG[key] ) then return end

    local type = BRICKS_SERVER.BASECLIENTCONFIG[key][2] or ""

    if( type == "number" ) then
        return BRICKS_SERVER.CLIENTCONFIG[key] or ((BRICKS_SERVER.BASECLIENTCONFIG[key] or {})[3] or 0)
    elseif( type == "string" ) then
        return BRICKS_SERVER.CLIENTCONFIG[key] or ((BRICKS_SERVER.BASECLIENTCONFIG[key] or {})[3] or "")
    elseif( type == "bind" ) then
        return BRICKS_SERVER.CLIENTCONFIG[key] or ((BRICKS_SERVER.BASECLIENTCONFIG[key] or {})[3] or 0)
    elseif( type == "bool" ) then
        return tobool( BRICKS_SERVER.CLIENTCONFIG[key] )
    end
end

function BRICKS_SERVER.Func.GetClientBind( key )
    if( not BRICKS_SERVER.BASECLIENTCONFIG[key] ) then return BRICKS_SERVER.Func.L( "unbound" ), 0 end

    local bindNum = BRICKS_SERVER.Func.GetClientConfig( key ) or BRICKS_SERVER.BASECLIENTCONFIG[key][3]
    if( BRICKS_SERVER.DEVCONFIG.KEY_BINDS[bindNum] ) then
        return BRICKS_SERVER.DEVCONFIG.KEY_BINDS[bindNum], bindNum
    else
        return BRICKS_SERVER.Func.L( "unbound" ), bindNum
    end
end

function BRICKS_SERVER.Func.SetClientCookie( key, type, value )
    if( type == "bool" ) then
        cookie.Set( "bricks_server_cc_" .. key, value and 1 or 0 )
    else
        cookie.Set( "bricks_server_cc_" .. key, value )
    end
end

function BRICKS_SERVER.Func.GetClientCookie( key, type )
    if( type == "number" ) then
        return cookie.GetNumber( "bricks_server_cc_" .. key, 0 )
    elseif( type == "bool" ) then
        return tobool( cookie.GetNumber( "bricks_server_cc_" .. key, 0 ) )
    else
        return cookie.GetString( "bricks_server_cc_" .. key, "" )
    end
end

BRICKS_SERVER.ConfigPages = BRICKS_SERVER.ConfigPages or {}
function BRICKS_SERVER.Func.AddConfigPage( name, vguiElement, addon, shouldCreate )
    for k, v in pairs( BRICKS_SERVER.ConfigPages ) do
        if( v[2] == vguiElement ) then return end
    end

    table.insert( BRICKS_SERVER.ConfigPages, { name, vguiElement, addon, shouldCreate } )
end

BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "themes" ), "bricks_server_config_themes" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "groups" ), "bricks_server_config_groups" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "general" ), "bricks_server_config_general" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "itemWhitelisting" ), "bricks_server_config_itemwhitelist" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "rarities" ), "bricks_server_config_rarities" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "itemRarities" ), "bricks_server_config_itemrarities" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "languages" ), "bricks_server_config_languages" )
BRICKS_SERVER.Func.AddConfigPage( "NPCS", "bricks_server_config_npcs" )

function BRICKS_SERVER.Func.FillVariableConfigs( parent, configKey, configChanged, specialConfigs )
    if( not BRICKS_SERVER.BASECONFIG[configKey] or not parent or not IsValid( parent ) ) then return end

    local spacing = 5
    local gridWide = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
    local slotsWide = (ScrW() >= 1080 and 2) or 1
    local slotWide = (gridWide-((slotsWide-1)*spacing))/slotsWide
    local slotTall = 80

    if( not parent.grid or not IsValid( parent.grid ) ) then
        parent.grid = vgui.Create( "DIconLayout", parent )
        parent.grid:Dock( TOP )
        parent.grid:DockMargin( 0, 0, 0, 5 )
        parent.grid:SetTall( slotTall )
        parent.grid:SetSpaceY( spacing )
        parent.grid:SetSpaceX( spacing )
    end

    if( not parent.grid or not IsValid( parent.grid ) ) then return end

    local configs, specialConfigs = {}, specialConfigs or {}

    for k, v in pairs( BRICKS_SERVER.BASECONFIG[configKey] ) do
        if( isnumber( v ) or isstring( v ) or isbool( v ) ) then
            configs[k] = v
        end
    end

    if( specialConfigs ) then
        for k, v in pairs( specialConfigs ) do
            configs[k] = v
        end
    end

    for k, v in pairs( configs ) do
        parent.slots = (parent.slots or 0)+1
        local slots = parent.slots
        local slotsTall = math.ceil( slots/slotsWide )
        parent.grid:SetTall( (slotsTall*slotTall)+((slotsTall-1)*spacing) )

        local header = k
        if( istable( v ) and v[3] ) then
            header = v[3]
        end

        local description
        if( istable( v ) and v[2] ) then
            description = v[2]
        end

        local variableBack = parent.grid:Add( "DPanel" )
        variableBack:SetSize( slotWide, slotTall )
        variableBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            draw.SimpleText( header, "BRICKS_SERVER_Font20", 10, 5, BRICKS_SERVER.Func.GetTheme( 5 ), 0, 0 )

            if( description ) then
                surface.SetFont( "BRICKS_SERVER_Font20" )
                local headerX, headerY = surface.GetTextSize( header )

                draw.SimpleText( description, "BRICKS_SERVER_Font20", 10+headerX+5, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end
        end

        if( not specialConfigs[k] and (isstring( v ) or isnumber( v )) ) then
            local valueEntryBack = vgui.Create( "DPanel", variableBack )
            valueEntryBack:Dock( BOTTOM )
            valueEntryBack:DockMargin( 10, 10, 10, 10 )
            valueEntryBack:SetTall( 40 )
            local Alpha = 0
            local valueEntry
            local color1 = BRICKS_SERVER.Func.GetTheme( 1 )
            valueEntryBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        
                if( valueEntry:IsEditing() ) then
                    Alpha = math.Clamp( Alpha+5, 0, 100 )
                else
                    Alpha = math.Clamp( Alpha-5, 0, 100 )
                end
                
                draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
            end

            if( isnumber( v ) ) then
                valueEntry = vgui.Create( "bricks_server_numberwang", valueEntryBack )
                valueEntry:Dock( FILL )
                valueEntry:SetMinMax( 0, 9999999999999 )
                valueEntry:SetValue( ((BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[configKey] or {})[k] or 0 )
                valueEntry.OnValueChanged = function( self2, value )
                    BS_ConfigCopyTable[configKey][k] = tonumber( valueEntry:GetValue() )
                    BRICKS_SERVER.Func.ConfigChange( configChanged )
                end
            else
                valueEntry = vgui.Create( "bricks_server_textentry", valueEntryBack )
                valueEntry:Dock( FILL )
                valueEntry:SetValue( ((BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[configKey] or {})[k] or "" )
                valueEntry.OnChange = function( self2, value )
                    BS_ConfigCopyTable[configKey][k] = valueEntry:GetValue()
                    BRICKS_SERVER.Func.ConfigChange( configChanged )
                end
            end
        elseif( specialConfigs[k] or isbool( v ) ) then
            local toggleButton = vgui.Create( "DButton", variableBack )
            toggleButton:Dock( BOTTOM )
            toggleButton:DockMargin( 10, 10, 10, 10 )
            toggleButton:SetTall( 40 )
            toggleButton:SetText( "" )
            local alpha = 0
            toggleButton.Paint = function( self2, w, h )
                local buttonText = BRICKS_SERVER.Func.L( "edit" )
                local buttonColor = BRICKS_SERVER.Func.GetTheme( 2 )
                local buttonDownColor = BRICKS_SERVER.Func.GetTheme( 1 )

                if( not specialConfigs[k] and isbool( v ) ) then
                    local enabled = BS_ConfigCopyTable[configKey][k]
                    buttonText = (enabled and BRICKS_SERVER.Func.L( "enabled" )) or BRICKS_SERVER.Func.L( "disabled" )
                    buttonColor = (enabled and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green) or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red
                    buttonDownColor = (enabled and BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen) or BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed
                end
    
                if( not self2:IsDown() and self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+5, 0, 200 )
                else
                    alpha = math.Clamp( alpha-5, 0, 255 )
                end
    
                draw.RoundedBox( 5, 0, 0, w, h, buttonColor )
    
                surface.SetAlphaMultiplier( alpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, buttonDownColor )
                surface.SetAlphaMultiplier( 1 )
    
                BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, buttonDownColor )
    
                draw.SimpleText( buttonText, "BRICKS_SERVER_Font20", w/2, h/2-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            if( specialConfigs[k] and istable( v ) and v[1] ) then
                toggleButton.DoClick = v[1]
            else
                toggleButton.DoClick = function()
                    BS_ConfigCopyTable[configKey][k] = not BS_ConfigCopyTable[configKey][k]
                    BRICKS_SERVER.Func.ConfigChange( configChanged )
                end
            end
        end
    end
end

BRS_SERVER_OS_DIFF = 0

net.Receive( "BRS.Net.SendServerTime", function()
    local svrOSTime = net.ReadInt( 32 )
    local svrCurTime = net.ReadInt( 32 )

    BRS_SERVER_OS_DIFF = os.time()-svrOSTime+svrCurTime-CurTime()
end )

function BRICKS_SERVER.Func.GetServerTime()
    return os.time()-BRS_SERVER_OS_DIFF
end

net.Receive( "BRS.Net.OpenBrickServer", function()
    if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
        BS_ConfigsChanged = {}
        BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
    end

	if( not IsValid( BRICKS_SERVER_MENU ) ) then
		BRICKS_SERVER_MENU = vgui.Create( "bricks_server_menu" )
		BRICKS_SERVER_MENU:FillTabs()
    elseif( not BRICKS_SERVER_MENU:IsVisible() ) then
        BRICKS_SERVER_MENU:SetVisible( true )
        if( BRICKS_SERVER_MENU.FillProfile ) then BRICKS_SERVER_MENU.FillProfile() end
        if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
            hook.Run( "BRS.Hooks.RefreshConfig" )
            if( BRICKS_SERVER_MENU.FillPlayers ) then BRICKS_SERVER_MENU.FillPlayers() end
            if( BRICKS_SERVER_MENU.RefreshAdminPerms ) then BRICKS_SERVER_MENU.RefreshAdminPerms() end
        end
    end
end )

BRICKS_SERVER.AdminPlayerFunctions = {}
function BRICKS_SERVER.Func.AddAdminPlayerFunc( title, category, func )
    if( not BRICKS_SERVER.AdminPlayerFunctions ) then
        BRICKS_SERVER.AdminPlayerFunctions = {}
    end

    table.insert( BRICKS_SERVER.AdminPlayerFunctions, { title, category, func } )
end

BRICKS_SERVER.Func.AddAdminPlayerFunc( BRICKS_SERVER.Func.L( "profile" ), BRICKS_SERVER.Func.L( "view" ), function( ply ) 
    if( not IsValid( BS_ADMIN_PROFILE ) ) then
        BS_ADMIN_PROFILE = vgui.Create( "bricks_server_admin_profile" )
    end

    net.Start( "BRS.Net.ProfileAdminRequest" )
        net.WriteString( ply:SteamID64() or "" )
    net.SendToServer()
end )

concommand.Add( "brs_removeonclose", function( ply, cmd, args )
	BRS_REMOVEONCLOSE = not BRS_REMOVEONCLOSE
end )

hook.Add( "InitPostEntity", "BRS.InitPostEntity.NetworkReady", function()
	net.Start( "BRS.Net.SendNetworkReady" )
	net.SendToServer()
end )

net.Receive( "BRS.Net.SendTopNotification", function()
    local text = net.ReadString()
    local time = net.ReadUInt( 8 ) or 5
    local color = net.ReadColor() or BRICKS_SERVER.Func.GetTheme( 5 )

    BRICKS_SERVER.Func.CreateTopNotification( text, time, color )
end )

net.Receive( "BRS.Net.SendNotification", function()
    local text = net.ReadString()
    local type = net.ReadUInt( 8 ) or 1
    local time = net.ReadUInt( 8 ) or 3

    notification.AddLegacy( text, type, time )
end )

net.Receive( "BRS.Net.SendChatNotification", function()
    chat.AddText( net.ReadColor(), net.ReadString(), " ", net.ReadColor(), net.ReadString() )
end )

net.Receive( "BRS.Net.UseMenuNPC", function()
    local vguiElement = net.ReadString()
    local title = net.ReadString()

    if( not vguiElement ) then return end

    if( IsValid( BRICKS_SERVER.TEMP.NPCMenu ) ) then
        BRICKS_SERVER.TEMP.NPCMenu:Remove()
    end

    BRICKS_SERVER.TEMP.NPCMenu = vgui.Create( "bricks_server_dframe" )
	BRICKS_SERVER.TEMP.NPCMenu:SetHeader( title )
    BRICKS_SERVER.TEMP.NPCMenu:SetSize( ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65 )
    BRICKS_SERVER.TEMP.NPCMenu:Center()
    
    local vguiPanel = vgui.Create( vguiElement, BRICKS_SERVER.TEMP.NPCMenu )
    vguiPanel:Dock( FILL )
    if( vguiPanel.FillPanel ) then
        vguiPanel:FillPanel()
    end
end )

function BRICKS_SERVER.Func.SendAdminConfig()
    if( BS_ConfigsChanged and table.Count( BS_ConfigsChanged ) > 0 ) then
        local configToSend = {}
        for k, v in pairs( BS_ConfigsChanged ) do
            if( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[k] ) then
                configToSend[k] = (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[k]
            end
        end

        local configData = util.Compress( util.TableToJSON( configToSend ) )

        net.Start( "BRS.Net.UpdateConfig" )
            net.WriteData( configData, string.len( configData ) )
        net.SendToServer()
    end
end
--PATH lua/bricks_server/vgui/bricks_server_admin_profile.lua:
local PANEL = {}

function PANEL:Init()
    self:SetSize( ScrW(), ScrH() )
    self:Center()
    self:MakePopup()
    self:SetTitle( "" )
    self:SetDraggable( false )
    self:ShowCloseButton( false )

    self.mainPanel = vgui.Create( "DPanel", self )
    self.mainPanel:SetSize( (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65-50 )
    self.mainPanel:Center()
    self.mainPanel.headerHeight = 40
    self.mainPanel:DockPadding( 0, self.mainPanel.headerHeight, 0, 0 )
    self.mainPanel.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        draw.RoundedBoxEx( 5, 0, 0, w, self.mainPanel.headerHeight, BRICKS_SERVER.Func.GetTheme( 0 ), true, true, false, false )
    
        local requestedPly = player.GetBySteamID64( self.requestedID64 or "" )
        if( requestedPly and IsValid( requestedPly ) ) then 
            draw.SimpleText( BRICKS_SERVER.Func.L( "profileView" ) .. " - " .. requestedPly:Nick(), "BRICKS_SERVER_Font30", 10, (self.mainPanel.headerHeight or 40)/2-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
        else
            draw.SimpleText( BRICKS_SERVER.Func.L( "profileView" ), "BRICKS_SERVER_Font30", 10, (self.mainPanel.headerHeight or 40)/2-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
        end
    end

    local closeButton = vgui.Create( "DButton", self.mainPanel )
	local size = 24
	closeButton:SetSize( size, size )
	closeButton:SetPos( self.mainPanel:GetWide()-size-((self.mainPanel.headerHeight-size)/2), (self.mainPanel.headerHeight/2)-(size/2) )
	closeButton:SetText( "" )
    local CloseMat = Material( "materials/bricks_server/close.png" )
    local textColor = BRICKS_SERVER.Func.GetTheme( 6 )
	closeButton.Paint = function( self2, w, h )
		if( self2:IsHovered() and !self2:IsDown() ) then
			surface.SetDrawColor( textColor.r*0.6, textColor.g*0.6, textColor.b*0.6 )
		elseif( self2:IsDown() || self2.m_bSelected ) then
			surface.SetDrawColor( textColor.r*0.8, textColor.g*0.8, textColor.b*0.8 )
		else
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
		end

		surface.SetMaterial( CloseMat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
    closeButton.DoClick = function()
        self:Remove()
    end

    self.contentsPanel = vgui.Create( "DPanel", self.mainPanel )
    self.contentsPanel:Dock( FILL )
    self.contentsPanel:DockMargin( 10, 10, 10, 10 )
    self.contentsPanel.Paint = function( self, w, h ) end 

    local loadingPanel = vgui.Create( "DPanel", self.contentsPanel )
    loadingPanel:Dock( FILL )
    local loadingIcon = Material( "materials/bricks_server/loading.png" )
    loadingPanel.Paint = function( self, w, h ) 
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( loadingIcon )
        local size = 32
        surface.DrawTexturedRectRotated( w/2, h/2, size, size, -(CurTime() % 360 * 250) )

        draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w/2, h/2+(size/2)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
    end 
end

function PANEL:RefreshProfile( requestedID64, profileTable )
    self.requestedID64 = requestedID64

    self.contentsPanel:Clear()

    local requestedPly = player.GetBySteamID64( requestedID64 or "" )
    if( not requestedPly or not IsValid( requestedPly ) ) then return end

    local profileSheet = vgui.Create( "bricks_server_colsheet_top", self.contentsPanel )
    profileSheet:Dock( FILL )
    profileSheet:DockMargin( 0, 0, 0, 0 )
    profileSheet.rounded = true
    profileSheet.pageClickFunc = function( page )
        self.page = page
    end

    local refreshButton = vgui.Create( "DButton", profileSheet.navigationBack )
    refreshButton:Dock( RIGHT )
    refreshButton:SetWide( profileSheet.navigationBack:GetTall() )
    refreshButton:SetText( "" )
    local changeAlpha = 0
    local refreshMat = Material( "materials/bricks_server/refresh.png" )
    refreshButton.Paint = function( self2, w, h ) 
        if( self2:IsDown() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
        elseif( self2:IsHovered() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
        else
            changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
        end
        
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.DrawRect( 0, 0, w, h )

        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
        surface.SetAlphaMultiplier( 1 )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
        surface.SetMaterial( refreshMat )
        local iconSize = 24
        surface.DrawTexturedRect( (h-iconSize)/2, (h/2)-(iconSize/2), iconSize, iconSize )
    end
    refreshButton.DoClick = function()
        net.Start( "BRS.Net.ProfileAdminRequest" )
            net.WriteString( requestedID64 )
        net.SendToServer()
    end

    local refreshCover = vgui.Create( "DPanel", profileSheet.navigationBack )
    refreshCover:Dock( RIGHT )
    refreshCover:SetWide( profileSheet.navigationBack:GetTall() )
    refreshCover.Paint = function( self2, w, h ) 
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.DrawRect( 0, 0, w, h )

        draw.RoundedBoxEx( 5, 0, 0, w-5, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, true )
    end

    local profileMain = vgui.Create( "DPanel", profileSheet )
    profileMain:Dock( FILL )
    profileMain.Paint = function( self, w, h ) end 
    profileSheet:AddSheet( BRICKS_SERVER.Func.L( "statistics" ), profileMain )

    local profileModelBack = vgui.Create( "DPanel", profileMain )
    profileModelBack:Dock( LEFT )
    profileModelBack:DockMargin( 0, 0, 5, 0 )
    profileModelBack:SetWide( (self.mainPanel:GetWide()-20-5)/2 )
    local plyName = requestedPly:Nick() or BRICKS_SERVER.Func.L( "nil" )
    surface.SetFont( "BRICKS_SERVER_Font25" )
    local textX, textY = surface.GetTextSize( plyName )
    local donationRank
    for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
        if( BRICKS_SERVER.Func.IsInGroup( requestedPly, v[1] ) ) then
            donationRank = k
            break
        end
    end
    surface.SetFont( "BRICKS_SERVER_Font20" )
    local donationTextX, donationTextY = surface.GetTextSize( (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] or {})[1] or "" )
    donationTextX = donationTextX+10
    local totalW = textX+donationTextX+5
    profileModelBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        draw.SimpleText( plyName, "BRICKS_SERVER_Font25", (w/2)-(totalW/2), h-(h/10), BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )

        if( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] ) then
            draw.RoundedBox( 5, (w/2)-(totalW/2)+textX+5, h-(h/10)-(donationTextY/2)+1.5, donationTextX, donationTextY, (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][3] or BRICKS_SERVER.Func.GetTheme( 5 )) )
            draw.SimpleText( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][1], "BRICKS_SERVER_Font20", (w/2)-(totalW/2)+textX+5+(donationTextX/2), h-(h/10), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
    end

    local profileModelBack = vgui.Create( "DModelPanel", profileModelBack )
    profileModelBack:Dock( FILL )
    profileModelBack:DockMargin( 10, 10, 10, 10 )
    profileModelBack:SetModel( requestedPly:GetModel() or "" )
    function profileModelBack:LayoutEntity( Entity ) return end

    local dataToShow = {
        [1] = { BRICKS_SERVER.Func.L( "name" ), requestedPly:Nick() },
        [2] = { BRICKS_SERVER.Func.L( "steamID64" ), requestedID64 },
        [3] = { BRICKS_SERVER.Func.L( "donationRank" ), (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] or {})[1] or BRICKS_SERVER.Func.L( "none" ) },
        [4] = { BRICKS_SERVER.Func.L( "staffRank" ), BRICKS_SERVER.Func.GetAdminGroup( requestedPly ) }
    }

    if( DarkRP ) then
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "currentJob" ), requestedPly:getDarkRPVar( "job" ) or BRICKS_SERVER.Func.L( "none" ) } )
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "wallet" ), DarkRP.formatMoney( requestedPly:getDarkRPVar( "money" ) or 0 ) } )
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "levelling" ) ) then
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "level" ), profileTable.level or 0 } )
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "experience" ), string.Comma( math.Round( profileTable.experience or 0 ) ) } )
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "default", "currencies" ) ) then
        for k, v in pairs( BRICKS_SERVER.CONFIG.CURRENCIES or {} ) do
            if( not BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k] ) then continue end

            local currencyTable = BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k]

            table.insert( dataToShow, { v.Name, currencyTable.formatFunction( (profileTable.currencies or {})[k] or 0 ) } )
        end
    end
    
    local profileInfoBack = vgui.Create( "DPanel", profileMain )
    profileInfoBack:Dock( FILL )
    local initialSpacer = 50
    local spacing = 30
    profileInfoBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        for k, v in ipairs( dataToShow ) do
            local pos = k
            if( k % 2 == 0 ) then
                pos = k-1
                draw.SimpleText( v[1], "BRICKS_SERVER_Font25", (w/4)*3, initialSpacer+(spacing*(pos-1)), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                draw.SimpleText( v[2], "BRICKS_SERVER_Font20", (w/4)*3, initialSpacer+(spacing*(pos-1))+20, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            else
                draw.SimpleText( v[1], "BRICKS_SERVER_Font25", (w/4)*1, initialSpacer+(spacing*(pos-1)), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                draw.SimpleText( v[2], "BRICKS_SERVER_Font20", (w/4)*1, initialSpacer+(spacing*(pos-1))+20, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
        end
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "logging" ) ) then    
        local profileLogs = vgui.Create( "bricks_server_scrollpanel", profileSheet )
        profileLogs:Dock( FILL )
        profileLogs.Paint = function( self, w, h ) end 
        profileSheet:AddSheet( BRICKS_SERVER.Func.L( "playerLogs" ), profileLogs, ((self.page or "") == BRICKS_SERVER.Func.L( "playerLogs" ) ) )

        function self.FillLogs()
            profileLogs:Clear()

            local logsRequest = vgui.Create( "DButton", profileLogs )
            logsRequest:Dock( TOP )
            logsRequest:DockMargin( 0, 0, 0, 5 )
            logsRequest:SetTall( 65 )
            logsRequest:DockPadding( 0, 0, 30, 0 )
            logsRequest:SetText( "" )
            local changeAlpha = 0
            logsRequest.Paint = function( self2, w, h ) 
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                draw.SimpleText( BRICKS_SERVER.Func.L( "deleteLogs" ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( BRICKS_SERVER.Func.L( "xLogs", (#(profileTable.logs or {}) or 0) ), "BRICKS_SERVER_Font20", 18, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )

                if( self2:IsDown() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
                elseif( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
                end

                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                surface.SetAlphaMultiplier( 1 )
            end
            logsRequest.DoClick = function()
                net.Start( "BRS.Net.DeleteLogsAdmin" )
                    net.WriteString( requestedID64 )
                net.SendToServer()
            end

            local sortedLogs = table.Copy( profileTable.logs or {} )
            table.sort( sortedLogs, function(a, b) return a[1] > b[1] end )

            for k, v in pairs( sortedLogs or {} ) do
                if( not BRICKS_SERVER.DEVCONFIG.LogTypes[v[2] or ""] ) then continue end

                local entryBack = vgui.Create( "DPanel", profileLogs )
                entryBack:Dock( TOP )
                entryBack:DockMargin( 0, 0, 0, 5 )
                entryBack:SetTall( 65 )
                entryBack:DockPadding( 0, 0, 30, 0 )
                local dateTime = os.date( "%H:%M:%S - %d/%m/%Y" , v[1] )
                local text = ""
                if( BRICKS_SERVER.DEVCONFIG.LogTypes[v[2] or ""].FormatInfo ) then
                    text = BRICKS_SERVER.DEVCONFIG.LogTypes[v[2] or ""].FormatInfo( v[3] )
                end
                entryBack.Paint = function( self2, w, h )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                    draw.SimpleText( dateTime, "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                    draw.SimpleText( text, "BRICKS_SERVER_Font20", 18, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                end
            end
        end
        self.FillLogs()
    end
end

function PANEL:Paint( w, h )
    BRICKS_SERVER.Func.DrawBlur( self, 4, 4 )
end

vgui.Register( "bricks_server_admin_profile", PANEL, "DFrame" )
--PATH lua/bricks_server/vgui/bricks_server_colsheet_top.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()
	self.navigationBack = vgui.Create( "DPanel", self )
	self.navigationBack:Dock( TOP )
	self.navigationBack:SetTall( 50 )
	self.navigationBack:DockMargin( 0, 0, 0, 5 )
	local NavWidth = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
	self.navigationBack.Paint = function( self2, w, h )
		if( self.rounded ) then
			draw.RoundedBox( 5, 0, 0, w, h, (self.navColor or BRICKS_SERVER.Func.GetTheme( 3 )) )
		else
			surface.SetDrawColor( self.navColor or BRICKS_SERVER.Func.GetTheme( 3 ) )
			surface.DrawRect( 0, 0, w, h )
		end
	end

	local moveDist = 100
	
	self.Navigation = vgui.Create( "DPanel", self.navigationBack )
	self.Navigation:SetPos( 0, 0 )
	self.Navigation:SetSize( 0, self.navigationBack:GetTall() )
	self.Navigation.Paint = function( self2, w, h ) end

	function self.Navigation.UpdateWide()
		self.Navigation:SetWide( math.Clamp( self.buttonsWide, 0, NavWidth-25+(self.Navigation.leftMargin or 0) ) )
		if( self.buttonsWide > NavWidth+10 ) then
			if( not IsValid( self.Navigation.rightButton ) ) then
				self.Navigation.rightButton = vgui.Create( "DButton", self.navigationBack )
				self.Navigation.rightButton:SetSize( 25, self.navigationBack:GetTall() )
				self.Navigation.rightButton:SetPos( NavWidth-self.Navigation.rightButton:GetWide(), 0 )
				self.Navigation.rightButton:SetText( "" )
				local changeAlpha = 0
				self.Navigation.rightButton.Paint = function( self2, w, h )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, true )

					if( self2:IsHovered() or self2.m_bSelected ) then
						changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
					else
						changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
					end
			
					surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), false, true, false, true )
					surface.SetAlphaMultiplier( 1 )
			
					draw.SimpleText( ">", "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
				self.Navigation.rightButton.DoClick = function()
					if( (NavWidth-50)+(self.Navigation.leftMargin or 0) >= self.buttonsWide ) then return end
					self.Navigation.leftMargin = math.Clamp( (self.Navigation.leftMargin or 0)+moveDist, 0, self.buttonsWide-(NavWidth-25) )
					self.Navigation:SetPos( -self.Navigation.leftMargin, 0 )
					self.Navigation.UpdateWide()
				end
			end

			if( (self.Navigation.leftMargin or 0) > 0 and not IsValid( self.Navigation.leftButton ) ) then
				self.Navigation.leftButton = vgui.Create( "DButton", self.navigationBack )
				self.Navigation.leftButton:SetSize( 25, self.navigationBack:GetTall() )
				self.Navigation.leftButton:SetPos( 0, 0 )
				self.Navigation.leftButton:SetText( "" )
				local changeAlpha = 0
				self.Navigation.leftButton.Paint = function( self2, w, h )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), true, false, true, false )

					if( self2:IsHovered() or self2.m_bSelected ) then
						changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
					else
						changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
					end
			
					surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), true, false, true, false )
					surface.SetAlphaMultiplier( 1 )
			
					draw.SimpleText( "<", "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
				self.Navigation.leftButton.DoClick = function()
					self.Navigation.leftMargin = math.Clamp( (self.Navigation.leftMargin or 0)-moveDist, 0, self.buttonsWide-(NavWidth-25) )
					self.Navigation:SetPos( -self.Navigation.leftMargin, 0 )
					self.Navigation.UpdateWide()
				end
			elseif( (self.Navigation.leftMargin or 0) <= 0 and IsValid( self.Navigation.leftButton ) ) then
				self.Navigation.leftButton:Remove()
			end
		end
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}
end

function PANEL:UseButtonOnlyStyle()
	self.ButtonOnly = true
end

function PANEL:AddSheet( label, panel, makeActive, onLoad )

	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( LEFT )
	Sheet.Button:DockMargin( 0, 0, 0, 0 )
	Sheet.Button:SetText( "" )
	Sheet.Button.label = label
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	Sheet.Button:SetWide( textX+30 )
	self.buttonsWide = (self.buttonsWide or 0)+(textX+30)
	self.Navigation.UpdateWide()
	local changeAlpha = 0
	local ButX, ButY = false, false
	local first = false
	if( #self.Items <= 0 ) then
		first = true
	end
	Sheet.Button.Paint = function( self2, w, h )
		if( not ButX or not ButY ) then
			ButX, ButY = self2:LocalToScreen( 0, 0 )
		end

		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( not first or not self.rounded ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, h-2, w, 2 )
		else
			BRICKS_SERVER.Func.DrawPartialRoundedBoxEx( 5, 0, h-2, w, 2, BRICKS_SERVER.Func.GetTheme( 5 ), w, 10, 0, h-10, false, false, true, false )
		end
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( label, "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	Sheet.Button.DoClick = function()
		self:SetActiveButton( Sheet.Button )
	end

	if( onLoad ) then
		Sheet.Button.onLoad = onLoad() 
	end

	Sheet.Button.label = label

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetVisible( false )

	if ( self.ButtonOnly ) then
		Sheet.Button:SizeToContents()
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button, true )
	elseif( makeActive ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:AddButton( label, func )
	local sheetButton = vgui.Create( "DButton", self.Navigation )
	sheetButton:Dock( LEFT )
	sheetButton:DockMargin( 0, 0, 0, 0 )
	sheetButton:SetText( "" )
	sheetButton.label = label
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	sheetButton:SetWide( textX+30 )
	self.buttonsWide = (self.buttonsWide or 0)+(textX+30)
	self.Navigation.UpdateWide()
	local changeAlpha = 0
	local ButX, ButY = false, false
	local first = false
	if( #self.Items <= 0 ) then
		first = true
	end
	sheetButton.Paint = function( self2, w, h )
		if( not ButX or not ButY ) then
			ButX, ButY = self2:LocalToScreen( 0, 0 )
		end

		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( not first or not self.rounded ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, h-2, w, 2 )
		else
			draw.RoundedBoxEx( 5, 0, h-20, w, 20, BRICKS_SERVER.Func.GetTheme( 5 ), false, false, true, false )
		end
		surface.SetAlphaMultiplier( 1 )

		if( first ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
			surface.DrawRect( 0, h-20, w, 18 )
		end

		draw.SimpleText( label, "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	sheetButton.DoClick = func
	
	return sheetButton
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active, first )

	if ( self.ActiveButton == active ) then return end

	if ( self.ActiveButton && self.ActiveButton.Target ) then
		self.ActiveButton.Target:SetVisible( false )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad ) then
		active.onLoad()
	end

	self.Content:InvalidateLayout()

	if( not first and self.pageClickFunc ) then
		self.pageClickFunc( active.label )
	end
end

function PANEL:SetActiveSheet( sheetLabel )
	if( not sheetLabel ) then return end

	for k, v in pairs( self.Items ) do
		if( v.Button and v.Button.label and v.Button.label == sheetLabel ) then
			self:SetActiveButton( v.Button )
			break
		end
	end
end

function PANEL:ClearSheets()
	self.buttonsWide = 0
	self.Items = {}
	self.Navigation:Clear()
	self.Content:Clear()
end

derma.DefineControl( "bricks_server_colsheet_top", "", PANEL, "Panel" )

--PATH lua/bricks_server/vgui/bricks_server_config_npcs.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel()
    local itemActions = {
        [1] = { BRICKS_SERVER.Func.L( "edit" ), function( k, v )
            BRICKS_SERVER.Func.CreateNPCEditor( k, v, function( NPCTable ) 
                BS_ConfigCopyTable.NPCS[k] = NPCTable
                BRICKS_SERVER.Func.ConfigChange( "NPCS" )
                self.RefreshPanel()
            end, function() end )
        end }
    }
    
    BS_ConfigCopyTable.NPCS = BS_ConfigCopyTable.NPCS or {}
    function self.RefreshPanel()
        self:Clear()

        self.slots = nil
        if( self.grid and IsValid( self.grid ) ) then
            self.grid:Remove()
        end

        BRICKS_SERVER.Func.FillVariableConfigs( self, "NPCS", "NPCS" )

        for k, v in pairs( BS_ConfigCopyTable.NPCS or {} ) do
            local itemBack = vgui.Create( "DPanel", self )
            itemBack:Dock( TOP )
            itemBack:DockMargin( 0, 0, 0, 5 )
            itemBack:SetTall( 100 )
            itemBack:DockPadding( 0, 0, 25, 0 )
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.RoundedBox( 5, 5, 5, h-10, h-10, BRICKS_SERVER.Func.GetTheme( 2 ) )

                draw.SimpleText( v.Name, "BRICKS_SERVER_Font33", h+15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( v.Type, "BRICKS_SERVER_Font20", h+15, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end

            local itemIcon = vgui.Create( "DModelPanel" , itemBack )
            itemIcon:SetPos( 5, 5 )
            itemIcon:SetSize( itemBack:GetTall()-10, itemBack:GetTall()-10 )
            itemIcon:SetModel( v.Model or "models/breen.mdl" )
            itemIcon:SetCamPos( itemIcon:GetCamPos()+Vector( 40, 0, 0 ) )
            itemIcon:SetColor( v.ModelColor or Color( 255, 255, 255 ) )
            function itemIcon:LayoutEntity(ent) return end

            if( IsValid( itemIcon.Entity ) ) then
                local eyepos = itemIcon.Entity:GetBonePosition( (itemIcon.Entity:LookupBone("ValveBiped.Bip01_Head1") or 1) ) or Vector( 0, 0, 0 )
                eyepos:Add(Vector(0, 0, 2))	-- Move up slightly
                itemIcon:SetLookAt(eyepos)
                itemIcon:SetCamPos(eyepos-Vector(-20, 0, 0))	-- Move cam in front of eyes
                itemIcon.Entity:SetEyeTarget(eyepos-Vector(-12, 0, 0))
            end

            local newItemActions = table.Copy( itemActions )
            if( BRICKS_SERVER.DEVCONFIG.NPCTypes[(v.Type or "")] and BRICKS_SERVER.DEVCONFIG.NPCTypes[(v.Type or "")].TypeDataFunction ) then
                newItemActions[2] = { (BRICKS_SERVER.Func.L( "edit" ) .. " " .. (BRICKS_SERVER.DEVCONFIG.NPCTypes[(v.Type or "")].TypeDataName or "Data")), function( k, v )
                    if( BRICKS_SERVER.DEVCONFIG.NPCTypes[(v.Type or "")] and BRICKS_SERVER.DEVCONFIG.NPCTypes[(v.Type or "")].TypeDataFunction ) then
                        BRICKS_SERVER.DEVCONFIG.NPCTypes[(v.Type or "")].TypeDataFunction( k, v )
                        BRICKS_SERVER.Func.ConfigChange( "NPCS" )
                    end
                end }
                newItemActions[3] = { BRICKS_SERVER.Func.L( "remove" ), function( k, v )
                    BS_ConfigCopyTable.NPCS[k] = nil
                    BRICKS_SERVER.Func.ConfigChange( "NPCS" )
                    self.RefreshPanel()
                end, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed }
            else
                newItemActions[2] = { BRICKS_SERVER.Func.L( "remove" ), function( k, v )
                    BS_ConfigCopyTable.NPCS[k] = nil
                    BRICKS_SERVER.Func.ConfigChange( "NPCS" )
                    self.RefreshPanel()
                end, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed }
            end

            for key2, val2 in ipairs( newItemActions ) do
                local itemAction = vgui.Create( "DButton", itemBack )
                itemAction:Dock( RIGHT )
                itemAction:SetText( "" )
                itemAction:DockMargin( 5, 25, 0, 25 )
                surface.SetFont( "BRICKS_SERVER_Font25" )
                local textX, textY = surface.GetTextSize( val2[1] )
                textX = textX+20
                itemAction:SetWide( math.max( (ScrW()/2560)*150, textX ) )
                local changeAlpha = 0
                itemAction.Paint = function( self2, w, h )
                    if( self2:IsDown() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
                    elseif( self2:IsHovered() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
                    end
                    
                    if( val2[3] ) then
                        draw.RoundedBox( 5, 0, 0, w, h, val2[3] )
                    else
                        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                    end
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                        if( val2[4] ) then
                            draw.RoundedBox( 5, 0, 0, w, h, val2[4] )
                        else
                            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                        end
                    surface.SetAlphaMultiplier( 1 )
            
                    draw.SimpleText( val2[1], "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
                itemAction.DoClick = function()
                    val2[2]( k, v )
                end
            end
        end

        local addNewNPC = vgui.Create( "DButton", self )
        addNewNPC:Dock( TOP )
        addNewNPC:SetText( "" )
        addNewNPC:SetTall( 40 )
        local changeAlpha = 0
        addNewNPC.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "addNPC" ), "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        addNewNPC.DoClick = function()
            BS_ConfigCopyTable.NPCS = BS_ConfigCopyTable.NPCS or {}
            local newNPC = {
                Name = BRICKS_SERVER.Func.L( "newNPC" )
            }
            table.insert( BS_ConfigCopyTable.NPCS, newNPC )
            BRICKS_SERVER.Func.ConfigChange( "NPCS" )
            self.RefreshPanel()
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_npcs", PANEL, "bricks_server_scrollpanel" )
--PATH lua/bricks_server/vgui/bricks_server_dcategorycollapse.lua:

local PANEL = {

	Init = function( self )

		self:SetContentAlignment( 4 )
		self:SetTextInset( 5, 0 )
		self:SetFont( "DermaDefaultBold" )

	end,

	DoClick = function( self )

		self:GetParent():Toggle()

	end,

	UpdateColours = function( self, skin )

		if ( !self:GetParent():GetExpanded() ) then
			self:SetExpensiveShadow( 0, Color( 0, 0, 0, 200 ) )
			return self:SetTextStyleColor( skin.Colours.Category.Header_Closed )
		end

		self:SetExpensiveShadow( 1, Color( 0, 0, 0, 100 ) )
		return self:SetTextStyleColor( skin.Colours.Category.Header )

	end,

	Paint = function( self )

		-- Do nothing!

	end,

	GenerateExample = function()

		-- Do nothing!

	end

}

derma.DefineControl( "bricks_server_dcategoryheader", "Category Header", PANEL, "DButton" )

local PANEL = {}

AccessorFunc( PANEL, "m_bSizeExpanded",		"Expanded", FORCE_BOOL )
AccessorFunc( PANEL, "m_iContentHeight",	"StartHeight" )
AccessorFunc( PANEL, "m_fAnimTime",			"AnimTime" )
AccessorFunc( PANEL, "m_bDrawBackground",	"PaintBackground", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDrawBackground",	"DrawBackground", FORCE_BOOL ) -- deprecated
AccessorFunc( PANEL, "m_iPadding",			"Padding" )
AccessorFunc( PANEL, "m_pList",				"List" )

function PANEL:Init()

	self.Header = vgui.Create( "bricks_server_dcategoryheader", self )
	self.Header:Dock( TOP )
	self.Header:SetSize( 20, 40 )

	self:SetSize( 16, 16 )
	self:SetExpanded( true )
	self:SetMouseInputEnabled( true )

	self:SetAnimTime( 0.2 )
	self.animSlide = Derma_Anim( "Anim", self, self.AnimSlide )

	self:SetPaintBackground( true )
	self:DockMargin( 0, 0, 0, 5 )
	self:DockPadding( 0, 0, 0, 0 )

end

function PANEL:Add( strName )

	local button = vgui.Create( "DButton", self )
	button.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "CategoryButton", panel, w, h ) end
	button.UpdateColours = function( button, skin )

		if ( button.AltLine ) then

			if ( button.Depressed || button.m_bSelected ) then	return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text_Selected ) end
			if ( button.Hovered ) then							return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text_Hover ) end
			return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text )

		end

		if ( button.Depressed || button.m_bSelected ) then	return button:SetTextStyleColor( skin.Colours.Category.Line.Text_Selected ) end
		if ( button.Hovered ) then							return button:SetTextStyleColor( skin.Colours.Category.Line.Text_Hover ) end
		return button:SetTextStyleColor( skin.Colours.Category.Line.Text )

	end

	button:SetHeight( 40 )
	button:SetTextInset( 4, 0 )

	button:SetContentAlignment( 4 )
	button.DoClickInternal = function()

		if ( self:GetList() ) then
			self:GetList():UnselectAll()
		else
			self:UnselectAll()
		end

		button:SetSelected( true )

	end

	button:Dock( TOP )
	button:SetText( strName )

	self:InvalidateLayout( true )
	self:UpdateAltLines()

	return button

end

function PANEL:UnselectAll()

	local children = self:GetChildren()
	for k, v in pairs( children ) do

		if ( v.SetSelected ) then
			v:SetSelected( false )
		end

	end

end

function PANEL:UpdateAltLines()

	local children = self:GetChildren()
	for k, v in pairs( children ) do
		v.AltLine = k % 2 != 1
	end

end

function PANEL:Think()

	self.animSlide:Run()

end

function PANEL:SetLabel( strLabel )

	self.Header:SetText( strLabel )

end

function PANEL:Paint( w, h )
	draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
	draw.RoundedBox( 5, 0, 0, w, 40, BRICKS_SERVER.Func.GetTheme( 3 ) )

	BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, 0, 3, 40, (self.backColor or BRICKS_SERVER.Func.GetTheme( 4 )), 10, 40 )

	draw.SimpleText( (self.headerText or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font20", 15, 40/2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
end

function PANEL:AddButton( material, func )
	local button = vgui.Create( "DButton", self.Header )
	button:Dock( RIGHT )
	button:DockMargin( 2, 2, 2, 2 )
	button:SetWide( 36 )
	button:SetText( "" )
	local changeAlpha = 0
	local x, y = 0, 0
	button.Paint = function( self2, w, h )
		local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
		if( x != toScreenX or y != toScreenY ) then
			x, y = toScreenX, toScreenY
		end

		if( self2:IsDown() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
		elseif( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
		surface.SetAlphaMultiplier( 1 )

		surface.SetMaterial( material )
		local size = 24
		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.DrawTexturedRect( (h-size)/2-1, (h-size)/2+1, size, size )

		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect( (h-size)/2, (h-size)/2, size, size )
	end
	button.DoClick = function()
		func( x, y, button:GetWide(), button:GetWide() )
	end
end

function PANEL:SetContents( pContents )

	self.Contents = pContents
	self.Contents:SetParent( self )
	self.Contents:Dock( FILL )

	if ( !self:GetExpanded() ) then

		self.OldHeight = self:GetTall()

	elseif ( self:GetExpanded() && IsValid( self.Contents ) && self.Contents:GetTall() < 1 ) then

		self.Contents:SizeToChildren( false, true )
		self.OldHeight = self.Contents:GetTall()
		self:SetTall( self.OldHeight )

	end

	self:InvalidateLayout( true )

end

function PANEL:SetExpanded( expanded )

	self.m_bSizeExpanded = tobool( expanded )

	if ( !self:GetExpanded() ) then
		if ( !self.animSlide.Finished && self.OldHeight ) then return end
		self.OldHeight = self:GetTall()
	end

end

function PANEL:Toggle()

	self:SetExpanded( !self:GetExpanded() )

	self.animSlide:Start( self:GetAnimTime(), { From = self:GetTall() } )

	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

	local open = "1"
	if ( !self:GetExpanded() ) then open = "0" end
	self:SetCookie( "Open", open )

	self:OnToggle( self:GetExpanded() )

end

function PANEL:OnToggle( expanded )

	-- Do nothing / For developers to overwrite

end

function PANEL:DoExpansion( b )

	if ( self:GetExpanded() == b ) then return end
	self:Toggle()

end

function PANEL:PerformLayout()

	if ( IsValid( self.Contents ) ) then

		if ( self:GetExpanded() ) then
			self.Contents:InvalidateLayout( true )
			self.Contents:SetVisible( true )
		else
			self.Contents:SetVisible( false )
		end

	end

	if ( self:GetExpanded() ) then

		if ( IsValid( self.Contents ) && #self.Contents:GetChildren() > 0 ) then self.Contents:SizeToChildren( false, true ) end
		self:SizeToChildren( false, true )

	else

		if ( IsValid( self.Contents ) && !self.OldHeight ) then self.OldHeight = self.Contents:GetTall() end
		self:SetTall( self.Header:GetTall() )

	end

	-- Make sure the color of header text is set
	self.Header:ApplySchemeSettings()

	self.animSlide:Run()
	self:UpdateAltLines()

end

function PANEL:OnMousePressed( mcode )

	if ( !self:GetParent().OnMousePressed ) then return end

	return self:GetParent():OnMousePressed( mcode )

end

function PANEL:AnimSlide( anim, delta, data )

	self:InvalidateLayout()
	self:InvalidateParent()

	if ( anim.Started ) then
		if ( !IsValid( self.Contents ) && ( self.OldHeight || 0 ) < self.Header:GetTall() ) then
			-- We are not using self.Contents and our designated height is less
			-- than the header size, something is clearly wrong, try to rectify
			self.OldHeight = 0
			for id, pnl in pairs( self:GetChildren() ) do
				self.OldHeight = self.OldHeight + pnl:GetTall()
			end
		end

		if ( self:GetExpanded() ) then
			data.To = math.max( self.OldHeight, self:GetTall() )
		else
			data.To = self:GetTall()
		end
	end

	if ( IsValid( self.Contents ) ) then self.Contents:SetVisible( true ) end

	self:SetTall( Lerp( delta, data.From, data.To ) )

end

function PANEL:LoadCookies()

	local Open = self:GetCookieNumber( "Open", 1 ) == 1

	self:SetExpanded( Open )
	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

end

derma.DefineControl( "bricks_server_dcollapsiblecategory", "Collapsable Category Panel", PANEL, "Panel" )

--PATH lua/bricks_server/vgui/bricks_server_dcheckbox.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSize( 45, 50 )

	self.toggle = vgui.Create( "DButton", self )
	self.toggle:Dock( LEFT )
	self.toggle:SetWide( 45 )
	self.toggle:SetText( "" )
	self.toggle.xPos = 0
	self.toggle.Paint = function( self2, w, h )
		local backH = 16
		local circleRadius = math.min( h/2, (backH/2)*1.35 )
		self2.minXPos, self2.maxXPos = circleRadius, w-circleRadius

		draw.RoundedBox( backH/2, 0, (h/2)-(backH/2), w, backH, (self.backgroundCol or BRICKS_SERVER.Func.GetTheme( 3 )) )
		
		if( self.toggled ) then
			self2.xPos = math.Clamp( self2.xPos+3, self2.minXPos, self2.maxXPos )
		else
			self2.xPos = math.Clamp( self2.xPos-3, self2.minXPos, self2.maxXPos )
		end

		BRICKS_SERVER.Func.DrawCircle( self2.xPos, h/2, circleRadius, (self.toggled and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green) or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
	end
	self.toggle.DoClick = function()
		self.toggled = not self.toggled

		if( self.OnChange ) then
			self.OnChange( self.toggled )
		end
	end
end

function PANEL:SetValue( value )
	if( value ) then
		self.toggle.xPos = self.toggle.maxXPos or 0
		self.toggled = true
	else
		self.toggle.xPos = self.toggle.minXPos or 0
		self.toggled = false
	end
end

function PANEL:SetDisabled( value )
	self.toggle:SetDisabled( value )
end

function PANEL:SetTitle( title )
	self.title = title

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local titleX, titleY = surface.GetTextSize( self.title or BRICKS_SERVER.Func.L( "toggle" ) )

	if( title != "" ) then
		self:SetWide( 45+5+titleX )
	else
		self:SetWide( 45 )
	end
end

function PANEL:Paint( w, h )
	draw.SimpleText( (self.title or BRICKS_SERVER.Func.L( "toggle" )), "BRICKS_SERVER_Font20", self.toggle:GetWide()+5, h/2-1, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
end
 
vgui.Register( "bricks_server_dcheckbox", PANEL, "DPanel" )
--PATH lua/bricks_server/vgui/bricks_server_dmenuoption.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_pMenu", "Menu" )
AccessorFunc( PANEL, "m_bChecked", "Checked" )
AccessorFunc( PANEL, "m_bCheckable", "IsCheckable" )

function PANEL:Init()

	self:SetContentAlignment( 4 )
	self:SetChecked( false )

end

function PANEL:SetSubMenu( menu )

	self.SubMenu = menu

	if ( !IsValid( self.SubMenuArrow ) ) then

		self.SubMenuArrow = vgui.Create( "DPanel", self )
		self.SubMenuArrow.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "MenuRightArrow", panel, w, h ) end

	end

end

function PANEL:AddSubMenu()

	local SubMenu = DermaMenu( self )
	SubMenu:SetVisible( false )
	SubMenu:SetParent( self )

	self:SetSubMenu( SubMenu )

	return SubMenu

end

function PANEL:OnCursorEntered()

	if ( IsValid( self.ParentMenu ) ) then
		self.ParentMenu:OpenSubMenu( self, self.SubMenu )
		return
	end

	self:GetParent():OpenSubMenu( self, self.SubMenu )

end

function PANEL:OnCursorExited()
end

function PANEL:Paint( w, h )
	if( self:IsHovered() ) then
		self.changeAlpha = math.Clamp( (self.changeAlpha or 0)+10, 0, 255 )
	else
		self.changeAlpha = math.Clamp( (self.changeAlpha or 0)-10, 0, 255 )
	end

	surface.SetAlphaMultiplier( (self.changeAlpha or 0)/255 )
	if( self.parentPanel.optionCount > 1 and self.position == 1 and not self.ParentMenu.dontRoundTop ) then
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), true, true, false, false )
	elseif( self.parentPanel.optionCount > 1 and self.position == self.parentPanel.optionCount ) then
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), false, false, true, true )
	elseif( self.parentPanel.optionCount == 1 ) then
		if( not self.ParentMenu.dontRoundTop ) then
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		else
			draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), false, false, true, true )
		end
	else
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.DrawRect( 0, 0, w, h )
	end
	surface.SetAlphaMultiplier( 1 )

	draw.SimpleText( self.label or BRICKS_SERVER.Func.L( "error" ), "BRICKS_SERVER_Font20", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	--
	-- Draw the button text
	--
	return false

end

function PANEL:OnMousePressed( mousecode )

	self.m_MenuClicking = true

	DButton.OnMousePressed( self, mousecode )

end

function PANEL:OnMouseReleased( mousecode )

	DButton.OnMouseReleased( self, mousecode )

	if ( self.m_MenuClicking && mousecode == MOUSE_LEFT ) then

		self.m_MenuClicking = false
		CloseDermaMenus()

	end

end

function PANEL:DoRightClick()

	if ( self:GetIsCheckable() ) then
		self:ToggleCheck()
	end

end

function PANEL:DoClickInternal()

	if ( self:GetIsCheckable() ) then
		self:ToggleCheck()
	end

	if ( self.m_pMenu ) then

		self.m_pMenu:OptionSelectedInternal( self )

	end

end

function PANEL:ToggleCheck()

	self:SetChecked( !self:GetChecked() )
	self:OnChecked( self:GetChecked() )

end

function PANEL:OnChecked( b )
end

function PANEL:PerformLayout()

	self:SizeToContents()
	self:SetWide( self:GetWide() + 30 )

	local w = math.max( self:GetParent():GetWide(), self:GetWide() )

	self:SetSize( w, 40 )

	if ( IsValid( self.SubMenuArrow ) ) then

		self.SubMenuArrow:SetSize( 15, 15 )
		self.SubMenuArrow:CenterVertical()
		self.SubMenuArrow:AlignRight( 4 )

	end

	DButton.PerformLayout( self )

end

function PANEL:GenerateExample()

	-- Do nothing!

end

derma.DefineControl( "bricks_server_dmenuoption", "Menu Option Line", PANEL, "DButton" )

--PATH lua/bricks_server/vgui/bricks_server_popupdmenu.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_bDeleteSelf", "DeleteSelf" )

function PANEL:Init()
	self:SetSize( 150, 45 )

	self:SetAlpha( 0 )
	self:AlphaTo( 255, 0.05, 0 )

	self.optionCount = 0
end

local optionH = 45
function PANEL:AddOption( label, onClick, ... )
	local args = { ... }

	self.optionCount = self.optionCount+1

	self:SetTall( self.optionCount*optionH )
	
	local optionButton = vgui.Create( "DButton", self )
	optionButton:Dock( TOP )
	optionButton:SetTall( optionH )
	optionButton:SetText( "" )
	optionButton.OptionPos = self.optionCount
	local alpha = 0
	optionButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			alpha = math.Clamp( alpha+20, 0, 255 )
		else
			alpha = math.Clamp( alpha-20, 0, 255 )
		end

		if( self2.OptionPos == 1 and self.optionCount > 1 ) then
			draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, alpha ), true, true, false, false)
		elseif( self2.OptionPos == self.optionCount and self.optionCount > 1 ) then
			draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, alpha ), false, false, true, true)
		elseif( self.optionCount <= 1 ) then
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, alpha ) )
		else
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, alpha ) )
			surface.DrawRect( 0, 0, w, h )
		end

		draw.SimpleText( label, "BRICKS_SERVER_Font20", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), 1, 1 )
	end
    optionButton.DoClick = function()
        onClick( unpack( args ) )
        self:Remove()
    end
end

function PANEL:Open( parent, x, y )
	self.parent = parent

	self:MakePopup()
	self:SetPos( x, y )
end

function PANEL:Think()
	if( not self:HasFocus() ) then
		if( not self.removeTime ) then
			self.removeTime = CurTime()+0.1
		end
	elseif( self.removeTime ) then
		self.removeTime = nil
	end

	if( not IsValid( self.parent ) or not self.parent:IsVisible() or (self.removeTime and CurTime() >= self.removeTime) ) then
		self:Remove()
	end
end

function PANEL:Paint( w, h )
	local x, y = self:LocalToScreen( 0, 0 )

	BRICKS_SERVER.BSHADOWS.BeginShadow()
	draw.RoundedBox( 8, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )	
	BRICKS_SERVER.BSHADOWS.EndShadow(2, 2, 1, 255, 0, 0, false )
end

vgui.Register( "bricks_server_popupdmenu", PANEL, "DPanel" )
--PATH lua/bricks_server/vgui/bricks_server_rounded_avatar.lua:
local PANEL = {}

function PANEL:Init()
	self.avatar = vgui.Create( "AvatarImage", self )
	self.avatar:SetPaintedManually( true )
end

function PANEL:PerformLayout()
	self.avatar:SetSize( self:GetWide(), self:GetTall() )
end

function PANEL:SetPlayer( ply, size )
	self.avatar:SetPlayer( ply, size )
end

function PANEL:SetSteamID( steamID, size )
	self.avatar:SetSteamID( steamID, size )
end

-- Credits: https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/modules/draw.lua, https://gist.github.com/MysteryPancake/e8d367988ef05e59843f669566a9a59f

local whiteColor = Color( 255, 255, 255 )
local renderTarget, previousRenderTarget
function PANEL:Paint( w, h )
	if( not renderTarget ) then
		renderTarget = GetRenderTargetEx( "BRS_GRADIENT_ROUNDEDAVATAR", ScrW(), ScrH(), RT_SIZE_FULL_FRAME_BUFFER, MATERIAL_RT_DEPTH_NONE, 2, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGBA8888 )
	end

	if( not previousRenderTarget ) then
		previousRenderTarget = render.GetRenderTarget() 
	end

	render.PushRenderTarget( renderTarget )
	render.OverrideAlphaWriteEnable( true, true )
	render.Clear( 0, 0, 0, 0 ) 

	self.avatar:PaintManual()

	--Draw the mask
	render.OverrideBlendFunc( true, BLEND_ZERO, BLEND_SRC_ALPHA, BLEND_DST_ALPHA, BLEND_ZERO )
	draw.RoundedBox( (self.rounded or 0), 0, 0, w, h, whiteColor )
	render.OverrideBlendFunc( false )
	render.OverrideAlphaWriteEnable( false )
	render.PopRenderTarget() 

	--Update material
	BRICKS_SERVER.MaskMaterial:SetTexture( "$basetexture", renderTarget )

	--Clear material for upcoming draw calls
	draw.NoTexture()

	surface.SetDrawColor( 255, 255, 255, 255 ) 
	surface.SetMaterial( BRICKS_SERVER.MaskMaterial ) 
	render.SetMaterial( BRICKS_SERVER.MaskMaterial )
	render.DrawScreenQuad() 
end
 
vgui.Register( "bricks_server_rounded_avatar", PANEL )
--PATH addons/sl_utils/lua/permaprops/cl_menu.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

surface.CreateFont( "pp_font", {
	font = "Arial",
	size = 20,
	weight = 700,
	shadow = false
} )

local function pp_open_menu()

	local Len = net.ReadFloat()
	local Data = net.ReadData( Len )
	local UnCompress = util.Decompress( Data )
	local Content = util.JSONToTable( UnCompress )

 	local Main = vgui.Create( "DFrame" )
	Main:SetSize( 600, 355 )
	Main:Center()
	Main:SetTitle("")
	Main:SetVisible( true )
	Main:SetDraggable( true )
	Main:ShowCloseButton( true )
	Main:MakePopup()
	Main.Paint = function(self)

		draw.RoundedBox( 0, 0, 0, self:GetWide(), self:GetTall(), Color(155, 155, 155, 220) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), self:GetTall() )	

		draw.RoundedBox( 0, 0, 0, self:GetWide(), 25, Color(17, 148, 240, 200) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), 25 )
		draw.DrawText( "PermaProps Config", "pp_font", 10, 2.2, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT )

	end

	local BSelect
	local PSelect

	local MainPanel = vgui.Create( "DPanel", Main )
	MainPanel:SetPos( 190, 51 )
	MainPanel:SetSize( 390, 275 )
	MainPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		surface.DrawOutlinedRect(0, 15, self:GetWide(), 40)
	end
	PSelect = MainPanel

	local MainLabel = vgui.Create("DLabel", MainPanel)
	MainLabel:SetFont("pp_font")
	MainLabel:SetPos(140, 25) 
	MainLabel:SetColor(Color(50, 50, 50, 255)) 
	MainLabel:SetText("Hey ".. LocalPlayer():Nick() .." !") 
	MainLabel:SizeToContents()

	local MainLabel2 = vgui.Create("DLabel", MainPanel)
	MainLabel2:SetFont("pp_font")
	MainLabel2:SetPos(80, 80) 
	MainLabel2:SetColor(Color(50, 50, 50, 255)) 
	MainLabel2:SetText("There are ".. ( Content.MProps or 0 ) .." props on this map.\n\nThere are ".. ( Content.TProps or 0 ) .." props in the DB.") 
	MainLabel2:SizeToContents()

	local RemoveMapProps = vgui.Create( "DButton", MainPanel )
	RemoveMapProps:SetText( " Clear map props " )
	RemoveMapProps:SetFont("pp_font")
	RemoveMapProps:SetSize( 370, 30)
	RemoveMapProps:SetPos( 10, 160 )
	RemoveMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	RemoveMapProps.DoClick = function()
		net.Start("pp_info_send")
			net.WriteTable({CMD = "CLR_MAP"})
		net.SendToServer()
	end
	RemoveMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearMapProps = vgui.Create( "DButton", MainPanel )
	ClearMapProps:SetText( " Clear map props in the DB " )
	ClearMapProps:SetFont("pp_font")
	ClearMapProps:SetSize( 370, 30)
	ClearMapProps:SetPos( 10, 200 )
	ClearMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearMapProps.DoClick = function()

		Derma_Query("Are you sure you want clear map props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_MAP"}) net.SendToServer() end, "Cancel")

	end
	ClearMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearAllProps = vgui.Create( "DButton", MainPanel )
	ClearAllProps:SetText( " Clear all props in the DB " )
	ClearAllProps:SetFont("pp_font")
	ClearAllProps:SetSize( 370, 30)
	ClearAllProps:SetPos( 10, 240 )
	ClearAllProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearAllProps.DoClick = function()

		Derma_Query("Are you sure you want clear all props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_ALL"}) net.SendToServer() end, "Cancel")

	end
	ClearAllProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local BMain = vgui.Create("DButton", Main)
	BSelect = BMain
	BMain:SetText("Main")
	BMain:SetFont("pp_font")
	BMain:SetSize(160, 50)
	BMain:SetPos(15, 27 + 25)
	BMain:SetTextColor( Color( 255, 255, 255, 255 ) )
	BMain.PaintColor = Color(17, 148, 240, 100)
	BMain.Paint = function(self)

		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())

	end
	BMain.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		MainPanel:Show()
		PSelect = MainPanel

	end

	local ConfigPanel = vgui.Create( "DPanel", Main )
	ConfigPanel:SetPos( 190, 51 )
	ConfigPanel:SetSize( 390, 275 )
	ConfigPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	ConfigPanel:Hide()

	local CheckCustom = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckCustom:SetPos( 5, 30 )
	CheckCustom:SetText( "Custom permissions" )
	CheckCustom:SetValue( 0 )
	CheckCustom:SizeToContents()
	CheckCustom:SetTextColor( Color( 0, 0, 0, 255) )
	CheckCustom:SetDisabled( true )

	local GroupsList = vgui.Create( "DComboBox", ConfigPanel )
	GroupsList:SetPos( 5, 5 )
	GroupsList:SetSize( 125, 20 )
	GroupsList:SetValue( "Select a group..." )

	local CheckBox1 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox1:SetPos( 150, 10 )
	CheckBox1:SetText( "Menu" )
	CheckBox1:SizeToContents()
	CheckBox1:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox1:SetDisabled( true )
	CheckBox1.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Menu", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox2 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox2:SetPos( 150, 30 )
	CheckBox2:SetText( "Edit permissions" )
	CheckBox2:SizeToContents()
	CheckBox2:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox2:SetDisabled( true )
	CheckBox2.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Permissions", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox3 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox3:SetPos( 150, 50 )
	CheckBox3:SetText( "Physgun permaprops" )
	CheckBox3:SizeToContents()
	CheckBox3:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox3:SetDisabled( true )
	CheckBox3.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Physgun", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox4 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox4:SetPos( 150, 70 )
	CheckBox4:SetText( "Tool permaprops" )
	CheckBox4:SizeToContents()
	CheckBox4:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox4:SetDisabled( true )
	CheckBox4.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Tool", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox5 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox5:SetPos( 150, 90 )
	CheckBox5:SetText( "Property permaprops" )
	CheckBox5:SizeToContents()
	CheckBox5:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox5:SetDisabled( true )
	CheckBox5.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Property", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox6 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox6:SetPos( 150, 110 )
	CheckBox6:SetText( "Save props" )
	CheckBox6:SizeToContents()
	CheckBox6:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox6:SetDisabled( true )
	CheckBox6.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Save", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox7 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox7:SetPos( 150, 130 )
	CheckBox7:SetText( "Delete permaprops" )
	CheckBox7:SizeToContents()
	CheckBox7:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox7:SetDisabled( true )
	CheckBox7.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Delete", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox8 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox8:SetPos( 150, 150 )
	CheckBox8:SetText( "Update permaprops" )
	CheckBox8:SizeToContents()
	CheckBox8:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox8:SetDisabled( true )
	CheckBox8.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Update", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	GroupsList.OnSelect = function( panel, index, value )
		
		CheckCustom:SetDisabled( false )
		CheckCustom:SetChecked( Content.Permissions[value].Custom )

		CheckBox1:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox1:SetChecked( Content.Permissions[value].Menu )
		CheckBox2:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox2:SetChecked( Content.Permissions[value].Permissions )
		CheckBox3:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox3:SetChecked( Content.Permissions[value].Physgun )
		CheckBox4:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox4:SetChecked( Content.Permissions[value].Tool )
		CheckBox5:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox5:SetChecked( Content.Permissions[value].Property )
		CheckBox6:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox6:SetChecked( Content.Permissions[value].Save )
		CheckBox7:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox7:SetChecked( Content.Permissions[value].Delete )
		CheckBox8:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox8:SetChecked( Content.Permissions[value].Update )

	end

	for k, v in pairs(Content.Permissions) do
		
		GroupsList:AddChoice(k)

	end

	CheckCustom.OnChange = function(Self, Value)

		CheckBox1:SetDisabled( !Value )
		CheckBox2:SetDisabled( !Value )
		CheckBox3:SetDisabled( !Value )
		CheckBox4:SetDisabled( !Value )
		CheckBox5:SetDisabled( !Value )
		CheckBox6:SetDisabled( !Value )
		CheckBox7:SetDisabled( !Value )
		CheckBox8:SetDisabled( !Value )

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Custom", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local BConfig = vgui.Create("DButton", Main)
	BConfig:SetText("Configuration")
	BConfig:SetFont("pp_font")
	BConfig:SetSize(160, 50)
	BConfig:SetPos(15, 71 + 55)
	BConfig:SetTextColor( Color( 255, 255, 255, 255 ) )
	BConfig.PaintColor = Color(0, 0, 0, 0)
	BConfig.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BConfig.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		ConfigPanel:Show()
		PSelect = ConfigPanel

	end

	local PropsPanel = vgui.Create( "DPanel", Main )
	PropsPanel:SetPos( 190, 51 )
	PropsPanel:SetSize( 390, 275 )
	PropsPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	PropsPanel:Hide()

	local PropsList = vgui.Create( "DListView", PropsPanel )
	PropsList:SetMultiSelect( false )
	PropsList:SetSize( 390, 275 )
	local ColID = PropsList:AddColumn( "ID" )
	local ColEnt = PropsList:AddColumn( "Entity" )
	local ColMdl = PropsList:AddColumn( "Model" )
	ColID:SetMinWidth(50)
	ColID:SetMaxWidth(50)
	PropsList.Paint = function( self )
		surface.SetDrawColor(17, 148, 240, 255)
	end

	PropsList.OnRowRightClick = function(panel, line)

		local MenuButtonOptions = DermaMenu()
	    MenuButtonOptions:AddOption("Draw entity", function() 

	    	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then LocalPlayer().DrawPPEnt = {} end

	    	if LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:IsValid() then return end

		    local ent = ents.CreateClientProp( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Model ) 
			ent:SetPos( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Pos )
			ent:SetAngles( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Angle )

			LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = ent

		end )

		if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] then
			
			MenuButtonOptions:AddOption("Stop Drawing", function() 

				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil

			end )

		end

		if LocalPlayer().DrawPPEnt != nil and istable(LocalPlayer().DrawPPEnt) and table.Count(LocalPlayer().DrawPPEnt) > 0 then

			MenuButtonOptions:AddOption("Stop Drawing All", function() 

				for k, v in pairs(LocalPlayer().DrawPPEnt) do
					
					LocalPlayer().DrawPPEnt[k]:Remove()
					LocalPlayer().DrawPPEnt[k] = nil

				end

			end )
			
		end

	    MenuButtonOptions:AddOption("Remove", function()

	    	net.Start("pp_info_send")
	    		net.WriteTable({CMD = "DEL", Val = PropsList:GetLine(line):GetValue(1)})
	    	net.SendToServer()

	    	if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] != nil then

	    		LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil
				
	    	end

	    	PropsList:RemoveLine(line)


		end )
	    MenuButtonOptions:Open()
		
	end

	for k, v in pairs(Content.PropsList) do
		
		PropsList:AddLine(k, v.Class, v.Model)

	end

	local BProps = vgui.Create("DButton", Main)
	BProps:SetText("Props List")
	BProps:SetFont("pp_font")
	BProps:SetSize(160, 50)
	BProps:SetPos(15, 115 + 85)
	BProps:SetTextColor( Color( 255, 255, 255, 255 ) )
	BProps.PaintColor = Color(0, 0, 0, 0)
	BProps.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BProps.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		PropsPanel:Show()
		PSelect = PropsPanel

	end

end
net.Receive("pp_open_menu", pp_open_menu)

--PATH lua/vgui/bvgui/scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(0,0,0,0)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(150,150,150,100)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

derma.DefineControl("bVGUI.ScrollPanel", nil, PANEL, "DScrollPanel")
--PATH lua/vgui/bvgui/vertical_option_selector.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.Buttons = {}
	self.Color = bVGUI.BUTTON_COLOR_BLUE
	self.BorderColor = bVGUI.DarkenColor(self.Color, 0.4)

	self.SelectedButton = 1
end

function PANEL:SetColor(col)
	self.Color = col
	self.BorderColor = bVGUI.DarkenColor(self.Color, 0.4)
end

function PANEL:SelectButton(index)
	self.SelectedButton = index
end

function PANEL:AddButton(text, color)
	local label = vgui.Create("DLabel", self)
	label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	label:SetContentAlignment(5)
	label:SetTextColor(bVGUI.COLOR_WHITE)
	label:SetText(text)
	label.BtnColor = color
	label.BtnBorderColor = bVGUI.DarkenColor(color, 0.4)
	table.insert(self.Buttons, label)

	self:SizeButtons()
end

local grey_col = Color(150,150,150)
local dark_grey_col = bVGUI.DarkenColor(grey_col, 0.4)
function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, dark_grey_col)
	draw.RoundedBoxEx(4, 0, 0, w, h - 4, grey_col, true, true)

	for i,v in ipairs(self.Buttons) do
		draw.RoundedBox(4, 0, (i * (h / #self.Buttons)) - 4, w, 4, dark_grey_col)
	end

	if (IsValid(self.Buttons[self.SelectedButton])) then
		local btn = self.Buttons[self.SelectedButton]

		if (self.LerpY == nil) then
			self.LerpY = (self.SelectedButton - 1) * (h / #self.Buttons)
		else
			self.LerpY = Lerp(FrameTime() * 10, self.LerpY, (self.SelectedButton - 1) * (h / #self.Buttons))
		end

		if (self.LerpBorderColor == nil) then
			self.LerpBorderColor = Color(btn.BtnBorderColor.r, btn.BtnBorderColor.g, btn.BtnBorderColor.b)
		else
			self.LerpBorderColor.r = Lerp(FrameTime() * 10, self.LerpBorderColor.r, btn.BtnBorderColor.r)
			self.LerpBorderColor.g = Lerp(FrameTime() * 10, self.LerpBorderColor.g, btn.BtnBorderColor.g)
			self.LerpBorderColor.b = Lerp(FrameTime() * 10, self.LerpBorderColor.b, btn.BtnBorderColor.b)
		end

		if (self.LerpColor == nil) then
			self.LerpColor = Color(btn.BtnColor.r, btn.BtnColor.g, btn.BtnColor.b)
		else
			self.LerpColor.r = Lerp(FrameTime() * 10, self.LerpColor.r, btn.BtnColor.r)
			self.LerpColor.g = Lerp(FrameTime() * 10, self.LerpColor.g, btn.BtnColor.g)
			self.LerpColor.b = Lerp(FrameTime() * 10, self.LerpColor.b, btn.BtnColor.b)
		end

		draw.RoundedBoxEx(4, 0, self.LerpY, w, h / #self.Buttons, self.LerpBorderColor, true, true, self.SelectedButton == #self.Buttons, self.SelectedButton == #self.Buttons)
		draw.RoundedBoxEx(4, 0, self.LerpY, w, (h / #self.Buttons) - 4, self.LerpColor, self.SelectedButton == 1, self.SelectedButton == 1)
	end
end

function PANEL:SizeButtons()
	local w = 0
	for _,v in ipairs(self.Buttons) do
		v:SizeToContents()
		if (v:GetWide() > w) then
			w = v:GetWide()
		end
	end
	self:SetWide(w + 20)
	for i,v in ipairs(self.Buttons) do
		v:SetWide(w)
	end
end

function PANEL:PerformLayout(w,h)
	for i,v in ipairs(self.Buttons) do
		v:SetSize(w,h / #self.Buttons)
		v:AlignTop((i - 1) * (h / #self.Buttons) - 2)
	end
end

function PANEL:OnMousePressed(m)
	self.MousePressed = m
end
function PANEL:OnMouseReleased(m)
	if (self.MousePressed == m) then
		if (m == MOUSE_LEFT) then
			local x,y = self:ScreenToLocal(gui.MousePos())
			self.SelectedButton = 1 + math.floor((y / self:GetTall()) * #self.Buttons)
			local btn = self.Buttons[self.SelectedButton]
			if (IsValid(btn)) then
				if (self.OptionChanged) then
					self:OptionChanged(btn:GetText())
				end
			end
		end
	end
end

derma.DefineControl("bVGUI.VerticalOptionSelector", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/gas_circles.lua:
/*
	https://github.com/Sneaky-Squid/Circles
	MIT License
*/

local blur = Material("pp/blurscreen")

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE.m_iType = CIRCLE_FILLED

CIRCLE.m_iX = 0
CIRCLE.m_iY = 0
CIRCLE.m_iR = 0

CIRCLE.m_iRotation = 0
CIRCLE.m_iThickness = 1
CIRCLE.m_iQuality = 2
CIRCLE.m_iDensity = 3

CIRCLE.m_iStartAngle = 0
CIRCLE.m_iEndAngle = 360

CIRCLE.m_bRotateMat = true

AccessorFunc(CIRCLE, "m_iType", "Type", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iR", "Radius", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iVertices", "Vertices", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iRotation", "Rotation", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iThickness", "Thickness", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iQuality", "Quality", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iDensity", "Density", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_bRotateMat", "RotateMaterial", FORCE_BOOL)

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:SetRadius(r)
	if (self.m_iR == r) then return end

	self.m_iR = r
	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetVertices(vertices)
	vertices = math.Clamp(vertices, 3, 360)

	if (self.m_iVertices == vertices) then return end

	self.m_iVertices = vertices
	self.m_iSteps = 360 / vertices

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetRotation(rotation)
	if (self.m_iRotation == rotation) then return end

	self.m_iRotation = rotation
	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetThickness(thicc)
	if (self.m_iThickness == thicc) then return end

	self.m_iThickness = thicc
	self.m_cInnerCircle = nil
end

function CIRCLE:SetPos(x, y)
	if (self.m_iX == x and self.m_iY == Y) then return end

	self.m_iX = x
	self.m_iY = y

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetAngles(start, finish)
	if (self.m_iStartAngle == start and self.m_iEndAngle == finish) then return end

	self.m_iStartAngle = math.min(start, finish)
	self.m_iEndAngle = math.max(start, finish)

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:OffsetVertices(x, y)
	if (not self.m_tVertices) then
		self:Calculate()
	end

	x = x or 0
	y = y or 0

	self.m_iX = self.m_iX + x
	self.m_iY = self.m_iY + y

	for i, v in ipairs(self.m_tVertices) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self.m_cInnerCircle) then
		self.m_cInnerCircle:OffsetVertices(x, y)
	end
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local r = self.m_iR
	local x, y = self.m_iX, self.m_iY
	local start, finish = self.m_iStartAngle, self.m_iEndAngle

	local verts, dist = {}, math.Clamp(self.m_iSteps or math.max(8, 360 / (r * math.pi)), 1, 120)

	if (finish - start ~= 360) then
		table.insert(verts, {
			x = x,
			y = y,

			u = 0.5,
			v = 0.5,
		})

		finish = finish + dist
	else
		finish = finish - dist
	end

	for a = start, finish, dist do
		a = math.Clamp(a, start, self.m_iEndAngle)

		local rad = math.rad(a)
		local rot = math.rad(self.m_iRotation)

		table.insert(verts, {
			x = x + math.cos(rad + rot) * r,
			y = y + math.sin(rad + rot) * r,

			u = math.cos(self.m_bRotateMat and rad - rot or rad) / 2 + 0.5,
			v = math.sin(self.m_bRotateMat and rad - rot or rad) / 2 + 0.5,
		})
	end

	self.m_tVertices = verts
end

function CIRCLE:__call(colour, material)
	if (not self.m_tVertices) then
		self:Calculate()
	end

	if (IsColor(colour)) then surface.SetDrawColor(colour) end
	if (TypeID(material) == TYPE_MATERIAL) then surface.SetMaterial(material) elseif (material) then draw.NoTexture() end

	if (self.m_iType == CIRCLE_OUTLINED) then
		if (not self.m_cInnerCircle) then
			local inner = self:Copy()

			inner:SetType(CIRCLE_FILLED)
			inner:SetRadius(self.m_iR - self.m_iThickness)

			self.m_cInnerCircle = inner
		end

		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilReferenceValue(1)
			render.SetStencilWriteMask(1)
			render.SetStencilTestMask(1)

			render.SetStencilPassOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self.m_cInnerCircle()

			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_GREATER)

			surface.DrawPoly(self.m_tVertices)
		render.SetStencilEnable(false)
	elseif (self.m_iType == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilReferenceValue(1)
			render.SetStencilWriteMask(1)
			render.SetStencilTestMask(1)

			render.SetStencilPassOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self.m_tVertices)

			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)

			surface.SetMaterial(blur)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self.m_iQuality do
				blur:SetFloat("$blur", (i / self.m_iQuality) * self.m_iDensity)
				blur:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self.m_tVertices)
	end
end

debug.getregistry()["Circle"] = CIRCLE

function GAS_NewCircle(type)
	return setmetatable({m_iType = tonumber(type)}, CIRCLE)
end
--PATH lua/vgui/openpermissions_checkbox.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:SetSize(16,16)

	self.Crossable = false
	self.Checked = false
end

function PANEL:SetCrossable(crossable)
	self.Crossable = crossable == true
	if (crossable) then
		self.Checked = 0
	else
		self.Checked = false
	end
end
function PANEL:IsCrossable()
	return self.Crossable
end

function PANEL:DoClick()
	self:SetAmbigious(false)
	if (self.Crossable) then
		self.Checked = self.Checked + 1
		if (self.Checked == 3) then
			self.Checked = 0
		end
	else
		self.Checked = not self.Checked
	end
	if (self.OnChange) then
		self:OnChange()
	end
end
function PANEL:DoRightClick()
	if (self.Crossable) then
		self:SetAmbigious(false)
		self.Checked = self.Checked - 1
		if (self.Checked == -1) then
			self.Checked = 2
		end
		if (self.OnChange) then
			self:OnChange()
		end
	end
end

function PANEL:OnMousePressed(m)
	if (m == MOUSE_LEFT) then
		self.Debounce_LEFT = true
	elseif (m == MOUSE_RIGHT) then
		self.Debounce_RIGHT = true
	end
end
function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		if (self.Debounce_LEFT) then
			self:DoClick()
		end
		self.Debounce_LEFT = nil
	elseif (m == MOUSE_RIGHT) then
		if (self.Debounce_RIGHT) then
			self:DoRightClick()
		end
		self.Debounce_RIGHT = nil
	end
end

function PANEL:GetChecked()
	return self.Checked
end
function PANEL:SetChecked(checked)
	self:SetAmbigious(false)
	self.Checked = checked
end

function PANEL:SetAmbigious(ambigious)
	self.Ambigious = ambigious
end
function PANEL:IsAmbigious()
	return self.Ambigious
end

local mat_checked = Material("openpermissions/checked.vtf")
local mat_crossed = Material("openpermissions/crossed.vtf")
local darker_soft_green = Color(52,145,52)
function PANEL:Paint(w,h)
	surface.SetDrawColor(OpenPermissions.COLOR_WHITE)
	surface.DrawRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(darker_soft_green)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_RED)
	else
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	end
	surface.DrawOutlinedRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_GREEN)
		surface.DrawRect(3,3,w - 6, h - 6)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_checked)
		surface.DrawTexturedRect(0,0,w,h)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_crossed)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

derma.DefineControl("OpenPermissions.Checkbox", nil, PANEL, "DPanel")
--PATH lua/vgui/openpermissions_combobox.lua:

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "ComboBox" )

Derma_Install_Convar_Functions( PANEL )

AccessorFunc( PANEL, "m_bDoSort", "SortItems", FORCE_BOOL )

function PANEL:Init()

	self.DropButton = vgui.Create( "DPanel", self )
	self.DropButton.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ComboDownArrow", panel, w, h ) end
	self.DropButton:SetMouseInputEnabled( false )
	self.DropButton.ComboBox = self

	self:SetTall( 22 )
	self:Clear()

	self:SetContentAlignment( 4 )
	self:SetTextInset( 8, 0 )
	self:SetIsMenu( true )
	self:SetSortItems( true )

end

function PANEL:Clear()

	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:GetOptionText( id )

	return self.Choices[ id ]

end

function PANEL:GetOptionData( id )

	return self.Data[ id ]

end

function PANEL:GetOptionTextByData( data )

	for id, dat in pairs( self.Data ) do
		if ( dat == data ) then
			return self:GetOptionText( id )
		end
	end

	-- Try interpreting it as a number
	for id, dat in pairs( self.Data ) do
		if ( dat == tonumber( data ) ) then
			return self:GetOptionText( id )
		end
	end

	-- In case we fail
	return data

end

function PANEL:PerformLayout()

	self.DropButton:SetSize( 15, 15 )
	self.DropButton:AlignRight( 4 )
	self.DropButton:CenterVertical()

end

function PANEL:ChooseOption( value, index )

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self:SetText( value )

	-- This should really be the here, but it is too late now and convar changes are handled differently by different child elements
	--self:ConVarChanged( self.Data[ index ] )

	self.selected = index
	self:OnSelect( index, value, self.Data[ index ] )

end

function PANEL:ChooseOptionID( index )

	local value = self:GetOptionText( index )
	self:ChooseOption( value, index )

end

function PANEL:GetSelectedID()

	return self.selected

end

function PANEL:GetSelected()

	if ( !self.selected ) then return end

	return self:GetOptionText( self.selected ), self:GetOptionData( self.selected )

end

function PANEL:OnSelect( index, value, data )

	-- For override

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end
	
	if ( icon ) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:IsMenuOpen()

	return IsValid( self.Menu ) && self.Menu:IsVisible()

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = DermaMenu( false, self )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val, spacer = self.Spacers[ k ] } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( v.spacer ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

function PANEL:CloseMenu()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
	end

end

-- This really should use a convar change hook
function PANEL:CheckConVarChanges()

	if ( !self.m_strConVar ) then return end

	local strValue = GetConVarString( self.m_strConVar )
	if ( self.m_strConVarValue == strValue ) then return end

	self.m_strConVarValue = strValue

	self:SetValue( self:GetOptionTextByData( self.m_strConVarValue ) )

end

function PANEL:Think()

	self:CheckConVarChanges()

end

function PANEL:SetValue( strValue )

	self:SetText( strValue )

end

function PANEL:DoClick()

	if ( self:IsMenuOpen() ) then
		return self:CloseMenu()
	end

	self:OpenMenu()

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:AddChoice( "Some Choice" )
	ctrl:AddChoice( "Another Choice", "myData" )
	ctrl:AddChoice( "Default Choice", "myData2", true )
	ctrl:AddChoice( "Icon Choice", "myData3", false, "icon16/star.png" )
	ctrl:SetWide( 150 )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "OpenPermissions.ComboBox", nil, PANEL, "DButton" )

--PATH gamemodes/mangarp/gamemode/libraries/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://docs.google.com/document/d/1QIRVcAgZfAYf1aBl_dNV_ewR6P25wze2KmUVzlbFgMI

Structures:
    CAMI_USERGROUP, defines the charactaristics of a usergroup:
    {
        Name
            string
            The name of the usergroup
        Inherits
            string
            The name of the usergroup this usergroup inherits from
    }

    CAMI_PRIVILEGE, defines the charactaristics of a privilege:
    {
        Name
            string
            The name of the privilege
        MinAccess
            string
            One of the following three: user/admin/superadmin
        Description
            string
            optional
            A text describing the purpose of the privilege
        HasAccess
            function(
                privilege :: CAMI_PRIVILEGE,
                actor     :: Player,
                target    :: Player
            ) :: bool
            optional
            Function that decides whether a player can execute this privilege,
            optionally on another player (target).
    }
]]

-- Version number in YearMonthDay format.
local version = 20190102

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version

--[[
usergroups
    Contains the registered CAMI_USERGROUP usergroup structures.
    Indexed by usergroup name.
]]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user"
    },
    admin = {
        Name = "admin",
        Inherits = "user"
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin"
    }
}

--[[
privileges
    Contains the registered CAMI_PRIVILEGE privilege structures.
    Indexed by privilege name.
]]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--[[
CAMI.RegisterUsergroup
    Registers a usergroup with CAMI.

    Parameters:
        usergroup
            CAMI_USERGROUP
            (see CAMI_USERGROUP structure)
        source
            any
            Identifier for your own admin mod. Can be anything.
            Use this to make sure CAMI.RegisterUsergroup function and the
            CAMI.OnUsergroupRegistered hook don't cause an infinite loop



    Return value:
        CAMI_USERGROUP
            The usergroup given as argument.
]]
function CAMI.RegisterUsergroup(usergroup, source)
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--[[
CAMI.UnregisterUsergroup
    Unregisters a usergroup from CAMI. This will call a hook that will notify
    all other admin mods of the removal.

    Call only when the usergroup is to be permanently removed.

    Parameters:
        usergroupName
            string
            The name of the usergroup.
        source
            any
            Identifier for your own admin mod. Can be anything.
            Use this to make sure CAMI.UnregisterUsergroup function and the
            CAMI.OnUsergroupUnregistered hook don't cause an infinite loop

    Return value:
        bool
            Whether the unregistering succeeded.
]]
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--[[
CAMI.GetUsergroups
    Retrieves all registered usergroups.

    Return value:
        Table of CAMI_USERGROUP, indexed by their names.
]]
function CAMI.GetUsergroups()
    return usergroups
end

--[[
CAMI.GetUsergroup
    Receives information about a usergroup.

    Return value:
        CAMI_USERGROUP
            Returns nil when the usergroup does not exist.
]]
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--[[
CAMI.UsergroupInherits
    Returns true when usergroupName1 inherits usergroupName2.
    Note that usergroupName1 does not need to be a direct child.
    Every usergroup trivially inherits itself.

    Parameters:
        usergroupName1
            string
            The name of the usergroup that is queried.
        usergroupName2
            string
            The name of the usergroup of which is queried whether usergroupName
            inherits from.

    Return value:
        bool
            Whether usergroupName1 inherits usergroupName2.
]]
function CAMI.UsergroupInherits(usergroupName1, usergroupName2)
    repeat
        if usergroupName1 == usergroupName2 then return true end

        usergroupName1 = usergroups[usergroupName1] and
                         usergroups[usergroupName1].Inherits or
                         usergroupName1
    until not usergroups[usergroupName1] or
          usergroups[usergroupName1].Inherits == usergroupName1

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName1 == usergroupName2 or usergroupName2 == "user"
end

--[[
CAMI.InheritanceRoot
    All usergroups must eventually inherit either user, admin or superadmin.
    Regardless of what inheritance mechism an admin may or may not have, this
    always applies.

    This method always returns either user, admin or superadmin, based on what
    usergroups eventually inherit.

    Parameters:
        usergroupName
            string
            The name of the usergroup of which the root of inheritance is
            requested

    Return value:
        string
            The name of the root usergroup (either user, admin or superadmin)
]]
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--[[
CAMI.RegisterPrivilege
    Registers a privilege with CAMI.
    Note: do NOT register all your admin mod's privileges with this function!
    This function is for third party addons to register privileges
    with admin mods, not for admin mods sharing the privileges amongst one
    another.

    Parameters:
        privilege
            CAMI_PRIVILEGE
            See CAMI_PRIVILEGE structure.

    Return value:
        CAMI_PRIVILEGE
            The privilege given as argument.
]]
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--[[
CAMI.UnregisterPrivilege
    Unregisters a privilege from CAMI. This will call a hook that will notify
    all other admin mods of the removal.

    Call only when the privilege is to be permanently removed.

    Parameters:
        privilegeName
            string
            The name of the privilege.

    Return value:
        bool
            Whether the unregistering succeeded.
]]
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--[[
CAMI.GetPrivileges
    Retrieves all registered privileges.

    Return value:
        Table of CAMI_PRIVILEGE, indexed by their names.
]]
function CAMI.GetPrivileges()
    return privileges
end

--[[
CAMI.GetPrivilege
    Receives information about a privilege.

    Return value:
        CAMI_PRIVILEGE when the privilege exists.
            nil when the privilege does not exist.
]]
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

--[[
CAMI.PlayerHasAccess
    Queries whether a certain player has the right to perform a certain action.

    Parameters:
        actorPly
            Player
            The player of which is requested whether they have the privilege.
        privilegeName
            string
            The name of the privilege.
        callback
            function(bool, string) or nil
            This function will be called with the answer. The bool signifies the
            yes or no answer as to whether the player is allowed. The string
            will optionally give a reason.

            Give an explicit nil here to get an answer immediately
                Important note: May throw an error when the admin mod doesn't
                give an answer immediately!
        targetPly
            Optional.
            The player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                Fallback
                    string
                    Either of user/admin/superadmin. When no admin mod replies,
                    the decision is based on the admin status of the user.
                    Defaults to admin if not given.
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.

    Return value:
        If callback is specified:
            None
        Otherwise:
            hasAccess
                bool
                Whether the player has access
            reason
                Optional.
                The reason why a player does or does not have access.
]]
-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, _, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        callback(
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()
            , "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--[[
CAMI.GetPlayersWithAccess
    Finds the list of currently joined players who have the right to perform a
    certain action.
    NOTE: this function will NOT return an immediate result!
    The result is in the callback!

    Parameters:
        privilegeName
            string
            The name of the privilege.
        callback
            function(players)
            This function will be called with the list of players with access.
        targetPly
            Optional.
            The player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                Fallback
                    string
                    Either of user/admin/superadmin. When no admin mod replies,
                    the decision is based on the admin status of the user.
                    Defaults to admin if not given.
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.
]]
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--[[
CAMI.SteamIDHasAccess
    Queries whether a player with a steam ID has the right to perform a certain
    action.
    Note: the player does not need to be in the server for this to
    work.

    Note: this function does NOT return an immediate result!
    The result is in the callback!

    Parameters:
        actorSteam
            Player
            The SteamID of the player of which is requested whether they have
            the privilege.
        privilegeName
            string
            The name of the privilege.
        callback
            function(bool, string)
            This function will be called with the answer. The bool signifies the
            yes or no answer as to whether the player is allowed. The string
            will optionally give a reason.
        targetSteam
            Optional.
            The SteamID of the player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.

    Return value:
        None, the answer is given in the callback function in order to allow
        for the admin mod to perform e.g. a database lookup.
]]
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--[[
CAMI.SignalUserGroupChanged
    Signify that your admin mod has changed the usergroup of a player. This
    function communicates to other admin mods what it thinks the usergroup
    of a player should be.

    Listen to the hook to receive the usergroup changes of other admin mods.

    Parameters:
        ply
            Player
            The player for which the usergroup is changed
        old
            string
            The previous usergroup of the player.
        new
            string
            The new usergroup of the player.
        source
            any
            Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--[[
CAMI.SignalSteamIDUserGroupChanged
    Signify that your admin mod has changed the usergroup of a disconnected
    player. This communicates to other admin mods what it thinks the usergroup
    of a player should be.

    Listen to the hook to receive the usergroup changes of other admin mods.

    Parameters:
        ply
            string
            The steam ID of the player for which the usergroup is changed
        old
            string
            The previous usergroup of the player.
        new
            string
            The new usergroup of the player.
        source
            any
            Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH lua/darkrp_config/disabled_defaults.lua:
DarkRP.disabledDefaults["modules"] = {
	["afk"]              = true,
	["chatsounds"]       = false,
	["events"]           = true,
	["fpp"]              = false,
	["f1menu"]           = true,
	["f4menu"]           = false,
	["hitmenu"]          = false,
	["fadmin"]           = false,
	["hud"]              = false,
	["hungermod"]        = true,
	["playerscale"]      = false,
	["sleep"]            = true,
	["chatindicator"]	 = true,
}

DarkRP.disabledDefaults["entities"] = {
	["Drug lab"]      = true,
	["Gun lab"]       = true,
	["Money printer"] = true,
	["Microwave"]     = true,
}

DarkRP.disabledDefaults["agendas"] = {
	["Gangster's agenda"] = true,
	["Police agenda"] = true,
}

DarkRP.disabledDefaults["jobs"] = {
    ["chief"]     = true,
    ["citizen"]   = false,
    ["cook"]      = true, --Hungermod only
    ["cp"]        = true,
    ["gangster"]  = true,
    ["gundealer"] = true,
    ["hobo"]      = true,
    ["mayor"]     = true,
    ["medic"]     = true,
    ["mobboss"]   = true,
}

--PATH gamemodes/mangarp/gamemode/modules/language/sh_english.lua:
--[[-----------------------------------------------------------------------
English (example) language file
---------------------------------------------------------------------------

This is the english language file. The things on the left side of the equals sign are the things you should leave alone
The parts between the quotes are the parts you should translate. You can also copy this file and create a new language.

= Warning =
Sometimes when DarkRP is updated, new phrases are added.
If you don't translate these phrases to your language, it will use the English sentence.
To fix this, join your server, open your console and enter darkp_getphrases yourlanguage
For English the command would be:
    darkrp_getphrases "en"
because "en" is the language code for English.

You can copy the missing phrases to this file and translate them.

= Note =
Make sure the language code is right at the bottom of this file

= Using a language =
Make sure the convar gmod_language is set to your language code. You can do that in a server CFG file.
---------------------------------------------------------------------------]]

local my_language = {
    -- Admin things
    need_admin = "Vous avez besoin des privil√®ges admin pour pouvoir %s",
    need_sadmin = "Vous avez besoin des privil√®ges super admin pour pouvoir %s",
    no_privilege = "Vous n'avez pas les bons privil√®ges pour effectuer cette action",
    no_jail_pos = "Pas de position de prison",
    invalid_x = "%s invalide¬†! %s",

    -- F1 menu
    f1ChatCommandTitle = "Commandes de chat",
    f1Search = "Recherche...",

    -- Money things:
    price = "Prix¬†: %s%d",
    priceTag = "Prix¬†: %s",
    reset_money = "%s a remis √† z√©ro l'argent de tous les joueurs¬†!",
    has_given = "%s vous a donn√© %s",
    you_gave = "Vous avez donn√© %s %s",
    npc_killpay = "%s pour avoir tu√© un NPC¬†!",
    profit = "b√©n√©fice",
    loss = "perte",
    Donate = "Donner",
    you_donated = "Vous avez donn√© %s √† %s¬†!",
    has_donated = "%s a donn√© %s¬†!",

    -- backwards compatibility
    deducted_x = "D√©duit %s%d",
    need_x = "Manque %s%d",

    deducted_money = "D√©duit %s",
    need_money = "Manque %s",

    payday_message = "Jour de paie¬†! Vous avez re√ßu %s¬†!",
    payday_unemployed = "Vous n'avez pas re√ßu de salaire car vous √™tes sans emploi¬†!",
    payday_missed = "Jour de paie manqu√©¬†! (Vous √™tes arr√™t√©)",

    property_tax = "Taxe de propri√©t√©¬†! %s",
    property_tax_cant_afford = "Vous n'avez pas pu payer les taxes¬†! Votre propri√©t√© a √©t√© saisie¬†!",
    taxday = "Jour de taxe¬†! %s%% de vos revenus ont √©t√© pr√©lev√©s¬†!",

    found_cheque = "Vous avez trouv√© %s%s dans un ch√®que √† votre nom sign√© par %s.",
    cheque_details = "Ce ch√®que est √† l'ordre de %s.",
    cheque_torn = "Vous avez d√©chir√© le ch√®que.",
    cheque_pay = "Pay√©¬†: %s",
    signed = "Sign√©¬†: %s",

    found_cash = "Vous avez trouv√© %s%d¬†!", -- backwards compatibility
    found_money = "Vous avez trouv√© %s¬†!",

    owner_poor = "Le propri√©taire de %s est trop pauvre pour subventionner cette vente¬†!",

    -- Police
    Wanted_text = "Recherch√©¬†!",
    wanted = "Recherch√© par la Police¬†!\nMotif¬†: %s",
    youre_arrested = "Vous avez √©t√© arr√™t√© pour %d secondes¬†!",
    youre_arrested_by = "Vous avez √©t√© arr√™t√© par %s.",
    youre_unarrested_by = "Vous avez √©t√© rel√¢ch√© par %s.",
    hes_arrested = "%s a √©t√© arr√™t√© pour %d secondes¬†!",
    hes_unarrested = "%s a √©t√© lib√©r√© de prison¬†!",
    warrant_ordered = "%s a ordonn√© une perquisition chez %s. Motif¬†: %s",
    warrant_request = "%s a demand√© un mandat de perquisition chez %s\nMotif¬†: %s",
    warrant_request2 = "Demande de mandat de perquisition envoy√©e au Maire %s¬†!",
    warrant_approved = "Mandat de perquisition approuv√© pour %s¬†!\nMotif¬†: %s\nOrdonn√© par¬†: %s",
    warrant_approved2 = "Vous avez maintenant la possibilit√© de fouiller sa maison.",
    warrant_denied = "Le Maire %s a d√©sapprouv√© votre demande de mandat de perquisition.",
    warrant_expired = "Le mandat de perquisition chez %s a expir√©¬†!",
    warrant_required = "Vous avez besoin d'un mandat pour avoir le droit d'ouvrir cette porte.",
    warrant_required_unfreeze = "Vous avez besoin d'un mandat pour avoir le droit de d√©geler cet objet.",
    warrant_required_unweld = "Vous avez besoin d'un mandat pour avoir le droit de dessouder cet objet.",
    wanted_by_police = "%s est recherch√© par la police¬†!\nMotif¬†: %s\nOrdonn√© par¬†: %s",
    wanted_by_police_print = "%s √©mis un avis de recherche de %s, motif¬†: %s",
    wanted_expired = "%s n'est plus recherch√© par la Police.",
    wanted_revoked = "%s n'est plus recherch√© par la Police.\nR√©voqu√© par¬†: %s",
    cant_arrest_other_cp = "Vous ne pouvez pas arr√™ter d'autres policiers¬†!",
    must_be_wanted_for_arrest = "Le joueur doit √™tre recherch√© pour que vous puissiez l'arr√™ter.",
    cant_arrest_fadmin_jailed = "Vous ne pouvez pas arr√™ter un joueur qui a √©t√© emprisonn√© par un admin.",
    cant_arrest_no_jail_pos = "Vous ne pouvez arr√™ter personne puisqu'il n'y a pas de positions d'emprisonnement d√©finies¬†!",
    cant_arrest_spawning_players = "Vous ne pouvez pas arr√™ter des joueurs en train d'appara√Ætre.",
    
    not_warranted = "Il n'y a pas de mandat de perquisition pour cette personne.",
    remove_a_warrant = "retirer un mandat",

    suspect_doesnt_exist = "Suspect n'existe pas.",
    actor_doesnt_exist = "Actor n'existe pas.",
    get_a_warrant = "obtenir un mandat",
    make_someone_wanted = "√©mettre un avis de recherche",
    remove_wanted_status = "retirer le statut de recherch√©",
    already_a_warrant = "Il y a d√©j√† un mandat de perquisition chez ce suspect.",
    already_wanted = "Le suspect est d√©j√† recherch√©.",
    not_wanted = "Le suspect n'est pas recherch√©.",
    need_to_be_cp = "Vous devez √™tre membre des forces de police.",
    suspect_must_be_alive_to_do_x = "Le suspect doit √™tre vivant pour %s.",
    suspect_already_arrested = "Le suspect est d√©j√† en prison.",

    -- Players
    health = "Sant√©¬†: %s",
    job = "M√©tier¬†: %s",
    salary = "Salaire¬†: %s%s",
    wallet = "Portefeuille¬†: %s%s",
    weapon = "Arme¬†: %s",
    kills = "Meurtres¬†: %s",
    deaths = "D√©c√®s¬†: %s",
    rpname_changed = "%s a chang√© son nom RP en¬†: %s",
    disconnected_player = "Joueur d√©connect√©",

    -- Teams
    need_to_be_before = "Vous devez d'abord √™tre %s pour pouvoir devenir %s",
    need_to_make_vote = "Vous devez faire un vote pour devenir %s¬†!",
    team_limit_reached = "Vous ne pouvez pas devenir %s car la limite est atteinte",
    wants_to_be = "%s\nveut √™tre\n%s",
    has_not_been_made_team = "%s n'est pas devenu %s¬†!",
    job_has_become = "%s est devenu %s¬†!",

    -- Disasters
    meteor_approaching = "AVERTISSEMENT¬†: Temp√™te de m√©t√©ores en approche¬†!",
    meteor_passing = "Temp√™te de m√©t√©ores en cours.",
    meteor_enabled = "Les Temp√™tes de M√©t√©ores sont maintenant activ√©es.",
    meteor_disabled = "Les Temp√™tes de M√©t√©ores sont maintenant d√©sactiv√©es",
    earthquake_report = "Tremblement de terre signal√© avec une magnitude de %sMw",
    earthtremor_report = "Secousse sismique signal√©e avec une magnitude de %sMw",

    -- Keys, vehicles and doors
    keys_allowed_to_coown = "Vous √™tes autoris√© √† √™tre cod√©tenteur de ceci\n(Appuyez sur Recharger avec les cl√©s ou appuyez sur F2 pour devenir cod√©tenteur)\n",
    keys_other_allowed = "Autoris√©s √† devenir cod√©tenteurs¬†:",
    keys_allow_ownership = "(Appuyez sur Recharger avec les cl√©s ou appuyez sur F2 pour autoriser la possession)",
    keys_disallow_ownership = "(Appuyez sur Recharger avec les cl√©s ou appuyez sur F2 pour interdire la possession)",
    keys_owned_by = "D√©tenu par¬†:",
    keys_unowned = "Aucun propri√©taire\n(Appuyez sur Recharger avec les cl√©s ou appuyez sur F2 pour acqu√©rir)",
    keys_everyone = "(Appuyez sur Recharger avec les cl√©s ou appuyez sur F2 pour activer pour tout le monde)",
    door_unown_arrested = "Vous ne pouvez pas acqu√©rir ou revendre des choses lorsque vous √™tes arr√™t√©¬†!",
    door_unownable = "Cette porte ne peut ni √™tre acquise ni √™tre vendue¬†!",
    door_sold = "Vous avez vendu ceci pour %s",
    door_already_owned = "Cette porte est d√©j√† d√©tenue par quelqu'un¬†!",
    door_cannot_afford = "Vous ne pouvez pas vous payer cette porte¬†!",
    door_hobo_unable = "Vous ne pouvez pas acheter une porte si vous √™tes un clochard¬†!",
    vehicle_cannot_afford = "Vous ne pouvez pas vous payer ce v√©hicule¬†!",
    door_bought = "Vous avez achet√© cette porte pour %s%s",
    vehicle_bought = "Vous avez achet√© ce v√©hicule pour %s%s",
    door_need_to_own = "Vous devez d√©tenir cette porte afin de pouvoir %s",
    door_rem_owners_unownable = "Vous ne pouvez pas supprimer des d√©tenteurs si une porte est non-d√©tenable¬†!",
    door_add_owners_unownable = "Vous ne pouvez pas ajouter des d√©tenteurs si une porte est non-d√©tenable¬†!",
    rp_addowner_already_owns_door = "%s poss√®de d√©j√† (ou est autoris√© √† poss√©der) cette porte¬†!",
    add_owner = "Ajouter un propri√©taire",
    remove_owner = "Supprimer un propri√©taire",
    coown_x = "Co-d√©tenir %s",
    allow_ownership = "Autoriser la possession",
    disallow_ownership = "Interdire la possession",
    edit_door_group = "√âditer le groupe de portes",
    door_groups = "Groupe de portes",
    door_group_doesnt_exist = "Le groupe de portes n'existe pas¬†!",
    door_group_set = "Groupe de porte affect√© avec succ√®s.",
    sold_x_doors_for_y = "Vous avez vendu %d portes pour %s%d¬†!", -- backwards compatibility
    sold_x_doors = "Vous avez vendu %d portes pour %s¬†!",

    -- Entities
    drugs = "stup√©fiants",
    Drugs = "Stup√©fiants",
    drug_lab = "Laboratoire de Drogue",
    gun_lab = "Laboratoire de Flingue",
    any_lab = "un laboratoire", -- √Ä REVOIR
    gun = "pistolet",
    microwave = "Four √† micro-ondes",
    food = "nourriture",
    Food = "Nourriture",
    money_printer = "Imprimante de Billets",
    tip_jar = "Pot √† Pourboires",

    sign_this_letter = "Signer cette lettre",
    signed_yours = "Cordialement,",

    money_printer_exploded = "Votre imprimante de billets a explos√©¬†!",
    money_printer_overheating = "Votre imprimante de billets surchauffe¬†!",

    contents = "Contenu¬†: ",
    amount = "Total¬†: ",

    picking_lock = "Outil de crochetage",

    cannot_pocket_x = "Vous ne pouvez pas mettre ceci dans votre poche¬†!",
    object_too_heavy = "Cet objet est trop gros.",
    pocket_full = "Votre poche est pleine¬†!",
    pocket_no_items = "Votre poche ne contient aucun √©l√©ment.",
    drop_item = "Laisser tomber l'objet",

    bonus_destroying_entity = "en d√©truisant cette entit√© ill√©gale.",

    switched_burst = "Chang√© en mode rafale.",
    switched_fully_auto = "Chang√© en mode automatique.",
    switched_semi_auto = "Chang√© en mode semi-automatique.",

    keypad_checker_shoot_keypad = "Tirez sur un pav√© num√©rique pour voir ce qu'il contr√¥le.",
    keypad_checker_shoot_entity = "Tirez sur une entit√© pour voir quels pav√©s num√©riques y sont connect√©s",
    keypad_checker_click_to_clear = "Click droit pour vider.",
    keypad_checker_entering_right_pass = "Entrant le bon mot de passe", -- √Ä REVOIR
    keypad_checker_entering_wrong_pass = "Entrant un mauvais mot de passe", -- √Ä REVOIR
    keypad_checker_after_right_pass = "apr√®s avoir entr√© le bon mot de passe",
    keypad_checker_after_wrong_pass = "apr√®s avoir entr√© un mauvais mot de passe",
    keypad_checker_right_pass_entered = "Bon mot de passe entr√©",
    keypad_checker_wrong_pass_entered = "Mauvais mot de passe entr√©",
    keypad_checker_controls_x_entities = "Ce pav√© num√©rique contr√¥le %d entit√©s",
    keypad_checker_controlled_by_x_keypads = "Cette entit√© est contr√¥l√©e par %d pav√©s num√©riques",
    keypad_on = "ON",
    keypad_off = "OFF",
    seconds = "secondes",

    persons_weapons = "Armes ill√©gales de %s¬†:",
    returned_persons_weapons = "Armes confisqu√©es de %s rendues.",
    no_weapons_confiscated = "%s n'avait pas d'armes confisqu√©es¬†!",
    no_illegal_weapons = "%s n'avait pas d'armes ill√©gales.",
    confiscated_these_weapons = "Ces armes ont √©t√© confisqu√©es¬†:",
    checking_weapons = "V√©rification des armes",

    shipment_antispam_wait = "Attendez SVP avant de faire appara√Ætre une nouvelle cargaison.",
    shipment_cannot_split = "Cette cargaison ne peut pas se scinder.",

    -- Talking
    hear_noone = "Personne ne peut vous entendre %s¬†!",
    hear_everyone = "Tout le monde peut vous entendre¬†!",
    hear_certain_persons = "Joueurs pouvant vous entendre %s¬†: ",

    whisper = "chuchoter",
    yell = "hurler",
    advert = "[Pub]",
    broadcast = "[Diffusion¬†!]",
    radio = "radio",
    request = "(REQU√äTE¬†!)",
    group = "(groupe)",
    demote = "(DEMOTE)", -- NOT TRANSLATED
    ooc = "GLOBAL",
    radio_x = "Radio %d",

    talk = "parler",
    speak = "parler",

    speak_in_ooc = "parler hors RP",
    perform_your_action = "effectuer votre action",
    talk_to_your_group = "parler √† votre groupe",

    channel_set_to_x = "Canal r√©gl√© sur %s¬†!",

    -- Notifies
    disabled = "%s a √©t√© d√©sactiv√©e¬†! %s",
    gm_spawnvehicle = "L'apparition de v√©hicules",
    gm_spawnsent = "L'apparition d'entit√©s script√©es (SENT)",
    gm_spawnnpc = "L'apparition de personnages non-joueurs (NPC)",
    see_settings = "Regardez SVP les r√©glages du DarkRP.",
    limit = "Vous avez atteint la limite de %s¬†!",
    have_to_wait = "Vous devez attendre encore %d secondes avant de pouvoir utiliser %s¬†!",
    must_be_looking_at = "Vous devez regarder un(e) %s¬†!",
    incorrect_job = "Vous n'avez pas le bon m√©tier pour %s",
    unavailable = "Ce %s n'est pas disponible",
    unable = "Vous ne pouvez pas %s. %s",
    cant_afford = "Vous ne pouvez pas vous payer ce/cette %s",
    created_x = "%s a cr√©√© un %s",
    cleaned_up = "Vos %s ont √©t√© nettoy√©(e)s.",
    you_bought_x = "Vous avez achet√© %s pour %s%d.", -- backwards compatibility
    you_bought = "Vous avez achet√© %s pour %s.",
    you_got_yourself = "You avez pris un(e) %s.", -- √Ä REVOIR
    you_received_x = "Vous avez re√ßu %s pour %s.",

    created_first_jailpos = "Vous avez cr√©√© le premier emplacement d'emprisonnement¬†!",
    added_jailpos = "Vous avez ajout√© un emplacement d'emprisonnement suppl√©mentaire¬†!",
    reset_add_jailpos = "Vous avez supprim√© tous les emplacements d'emprisonnement et vous en avez ajout√© un ici.",
    created_spawnpos = "Emplacement d'apparition de %s cr√©√©.",
    updated_spawnpos = "Emplacement d'apparition de %s mis √† jour.",
    do_not_own_ent = "Vous ne poss√©dez pas cette entit√©¬†!",
    cannot_drop_weapon = "Cette arme ne peut pas √™tre l√¢ch√©e¬†!",
    job_switch = "M√©tiers chang√©s avec succ√®s¬†!",
    job_switch_question = "Changer de m√©tier en %s¬†?",
    job_switch_requested = "Changement de m√©tier demand√©.",

    cooks_only = "Cuisiniers seulement.",

    -- Misc
    unknown = "Inconnu",
    arguments = "arguments",
    no_one = "personne",
    door = "porte",
    vehicle = "v√©hicule",
    door_or_vehicle = "porte/v√©hicule",
    driver = "Conducteur¬†: %s",
    name = "Nom¬†: %s",
    locked = "Verrouill√©.",
    unlocked = "D√©verouill√©.",
    player_doesnt_exist = "Le joueur n'existe pas.",
    job_doesnt_exist = "Le m√©tier n'existe pas¬†!",
    must_be_alive_to_do_x = "Vous devez √™tre en vie afin de %s.",
    banned_or_demoted = "Banni/r√©trograd√©",
    wait_with_that = "Attendre avec √ßa.",
    could_not_find = "N'a pas pu trouver %s",
    f3tovote = "Appuyez sur F3 pour voter",
    listen_up = "Bien √©couter¬†:", -- In rp_tell or rp_tellall
    nlr = "R√®gle de Nouvelle Vie (NLR): Ne Pas Arr√™ter/Assassiner Par Vengeance.",
    reset_settings = "Vous avez r√©initialis√© tous les r√©glages¬†!",
    must_be_x = "Vous devez √™tre %s afin de pouvoir %s.",
    agenda_updated = "L'agenda a √©t√© mis √† jour",
    job_set = "%s a chang√© son m√©tier en '%s'",
    demoted = "%s a √©t√© r√©trograd√©",
    demoted_not = "%s n'a pas √©t√© r√©trograd√©",
    demote_vote_started = "%s a lanc√© un vote pour que %s soit r√©trograd√©",
    demote_vote_text = "Joueur r√©trograd√©¬†:\n%s", -- '%s' is the reason here
    cant_demote_self = "Vous ne pouvez pas vous r√©trograder vous-m√™me.",
    i_want_to_demote_you = "Je veux te r√©trograder. Motif¬†: %s",
    tried_to_avoid_demotion = "Vous avez tent√© d'√©chapper √† √™tre r√©trograd√©. Vous avez √©chou√© et vous avez √©t√© r√©trograd√©.", -- naughty boy!
    lockdown_started = "Le maire a instaur√© un Couvre-feu, SVP retournez √† vos domiciles¬†!",
    lockdown_ended = "Le couvre-feu est termin√©",
    gunlicense_requested = "%s a demand√© un permis d'armes √† feu √† %s",
    gunlicense_granted = "%s a accord√© un permis d'armes √† feu √† %s",
    gunlicense_denied = "%s a refus√© le permis d'armes √† feu √† %s",
    gunlicense_question_text = "Accorder √† %s un permis d'armes √† feu¬†?",
    gunlicense_remove_vote_text = "%s a lanc√© un vote pour le retrait du permis d'armes √† feu de %s",
    gunlicense_remove_vote_text2 = "R√©voquer permis d'armes¬†:\n%s", -- Where %s is the reason
    gunlicense_removed = "Le permis de %s a √©t√© supprim√©¬†!",
    gunlicense_not_removed = "Le permis de %s n'a pas √©t√© supprim√©¬†!",
    vote_specify_reason = "Vous devez indiquer un motif¬†!",
    vote_started = "Le vote est cr√©√©",
    vote_alone = "Vous avez remport√© le vote puisque vous √™tes seul sur le serveur.",
    you_cannot_vote = "Vous ne pouvez pas voter¬†!",
    x_cancelled_vote = "%s a annul√© le dernier vote.",
    cant_cancel_vote = "Le dernier vote n'a pas pu √™tre annul√© puisqu'il n'y avait pas de dernier vote √† annuler¬†!",
    jail_punishment = "Sanction pour s'√™tre d√©connect√©¬†! Emprisonn√© pour¬†: %d secondes.",
    admin_only = "Admin seulement¬†!", -- When doing /addjailpos
    chief_or = "Commissaire ou ",-- When doing /addjailpos
    frozen = "Gel√©.",

    dead_in_jail = "Vous √™tes maintenant mort jusqu'√† la fin de votre dur√©e d'emprisonnement¬†!",
    died_in_jail = "%s est mort en prison¬†!",

    credits_for = "CR√âDITS POUR %s\n",
    credits_see_console = "Cr√©dits du DarkRP affich√©s dans la console.",

    rp_getvehicles = "V√©hicules disponibles pour v√©hicules personnalis√©s¬†:",

    data_not_loaded_one = "Vos donn√©es n'ont pas encore √©t√© charg√©es. Merci de patienter.",
    data_not_loaded_two = "Si cela persiste, essayez de vous reconnecter ou contactez un admin.",

    cant_spawn_weapons = "Vous ne pouvez pas faire appara√Ætre d'armes.",
    drive_disabled = "Conduite d√©sactiv√©e pour le moment.",
    property_disabled = "Propri√©t√© d√©sactiv√©e pour le moment.",

    not_allowed_to_purchase = "Vous n'√™tes pas autoris√© √† acheter cet article.",

    rp_teamban_hint = "rp_teamban [nom de joueur/ID] [nom d'√©quipe/id]. Utilisez ceci pour bannir un joueur d'une certaine √©quipe.",
    rp_teamunban_hint = "rp_teamunban [nom de joueur/ID] [nom d'√©quipe/id]. Utilisez ceci pour r√©admettre un joueur d'une certaine √©quipe.",
    x_teambanned_y = "%s a banni %s pour devenir %s.",
    x_teamunbanned_y = "%s a r√©admis %s pour devenir %s.",

    -- Backwards compatibility:
    you_set_x_salary_to_y = "Vous avez d√©fini le salaire de %s √† %s%d.",
    x_set_your_salary_to_y = "%s a d√©fini votre salaire √† %s%d.",
    you_set_x_money_to_y = "Vous avez d√©fini l'argent de %s √† %s%d.",
    x_set_your_money_to_y = "%s a d√©fini votre argent √† %s%d.",

    you_set_x_salary = "Vous avez d√©fini le salaire de %s √† %s.",
    x_set_your_salary = "%s a d√©fini votre salaire √† %s.",
    you_set_x_money = "Vous avez d√©fini l'argent de %s √† %s.",
    x_set_your_money = "%s a d√©fini votre argent √† %s.",
    you_set_x_name = "Vous avez d√©fini le nom de %s √† %s",
    x_set_your_name = "%s a d√©fini votre nom √† %s",

    someone_stole_steam_name = "Quelqu'un utilise d√©j√† votre nom Steam en tant que nom RP donc nous vous avons donn√© un \"1\" apr√®s votre nom.", -- Uh oh
    already_taken = "D√©j√† pris.",

    job_doesnt_require_vote_currently = "Ce m√©tier ne requiert pas de vote pour le moment¬†!",

    x_made_you_a_y = "%s vous a chang√© en %s¬†!",

    cmd_cant_be_run_server_console = "Cette commande ne peut pas √™tre lanc√©e depuis la console du serveur.",

    -- The lottery
    lottery_started = "Il y a une loterie¬†! Participer pour %s%d¬†?", -- backwards compatibility
    lottery_has_started = "Il y a une loterie¬†! Participer pour %s¬†?",
    lottery_entered = "Vous vous √™tes inscrit √† la loterie pour %s",
    lottery_not_entered = "%s ne s'est pas inscrit √† la loterie",
    lottery_noone_entered = "Personne ne s'est inscrit √† la loterie",
    lottery_won = "%s a gagn√© la loterie¬†! Il/elle a gagn√© %s",

    -- Animations
    custom_animation = "Animation personnalis√©e¬†!",
    bow = "S'incliner",
    sexy_dance = "Danse sexy",
    dance = "Danser",
    follow_me = "Suivez-moi¬†!",
    laugh = "Rire",
    lion_pose = "Pose du lion",
    nonverbal_no = "Non gestuel",
    thumbs_up = "Signe ok",
    wave = "Faire coucou",

    -- Hungermod
    starving = "Mourant de faim¬†!",

    -- AFK
    afk_mode = "Mode AFK",
    salary_frozen = "Votre salaire a √©t√© gel√©.",
    salary_restored = "Heureux de vous revoir, votre salaire a √©t√© restaur√©.",
    no_auto_demote = "Vous n'allez pas √™tre auto-r√©trograd√©.",
    youre_afk_demoted = "Vous allez √™tre r√©trograd√© pour avoir √©t√© AFK trop longtemps. La prochaine fois utilisez /afk.",
    hes_afk_demoted = "%s a √©t√© r√©trograd√© pour avoir √©t√© AFK trop longtemps.",
    afk_cmd_to_exit = "Tapez /afk √† nouveau pour sortir du mode AFK.",
    player_now_afk = "%s est maintenant AFK.",
    player_no_longer_afk = "%s n'est plus AFK.",

    -- Hitmenu
    hit = "contrat",
    hitman = "Tueur √† gages",
    current_hit = "Contrat¬†: %s",
    cannot_request_hit = "Vous ne pouvez pas solliciter un contrat¬†! %s",
    hitmenu_request = "Requ√™te",
    player_not_hitman = "Ce joueur n'est pas tueur √† gages¬†!",
    distance_too_big = "Distance trop grande.",
    hitman_no_suicide = "Le tueur √† gages ne va pas se tuer lui-m√™me.",
    hitman_no_self_order = "Un tueur √† gages ne peut pas ordonner un contrat pour lui-m√™me.",
    hitman_already_has_hit = "Le tueur √† gages a d√©j√† un contrat en cours.",
    price_too_low = "Prix trop bas¬†!",
    hit_target_recently_killed_by_hit = "La cible a √©t√© tu√©e sur contrat r√©cemment,",
    customer_recently_bought_hit = "Le client a r√©cemment demand√© un contrat.",
    accept_hit_question = "Accepter le contrat de %s\n√† l'encontre de %s pour %s%d¬†?", -- backwards compatibility
    accept_hit_request = "Accepter le contrat de %s\n√† l'encontre de %s pour %s¬†?",
    hit_requested = "Contrat demand√©¬†!",
    hit_aborted = "Contrat abandonn√©¬†! %s",
    hit_accepted = "Contrat accept√©¬†!",
    hit_declined = "Le tueur √† gages a d√©clin√© le contrat¬†!",
    hitman_left_server = "Le tueur √† gages a quitt√© le serveur¬†!",
    customer_left_server = "Le client a quitt√© le serveur¬†!",
    target_left_server = "La cible a quitt√© le serveur¬†",
    hit_price_set_to_x = "Prix du contrat fix√© √† %s%d.", -- backwards compatibility
    hit_price_set = "Prix du contrat fix√© √† %s.",
    hit_complete = "Contrat par %s accompli¬†!",
    hitman_died = "Le tueur √† gages est mort¬†!",
    target_died = "La cible est morte¬†!",
    hitman_arrested = "Le tueur √† gages a √©t√© arr√™t√©¬†!",
    hitman_changed_team = "Le tueur √† gages a chang√© d'√©quipe¬†!",
    x_had_hit_ordered_by_y = "%s avait un contrat en cours ordonn√© par %s",

    -- Vote Restrictions
    hobos_no_rights = "Les clochards n'ont pas le droit de vote¬†!",
    gangsters_cant_vote_for_government = "Les gangsters ne peuvent pas voter pour les choses du gouvernement¬†!",
    government_cant_vote_for_gangsters = "Les officiels du gouvernement ne peuvent pas voter pour les choses des gangsters¬†!",

    -- VGUI and some more doors/vehicles
    vote = "Voter",
    time = "Dur√©e¬†: %d",
    yes = "Oui",
    no = "Non",
    ok = "OK",
    cancel = "Annuler",
    add = "Ajouter",
    remove = "Retirer",
    none = "Aucun",

    x_options = "Options de %s",
    sell_x = "Vendre %s",
    set_x_title = "D√©finir le titre de %s",
    set_x_title_long = "D√©finir le titre de la %s que vous regardez.",
    jobs = "M√©tiers",
    buy_x = "Acheter %s",

    -- F4menu
    ammo = "munitions",
    weapon_ = "arme",
    no_extra_weapons = "Ce m√©tier n'a pas d'armes additionnelles.",
    become_job = "Opter pour ce m√©tier",
    create_vote_for_job = "Cr√©er un vote",
    shipment = "cargaison",
    Shipments = "Cargaisons",
    shipments = "cargaisons",
    F4guns = "Armes",
    F4entities = "Divers",
    F4ammo = "Munitions",
    F4vehicles = "V√©hicules",

    -- Tab 1
    give_money = "Donner de l'argent au joueur que vous regardez",
    drop_money = "Laisser tomber de l'argent",
    change_name = "Modifier votre nom DarkRP",
    go_to_sleep = "Aller dormir / se r√©veiller",
    drop_weapon = "Laisser tomber l'arme actuelle",
    buy_health = "Acheter de la sant√©(%s)",
    request_gunlicense = "Demander un permis d'armes",
    demote_player_menu = "R√©trograder un joueur",


    searchwarrantbutton = "Lancer un avis de recherche d'un joueur",
    unwarrantbutton = "Retirer le statut de recherch√© d'un joueur",
    noone_available = "Personne disponible",
    request_warrant = "Demander un mandat de perquisition chez un joueur",
    make_wanted = "Lancer un avis de recherche",
    make_unwanted = "Terminer un avis de recherche",
    set_jailpos = "D√©finir la position d'emprisonnement",
    add_jailpos = "Ajouter une position d'emprisonnement",

    set_custom_job = "D√©finir un m√©tier personnalis√© (appuyez entr√©e pour activer)",

    set_agenda = "D√©finir l'agenda (appuyez entr√©e pour activer)",

    initiate_lockdown = "D√©marrer un couvre-feu",
    stop_lockdown = "Arr√™ter le couvre-feu",
    start_lottery = "D√©marrer une loterie",
    give_license_lookingat = "Donner √† <lookingat> un permis d'armes",

    laws_of_the_land = "LOIS DU PAYS",
    law_added = "Loi ajout√©e.",
    law_removed = "Loi retir√©e.",
    law_reset = "Lois remises √† z√©ro.",
    law_too_short = "Loi trop courte.",
    laws_full = "Les lois sont pleines.",
    default_law_change_denied = "Vous n'√™tes pas autoris√© √† changer les lois par d√©faut.",

    -- Second tab
    job_name = "Nom¬†: ",
    job_description = "Description¬†: ",
    job_weapons = "Armes¬†: ",

    -- Entities tab
    buy_a = "Acheter %s¬†: %s",

    -- Licenseweaponstab
    license_tab = [[Armes avec permis

    Cochez les armes que les gens peuvent obtenir SANS permis¬†!
    ]],
    license_tab_other_weapons = "Autres armes¬†:",

    zombie_spawn_removed = "Vous avez supprim√© ce spawn de zombie.",
    zombie_spawn = "Zombie Spawn",
    zombie_disabled = "Les zombies sont maintenant d√©sactiv√©s.",
    zombie_enabled = "Les zombies sont maintenant activ√©s.",
    zombie_maxset = "Le nombre maximum de zombies est d√©sormais r√©gl√© √† %s",
    zombie_spawn_added = "Vous avez ajout√© un spawn de zombie.",
    zombie_spawn_not_exist = "Le Spawn de Zombie %s n'existe pas.",
    zombie_leaving = "Les zombies partent.",
    zombie_approaching = "AVERTISSEMENT¬†: des Zombies approchent¬†!",
    zombie_toggled = "Zombies activ√©s/d√©sactiv√©s.",
}

-- The language code is usually (but not always) a two-letter code. The default language is "en".
-- Other examples are "nl" (Dutch), "de" (German)
-- If you want to know what your language code is, open GMod, select a language at the bottom right
-- then enter gmod_language in console. It will show you the code.
-- Make sure language code is a valid entry for the convar gmod_language.
DarkRP.addLanguage("en", my_language)

--PATH gamemodes/mangarp/gamemode/modules/hud/sh_chatcommands.lua:
DarkRP.declareChatCommand{
    command = "admintell",
    description = "Send a private, very intimidating message to someone.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "admintellall",
    description = "Send a very intimidating message to everyone.",
    delay = 1.5
}

--PATH gamemodes/mangarp/gamemode/modules/fpp/pp/client/hud.lua:
FPP = FPP or {}

surface.CreateFont("TabLarge", {
    size = 17,
    weight = 700,
    antialias = true,
    shadow = false,
    font = "Trebuchet MS"})

hook.Add("CanTool", "FPP_CL_CanTool", function(ply, trace, tool) -- Prevent client from SEEING his toolgun shoot while it doesn't shoot serverside.
    if IsValid(trace.Entity) and not FPP.canTouchEnt(trace.Entity, "Toolgun") then
        return false
    end
end)

-- This looks weird, but whenever a client touches an ent he can't touch, without the code it'll look like he picked it up. WITH the code it really looks like he can't
-- besides, when the client CAN pick up a prop, it also looks like he can.
hook.Add("PhysgunPickup", "FPP_CL_PhysgunPickup", function(ply, ent)
    if not FPP.canTouchEnt(ent, "Physgun") then
        return false
    end
end)

-- Makes sure the client doesn't think they can punt props
hook.Add("GravGunPunt", "FPP_CL_GravGunPunt", function(ply, ent)
    if tobool(FPP.Settings.FPP_GRAVGUN1.noshooting) then return false end
    if IsValid(ent) and not FPP.canTouchEnt(ent, "Gravgun") then
        return false
    end
end)

local surface_SetFont = surface.SetFont
local surface_GetTextSize = surface.GetTextSize
local surface_SetDrawColor = surface.SetDrawColor

local draw_SimpleText = draw.SimpleText
local draw_DrawText = draw.DrawText
local draw_RoundedBox = draw.RoundedBox

local HUDNote_c = 0
local HUDNote_i = 1
local HUDNotes = {}

-- Notify ripped off the Sandbox notify, changed to my likings
function FPP.AddNotify(str, type, total_time)
    local tab = {}
    tab.text    = str
    tab.recv    = SysTime()
    tab.velx    = 0
    tab.vely    = -5
    tab.time_visible = total_time ~= 0 and total_time or 6
    surface_SetFont( "TabLarge" )
    local w = surface_GetTextSize( str )

    tab.x       = ScrW() / 2 + w * 0.5 + (ScrW() / 20)
    tab.y       = ScrH()
    tab.a       = 255

    if type then
        tab.type = true
    else
        tab.type = false
    end

    table.insert( HUDNotes, tab )

    HUDNote_c = HUDNote_c + 1
    HUDNote_i = HUDNote_i + 1

    local ply = LocalPlayer()

    if not IsValid(ply) then return end -- I honestly got this error
    ply:EmitSound("npc/turret_floor/click1.wav", 10, 100)
end

usermessage.Hook("FPP_Notify", function(u) FPP.AddNotify(u:ReadString(), u:ReadBool(), u:ReadFloat()) end)

local function DrawNotice(k, v, i)

    local H = ScrH() / 1024
    local x = v.x - 75 * H
    local y = v.y - 20 * H - 2

    surface_SetFont( "TabLarge" )
    local w, h = surface_GetTextSize( v.text )

    w = w
    h = h + 10

    if v.type then
        draw_RoundedBox(4, x - w - h + 16, y - 8, w + h, h, Color(30, 100, 30, v.a * 0.4))
    else
        draw_RoundedBox(4, x - w - h + 16, y - 8, w + h, h, Color(100, 30, 30, v.a * 0.4))
    end

    -- Draw Icon

    surface_SetDrawColor( 255, 255, 255, v.a )

    draw_SimpleText(v.text, "TabLarge", x + 1, y + 1, Color(0, 0, 0, v.a * 0.8), TEXT_ALIGN_RIGHT)
    draw_SimpleText(v.text, "TabLarge", x - 1, y - 1, Color(0, 0, 0, v.a * 0.5), TEXT_ALIGN_RIGHT)
    draw_SimpleText(v.text, "TabLarge", x + 1, y - 1, Color(0, 0, 0, v.a * 0.6), TEXT_ALIGN_RIGHT)
    draw_SimpleText(v.text, "TabLarge", x - 1, y + 1, Color(0, 0, 0, v.a * 0.6), TEXT_ALIGN_RIGHT)
    draw_SimpleText(v.text, "TabLarge", x, y, Color(255, 255, 255, v.a), TEXT_ALIGN_RIGHT)

    local ideal_y = ScrH() - (HUDNote_c - i) * h
    local ideal_x = ScrW() / 2 + w * 0.5 + (ScrW() / 20)
    local timeleft = v.time_visible - (SysTime() - v.recv)

    -- Cartoon style about to go thing
    if (timeleft < 0.5) then
        ideal_x = ScrW() / 2 + w * 0.5 + 200
    end

    -- Gone!
    if (timeleft < 0.2) then
        ideal_y = ScrH() + 50
    end

    local spd = RealFrameTime() * 15
    v.y = v.y + v.vely * spd
    v.x = v.x + v.velx * spd
    local dist = ideal_y - v.y
    v.vely = v.vely + dist * spd * 1

    if (math.abs(dist) < 2 and math.abs(v.vely) < 0.1) then
        v.vely = 0
    end

    dist = ideal_x - v.x
    v.velx = v.velx + dist * spd * 1

    if math.abs(dist) < 2 and math.abs(v.velx) < 0.1 then
        v.velx = 0
    end

    -- Friction.. kind of FPS independant.
    v.velx = v.velx * (0.95 - RealFrameTime() * 8)
    v.vely = v.vely * (0.95 - RealFrameTime() * 8)
end

local weaponClassTouchTypes = {
    ["weapon_physgun"] = "Physgun",
    ["weapon_physcannon"] = "Gravgun",
    ["gmod_tool"] = "Toolgun",
}

local function FilterEntityTable(eyepos, t)
    local filtered = nil
    local filteredDistance = nil

    for i, ent in ipairs(t) do
        local class = ent:GetClass()
        if ent:IsWeapon() or ent:IsPlayer() or class == "viewmodel" then continue end

        -- Get the entity that is closest by
        local distance = ent:NearestPoint(eyepos):DistToSqr(eyepos)
        if filtered == nil or distance < filteredDistance then
            filtered = ent
            filteredDistance = distance
        end
    end

    return filtered
end

local boxBackground = Color(0, 0, 0, 110)
local canTouchTextColor = Color(0, 255, 0, 255)
local cannotTouchTextColor = Color(255, 0, 0, 255)
local function HUDPaint()
    local i = 0
    for k, v in pairs(HUDNotes) do
        if v ~= 0 then
            i = i + 1
            DrawNotice(k, v, i)
        end
    end

    for k, v in pairs(HUDNotes) do
        if v ~= 0 and v.recv + v.time_visible < SysTime() then
            HUDNotes[ k ] = 0
            HUDNote_c = HUDNote_c - 1
            if (HUDNote_c == 0) then HUDNotes = {} end
        end
    end

    if FPP.getPrivateSetting("HideOwner") then return end

    --Show the owner:
    local ply = LocalPlayer()
    local eyepos = ply:EyePos()
    local LAEnt2 = ents.FindAlongRay(eyepos, eyepos + EyeAngles():Forward() * 16384)

    local LAEnt = FilterEntityTable(eyepos, LAEnt2)
    if not IsValid(LAEnt) then return end
    -- Prevent being able to see ownership through walls
    local eyeTrace = ply:GetEyeTrace()
    -- GetEyeTrace can return nil before InitPostEntity
    if eyeTrace == nil then return end
    if eyeTrace.HitPos:DistToSqr(eyeTrace.StartPos) < LAEnt:NearestPoint(eyeTrace.StartPos):DistToSqr(eyeTrace.StartPos) then return end

    local weapon = ply:GetActiveWeapon()
    local class = weapon:IsValid() and weapon:GetClass() or ""

    local touchType = weaponClassTouchTypes[class] or "EntityDamage"
    local reason = FPP.entGetTouchReason(LAEnt, touchType)
    if not reason then return end
    local originalOwner = LAEnt:GetNW2String("FPP_OriginalOwner")
    originalOwner = originalOwner ~= "" and (" (previous owner: %s)"):format(originalOwner) or ""
    reason = reason .. originalOwner

    surface_SetFont("Default")
    local w,h = surface_GetTextSize(reason)
    local col = FPP.canTouchEnt(LAEnt, touchType) and canTouchTextColor or cannotTouchTextColor
    local scrH = ScrH()

    draw_RoundedBox(4, 0, scrH / 2 - h - 2, w + 10, 20, boxBackground)
    draw_DrawText(reason, "Default", 5, scrH / 2 - h, col, 0)
    surface_SetDrawColor(255, 255, 255, 255)
end
hook.Add("HUDPaint", "FPP_HUDPaint", HUDPaint)

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/restrict/cl_restrict.lua:
local function FillMenu(menu, SpawnName, GroupName)
    menu:AddOption("unrestrict", function() RunConsoleCommand("_FAdmin", "UnRestrictWeapon", SpawnName) end)

    menu:AddSpacer("")
    for k in SortedPairsByMemberValue(FAdmin.Access.Groups, "ADMIN", true) do
        menu:AddOption(k, function() RunConsoleCommand("_FAdmin", "RestrictWeapon", SpawnName, k) end)
    end
end

local function RestrictWeaponMenu()
    local frame = vgui.Create("DFrame")
    frame:SetTitle("Restrict weapons")
    frame:SetSize(ScrW() / 2, ScrH() - 50)
    frame:Center()
    frame:SetVisible(true)
    frame:MakePopup()

    local WeaponMenu = vgui.Create("FAdmin_weaponPanel", frame)
    WeaponMenu.HideAmmo = true
    function WeaponMenu:DoGiveWeapon(SpawnName)
        local menu = DermaMenu()
        menu:SetPos(gui.MouseX(), gui.MouseY())
        FillMenu(menu, SpawnName)
        menu:Open()
    end
    WeaponMenu:BuildList()
    WeaponMenu:StretchToParent(0,25,0,0)
end

FAdmin.StartHooks["Restrict"] = function()
    FAdmin.Access.AddPrivilege("Restrict", 3)
    FAdmin.ScoreBoard.Server:AddPlayerAction("Restrict weapons", "fadmin/icons/weapon", Color(0, 155, 0, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(ply, "Restrict") end, RestrictWeaponMenu)
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/messaging/sh_shared.lua:
FAdmin.Messages = {}

FAdmin.Messages.MsgTypes = {
    ERROR = {TEXTURE = "icon16/exclamation.png", COLOR = Color(255,180,0,80)},
    NOTIFY = {TEXTURE = "vgui/notices/error", COLOR = Color(255,255,0,80)},
    QUESTION = {TEXTURE = "vgui/notices/hint", COLOR = Color(0,0,255,80)},
    GOOD = {TEXTURE = "icon16/tick.png", COLOR = Color(0,255,0,80)},
    BAD = {TEXTURE = "icon16/cross.png", COLOR = Color(255,0,0,80)}
}
FAdmin.Messages.MsgTypesByName = {
    ERROR = 1,
    NOTIFY = 2,
    QUESTION = 3,
    GOOD = 4,
    BAD = 5,
}

function FAdmin.PlayerName(ply)
    if CLIENT and ply == LocalPlayer() then return "you" end

    if isstring(ply) then return ply end

    return isentity(ply) and (ply:EntIndex() == 0 and "Console" or ply:Nick()) or "unknown"
end

function FAdmin.TargetsToString(targets)
    if not istable(targets) then
        return FAdmin.PlayerName(targets)
    end

    local targetCount = #targets
    if targetCount == 0 then
        return "no one"
    end

    if targetCount == player.GetCount() and targetCount ~= 1 then
        return "everyone"
    end

    targets = table.Copy(targets)
    local names = fn.Map(FAdmin.PlayerName, targets)

    if #names == 1 then
        return names[1]
    end

    return table.concat(names, ", ", 1, #names - 1) .. " and " .. names[#names]
end

FAdmin.Notifications = {}

local validNotification = tc.checkTable{
    -- A name to identify the notification by
    name =
        tc.addHint(
            isstring,
            "The name must be a string!"
        ),

    -- Whether the notification applies to some kind of target
    hasTarget =
        tc.addHint(
            tc.optional(isbool),
            "hasTarget must either be true, false or nil!"
        ),

    -- Who receives the notification. Can be either one of the list or a function that returns a table of players
    receivers =
        tc.addHint(
            fn.FOr{tc.client, isfunction, tc.oneOf{"everyone", "admins", "superadmins", "self", "targets", "involved", "involved+admins", "involved+superadmins"}},
            "receivers must either be a function returning a table of players or one of 'admins', 'superadmins', 'everyone', 'self', 'targets', 'involved', 'involved+admins', 'involved+superadmins'"
        ),

    -- A table containing the message in parts. There are special strings
    message =
        tc.addHint(
            tc.tableOf(isstring),
            "The message field must be a table of strings! with special strings 'targets', 'you', 'instigator', 'extraInfo.#', with # a number."
        ),

    -- The message type when chat notifications are disabled. NOTIFY by default
    msgType =
        tc.default(
            "NOTIFY",
            tc.addHint(
                tc.oneOf{"ERROR", "NOTIFY", "QUESTION", "GOOD", "BAD"}, "msgType must be one of 'ERROR', 'NOTIFY', 'QUESTION', 'GOOD', 'BAD'"
            )
        ),

    -- A function that writes extra data in the net message
    writeExtraInfo =
        tc.addHint(
            tc.optional(isfunction),
            "writeExtraInfo must be a function"
        ),

    -- A function that reads the written data, formats it and puts it in a table
    readExtraInfo =
        tc.addHint(
            tc.optional(isfunction),
            "writeExtraInfo must be a function"
        ),

    -- When using extra information, this table contains the colours of the extraInfo messages
    extraInfoColors =
        tc.addHint(
            tc.optional(tc.tableOf(tc.iscolor)),
            "extraInfoColors must be a table of colours!"
        ),

    -- Whether the notification is to be logged to console
    logging =
        tc.default(true,
            tc.addHint(
                isbool,
                "logging must be a boolean!"
            )
        ),
}


FAdmin.NotificationNames = {}

function FAdmin.Messages.RegisterNotification(tbl)
    local correct, err = validNotification(tbl)

    if not correct then
        error(string.format("Incorrect notification format for notification '%s'!\n\n%s", istable(tbl) and tbl.name or "unknown", err), 2)
    end

    local key = table.insert(FAdmin.Notifications, tbl)
    FAdmin.NotificationNames[tbl.name] = key

    return key
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/logging/sh_shared.lua:
local logging = CreateConVar("FAdmin_logging", 1, {FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE})

if SERVER then return end
FAdmin.StartHooks["Logging"] = function()
    FAdmin.Access.AddPrivilege("Logging", 3)
    FAdmin.Commands.AddCommand("Logging", nil)

    FAdmin.ScoreBoard.Server:AddServerSetting(function() return (logging:GetBool() and "Disable" or "Enable") .. " Logging" end,
    function() return "fadmin/icons/message", logging:GetBool() and "fadmin/icons/disable" end,
    Color(0, 0, 155, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(ply, "Logging") end, function(button)
        button:SetImage2((not logging:GetBool() and "fadmin/icons/disable") or "null")
        button:SetText((not logging:GetBool() and "Disable" or "Enable") .. " Logging")
        button:GetParent():InvalidateLayout()

        RunConsoleCommand("_Fadmin", "Logging", logging:GetBool() and 0 or 1)
    end)
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/cl_interface/cl_playerlists.lua:
local function SortedPairsByFunction(Table, Sorted, SortDown)
    local CopyTable = {}
    for _, v in pairs(Table) do
        table.insert(CopyTable, {NAME = tostring(v:Nick()), PLY = v})
    end
    table.SortByMember(CopyTable, "NAME", SortDown)

    local SortedTable = {}
    for _, v in ipairs(CopyTable) do
        if not IsValid(v.PLY) or not v.PLY[Sorted] then continue end
        local SortBy = (Sorted ~= "Team" and v.PLY[Sorted](v.PLY)) or (v.PLY:getDarkRPVar("job") or team.GetName(v.PLY[Sorted](v.PLY)))
        SortedTable[SortBy] = SortedTable[SortBy] or {}
        table.insert(SortedTable[SortBy], v.PLY)
    end

    local SecondSort = {}
    for _, v in SortedPairs(SortedTable, SortDown) do
        table.insert(SecondSort, v)
    end

    CopyTable = {}
    for _, v in pairs(SecondSort) do
        for _, b in pairs(v) do
            table.insert(CopyTable, b)
        end
    end

    return ipairs(CopyTable)
end

function FAdmin.ScoreBoard.Main.PlayerListView(Sorted, SortDown)
    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:Clear(true)
    for _, ply in SortedPairsByFunction(player.GetAll(), Sorted, SortDown) do
        local Row = vgui.Create("FadminPlayerRow")
        Row:SetPlayer(ply)
        Row:Dock(TOP)
        Row:InvalidateLayout()

        FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:AddItem(Row)
    end
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/access/cl_init.lua:
local ContinueNewGroup
local EditGroups

local function RetrievePRIVS(len)
    FAdmin.Access.Groups = net.ReadTable()

    for k, v in pairs(FAdmin.Access.Groups) do
        if CAMI.GetUsergroup(k) then continue end

        CAMI.RegisterUsergroup({
            Name = k,
            Inherits = FAdmin.Access.ADMIN[v.ADMIN]
        }, "FAdmin")
    end

    -- Remove any groups that are removed from FAdmin from CAMI.
    for k in pairs(CAMI.GetUsergroups()) do
        if FAdmin.Access.Groups[k] then continue end

        CAMI.UnregisterUsergroup(k, "FAdmin")
    end
end
net.Receive("FADMIN_SendGroups", RetrievePRIVS)

local function addPriv(um)
    local group = um:ReadString()
    FAdmin.Access.Groups[group] = FAdmin.Access.Groups[group] or {}
    FAdmin.Access.Groups[group].PRIVS[um:ReadString()] = true
end
usermessage.Hook("FAdmin_AddPriv", addPriv)

local function removePriv(um)
    FAdmin.Access.Groups[um:ReadString()].PRIVS[um:ReadString()] = nil
end
usermessage.Hook("FAdmin_RemovePriv", removePriv)

local function addGroupUI(ply, func)
    Derma_StringRequest("Set name",
    "What will be the name of the new group?",
    "",
    function(text)
        if text == "" then return end
        Derma_Query("On what access will this team be based? (the new group will inherit all the privileges from the group)", "Admin access",
            "user", function() ContinueNewGroup(ply, text, 0, func) end,
            "admin", function() ContinueNewGroup(ply, text, 1, func) end,
            "superadmin", function() ContinueNewGroup(ply, text, 2, func) end)
    end)
end

FAdmin.StartHooks["1SetAccess"] = function() -- 1 in hook name so it will be executed first.
    FAdmin.Commands.AddCommand("setaccess", nil, "<Player>", "<Group name>", "[new group based on (number)]", "[new group privileges]")

    FAdmin.ScoreBoard.Player:AddActionButton("Set access", "fadmin/icons/access", Color(155, 0, 0, 255),
    function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "SetAccess") or LocalPlayer():IsSuperAdmin() end, function(ply)
        local menu = DermaMenu()

        local Padding = vgui.Create("DPanel")
        Padding:SetPaintBackgroundEnabled(false)
        Padding:SetSize(1,5)
        menu:AddPanel(Padding)

        local Title = vgui.Create("DLabel")
        Title:SetText("  Set access:\n")
        Title:SetFont("UiBold")
        Title:SizeToContents()
        Title:SetTextColor(color_black)

        menu:AddPanel(Title)

        for k in SortedPairsByMemberValue(FAdmin.Access.Groups, "ADMIN", true) do
            menu:AddOption(k, function()
                if not IsValid(ply) then return end
                RunConsoleCommand("_FAdmin", "setaccess", ply:UserID(), k)
            end)
        end

        menu:AddOption("New...", function() addGroupUI(ply) end)
        menu:Open()
    end)

    FAdmin.ScoreBoard.Server:AddPlayerAction("Edit groups", "fadmin/icons/access", Color(0, 155, 0, 255), function() return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "ManageGroups") or FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "ManagePrivileges") end, EditGroups)

    -- Admin immunity
    FAdmin.ScoreBoard.Server:AddServerSetting(function()
            return (FAdmin.GlobalSetting.Immunity and "Disable" or "Enable") .. " Admin immunity"
        end,
        function()
            return "fadmin/icons/access", FAdmin.GlobalSetting.Immunity and "fadmin/icons/disable"
        end, Color(0, 0, 155, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "ManageGroups") end, function(button)
            button:SetImage2((not FAdmin.GlobalSetting.Immunity and "fadmin/icons/disable") or "null")
            button:SetText((not FAdmin.GlobalSetting.Immunity and "Disable" or "Enable") .. " Admin immunity")
            button:GetParent():InvalidateLayout()

            RunConsoleCommand("_Fadmin", "immunity", (FAdmin.GlobalSetting.Immunity and 0) or 1)
        end
    )
end

ContinueNewGroup = function(ply, name, admin_access, func)
    if IsValid(ply) then
        RunConsoleCommand("_FAdmin", "setaccess", ply:UserID(), name, admin_access)
    else
        RunConsoleCommand("_FAdmin", "AddGroup", name, admin_access)
    end

    if func then
        func(name, admin_access)
    end
end

EditGroups = function()
    local frame, SelectedGroup, AddGroup, RemGroup, Privileges, SelectedPrivs, AddPriv, RemPriv, lblImmunity, nmbrImmunity

    frame = vgui.Create("DFrame")
    frame:SetTitle("Create, edit and remove groups")
    frame:MakePopup()
    frame:SetVisible(true)
    frame:SetSize(640, 480)
    frame:Center()

    SelectedGroup = vgui.Create("DComboBox", frame)
    SelectedGroup:SetPos(5, 30)
    SelectedGroup:SetWidth(145)

    for _, v in pairs(FAdmin.Access.Groups) do
        v.immunity = v.immunity or 0
    end
    for k in SortedPairsByMemberValue(FAdmin.Access.Groups, "immunity", true) do
        SelectedGroup:AddChoice(k)
    end

    AddGroup = vgui.Create("DButton", frame)
    AddGroup:SetPos(155, 30)
    AddGroup:SetSize(60, 22)
    AddGroup:SetText("Add Group")
    AddGroup.DoClick = function()
        addGroupUI(nil, function(name, admin, privs)
            SelectedGroup:AddChoice(name)
            SelectedGroup:SetValue(name)
            RemGroup:SetDisabled(false)

            Privileges:Clear()
            SelectedPrivs:Clear()
            nmbrImmunity:SetText(FAdmin.Access.Groups[FAdmin.Access.ADMIN[admin + 1]].immunity)
            nmbrImmunity:SetDisabled(false)
            nmbrImmunity:SetEditable(true)

            for priv, am in SortedPairs(FAdmin.Access.Privileges) do
                if am <= admin + 1 then
                    SelectedPrivs:AddLine(priv)
                else
                    Privileges:AddLine(priv)
                end
            end
        end)
    end

    RemGroup = vgui.Create("DButton", frame)
    RemGroup:SetPos(220, 30)
    RemGroup:SetSize(85, 22)
    RemGroup:SetText("Remove Group")
    RemGroup.DoClick = function()
        RunConsoleCommand("_FAdmin", "RemoveGroup", SelectedGroup:GetValue())

        for k, v in pairs(SelectedGroup.Choices) do
            if v ~= SelectedGroup:GetValue() then continue end

            SelectedGroup.Choices[k] = nil
            break
        end
        table.ClearKeys(SelectedGroup.Choices)

        SelectedGroup:SetValue("user")
        SelectedGroup:OnSelect(1, "user")
    end

    Privileges = vgui.Create("DListView", frame)
    Privileges:SetPos(5, 55)
    Privileges:SetSize(300, 420)
    Privileges:AddColumn("Available privileges")

    SelectedPrivs = vgui.Create("DListView", frame)
    SelectedPrivs:SetPos(340, 55)
    SelectedPrivs:SetSize(295, 420)
    SelectedPrivs:AddColumn("Selected Privileges")

    function SelectedGroup:OnSelect(index, value, data)
        if not FAdmin.Access.Groups[value] then return end

        RemGroup:SetDisabled(false)
        if table.HasValue(FAdmin.Access.ADMIN, value) then
            RemGroup:SetDisabled(true)
        end

        Privileges:Clear()
        SelectedPrivs:Clear()

        for priv, _ in SortedPairs(FAdmin.Access.Privileges) do
            if FAdmin.Access.Groups[value].PRIVS[priv] then
                SelectedPrivs:AddLine(priv)
            else
                Privileges:AddLine(priv)
            end
        end

        if nmbrImmunity then
            nmbrImmunity:SetText(FAdmin.Access.Groups[value].immunity or "")
            if table.HasValue({"superadmin", "admin", "user", "noaccess"}, string.lower(value)) then
                nmbrImmunity:SetDisabled(true)
                nmbrImmunity:SetEditable(false)
            else
                nmbrImmunity:SetDisabled(false)
                nmbrImmunity:SetEditable(true)
            end
        end
    end
    SelectedGroup:SetValue("user")
    SelectedGroup:OnSelect(1, "user")

    AddPriv = vgui.Create("DButton", frame)
    AddPriv:SetPos(310, 55)
    AddPriv:SetSize(25, 25)
    AddPriv:SetText(">")
    AddPriv.DoClick = function()
        for _, v in pairs(Privileges:GetSelected()) do
            local priv = v.Columns[1]:GetValue()
            RunConsoleCommand("FAdmin", "AddPrivilege", SelectedGroup:GetValue(), priv)
            SelectedPrivs:AddLine(priv)
            Privileges:RemoveLine(v.m_iID)
        end
    end

    RemPriv = vgui.Create("DButton", frame)
    RemPriv:SetPos(310, 85)
    RemPriv:SetSize(25, 25)
    RemPriv:SetText("<")
    RemPriv.DoClick = function()
        for _, v in pairs(SelectedPrivs:GetSelected()) do
            local priv = v.Columns[1]:GetValue()
            if SelectedGroup:GetValue() == LocalPlayer():GetUserGroup() and priv == "ManagePrivileges" then
                return Derma_Message("You shouldn't be removing ManagePrivileges. It will make you unable to edit the groups. This is preventing you from locking yourself out of the system.", "Clever move.")
            end
            RunConsoleCommand("FAdmin", "RemovePrivilege", SelectedGroup:GetValue(), priv)
            Privileges:AddLine(priv)
            SelectedPrivs:RemoveLine(v.m_iID)
        end
    end

    lblImmunity = vgui.Create("DLabel", frame)
    lblImmunity:SetPos(340, 30)
    lblImmunity:SetText("Immunity number (higher is more immune)")
    lblImmunity:SizeToContents()

    nmbrImmunity = vgui.Create("DTextEntry", frame)
    nmbrImmunity:SetPos(545, 28)
    nmbrImmunity:SetWide(90)
    nmbrImmunity:SetNumeric(true)
    nmbrImmunity:SetText(FAdmin.Access.Groups.user.immunity)
    nmbrImmunity:SetDisabled(true)
    nmbrImmunity:SetEditable(false)
    nmbrImmunity.OnEnter = function(self) RunConsoleCommand("FAdmin", "SetImmunity", SelectedGroup:GetValue(), self:GetValue()) end
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/playeractions/voicemute/cl_init.lua:
hook.Add("PlayerBindPress", "FAdmin_voicemuted", function(ply, bind, pressed)
    if ply:FAdmin_GetGlobal("FAdmin_voicemuted") and string.find(string.lower(bind), "voicerecord") then return true end
    -- The voice muting is not done clientside, this is just so people know they can't talk
end)

FAdmin.StartHooks["VoiceMute"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "voicemute",
        hasTarget = true,
        message = {"instigator", " voice muted ", "targets", " ", "extraInfo.1"},
        readExtraInfo = function()
            local time = net.ReadUInt(16)
            return {time == 0 and FAdmin.PlayerActions.commonTimes[time] or string.format("for %s", FAdmin.PlayerActions.commonTimes[time] or (time .. " seconds"))}
        end
    }

    FAdmin.Messages.RegisterNotification{
        name = "voiceunmute",
        hasTarget = true,
        message = {"instigator", " voice unmuted ", "targets"}
    }

    FAdmin.Access.AddPrivilege("Voicemute", 2)
    FAdmin.Commands.AddCommand("Voicemute", nil, "<Player>")
    FAdmin.Commands.AddCommand("UnVoicemute", nil, "<Player>")

    FAdmin.ScoreBoard.Player:AddActionButton(function(ply)
            if ply:FAdmin_GetGlobal("FAdmin_voicemuted") then return "Unmute voice globally" end
            return "Mute voice globally"
        end,

    function(ply)
        if ply:FAdmin_GetGlobal("FAdmin_voicemuted") then return "fadmin/icons/voicemute" end
        return "fadmin/icons/voicemute", "fadmin/icons/disable"
    end,
    Color(255, 130, 0, 255),

    function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "Voicemute", ply) end,
    function(ply, button)
        if not ply:FAdmin_GetGlobal("FAdmin_voicemuted") then
            FAdmin.PlayerActions.addTimeMenu(function(secs)
                RunConsoleCommand("_FAdmin", "Voicemute", ply:UserID(), secs)
                button:SetImage2("null")
                button:SetText("Unmute voice globally")
                button:GetParent():InvalidateLayout()
            end)
        else
            RunConsoleCommand("_FAdmin", "UnVoicemute", ply:UserID())
        end

        button:SetImage2("fadmin/icons/disable")
        button:SetText("Mute voice globally")
        button:GetParent():InvalidateLayout()
    end)

    FAdmin.ScoreBoard.Player:AddActionButton(function(ply)
        return ply.FAdminMuted and "Unmute voice" or "Mute voice"
    end,
    function(ply)
        if ply.FAdminMuted then return "fadmin/icons/voicemute" end
        return "fadmin/icons/voicemute", "fadmin/icons/disable"
    end,
    Color(255, 130, 0, 255),

    true,

    function(ply, button)
        ply:SetMuted(not ply.FAdminMuted)
        ply.FAdminMuted = not ply.FAdminMuted

        if ply.FAdminMuted then button:SetImage2("null") button:SetText("Unmute voice") button:GetParent():InvalidateLayout() return end

        button:SetImage2("fadmin/icons/disable")
        button:SetText("Mute voice")
        button:GetParent():InvalidateLayout()
    end)

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("Mute/Unmute", function(ply, Panel)
        ply:SetMuted(not ply.FAdminMuted)
        ply.FAdminMuted = not ply.FAdminMuted
    end)
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/playeractions/slay/cl_init.lua:
FAdmin.StartHooks["Slay"] = function()
    FAdmin.Access.AddPrivilege("Slay", 2)
    FAdmin.Commands.AddCommand("Slay", nil, "<Player>", "[Normal/Silent/Explode/Rocket]")

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("Slay", function(ply)
        RunConsoleCommand("_FAdmin", "slay", ply:UserID())
    end)

    FAdmin.ScoreBoard.Player:AddActionButton("Slay", "fadmin/icons/slay", Color(255, 130, 0, 255),
    function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "Slay", ply) end,
    function(ply)
        local menu = DermaMenu()

        local Padding = vgui.Create("DPanel")
        Padding:SetPaintBackgroundEnabled(false)
        Padding:SetSize(1,5)
        menu:AddPanel(Padding)

        local Title = vgui.Create("DLabel")
        Title:SetText("  Kill Type:\n")
        Title:SetFont("UiBold")
        Title:SizeToContents()
        Title:SetTextColor(color_black)
        menu:AddPanel(Title)

        for k, v in pairs(FAdmin.PlayerActions.SlayTypes) do
            local uid = ply:UserID()
            menu:AddOption(v, function()
                RunConsoleCommand("_FAdmin", "slay", uid, k)
            end)
        end

        menu:Open()
    end)
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/playeractions/giveweapons/cl_controls.lua:
-- Controls for the give weapons menu. These are litterally copied and edited from the garry's mod code.
-- Remaking them in case the gamemode is not derived from sandbox
-- Copying from garry's mod code because I'm lazy and because it looks good.


-- Weapon icon:
local PANEL = {}

function PANEL:Init()
    self:SetSize(83, 83)

    self.Label = vgui.Create("DLabel", self)

    self:SetKeepAspect(true)
    self:SetDrawBorder(true)
    self.m_Image:SetPaintedManually(true)
end


function PANEL:PerformLayout()
    self.Label:SizeToContents()
    self.Label:SetFont("TabLarge")
    self.Label:SetTextColor(color_white)
    self.Label:SetContentAlignment(5)
    self.Label:SetWide(self:GetWide())
    self.Label:AlignBottom(2)

    DImageButton.PerformLayout(self)

    if self.imgAdmin then
        self.imgAdmin:SizeToContents()
        self.imgAdmin:AlignTop(4)
        self.imgAdmin:AlignRight(4)
    end
end

function PANEL:CreateAdminIcon()
    self.imgAdmin = vgui.Create("DImage", self)
    self.imgAdmin:SetImage("icon16/shield.png") -- SilkIcons are now merged into GMOD as materials/icon16
    self.imgAdmin:SetTooltip("#Admin Only")
end

function PANEL:Paint()
    local w, h = self:GetSize()
    self.m_Image:Paint()

    surface.SetDrawColor(30, 30, 30, 200)
    surface.DrawRect(0, h - 16, w, 16)
end

function PANEL:Setup(NiceName, SpawnName, IconMaterial, AdminOnly, Parent, IsAmmo)
    self.Label:SetText(DarkRP.deLocalise(NiceName))

    self.DoClick = function() Parent:DoGiveWeapon(SpawnName, IsAmmo) end
    self.DoRightClick = function() end

    if not IconMaterial then
        IconMaterial = "VGUI/entities/" .. SpawnName
    end

    self:SetOnViewMaterial(IconMaterial, "vgui/swepicon")

    if AdminOnly then self:CreateAdminIcon() end

    self:InvalidateLayout()
end

local WeaponIcon = vgui.RegisterTable(PANEL, "DImageButton")

-- Full panel:
local PANEL2 = {}

function PANEL2:Init()
    self.PanelList = vgui.Create("DPanelList", self)
    self.PanelList:SetPadding(4)
    self.PanelList:SetSpacing(2)
    self.PanelList:EnableVerticalScrollbar(true)
end

function PANEL2:BuildList()
    self.PanelList:Clear()

    if not self.HideAmmo then
        local AmmoCat = vgui.Create("DCollapsibleCategory", self)
        self.PanelList:AddItem(AmmoCat)
        AmmoCat:SetLabel("Give ammo")

        local AmmoPan = vgui.Create("DPanelList")
        AmmoCat:SetContents(AmmoPan)
        AmmoPan:EnableHorizontal(true)
        AmmoPan:SetPaintBackground(false)
        AmmoPan:SetSpacing(2)
        AmmoPan:SetPadding(2)
        AmmoPan:SetAutoSize(true)

        for k in SortedPairs(FAdmin.AmmoTypes) do
            local Icon = vgui.CreateFromTable(WeaponIcon, self)
            Icon:Setup(k, k, "spawnicons/models/items/boxmrounds60x60.png", false, self, true) -- Gets created clientside by GMOD when someone is after that model, or trying to buy ammo.
            AmmoPan:AddItem(Icon)
        end
    end

    local Weapons = weapons.GetList()
    local Categorised = {}

    Categorised["Half-life 2"] = {}
    for k, weapon in pairs(FAdmin.HL2Guns) do
        table.insert(Categorised["Half-life 2"], {PrintName = k, ClassName = weapon, Spawnable = true,
        Author = "Half-life 2",
        Contact = "gaben@valvesoftware.com",
        Instructions = "Shoot!"})
    end

    for k, weapon in pairs(Weapons) do
        weapon = weapons.Get(weapon.ClassName)
        Weapons[k] = weapon
        weapon.Category = weapon.Category or "Other"

        if not weapon.Spawnable and not weapon.AdminSpawnable then
            Weapons[k] = nil
        else
            Categorised[weapon.Category] = Categorised[weapon.Category] or {}
            table.insert(Categorised[weapon.Category], weapon)
            Weapons[k] = nil
        end
    end

    Weapons = nil

    for CategoryName, v in SortedPairs(Categorised) do
        local Category = vgui.Create("DCollapsibleCategory", self)
        self.PanelList:AddItem(Category)
        Category:SetLabel(CategoryName)
        Category:SetCookieName("WeaponSpawn." .. CategoryName)

        local Content = vgui.Create("DPanelList")
        Category:SetContents(Content)
        Content:EnableHorizontal(true)
        Content:SetPaintBackground(false)
        Content:SetSpacing(2)
        Content:SetPadding(2)
        Content:SetAutoSize(true)

        for _, WeaponTable in SortedPairsByMemberValue(v, "PrintName") do
            local Icon = vgui.CreateFromTable(WeaponIcon, self)
            Icon:Setup(WeaponTable.PrintName or WeaponTable.ClassName, WeaponTable.ClassName, WeaponTable.SpawnMenuIcon, WeaponTable.AdminSpawnable and not WeaponTable.Spawnable, self)

            local Tooltip = Format("Name: %s", WeaponTable.PrintName)
            if WeaponTable.Author ~= "" then Tooltip = Format("%s\nAuthor: %s", Tooltip, WeaponTable.Author) end
            if WeaponTable.Contact ~= "" then Tooltip = Format("%s\nContact: %s", Tooltip, WeaponTable.Contact) end
            if WeaponTable.Instructions ~= "" then Tooltip = Format("%s\n\n%s", Tooltip, WeaponTable.Instructions) end

            Icon:SetTooltip(Tooltip)
            Content:AddItem(Icon)
        end
    end
    self.PanelList:InvalidateLayout()
end

function PANEL2:PerformLayout()
    self.PanelList:StretchToParent(0, 0, 0, 0)
end

derma.DefineControl("FAdmin_weaponPanel", "Weapon panel for giving weapons in FAdmin", PANEL2, "Panel")

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/playeractions/changeteam/cl_init.lua:
FAdmin.StartHooks["zzSetTeam"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "setteam",
        hasTarget = true,
        message = {"instigator", " set the team of ", "targets", " to ", "extraInfo.1"},
        readExtraInfo = function()
            return {team.GetName(net.ReadUInt(16))}
        end,
        extraInfoColors = {Color(255, 102, 0)}
    }

    FAdmin.Access.AddPrivilege("SetTeam", 2)
    FAdmin.Commands.AddCommand("SetTeam", nil, "<Player>", "<Team>")

    FAdmin.ScoreBoard.Player:AddActionButton("Set team", "fadmin/icons/changeteam", Color(0, 200, 0, 255),
    function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "SetTeam", ply) end, function(ply, button)
        local menu = DermaMenu()

        local Padding = vgui.Create("DPanel")
        Padding:SetPaintBackgroundEnabled(false)
        Padding:SetSize(1,5)
        menu:AddPanel(Padding)

        local Title = vgui.Create("DLabel")
        Title:SetText("  Teams:\n")
        Title:SetFont("UiBold")
        Title:SizeToContents()
        Title:SetTextColor(color_black)

        menu:AddPanel(Title)
        for k, v in SortedPairsByMemberValue(team.GetAllTeams(), "Name") do
            local uid = ply:UserID()
            menu:AddOption(v.Name, function() RunConsoleCommand("_FAdmin", "setteam", uid, k) end)
        end
        menu:Open()
    end)
end

--PATH gamemodes/mangarp/gamemode/modules/chat/sh_chatcommands.lua:
local plyMeta = FindMetaTable("Player")
DarkRP.chatCommands = DarkRP.chatCommands or {}

local validChatCommand = {
    command = isstring,
    description = isstring,
    condition = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isfunction},
    delay = isnumber,
    tableArgs = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isbool},
}

local checkChatCommand = function(tbl)
    for k in pairs(validChatCommand) do
        if not validChatCommand[k](tbl[k]) then
            return false, k
        end
    end
    return true
end

function DarkRP.declareChatCommand(tbl)
    local valid, element = checkChatCommand(tbl)
    if not valid then
        DarkRP.error("Incorrect chat command! " .. element .. " is invalid!", 2)
    end

    tbl.command = string.lower(tbl.command)
    DarkRP.chatCommands[tbl.command] = DarkRP.chatCommands[tbl.command] or tbl
    for k, v in pairs(tbl) do
        DarkRP.chatCommands[tbl.command][k] = v
    end
end

function DarkRP.removeChatCommand(command)
    DarkRP.chatCommands[string.lower(command)] = nil
end

function DarkRP.chatCommandAlias(command, ...)
    local name
    for k, v in pairs{...} do
        name = string.lower(v)

        DarkRP.chatCommands[name] = {command = name}
        setmetatable(DarkRP.chatCommands[name], {
            __index = DarkRP.chatCommands[command]
        })
    end
end

function DarkRP.getChatCommand(command)
    return DarkRP.chatCommands[string.lower(command)]
end

function DarkRP.getChatCommands()
    return DarkRP.chatCommands
end

function DarkRP.getSortedChatCommands()
    local tbl = fn.Compose{table.ClearKeys, table.Copy, DarkRP.getChatCommands}()
    table.SortByMember(tbl, "command", true)

    return tbl
end

-- chat commands that have been defined, but not declared
DarkRP.getIncompleteChatCommands = fn.Curry(fn.Filter, 3)(fn.Compose{fn.Not, checkChatCommand})(DarkRP.chatCommands)

--[[---------------------------------------------------------------------------
Chat commands
---------------------------------------------------------------------------]]
DarkRP.declareChatCommand{
    command = "pm",
    description = "Send a private message to someone.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "w",
    description = "Say something in whisper voice.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "y",
    description = "Yell something out loud.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "me",
    description = "Chat roleplay to say you're doing things that you can't show otherwise.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "/",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "a",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "ooc",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "broadcast",
    description = "Broadcast something as a mayor.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "channel",
    description = "Tune into a radio channel.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "radio",
    description = "Say something through the radio.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "g",
    description = "Group chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "credits",
    description = "Send the DarkRP credits to someone.",
    delay = 1.5
}

--PATH gamemodes/mangarp/gamemode/modules/base/cl_jobmodels.lua:
-- Create a table for the preferred playermodels
sql.Query([[CREATE TABLE IF NOT EXISTS darkp_playermodels(
    jobcmd VARCHAR(45) NOT NULL PRIMARY KEY,
    model VARCHAR(140) NOT NULL
);]])

local preferredModels = {}


--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function DarkRP.setPreferredJobModel(teamNr, model)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    preferredModels[job.command] = model
    sql.Query(string.format([[REPLACE INTO darkp_playermodels VALUES(%s, %s);]], sql.SQLStr(job.command), sql.SQLStr(model)))

    net.Start("DarkRP_preferredjobmodel")
        net.WriteUInt(teamNr, 8)
        net.WriteString(model)
    net.SendToServer()
end

function DarkRP.getPreferredJobModel(teamNr)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    return preferredModels[job.command]
end

--[[---------------------------------------------------------------------------
Load the preferred models
---------------------------------------------------------------------------]]
local function sendModels() -- run after the jobs have loaded
    net.Start("DarkRP_preferredjobmodels")
        for _, job in pairs(RPExtraTeams) do
            if not preferredModels[job.command] then net.WriteBit(false) continue end

            net.WriteBit(true)
            net.WriteString(preferredModels[job.command])
        end
    net.SendToServer()
end

do
    local models = sql.Query([[SELECT jobcmd, model FROM darkp_playermodels;]])
    for _, v in ipairs(models or {}) do
        preferredModels[v.jobcmd] = v.model
    end

    timer.Simple(0, sendModels)
end

--PATH gamemodes/mangarp/gamemode/modules/base/cl_fonts.lua:
--[[---------------------------------------------------------------------------
The fonts that DarkRP uses
---------------------------------------------------------------------------]]
local function loadFonts()
    surface.CreateFont("DarkRPHUD1", {
        size = 20,
        weight = 600,
        antialias = true,
        shadow = true,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("DarkRPHUD2", {
        size = 23,
        weight = 400,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("Roboto20", {
        size = 20,
        weight = 600,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("Trebuchet18", {
        size = 18,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("Trebuchet20", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("Trebuchet24", {
        size = 24,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("Trebuchet48", {
        size = 48,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("TabLarge", {
        size = 18,
        weight = 700,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana",
        extended = true,
    })

    surface.CreateFont("HUDNumber5", {
        size = 30,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana",
        extended = true,
    })

    surface.CreateFont("ScoreboardHeader", {
        size = 32,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardSubtitle", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardPlayerName", {
        size = 19,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardPlayerName2", {
        size = 15,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardPlayerNameBig", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("AckBarWriting", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Akbar",
        extended = true,
    })

    surface.CreateFont("DarkRP_tipjar", {
        size = 100,
        weight = 500,
        antialias = true,
        shadow = true,
        font = "Verdana",
        extended = true,
    })
end
loadFonts()
--PATH addons/sl_util_wallet/lua/darkrp_modules/ez_wallet/sh_init.lua:
-- If you want to change the currency here, uncomment the line
GM.Config.currency = "$"

-- Changes the money model to the Easzy's Wallet one (comment to let the default one)
GM.Config.MoneyClass = "ez_wallet_spawned_money"

-- In order to disallow the drop of these items (so no infinite entity is possible)
GM.Config.DisallowDrop["ez_wallet_wallet"] = true
GM.Config.DisallowDrop["ez_wallet_card"] = true
GM.Config.DisallowDrop["ez_wallet_money"] = true

-- In order to give the wallet to all the players
table.insert(GM.Config.DefaultWeapons, "ez_wallet_wallet")

--PATH addons/sl_aphone/lua/weapons/aphone/cl_init.lua:
include("shared.lua")

local last_open = 0
local vm_pos, vm_ang
local phone_bg2D = Material("materials/akulla/aphone/phone_bg.png", "smooth 1")
local clr = Color(40, 40, 40)

local backup_setting = aphone:GetParameters("Core", "2D", false)
aphone:ChangeParameters("Core", "2D", false)

local rt = GetRenderTarget("aphone_rt_" .. math.ceil(aphone.GUI.ScaledSize(400)) .. "_" .. math.ceil(aphone.GUI.ScaledSize(855)), aphone.GUI.ScaledSize(400), aphone.GUI.ScaledSize(855), RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_NONE, bit.bor(2, 256), 0, IMAGE_FORMAT_RGBA8888)
local mat_rt = CreateMaterial( "mat_aphone_rt", "UnlitGeneric", {
	["$basetexture"] = rt:GetName(),
} )

aphone:ChangeParameters("Core", "2D", backup_setting)

local ratio_3D2D_notinvert = ScrH() / 1080
local ratio_3D2D = 1 / ratio_3D2D_notinvert

aphone.cursor_visible = false

// Stencils
local stencil_poly_default = {
	[1] = {
		x = -1,
		y = 20,
	},
	[2] = {
		x = 15,
		y = 0,
	},
	[3] = {
		x = 385,
		y = 0,
	},
	[4] = {
		x = 405,
		y = 20,
	},
	[5] = {
		x = 405,
		y = 840,
	},
	[6] = {
		x = 385,
		y = 855,
	},
	[7] = {
		x = 15,
		y = 855,
	},
	[8] = {
		x = -1,
		y = 840,
	},
}
local stencil_poly = table.Copy(stencil_poly_default)

local function calculate_ratios()
	local ratio_h = ScrH() / 1080
	local ratio_w = ScrW() / 1920
	local new_ratio = ratio_h < ratio_w and ratio_h or ratio_w

	ratio = new_ratio
	ratio_3D2D = 1 / ratio
	ratio_3D2D_notinvert = ratio

	--[[
	I tried to avoid recreating a rendertarget
	However, even if I avoid recreating by sizing perfectly panels, if the new resolution is too much bigger, then the phone panel would broke
	A solution would be to scale with matrix at the end, but it makes everything looks like a PS1 UI
	]]--

	local backup_setting = aphone:GetParameters("Core", "2D", false)
	aphone:ChangeParameters("Core", "2D", false)

	rt = GetRenderTarget("aphone_rt_" .. math.ceil(aphone.GUI.ScaledSize(400)) .. "_" .. math.ceil(aphone.GUI.ScaledSize(855)), aphone.GUI.ScaledSize(400), aphone.GUI.ScaledSize(855), RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_NONE, bit.bor(2, 256), 0, IMAGE_FORMAT_RGBA8888)

	aphone:ChangeParameters("Core", "2D", backup_setting)
	mat_rt:SetTexture("$basetexture", rt)

	if IsValid(aphone.MainDerma) then
		-- Reset the panel
		aphone.MainDerma:Remove()
	end

	for k, v in pairs(stencil_poly_default) do
		for i, j in pairs(v) do
			stencil_poly[k][i] = j * ratio_3D2D_notinvert
		end
	end
end
calculate_ratios()

hook.Add("OnScreenSizeChanged", "APhone_Refresh3D2DRatio", calculate_ratios)

function aphone.blur_rt(x, y, pass)
	if rt then
		render.BlurRenderTarget( rt, x, y, pass)
	end
end

local hdr_vec = Vector(0.67, 0.67, 0.67)

function SWEP:PostDrawViewModel(vm)
	self.ViewModelFOV = LocalPlayer():GetFOV()

	-- FIXME: This should be removed when ViewModelFOV() is binded
	local nFOV = self.ViewModelFOV
	if (not isnumber(nFOV)) then nFOV = 62 end

	if !aphone.MainDerma or !IsValid(aphone.MainDerma) then
		aphone.MainDerma = vgui.Create("aphone_Main")
		aphone.MainDerma:SetMouseInputEnabled(false)

		/* 
		Why 100 ? Because if we set it to a little value like 0 or 1, if he drag his mouse to the left of the screen and he is playing windowed then
		my code won't detect him going outside, so the mouse will stay and can make your mouse move out of the game
		Don't worry, I will fix this pos later in my rendertarget with matrix
		*/

		aphone.MainDerma:SetPos(aphone.GUI.ScaledSize(100, 100))

		// Notif panel, made it global so we can notify things
		aphone.NotifPanel = vgui.Create("DPanel", aphone.MainDerma)
		aphone.NotifPanel:SetSize(aphone.MainDerma:GetSize())
		aphone.NotifPanel:SetPaintedManually(true)
		aphone.NotifPanel:SetPaintBackground(false)
		aphone.NotifPanel:SetMouseInputEnabled(false)
		aphone.NotifPanel:SetZPos(4)
		
		if !aphone:Is2D() then
			aphone.NotifPanel:SetCursor("blank")
		else
			local aphone_main2D = vgui.Create("EditablePanel")

			aphone_main2D:SetSize(aphone.GUI.ScaledSize(215 * 2, 490 * 2))
			aphone_main2D:SetPos(ScrW() - aphone_main2D:GetWide(), ScrH() - aphone_main2D:GetTall())

			aphone.MainDerma:SetParent(aphone_main2D)
			aphone.MainDerma:SetPos(aphone.GUI.ScaledSize(15, 63))

			function aphone_main2D:PaintOver(w, h)
				surface.SetMaterial(phone_bg2D)
				surface.SetDrawColor(color_white)
				surface.DrawTexturedRect(0, 0, w, h)
			end

			function aphone_main2D:Think()
				self:MoveToFront()
				if !IsValid(aphone.MainDerma) then
					self:Remove()
					aphone.MainDerma = nil
				end

				local hovered_pnl = vgui.GetHoveredPanel()
				if input.IsMouseDown( 107 ) and last_open < CurTime() and !self:IsChildHovered() and !self:IsHovered() and IsValid(hovered_pnl) then
					gui.EnableScreenClicker(false)
					aphone.cursor_visible = false
				end
			end
		end
	end

	local tAttachment = vm:GetAttachment(1)

	vm_pos = tAttachment.Pos
	vm_ang = tAttachment.Ang

	vm_pos = vm_pos + vm_ang:Up() * 0.025
	vm_ang:RotateAroundAxis( vm_ang:Up(), -90)

	// Global, for camera app
	aphone.VM_Pos = vm_pos

	local ext_attachment = self:GetAttachment(1)

	aphone.WM_Pos = ext_attachment.Pos
	aphone.WM_Ang = ext_attachment.Ang

	if !aphone:Is2D() then
		// Ratio
		local c = vm:GetCycle()
		if c == 1 then
			aphone.horizontal_ratio = tonumber(aphone.Horizontal)
		else
			aphone.horizontal_ratio = (!aphone.Horizontal and 1 - c or c)
		end

		local pre_hdr = render.GetToneMappingScaleLinear()

		if aphone:GetParameters("Core", "AutoLight", false) and render.GetHDREnabled() then
			local inverted = math.Clamp(5 / pre_hdr.x - 2.6, 0.1, 0.67)
			render.SetToneMappingScaleLinear(Vector(inverted, inverted, inverted))
		else
			render.SetToneMappingScaleLinear(hdr_vec)
		end

		cam.Start3D2D(vm_pos, vm_ang, 0.01 * ratio_3D2D)
			render.SetStencilWriteMask( 0xFF )
			render.SetStencilTestMask( 0xFF )
			render.SetStencilReferenceValue( 1 )
			render.SetStencilCompareFunction( STENCIL_ALWAYS )
			render.SetStencilPassOperation( STENCIL_REPLACE )
			render.SetStencilFailOperation( STENCIL_KEEP )
			render.SetStencilZFailOperation( STENCIL_KEEP )
			render.ClearStencil()

			// Enable stencils
			render.SetStencilEnable( true )
				surface.SetDrawColor(color_white)
				surface.DrawPoly(stencil_poly)
			render.SetStencilCompareFunction( STENCIL_EQUAL )
				surface.SetMaterial(mat_rt)
				surface.DrawTexturedRect(-2, 0, aphone.GUI.ScaledSize(405, 855))
			render.SetStencilEnable( false )
		cam.End3D2D()
		render.SetToneMappingScaleLinear(pre_hdr)
	end

	self:DrawLight(LocalPlayer(), ext_attachment)
end

// Without DrawHUD ( drawing in viewmodel), we would get big issues where the panel show himself even outside the bounds, like this : https://prnt.sc/121oske
function SWEP:DrawHUD()
	if vm_pos and !aphone:Is2D() and IsValid(aphone.MainDerma) then
		render.PushRenderTarget( rt )
			render.Clear(255, 255, 255, 255)
			// https://www.gitmemory.com/issue/Facepunch/garrysmod-issues/4662/691134213
			// https://wiki.facepunch.com/gmod/render.OverrideAlphaWriteEnable
			render.SetWriteDepthToDestAlpha(false)
			render.ClearDepth()
			render.OverrideAlphaWriteEnable(true, true)
				cam.Start2D()
					local size = aphone.MainDerma:GetPos()

					local tr = Matrix()
					tr:Translate(Vector(-size, -size, 0))
					if aphone.HorizontalApp then
						tr:Translate(Vector(mat_rt:Width() + size * 2, 0, 0))
						tr:Rotate(Angle(0, 90, 0))
					end
					cam.PushModelMatrix(tr)

					aphone.MainDerma:MoveToFront()
					aphone.MainDerma:PaintManual()

					if aphone.cursor_visible then
						local hovered_pnl = vgui.GetHoveredPanel()
						if last_open < CurTime() and !aphone.MainDerma:IsHovered() and !aphone.MainDerma:IsChildHovered() and IsValid(hovered_pnl) then
							// Try to get the mouse pos outside the phone
							local tbl_pos = vm_pos:ToScreen()
							tbl_pos.x = tbl_pos.x + gui.MouseX() / 1.5
							tbl_pos.y = tbl_pos.y + gui.MouseY() / 1.5
							input.SetCursorPos(tbl_pos.x, tbl_pos.y)
							aphone.cursor_visible = false

							gui.EnableScreenClicker(false)
							aphone.MainDerma:SetMouseInputEnabled(false)
						end

						local mousex, mousey = input.GetCursorPos()

						draw.SimpleText("d", "SVG_20_3D", lastframe_x or mousex, lastframe_y or mousey, clr, 1, 1)
						draw.SimpleText("d", "SVG_16_3D", lastframe_x or mousex, lastframe_y or mousey, color_white, 1, 1)
					end

					cam.PopModelMatrix()
				cam.End2D()
			render.SetWriteDepthToDestAlpha(true)
		render.PopRenderTarget()
	end
end

function SWEP:PrimaryAttack()
	if self:GetOwner() != LocalPlayer() then return end

	gui.EnableScreenClicker(true)

	-- I guess he won't travel +100px with his mouse in 0.03
	-- Using this to prevent the mouse reset instantly, because the setmousepos take some times/frames
	last_open = CurTime() + 0.1

	if !aphone:Is2D() then
		aphone.cursor_visible = true

		if aphone.HorizontalApp then
			input.SetCursorPos(aphone.GUI.ScaledSize(427.5, 200))
		else
			input.SetCursorPos(aphone.GUI.ScaledSize(200, 427.5))
		end
	end

	if IsValid(aphone.MainDerma) then
		aphone.MainDerma:SetMouseInputEnabled(true)
	end
end

-- I don't check if predicted, because I got issue with it on some servers, also because we don't need, even if the function 
-- is called multiples times. I check if the panel is valid
function SWEP:Holster()
	if self:GetOwner() != LocalPlayer() then return end

	if IsValid(aphone.Running_App) then
		aphone.Running_App:OnClose()
	end

	if IsValid(aphone.MainDerma) then
		aphone.MainDerma:Remove()

		if aphone.Horizontal then
			aphone.RequestAnim(1)
		end

		if !aphone:Is2D() then
			aphone.HorizontalApp = false

			// timer.simple 0 so weapon selectors, when you select a weapon, doesn't trigger mouse
			timer.Simple(0.5, function()
				if aphone.cursor_visible and (!IsValid(vgui.GetHoveredPanel()) or vgui.GetHoveredPanel():GetName() == "GModBase") then
					gui.EnableScreenClicker(false)
				end
			end)
		end
	end

	if ( IsValid( self.lamp ) ) then
		self.lamp:Remove()
		self.lamp = nil
	end
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:DrawLight(owner, tAttachment)
	if owner != LocalPlayer() then return end
	local param = aphone:GetParameters("Core", "Flashlight", false)
	local a = tAttachment.Ang + Angle(0, 90, 0)
	local p = tAttachment.Pos

	p = p + a:Up()*-0.9 + a:Right()*-1 + a:Forward()*-0.6

	if !self.lamp then
		if !param then return end
		local lamp = ProjectedTexture() -- Create a projected texture
		self.lamp = lamp -- Assign it to the entity table so it may be accessed later

		-- Set it all up
		lamp:SetTexture( "effects/flashlight001" )
		lamp:SetFarZ( 400 ) -- How far the light should shine

		lamp:SetPos( p ) -- Initial position and angles
		lamp:SetAngles( a )
		lamp:Update()
	else
		if ( IsValid( self.lamp ) ) then
			if param then
				self.lamp:SetPos( p )
				self.lamp:SetAngles( LocalPlayer():EyeAngles() )
				self.lamp:SetBrightness(4)
				self.lamp:SetEnableShadows(false)
				self.lamp:SetFarZ( 300 ) 
				self.lamp:Update()
				self.lamp:SetTexture( "effects/flashlight_border" )
			else
				self.lamp:Remove()
				self.lamp = nil
			end
		end
	end
end

function SWEP:DrawWorldModel()
	local o = self:GetOwner()

	if IsValid(o) then
		aphone.RefreshWeapon(o, self)
		self:DrawLight(o, self:GetAttachment(1))
	end

	self:DrawModel()
end

function SWEP:Reload()
	self.lastanimchange = self.lastanimchange or 0

	if self.lastanimchange < CurTime() then
		aphone.RequestAnim(aphone.Horizontal and 1 or 2)
		self.lastanimchange = CurTime() + 1
	end
end

function SWEP:SecondaryAttack() end
--PATH addons/sl_main_system/lua/weapons/buellost_faux/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/buellost_faux1/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "22 : Faux D√©moniaque" 
SWEP.Author 		      = "Buellost" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/price.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "buellost_faux" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[ARMES - MAD]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "faux"
SWEP.holdtype = "sl_marteau_ht_mad"
SWEP.BonusDegats = 168

--------------------------------------------------------------------------
--PATH addons/sl_util_accessory/lua/weapons/gmod_tool/stools/aas_setup.lua:
AddCSLuaFile()

TOOL.Category = "Advanced Accessory System"
TOOL.Name = "Entity-Setup"
TOOL.Author = "Kobralost"

if CLIENT then 
	TOOL.Information = {
		{ name = "left" },
		{ name = "right" },
		{ name = "reload" },
	}
	language.Add("tool.aas_setup.name", "Entity Setup")
	language.Add("tool.aas_setup.desc", "Place Bodygroups, Models, Items entity")
	language.Add("tool.aas_setup.left", "Left-Click to place entity in your server" )
	language.Add("tool.aas_setup.right", "Right-Click to delete entity on your server" )
	language.Add("tool.aas_setup.reload", "Reload to change the step of the toolgun" )
end

local AASSwepTable = {
	[1] = {
		["model"] = AAS.BodyGroupModel,
		["class"] = "aas_bodygroup",
		["vector"] = Vector(0,0,40),
	},
	[2] = {
		["model"] = AAS.ModelChanger,
		["class"] = "aas_model",
		["vector"] = Vector(0,0,40),
	},
	[3] = {
		["model"] = AAS.ItemNpcModel,
		["class"] = "aas_npc_shop",
		["vector"] = Vector(0,0,0),
	},
}

function TOOL:Deploy()
	self:SetStage(0)
end

function TOOL:LeftClick(trace)
	if SERVER then
		local ply = self:GetOwner()
		if not IsValid(ply) and not ply:IsPlayer() or not AAS.AdminRank[ply:GetUserGroup()] then return end
		
		ply.AASSpam = ply.AASSpam or CurTime()
		if ply.AASSpam > CurTime() then return end 
		ply.AASSpam = CurTime() + 0.5

		local position = trace.HitPos
		local angle = ply:GetAngles()

		local AASEnt = ents.Create(AASSwepTable[self:GetStage() + 1]["class"])
		AASEnt:SetPos(position + AASSwepTable[self:GetStage() + 1]["vector"])
		AASEnt:SetAngles(Angle(0, angle.Yaw - 180, 0))
		AASEnt:Spawn()
		AASEnt:Activate()
	end
end 

function TOOL:RightClick()
	if SERVER then 
		local ply = self:GetOwner()
		if not IsValid(ply) and not ply:IsPlayer() or not AAS.AdminRank[ply:GetUserGroup()] then return end
		
		local TraceEntity = self:GetOwner():GetEyeTrace().Entity
		if IsValid(TraceEntity) then 
			TraceEntity:Remove()
		end  
	end 
end 

function TOOL:CreateAASEnt()
	if CLIENT then
		local ply = self:GetOwner()
		if not IsValid(ply) and not ply:IsPlayer() then return end  
	
		if not AAS.AdminRank[ply:GetUserGroup()] then return end

		if not IsValid(self.AASEnt) then
 			self.AASEnt = ClientsideModel(AASSwepTable[self:GetStage() + 1]["model"], RENDERGROUP_OPAQUE)
			self.AASEnt:SetModel(AASSwepTable[self:GetStage() + 1]["model"])
			self.AASEnt:SetMaterial("models/wireframe")
			self.AASEnt:Spawn()
			self.AASEnt:Activate()	
			self.AASEnt:SetRenderMode(RENDERMODE_TRANSALPHA)
			self.AASEnt:SetColor(AAS.Colors["white"])
		end
	end 
end

function TOOL:Think()
	if CLIENT then
		local ply = self:GetOwner()
		if not IsValid(ply) and not ply:IsPlayer() or not AAS.AdminRank[ply:GetUserGroup()] then return end

		if IsValid(self.AASEnt) then
			local trace = util.TraceLine(util.GetPlayerTrace(ply))
			local ang = ply:GetAimVector():Angle()
			local angSet = Angle(0, ang.Yaw - 180, 0)
			local pos = Vector(trace.HitPos.X, trace.HitPos.Y, trace.HitPos.Z)

			self.AASEnt:SetPos(pos + AASSwepTable[self:GetStage() + 1]["vector"])
			self.AASEnt:SetAngles(angSet)
			self.AASEnt:SetModel(AASSwepTable[self:GetStage() + 1]["model"])
		else 
			self:CreateAASEnt() 
		end
	end
end 

function TOOL:Holster()
	if CLIENT then
		local ply = self:GetOwner()
		if not IsValid(ply) and not ply:IsPlayer() or not AAS.AdminRank[ply:GetUserGroup()] then return end

		if IsValid(self.AASEnt) then 
			self.AASEnt:Remove()
		end
	end
end

function TOOL:Reload()
	local ply = self:GetOwner()
	if not IsValid(ply) and not ply:IsPlayer() or not AAS.AdminRank[ply:GetUserGroup()] then return end

	if self:GetStage() < 2 then
		self:SetStage(self:GetStage() + 1)
	else
		self:SetStage(0)
	end
end

function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl("label", {
	Text = "Save Advanced Accessory Entities" })
	CPanel:Button("Save Entities", "aas_save_entity")

	CPanel:AddControl("label", {
	Text = "Remove all Entities in The Data" })
	CPanel:Button("Remove Entities Data", "aas_remove_entitysql")

	CPanel:AddControl("label", {
	Text = "Remove all Entities in The Map" })
	CPanel:Button("Remove Entities Map", "aas_remove_entity")

	CPanel:AddControl("label", {
	Text = "Reload all Entities in The Map" })
	CPanel:Button("Reload Entities Map", "aas_reload_entity")
end

--PATH lua/weapons/gmod_tool/stools/catmullrom_camera.lua:
TOOL.Category   = "Main"
TOOL.Name       = "Camera Layout"
TOOL.Command    = nil
TOOL.ConfigName	= nil
TOOL.Tab        = "CRCCams"



TOOL.ClientConVar["key"] = "-1"

TOOL.ClientConVar["facetraveldir"] = "0"

TOOL.ClientConVar["bankonturn"]    = "1"
TOOL.ClientConVar["bankdelta_max"] = "1"
TOOL.ClientConVar["bank_multi"]    = "1"

TOOL.ClientConVar["zoom"] = "75"

TOOL.ClientConVar["enable_roll"] = "0"
TOOL.ClientConVar["roll"]        = "0"

--TOOL.ClientConVar["enable_stay_on_end"] = "0"
--TOOL.ClientConVar["enable_looping"]     = "0"

function TOOL:LeftClick(trace)
	return CatmullRomCams.SToolMethods.Layout.LeftClick(self, trace)
end

function TOOL:RightClick(trace)
	return CatmullRomCams.SToolMethods.Layout.RightClick(self, trace)
end

function TOOL:Reload(trace)
	return CatmullRomCams.SToolMethods.Layout.Reload(self, trace)
end

function TOOL:Think()
	return CatmullRomCams.SToolMethods.Layout.Think(self)
end

function TOOL:ValidTrace(trace)
	return CatmullRomCams.SToolMethods.ValidTrace(trace)
end

function TOOL.BuildCPanel(panel)
	return CatmullRomCams.SToolMethods.Layout.BuildCPanel(panel)
end


--PATH lua/weapons/gmod_tool/stools/drgbase_tool_disableai.lua:
TOOL.Tab = "DrGBase"
TOOL.Category = "Tools"
TOOL.Name = "#tool.drgbase_tool_disableai.name"
TOOL.BuildCPanel = function(panel)
	panel:Help("#tool.drgbase_tool_disableai.desc")
	panel:Help("#tool.drgbase_tool_disableai.0")
end

function TOOL:LeftClick(tr)
	if not IsValid(tr.Entity) then return false end
	if not tr.Entity.IsDrGNextbot then return false end
	if SERVER then tr.Entity:SetAIDisabled(not tr.Entity:IsAIDisabled()) end
	return true
end

if CLIENT then
	language.Add("tool.drgbase_tool_disableai.name", "Disable AI")
	language.Add("tool.drgbase_tool_disableai.desc", "Disable/enable AI for a nextbot.")
	language.Add("tool.drgbase_tool_disableai.0", "Left click to toggle AI. (Green => Enabled / Red => Disabled)")

	hook.Add("PreDrawHalos", "DrGBaseToolDisableAIHalos", function()
		local wep = LocalPlayer():GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() ~= "gmod_tool" then return end
		local tool = LocalPlayer():GetTool()
		if tool == nil or tool.Mode ~= "drgbase_tool_disableai" then return end
		local enabled = {}
		local disabled = {}
		for i, nextbot in ipairs(DrGBase.GetNextbots()) do
			if not IsValid(nextbot) then continue end
			if nextbot:IsAIDisabled() then table.insert(disabled, nextbot)
			else table.insert(enabled, nextbot) end
		end
		halo.Add(enabled, DrGBase.CLR_GREEN)
		halo.Add(disabled, DrGBase.CLR_RED)
	end)
end

--PATH lua/weapons/gmod_tool/stools/drgbase_tool_scale.lua:
TOOL.Tab = "DrGBase"
TOOL.Category = "Tools"
TOOL.Name = "#tool.drgbase_tool_scale.name"
TOOL.BuildCPanel = function(panel)
	panel:Help("#tool.drgbase_tool_scale.desc")
	panel:Help("#tool.drgbase_tool_scale.0")
end

function TOOL:LeftClick(tr)
	if not IsValid(tr.Entity) then return false end
	if not tr.Entity.IsDrGNextbot then return false end
	if SERVER then tr.Entity:Scale(1.1, 0.1) end
	return true
end
function TOOL:RightClick(tr)
	if not IsValid(tr.Entity) then return false end
	if not tr.Entity.IsDrGNextbot then return false end
	if SERVER then tr.Entity:Scale(0.9, 0.1) end
	return true
end
function TOOL:Reload(tr)
	if not IsValid(tr.Entity) then return false end
	if not tr.Entity.IsDrGNextbot then return false end
	if SERVER then tr.Entity:SetScale(1, 0.1) end
	return true
end

if CLIENT then
	language.Add("tool.drgbase_tool_scale.name", "Change Scale")
	language.Add("tool.drgbase_tool_scale.desc", "Change the scale of a nextbot.")
	language.Add("tool.drgbase_tool_scale.0", "Left click to scale up, right click to scale down, reload to reset scale.")
end

--PATH lua/weapons/gmod_tool/stools/fading_door.lua:
TOOL.Category = "Construction"
TOOL.Name = "#Fading Doors"

TOOL.ClientConVar["key"] = "41"
TOOL.ClientConVar["swap"] = "0"
TOOL.ClientConVar["reversed"] = "0"
TOOL.ClientConVar["mat"] = "sprites/heatwave"
TOOL.ClientConVar["opensound"] = "0"
TOOL.ClientConVar["loopsound"] = "0"
TOOL.ClientConVar["closesound"] = "0"

list.Add("FDoorMaterials", "sprites/heatwave")
list.Add("FDoorMaterials", "models/wireframe")
list.Add("FDoorMaterials", "debug/env_cubemap_model")
list.Add("FDoorMaterials", "models/shadertest/shader3")
list.Add("FDoorMaterials", "models/shadertest/shader4")
list.Add("FDoorMaterials", "models/shadertest/shader5")
list.Add("FDoorMaterials", "models/shiny")
list.Add("FDoorMaterials", "models/debug/debugwhite")
list.Add("FDoorMaterials", "Models/effects/comball_sphere")
list.Add("FDoorMaterials", "Models/effects/comball_tape")
list.Add("FDoorMaterials", "Models/effects/splodearc_sheet")
list.Add("FDoorMaterials", "Models/effects/vol_light001")
list.Add("FDoorMaterials", "models/props_combine/stasisshield_sheet")
list.Add("FDoorMaterials", "models/props_combine/portalball001_sheet")
list.Add("FDoorMaterials", "models/props_combine/com_shield001a")
list.Add("FDoorMaterials", "models/props_c17/frostedglass_01a")
list.Add("FDoorMaterials", "models/props_lab/Tank_Glass001")
list.Add("FDoorMaterials", "models/props_combine/tprings_globe")
list.Add("FDoorMaterials", "models/rendertarget")
list.Add("FDoorMaterials", "models/screenspace")
list.Add("FDoorMaterials", "brick/brick_model")
list.Add("FDoorMaterials", "models/props_pipes/GutterMetal01a")
list.Add("FDoorMaterials", "models/props_pipes/Pipesystem01a_skin3")
list.Add("FDoorMaterials", "models/props_wasteland/wood_fence01a")
list.Add("FDoorMaterials", "models/props_foliage/tree_deciduous_01a_trunk")
list.Add("FDoorMaterials", "models/props_c17/FurnitureFabric003a")
list.Add("FDoorMaterials", "models/props_c17/FurnitureMetal001a")
list.Add("FDoorMaterials", "models/props_c17/paper01")
list.Add("FDoorMaterials", "models/flesh")

if SERVER then
	util.AddNetworkString("DrawFadeDoor")
end

local Sounds = {}
Sounds[1] = Sound("doors/doorstop1.wav")
Sounds[2] = Sound("npc/turret_floor/retract.wav")
Sounds[3] = Sound("npc/roller/mine/combine_mine_deactivate1.wav")
Sounds[4] = Sound("npc/roller/mine/combine_mine_deploy1.wav")
Sounds[5] = Sound("npc/roller/mine/rmine_taunt1.wav")
Sounds[6] = Sound("npc/scanner/scanner_nearmiss2.wav")
Sounds[7] = Sound("npc/scanner/scanner_siren1.wav")
Sounds[8] = Sound("npc/barnacle/barnacle_gulp1.wav")
Sounds[9] = Sound("npc/barnacle/barnacle_gulp2.wav")
Sounds[10] = Sound("npc/combine_gunship/attack_start2.wav")
Sounds[11] = Sound("npc/combine_gunship/attack_stop2.wav")
Sounds[12] = Sound("npc/dog/dog_pneumatic1.wav")
Sounds[13] = Sound("npc/dog/dog_pneumatic2.wav")

util.PrecacheSound(Sounds[1])
util.PrecacheSound(Sounds[2])
util.PrecacheSound(Sounds[3])
util.PrecacheSound(Sounds[4])
util.PrecacheSound(Sounds[5])
util.PrecacheSound(Sounds[6])
util.PrecacheSound(Sounds[7])
util.PrecacheSound(Sounds[8])
util.PrecacheSound(Sounds[9])
util.PrecacheSound(Sounds[10])
util.PrecacheSound(Sounds[11])
util.PrecacheSound(Sounds[12])
util.PrecacheSound(Sounds[13])

local LoopSounds = {}
LoopSounds[1] = "ambient/machines/machine6.wav"
LoopSounds[2] = "ambient/energy/force_field_loop1.wav"
LoopSounds[3] = "physics/metal/canister_scrape_smooth_loop1.wav"
LoopSounds[4] = "ambient/levels/citadel/citadel_drone_loop5.wav"
LoopSounds[5] = "ambient/levels/citadel/citadel_drone_loop6.wav"
LoopSounds[6] = "ambient/atmosphere/city_rumble_loop1.wav"
LoopSounds[7] = "ambient/machines/city_ventpump_loop1.wav"
LoopSounds[8] = "ambient/machines/combine_shield_loop3.wav"
LoopSounds[9] = "npc/manhack/mh_engine_loop1.wav"
LoopSounds[10] = "npc/manhack/mh_engine_loop2.wav"

if CLIENT then
	language.Add("Tool.fading_door.name", "Fading Doors")
	language.Add("Tool.fading_door.desc", "Makes anything into a fadable door")
	language.Add("Tool.fading_door.0", "Click on something to make it a fading door. Right click to copy data. Reload to remove fading door.")
	
	function TOOL:BuildCPanel()
		self:AddControl("Header",   {Text = "#Tool.fading_door.name", Description = "#Tool.fading_door.desc"})
		self:AddControl("CheckBox", {Label = "Reversed", Command = "fading_door_reversed"})
		self:AddControl("CheckBox", {Label = "Toggle Active", Command = "fading_door_swap"})
		
		local DoorOpenSound = vgui.Create("CtrlListBox", self)
		DoorOpenSound:AddOption("None", {fading_door_opensound = "0"})
		if file.Exists("sound/doors/doorstop1.wav", "GAME") then DoorOpenSound:AddOption("1", {fading_door_opensound = "1"}) end
		if file.Exists("sound/npc/turret_floor/retract.wav", "GAME") then DoorOpenSound:AddOption("2", {fading_door_opensound = "2"}) end
		if file.Exists("sound/npc/roller/mine/combine_mine_deactivate1.wav", "GAME") then DoorOpenSound:AddOption("3", {fading_door_opensound = "3"}) end
		if file.Exists("sound/npc/roller/mine/combine_mine_deploy1.wav", "GAME") then DoorOpenSound:AddOption("4", {fading_door_opensound = "4"}) end
		if file.Exists("sound/npc/roller/mine/rmine_taunt1.wav", "GAME") then DoorOpenSound:AddOption("5", {fading_door_opensound = "5"}) end
		if file.Exists("sound/npc/scanner/scanner_nearmiss2.wav", "GAME") then DoorOpenSound:AddOption("6", {fading_door_opensound = "6"}) end
		if file.Exists("sound/npc/scanner/scanner_siren1.wav", "GAME") then DoorOpenSound:AddOption("7", {fading_door_opensound = "7"}) end
		if file.Exists("sound/npc/barnacle/barnacle_gulp1.wav", "GAME") then DoorOpenSound:AddOption("8", {fading_door_opensound = "8"}) end
		if file.Exists("sound/npc/barnacle/barnacle_gulp2.wav", "GAME") then DoorOpenSound:AddOption("9", {fading_door_opensound = "9"}) end
		if file.Exists("sound/npc/combine_gunship/attack_start2.wav", "GAME") then DoorOpenSound:AddOption("10", {fading_door_opensound = "10"}) end
		if file.Exists("sound/npc/combine_gunship/attack_stop2.wav", "GAME") then DoorOpenSound:AddOption("11", {fading_door_opensound = "11"}) end
		if file.Exists("sound/npc/dog/dog_pneumatic1.wav", "GAME") then DoorOpenSound:AddOption("12", {fading_door_opensound = "12"}) end
		if file.Exists("sound/npc/dog/dog_pneumatic2.wav", "GAME") then DoorOpenSound:AddOption("13", {fading_door_opensound = "13"}) end
		
		local left = vgui.Create("DLabel", self)
		left:SetText("Open Sound")
		left:SetDark(true)
		DoorOpenSound:SetHeight(25)
		DoorOpenSound:Dock(TOP)
		
		self:AddItem(left, DoorOpenSound)
		
		local DoorActiveSound = vgui.Create("CtrlListBox", self)
		DoorActiveSound:AddOption("None", {fading_door_loopsound = "0"})
		if file.Exists("sound/"..LoopSounds[1], "GAME") then DoorActiveSound:AddOption("1", {fading_door_loopsound = "1"}) end
		if file.Exists("sound/"..LoopSounds[2], "GAME") then DoorActiveSound:AddOption("2", {fading_door_loopsound = "2"}) end
		if file.Exists("sound/"..LoopSounds[3], "GAME") then DoorActiveSound:AddOption("3", {fading_door_loopsound = "3"}) end
		if file.Exists("sound/"..LoopSounds[4], "GAME") then DoorActiveSound:AddOption("4", {fading_door_loopsound = "4"}) end
		if file.Exists("sound/"..LoopSounds[5], "GAME") then DoorActiveSound:AddOption("5", {fading_door_loopsound = "5"}) end
		if file.Exists("sound/"..LoopSounds[6], "GAME") then DoorActiveSound:AddOption("6", {fading_door_loopsound = "6"}) end
		if file.Exists("sound/"..LoopSounds[7], "GAME") then DoorActiveSound:AddOption("7", {fading_door_loopsound = "7"}) end
		if file.Exists("sound/"..LoopSounds[8], "GAME") then DoorActiveSound:AddOption("8", {fading_door_loopsound = "8"}) end
		if file.Exists("sound/"..LoopSounds[9], "GAME") then DoorActiveSound:AddOption("9", {fading_door_loopsound = "9"}) end
		if file.Exists("sound/"..LoopSounds[10], "GAME") then DoorActiveSound:AddOption("10", {fading_door_loopsound = "10"}) end
		
		local left = vgui.Create("DLabel", self)
		left:SetText("Active Sound")
		left:SetDark(true)
		DoorActiveSound:SetHeight(25)
		DoorActiveSound:Dock(TOP)
		
		self:AddItem(left, DoorActiveSound)
		
		local DoorCloseSound = vgui.Create("CtrlListBox", self)
		DoorCloseSound:AddOption("None", {fading_door_closesound = "0"})
		if file.Exists("sound/doors/doorstop1.wav", "GAME") then DoorCloseSound:AddOption("1", {fading_door_closesound = "1"}) end
		if file.Exists("sound/npc/turret_floor/retract.wav", "GAME") then DoorCloseSound:AddOption("2", {fading_door_closesound = "2"}) end
		if file.Exists("sound/npc/roller/mine/combine_mine_deactivate1.wav", "GAME") then DoorCloseSound:AddOption("3", {fading_door_closesound = "3"}) end
		if file.Exists("sound/npc/roller/mine/combine_mine_deploy1.wav", "GAME") then DoorCloseSound:AddOption("4", {fading_door_closesound = "4"}) end
		if file.Exists("sound/npc/roller/mine/rmine_taunt1.wav", "GAME") then DoorCloseSound:AddOption("5", {fading_door_closesound = "5"}) end
		if file.Exists("sound/npc/scanner/scanner_nearmiss2.wav", "GAME") then DoorCloseSound:AddOption("6", {fading_door_closesound = "6"}) end
		if file.Exists("sound/npc/scanner/scanner_siren1.wav", "GAME") then DoorCloseSound:AddOption("7", {fading_door_closesound = "7"}) end
		if file.Exists("sound/npc/barnacle/barnacle_gulp1.wav", "GAME") then DoorCloseSound:AddOption("8", {fading_door_closesound = "8"}) end
		if file.Exists("sound/npc/barnacle/barnacle_gulp2.wav", "GAME") then DoorCloseSound:AddOption("9", {fading_door_closesound = "9"}) end
		if file.Exists("sound/npc/combine_gunship/attack_start2.wav", "GAME") then DoorCloseSound:AddOption("10", {fading_door_closesound = "10"}) end
		if file.Exists("sound/npc/combine_gunship/attack_stop2.wav", "GAME") then DoorCloseSound:AddOption("11", {fading_door_closesound = "11"}) end
		if file.Exists("sound/npc/dog/dog_pneumatic1.wav", "GAME") then DoorCloseSound:AddOption("12", {fading_door_closesound = "12"}) end
		if file.Exists("sound/npc/dog/dog_pneumatic2.wav", "GAME") then DoorCloseSound:AddOption("13", {fading_door_closesound = "13"}) end
		
		local left = vgui.Create("DLabel", self)
		left:SetText("Close Sound")
		left:SetDark(true)
		DoorCloseSound:SetHeight(25)
		DoorCloseSound:Dock(TOP)
		
		self:AddItem(left, DoorCloseSound)
		self:AddControl("Numpad", {Label = "Button", ButtonSize = "22", Command = "fading_door_key"})
		self:MatSelect("fading_door_mat", list.Get("FDoorMaterials"), true, 0.33, 0.33)
	end
	
	local EFFECT = {}
	
	net.Receive("DrawFadeDoor",function()
		local String = net.ReadString()
		if String == "0" then
			EFFECT.Type = nil
			EFFECT.Ent = nil
			if EFFECT.Remove == false then EFFECT.Remove = true end
		else
			EFFECT.Type = nil
			EFFECT.Ent = nil
			if EFFECT.Remove == nil then util.Effect("render_fade_door", EffectData()) end
			EFFECT.Remove = false
			
			local Table = string.Explode("_",String)
			local Ent = ents.GetByIndex(tonumber(Table[1]))
			if IsValid(Ent) then
				EFFECT.Type = tonumber(Table[2])
				EFFECT.Ent = Ent
			end
		end
	end)
	
	function EFFECT:Init(data) end

	function EFFECT:Think()
		-- This makes the effect always visible.
		local pl = LocalPlayer()
		local Pos = pl:EyePos()
		local Trace = {}
		Trace.start = Pos
		Trace.endpos = Pos+(pl:GetAimVector()*10)
		Trace.filter = {pl}
		local TR = util.TraceLine(Trace)
		self:SetPos(TR.HitPos)
		
		-- Remove when ent is not valid.
		if !IsValid(EFFECT.Ent) then
			EFFECT.Type = nil
			EFFECT.Ent = nil
			EFFECT.Remove = true
		end
		
		if EFFECT.Remove or EFFECT.Remove == nil then
			EFFECT.Remove = nil
			return false
		end
		return true
	end
	
	function EFFECT:Render()
		if IsValid(EFFECT.Ent) then
			if EFFECT.Type == 1 then
				halo.Add({EFFECT.Ent}, Color(255, 255, 255, 255), 10, 10, 1, true, false)
			elseif EFFECT.Type == 2 then
				halo.Add({EFFECT.Ent}, Color(100, 255, 100, 255), 10, 10, 1, true, false)
			else
				halo.Add({EFFECT.Ent}, Color(255, 150, 50, 255), 10, 10, 1, true, false)
			end
		end
	end
	
	effects.Register(EFFECT,"render_fade_door",true)
	
	function TOOL:LeftClick(tr)
		if !tr.Entity or !tr.Entity:IsValid() then return false end
		if tr.Entity:IsPlayer() or tr.HitWorld then return false end
		return true
	end
	
	function TOOL:RightClick(tr)
		if !tr.Entity or !tr.Entity:IsValid() then return false end
		if tr.Entity:IsPlayer() or tr.HitWorld then return false end
		return true
	end

	function TOOL:Reload(tr)
		if !tr.Entity or !tr.Entity:IsValid() then return false end
		if tr.Entity:IsPlayer() or tr.HitWorld then return false end
		return true
	end
	
	return
end

local function fadeActivate(self)
	if self.fadeActive then return end
	self.fadeActive = true
	self.fadeMaterial = self:GetMaterial()
	self.fadeDoorMaterial = self.fadeDoorMaterial or "sprites/heatwave"
	self:SetMaterial(self.fadeDoorMaterial)
	self:DrawShadow(false)
	if self.fadeCanDisableMotion then self:SetNotSolid(true) else self:SetCollisionGroup(COLLISION_GROUP_WORLD) end
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		self.fadeMoveable = phys:IsMoveable()
		phys:EnableMotion(false)
	end
	
	if self.fadeDoorOpenSound and Sounds and Sounds[self.fadeDoorOpenSound] then
		self:EmitSound(Sounds[self.fadeDoorOpenSound],350,100)
	end
	
	if self.fadeDoorLoopSound and LoopSounds and LoopSounds[self.fadeDoorLoopSound] and !self.FadeDoorSound then
		self.FadeDoorSound = CreateSound(self, LoopSounds[self.fadeDoorLoopSound])
		self.FadeDoorSound:Play()
	end
	
	if WireLib then
		Wire_TriggerOutput(self,  "FadeActive",  1)
	end
end

local function fadeDeactivate(self)
	self.fadeActive = false
	if self:GetMaterial() == self.fadeDoorMaterial and self.fadeMaterial then self:SetMaterial(self.fadeMaterial) end
	self:DrawShadow(true)
	if self.fadeCanDisableMotion then self:SetNotSolid(false) else self:SetCollisionGroup(COLLISION_GROUP_NONE) end
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		phys:EnableMotion(self.fadeMoveable or false)
		phys:Wake()
	end
	
	if self.fadeDoorCloseSound and Sounds and Sounds[self.fadeDoorCloseSound] then
		self:EmitSound(Sounds[self.fadeDoorCloseSound],350,100)
	end
	
	if self.FadeDoorSound then self.FadeDoorSound:Stop() end
	self.FadeDoorSound = nil
	
	if WireLib then
		Wire_TriggerOutput(self,  "FadeActive",  0)
	end
end

local function onUp(pl, Ent)
	if IsValid(Ent) then
		local Activate = false
		if Ent.fadeToggle then
			if Ent.fadeReversed then
				Activate = !Ent.fadeActive
			else
				Activate = Ent.fadeActive
			end
		elseif Ent.fadeReversed then
			Activate = true
		end
		if Activate then
			if !Ent.fadeActive then Ent:fadeActivate() end
		else
			if Ent.fadeActive then Ent:fadeDeactivate() end
		end
	end
end
numpad.Register("Fading Door onUp", onUp)

local function onDown(pl, Ent)
	if IsValid(Ent) then
		local Activate = true
		if Ent.fadeToggle then
			if Ent.fadeReversed then
				Activate = Ent.fadeActive
			else
				Activate = !Ent.fadeActive
			end
		elseif Ent.fadeReversed then
			Activate = false
		end
		if Activate then
			if !Ent.fadeActive then Ent:fadeActivate() end
		else
			if Ent.fadeActive then Ent:fadeDeactivate() end
		end
	end
end
numpad.Register("Fading Door onDown", onDown)

local function getWireInputs(Ent)
	local inputs = Ent.Inputs
	local names, types, descs = {}, {}, {}
	if inputs then
		local num
		for _, data in pairs(inputs) do
			num = data.Num
			names[num] = data.Name
			types[num] = data.Type
			descs[num] = data.Desc
		end
	end
	return names, types, descs
end

local function doWireInputs(Ent)
	local inputs = Ent.Inputs
	if !inputs then
		Wire_CreateInputs(Ent, {"Fade"})
		return
	end
	local names, types, descs = {}, {}, {}
	local num
	for _, data in pairs(inputs) do
		num = data.Num
		names[num] = data.Name
		types[num] = data.Type
		descs[num] = data.Desc
	end
	table.insert(names, "Fade")
	WireLib.AdjustSpecialInputs(Ent, names, types, descs)
end

local function doWireOutputs(Ent)
	local outputs = Ent.Outputs
	if !outputs then
		Wire_CreateOutputs(Ent, {"FadeActive"})
		return
	end
	local names, types, descs = {}, {}, {}
	local num
	for _, data in pairs(outputs) do
		num = data.Num
		names[num] = data.Name
		types[num] = data.Type
		descs[num] = data.Desc
	end
	table.insert(names, "FadeActive")
	WireLib.AdjustSpecialOutputs(Ent, names, types, descs)
end

local function TriggerInput(self, name, value, ...)
	if name == "Fade" then
		if value == 0 then onUp(nil, self) else onDown(nil, self) end
	elseif self.fadeTriggerInput then
		return self:fadeTriggerInput(name, value, ...)
	end
end

local function PreEntityCopy(self)
	if self then
		local info = WireLib.BuildDupeInfo(self)
		if info then duplicator.StoreEntityModifier(self, "WireDupeInfo", info) end
		if self.fadePreEntityCopy then self:fadePreEntityCopy() end
	end
end

local function PostEntityPaste(self, pl, Ent, ents)
	if self then
		if self.EntityMods and self.EntityMods.WireDupeInfo then WireLib.ApplyDupeInfo(pl, self, self.EntityMods.WireDupeInfo, function(id) return ents[id] end) end
		if self.fadePostEntityPaste then self:fadePostEntityPaste(pl, Ent, ents) end
	end
end

local function onRemove(self)
	if self.fadeDeactivate then self:fadeDeactivate() end
	self.isFadingDoor = nil
	self.PreEntityCopy = self.fadePreEntityCopy
	self.fadePreEntityCopy = nil
	self.PostEntityPaste = self.fadePostEntityPaste
	self.fadePostEntityPaste = nil
	self.TriggerInput = self.fadeTriggerInput
	self.fadeTriggerInput = nil
	duplicator.ClearEntityModifier(self, "Fading Door")
	if self.fadeUpNum then numpad.Remove(self.fadeUpNum) end
	if self.fadeDownNum then numpad.Remove(self.fadeDownNum) end
	self.fadeActive = nil
	self.fadeMaterial = nil
	if IsValid(self.FadingDoorDummy) then self.FadingDoorDummy:Remove() end
	self.FadingDoorDummy = nil
	self.fadeToggle = nil
	self.fadeDoorMaterial = nil
	self.fadeMoveable = nil
	self.fadeCanDisableMotion = nil
	self.fadeDoorOpenSound = nil
	self.fadeDoorCloseSound = nil
	self.fadeDoorLoopSound = nil
	self.fadeDeactivate = nil
	self.fadeUpNum = nil
	self.fadeDownNum = nil
	self.fadeToggleActive = nil
	self.fadeReversed = nil
	self.fadeActivate = nil
	self.fadeKey = nil
	if self.OnDieFunctions then
		self.OnDieFunctions["UndoFadingDoor"..self:EntIndex()] = nil
		self.OnDieFunctions["Fading Doors"] = nil
	end
	if WireLib then
		if self.Inputs then
			Wire_Link_Clear(self, "Fade")
			self.Inputs['Fade'] = nil
			WireLib._SetInputs(self)
		end
		if self.Outputs then
			local port = self.Outputs['FadeActive']
			if port then
				for i,inp in ipairs(port.Connected) do
					if inp.Entity:IsValid() then
						Wire_Link_Clear(inp.Entity, inp.Name)
					end
				end
			end
			self.Outputs['FadeActive'] = nil
			WireLib._SetOutputs(self)
		end
	end
	if self.EntityMods and self.EntityMods.WireDupeInfo and self.EntityMods.WireDupeInfo.Wires then self.EntityMods.WireDupeInfo.Wires.Fade = nil end
end

local function RemoveKeys(self)
	if self.FadeDoorSound then self.FadeDoorSound:Stop() end
	numpad.Remove(self.fadeUpNum)
	numpad.Remove(self.fadeDownNum)
end

local function dooEet(pl, Ent, stuff)
	if Ent.isFadingDoor then
		if Ent.fadeDeactivate then Ent:fadeDeactivate() end
		RemoveKeys(Ent)
	else
		Ent.isFadingDoor = true
		Ent.fadeActivate = fadeActivate
		Ent.fadeDeactivate = fadeDeactivate
		Ent.fadeToggleActive = fadeToggleActive
		Ent:CallOnRemove("Fading Doors", RemoveKeys)
		if WireLib then
			doWireInputs(Ent)
			doWireOutputs(Ent)
			Ent.fadeTriggerInput = Ent.fadeTriggerInput or Ent.TriggerInput
			Ent.TriggerInput = TriggerInput
			if !Ent.IsWire then
				if !Ent.fadePreEntityCopy and Ent.PreEntityCopy then Ent.fadePreEntityCopy = Ent.PreEntityCopy end
				Ent.PreEntityCopy = PreEntityCopy
				if !Ent.fadePostEntityPaste and Ent.PreEntityCopy then Ent.fadePostEntityPaste = Ent.PostEntityPaste end
				Ent.PostEntityPaste = PostEntityPaste
			end
		end
	end
	Ent.fadeUpNum = numpad.OnUp(pl, stuff.key, "Fading Door onUp", Ent)
	Ent.fadeDownNum = numpad.OnDown(pl, stuff.key, "Fading Door onDown", Ent)
	Ent.fadeToggle = stuff.toggle
	Ent.fadeReversed = stuff.reversed
	Ent.fadeKey = stuff.key
	Ent.fadeCanDisableMotion = stuff.CanDisableMotion
	Ent.fadeDoorMaterial = stuff.DoorMaterial
	Ent.fadeDoorOpenSound = stuff.DoorOpenSound
	Ent.fadeDoorLoopSound = stuff.DoorLoopSound
	Ent.fadeDoorCloseSound = stuff.DoorCloseSound
	if stuff.reversed then Ent:fadeActivate() end
	duplicator.StoreEntityModifier(Ent, "Fading Door", stuff)
	return true
end

duplicator.RegisterEntityModifier("Fading Door", dooEet)
hook.Add("Initialize", "FadingDoor1", function() duplicator.RegisterEntityModifier("Fading Door", dooEet) end)	-- No overwrite.

if !FadingDoor then
	local function legacy(pl, Ent, data)
		return dooEet(pl, Ent, {
			key					= data.Key,
			toggle				= data.Toggle,
			reversed			= data.Inverse,
			CanDisableMotion	= data.CanDisableMotion,
			DoorMaterial		= data.DoorMaterial,
			DoorOpenSound		= data.DoorOpenSound,
			DoorLoopSound		= data.DoorLoopSound,
			DoorCloseSound		= data.DoorCloseSound
		})
	end
	duplicator.RegisterEntityModifier("FadingDoor", legacy)
	hook.Add("Initialize", "FadingDoor2", function() duplicator.RegisterEntityModifier("FadingDoor", legacy) end)	-- No overwrite.
end

function TOOL:LeftClick(tr)
	if !tr.Entity or !tr.Entity:IsValid() then return false end
	if tr.Entity:IsPlayer() or tr.HitWorld then return false end
	if CLIENT then return true end
	
	local Ent = tr.Entity
	local pl = self:GetOwner()
	
	if !IsValid(pl) then return false end
	
	local phys = Ent:GetPhysicsObject()
	local CanDisableMotion = false
	
	if phys:IsValid() then
		local MotionEnabled = phys:IsMotionEnabled()
		phys:EnableMotion(!MotionEnabled)
		CanDisableMotion = MotionEnabled != phys:IsMotionEnabled()
		phys:EnableMotion(MotionEnabled)
	end
	
	if self.AimEnt then
		self.AimEnt[pl] = nil
		net.Start("DrawFadeDoor")
		net.WriteString("0")
		net.Send(pl)
	end
	
	dooEet(pl, Ent, {
		key     			= self:GetClientNumber("key"),
		toggle   			= self:GetClientNumber("swap") == 1,
		reversed			= self:GetClientNumber("reversed") == 1,
		CanDisableMotion	= CanDisableMotion,
		DoorMaterial		= self:GetClientInfo("mat"),
		DoorOpenSound     	= self:GetClientNumber("opensound"),
		DoorLoopSound     	= self:GetClientNumber("loopsound"),
		DoorCloseSound     	= self:GetClientNumber("closesound")
	})
	
	if !IsValid(Ent.FadingDoorDummy) then
		local Dummy = ents.Create("info_null")
		Dummy.Owner = pl
		Dummy.Door = Ent
		undo.Create("Undo fading door")
		undo.AddEntity(Dummy)
		Ent.FadingDoorDummy = Dummy
		local UndoT = {Ent,self:GetOwner(),self}
		undo.AddFunction(function(Undo, UndoT)
			local Ent = UndoT[1]
			local pl = UndoT[2]
			local Tool = UndoT[3]
			if IsValid(Ent) then onRemove(Ent) end
			if IsValid(pl) then
				if Tool and Tool.AimEnt then Tool.AimEnt[pl] = nil end
				net.Start("DrawFadeDoor")
				net.WriteString("0")
				net.Send(pl)
			end
		end, UndoT)
		undo.SetPlayer(pl)
		undo.SetCustomUndoText("Undone Fading Door")
		undo.Finish()
		
		Ent:CallOnRemove("UndoFadingDoor"..Ent:EntIndex(),function(Ent)
			if Ent.FadingDoorDummy and Ent.FadingDoorDummy:IsValid() then
				if IsValid(Ent.FadingDoorDummy.Owner) then
					local PlayerID = Ent.FadingDoorDummy.Owner:UniqueID()
					local PlayerUndo = undo:GetTable()[PlayerID]
					if PlayerUndo then
						for k,v in pairs(PlayerUndo) do
							if PlayerUndo[k] and PlayerUndo[k].Name and PlayerUndo[k].Name == "Undo fading door" and PlayerUndo[k].Entities and IsValid(PlayerUndo[k].Entities[1]) and PlayerUndo[k].Entities[1]:GetTable().Door == Ent then
								undo:GetTable()[PlayerID][k] = nil
								break
							end
						end
					end
				end
				Ent.FadingDoorDummy:Remove()
			end
		end,Ent)
	end
	
	return true
end

function TOOL:RightClick(tr)
	if !tr.Entity or !tr.Entity:IsValid() then return false end
	if tr.Entity:IsPlayer() or tr.HitWorld then return false end
	if CLIENT then return true end
	local Ent = tr.Entity
	if Ent.isFadingDoor then
		local pl = self:GetOwner()
		if !IsValid(pl) then return false end
		if Ent.fadeKey != nil then pl:ConCommand("fading_door_key "..tostring(Ent.fadeKey)) end
		if Ent.fadeToggle != nil then if Ent.fadeToggle then pl:ConCommand("fading_door_swap 1") else pl:ConCommand("fading_door_swap 0") end end
		if Ent.fadeReversed != nil then if Ent.fadeReversed then pl:ConCommand("fading_door_reversed 1") else pl:ConCommand("fading_door_reversed 0") end end
		if Ent.fadeDoorMaterial != nil then pl:ConCommand("fading_door_mat "..Ent.fadeDoorMaterial) end
		if Ent.fadeDoorOpenSound != nil then pl:ConCommand("fading_door_opensound "..tostring(Ent.fadeDoorOpenSound)) end
		if Ent.fadeDoorLoopSound != nil then pl:ConCommand("fading_door_loopsound "..tostring(Ent.fadeDoorLoopSound)) end
		if Ent.fadeDoorCloseSound != nil then pl:ConCommand("fading_door_closesound "..tostring(Ent.fadeDoorCloseSound)) end
		return true
	end
end

function TOOL:Reload(tr)
	if !tr.Entity or !tr.Entity:IsValid() then return false end
	if tr.Entity:IsPlayer() or tr.HitWorld then return false end
	if CLIENT then return true end
	local Ent = tr.Entity
	
	if Ent.isFadingDoor then
		if IsValid(Ent.FadingDoorDummy) then
			if IsValid(Ent.FadingDoorDummy.Owner) then
				local PlayerID = Ent.FadingDoorDummy.Owner:UniqueID()
				local PlayerUndo = undo:GetTable()[PlayerID]
				if PlayerUndo then
					for k,v in pairs(PlayerUndo) do
						if PlayerUndo[k] and PlayerUndo[k].Name and PlayerUndo[k].Name == "Undo fading door" and PlayerUndo[k].Entities and IsValid(PlayerUndo[k].Entities[1]) and PlayerUndo[k].Entities[1]:GetTable().Door == Ent then
							undo:GetTable()[PlayerID][k] = nil
							break
						end
					end
				end
			end
			Ent.FadingDoorDummy:Remove()
		end
		onRemove(Ent)
		net.Start("DrawFadeDoor")
		net.WriteString(tostring(Ent:EntIndex()).."_1")
		net.Send(self:GetOwner())
		return true
	end
end

function TOOL:Holster()
	if CLIENT then return end
	local pl = self:GetOwner()
	if !IsValid(pl) then return false end
	if self.AimEnt and self.AimEnt[pl] != nil then
		self.AimEnt[pl] = nil
		net.Start("DrawFadeDoor")
		net.WriteString("0")
		net.Send(pl)
	end
end

function TOOL:Think()
	if CLIENT then return end
	if self.Hold then return end
	local pl = self:GetOwner()
	local trace = pl:GetEyeTrace()
	
	if trace.Hit and trace.Entity and trace.Entity:IsValid() and !trace.Entity:IsPlayer() then
		if !self.AimEnt then self.AimEnt = {} end
		if !self.OldKey then self.OldKey = {} end
		if !self.OldToggle then self.OldToggle = {} end
		if !self.OldReversed then self.OldReversed = {} end
		
		if !IsValid(pl) then return false end
		
		if trace.Entity != self.AimEnt[pl] or self:GetClientNumber("key") != self.OldKey[pl] or self:GetClientNumber("swap") != self.OldToggle[pl] or self:GetClientNumber("reversed") != self.OldReversed[pl] then
			self.AimEnt[pl] = trace.Entity
			local Key = self:GetClientNumber("key")
			self.OldKey[pl] = Key
			local Toggle = self:GetClientNumber("swap")
			self.OldToggle[pl] = Toggle
			local Reversed = self:GetClientNumber("reversed")
			self.OldReversed[pl] = Reversed
			if trace.Entity.isFadingDoor then
				Toggle = Toggle == 1
				Reversed = Reversed == 1
				if trace.Entity.fadeKey == Key and trace.Entity.fadeReversed == Reversed and trace.Entity.fadeToggle == Toggle then
					net.Start("DrawFadeDoor")
					net.WriteString(tostring(trace.Entity:EntIndex()).."_2")
					net.Send(pl)
				else
					net.Start("DrawFadeDoor")
					net.WriteString(tostring(trace.Entity:EntIndex()).."_3")
					net.Send(pl)
				end
			else
				net.Start("DrawFadeDoor")
				net.WriteString(tostring(trace.Entity:EntIndex()).."_1")
				net.Send(pl)
			end
		end
	elseif self.AimEnt and self.AimEnt[pl] != nil then
		self.AimEnt[pl] = nil
		net.Start("DrawFadeDoor")
		net.WriteString("0")
		net.Send(pl)
	end
end
--PATH addons/sl_utils/lua/weapons/guigui_handcuffed.lua:
SWEP.PrintName = guigui_handcuff_lang().PrintName
SWEP.Author = "Guillaume"
SWEP.Category = "Guillaume's weapons"
SWEP.Contact = "steamcommunity.com/id/guillaume_"
SWEP.Slot = 0
SWEP.SlotPos = 0
SWEP.Spawnable = false
SWEP.ViewModelFOV = 62
SWEP.WorldModel = ""
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"
SWEP.UseHands = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.DrawAmmo = false

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
    return true
end

function SWEP:PreDrawViewModel()
    return true
end

function SWEP:Holster()
	return false
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end
--PATH addons/sl_utils/lua/weapons/guigui_handcuffs.lua:
SWEP.PrintName = guigui_handcuff_lang().PrintName
SWEP.Author = "Guillaume"
SWEP.Category = "Guillaume's weapons"
SWEP.Instructions = guigui_handcuff_lang().Instructions
SWEP.Contact = "steamcommunity.com/id/guillaume_"
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.ViewModelFOV = 62
SWEP.WorldModel = ""
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"
SWEP.UseHands = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic  = true
SWEP.Secondary.Ammo = "none"
SWEP.DrawAmmo = false

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
	return true
end

function SWEP:PreDrawViewModel()
	return true
end

function SWEP:PrimaryAttack()
	if SERVER then 
		local ply = self.Owner
		local ent = ply:GetEyeTrace().Entity
		if ply:GetPos():DistToSqr(ent:GetPos())<2500 then
			local wep = ent:GetActiveWeapon():GetClass()
			if wep == "guigui_handcuffed" then return false end
			if guigui_handcuff_wep(wep) then
				ply:PrintMessage(4, "...")
				timer.Simple(2, function() if ply:GetPos():DistToSqr(ent:GetPos())<2500 and ply:GetActiveWeapon():GetClass() == "guigui_handcuffs" then Handcuff(ent, ply) end end)
			end
		end
	end
end

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self.Owner
	local ent = ply:GetEyeTrace().Entity
	if ply:GetPos():DistToSqr(ent:GetPos())<2500 then
		if ent:IsValid() and ent:IsPlayer() then
			local wep = ent:GetActiveWeapon():GetClass()
			if wep == "guigui_handcuffed" then
				ply:PrintMessage(4, "...")
				timer.Simple(2, function() if ply:GetPos():DistToSqr(ent:GetPos())<2500 and ply:GetActiveWeapon():GetClass() == "guigui_handcuffs" then RemoveHandcuff(ent, ply) end end)
			end
		end
	end
end

function SWEP:Reload()
end
--PATH gamemodes/mangarp/entities/weapons/ls_sniper/cl_init.lua:
include("shared.lua")
local deltas = {-44, -34, -24, -14, 44, 34, 24, 14}
function SWEP:DrawHUD()
    if self:GetScopeLevel() < 2 then return end

    --Width hairs
    draw.RoundedBox(1, ScrW() / 2 - 54, ScrH() / 2, 50, 1, color_black)
    draw.RoundedBox(1, ScrW() / 2 + 4, ScrH() / 2, 50, 1, color_black)

    draw.RoundedBox(1, ScrW() / 2, ScrH() / 2 - 54, 1, 50, color_black)
    draw.RoundedBox(1, ScrW() / 2, ScrH() / 2 + 4, 1, 50, color_black)

    for _, v in ipairs(deltas) do
        draw.RoundedBox(1, ScrW() / 2 + v, ScrH() / 2 - 5, 1, 11, color_black)
        draw.RoundedBox(1, ScrW() / 2 - 5, ScrH() / 2 + v, 11, 1, color_black)
    end
end

--PATH addons/sl_main_system/lua/weapons/mad_baton12/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_baton14/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_baton16/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "16 : Baton avec catalyseur" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/baton18.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_baton" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Baton NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "magie"
SWEP.holdtype = "sl_mage_ht_mad"
SWEP.BonusDegats = 130

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_baton2/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "2 : Baguette naturelle" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/baton2.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_baton" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Baton NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

SWEP.TypeArme = "magie"
SWEP.BonusDegats = 18
SWEP.holdtype = "sl_mage_ht_mad"
--PATH addons/sl_main_system/lua/weapons/mad_baton9/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_dague10/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "10 : Dague √©pur√©" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/dague36.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_dague" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Dague NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "dague"
SWEP.holdtype = "sl_dague_ht_mad"
SWEP.BonusDegats = 82

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_dague16/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_dague20/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_dague22/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_dague6/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "6 : Dague Flambloyante" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/dague10.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_dague" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Dague NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "dague"
SWEP.holdtype = "sl_dague_ht_mad"
SWEP.BonusDegats = 50

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_epee/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "Base : √âp√©e" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ShowWorldModel         = false
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "weapon_base" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Epee NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------

local DATA = {}
DATA.Name = "sl_epee_ht_mad"
DATA.HoldType = "sl_epee_ht_mad"
DATA.BaseHoldType = "normal"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
    { Sequence = "mad_an_hero_asta_101_combat_idle_01 retarget", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
    { Sequence = "mad_eaujump3", Weight = 1 },
}            

DATA.Translations[ ACT_MP_WALK ] = {
    { Sequence = "phalanx_walk_lower_2", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
    { Sequence = "mad_son_run_base", Weight = 1 },
}

DATA.Translations[ ACT_MP_RUN ] = {
    { Sequence = "mad_son_run_base", Weight = 5 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )

--------------------------------------------------------------------------

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

SWEP.TypeArme = "sword"
SWEP.BonusDegats = 10
SWEP.holdtype = "sl_epee_ht_mad"

function SWEP:Initialize()
    if IsValid(self) and IsValid(self:GetOwner()) then
        self:GetOwner():SetNWInt("Combo", 0)
        if CLIENT then
        self:GetOwner():SetNWInt("FOV", self:GetOwner():GetFOV())
        end
        self.Weapon:SetHoldType( self.holdtype )
    end
end

function SWEP:Deploy()
    self.Weapon:SetHoldType( self.holdtype )
    print(self:GetOwner():GetFOV())
    self:GetOwner():SetNWInt("Combo", 0)   
end
--PATH addons/sl_main_system/lua/weapons/mad_epee13/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_epee19/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_marteau13/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "13 : Hache volcanique" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/axe11.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_marteau" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Hache NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "marteau"
SWEP.holdtype = "sl_marteau_ht_mad"
SWEP.BonusDegats = 106

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_marteau16/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "16 : Hache Blue Marine" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/axe4.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_marteau" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Hache NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "marteau"
SWEP.holdtype = "sl_marteau_ht_mad"
SWEP.BonusDegats = 130

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_marteau6/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "6 : Marteau Elementaire" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/marteau6.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_marteau" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Hache NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "marteau"
SWEP.holdtype = "sl_marteau_ht_mad"
SWEP.BonusDegats = 50

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_marteau7/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon r√©alis√© par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH gamemodes/mangarp/entities/weapons/med_kit/shared.lua:
if SERVER then
    AddCSLuaFile("shared.lua")
end

SWEP.PrintName = "Medic Kit"
SWEP.Author = "DarkRP Developers"
SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.Description = "Heals the wounded."
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = "Left click to heal someone\nRight click to heal yourself"
SWEP.IsDarkRPMedKit = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.ViewModel = "models/weapons/c_medkit.mdl"
SWEP.WorldModel = "models/weapons/w_medkit.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 0
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = true
SWEP.Primary.Delay = 0.1
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Recoil = 0
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Delay = 0.3
SWEP.Secondary.Ammo = "none"

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local found
    local lastDot = -1 -- the opposite of what you're looking at
    Owner:LagCompensation(true)
    local aimVec = Owner:GetAimVector()
    local shootPos = Owner:GetShootPos()

    for _, v in ipairs(player.GetAll()) do
        local maxhealth = v:GetMaxHealth() or 100
        local targetShootPos = v:GetShootPos()
        if v == Owner or targetShootPos:DistToSqr(shootPos) > 7225 or v:Health() >= maxhealth or not v:Alive() then continue end

        local direction = targetShootPos - shootPos
        direction:Normalize()
        local dot = direction:Dot(aimVec)

        -- Looking more in the direction of this player
        if dot > lastDot then
            lastDot = dot
            found = v
        end
    end
    Owner:LagCompensation(false)

    if found then
        found:SetHealth(found:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, math.max(found:Health() / found:GetMaxHealth() * 100, 25), 1, CHAN_AUTO)
    end
end

function SWEP:SecondaryAttack()
    self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
    local ply = self:GetOwner()
    local maxhealth = ply:GetMaxHealth() or 100
    if ply:Health() < maxhealth then
        ply:SetHealth(ply:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, math.max(ply:Health() / ply:GetMaxHealth() * 100, 25), 1, CHAN_AUTO)
    end
end

--PATH addons/sl_utils/lua/weapons/voice_amplifier/cl_init.lua:
include("shared.lua")

SWEP.PrintName = "Voice Amplifier"
SWEP.Author = "Dannelor"
SWEP.Purpose = "Amplifies the distance a players voice can be heard."
SWEP.Instructions = "Select swep and change settings"

SWEP.BobScale = 0
SWEP.SwayScale = 0
SWEP.BounceWeaponIcon = false

SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.slot = 5
SWEP.WepSelectIcon = surface.GetTextureID("VGUI/entities/voice_amplifier")

SWEP.AllTalkSize = 200
SWEP.SphereQuality = 20

local drawsphere = render.DrawSphere
local setcolormaterial = render.SetColorMaterial
local sqrt = math.sqrt
local camstart = cam.Start3D
local camend = cam.End3D

function SWEP:Initialize()
  self:SetHoldType(self.HoldType)
end

function SWEP:PostDrawViewModel()
  camstart()
    local alltalk = self:GetAllTalk()
    local size = -(alltalk and self.AllTalkSize or sqrt(self:GetDistance()))

    setcolormaterial()
    drawsphere(self.Owner:GetPos(),size,self.SphereQuality,self.SphereQuality,alltalk and Color(255,0,0,40) or Color(0,255,0,40))
  camend()
end

function SWEP:DrawWorldModel()
  if LocalPlayer() ~= self.Owner then return end -- Only draw the world bubble for owner

  local alltalk = self:GetAllTalk()
  local size = alltalk and self.AllTalkSize or sqrt(self:GetDistance())

  setcolormaterial()
  drawsphere(self.Owner:GetPos(),-size,self.SphereQuality,self.SphereQuality,alltalk and Color(255,0,0,40) or Color(0,255,0,40))
  drawsphere(self.Owner:GetPos(),size,self.SphereQuality,self.SphereQuality,alltalk and Color(255,0,0,40) or Color(0,255,0,40))
end

-- Stop clicking sounds
function SWEP:CanPrimaryAttack() end
function SWEP:CanSecondaryAttack() end

--PATH addons/sl_utils/lua/weapons/voice_amplifier/shared.lua:
SWEP.ViewModel = "models/weapons/v_slam.mdl"
SWEP.WorldModel = "models/weapons/w_slam.mdl"
SWEP.HoldType = "normal"
SWEP.Spawnable = true
SWEP.AdminOnly = true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.Category = "Other"

SWEP.MinDistanceSqr = 302500 -- DarkRP default distance (550 units)
SWEP.DistanceChangeRate = 62500 -- 250 units

function SWEP:SetupDataTables()
  self:NetworkVar("Bool",0,"AllTalk")
  self:NetworkVar("Int",0,"Distance")

  if SERVER then
    self:SetAllTalk(false)
    self:SetDistance(self.MinDistanceSqr)
  end
end

--PATH gamemodes/mangarp/entities/weapons/weapon_keypadchecker/shared.lua:
AddCSLuaFile()

if SERVER then
    AddCSLuaFile("cl_init.lua")

    util.AddNetworkString("DarkRP_keypadData")
end

SWEP.Base = "weapon_base"

SWEP.PrintName = "Admin Keypad Checker"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click on a keypad or fading door to check it\nRight click to clear"
SWEP.Slot = 5
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.ViewModelFlip = false
SWEP.Primary.ClipSize = 0
SWEP.Primary.Ammo = ""
SWEP.Secondary.Ammo = ""

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.HoldType = "normal"
SWEP.ViewModel = Model("models/weapons/c_pistol.mdl")
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.IconLetter = ""

SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true

local table_insert = table.insert
local tonumber = tonumber

--[[
    Gets which entities are controlled by which keyboard keys
]]
local function getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
    local targets = {}
    local Owner = keypad:CPPIGetOwner()

    for _, v in pairs(numpad.OnDownItems or {}) do
        if v.key == keyPass and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_entering_right_pass"), name = v.name, ent = v.ent, original = keypad})
        end
        if v.key == keyDenied and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_entering_wrong_pass"), name = v.name, ent = v.ent, original = keypad})
        end
    end

    for _, v in pairs(numpad.OnUpItems or {}) do
        if v.key == keyPass and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_after_right_pass"), name = v.name, delay = math.Round(delayPass, 2), ent = v.ent, original = keypad})
        end
        if v.key == keyDenied and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_after_wrong_pass"), name = v.name, delay = math.Round(delayDenied, 2), ent = v.ent, original = keypad})
        end
    end

    return targets
end

--[[---------------------------------------------------------------------------
Get the entities that are affected by the keypad
---------------------------------------------------------------------------]]
local function get_sent_keypad_Info(keypad)
    local keyPass = keypad:GetNWInt("keypad_keygroup1")
    local keyDenied = keypad:GetNWInt("keypad_keygroup2")
    local delayPass = keypad:GetNWInt("keypad_length1")
    local delayDenied = keypad:GetNWInt("keypad_length2")

    return getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
end

--[[---------------------------------------------------------------------------
Overload for a different keypad addon
---------------------------------------------------------------------------]]
local function get_keypad_Info(keypad)
    local keyPass = tonumber(keypad.KeypadData.KeyGranted) or 0
    local keyDenied = tonumber(keypad.KeypadData.KeyDenied) or 0
    local delayPass = tonumber(keypad.KeypadData.LengthGranted) or 0
    local delayDenied = tonumber(keypad.KeypadData.LengthDenied) or 0

    return getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
end


--[[---------------------------------------------------------------------------
Get the keypads that trigger this entity
---------------------------------------------------------------------------]]
local function getEntityKeypad(ent)
    local targets = {}
    local doorKeys = {} -- The numpad keys that activate this entity
    local entOwner = ent:CPPIGetOwner()

    for _, v in pairs(numpad.OnDownItems or {}) do
        if v.ent == ent then
            table_insert(doorKeys, v.key)
        end
    end

    for _, v in pairs(numpad.OnUpItems or {}) do
        if v.ent == ent then
            table_insert(doorKeys, v.key)
        end
    end

    for _, v in ipairs(ents.FindByClass("sent_keypad")) do
        local vOwner = v:CPPIGetOwner()

        if vOwner == entOwner and table.HasValue(doorKeys, v:GetNWInt("keypad_keygroup1")) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_right_pass_entered"), ent = v, original = ent})
        end
        if vOwner == entOwner and table.HasValue(doorKeys, v:GetNWInt("keypad_keygroup2")) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_wrong_pass_entered"), ent = v, original = ent})
        end
    end

    for _, v in ipairs(ents.FindByClass("keypad")) do
        local vOwner = v:CPPIGetOwner()

        if vOwner == entOwner and table.HasValue(doorKeys, tonumber(v.KeypadData.KeyGranted) or 0) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_right_pass_entered"), ent = v, original = ent})
        end
        if vOwner == entOwner and table.HasValue(doorKeys, tonumber(v.KeypadData.KeyDenied) or 0) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_wrong_pass_entered"), ent = v, original = ent})
        end
    end

    return targets
end

--[[---------------------------------------------------------------------------
Send the info to the client
---------------------------------------------------------------------------]]
function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 0.3)
    if not SERVER then return end

    local Owner = self:GetOwner()
    local trace = Owner:GetEyeTrace()
    if not IsValid(trace.Entity) then return end
    local ent, class = trace.Entity, string.lower(trace.Entity:GetClass() or "")
    local data

    if class == "sent_keypad" then
        data = get_sent_keypad_Info(ent)
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("keypad_checker_controls_x_entities", #data / 2))
    elseif class == "keypad" then
        data = get_keypad_Info(ent)
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("keypad_checker_controls_x_entities", #data / 2))
    else
        data = getEntityKeypad(ent)
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("keypad_checker_controlled_by_x_keypads", #data))
    end

    net.Start("DarkRP_keypadData")
        net.WriteTable(data)
    net.Send(Owner)
end

function SWEP:SecondaryAttack()
end

if not SERVER then return end

--[[---------------------------------------------------------------------------
Registering numpad data
---------------------------------------------------------------------------]]
local oldNumpadUp = numpad.OnUp
local oldNumpadDown = numpad.OnDown

function numpad.OnUp(ply, key, name, ent, ...)
    numpad.OnUpItems = numpad.OnUpItems or {}
    table_insert(numpad.OnUpItems, {ply = ply, key = key, name = name, ent = ent, arg = {...}})

    return oldNumpadUp(ply, key, name, ent, ...)
end

function numpad.OnDown(ply, key, name, ent, ...)
    numpad.OnDownItems = numpad.OnDownItems or {}
    table_insert(numpad.OnDownItems, {ply = ply, key = key, name = name, ent = ent, arg = {...}})

    return oldNumpadDown(ply, key, name, ent, ...)
end

--PATH addons/realistichandcuffs/lua/weapons/weapon_r_cuffed/shared.lua:
if SERVER then
	AddCSLuaFile("shared.lua")
end

if CLIENT then
	SWEP.PrintName = "Cuffed"
	SWEP.Slot = 2
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Author = "ToBadForYou"
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.HoldType = "passive";
SWEP.ViewModelFlip = false
SWEP.AnimPrefix	 = "passive"
SWEP.Category = "ToBadForYou"
SWEP.UID = 76561199385207507

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize() self:SetHoldType("passive") end
function SWEP:CanPrimaryAttack() return false; end
function SWEP:SecondaryAttack() return false; end

function SWEP:PreDrawViewModel(vm)
    return true
end

function SWEP:DrawWorldModel()
end

if CLIENT then
function SWEP:DrawHUD()
    draw.SimpleTextOutlined("Menott√©","Trebuchet24",ScrW()/2,ScrH()/12,Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM,2,Color(0,0,0,255))
end
end
--PATH addons/sl_util_atm/lua/entities/atm_wall/cl_init.lua:
include("shared.lua")

--The X resolution of the screen
local screenX = 1024
local screenY = 676

BATM_CACHED_ATMS = BATM_CACHED_ATMS or {}

--Lerps between colors instead of single values
local function LerpColor(t, col1, col2)
	local newCol = Color(0,0,0,0)

	newCol.r = Lerp(t, col1.r, col2.r)
	newCol.g = Lerp(t, col1.g, col2.g)
	newCol.b = Lerp(t, col1.b, col2.b)
	newCol.a = Lerp(t, col1.a, col2.a)

	return newCol
end

--Formats a number into a string with commas
local function comma_value(amount)
 	local formatted = amount
 	while true do   
    	formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
    	if (k==0) then
    		break 
    	end
  	end
	return formatted
end
 
--Set up the entity and its render targts and materials
function ENT:Initialize()
	
	self.screenMaterial = CreateMaterial("blueatm_machinescreenmat_"..self:EntIndex(), "UnlitGeneric", {})
	self.renderTarget = GetRenderTarget("blueatm_machinescreenmat_"..self:EntIndex(), 1024, 1024, false)
	self.color = Color(math.random(0, 255), math.random(0, 255), math.random(0, 255))

	--Set up back panel
	self.csModel = ClientsideModel("models/bluesatm/atm_wall_back.mdl")
	self.csModel:SetPos(self:GetPos())
	self.csModel:SetAngles(self:GetAngles())
	self.csModel:SetParent(self)
	self.csModel:SetNoDraw(true)

	self.ScreenZoom = 1
	self.ScreenRotation = 0
	self.textRotation = 0

	--The position of the cursor
	self.cursor = {x= 0, y = 0}

	self.screenMaterial:SetTexture('$basetexture', self.renderTarget)

	self.currentSceneName = nil

	--The buttons on the screen
	self.buttons = {}

	--Prevent double presses
	self.lastPressedTime = CurTime()

	self:SetScene("home")

	BATM_CACHED_ATMS[self:EntIndex()] = self
end

local lastButton = 0

--Clears all the buttons on the screen
function ENT:ClearButtons()
	self.buttons = {}
end

function ENT:AddButton(x, y, width, height, onClick, onMouseEnter, onMouseExit)
	table.insert(self.buttons, {hovered = false, x = x, y = y, w = width, h = height, onClick = onClick, onMouseEnter = onMouseEnter, onMouseExit = onMouseExit})
end

--When called, it will try to press a button where ever the cursor is, if not button exists then it does nothing
function ENT:PressButton()

	--First, do we have any buttons?
	if table.Count(self.buttons) > 0 then
		--This will contain the acctual button
		local button = nil
		--Now we need to find the button that we are on
		for k ,v in pairs(self.buttons) do
			--We are in the top left, now lets check to make sure that we are in the bottom right
			if self.cursor.x >= v.x and self.cursor.y >= v.y then
				if self.cursor.x <= v.x + v.w and self.cursor.y <= v.y + v.h then
					--Found a button!
					button = v
					break
				end
			end
		end

		--a button was found
		if button ~= nil then
			button.onClick(self) 
			return
		end 
	end 

	--If we made it this far it means they were not looking at a button on the screen
	--so instead lets check if there looking at a keypad button
	if self.selectedButton ~= nil then
		if self.currentSceneName ~= nil and BATM.Scenes[self.currentSceneName] ~= nil then
			if BATM.Scenes[self.currentSceneName].OnKeypadPressed ~= nil then
				BATM.Scenes[self.currentSceneName].OnKeypadPressed(self, self.selectedButton)
			end
		end
	end
end

--Recalculates the position the cursor should be at on the screen
--Also updates buttons to call onMouseEnter and onMouseExit
function ENT:UpdateCursorPosition()
	--To far
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 100 then return end

	--Not us
	if LocalPlayer():GetEyeTrace().Entity ~= self then return end

	--Create ray
	local rayOrigin = LocalPlayer():EyePos()
	local rayDirection = LocalPlayer():EyeAngles():Forward()
	local planePosition = self:GetPos() + (self:GetAngles():Forward() * -3)
	local planeAngle = self:GetAngles()
	planeAngle:RotateAroundAxis(planeAngle:Up(),180)

	local planeNormal = planeAngle:Forward() 


	local ang = Angle(0, 0, 0)
	ang:RotateAroundAxis(self:GetAngles():Right(), -15.3)
	planeNormal:Rotate(ang)
 
	local hitPos = util.IntersectRayWithPlane(rayOrigin, rayDirection, planePosition, planeNormal)

	if hitPos == nil then return end

	--render.DrawWireframeSphere(hitPos,1,25,25,Color(255,0,0, 50),false)

	hitPos = self:WorldToLocal(hitPos)

	local screenTopLeft = Vector(13.716227, 11.510023, 61.104160)
	local screenBottomRight = Vector(9.706230, -11.731017, 46.445992)

	local totalDifference = screenTopLeft - screenBottomRight

	local xCursorScale = (screenTopLeft.y - hitPos.y) / totalDifference.y
	local yCursorScale = (screenTopLeft.z - hitPos.z) / totalDifference.z
	
	--Translate the scales into acctualy screen chords
	local xScreenChord = math.Clamp(xCursorScale * screenX, 0, screenX)
	local yScreenChord = math.Clamp(yCursorScale * screenY, 0, screenY)

	--Now updaet the entities cursor position
	self.cursor.x = xScreenChord
	self.cursor.y = yScreenChord

	--Now check which buttons are entered and which ones are not
	for k ,v in pairs(self.buttons) do
		local mouseInRange = false

		--We are in the top left, now lets check to make sure that we are in the bottom right
		if self.cursor.x >= v.x and self.cursor.y >= v.y then
			if self.cursor.x <= v.x + v.w and self.cursor.y <= v.y + v.h then
				mouseInRange = true
				if v.hovered == false then
					self.buttons[k].hovered = true
					if v.onMouseEnter then
						v.onMouseEnter(self)
					end
				end
			end
		end

		--Check hover status
		if not mouseInRange and v.hovered then
			self.buttons[k].hovered = false
			if v.onMouseExit then
				v.onMouseExit(self)
			end
		end
	end

	--Now check which keypad button they are looking at
	local rayOrigin = LocalPlayer():EyePos()
	local rayDirection = LocalPlayer():EyeAngles():Forward()
	local planePosition = self:GetPos() + (self:GetAngles():Up() * 41.2)
	local planeAngle = self:GetAngles()
	planeAngle:RotateAroundAxis(planeAngle:Up(),180)

	local planeNormal = planeAngle:Forward() 
	local ang = Angle(0, 0, 0)
	ang:RotateAroundAxis(self:GetAngles():Right(), -80)
	planeNormal:Rotate(ang)
 
	local hitPos = util.IntersectRayWithPlane(rayOrigin, rayDirection, planePosition, planeNormal)

	if hitPos == nil then return end
	hitPos = self:WorldToLocal(hitPos)

	local selectedButton = nil
	--Check if its in the zone of a keypad
	for k ,v in pairs(self.KeypadButtons) do
		if hitPos:WithinAABox(v.v2,v.v1) then
			self.selectedButton = k
			selectedButton = k
			break
		end
	end

	if selectedButton == nil then
		self.selectedButton = nil
	end
end

--Allows you to change a scene (A scene is a table, that has a Think, Draw and a Unload which get called respectivly)
function ENT:SetScene(sceneName)
	--Clear any previous buttons
	self:ClearButtons()

	local scene = BATM.Scenes[sceneName]

	--Prevent potential error
	if scene == nil then print("Failed to load ss not found") return end

	--Unload the old scene
	if BATM.Scenes[self.currentSceneName] ~= nil then 
		--Clear button
		BATM.Scenes[self.currentSceneName].Unload(self, sceneName) --Pass the sceneName that we are changing to
	end

	--Call on load on the new scene
	scene.Load(self)

	self.currentSceneName = sceneName
end

--Draw the model and call the screen rendering functions.
function ENT:RenderScreen()
	if self:GetPos():Distance(LocalPlayer():GetPos()) < 300 and not screenDisabled and BATM.Scenes[self.currentSceneName] ~= nil then
		--Draw the screen
		render.PushRenderTarget(self.renderTarget)
			render.Clear(0,0,0,0,true,true) 
			cam.Start2D()
					BATM.Scenes[self.currentSceneName].Draw(self, screenX, screenY) --Draw the scene
			cam.End2D()
		render.PopRenderTarget()
 
		--Update material texture
		self.csModel:SetSubMaterial(3, "!blueatm_machinescreenmat_"..self:EntIndex())
	end

end

--Handle scene thinks
function ENT:Think()
	if BATM.Scenes[self.currentSceneName] ~= nil then
		BATM.Scenes[self.currentSceneName].Think(self, FrameTime()) 
	end

	self.csModel:SetPos(self:GetPos()) 
	self.csModel:SetAngles(self:GetAngles())

	if self:GetPos():Distance(LocalPlayer():GetPos()) < 150 and not screenDisabled then
		--Updates the cursor position
		self:UpdateCursorPosition()
	end
end

local buttonCooldown = CurTime()

hook.Add( "KeyPress", "batm:client_use", function( ply, key )
	if key == IN_USE and CurTime() - buttonCooldown > 0.1 then
		if LocalPlayer():GetEyeTrace().Entity ~= nil and IsValid(LocalPlayer():GetEyeTrace().Entity) and LocalPlayer():GetEyeTrace().Entity:GetClass() == "atm_wall" then
			LocalPlayer():GetEyeTrace().Entity:PressButton()
			buttonCooldown = CurTime()
		end
	end
end )

--[[-------------------------------------------------------------------------
Rendering
---------------------------------------------------------------------------]]
local DynamicLight = DynamicLight
local render = render

hook.Add("PreDrawTranslucentRenderables" , "batm:drawAtms", function(depth, skybox)

	if skybox then return end
	if depth then return end

	for k, s in pairs(BATM_CACHED_ATMS) do
		if not IsValid(s) then continue end

		if BATM.ScreenDisabled == false then
			s:RenderScreen()
		end
 
		--Figure out if this should be rendered?
		local screenpos = s:GetPos():ToScreen()
		if screenpos.visible == false then
			continue --Its behind the player
		end

		--Is something blocking out direction view to it?
		render.ClearStencil()
		render.SetStencilEnable( true )
			render.SetStencilWriteMask( 255 )
			render.SetStencilTestMask( 255 )
			render.SetStencilReferenceValue( 57 )
	        render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_ALWAYS )
			render.SetStencilPassOperation( STENCILOPERATION_REPLACE )

			local angle = s:GetAngles()
			angle:RotateAroundAxis(angle:Right(), -90)

			cam.Start3D2D(s:GetPos() - (s:GetAngles():Up() * -61) + (s:GetAngles():Forward() * -1.3), angle, 0.5)
			draw.NoTexture()
				draw.RoundedBox(0,-64 / 2,-64 / 2,75.5,65,Color(255,255,255,1))
			cam.End3D2D()
			
			render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
			render.SuppressEngineLighting(true)
			render.DepthRange(0, 0.8)
			s.csModel:DrawModel()
			render.SuppressEngineLighting(false)

			if BATM.LightsDisabled == false then
				s.dlight = DynamicLight(s:EntIndex())
				if ( s.dlight ) then
					s.dlight.pos = s:GetPos() + (s:GetAngles():Forward() * -14) + (s:GetAngles():Up() * 62)
					s.dlight.r = 255
					s.dlight.g = 255
					s.dlight.b = 255
					s.dlight.brightness = 5
					s.dlight.Decay = 0
					s.dlight.Size = 70 
					s.dlight.DieTime = CurTime() + 0.5
				end
			end
		render.SetStencilEnable( false )
		render.DepthRange(0, 1)
	
		--s:DrawModel()
	end
end)



--[[-------------------------------------------------------------------------
Commands
---------------------------------------------------------------------------]]
concommand.Add("batm_enable_screens", function() 
	BATM.ScreenDisabled = false
end)

concommand.Add("batm_disable_screens", function() 
	BATM.ScreenDisabled = true
end)

concommand.Add("batm_enable_lights", function() 
	BATM.LightsDisabled = false
end)

concommand.Add("batm_disable_lights", function() 
	BATM.LightsDisabled = true
end)

--[[-------------------------------------------------------------------------
Networking
---------------------------------------------------------------------------]]
net.Receive("batm:updatescene", function()
	local e = net.ReadEntity()
	local sceneName = net.ReadString()

	--Uh oh
	if e == nil and not e:IsValid() then return end

	--Update the scene
	if e.SetScene then
		e:SetScene(sceneName) --Sometimes errors, maybe outside player PVC?
	end
end)

--PATH addons/sl_util_atm/lua/entities/atm_wall/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Wall ATM"
ENT.Author = "<CODE BLUE>"
ENT.Contact = "Via Steam"
ENT.Spawnable = true
ENT.Category = "Blue's ATM"
ENT.AdminSpawnable = true 

ENT.KeypadButtons = {
	[1] = {
		v1 = Vector(6.3242154121399, 4.6794362068176, 42.315120697021),
		v2 = Vector(5.2774815559387, 3.2131419181824, 42.130558013916)
	},
	[2] = {
		v1 = Vector(6.2842335700989, 2.8623576164246, 42.30806350708),
		v2 = Vector(5.2010078430176, 1.3468786478043, 42.117069244385)
	},
	[3] = {
		v1 = Vector(6.3260402679443, 0.99942409992218, 42.315448760986),
		v2 = Vector(5.1430888175964, -0.4899827837944, 42.106864929199)
	},
	[4] = {
		v1 = Vector(4.7365732192993, 4.6431932449341, 42.03519821167),
		v2 = Vector(3.6755030155182, 3.1529352664948, 41.848094940186)
	},
	[5] = {
		v1 = Vector(4.9846606254578, 2.9224467277527, 42.078937530518),
		v2 = Vector(3.7379949092865, 1.4061270952225, 41.859127044678)
	},
	[6] = {
		v1 = Vector(4.8523707389832, 1.0120477676392, 42.055606842041),
		v2 = Vector(3.7184247970581, -0.51208257675171, 41.855659484863)
	},
	[7] = {
		v1 = Vector(3.357097864151, 4.7287225723267, 41.791942596436),
		v2 = Vector(2.2441239356995, 3.1697614192963, 41.595695495605)
	},
	[8] = {
		v1 = Vector(3.3098621368408, 2.8721208572388, 41.783622741699),
		v2 = Vector(2.2989020347595, 1.2975977659225, 41.605354309082)
	},
	[9] = {
		v1 = Vector(3.3003168106079, 0.98232841491699, 41.781940460205),
		v2 = Vector(2.3017039299011, -0.49305874109268, 41.605854034424)
	},
	[0] = {
		v1 = Vector(1.9256201982498, 2.9167428016663, 41.539535522461),
		v2 = Vector(0.76918041706085, 1.3108148574829, 41.335628509521)
	},
	["clear"] = {
		v1 = Vector(6.3366770744324, -1.4786270856857, 42.317321777344),
		v2 = Vector(5.2353281974792, -4.688268661499, 42.123134613037)
	},
	["enter"] = {
		v1 = Vector(4.7916941642761, -1.4398620128632, 42.044898986816),
		v2 = Vector(3.6682436466217, -4.7248086929321, 41.846809387207)
	},
	["cancel"] = {
		v1 = Vector(3.2898850440979, -1.4525005817413, 41.780094146729),
		v2 = Vector(2.2739601135254, -4.7292504310608, 41.600955963135)
	}
}

function ENT:SetupDataTables()

end
--PATH lua/entities/bagel2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Bagel"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Bagel2.mdl")
	
end
--PATH addons/sl_main_system/lua/entities/banque_item_sl/shared.lua:
ENT.Base	    			= "base_ai"
ENT.Type	    			= "ai"
ENT.PrintName				= "Shop"
ENT.Author					= "Mad"
ENT.Category                = "Union - SL"
ENT.Instructions			= "Appuyez sur votre touche [USE]"
ENT.Spawnable				= true
ENT.AdminSpawnable			= true
--PATH lua/entities/cheesewheel1a/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cheese wheel"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/cheesewheel1a.mdl")
	
end
--PATH lua/entities/chipscheezit/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Chips - Cheez It"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A bag of Chips (Crisps if ya from Blighty)"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/chipscheezit.mdl")
	
end
--PATH lua/entities/chipsfritost/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Chips - Fritos Twists"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A bag of Chips (Crisps if ya from Blighty)"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/ChipsFritostwists.mdl")
	
end
--PATH lua/entities/cookies/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cookies"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A pack of cookies"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/cookies.mdl")
	
end
--PATH gamemodes/mangarp/entities/entities/darkrp_laws/cl_init.lua:
include("shared.lua")

local Laws = {}

ENT.DrawPos = Vector(1, -111, 58)

local color_navy_200 = Color(0, 0, 70, 200)
local color_red = Color(255, 0, 0, 255)
local color_white = color_white

function ENT:Draw()
    self:DrawModel()

    local DrawPos = self:LocalToWorld(self.DrawPos)

    local DrawAngles = self:GetAngles()
    DrawAngles:RotateAroundAxis(self:GetAngles():Forward(), 90)
    DrawAngles:RotateAroundAxis(self:GetAngles():Up(), 90)

    cam.Start3D2D(DrawPos, DrawAngles, 0.4)

        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawRect(0, 0, 558, 290)

        draw.RoundedBox(4, 0, 0, 558, 30, color_navy_200)

        draw.DrawNonParsedSimpleText(DarkRP.getPhrase("laws_of_the_land"), "Roboto20", 279, 5, color_red, TEXT_ALIGN_CENTER)

        local lastHeight = 0
        for k, v in ipairs(Laws) do
            draw.DrawNonParsedText(string.format("%u. %s", k, v), "Roboto20", 5, 35 + lastHeight, color_white)
            lastHeight = lastHeight + (fn.ReverseArgs(string.gsub(v, "\n", "")) + 1) * 21
        end

    cam.End3D2D()
end

local function addLaw(inLaw)
    local law = DarkRP.textWrap(inLaw, "Roboto20", 522)

    local lawNumber = table.insert(Laws, law)
    hook.Run("addLaw", lawNumber, inLaw)
end

local function umAddLaw(um)
    local law = um:ReadString()
    timer.Simple(0, fn.Curry(addLaw, 2)(law))
end
usermessage.Hook("DRP_AddLaw", umAddLaw)

local function umRemoveLaw(um)
    local i = um:ReadShort()

    local removed = table.remove(Laws, i)
    hook.Run("removeLaw", i, removed)
end
usermessage.Hook("DRP_RemoveLaw", umRemoveLaw)

local function umResetLaws(um)
    Laws = {}
    fn.Foldl(function(val,v) addLaw(v) end, nil, GAMEMODE.Config.DefaultLaws)
    hook.Run("resetLaws")
end
usermessage.Hook("DRP_ResetLaws", umResetLaws)

function DarkRP.getLaws()
    return Laws
end

timer.Simple(0, function()
    fn.Foldl(function(val,v) addLaw(v) end, nil, GAMEMODE.Config.DefaultLaws)
end)

--PATH addons/the_perfect_training_system/lua/entities/diablos_treadmill_npc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

--PATH addons/the_perfect_training_system/lua/entities/diablos_turnstile/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	CreateMaterial( "Diablos:TS:EmptyNFCIco", "VertexLitGeneric", {
		["$basetexture"] = "color/green",
		["$model"] = 1,
		["$translucent"] = 1,
		["$vertexalpha"] = 1,
		["$vertexcolor"] = 1
	} )
end


--PATH addons/the_perfect_training_system/lua/entities/diablos_turnstile_trigger/shared.lua:
ENT.Base = "base_entity"
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.AutomaticFrameAdvance = true
--PATH lua/entities/drgbase_nextbot/awareness.lua:

-- Convars --

local AllOmniscient = CreateConVar("drgbase_ai_omniscient", "0", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})

-- Getters/setters --

function ENT:IsOmniscient()
	return AllOmniscient:GetBool() or self:GetNW2Bool("DrGBaseOmniscient")
end
function ENT:GetSpotDuration()
	return self:GetNW2Float("DrGBaseSpotDuration")
end

-- Hooks --

function ENT:OnSpotted() end
function ENT:OnLost() end

-- Handlers --

function ENT:_InitAwareness()
	if CLIENT then return end
	self._DrGBaseSpotted = {}
	self:SetOmniscient(self.Omniscient)
	self._DrGBaseLastTimeSpotted = {}
	self._DrGBaseLastKnownPos = {}
	self:SetSpotDuration(self.SpotDuration)
end

if SERVER then
	util.AddNetworkString("DrGBaseNextbotPlayerAwareness")

	-- Getters/setters --

	function ENT:SetOmniscient(omniscient)
		self:SetNW2Bool("DrGBaseOmniscient", omniscient)
	end
	function ENT:SetSpotDuration(duration)
		self:SetNW2Float("DrGBaseSpotDuration", duration)
	end

	function ENT:HasSpotted(ent, absolute)
		if not IsValid(ent) then return false end
		if ent == self then return true end
		if not absolute and self:IsOmniscient() then return true end
		return self._DrGBaseSpotted[ent] or false
	end
	function ENT:HasLost(ent, absolute)
		if not IsValid(ent) then return false end
		if ent == self then return false end
		if not absolute and self:IsOmniscient() then return false end
		return self._DrGBaseSpotted[ent] == false
	end

	local function NextAwareEntity(self, entities, j, spotted)
		local i = j+1
		local ent = entities[i]
		if ent == nil then return nil
		elseif not IsValid(ent) or
		(spotted and not self:HasSpotted(ent)) or
		(not spotted and not self:HasLost(ent)) then
			return NextAwareEntity(self, entities, i, spotted)
		else return i, ent end
	end
	function ENT:SpottedEntities()
		local entities = ents.GetAll()
		local i = 0
		return function()
			local j, ent = NextAwareEntity(self, entities, i, true)
			i = j
			return ent
		end
	end
	function ENT:LostEntities()
		local entities = ents.GetAll()
		local i = 0
		return function()
			local j, ent = NextAwareEntity(self, entities, i, false)
			i = j
			return ent
		end
	end
	function ENT:GetSpotted()
		local entities = {}
		for ent in self:SpottedEntities() do
			table.insert(entities, ent)
		end
		return entities
	end
	function ENT:GetLost()
		local entities = {}
		for ent in self:LostEntities() do
			table.insert(entities, ent)
		end
		return entities
	end

	function ENT:LastTimeSpotted(ent)
		return self._DrGBaseLastTimeSpotted[ent] or -1
	end
	function ENT:LastKnownPosition(ent)
		return self._DrGBaseLastKnownPos[ent]
	end
	function ENT:UpdateKnownPosition(ent, pos)
		pos = isvector(pos) and pos or ent:GetPos()
		self._DrGBaseLastKnownPos[ent] = pos
	end

	-- Functions --

	local function SpotTimerName(self, ent)
		return "DrGBaseNB"..self:GetCreationID().."SpotENT"..ent:GetCreationID()
	end
	function ENT:SpotEntity(ent)
		if not IsValid(ent) then return end
		if ent:IsPlayer() and not ent:Alive() then return end
		if ent:IsPlayer() and GetConVar("ai_ignoreplayers"):GetBool() then return end
		if self:GetSpotDuration() == 0 then return end
		local spotted = self:HasSpotted(ent)
		self._DrGBaseLastTimeSpotted[ent] = CurTime()
		self._DrGBaseSpotted[ent] = true
		local disp = self:GetRelationship(ent, true)
		if disp == D_HT or disp == D_LI or disp == D_FR then
			self._DrGBaseRelationshipCachesSpotted[disp][ent] = true
		end
		self:UpdateKnownPosition(ent)
		if self._DrGBasePatrolSound and
		self._DrGBasePatrolSound:GetSound().Entity == ent then
			self:RemovePatrol(self._DrGBasePatrolSound)
		end
		if not spotted then
			self:OnSpotted(ent)
			if ent:IsPlayer() then
				net.Start("DrGBaseNextbotPlayerAwareness")
				net.WriteEntity(self)
				net.WriteBit(true)
				net.Send(ent)
			end
		end
		local timerName = SpotTimerName(self, ent)
		timer.Remove(timerName)
		if self:GetSpotDuration() <= 0 then return end
		timer.Create(timerName, self:GetSpotDuration(), 1, function()
			if not IsValid(self) or not IsValid(ent) then return end
			self:LoseEntity(ent)
		end)
	end
	function ENT:LoseEntity(ent)
		if not IsValid(ent) then return end
		if not self:HasSpotted(ent) then return end
		if self:HasLost(ent) then return end
		if ent:IsPlayer() then
			net.Start("DrGBaseNextbotPlayerAwareness")
			net.WriteEntity(self)
			net.WriteBit(false)
			net.Send(ent)
		end
		timer.Remove(SpotTimerName(self, ent))
		self._DrGBaseSpotted[ent] = false
		self._DrGBaseRelationshipCachesSpotted[D_LI][ent] = nil
		self._DrGBaseRelationshipCachesSpotted[D_HT][ent] = nil
		self._DrGBaseRelationshipCachesSpotted[D_FR][ent] = nil
		self:OnLost(ent)
	end

	function ENT:AlertAllies(ent, spotted)
		if not self:HasSpotted(ent) then return end
		local alerted = {}
		for ally in self:AllyIterator(spotted) do
			if not ally.IsDrGNextbot then continue end
			if not ally:HasSpotted(ent) then
				table.insert(alerted, ent)
				ally:OnAlerted(ent, self)
			else ally:SpotEntity(ent) end
		end
		if #alerted > 0 then
			self:OnAlert(ent, alerted)
		end
	end

	-- Hooks --

	function ENT:OnAlert(ent, alerted) end
	function ENT:OnAlerted(ent, alertedBy)
		self:SpotEntity(ent)
	end

	-- Handlers --

	cvars.AddChangeCallback("ai_ignoreplayers", function(name, old, new)
		for i, nextbot in ipairs(DrGBase.GetNextbots()) do
			if tobool(new) then
				for h, ply in ipairs(player.GetAll()) do
					nextbot:LoseEntity(ply)
				end
			end
			nextbot:UpdateAI()
		end
	end, "DrGBaseIgnorePlayers")

	hook.Add("PostPlayerDeath", "DrGBaseForgetPlayerDeath", function(ply)
		for i, nextbot in ipairs(DrGBase.GetNextbots()) do
			nextbot:LoseEntity(ply)
			nextbot:UpdateAI()
		end
	end)

else

	local function CallAwarenessHooks(self, spotted)
		local ply = LocalPlayer()
		if spotted then
			if isfunction(self.OnSpotted) then
				self._DrGBaseLastTimeSpotted = CurTime()
				self._DrGBaseLastKnownPosition = ply:GetPos()
				self:OnSpotted(ply)
			else
				timer.Simple(engine.TickInterval(), function()
					if IsValid(self) and IsValid(ply) then
						CallAwarenessHooks(self, spotted)
					end
				end)
			end
		elseif isfunction(self.OnLost) then
			self:OnLost(ply)
		else
			timer.Simple(engine.TickInterval(), function()
				if IsValid(self) and IsValid(ply) then
					CallAwarenessHooks(self, spotted)
				end
			end)
		end
	end
	net.Receive("DrGBaseNextbotPlayerAwareness", function()
		local nextbot = net.ReadEntity()
		local awareness = net.ReadBit()
		if IsValid(nextbot) then
			nextbot._DrGBaseLocalPlayerAwareness = awareness
			CallAwarenessHooks(nextbot, awareness == 1)
		end
	end)

	-- Getters/setters --

	function ENT:HasSpottedLocalPlayer()
		if self:IsOmniscient() then return true end
		return self._DrGBaseLocalPlayerAwareness == 1
	end
	function ENT:HasLostLocalPlayer()
		if self:IsOmniscient() then return false end
		return self._DrGBaseLocalPlayerAwareness == 0
	end

	function ENT:LastTimeSpotted()
		return self._DrGBaseLastTimeSpotted or -1
	end
	function ENT:LastKnownPosition()
		return self._DrGBaseLastKnownPosition
	end

end

--PATH lua/entities/drgbase_nextbot/detection.lua:

-- Convars --

local EnableSight = CreateConVar("drgbase_ai_sight", "1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})
local EnableHearing = CreateConVar("drgbase_ai_hearing", "1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})

-- Getters/setters --

function ENT:GetSightFOV()
	return self:GetNW2Int("DrGBaseSightFOV")
end
function ENT:GetSightRange()
	return self:GetNW2Int("DrGBaseSightRange")
end
function ENT:GetSightLuminosityRange()
	return self:GetNW2Float("DrGBaseMinLuminosity"), self:GetNW2Float("DrGBaseMaxLuminosity")
end
function ENT:IsBlind()
	if not EnableSight:GetBool() then return true end
	if self:GetCooldown("DrGBaseBlind") > 0 then return true end
	return self:GetSightFOV() <= 0 or self:GetSightRange() <= 0
end

function ENT:GetHearingCoefficient()
	return self:GetNW2Int("DrGBaseHearingCoefficient")
end
function ENT:IsDeaf()
	if not EnableHearing:GetBool() then return true
	else return self:GetHearingCoefficient() <= 0 end
end

-- Functions --

-- Hooks --

-- Handlers --

function ENT:_InitDetection()
	self._DrGBaseWasInSight = {}
	if CLIENT then return end
	self:SetSightFOV(self.SightFOV)
	self:SetSightRange(self.SightRange)
	self:SetSightLuminosityRange(self.MinLuminosity, self.MaxLuminosity)
	self:SetHearingCoefficient(self.HearingCoefficient)
end

if SERVER then

	-- Getters/setters --

	function ENT:SetSightFOV(angle)
		if angle > 360 then angle = 360 end
		if angle < 0 then angle = 0 end
		self:SetNW2Int("DrGBaseSightFOV", angle)
	end
	function ENT:SetSightRange(range)
		if range < 0 then range = 0 end
		self:SetNW2Int("DrGBaseSightRange", range)
	end
	function ENT:SetSightLuminosityRange(min, max)
		if isnumber(max) then
			self:SetNW2Float("DrGBaseMinLuminosity", math.Clamp(min, 0, 1))
			self:SetNW2Float("DrGBaseMaxLuminosity", math.Clamp(max, 0, 1))
		else self:SetSightLuminosityRange(0, min) end
	end

	function ENT:SetHearingCoefficient(coeff)
		if coeff < 0 then coeff = 0 end
		self:SetNW2Int("DrGBaseHearingCoefficient", coeff)
	end

	-- Functions --

	function ENT:IsInSight(ent)
		if not IsValid(ent) then return false end
		if self:IsBlind() then return false end
		if ent == self then return true end
		local eyepos = self:EyePos()
		if eyepos:DistToSqr(ent:GetPos()) > self:GetSightRange()^2 then return false end
		if ent:IsPlayer() then
			if ent:DrG_IsPossessing() then return self:IsInSight(ent:DrG_GetPossessing()) end
			local luminosity = ent:FlashlightIsOn() and 1 or ent:DrG_Luminosity()
			local min, max = self:GetSightLuminosityRange()
			if luminosity < min or luminosity > max then return false end
		end
		local angle = (eyepos + self:EyeAngles():Forward()):DrG_Degrees(ent:WorldSpaceCenter(), eyepos)
		if angle > self:GetSightFOV()/2 then return false end
		return self:Visible(ent)
	end

	net.DrG_DefineCallback("DrGBaseIsInSight", function(nextbot, ent)
		if not IsValid(nextbot) or not IsValid(ent) then return false
		else return nextbot:IsInSight(ent) end
	end)

	-- Get entities in sight
	function ENT:GetInSight(disp, spotted)
		if istable(disp) then
			local insight = {}
			for i, dis in ipairs(disp) do
				table.Merge(insight, self:GetInSight(dis, spotted))
			end
			return insight
		elseif isnumber(disp) then
			local insight = {}
			for ent in self:EntityIterator(disp, spotted) do
				if self:IsInSight(ent) then table.insert(insight, ent) end
			end
			return insight
		else return self:GetInSight({D_LI, D_HT, D_FR, D_NU}, spotted) end
	end
	function ENT:GetAlliesInSight(spotted)
		return self:GetInSight(D_LI, spotted)
	end
	function ENT:GetEnemiesInSight(spotted)
		return self:GetInSight(D_HT, spotted)
	end
	function ENT:GetAfraidOfInSight(spotted)
		return self:GetInSight(D_FR, spotted)
	end
	function ENT:GetHostilesInSight(spotted)
		return self:GetInSight({D_HT, D_FR}, spotted)
	end
	function ENT:GetNeutralInSight(spotted)
		return self:GetInSight(D_NU, spotted)
	end

	-- Check if entities are in sight
	function ENT:UpdateSight(disp, spotted)
		if self:IsAIDisabled() then return end
		if istable(disp) then
			for i, dis in ipairs(disp) do self:UpdateSight(dis, spotted) end
		elseif isnumber(disp) then
			for ent in self:EntityIterator(disp, spotted) do
				local insight = self:IsInSight(ent)
				if not insight and self._DrGBaseWasInSight[ent] then
					self:OnLostSight(ent)
				elseif insight then self:OnSight(ent) end
				self._DrGBaseWasInSight[ent] = insight
			end
		else self:UpdateSight({
			D_LI, D_HT, D_FR, D_NU
		}, spotted) end
	end
	function ENT:UpdateAlliesSight(spotted)
		return self:UpdateSight(D_LI, spotted)
	end
	function ENT:UpdateEnemiesSight(spotted)
		return self:UpdateSight(D_HT, spotted)
	end
	function ENT:UpdateAfraidOfSight(spotted)
		return self:UpdateSight(D_FR, spotted)
	end
	function ENT:UpdateHostilesSight(spotted)
		return self:UpdateSight({D_HT, D_FR}, spotted)
	end
	function ENT:UpdateNeutralSight(spotted)
		return self:UpdateSight(D_NU, spotted)
	end

	function ENT:Blind(blind)
		if self:IsBlind() then return end
		local res = self:OnBlind(blind)
		if res == true then return
		elseif isnumber(res) then blind:ScaleDuration(res) end
		self:SetCooldown("DrGBaseBlind", blind:GetDuration())
		if not isfunction(self.OnBlinded) then return end
		self:ReactInCoroutine(self.OnBlinded, blind)
	end

	-- Hooks --

	function ENT:OnContact(ent)
		self:SpotEntity(ent)
	end
	function ENT:OnSight(ent)
		self:SpotEntity(ent)
	end
	function ENT:OnLostSight() end
	function ENT:OnSound(ent, sound)
		self:SpotEntity(ent)
	end
	function ENT:OnBlind() end
	--function ENT:OnBlinded() end

	-- Handlers --

	--[[local function ATTN_TO_SNDLVL(attn)
		return (50+20)/attn
	end
	local function SNDLVL_TO_ATTN(sndlvl)
		return sndlvl > 50 and 20/(sndlvl-50) or 4
	end
	local SOUND_NORMAL_CLIP_DIST = 1000]]

	local function HandleSound(ent, sound)
		if #DrGBase.GetNextbots() == 0 then return end
		sound.Pos = sound.Pos or ent:GetPos()
		--[[local attenuation = SNDLVL_TO_ATTN(sound.SoundLevel)
		local distance = ((2*SOUND_NORMAL_CLIP_DIST)/attenuation*sound.Volume)/2]]
		local distance = math.pow(sound.SoundLevel/2, 2)*sound.Volume
		--print(distance)
		for i, nextbot in ipairs(DrGBase.GetNextbots()) do
			if ent == nextbot then continue end
			if nextbot:IsAIDisabled() then continue end
			if nextbot:IsDeaf() then continue end
			local mult = nextbot:VisibleVec(sound.Pos) and 1 or 0.5
			if (distance*nextbot:GetHearingCoefficient()*mult)^2 >= nextbot:GetRangeSquaredTo(sound.Pos) then
				nextbot:Timer(0, nextbot.OnSound, ent, sound)
			end
		end
	end
	hook.Add("EntityEmitSound", "DrGBaseNextbotHearing", function(sound)
		if not EnableHearing:GetBool() then return end
		if not IsValid(sound.Entity) then return end
		if sound.Entity:IsPlayer() then
			HandleSound(sound.Entity, sound)
		elseif sound.Entity:IsVehicle() then
			local driver = sound.Entity:GetDriver()
			if IsValid(driver) and driver:IsPlayer() then
				HandleSound(driver, sound)
			end
		end
	end)

else

	-- Getters/setters --

	function ENT:IsInSight(ent, callback)
		if IsValid(ent) then
			return self:NetCallback("DrGBaseIsInSight", callback, ent)
		elseif isfunction(callback) then callback(self, false) end
	end
	function ENT:WasInSight(ent)
		if not IsValid(ent) then return false end
		self:IsInSight(ent, function(self, insight)
			if not IsValid(ent) then return end
			self._DrGBaseWasInSight[ent] = insight
		end)
		return self._DrGBaseWasInSight[ent] or false
	end

end

--PATH lua/entities/drgbase_nextbot_human/animations.lua:

-- Activities list --

ENT.Animations = {
	PlayerModel = {
		RunAnimations = {
			["normal"] = ACT_HL2MP_RUN,
			["ar2"] = ACT_HL2MP_RUN_AR2,
			["camera"] = ACT_HL2MP_RUN_CAMERA,
			["crossbow"] = ACT_HL2MP_RUN_CROSSBOW,
			["duel"] = ACT_HL2MP_RUN_DUEL,
			["fist"] = ACT_HL2MP_RUN_FIST,
			["knife"] = ACT_HL2MP_RUN_KNIFE,
			["magic"] = ACT_HL2MP_RUN_MAGIC,
			["melee2"] = ACT_HL2MP_RUN_MELEE2,
			["passive"] = ACT_HL2MP_RUN_PASSIVE,
			["physgun"] = ACT_HL2MP_RUN_PHYSGUN,
			["revolver"] = ACT_HL2MP_RUN_REVOLVER,
			["rpg"] = ACT_HL2MP_RUN_RPG,
			["shotgun"] = ACT_HL2MP_RUN_SHOTGUN,
			["smg"] = ACT_HL2MP_RUN_SMG1,
			["grenade"] = ACT_HL2MP_RUN_GRENADE,
			["melee"] = ACT_HL2MP_RUN_MELEE,
			["pistol"] = ACT_HL2MP_RUN_PISTOL,
			["slam"] = ACT_HL2MP_RUN_SLAM
		},
		WalkAnimations = {
			["normal"] = ACT_HL2MP_WALK,
			["ar2"] = ACT_HL2MP_WALK_AR2,
			["camera"] = ACT_HL2MP_WALK_CAMERA,
			["crossbow"] = ACT_HL2MP_WALK_CROSSBOW,
			["duel"] = ACT_HL2MP_WALK_DUEL,
			["fist"] = ACT_HL2MP_WALK_FIST,
			["knife"] = ACT_HL2MP_WALK_KNIFE,
			["magic"] = ACT_HL2MP_WALK_MAGIC,
			["melee2"] = ACT_HL2MP_WALK_MELEE2,
			["passive"] = ACT_HL2MP_WALK_PASSIVE,
			["physgun"] = ACT_HL2MP_WALK_PHYSGUN,
			["revolver"] = ACT_HL2MP_WALK_REVOLVER,
			["rpg"] = ACT_HL2MP_WALK_RPG,
			["shotgun"] = ACT_HL2MP_WALK_SHOTGUN,
			["smg"] = ACT_HL2MP_WALK_SMG1,
			["grenade"] = ACT_HL2MP_WALK_GRENADE,
			["melee"] = ACT_HL2MP_WALK_MELEE,
			["pistol"] = ACT_HL2MP_WALK_PISTOL,
			["slam"] = ACT_HL2MP_WALK_SLAM
		},
		IdleAnimations = {
			["normal"] = ACT_HL2MP_IDLE,
			["ar2"] = ACT_HL2MP_IDLE_AR2,
			["camera"] = ACT_HL2MP_IDLE_CAMERA,
			["crossbow"] = ACT_HL2MP_IDLE_CROSSBOW,
			["duel"] = ACT_HL2MP_IDLE_DUEL,
			["fist"] = ACT_HL2MP_IDLE_FIST,
			["knife"] = ACT_HL2MP_IDLE_KNIFE,
			["magic"] = ACT_HL2MP_IDLE_MAGIC,
			["melee2"] = ACT_HL2MP_IDLE_MELEE2,
			["passive"] = ACT_HL2MP_IDLE_PASSIVE,
			["physgun"] = ACT_HL2MP_IDLE_PHYSGUN,
			["revolver"] = ACT_HL2MP_IDLE_REVOLVER,
			["rpg"] = ACT_HL2MP_IDLE_RPG,
			["shotgun"] = ACT_HL2MP_IDLE_SHOTGUN,
			["smg"] = ACT_HL2MP_IDLE_SMG1,
			["grenade"] = ACT_HL2MP_IDLE_GRENADE,
			["melee"] = ACT_HL2MP_IDLE_MELEE,
			["pistol"] = ACT_HL2MP_IDLE_PISTOL,
			["slam"] = ACT_HL2MP_IDLE_SLAM
		},
		CrouchWalkAnimations = {
			["normal"] = ACT_HL2MP_WALK_CROUCH,
			["ar2"] = ACT_HL2MP_WALK_CROUCH_AR2,
			["camera"] = ACT_HL2MP_WALK_CROUCH_CAMERA,
			["crossbow"] = ACT_HL2MP_WALK_CROUCH_CROSSBOW,
			["duel"] = ACT_HL2MP_WALK_CROUCH_DUEL,
			["fist"] = ACT_HL2MP_WALK_CROUCH_FIST,
			["knife"] = ACT_HL2MP_WALK_CROUCH_KNIFE,
			["magic"] = ACT_HL2MP_WALK_CROUCH_MAGIC,
			["melee2"] = ACT_HL2MP_WALK_CROUCH_MELEE2,
			["passive"] = ACT_HL2MP_WALK_CROUCH_PASSIVE,
			["physgun"] = ACT_HL2MP_WALK_CROUCH_PHYSGUN,
			["revolver"] = ACT_HL2MP_WALK_CROUCH_REVOLVER,
			["rpg"] = ACT_HL2MP_WALK_CROUCH_RPG,
			["shotgun"] = ACT_HL2MP_WALK_CROUCH_SHOTGUN,
			["smg"] = ACT_HL2MP_WALK_CROUCH_SMG1,
			["grenade"] = ACT_HL2MP_WALK_CROUCH_GRENADE,
			["melee"] = ACT_HL2MP_WALK_CROUCH_MELEE,
			["pistol"] = ACT_HL2MP_WALK_CROUCH_PISTOL,
			["slam"] = ACT_HL2MP_WALK_CROUCH_SLAM
		},
		CrouchIdleAnimations = {
			["normal"] = ACT_HL2MP_IDLE_CROUCH,
			["ar2"] = ACT_HL2MP_IDLE_CROUCH_AR2,
			["camera"] = ACT_HL2MP_IDLE_CROUCH_CAMERA,
			["crossbow"] = ACT_HL2MP_IDLE_CROUCH_CROSSBOW,
			["duel"] = ACT_HL2MP_IDLE_CROUCH_DUEL,
			["fist"] = ACT_HL2MP_IDLE_CROUCH_FIST,
			["knife"] = ACT_HL2MP_IDLE_CROUCH_KNIFE,
			["magic"] = ACT_HL2MP_IDLE_CROUCH_MAGIC,
			["melee2"] = ACT_HL2MP_IDLE_CROUCH_MELEE2,
			["passive"] = ACT_HL2MP_IDLE_CROUCH_PASSIVE,
			["physgun"] = ACT_HL2MP_IDLE_CROUCH_PHYSGUN,
			["revolver"] = ACT_HL2MP_IDLE_CROUCH_REVOLVER,
			["rpg"] = ACT_HL2MP_IDLE_CROUCH_RPG,
			["shotgun"] = ACT_HL2MP_IDLE_CROUCH_SHOTGUN,
			["smg"] = ACT_HL2MP_IDLE_CROUCH_SMG1,
			["grenade"] = ACT_HL2MP_IDLE_CROUCH_GRENADE,
			["melee"] = ACT_HL2MP_IDLE_CROUCH_MELEE,
			["pistol"] = ACT_HL2MP_IDLE_CROUCH_PISTOL,
			["slam"] = ACT_HL2MP_IDLE_CROUCH_SLAM
		},
		JumpAnimations = {
			["normal"] = ACT_HL2MP_JUMP_KNIFE,
			["ar2"] = ACT_HL2MP_JUMP_AR2,
			["camera"] = ACT_HL2MP_JUMP_CAMERA,
			["crossbow"] = ACT_HL2MP_JUMP_CROSSBOW,
			["duel"] = ACT_HL2MP_JUMP_DUEL,
			["fist"] = ACT_HL2MP_JUMP_FIST,
			["knife"] = ACT_HL2MP_JUMP_KNIFE,
			["magic"] = ACT_HL2MP_JUMP_MAGIC,
			["melee2"] = ACT_HL2MP_JUMP_MELEE2,
			["passive"] = ACT_HL2MP_JUMP_PASSIVE,
			["physgun"] = ACT_HL2MP_JUMP_PHYSGUN,
			["revolver"] = ACT_HL2MP_JUMP_REVOLVER,
			["rpg"] = ACT_HL2MP_JUMP_RPG,
			["shotgun"] = ACT_HL2MP_JUMP_SHOTGUN,
			["smg"] = ACT_HL2MP_JUMP_SMG1,
			["grenade"] = ACT_HL2MP_JUMP_GRENADE,
			["melee"] = ACT_HL2MP_JUMP_MELEE,
			["pistol"] = ACT_HL2MP_JUMP_PISTOL,
			["slam"] = ACT_HL2MP_JUMP_SLAM
		},
		ShootAnimations = {
			["normal"] = ACT_HL2MP_GESTURE_RANGE_ATTACK,
			["ar2"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2,
			["camera"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_CAMERA,
			["crossbow"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,
			["duel"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_DUEL,
			["fist"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST,
			["knife"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE,
			["magic"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_MAGIC,
			["melee2"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE2,
			["passive"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_PASSIVE,
			["physgun"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,
			["revolver"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER,
			["rpg"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG,
			["shotgun"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN,
			["smg"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1,
			["grenade"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
			["melee"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,
			["pistol"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,
			["slam"] = ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM
		},
		ReloadAnimations = {
			["normal"] = ACT_HL2MP_GESTURE_RELOAD,
			["ar2"] = ACT_HL2MP_GESTURE_RELOAD_AR2,
			["camera"] = ACT_HL2MP_GESTURE_RELOAD_CAMERA,
			["crossbow"] = ACT_HL2MP_GESTURE_RELOAD_CROSSBOW,
			["duel"] = ACT_HL2MP_GESTURE_RELOAD_DUEL,
			["fist"] = ACT_HL2MP_GESTURE_RELOAD_FIST,
			["knife"] = ACT_HL2MP_GESTURE_RELOAD_KNIFE,
			["magic"] = ACT_HL2MP_GESTURE_RELOAD_MAGIC,
			["melee2"] = ACT_HL2MP_GESTURE_RELOAD_MELEE2,
			["passive"] = ACT_HL2MP_GESTURE_RELOAD_PASSIVE,
			["physgun"] = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
			["revolver"] = ACT_HL2MP_GESTURE_RELOAD_REVOLVER,
			["rpg"] = ACT_HL2MP_GESTURE_RELOAD_RPG,
			["shotgun"] = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
			["smg"] = ACT_HL2MP_GESTURE_RELOAD_SMG1,
			["grenade"] = ACT_HL2MP_GESTURE_RELOAD_GRENADE,
			["melee"] = ACT_HL2MP_GESTURE_RELOAD_MELEE,
			["pistol"] = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
			["slam"] = ACT_HL2MP_GESTURE_RELOAD_SLAM
		}
	},
	NPCModel = {
		RunAnimations = {
			["normal"] = ACT_RUN,
			["ar2"] = ACT_HL2MP_RUN_AR2,
			["camera"] = ACT_HL2MP_RUN_CAMERA,
			["crossbow"] = ACT_HL2MP_RUN_CROSSBOW,
			["duel"] = ACT_HL2MP_RUN_DUEL,
			["fist"] = ACT_HL2MP_RUN_FIST,
			["knife"] = ACT_HL2MP_RUN_KNIFE,
			["magic"] = ACT_HL2MP_RUN_MAGIC,
			["melee2"] = ACT_HL2MP_RUN_MELEE2,
			["passive"] = ACT_HL2MP_RUN_PASSIVE,
			["physgun"] = ACT_HL2MP_RUN_PHYSGUN,
			["revolver"] = ACT_HL2MP_RUN_REVOLVER,
			["rpg"] = ACT_HL2MP_RUN_RPG,
			["shotgun"] = ACT_HL2MP_RUN_SHOTGUN,
			["smg"] = ACT_HL2MP_RUN_SMG1,
			["grenade"] = ACT_HL2MP_RUN_GRENADE,
			["melee"] = ACT_HL2MP_RUN_MELEE,
			["pistol"] = ACT_HL2MP_RUN_PISTOL,
			["slam"] = ACT_HL2MP_RUN_SLAM
		},
		WalkAnimations = {
			["normal"] = ACT_WALK,
			["ar2"] = ACT_HL2MP_WALK_AR2,
			["camera"] = ACT_HL2MP_WALK_CAMERA,
			["crossbow"] = ACT_HL2MP_WALK_CROSSBOW,
			["duel"] = ACT_HL2MP_WALK_DUEL,
			["fist"] = ACT_HL2MP_WALK_FIST,
			["knife"] = ACT_HL2MP_WALK_KNIFE,
			["magic"] = ACT_HL2MP_WALK_MAGIC,
			["melee2"] = ACT_HL2MP_WALK_MELEE2,
			["passive"] = ACT_HL2MP_WALK_PASSIVE,
			["physgun"] = ACT_HL2MP_WALK_PHYSGUN,
			["revolver"] = ACT_HL2MP_WALK_REVOLVER,
			["rpg"] = ACT_HL2MP_WALK_RPG,
			["shotgun"] = ACT_HL2MP_WALK_SHOTGUN,
			["smg"] = ACT_HL2MP_WALK_SMG1,
			["grenade"] = ACT_HL2MP_WALK_GRENADE,
			["melee"] = ACT_HL2MP_WALK_MELEE,
			["pistol"] = ACT_HL2MP_WALK_PISTOL,
			["slam"] = ACT_HL2MP_WALK_SLAM
		},
		CrouchWalkAnimations = {
			["normal"] = ACT_WALK_CROUCH,
			["ar2"] = ACT_HL2MP_WALK_CROUCH_AR2,
			["camera"] = ACT_HL2MP_WALK_CROUCH_CAMERA,
			["crossbow"] = ACT_HL2MP_WALK_CROUCH_CROSSBOW,
			["duel"] = ACT_HL2MP_WALK_CROUCH_DUEL,
			["fist"] = ACT_HL2MP_WALK_CROUCH_FIST,
			["knife"] = ACT_HL2MP_WALK_CROUCH_KNIFE,
			["magic"] = ACT_HL2MP_WALK_CROUCH_MAGIC,
			["melee2"] = ACT_HL2MP_WALK_CROUCH_MELEE2,
			["passive"] = ACT_HL2MP_WALK_CROUCH_PASSIVE,
			["physgun"] = ACT_HL2MP_WALK_CROUCH_PHYSGUN,
			["revolver"] = ACT_HL2MP_WALK_CROUCH_REVOLVER,
			["rpg"] = ACT_HL2MP_WALK_CROUCH_RPG,
			["shotgun"] = ACT_HL2MP_WALK_CROUCH_SHOTGUN,
			["smg"] = ACT_HL2MP_WALK_CROUCH_SMG1,
			["grenade"] = ACT_HL2MP_WALK_CROUCH_GRENADE,
			["melee"] = ACT_HL2MP_WALK_CROUCH_MELEE,
			["pistol"] = ACT_HL2MP_WALK_CROUCH_PISTOL,
			["slam"] = ACT_HL2MP_WALK_CROUCH_SLAM
		},
		IdleAnimations = {
			["normal"] = ACT_IDLE,
			["ar2"] = ACT_HL2MP_IDLE_AR2,
			["camera"] = ACT_HL2MP_IDLE_CAMERA,
			["crossbow"] = ACT_HL2MP_IDLE_CROSSBOW,
			["duel"] = ACT_HL2MP_IDLE_DUEL,
			["fist"] = ACT_HL2MP_IDLE_FIST,
			["knife"] = ACT_HL2MP_IDLE_KNIFE,
			["magic"] = ACT_HL2MP_IDLE_MAGIC,
			["melee2"] = ACT_HL2MP_IDLE_MELEE2,
			["passive"] = ACT_HL2MP_IDLE_PASSIVE,
			["physgun"] = ACT_HL2MP_IDLE_PHYSGUN,
			["revolver"] = ACT_HL2MP_IDLE_REVOLVER,
			["rpg"] = ACT_HL2MP_IDLE_RPG,
			["shotgun"] = ACT_HL2MP_IDLE_SHOTGUN,
			["smg"] = ACT_HL2MP_IDLE_SMG1,
			["grenade"] = ACT_HL2MP_IDLE_GRENADE,
			["melee"] = ACT_HL2MP_IDLE_MELEE,
			["pistol"] = ACT_HL2MP_IDLE_PISTOL,
			["slam"] = ACT_HL2MP_IDLE_SLAM
		},
		CrouchIdleAnimations = {
			["normal"] = ACT_CROUCHIDLE,
			["ar2"] = ACT_HL2MP_IDLE_CROUCH_AR2,
			["camera"] = ACT_HL2MP_IDLE_CROUCH_CAMERA,
			["crossbow"] = ACT_HL2MP_IDLE_CROUCH_CROSSBOW,
			["duel"] = ACT_HL2MP_IDLE_CROUCH_DUEL,
			["fist"] = ACT_HL2MP_IDLE_CROUCH_FIST,
			["knife"] = ACT_HL2MP_IDLE_CROUCH_KNIFE,
			["magic"] = ACT_HL2MP_IDLE_CROUCH_MAGIC,
			["melee2"] = ACT_HL2MP_IDLE_CROUCH_MELEE2,
			["passive"] = ACT_HL2MP_IDLE_CROUCH_PASSIVE,
			["physgun"] = ACT_HL2MP_IDLE_CROUCH_PHYSGUN,
			["revolver"] = ACT_HL2MP_IDLE_CROUCH_REVOLVER,
			["rpg"] = ACT_HL2MP_IDLE_CROUCH_RPG,
			["shotgun"] = ACT_HL2MP_IDLE_CROUCH_SHOTGUN,
			["smg"] = ACT_HL2MP_IDLE_CROUCH_SMG1,
			["grenade"] = ACT_HL2MP_IDLE_CROUCH_GRENADE,
			["melee"] = ACT_HL2MP_IDLE_CROUCH_MELEE,
			["pistol"] = ACT_HL2MP_IDLE_CROUCH_PISTOL,
			["slam"] = ACT_HL2MP_IDLE_CROUCH_SLAM
		},
		JumpAnimations = {
			["normal"] = ACT_JUMP,
			["ar2"] = ACT_HL2MP_JUMP_AR2,
			["camera"] = ACT_HL2MP_JUMP_CAMERA,
			["crossbow"] = ACT_HL2MP_JUMP_CROSSBOW,
			["duel"] = ACT_HL2MP_JUMP_DUEL,
			["fist"] = ACT_HL2MP_JUMP_FIST,
			["knife"] = ACT_HL2MP_JUMP_KNIFE,
			["magic"] = ACT_HL2MP_JUMP_MAGIC,
			["melee2"] = ACT_HL2MP_JUMP_MELEE2,
			["passive"] = ACT_HL2MP_JUMP_PASSIVE,
			["physgun"] = ACT_HL2MP_JUMP_PHYSGUN,
			["revolver"] = ACT_HL2MP_JUMP_REVOLVER,
			["rpg"] = ACT_HL2MP_JUMP_RPG,
			["shotgun"] = ACT_HL2MP_JUMP_SHOTGUN,
			["smg"] = ACT_HL2MP_JUMP_SMG1,
			["grenade"] = ACT_HL2MP_JUMP_GRENADE,
			["melee"] = ACT_HL2MP_JUMP_MELEE,
			["pistol"] = ACT_HL2MP_JUMP_PISTOL,
			["slam"] = ACT_HL2MP_JUMP_SLAM
		}
	}
}

if SERVER then

	-- Getters/setters --

	function ENT:GetAnimList()
		if self._DrGBasePoseParameters["move_x"] then
			return self.Animations.PlayerModel
		else return self.Animations.NPCModel end
	end

	function ENT:GetShootAnimation()
		if not self:HasWeapon() then return end
		return self:GetAnimList().ShootAnimations[self:GetWeapon():GetHoldType()]
	end
	function ENT:GetReloadAnimation()
		if not self:HasWeapon() then return end
		return self:GetAnimList().ReloadAnimations[self:GetWeapon():GetHoldType()]
	end

	-- Functions --

	function ENT:LookAt(pos)
		self:DirectPoseParametersAt(pos, "head", self:EyePos())
	end
	function ENT:AimAt(pos)
		self:DirectPoseParametersAt(pos, "aim", self:GetShootPos())
	end

	-- Hooks --

	local passives = {
		["ar2"] = true,
		["smg"] = true,
		["shotgun"] = true
	}
	local normals = {
		["pistol"] = true,
		["revolver"] = true,
		["melee"] = true,
		["fist"] = true,
		["knife"] = true,
		["duel"] = true
	}
	function ENT:OnUpdateAnimation()
		local anims = self:GetAnimList()
		if self:IsClimbingUp() then return self.ClimbUpAnimation, self.ClimbAnimRate end
		if self:IsClimbingDown() then return self.ClimbDownAnimation, self.ClimbAnimRate end
		local holdtype = self:HasWeapon() and self:GetWeapon():GetHoldType() or "normal"
		if not self:IsPossessed() and not self:HadEnemy() then
			if passives[holdtype] then holdtype = "passive"
			elseif normals[holdtype] then holdtype = "normal" end
		end
		if not self:IsOnGround() then
			return anims.JumpAnimations[holdtype], self.JumpAnimRate
		elseif self:IsCrouching() then
			if self:IsMoving() then return anims.CrouchWalkAnimations[holdtype], self.CrouchWalkAnimRate
			else return anims.CrouchIdleAnimations[holdtype], self.CrouchIdleAnimRate end
		elseif self:IsRunning() then return anims.RunAnimations[holdtype], self.RunAnimRate
		elseif self:IsMoving() then return anims.WalkAnimations[holdtype], self.WalkAnimRate
		else return anims.IdleAnimations[holdtype], self.IdleAnimRate end
	end

	-- Handlers --

else

	-- Getters/setters --

	-- Functions --

	-- Hooks --

	-- Handlers --

end

--PATH lua/entities/egg1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Egg"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/egg1.mdl")
	
end
--PATH addons/sl_util_wallet/lua/entities/ez_wallet_spawned_money/shared.lua:


ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Money"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsSpawnedMoney = true

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "amount")
end


--PATH lua/entities/fishsteak/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cooked Fish Steak"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/fishsteak.mdl")
	
end
--PATH gamemodes/mangarp/entities/entities/food/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Food"
ENT.Author = "Pcwizdan"
ENT.Spawnable = false
ENT.EatSound = "vo/sandwicheat09.mp3" -- Requires Team Fortress 2

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 1, "owning_ent")
end

--PATH lua/entities/fruitapple/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Apple"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/apple.mdl")
	
end
--PATH lua/entities/fruitapple1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Apple"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/apple2.mdl")
	
end
--PATH lua/entities/fruitcoconut/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Coconut"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/coconut.mdl")
	
end
--PATH lua/entities/fruitpineapple/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Pineapple"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/pineapple.mdl")
	
end
--PATH lua/entities/icecream1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Ice Cream (Neapolitan)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/IceCream1.mdl")
	
end
--PATH lua/entities/icecream3b/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Ice Cream (Strawberry)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/IceCream_open3.mdl")
	
end
--PATH lua/entities/marabou1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Marabou"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/marabou1.mdl")
	
end
--PATH lua/entities/mcdmeal2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "McDonalds Meal"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A McDonalds Meal"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/mcdmeal2.mdl")
	
end
--PATH lua/entities/meat6/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cooked Meat"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/meat6.mdl")
	
end
--PATH lua/entities/meat7/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Raw Meat"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/meat7.mdl")
	
end
--PATH lua/entities/meatribs/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Raw Ribs"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/meat_ribs.mdl")
	
end
--PATH gamemodes/mangarp/entities/entities/microwave/shared.lua:
ENT.Base = "lab_base"
ENT.PrintName = "Microwave"

function ENT:initVars()
    self.model = "models/props/cs_office/microwave.mdl"
    self.initialPrice = GAMEMODE.Config.microwavefoodcost
    self.labPhrase = DarkRP.getPhrase("microwave")
    self.itemPhrase = DarkRP.getPhrase("food")
end

--PATH lua/entities/milk/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Milk"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A carton of milk"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/milk.mdl")
	
end
--PATH lua/entities/nb_klk_ryuko.lua:
if not DrGBase then return end -- return if DrGBase isn't installed
ENT.Base = "drgbase_nextbot" -- DO NOT TOUCH (obviously)

-- Misc --
ENT.PrintName = "Ryuko Matoi"
ENT.Category = "KILL la KILL"
ENT.Models = {"models/ryuko/klk-if/juggy/Ryuko_Nextbot.mdl"}
--ENT.Skins = {0, 1, 2, 3}
ENT.CollisionBounds = Vector(20, 20, 75)
ENT.BloodColor = DONT_BLEED

-- Sounds --
--ENT.MultiDamageSounds = {"KLK-IF.Ryuko.Pain",11}
ENT.RandomDamageSounds = {"KLK-IF.Ryuko.Pain1","KLK-IF.Ryuko.Pain2","KLK-IF.Ryuko.Pain3","KLK-IF.Ryuko.Pain4","KLK-IF.Ryuko.Pain5","KLK-IF.Ryuko.Pain6","KLK-IF.Ryuko.Pain7","KLK-IF.Ryuko.Pain8","KLK-IF.Ryuko.Pain9","KLK-IF.Ryuko.Pain10","KLK-IF.Ryuko.Pain11"}

-- Stats --
ENT.SpawnHealth = 22000
ENT.SightRange = 32000

-- AI --
ENT.RangeAttackRange = 12500
ENT.MeleeAttackRange = 85
ENT.ReachEnemyRange = 25
ENT.AvoidEnemyRange = 0
ENT.FollowPlayers = true

-- Relationships --
ENT.Factions = {FACTION_KLK}

-- Movements/animations --
ENT.UseWalkframes = true
ENT.WalkAnimation = "idletowalk"
ENT.RunAnimation = "idletorun"
ENT.IdleAnimation = "idle"
ENT.JumpAnimation = "jumpstart"
ENT.MultiFlinchAnims = {"hitheadlight","hitheadheavy","hitchest","hitstomachlight","hitstomachheavy","hitfaceleft","hitfaceright","hitlegleft","hitlegright"}
ENT.GroundDodgeAnims = {"dodgeleft","dodgeright","dodgeback"}
ENT.SideDodgeAnims = {"dodgeleft","dodgeright"}
ENT.AirDodgeAnims = {"dashairleft","dashairright"}

-- Detection --
ENT.EyeBone = "G_Root_EyeAll"
ENT.EyeOffset = Vector(10, 0, 1)
ENT.EyeAngle = Angle(0, 0, 0)

-- ConVars --
ENT.KLK_Handicap = 1
ENT.KLK_PlyDMGMult = 1
ENT.KLK_OwnDMGMult = 1
ENT.KLK_DisableMusic = false
ENT.KLK_CanPlayMusic = true
ENT.KLK_MusicTimer = 0
ENT.KLK_DisableValor = false
ENT.KLK_DisableValParry = false
ENT.KLK_DisableValReset = false
ENT.KLK_DisableRegen = false
ENT.KLK_DisableArmor = false
ENT.KLK_DisableCounter = false
ENT.KLK_DisableIntro = false
ENT.KLK_DisableSpecials = false
ENT.KLK_DisableFinishers = false
ENT.KLK_EnableAlliance = false
ENT.KLK_PlayerFriendly = false
ENT.KLK_CloneFriendly = false
-- ===== ---

-- ===== ---
-- Custom Dark Magic Fuckery --
ENT.DrG_IsKLK = true
ENT.KLK_RyukoEnemyVel = 0
ENT.KLK_IsLosing = false
ENT.KLK_Doppelgangers = false
ENT.KLK_IsDefeated = false
ENT.KLK_IsAttacking = false
ENT.KLK_DashAirCharging = false
ENT.KLK_DashGroundCharging = false
ENT.KLK_DashLaunchCharging = false
ENT.KLK_DashChargeSuccess = false
ENT.KLK_IsFlinching = false
ENT.KLK_IsDodging = false
ENT.KLK_IsKnocked = false
ENT.KLK_KnockedLock = false
ENT.KLK_CanParry = false
ENT.KLK_BlockMode = false
ENT.KLK_IsBlocking = false
ENT.KLK_IsDoingAirAttack = false
ENT.KLK_AirAttackLock = true
ENT.KLK_IsDoingAirDash = false
ENT.KLK_AirDashLock = true
ENT.KLK_CanGroundStomp = false
ENT.KLK_CanTaunt = false
ENT.KLK_ShouldJump = false
ENT.KLK_HitGroundLock = false
ENT.KLK_PunchConnect = false
ENT.KLK_CanReleaseSteam = false
ENT.KLK_SteamRelease = false
ENT.KLK_AttackCount = 0
ENT.KLK_AttackRange = 100
ENT.KLK_KMTCCounter = 0
ENT.KLK_ShearCounter = 0
ENT.KLK_DodgeCounter = 0
ENT.KLK_KnockedTime = 0
ENT.KLK_BlockHits = 0
ENT.KLK_KnockHits = 0
ENT.KLK_AAElevationDiff = 0
ENT.KLK_AADistDiff = 0
ENT.KLK_ADElevationDiff = 0
ENT.KLK_ADDistDiff = 0
ENT.KLK_SizeDiff = 1
ENT.KLK_NextRoll = 0
ENT.KLK_HitGroundVel = 0
ENT.KLK_HitGroundVertical = 0
ENT.KLK_HitGroundLength = 0
ENT.KLK_PunchCount = 0
ENT.KLK_PunchDist = 0
ENT.KLK_RyukoMeter = 0
ENT.KLK_RyukoParry = 0
ENT.KLK_LastDetect = CurTime()
ENT.KLK_ShakeTime = CurTime()
ENT.KLK_FlyTime = CurTime()
ENT.KLK_PunchTime = CurTime()
ENT.KLK_BlockTime = CurTime()
ENT.KLK_RollTime = CurTime()
ENT.KLK_RapidTime = CurTime()
ENT.KLK_AttackTime = CurTime()
ENT.KLK_TauntTime = CurTime()
ENT.KLK_RecoverTime = CurTime()
ENT.KLK_ImmuneTime = CurTime()
ENT.KLK_ParryTime = CurTime()
ENT.KLK_TookDmgTime = CurTime() + 10
ENT.KLK_Checker = CurTime()
ENT.KLK_DashTime = CurTime()
ENT.KLK_HitGroundCheck = CurTime()
ENT.KLK_Charging = CurTime()
ENT.KLK_DodgeTimer = CurTime()
ENT.KLK_MeterTimer = CurTime()
ENT.KLK_MeterCooldown = CurTime()
ENT.KLK_CombatTime = CurTime() + 30
ENT.KLK_BoredTimer = CurTime()
ENT.KLK_PatienceTime = CurTime() + 30
ENT.KLK_FinishTime = CurTime()
ENT.KLK_JetTime = CurTime()
ENT.KLK_NextFinish = CurTime()
ENT.KLK_RangeLightTime = CurTime() + math.random(3,9)
ENT.KLK_RangeMediumTime = CurTime() + math.random(9,27)
ENT.KLK_RangeHeavyTime = CurTime() + math.random(27,81)
ENT.KLK_RangeCooldown = CurTime() + math.random(1,3)
-- ===== ---

ENT.KLK_ValorMode = false
ENT.KLK_ValorBursting = false
ENT.KLK_ValorLevelLock = false
ENT.KLK_ValorLimit = 0
ENT.KLK_ValorLevel = 0
ENT.KLK_ValorCount = 0
ENT.KLK_ValorArmor = 1
ENT.KLK_ValorPoiseBonus = 1
ENT.KLK_ValorArmorBonus = 1
ENT.KLK_ValorDamageBonus = 1
ENT.KLK_ValorSpeedBonus = 1
ENT.KLK_ValorRegenBonus = 1
ENT.KLK_ValorHitLimit = 0
ENT.KLK_ValorTimer = CurTime()
ENT.KLK_ValorSoak = 0
ENT.KLK_ValorHits = 1
ENT.KLK_TargLockTime = 0
ENT.KLK_NoLimits = false

ENT.KLK_CurMeleeAnim = nil
ENT.KLK_CurRangeAnim = nil

-- Ryuko Combos --
ENT.KLK_DoingFirstCombo = false
ENT.KLK_HasTransformed = true
ENT.KLK_ShouldTransform = true
ENT.KLK_Synchronized = false
ENT.KLK_Transforming = false
ENT.KLK_RyukoStamina = 100
ENT.KLK_Combo_Range = 125
ENT.KLK_Combo_Cycle = 0.4
ENT.KLK_FanTime = CurTime()
ENT.KLK_FanCount = CurTime()
ENT.KLK_FirstCombo_1 = "attackswingrightwide"
ENT.KLK_FirstCombo_2 = "attacksrwswingleftkickright"
ENT.KLK_FirstCombo_3 = "attackjumpswingoverhead"
ENT.KLK_FirstCombo_4 = "attackspinleftswingoverhead"
ENT.KLK_SecondCombo_1 = "attackswingleft2x"
ENT.KLK_SecondCombo_2 = "attackjsoswiperight"
ENT.KLK_SecondCombo_3 = "attackjsopunchuppercutlaunch"
ENT.KLK_SecondCombo_4 = "attackjsoswinguppercutrampant"
ENT.KLK_ThirdCombo_1 = "attackjsopunchuppercut"
ENT.KLK_ThirdCombo_2 = "attackheadbutttokick"
ENT.KLK_ThirdCombo_3 = "dashair"
ENT.KLK_ThirdCombo_4 = "attackdashelbow"
ENT.KLK_ThirdCombo_5 = "attackswingrightswingleft"
ENT.KLK_FourthCombo_1 = "attackpunchhookleft"
ENT.KLK_FourthCombo_2 = "attackfrontkick"
ENT.KLK_FourthCombo_3 = "attackdecapmodefull"
ENT.KLK_FifthCombo_1 = "attackhopswingright"
ENT.KLK_SixthCombo_1 = "attackswingoverheadlight"
ENT.KLK_SixthCombo_2 = "attackjsoswinguppercut"
ENT.KLK_SixthCombo_3 = "attackfinisheropener"
ENT.KLK_SixthCombo_4 = "attackfinisherslashfull"
ENT.KLK_SeventhCombo_1 = "attackairswingrightoverhead"
ENT.KLK_SeventhCombo_2 = "attackairswingoverheadlight"
ENT.KLK_SeventhCombo_3 = "attackairswingoverheadheavy"
ENT.KLK_SeventhCombo_4 = "attackairjumpswingoverhead"
ENT.KLK_SeventhCombo_5 = "attackdashstart"
ENT.KLK_SeventhCombo_6 = "attackdashcharge"
ENT.KLK_SeventhCombo_7 = "attackdashslashoverhead"
ENT.KLK_EighthCombo_1 = "jumpstart"
ENT.KLK_EighthCombo_2 = "jumpup"
ENT.KLK_EighthCombo_3 = "dashairparryloop"
ENT.KLK_EighthCombo_4 = "dashairslow"
ENT.KLK_EighthCombo_5 = "attackairswingleft"
ENT.KLK_EighthCombo_6 = "attackairslflswingleft4x"
ENT.KLK_EighthCombo_7 = "attackairsidekick"
ENT.KLK_NinthCombo_1 = "attackswingoverheadheavy"
ENT.KLK_TenthCombo_1 = "attackairkick"
ENT.KLK_TenthCombo_2 = "dashairdragon"
ENT.KLK_TenthCombo_3 = "attackairbackflipkick"
ENT.KLK_EleventhCombo_1 = "attackairkick"
ENT.KLK_EleventhCombo_2 = "dashairdragon"
ENT.KLK_EleventhCombo_3 = "attackairbackflipkick"
ENT.KLK_TwelfthCombo_1 = "attackspinfull"
ENT.KLK_TwelfthCombo_2 = "attackspinpunch"
ENT.KLK_ThirteenthCombo_1 = "dashground"
ENT.KLK_ThirteenthCombo_2 = "dodgeback"
ENT.KLK_ThirteenthCombo_3 = "dodgeleft"
ENT.KLK_ThirteenthCombo_4 = "dodgeright"
---------------------------------------------------------------------------------------------------------------------------------------------
--=========================================================================================================================================--
---------------------------------------------------------------------------------------------------------------------------------------------
-- Possession --
ENT.PossessionEnabled = false
ENT.PossessionMovement = POSSESSION_MOVE_8DIR
ENT.PossessionCrosshair = true
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.PossessionViews = {
  {
    offset = Vector(0, 40, 0),
    distance = 125
  },
  {
    offset = Vector(7.5, 0, 10),
    distance = 0,
    eyepos = true
  }
}
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.PossessionBinds = {
  [IN_JUMP] = {{
    coroutine = false,
    onkeypressed = function(self)
      if not self:IsOnGround() then return end
      self:LeaveGround()
      self:SetVelocity(self:PossessorNormal()*1500)
    end
  }},
  [IN_ATTACK] = {{
    coroutine = true,
    onkeydown = function(self)
      self:PlaySequenceAndMove("attack"..math.random(6), 1, self.PossessionFaceForward)
    end
  }},
  [IN_ATTACK2] = {{
    coroutine = true,
    onkeydown = function(self)
      self:BurrowTo(self:PossessorTrace().HitPos)
    end
  }}
}
---------------------------------------------------------------------------------------------------------------------------------------------
--=========================================================================================================================================--
---------------------------------------------------------------------------------------------------------------------------------------------
if SERVER then
---------------------------------------------------------------------------------------------------------------------------------------------
	-- Antlion --
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:BurrowTo(pos)
	self:PlaySequenceAndMove("digin")
	if navmesh.IsLoaded() then
		pos = navmesh.GetNearestNavArea(pos):GetClosestPointOnArea(pos) or pos
	end
	self:SetPos(pos)
	self:DropToFloor()
	self:PlaySequenceAndMove("digout")
end
---------------------------------------------------------------------------------------------------------------------------------------------
	-- Init/Think --
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomInitialize()
	-- ConVars --
	self:SetDefaultRelationship(D_HT)
	self:AddRelationship( "nb_klk_covers D_HT 99" )
	self:AddRelationship( "nb_klk_titancovers D_HT 99" )
	self.KLK_Handicap = GetConVar("drg_killlakill_handicap"):GetFloat()
	self.KLK_PlyDMGMult = GetConVar("drg_killlakill_plydmgmult"):GetFloat()
	self.KLK_RyukoParry = GetConVar("drg_killlakill_parryamount"):GetFloat()*10
	self.KLK_ValorLimit = GetConVar("drg_killlakill_valorlimit"):GetFloat()
	if GetConVar("drg_killlakill_easymode"):GetBool() then
		self.KLK_OwnDMGMult = 0.05
	end
	if self.KLK_ValorLimit == 0 then
		self.KLK_NoLimits = true
	end
	if GetConVar("drg_killlakill_armor"):GetBool() then
		self.KLK_ValorArmor = 0
	end
	if GetConVar("drg_killlakill_regen"):GetBool() then
		self.KLK_DisableRegen = true
	end
	if GetConVar("drg_killlakill_music"):GetBool() then
		self.KLK_CanPlayMusic = false
	end
	if GetConVar("drg_killlakill_valormode"):GetBool() then
		self.KLK_DisableValor = true
	end
	if GetConVar("drg_killlakill_valorparry"):GetBool() then
		self.KLK_DisableValParry = true
	end
	if GetConVar("drg_killlakill_valorreset"):GetBool() then
		self.KLK_DisableValReset = true
	end
	if GetConVar("drg_killlakill_counterburst"):GetBool() then
		self.KLK_DisableCounter = true
	end
	if GetConVar("drg_killlakill_transform"):GetBool() then
		self.KLK_DisableIntro = true
	end
	if GetConVar("drg_killlakill_specials"):GetBool() then
		self.KLK_DisableSpecials = true
	end
	if GetConVar("drg_killlakill_finisher"):GetBool() then
		self.KLK_DisableFinishers = true
	end
	if GetConVar("drg_killlakill_alliance"):GetBool() then
		self.KLK_EnableAlliance = true
		self:AddRelationship( "nb_klk_satsuki D_LI 99" )
		self:SetModelRelationship("models/satsuki/klk-if/juggy/Satsuki_Nextbot.mdl", D_LI)
		if GetConVar("drg_killlakill_stucoop"):GetBool() then
			self:AddRelationship( "nb_klk_student D_LI 99" )
			self:SetModelRelationship("models/student/klk-if/juggy/Student_Nextbot.mdl", D_LI)
		else
			self:AddRelationship( "nb_klk_student D_HT 1" )
			self:SetModelRelationship("models/student/klk-if/juggy/Student_Nextbot.mdl", D_HT)
		end
		--self.Factions = {"FACTION_KLK_REBEL","FACTION_KLK_HONNOJI"}
	else
		if GetConVar("drg_killlakill_stucoop"):GetBool() then
			self:AddRelationship( "nb_klk_student D_LI 99" )
			self:SetModelRelationship("models/student/klk-if/juggy/Student_Nextbot.mdl", D_LI)
			--self.Factions = {"FACTION_KLK_REBEL","FACTION_KLK_INSURRECTION"}
		else
			self:AddRelationship( "nb_klk_student D_HT 1" )
			self:SetModelRelationship("models/student/klk-if/juggy/Student_Nextbot.mdl", D_HT)
		end
		self.KLK_EnableAlliance = false
	end
	if GetConVar("drg_killlakill_friendly"):GetBool() then
		self.KLK_PlayerFriendly = true
		self:SetPlayersRelationship(D_LI, 99)
	else
		self.KLK_PlayerFriendly = false
		--self:SetPlayersRelationship(D_HT, 5)
	end
	if GetConVar("drg_killlakill_clone"):GetBool() then
		self.KLK_CloneFriendly = true
		self:SetSelfClassRelationship(D_LI)
	else
		self.KLK_CloneFriendly = false
		self:SetSelfClassRelationship(D_HT)
	end
	if self.KLK_CanPlayMusic == false then
		self.KLK_DisableMusic = true
	end
	-- ===== --
	
	for k, OtherRyukos in pairs(ents.GetAll()) do
		if (IsValid(OtherRyukos) && OtherRyukos.DrG_IsKLK == true && OtherRyukos != self && OtherRyukos.KLK_CanPlayMusic == true) then
			self.KLK_ShouldTransform = false
			self.KLK_DisableMusic = true
		end
	end
	
	/*self.KLK_ValorPoiseBonus = 1 *(1-(math.Clamp((self.KLK_Handicap-1),0,9)/10))
	self.KLK_ValorArmorBonus = 1 *(1-(math.Clamp((self.KLK_Handicap-1),0,9)/10))
	self.KLK_ValorDamageBonus = 1 *(1-(math.Clamp((self.KLK_Handicap-1),0,9)/10))*/
	
	--self.KLK_ValorPoiseBonus = 1 / math.Clamp(self.KLK_Handicap,1,10)
	--self.KLK_ValorArmorBonus = 1 / math.Clamp(self.KLK_Handicap,1,10)
	self.KLK_ValorDamageBonus = 1 / math.Clamp(self.KLK_Handicap,1,10)

	self:KLK_ResetAttacks()
	self.KLK_TookDmgTime = CurTime() + 10
	self.KLK_CombatTime = CurTime() + 20
	
	--self:SetDefaultRelationship(D_LI)
	
	self.SSDefaultOutline = ents.Create("prop_physics")
	self.SSDefaultOutline:SetModel("models/ryuko/klk-if/juggy/SS_Default_Outline.mdl")
	self.SSDefaultOutline:SetLocalPos(self:GetPos())
	self.SSDefaultOutline:SetParent(self)
	self.SSDefaultOutline:SetOwner(self)
	self.SSDefaultOutline:Fire("setparentattachment", self:GetPos())
	self.SSDefaultOutline:Spawn()
	self.SSDefaultOutline:Activate()
	self.SSDefaultOutline:SetNoDraw(true)
	self.SSDefaultOutline:SetSolid(SOLID_NONE)
	self.SSDefaultOutline:AddEffects(EF_BONEMERGE)
	self:DeleteOnRemove(self.SSDefaultOutline)
	
	self.SSDecapOutline = ents.Create("prop_physics")
	self.SSDecapOutline:SetModel("models/ryuko/klk-if/juggy/SS_Decap_Outline.mdl")
	self.SSDecapOutline:SetLocalPos(self:GetPos())
	self.SSDecapOutline:SetParent(self)
	self.SSDecapOutline:SetOwner(self)
	self.SSDecapOutline:Fire("setparentattachment", self:GetPos())
	self.SSDecapOutline:Spawn()
	self.SSDecapOutline:Activate()
	self.SSDecapOutline:SetNoDraw(true)
	self.SSDecapOutline:SetSolid(SOLID_NONE)
	self.SSDecapOutline:AddEffects(EF_BONEMERGE)
	self:DeleteOnRemove(self.SSDecapOutline)
	
	ParticleEffect("martialhit_heavy_helper_base",self:GetPos(),self:GetAngles())
	ParticleEffect("martialhit_heavy_slowhelper_base",self:GetPos(),self:GetAngles())
	
	if self.KLK_ShouldTransform == true && self.KLK_DisableIntro == false then
		self.KLK_HasTransformed = false
		self.KLK_Transforming = true
		self.spot = ents.Create( "env_projectedtexture" )
		self.spot:SetParent(self)
		self.spot:SetPos(self:GetPos() +self:GetForward()*25)
		self.spot:SetAngles(self:GetAngles() +Angle(-105,0,0))
		self.spot:SetKeyValue( "enableshadows", 1 )
		self.spot:SetKeyValue( "shadowquality", 1 )
		self.spot:SetKeyValue( "nearz", 1 )
		self.spot:Input("SpotlightTexture",NULL,NULL,"effects/flashlight/hard")
		self.spot:Input("FOV",NULL,NULL,90)
		self.spot:SetKeyValue("farz", 2048)
		self.spot:SetKeyValue("brightnessscale", 8.00)
		self.spot:SetKeyValue("lightcolor","225 255 255 255")
		self.spot:Spawn()
		self:DeleteOnRemove(self.spot)
		self.transformlight = ents.Create("light_dynamic")
		self.transformlight:SetParent(self)
		self.transformlight:SetPos(self:GetPos() +self:GetUp()*5 +self:GetForward()*15)
		self.transformlight:SetKeyValue( "_light", "225 255 255 255" )
		self.transformlight:SetKeyValue("distance", "125" )
		self.transformlight:SetKeyValue("brightness", 6)
		self.transformlight:Spawn()
		self:DeleteOnRemove(self.transformlight)
		timer.Simple(7.5,function() if IsValid(self) && IsValid(self.spot) && IsValid(self.transformlight) then
			self.spot:Remove()
			self.transformlight:Remove()
			timer.Simple(0.5,function() if IsValid(self) then
				self.KLK_Transforming = false
				self:RemoveFlags(FL_NOTARGET)
			end end)
		end end)
		self.KLK_ImmuneTime = CurTime() + 8
		self:SetBodygroup(2,2)
		self:SetCooldown("NextRyukoCharge",10)
		self:SetCooldown("NextRyukoFlinch",10)
		self:SetCooldown("NextRyukoDodge",10)
		self:SetCooldown("NextRyukoEvade",10)
		self:SetCooldown("NextRyukoDash",10)
		self:SetCooldown("NextRyukoParry",10)
		self:SetCooldown("NextRyukoValParry",10)
		self:SetCooldown("NextRyukoValor",10)
		self:SetCooldown("RyukoInvul",10)
		self:SetCooldown("RyukoStaminaRecharge",10)
		self:SetCooldown("RyukoParryRecharge",10)
	else
		self:SetCooldown("NextRyukoCharge",0)
		self:SetCooldown("NextRyukoFlinch",0)
		self:SetCooldown("NextRyukoDodge",0)
		self:SetCooldown("NextRyukoEvade",0)
		self:SetCooldown("NextRyukoDash",0)
		self:SetCooldown("NextRyukoParry",0)
		self:SetCooldown("NextRyukoValParry",0)
		self:SetCooldown("NextRyukoValor",0)
		self:SetCooldown("RyukoInvul",0)
		self:SetCooldown("RyukoStaminaRecharge",0)
		self:SetCooldown("RyukoParryRecharge",0)
	end
	
	/*for amt = 1, self.MultiDamageSounds[2] do table.insert(self.OnDamageSounds,self.MultiDamageSounds[1]..""..amt) end*/
	
	if self.KLK_DisableRegen == false then
		self:SetHealthRegen(110)
	end
	
	-- Initialization --
		self:SequenceEvent("ryukotransformland",{480/484},function()
			self:KLK_WeaponSwitch()
			self.IdleAnimation = "idle"
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "idletosprint"
				else
					self.RunAnimation = "idletorun"
				end
			end
		end)
	-- Movement --
		self:SequenceEvent("idle",{40/41},function()
			self:KLK_WeaponSwitch()
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_ValorLevel > 0 then
				self.RunAnimation = "idletosprint"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "idletosprint"
				else
					self.RunAnimation = "idletorun"
				end
			end
		end)
		self:SequenceEvent("idletowalk",{29/30},function()
			self:KLK_WeaponSwitch()
			self.KLK_IsKnocked = false
			self.KLK_KnockedLock = false
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.KLK_IsAttacking = false
			self.WalkAnimation = "walk"
			self.JumpAnimation = "jumpstart"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "walk"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "sprint"
				else
					self.RunAnimation = "run"
				end
			end
		end)
		self:SequenceEvent("idletorun",{13/14},function()
			self:KLK_WeaponSwitch()
			self.KLK_IsDodging = false
			self.KLK_IsKnocked = false
			self.KLK_KnockedLock = false
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.KLK_IsAttacking = false
			self.JumpAnimation = "jumpstart"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "runtoidle"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "sprint"
				else
					self.RunAnimation = "run"
				end
			end
		end)
		self:SequenceEvent("idletosprint",{13/14},function()
			self:KLK_WeaponSwitch()
			self.KLK_DashTime = CurTime() + 1
			self.KLK_IsDodging = false
			self.KLK_IsKnocked = false
			self.KLK_KnockedLock = false
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.KLK_IsAttacking = false
			self.JumpAnimation = "jumpstart"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "sprinttoidle"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "sprint"
				else
					self.RunAnimation = "run"
				end
			end
		end)
		self:SequenceEvent("runtoidle",{40/41},function()
			self:KLK_WeaponSwitch()
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				self.RunAnimation = "idletorun"
			end
		end)
		self:SequenceEvent("sprinttoidle",{40/41},function()
			self:KLK_WeaponSwitch()
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "idletosprint"
				else
					self.RunAnimation = "idletorun"
				end
			end
		end)
		self:SequenceEvent("dodgeleft",{1/66},function()
			self.KLK_DashTime = CurTime() + 0.425
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*-50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("dodgeright",{1/66},function()
			self.KLK_DashTime = CurTime() + 0.425
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("dodgeback",{1/72},function()
			self.KLK_DashTime = CurTime() + 0.425
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles())
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*-50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("dashground",{1/81},function()
			self.KLK_DashTime = CurTime() + 0.425
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles())
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("rapiddashleft",{1/66},function()
			self.KLK_DashTime = CurTime() + 0.375
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*-50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("rapiddashright",{1/66},function()
			self.KLK_DashTime = CurTime() + 0.375
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("rapiddashback",{1/72},function()
			self.KLK_DashTime = CurTime() + 0.375
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles())
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*-50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("rapiddashfront",{1/81},function()
			self.KLK_DashTime = CurTime() + 0.375
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles())
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
			util.Effect("PunchShockwave",Effect,true,true)
		end)
		self:SequenceEvent("walktoidle",{40/41},function()
			self:KLK_WeaponSwitch()
			self.IdleAnimation = "idle"
		end)
		self:SequenceEvent("jumpstart",{1/5},function()
			self:KLK_WeaponSwitch()
			self.JumpAnimation = "jumpup"
			if self.KLK_ShouldJump == true then
				self.KLK_ShouldJump = false
				self:Jump(250)
				self:SetVelocity(self:GetUp()*625)
			end
		end)
		self:SequenceEvent("jumpup",{22/23},function()
			self:KLK_WeaponSwitch()
			self.JumpAnimation = "jumploop"
			if self.KLK_ShouldJump == true then
				self.KLK_ShouldJump = false
				self:Jump(250)
				self:SetVelocity(self:GetUp()*625)
			end
		end)
		self:SequenceEvent("jumploop",{1/14},function()
			if self:WaterLevel() <= 0 then self.KLK_HitGroundLock = false end
			self:KLK_WeaponSwitch()
			self.IdleAnimation = "jumpend"
			self.WalkAnimation = "jumpend"
			self.RunAnimation = "jumpend"
			self.KLK_IsDoingAirAttack = false
			self.KLK_IsDoingAirDash = false
		end)
		self:SequenceEvent("jumpend",{20/26},function()
			self:KLK_WeaponSwitch()
			self.IdleAnimation = "idle"
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				self.RunAnimation = "idletorun"
			end
		end)
		self:SequenceEvent("walk",{106/107},function()
			self:KLK_WeaponSwitch()
			self:KLK_ResetAttacks()
			self.KLK_IsKnocked = false
			self.KLK_KnockedLock = false
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.KLK_IsAttacking = false
			self.KLK_DashAirCharging = false
			self.KLK_DashGroundCharging = false
			self.IdleAnimation = "walktoidle"
			self.JumpAnimation = "jumpstart"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "walk"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "idletosprint"
				else
					self.RunAnimation = "idletorun"
				end
			end
		end)
		self:SequenceEvent("run",{46/47},function()
			self:KLK_WeaponSwitch()
			self:KLK_ResetAttacks()
			self.KLK_IsKnocked = false
			self.KLK_KnockedLock = false
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.KLK_IsAttacking = false
			self.KLK_DashAirCharging = false
			self.KLK_DashGroundCharging = false
			self.JumpAnimation = "jumpstart"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "runtoidle"
			end
		end)
		self:SequenceEvent("sprint",{46/47},function()
			self:KLK_WeaponSwitch()
			self:KLK_ResetAttacks()
			self.KLK_IsKnocked = false
			self.KLK_KnockedLock = false
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.KLK_IsAttacking = false
			self.KLK_DashAirCharging = false
			self.KLK_DashGroundCharging = false
			self.JumpAnimation = "jumpstart"
			self.KLK_DashTime = CurTime() + 1
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles())
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
			util.Effect("PunchShockwave",Effect,true,true)
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "sprinttoidle"
			end
		end)
		self:SequenceEvent("blockstart",{10/11},function()
			self:KLK_WeaponSwitch()
			self.IdleAnimation = "blockloop"
			self.WalkAnimation = "blockloop"
			self.RunAnimation = "blockloop"
		end)
		self:SequenceEvent("blockloop",{106/107},function()
			self:KLK_WeaponSwitch()
			if self.KLK_BlockTime < CurTime() then
				self.IdleAnimation = "blockend"
				self.WalkAnimation = "blockend"
				self.RunAnimation = "blockend"
			else
				self.IdleAnimation = "blockloop"
				self.WalkAnimation = "blockloop"
				self.RunAnimation = "blockloop"
			end
		end)
		self:SequenceEvent("blockhit",{10/11},function()
			self:KLK_WeaponSwitch()
			self.IdleAnimation = "blockloop"
			self.WalkAnimation = "blockloop"
			self.RunAnimation = "blockloop"
		end)
		self:SequenceEvent("blockend",{16/17},function()
			self:KLK_WeaponSwitch()
			self.KLK_BlockMode = false
			self.IdleAnimation = "idle"
			self.WalkAnimation = "idletowalk"
			self.JumpAnimation = "jumpstart"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				self.RunAnimation = "idletorun"
			end
		end)
	-- Flinching --
		self:SequenceEvent("hitlaunchup",{1/39,11/39,21/39},function()
			self.KLK_IsKnocked = true
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.JumpAnimation = "hitlaunchupfallloop"
			self.IdleAnimation = "hitlaunchupdrop"
			self.WalkAnimation = "hitlaunchupdrop"
			self.RunAnimation = "hitlaunchupdrop"
		end)
		self:SequenceEvent("hitlaunchupflip",{1/16},function()
			self.KLK_IsKnocked = true
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.JumpAnimation = "hitlaunchupfallloop"
			self.IdleAnimation = "hitlaunchupdrop"
			self.WalkAnimation = "hitlaunchupdrop"
			self.RunAnimation = "hitlaunchupdrop"
		end)
		self:SequenceEvent("hitlaunchupfallloop",{1/19},function()
			self.KLK_IsKnocked = true
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.IdleAnimation = "hitlaunchupdrop"
			self.WalkAnimation = "hitlaunchupdrop"
			self.RunAnimation = "hitlaunchupdrop"
			self.KLK_IsDoingAirAttack = false
		end)
		self:SequenceEvent("hitlaunchupdrop",{1/16},function()
			self.KLK_RecoverTime = CurTime() + 0.75
			self.KLK_IsKnocked = true
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.IdleAnimation = "hitlaunchupendloop"
			self.WalkAnimation = "hitlaunchupendloop"
			self.RunAnimation = "hitlaunchupendloop"
		end)
		self:SequenceEvent("hitlaunchupendloop",{1/1},function()
			if self.KLK_RecoverTime >= CurTime() then
				self.KLK_IsKnocked = true
				self.KLK_BlockMode = false
				self.KLK_IsBlocking = false
				self.IdleAnimation = "hitlaunchupendloop"
				self.WalkAnimation = "hitlaunchupendloop"
				self.RunAnimation = "hitlaunchupendloop"
				self:SetCooldown("NextRyukoDodge",5)
				--self.KLK_ImmuneTime = CurTime() + 0.875
			else
				self.KLK_ImmuneTime = CurTime() + 1
				self.IdleAnimation = "recoverground"
				self.WalkAnimation = "recoverground"
				self.RunAnimation = "recoverground"
			end
		end)
		self:SequenceEvent("hitlaunchback",{1/83,11/83,21/83,31/83,41/83,51/83},function()
			self.KLK_IsKnocked = true
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.JumpAnimation = "wallsplatfallloop"
			self.IdleAnimation = "wallsplatdrop"
			self.WalkAnimation = "wallsplatdrop"
			self.RunAnimation = "wallsplatdrop"
		end)
		self:SequenceEvent("wallsplatfallloop",{1/14},function()
			self.KLK_IsKnocked = true
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.IdleAnimation = "wallsplatdrop"
			self.WalkAnimation = "wallsplatdrop"
			self.RunAnimation = "wallsplatdrop"
			self.KLK_IsDoingAirAttack = false
		end)
		self:SequenceEvent("wallsplatdrop",{1/26},function()
			self.KLK_IsKnocked = true
			self.KLK_BlockMode = false
			self.KLK_IsBlocking = false
			self.KLK_RecoverTime = CurTime() + 0.75
			self.IdleAnimation = "wallsplatendloop"
			self.WalkAnimation = "wallsplatendloop"
			self.RunAnimation = "wallsplatendloop"
		end)
		self:SequenceEvent("wallsplatendloop",{1/1},function()
			if self.KLK_RecoverTime >= CurTime() then
				self.KLK_IsKnocked = true
				self.KLK_BlockMode = false
				self.KLK_IsBlocking = false
				self.IdleAnimation = "wallsplatendloop"
				self.WalkAnimation = "wallsplatendloop"
				self.RunAnimation = "wallsplatendloop"
				self:SetCooldown("NextRyukoDodge",5)
				--self.KLK_ImmuneTime = CurTime() + 0.875
			else
				self.KLK_ImmuneTime = CurTime() + 1
				self.IdleAnimation = "recoverground"
				self.WalkAnimation = "recoverground"
				self.RunAnimation = "recoverground"
			end
		end)
		self:SequenceEvent("recoverground",{40/41},function()
			self:SetCooldown("NextRyukoDodge",5)
			self.KLK_IsKnocked = false
			self.KLK_KnockedLock = false
			self.KLK_IsBlocking = false
			self.IdleAnimation = "idle"
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				self.RunAnimation = "idletorun"
			end
		end)
	-- Attacks --
		self:SequenceEvent("attackdashelbow",{1/62,20/62},function()
			if self.KLK_AttackCount < 1 then
				self.KLK_DashTime = CurTime() + 0.625
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self.KLK_DashGroundCharging = true
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairswingrightoverhead",{1/136,15/136,30/136,80/136},function()
			if self.KLK_AttackCount < 1 then
				self.KLK_DashLaunchCharging = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			elseif self.KLK_AttackCount == 1 then
				self.KLK_IsDoingAirAttack = true
				self.KLK_AirAttackLock = false
				self:Jump(100)
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			elseif self.KLK_AttackCount == 2 then
				self.KLK_AirAttackLock = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
				self.KLK_DashLaunchCharging = false
			elseif self.KLK_AttackCount == 3 then
				self.KLK_IsDoingAirAttack = false
				self.KLK_CanGroundStomp = true
				self.KLK_AttackCount = 0
			end
		end)
		/*self:SequenceEvent("attackdecapmodefull",{236/411,250/411,265/411,315/411},function()
			if self.KLK_AttackCount < 1 then
				self.KLK_DashLaunchCharging = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			elseif self.KLK_AttackCount == 1 then
				self.KLK_IsDoingAirAttack = true
				self.KLK_AirAttackLock = false
				self:Jump(100)
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			elseif self.KLK_AttackCount == 2 then
				self.KLK_AirAttackLock = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
				self.KLK_DashLaunchCharging = false
			elseif self.KLK_AttackCount == 3 then
				self.KLK_IsDoingAirAttack = false
				self.KLK_CanGroundStomp = true
				self.KLK_AttackCount = 0
			end
		end)*/
		self:SequenceEvent("attackairsidekick",{24/101},function()
			self.KLK_IsDoingAirAttack = false
			self.KLK_AirAttackLock = false
			self:KLK_WeaponSwitch()
		end)
		self:SequenceEvent("attackpunchhookleft",{1/111},function()
			self.KLK_DashTime = CurTime() + 1
		end)
		self:SequenceEvent("dashair",{1/14},function()
			self:KLK_WeaponSwitch()
			self.KLK_DashGroundCharging = true
			self.KLK_DashTime = CurTime() + 0.5
		end)
		self:SequenceEvent("dashairslow",{1/14,13/14},function()
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirDash = true
				self.KLK_AirDashLock = false
				self.KLK_AttackCount = self.KLK_AttackCount + 1
				self.KLK_DashTime = CurTime() + 0.5
			else
				self.KLK_IsDoingAirDash = false
				self.KLK_AirDashLock = false
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairswingleft",{1/79,78/79},function()
			self.KLK_AttackRange = 100
			self.JumpAnimation = "attackairswingleftfallloop"
			self.KLK_IsDoingAirDash = false
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirAttack = true
				self.KLK_AirAttackLock = false
				self:Jump(100)
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self.KLK_IsDoingAirAttack = false
				self.KLK_AirAttackLock = true
				--self.KLK_CanGroundStomp = true
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairswingleftfallloop",{1/11},function()
			self.IdleAnimation = "attackairswingleftend"
			self.WalkAnimation = "attackairswingleftend"
			self.RunAnimation = "attackairswingleftend"
			self.KLK_IsDoingAirAttack = false
		end)
		self:SequenceEvent("attackairswingleftend",{40/47},function()
			self.IdleAnimation = "idle"
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				self.RunAnimation = "idletorun"
			end
		end)
		self:SequenceEvent("attackairslflswingleft4x",{18/152,101/152,151/152},function()
			self.KLK_AttackRange = 100
			self.JumpAnimation = "attackairsl4xfallloop"
			self.KLK_IsDoingAirDash = false
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirAttack = true
				self.KLK_AirAttackLock = false
				self:Jump(100)
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			elseif self.KLK_AttackCount == 1 then
				self.KLK_AirAttackLock = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self.KLK_IsDoingAirAttack = false
				--self.KLK_CanGroundStomp = true
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairsl4xfallloop",{1/1},function()
			self.IdleAnimation = "attackairsl4xend"
			self.WalkAnimation = "attackairsl4xend"
			self.RunAnimation = "attackairsl4xend"
			self.KLK_IsDoingAirAttack = false
		end)
		self:SequenceEvent("attackairsl4xend",{1/25},function()
			self.IdleAnimation = "idle"
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				self.RunAnimation = "idletorun"
			end
		end)
		self:SequenceEvent("attackswingoverheadheavy",{80/204},function()
			self:Jump(100)
			self:SetVelocity(self:GetUp()*250 +self:GetForward()*125)
		end)
		self:SequenceEvent("attackairjumpswingoverhead",{1/124,25/124},function()
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirAttack = false
				self:Jump(100)
				self:SetVelocity(self:GetUp()*250 +self:GetForward()*875)
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self.KLK_CanGroundStomp = true
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairswingoverheadlight",{1/68,65/68},function()
			self.JumpAnimation = "attackairswingoverheadfallloop"
			self.IdleAnimation = "attackairswingoverheadend"
			self.WalkAnimation = "attackairswingoverheadend"
			self.RunAnimation = "attackairswingoverheadend"
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirAttack = true
				self.KLK_AirAttackLock = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self.KLK_IsDoingAirAttack = false
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairswingoverheadheavy",{1/94,90/94},function()
			self.JumpAnimation = "attackairswingoverheadfallloop"
			self.IdleAnimation = "attackairswingoverheadend"
			self.WalkAnimation = "attackairswingoverheadend"
			self.RunAnimation = "attackairswingoverheadend"
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirAttack = true
				self.KLK_AirAttackLock = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self.KLK_IsDoingAirAttack = false
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairswingoverheadfallloop",{1/6},function()
			self.IdleAnimation = "attackairswingoverheadend"
			self.WalkAnimation = "attackairswingoverheadend"
			self.RunAnimation = "attackairswingoverheadend"
			self.KLK_IsDoingAirAttack = false
		end)
		self:SequenceEvent("attackairswingoverheadend",{1/59},function()
			self.IdleAnimation = "idle"
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				self.RunAnimation = "idletorun"
			end
		end)
		self:SequenceEvent("dashairdragon",{1/14,13/14},function()
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirDash = true
				self.KLK_AirDashLock = false
				self.KLK_AttackCount = self.KLK_AttackCount + 1
				self.KLK_DashTime = CurTime() + 0.5
			else
				self.KLK_IsDoingAirDash = false
				self.KLK_AirDashLock = false
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackairbackflipkick",{1/113,38/113},function()
			if self.KLK_AttackCount < 1 then
				self.KLK_IsDoingAirAttack = true
				self.KLK_AirAttackLock = true
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self.KLK_AirAttackLock = false
				self.KLK_IsDoingAirAttack = false
				self.KLK_CanGroundStomp = true
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("attackspinfull",{125/398},function()
			self.KLK_FanTime = CurTime() + 2.5
			self.KLK_ImmuneTime = CurTime() + 2.5
			self.KLK_DodgeTimer = CurTime() + 5
			self.KLK_AttackCount = 0
		end)
		self:SequenceEvent("dashairright",{1/30,20/30},function()
			if self.KLK_AttackCount < 1 then
				local Effect = EffectData()
				Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*50)
				util.Effect("PunchShockwave",Effect,true,true)
				self:Jump(100)
				self:SetVelocity(self:GetUp()*250)
				self.KLK_DashTime = CurTime() + 0.425
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self:SetVelocity(self:GetUp()*250)
				self.KLK_AttackCount = 0
			end
		end)
		self:SequenceEvent("dashairleft",{1/30,20/30},function()
			if self.KLK_AttackCount < 1 then
				local Effect = EffectData()
				Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*-50)
				util.Effect("PunchShockwave",Effect,true,true)
				self:Jump(100)
				self:SetVelocity(self:GetUp()*250)
				self.KLK_DashTime = CurTime() + 0.425
				self.KLK_AttackCount = self.KLK_AttackCount + 1
			else
				self:SetVelocity(self:GetUp()*250)
				self.KLK_AttackCount = 0
			end
		end)
	--
	
end
---------------------------------------------------------------------------------------------------------------------------------------------
	-- AI --
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_Dodging()

	if self.KLK_IsFlinching == true or self.KLK_ValorBursting == true or self.KLK_IsDefeated == true or self.KLK_IsKnocked == true or self.KLK_IsAttacking == true or self:KLK_IsBored() or self:Health() <= 0 then return end
	
	for k, EnemyProjectile in pairs(ents.FindByClass( "obj_*" )) do
		if EnemyProjectile:GetOwner() != self then
			if IsValid(EnemyProjectile.Owner) then
				if EnemyProjectile.Owner:GetOwner() != self then
					if EnemyProjectile:GetParent() != self then
						if EnemyProjectile != self then
							local phys = EnemyProjectile:GetPhysicsObject()
							if phys:IsValid() then
								if self:GetPos():Distance(phys:GetPos()) < (phys:GetVelocity():Length()/4) then
									if self:GetCooldown("NextRyukoEvade") <= 0 && self.KLK_IsFlinching == false && IsValid(self) then
										self.KLK_IsDodging = true
										self:SetCooldown("NextRyukoEvade",2.25)
										self:FaceInstant(EnemyProjectile:GetPos())
										if self:IsOnGround() then
											self:KLK_CICO(function()
												self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
													self.KLK_DashTime = CurTime() + 0.425
													if cycle > 0.65 && IsValid(self:GetEnemy()) then
														self.KLK_IsDodging = false
														return true
													elseif cycle > 0.95 then
														self.KLK_IsDodging = false
													end
												end)
											end)
										else
											self:KLK_CICO(function()
												self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
													self.KLK_DashTime = CurTime() + 0.425
													if cycle > 0.65 && IsValid(self:GetEnemy()) then
														self.KLK_IsDodging = false
														return true
													elseif cycle > 0.95 then
														self.KLK_IsDodging = false
													end
												end)
											end)
										end
									end
								end
							end
						end
					end
				end
			elseif !IsValid(EnemyProjectile.Owner) then
				if EnemyProjectile:GetParent() != self then
					if EnemyProjectile != self then
						local phys = EnemyProjectile:GetPhysicsObject()
						if phys:IsValid() then
							if self:GetPos():Distance(phys:GetPos()) < (phys:GetVelocity():Length()/4) then
								if self:GetCooldown("NextRyukoEvade") <= 0 && self.KLK_IsFlinching == false && IsValid(self) then
									self.KLK_IsDodging = true
									self:SetCooldown("NextRyukoEvade",2.25)
									self:FaceInstant(EnemyProjectile:GetPos())
									if self:IsOnGround() then
										self:KLK_CICO(function()
											self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
												self.KLK_DashTime = CurTime() + 0.425
												if cycle > 0.65 && IsValid(self:GetEnemy()) then
													self.KLK_IsDodging = false
													return true
												elseif cycle > 0.95 then
													self.KLK_IsDodging = false
												end
											end)
										end)
									else
										self:KLK_CICO(function()
											self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
												self.KLK_DashTime = CurTime() + 0.425
												if cycle > 0.65 && IsValid(self:GetEnemy()) then
													self.KLK_IsDodging = false
													return true
												elseif cycle > 0.95 then
													self.KLK_IsDodging = false
												end
											end)
										end)
									end
								end
							end
						end
					end
				end
			end
		end
	end
	for k, EnemyProjectile in pairs(ents.FindByClass( "rpg_missile" )) do
		if self:GetPos():Distance(EnemyProjectile:GetPos()) < 1250 then
			if self:GetCooldown("NextRyukoEvade") <= 0 && self.KLK_IsFlinching == false && IsValid(self) then
				self.KLK_IsDodging = true
				self:SetCooldown("NextRyukoEvade",2.25)
				self:FaceInstant(EnemyProjectile:GetPos())
				if self:IsOnGround() then
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				else
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				end
			end
		end
	end
	for k, EnemyProjectile in pairs(ents.FindByClass( "prop_combine_ball" )) do
		if self:GetPos():Distance(EnemyProjectile:GetPos()) < 500 then
			if self:GetCooldown("NextRyukoEvade") <= 0 && self.KLK_IsFlinching == false && IsValid(self) then
				self.KLK_IsDodging = true
				self:SetCooldown("NextRyukoEvade",2.25)
				self:FaceInstant(EnemyProjectile:GetPos())
				if self:IsOnGround() then
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				else
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				end
			end
		end
	end
	for k, EnemyProjectile in pairs(ents.FindByClass( "drg_roach_light*" )) do
		if self:GetPos():Distance(EnemyProjectile:GetPos()) <= 625 then
			if self:GetCooldown("NextRyukoEvade") <= 0 && self.KLK_IsFlinching == false && IsValid(self) then
				self.KLK_IsDodging = true
				self:SetCooldown("NextRyukoEvade",2.25)
				self:FaceInstant(EnemyProjectile:GetPos())
				if self:IsOnGround() then
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				else
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				end
			end
		end
	end
	for k, EnemyProjectile in pairs(ents.FindByClass( "npc_grenade_frag" )) do
		if self:GetPos():Distance(EnemyProjectile:GetPos()) < 250 then
			if self:GetCooldown("NextRyukoEvade") <= 0 && self.KLK_IsFlinching == false && IsValid(self) then
				self.KLK_IsDodging = true
				self:SetCooldown("NextRyukoEvade",2.25)
				self:FaceInstant(EnemyProjectile:GetPos())
				if self:IsOnGround() then
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				else
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				end
			end
		end
	end
	for k, EnemyProjectile in pairs(ents.FindByClass( "crossbow_bolt" )) do
		if self:GetPos():Distance(EnemyProjectile:GetPos()) < 1250 then
			if self:GetCooldown("NextRyukoEvade") <= 0 && self.KLK_IsFlinching == false && IsValid(self) then
				self.KLK_IsDodging = true
				self:SetCooldown("NextRyukoEvade",2.25)
				self:FaceInstant(EnemyProjectile:GetPos())
				if self:IsOnGround() then
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				else
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				end
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomThink()
	self.SightRange = math.huge
	self:Extinguish()
	if self:GetBodygroup(2) == 0 then
		self.SSDefaultOutline:SetNoDraw(false)
		self.SSDecapOutline:SetNoDraw(true)
	elseif self:GetBodygroup(2) == 1 then
		self.SSDefaultOutline:SetNoDraw(true)
		self.SSDecapOutline:SetNoDraw(false)
	elseif self:GetBodygroup(2) == 2 then
		self.SSDefaultOutline:SetNoDraw(true)
		self.SSDecapOutline:SetNoDraw(true)
	end
	if self.KLK_Checker < CurTime() then
		self.KLK_Checker = CurTime() + 1
		print(self.RunAnimation)
		for k, Purification in pairs(ents.FindByClass( "npc_drg_p*" )) do
			if Purification.Frightening == true or Purification.Frightening == false && Purification:Health() > 0 then
				Purification:NextThink(CurTime() + 2)
			end
		end
		/*print(self.IdleAnimation)
		print(self.WalkAnimation)
		print(self.RunAnimation)
		print(self.JumpAnimation)
		print(self.KLK_CurMeleeAnim)
		print(self.KLK_CurRangeAnim)
		print(self.KLK_BlockMode)
		print(self.KLK_IsFlinching)
		print(self.KLK_IsBlocking)
		print(self.KLK_IsKnocked)
		print(self.KLK_IsDodging)
		print(!IsValid(self:GetEnemy()))
		print(self:KLK_IsBored())
		print(self.KLK_ValorArmorBonus)
		print(self.KLK_ValorDamageBonus)
		print(self.KLK_ValorPoiseBonus)
		print(self.KLK_RyukoStamina)
		print(self.KLK_RyukoMeter)
		print(self.KLK_DisableMusic)*/
	end
	local waterdata   = {}
	local waterlength = Vector(0,0,2500)
	waterdata.start   = self:LocalToWorld(self:OBBCenter())
	waterdata.endpos  = waterdata.start + waterlength
	waterdata.filter  = self
	local sploosh = util.TraceLine(waterdata) 
	local splotchdata   = {}
	splotchdata.start   = sploosh.HitPos
	splotchdata.endpos  = waterdata.start - waterlength
	splotchdata.filter  = self
	splotchdata.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
	local waterline = util.TraceLine(splotchdata)
	if self:KLK_IsBored() && self.KLK_IsDefeated == false && GetConVar("ai_disabled"):GetBool() != true && self.KLK_TauntTime < CurTime() && self.KLK_IsAttacking == false && IsValid(self:GetEnemy()) && (self:GetPos():Distance(self:GetEnemy():GetPos()) <= 375) && self:IsOnGround() && self:IsLineOfSightClear(self:GetEnemy()) && self.KLK_BoredTimer < CurTime() then
		self.KLK_BoredTimer = CurTime() + 60
		self.IdleAnimation = "idle"
		self.JumpAnimation = "jumpstart"
		self.WalkAnimation = "idletowalk"
		self.RunAnimation = "idletorun"
		self:KLK_CICO(function()
			self.KLK_IsFlinching = false
			self:PlaySequenceAndMove("taunt3", 1, function(self,cycle)
				if cycle < 0.1 then
					self:FaceEnemy()
					self:KLK_ResetAttacks()
				end
				if cycle >= 0.99 then
					self.KLK_CombatTime = CurTime() + 60
				end
			end)
		end)
	end
	if self.KLK_PunchConnect == true then
		if self.KLK_PunchCount < 5 && self.KLK_PunchTime <= CurTime() then
			self.KLK_PunchTime = CurTime() + 0.025
			self.KLK_PunchCount = self.KLK_PunchCount + 1
			util.ScreenShake(self:GetPos(),15,15,math.Rand(0.5,0.5),1048)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*(50+self.KLK_PunchDist))
			Effect:SetAngles(self:GetAngles())
			util.Effect("PunchShockwave",Effect,true,true)
			self.KLK_PunchDist = self.KLK_PunchDist + 125
		end
	end
	if self.KLK_ShakeTime > CurTime() then
		util.ScreenShake(self:GetPos(),5,5,math.Rand(0.025,0.025),1048)
	end
	if self.KLK_BlockMode == true && self.KLK_PatienceTime < CurTime() then
		self.KLK_IsBlocking = false
		self.KLK_PatienceTime = CurTime() + 15
		if self.KLK_DisableValor == false then self:KLK_ValorBurst() end
	elseif self.KLK_BlockMode == false then
		self.KLK_PatienceTime = CurTime() + 15
	end
	if self.KLK_Synchronized == true or self.KLK_Transforming == true then
        ParticleEffectAttach( "kirakira_synchronize", 4, self, 0 )
		if self.KLK_ValorLevel >= 3 then
			ParticleEffectAttach( "kirakira_ryuko-3", 4, self, 0 )
			self:StartLoopingSound("KLK-IF.SpecialSFX.ValorAura")
			util.ScreenShake(self:GetPos(),1,1,math.Rand(0.125,0.125),256)
			if self:IsOnGround() then
				ParticleEffectAttach( "kirakira_ryuko-3_floor", 4, self, 0 )
				ParticleEffect("kirakira_synchdust", self:GetPos(), Angle(0,0,0), nil)
			end
		end
	end
	if self.KLK_RollTime >= CurTime() && self:IsOnGround() && self.KLK_NextRoll < CurTime() then
		self.KLK_NextRoll = CurTime() + 0.1
        if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_roll", waterline.HitPos, Angle(0,0,0), nil) else ParticleEffectAttach( "dust_roll", 4, self, 0 ) end
	end
	if self.KLK_RapidTime >= CurTime() && self:IsOnGround() then
        ParticleEffectAttach( "ryu_actionlines", 4, self, 0 )
		if self.KLK_NextRoll < CurTime() then
			if self:GetSequenceName(self:GetSequence()) == "attackdashstart" or self:GetSequenceName(self:GetSequence()) == "attackdashcharge" or self:GetSequenceName(self:GetSequence()) == "attackdashslashoverhead" or self:GetSequenceName(self:GetSequence()) == "attackfinisherslashfull" then
				local Effect = EffectData()
				Effect:SetAngles(self:GetAngles())
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
				ParticleEffectAttach( "klkdash_forward", 4, self, 0 )
			end
			self.KLK_NextRoll = CurTime() + 0.025
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_roll", waterline.HitPos, Angle(0,0,0), nil) else ParticleEffectAttach( "dust_roll", 4, self, 0 ) end
			util.ScreenShake(self:GetPos(),5,5,math.Rand(0.25,0.25),512)
		end
	end
	if self.KLK_FinishTime >= CurTime() && self.KLK_NextFinish < CurTime() then
		self.KLK_NextFinish = CurTime() + 0.75
		self.KLK_DashGroundCharging = true
	end
	if self.KLK_DashTime >= CurTime() then
        ParticleEffectAttach( "ryu_actionlines", 4, self, 0 )
		if self.KLK_NextRoll < CurTime() then
			self.KLK_NextRoll = CurTime() + 0.025
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_dash", waterline.HitPos, Angle(0,0,0), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_dash", 4, self, 0 ) end
			local Effect = EffectData()
			if self:GetSequenceName(self:GetSequence()) == "dodgeleft" or self:GetSequenceName(self:GetSequence()) == "rapiddashleft" then
				Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*-50)
				ParticleEffectAttach( "klkdash_right", 4, self, 0 )
				--ParticleEffect( "klkdash_right", self:GetPos() +self:GetUp()*5, self:GetAngles(), self )
			elseif self:GetSequenceName(self:GetSequence()) == "dashairleft" then
				Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*-50)
				ParticleEffectAttach( "klkdash_air_right", 4, self, 0 )
			elseif self:GetSequenceName(self:GetSequence()) == "dodgeright" or self:GetSequenceName(self:GetSequence()) == "rapiddashright" then
				Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*50)
				ParticleEffectAttach( "klkdash_left", 4, self, 0 )
			elseif self:GetSequenceName(self:GetSequence()) == "dashairright" then
				Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*50)
				ParticleEffectAttach( "klkdash_air_left", 4, self, 0 )
			elseif self:GetSequenceName(self:GetSequence()) == "dodgeback" or self:GetSequenceName(self:GetSequence()) == "rapiddashback" then
				Effect:SetAngles(self:GetAngles())
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*-50)
				ParticleEffectAttach( "klkdash_backward", 4, self, 0 )
			elseif self:GetSequenceName(self:GetSequence()) == "dashground" or self:GetSequenceName(self:GetSequence()) == "rapiddashfront" or self:GetSequenceName(self:GetSequence()) == "sprinttoidle" or self:GetSequenceName(self:GetSequence()) == "idletosprint" or self:GetSequenceName(self:GetSequence()) == "sprint" or self:GetSequenceName(self:GetSequence()) == "attackhopswingright" or self:GetSequenceName(self:GetSequence()) == "attackdashelbow" or self:GetSequenceName(self:GetSequence()) == "attackpunchhookleft" then
				Effect:SetAngles(self:GetAngles())
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
				ParticleEffectAttach( "klkdash_forward", 4, self, 0 )
			elseif self:GetSequenceName(self:GetSequence()) == "dashair" or self:GetSequenceName(self:GetSequence()) == "dashairslow" then
				Effect:SetAngles(self:GetAngles())
				Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
				ParticleEffectAttach( "klkdash_air_forward", 4, self, 0 )
			end
			util.Effect("PunchSonicBoom",Effect,true,true)
		end
	end
	if self.KLK_Charging >= CurTime() then
        ParticleEffectAttach( "ryu_actionlines", 4, self, 0 )
		if self.KLK_NextRoll < CurTime() then
			self.KLK_NextRoll = CurTime() + 0.25
			ParticleEffectAttach( "kirakirahelper_1", 4, self, 1 )
		end
	end
	if self.KLK_HitGroundLock == false then 
		if self.KLK_HitGroundCheck < CurTime() then
			self.KLK_HitGroundCheck = CurTime() + 0.2
			self.KLK_HitGroundLength = self:GetVelocity():Length()
			self.KLK_HitGroundVel = self:GetVelocity()
		end
		if self:IsOnGround() or self:WaterLevel() >= 1 then
			self.KLK_HitGroundLock = true
			if self.KLK_HitGroundLength >= 500 && self.KLK_FlyTime < CurTime() then
				self.KLK_FlyTime = CurTime() + 0.2
				if self:WaterLevel() >= 1 && waterline.Hit then
					self:EmitSound("KLK-IF.Movement.HeavySplash")
					ParticleEffect("klk_water_sharp", waterline.HitPos, Angle(0,0,0), nil)
				else 
					self:EmitSound("KLK-IF.Movement.HeavyStomp")
					ParticleEffect( "dust_sharp", self:GetPos() +self:GetUp()*5, self:GetAngles(), self )
				end
				util.ScreenShake(self:GetPos(),150,150,math.Rand(2,3),2048)
				if self.KLK_IsKnocked == true && self.KLK_IsDefeated == false then
					self:KLK_WeaponSwitch()
					self:EmitSound("KLK-IF.Ryuko.PainHeavy")
					self.KLK_IsFlinching = true
					self.KLK_IsKnocked = true
					self.KLK_HitGroundLock = false
					self.KLK_CanParry = false
					self.KLK_BlockMode = false
					self.KLK_IsBlocking = false
					self:KLK_ResetAttacks()
					self:Jump(100)
					if self.KLK_HitGroundVel.z <= 0 then
						self.KLK_HitGroundVertical = (self.KLK_HitGroundVel.z*-1)
					else
						self.KLK_HitGroundVertical = self.KLK_HitGroundVel.z
					end
					self:SetVelocity(Vector(self.KLK_HitGroundVel.x*0.75,self.KLK_HitGroundVel.y*0.75,self.KLK_HitGroundVertical*0.875))
					if (self.KLK_HitGroundVel.x+self.KLK_HitGroundVel.y)/2 > self.KLK_HitGroundVertical then
						self.KLK_RollTime = CurTime() + 1.75
						self.JumpAnimation = "wallsplatfallloop"
						self.IdleAnimation = "wallsplatdrop"
						self.WalkAnimation = "wallsplatdrop"
						self.RunAnimation = "wallsplatdrop"
						self:KLK_CICO(function()
							self.KLK_IsFlinching = false
							self:PlaySequenceAndMove("hitlaunchback", 1, function(self,cycle)
								self:FaceEnemy()
								if self.KLK_IsFlinching == true then 
									return true
								end
							end)
						end)
					else
						self.JumpAnimation = "hitlaunchupfallloop"
						self.IdleAnimation = "hitlaunchupdrop"
						self.WalkAnimation = "hitlaunchupdrop"
						self.RunAnimation = "hitlaunchupdrop"
						self:KLK_CICO(function()
							self.KLK_IsFlinching = false
							self:PlaySequenceAndMove("hitlaunchup", 1, function(self,cycle)
								self:FaceEnemy()
								if self.KLK_IsFlinching == true then 
									return true
								end
							end)
						end)
					end
				end
			else
				util.ScreenShake(self:GetPos(),15,15,math.Rand(0.5,0.75),1024)
				if self:WaterLevel() >= 1 && waterline.Hit then
					self:EmitSound("KLK-IF.Movement.LightSplash")
					ParticleEffect("klk_water_roll", waterline.HitPos, Angle(0,0,0), nil)
				else 
					self:EmitSound("KLK-IF.Movement.LightStomp")
					ParticleEffect( "dust_roll", self:GetPos() +self:GetUp()*5, self:GetAngles(), self )
				end
			end
		end
	end
	if self.KLK_HasTransformed == false && self.KLK_IsDefeated == false then
		self.KLK_HasTransformed = true
		self.KLK_ImmuneTime = CurTime() + 8
		self:KLK_CICO(function()
			self:AddFlags(FL_NOTARGET)
			if self.KLK_DisableMusic == false then
				self:EmitSound("KLK-IF.Ryuko.TransformTheme")
				self.KLK_MusicTimer = CurTime() + 8
			end
			self:PlaySequenceAndMove("ryukotransformland", 1, function(self,cycle)
				if cycle >= 0.9 then
					self:RemoveFlags(FL_NOTARGET)
				end
			end)
		end)
	end
	if self.KLK_IsKnocked == true && self.KLK_KnockedTime < CurTime() && self.KLK_DisableValor == false then
		self:KLK_ValorBurst()
	end
	if self.KLK_ValorTimer < CurTime() then
		self.KLK_ValorTimer = CurTime() + 0.25
		self.KLK_ValorHitLimit = 0
	end
	if !IsValid(self:GetEnemy()) && self.KLK_LastDetect < CurTime() && self.KLK_DisableValReset == false then
		if IsValid(self.ValorLights) then
			self.ValorLights:Remove()
		end
		self:SetSkin(0)
		self.KLK_Synchronized = false
		self.KLK_ValorArmorBonus = 1
		self.KLK_ValorRegenBonus = 1
		self.KLK_ValorLevel = 0
		self.GroundDodgeAnims = {"dodgeleft","dodgeright","dodgeback"}
		self.SideDodgeAnims = {"dodgeleft","dodgeright"}
		self.KLK_ThirteenthCombo_1 = "dashground"
		self.KLK_ThirteenthCombo_2 = "dodgeback"
		self.KLK_ThirteenthCombo_3 = "dodgeleft"
		self.KLK_ThirteenthCombo_4 = "dodgeright"
	end
	if self.KLK_FanTime > CurTime() then
		if self.KLK_FanCount < CurTime() then
			self.KLK_FanCount = CurTime() + 0.1
			self:SBFanningBlade()
		end
		if self.KLK_NextRoll < CurTime() && self:IsOnGround() then
			self.KLK_NextRoll = CurTime() + 0.025
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_dash", waterline.HitPos, Angle(0,0,0), nil) else ParticleEffectAttach( "dust_dash", 4, self, 0 ) end
		end
	end
	if self.KLK_DashAirCharging == true then
		self:AirTackle()
	end
	if self.KLK_DashGroundCharging == true then
		self:ShoulderTackle()
	end
	if self.KLK_DashLaunchCharging == true then
		self:LaunchingTackle()
	end
	if self.KLK_IsDoingAirAttack == true then
		if self:IsOnGround() then
			self:Jump(100)
		end
		if self.KLK_AirAttackLock == false && IsValid(self:GetEnemy()) then
			self.KLK_AAElevationDiff = ((self:GetEnemy():GetPos() +(self:GetEnemy():OBBCenter()*0.5)).z-self:GetPos().z)*5
			self.KLK_ADDistDiff = (self:GetPos():Distance(self:GetEnemy():GetPos()))*5
		else
			self.KLK_AAElevationDiff = 5
			self.KLK_AADistDiff = 25
		end
		self:SetVelocity(self:GetUp()*(self.KLK_AAElevationDiff) +self:GetForward()*self.KLK_AADistDiff)
	end
	if self.KLK_IsDoingAirDash == true then
		if self:IsOnGround() then
			self:Jump(250)
		end
		if self.KLK_AirDashLock == false && IsValid(self:GetEnemy()) then
			self.KLK_AirDashLock = true
			self.KLK_ADElevationDiff = ((self:GetEnemy():GetPos() +(self:GetEnemy():OBBCenter()*0.5)).z-self:GetPos().z)*5
			self.KLK_ADDistDiff = (self:GetPos():Distance(self:GetEnemy():GetPos()))*2.75
		end
		self:SetVelocity(self:GetUp()*self.KLK_ADElevationDiff +self:GetForward()*self.KLK_ADDistDiff)
	end
	if self.KLK_CanGroundStomp == true then
		if self.KLK_NextRoll < CurTime() then
			self.KLK_NextRoll = CurTime() + 0.25
			ParticleEffectAttach( "klkdash_down", 4, self, 0 )
			self.KLK_HitGroundLock = false
		end
		if !self:IsOnGround() then
			self:SetVelocity(self:GetUp()*-1000)
		else
			self.KLK_CanGroundStomp = false
		end
	end
	if IsValid(self:GetEnemy()) then
		if (self:GetEnemy().KLK_TrueControl == true && self.KLK_TrueControl != true) or (self:GetEnemy().KLK_TrueControl != true && self.KLK_TrueControl == true) then
			self:AddEntityRelationship( self:GetEnemy(), D_HT, 1 )
			self:GetEnemy():AddEntityRelationship( self, D_HT, 1 )
		elseif self:GetEnemy().KLK_TrueControl == true && self.KLK_TrueControl == true then
			self:GetEnemy():AddEntityRelationship( self, D_LI, 99 )
			self:AddEntityRelationship( self:GetEnemy(), D_LI, 99 )
		end
		self.KLK_Doppelgangers = false
		self.KLK_LastDetect = CurTime() + 10
		if !self:GetEnemy():IsOnGround() then
			self.KLK_RyukoEnemyVel = self:GetEnemy():GetVelocity():Length()
			self.RangeAttackRange = 12500
			self.ReachEnemyRange = ((self:GetEnemy():GetPos() +(self:GetEnemy():OBBCenter())).z-self:GetPos().z)*2.5
			self.MeleeAttackRange = (self:GetPos():Distance(self:GetEnemy():GetPos())/1)
		else
			self.KLK_RyukoEnemyVel = self:GetEnemy():GetGroundSpeedVelocity():Length()
			if self:GetPos():Distance(self:GetEnemy():GetPos()) <= 1000 then
				self.MeleeAttackRange = self:GetPos():Distance(self:GetEnemy():GetPos())
			end
			self.RangeAttackRange = 2000
			self.ReachEnemyRange = 25
		end
		if self:GetEnemy().ModelScale == 2.3 then
			if self.KLK_DisableRegen == false then
				self:SetHealthRegen(75)
			end
		else
			if self.KLK_DisableRegen == false then
				self:SetHealthRegen(110 * (1*(self.KLK_ValorRegenBonus)))
			end
		end
		if (self:GetEnemy():OBBMins():Distance(self:GetEnemy():OBBMaxs())/self:OBBMins():Distance(self:OBBMaxs()))*1.05 <= 1 then
			self.KLK_SizeDiff = 1
		else
			self.KLK_SizeDiff = (self:GetEnemy():OBBMins():Distance(self:GetEnemy():OBBMaxs())/self:OBBMins():Distance(self:OBBMaxs()))*1.05
		end
		if self.KLK_IsLosing == false && self.KLK_DisableMusic == false && self.KLK_IsDefeated == false then
			if self:GetEnemy().DrG_IsKLK == true then
				if self.KLK_MusicTimer < CurTime() && ((self:GetEnemy().KLK_ValorDamageBonus > self.KLK_ValorDamageBonus*2) or (self:Health() <= self:GetMaxHealth()*0.5 && self:GetEnemy():Health() >= self:GetEnemy():GetMaxHealth()*0.75)) then
					self.KLK_IsLosing = true
					self.KLK_MusicTimer = CurTime() + 55
					self:KLK_StopMusic()
					self:EmitSound("KLK-IF.Ryuko.LosingThemeShort")
				end
			else
				if self.KLK_MusicTimer < CurTime() && ((self:Health() <= self:GetMaxHealth()*0.5 && self:GetEnemy():Health() >= self:GetEnemy():GetMaxHealth()*0.75 && (self:GetEnemy():IsPlayer() or self:GetEnemy():GetMaxHealth() >= self:GetMaxHealth()*0.25))) then
					self.KLK_IsLosing = true
					self.KLK_MusicTimer = CurTime() + 107
					self:KLK_StopMusic()
					self:EmitSound("KLK-IF.Ryuko.LosingThemeLong")
				end
			end
		end
		if self:GetPos():Distance(self:GetEnemy():GetPos()) <= 1000 && self.KLK_IsDefeated == false then
			--self.MeleeAttackRange = self:GetPos():Distance(self:GetEnemy():GetPos())
			if self.KLK_IsKnocked == false && !self:KLK_IsBored() && self.KLK_ValorBursting == false && GetConVar("ai_disabled"):GetBool() != true && self.KLK_DodgeTimer < CurTime() && self.KLK_AttackTime < CurTime() && self.KLK_BlockMode == false /*&& self.KLK_RyukoStamina <= 50*/ && self:GetCooldown("NextRyukoDodge") <= 0 then
				if self:GetPos():Distance(self:GetEnemy():GetPos()) <= 125 && self:IsOnGround() && ((self.KLK_RyukoStamina <= 25 or (self:GetEnemy():GetPos().z-self:GetPos().z) >= -30) && self.KLK_IsAttacking == false) then
					self.KLK_IsDodging = true
					self.KLK_ImmuneTime = CurTime() + 0.75
					self:SetCooldown("NextRyukoDodge",math.random(1,3))
					self:KLK_CICO(function()
						self:PlaySequenceAndMove("dodgeback", 1, function(self,cycle)
							self:FaceEnemy()
							self.KLK_DashTime = CurTime() + 0.3
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				elseif self.KLK_IsAttacking == false && (self.KLK_RyukoEnemyVel > self:GetVelocity():Length()*3) && self:GetPos():Distance(self:GetEnemy():GetPos()) < self.KLK_RyukoEnemyVel then
					self.KLK_IsDodging = true
					self.KLK_ImmuneTime = CurTime() + 0.75
					self:SetCooldown("NextRyukoDodge",math.random(1,3))
					if self:IsOnGround() then
						self:KLK_CICO(function()
							self:PlaySequenceAndMove(table.Random(self.GroundDodgeAnims), 1, function(self,cycle)
								self.KLK_DashTime = CurTime() + 0.425
								if cycle > 0.65 && IsValid(self:GetEnemy()) then
									self.KLK_IsDodging = false
									return true
								elseif cycle > 0.95 then
									self.KLK_IsDodging = false
								end
							end)
						end)
					else
						self:KLK_CICO(function()
							self:PlaySequenceAndMove(table.Random(self.AirDodgeAnims), 1, function(self,cycle)
								self.KLK_DashTime = CurTime() + 0.425
								if cycle > 0.65 && IsValid(self:GetEnemy()) then
									self.KLK_IsDodging = false
									return true
								elseif cycle > 0.95 then
									self.KLK_IsDodging = false
								end
							end)
						end)
					end
				end
			end
		else
			self.MeleeAttackRange = 1000
		end
	elseif !IsValid(self:GetEnemy()) then
		if self.KLK_LastDetect <= CurTime() then 
			if self.KLK_CanPlayMusic == true then
				self.KLK_Doppelgangers = false
				for k, OtherRyukos in pairs(ents.GetAll()) do
					if IsValid(OtherRyukos) && OtherRyukos.DrG_IsKLK == true && OtherRyukos != self && OtherRyukos.KLK_DisableMusic == false then
						self.KLK_Doppelgangers = true
					end
				end
				if self.KLK_Doppelgangers == true then
					self.KLK_DisableMusic = true
				else
					self.KLK_DisableMusic = false
				end
			end
		end
		self.RangeAttackRange = 2000
		self.ReachEnemyRange = 25
		if self.KLK_DisableRegen == false then
			self:SetHealthRegen(110 * (1*(self.KLK_ValorRegenBonus)))
		end
		self.KLK_SizeDiff = 1
		self:KLK_ResetAttacks()
		self.KLK_IsLosing = false
	end
	if self:GetCooldown("RyukoStaminaRecharge") <= 0 && self.KLK_RyukoStamina < 100 then
		self:SetCooldown("RyukoStaminaRecharge",0.25)
		self.KLK_RyukoStamina = math.Clamp( self.KLK_RyukoStamina + 1, 0, 100 )
		if self.KLK_RyukoStamina >= 65 && self.KLK_CanReleaseSteam == false then
			self.KLK_CanReleaseSteam = true
			self.KLK_SteamRelease = false
		end
		if self.KLK_RyukoStamina < 50 && self.KLK_SteamRelease == false then
			self.KLK_CanReleaseSteam = false
			self.KLK_SteamRelease = true
			self:EmitSound("KLK-IF.SpecialSFX.SteamRelease")
			ParticleEffectAttach( "senketsu_steam_t_l", 4, self, 4 )
			ParticleEffectAttach( "senketsu_steam_t_r", 4, self, 5 )
			ParticleEffectAttach( "senketsu_steam_t_c", 4, self, 6 )
			ParticleEffectAttach( "senketsu_steam_b_l", 4, self, 7 )
			ParticleEffectAttach( "senketsu_steam_b_r", 4, self, 8 )
		end
	end
	if self:GetCooldown("RyukoParryRecharge") <= 0 && self.KLK_RyukoParry < 100 && self.KLK_Synchronized == true then
		self:SetCooldown("RyukoParryRecharge",1)
		--self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
	end
	if self.KLK_MeterCooldown <= CurTime() && self.KLK_MeterTimer <= CurTime() && self.KLK_RyukoMeter < 100 then
		self.KLK_MeterTimer = CurTime() + 1
		self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 1, 0, 100 )
	end
	self:KLK_Dodging()
	if IsValid(self:GetEnemy()) then
		local yawang = (self:GetEnemy():WorldSpaceCenter() - self:WorldSpaceCenter()):Angle()
		local pitchang = (self:WorldSpaceCenter() - self:GetEnemy():WorldSpaceCenter()):Angle()
		self:SetPoseParameter("aim_yaw", math.AngleDifference(yawang.y, self:GetAngles().y))
		self:SetPoseParameter("aim_pitch", math.AngleDifference(yawang.p, self:GetAngles().p))
	else
		self:SetPoseParameter("aim_yaw", 0)
		self:SetPoseParameter("aim_pitch", 0)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnRangeAttack(enemy)
	if IsValid(enemy) && !enemy:IsOnGround() then
		if self.KLK_BlockMode == true or self.KLK_IsFlinching == true or self.KLK_IsBlocking == true or self.KLK_IsKnocked == true or self.KLK_IsDodging == true or !IsValid(self:GetEnemy()) then return end
		if self:GetEnemy():GetPos():Distance(self:GetPos()) <= ((self.ReachEnemyRange*2)*self.KLK_SizeDiff) then
			self.KLK_IsAttacking = true
			self.KLK_CanParry = true
			self.KLK_CanTaunt = true
			self.KLK_AttackTime = CurTime() + 3
			self.KLK_AttackCount = 0
			self:PlaySequenceAndMove(self.KLK_CurRangeAnim, 1, function(self, cycle)
				if cycle >= 0.95 then
					self.KLK_IsAttacking = false
					self:KLK_ResetAttacks()
				end
				if cycle < 0.375 then
					self:FaceEnemy()
				end
			end)
			if self.KLK_BlockMode == false && self.KLK_IsFlinching == false && self.KLK_IsBlocking == false && self.KLK_IsKnocked == false && self.KLK_IsDodging == false && self.KLK_TauntTime <= CurTime() then
				if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
					self.WalkAnimation = "idletowalk"
					self.RunAnimation = "idletowalk"
				else
					self.WalkAnimation = "idletowalk"
					if self.KLK_ValorLevel > 0 then
						self.RunAnimation = "idletosprint"
					else
						self.RunAnimation = "idletorun"
					end
				end
			end
		end
	return end
	if self.KLK_DashAirCharging == true or self.KLK_IsKnocked == true or self.KLK_IsFlinching == true or self.KLK_TauntTime > CurTime() or self.KLK_BlockMode == true then return end
	if not self:IsInRange(enemy, 1500) && self.JumpAnimation == "jumpstart" then
		self.KLK_HasJumped = true
		self:Leap(enemy, 750)
		self:PauseCoroutine(0.25)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnMeleeAttack(enemy)
	if self:KLK_IsBored() or self.KLK_BlockMode == true or self.KLK_IsFlinching == true or self.KLK_IsBlocking == true or self.KLK_IsKnocked == true or self.KLK_IsDodging == true or !IsValid(self:GetEnemy()) then return end
	if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) then
		self.KLK_IsAttacking = true
		self.KLK_CanParry = true
		self.KLK_CanTaunt = true
		self.KLK_AttackTime = CurTime() + 3
		self.KLK_AttackCount = 0
		self:PlaySequenceAndMove(self.KLK_CurMeleeAnim, 1, function(self, cycle)
			if self.KLK_CurMeleeAnim == "dodgeleft" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if self.MeleeAttackRange <= 1250 && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(6)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_2
						elseif NextChange == 3 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
						elseif NextChange == 4 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
						else
							self.KLK_Combo_Cycle = 0.3
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "rapiddashleft" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if self.MeleeAttackRange <= 1250 && self.KLK_RyukoStamina > 5 then
						local NextChange = math.random(14)
						if NextChange == 1 or NextChange == 2 or NextChange == 3 or NextChange == 4 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1500
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						elseif NextChange == 5 or NextChange == 6 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_2
						elseif NextChange == 7 or NextChange == 8 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
						elseif NextChange == 9 or NextChange == 10 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
						else
							self.KLK_Combo_Cycle = 0.3
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "dodgeright" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if self.MeleeAttackRange <= 1250 && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(6)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_2
						elseif NextChange == 3 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
						elseif NextChange == 4 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
						else
							self.KLK_Combo_Cycle = 0.3
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "rapiddashright" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if self.MeleeAttackRange <= 1250 && self.KLK_RyukoStamina > 5 then
						local NextChange = math.random(14)
						if NextChange == 1 or NextChange == 2 or NextChange == 3 or NextChange == 4 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1500
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						elseif NextChange == 5 or NextChange == 6 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_2
						elseif NextChange == 7 or NextChange == 8 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
						elseif NextChange == 9 or NextChange == 10 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
						else
							self.KLK_Combo_Cycle = 0.3
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "dodgeback" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if self.MeleeAttackRange <= 2500 && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(6)
						if NextChange == 1 then
							self.KLK_IsDoingAirDash = false
							self.KLK_IsDoingAirAttack = false
							self.KLK_AirDashLock = false
							self.KLK_AirAttackLock = false
							self.KLK_ShouldJump = true
							self.KLK_Combo_Cycle = 0.95
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_1
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						elseif NextChange == 3 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
						elseif NextChange == 4 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
						else
							self.KLK_Combo_Cycle = 0.3
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "rapiddashback" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if self.MeleeAttackRange <= 2500 && self.KLK_RyukoStamina > 5 then
						local NextChange = math.random(14)
						if NextChange == 1 or NextChange == 2 then
							self.KLK_IsDoingAirDash = false
							self.KLK_IsDoingAirAttack = false
							self.KLK_AirDashLock = false
							self.KLK_AirAttackLock = false
							self.KLK_ShouldJump = true
							self.KLK_Combo_Cycle = 0.95
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_1
						elseif NextChange == 3 or NextChange == 4 or NextChange == 5 or NextChange == 6 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 2000
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						elseif NextChange == 7 or NextChange == 8 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
						elseif NextChange == 9 or NextChange == 10 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
						else
							self.KLK_Combo_Cycle = 0.3
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "dashground" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(3)
						if NextChange == 1 then
							self.KLK_IsDoingAirAttack = false
							self.KLK_IsDoingAirDash = false
							self.KLK_Combo_Cycle = 0.4
							self.KLK_Combo_Range = 125
							self.KLK_CurMeleeAnim = self.KLK_FirstCombo_1
						elseif NextChange == 2 then
							self.KLK_IsDoingAirAttack = false
							self.KLK_IsDoingAirDash = false
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_SecondCombo_1
						else
							self.KLK_IsDoingAirAttack = false
							self.KLK_IsDoingAirDash = false
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 75
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "rapiddashfront" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 5 then
						local NextChange = math.random(14)
						if NextChange == 1 then
							self.KLK_IsDoingAirAttack = false
							self.KLK_IsDoingAirDash = false
							self.KLK_Combo_Cycle = 0.4
							self.KLK_Combo_Range = 125
							self.KLK_CurMeleeAnim = self.KLK_FirstCombo_1
						elseif NextChange == 2 then
							self.KLK_IsDoingAirAttack = false
							self.KLK_IsDoingAirDash = false
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_SecondCombo_1
						elseif NextChange == 3 then
							self.KLK_IsDoingAirAttack = false
							self.KLK_IsDoingAirDash = false
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 75
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_1
						elseif NextChange == 4 then
							self.KLK_IsDoingAirDash = false
							self.KLK_IsDoingAirAttack = false
							self.KLK_AirDashLock = false
							self.KLK_AirAttackLock = false
							self.KLK_ShouldJump = true
							self.KLK_Combo_Cycle = 0.95
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_1
						elseif NextChange == 5 or NextChange == 6 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						elseif NextChange == 7 or NextChange == 8 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
						elseif NextChange == 9 or NextChange == 10 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
						else
							self.KLK_Combo_Cycle = 0.3
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_2
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == "dashairleft" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.95
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_EighthCombo_3
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle < 0.05 then
					self.KLK_DashTime = CurTime() + 0.45
				end
			elseif self.KLK_CurMeleeAnim == "dashairright" then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.95
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_EighthCombo_3
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle < 0.05 then
					self.KLK_DashTime = CurTime() + 0.45
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FirstCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.65
						self.KLK_Combo_Range = 125
						self.KLK_CurMeleeAnim = self.KLK_FirstCombo_2
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FirstCombo_2 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(3)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 375
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						else
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_FirstCombo_3
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FirstCombo_3 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						if self.KLK_ValorLevel >= 3 && self.KLK_DisableFinishers == false then
							self.KLK_Combo_Cycle = 0.775
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_3
						else
							local DecapChance = math.random(5)
							if DecapChance == 1 && (self.KLK_RyukoMeter >= 50 && self.KLK_DisableSpecials == false) then
								self.KLK_ImmuneTime = CurTime() + 6.5
								self.KLK_Combo_Cycle = 1
								self.KLK_Combo_Range = 1250
								self.KLK_CurMeleeAnim = self.KLK_FourthCombo_3
							else
								local NextChange = math.random(4)
								if NextChange == 1 then
									self.KLK_Combo_Cycle = 0.4
									self.KLK_Combo_Range = 200
									self.KLK_CurMeleeAnim = self.KLK_FirstCombo_4
								elseif NextChange == 2 then
									self.KLK_Combo_Cycle = 0.4
									self.KLK_Combo_Range = 125
									self.KLK_CurMeleeAnim = self.KLK_SecondCombo_2
								elseif NextChange == 3 then
									self.KLK_Combo_Cycle = 0.725
									self.KLK_Combo_Range = 175
									self.KLK_CurMeleeAnim = self.KLK_SecondCombo_3
								elseif NextChange == 4 then
									self.KLK_Combo_Cycle = 0.5
									self.KLK_Combo_Range = 500
									self.KLK_CurMeleeAnim = self.KLK_SecondCombo_4
								end
							end
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FirstCombo_4 then
				if IsValid(self:GetEnemy()) && cycle >= 0.9 then
					self:KLK_ResetAttacks()
				end
				if cycle <= 0.1 then
					self.KLK_ImmuneTime = CurTime() + 1.5
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SecondCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(2)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.65
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_FirstCombo_2
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_4
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SecondCombo_2 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && (self.KLK_RyukoMeter >= 50 && self.KLK_DisableSpecials == false) then
						self.KLK_ImmuneTime = CurTime() + 4.25
						self.KLK_Combo_Cycle = 0.95
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_5
						self.KLK_DashGroundCharging = true
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle <= 0.1 then
					self.KLK_ImmuneTime = CurTime() + 1.5
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SecondCombo_3 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(5)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.85
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_2
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.9
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_3
						elseif NextChange == 3 then
							self.KLK_Combo_Cycle = 1
							self.KLK_Combo_Range = 750
							self.KLK_CurMeleeAnim = self.KLK_TenthCombo_3
						else
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_5
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SecondCombo_4 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && (self.KLK_RyukoMeter >= 50 && self.KLK_DisableSpecials == false) then
						local NextChange = math.random(2)
						if NextChange == 1 then
							self.KLK_ImmuneTime = CurTime() + 4.25
							self.KLK_Combo_Cycle = 0.95
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_5
							self.KLK_DashGroundCharging = true
						else
							self.KLK_ImmuneTime = CurTime() + 6.5
							self.KLK_Combo_Cycle = 1
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_FourthCombo_3
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle <= 0.1 then
					self.KLK_ImmuneTime = CurTime() + 1.5
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_ThirdCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(3)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.6
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_7
						else
							self.KLK_Combo_Cycle = 0.55
							self.KLK_Combo_Range = 125
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_2
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle <= 0.1 then
					self.KLK_ImmuneTime = CurTime() + 1.5
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_ThirdCombo_2 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= (((self.KLK_Combo_Range*5) * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(2)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.65
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_FifthCombo_1
						elseif NextChange == 2 then
							self.KLK_DashAirCharging = true
							self.KLK_Combo_Cycle = 0.9
							self.KLK_Combo_Range = 2500
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_3
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_ThirdCombo_3 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(2)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.65
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_FifthCombo_1
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_4
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle < 0.1 then
					self.KLK_DashTime = CurTime() + 1
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_ThirdCombo_4 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(4)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_FourthCombo_1
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.4
							self.KLK_Combo_Range = 125
							self.KLK_CurMeleeAnim = self.KLK_FourthCombo_2
						else
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_5
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle < 0.1 then
					self.KLK_DashTime = CurTime() + 0.5
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_ThirdCombo_5 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(4)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 500
							self.KLK_CurMeleeAnim = self.KLK_FourthCombo_1
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.55
							self.KLK_Combo_Range = 125
							self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_2
						else
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_FirstCombo_3
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FourthCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= (((self.KLK_Combo_Range*2) * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.75
						self.KLK_Combo_Range = 500
						self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_4
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle <= 0.1 then
					self.KLK_ImmuneTime = CurTime() + 1.5
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FourthCombo_2 then
				if IsValid(self:GetEnemy()) && cycle >= 0.9 then
					self:KLK_ResetAttacks()
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FourthCombo_3 then
				if IsValid(self:GetEnemy()) && cycle >= 0.9 then
					self:KLK_ResetAttacks()
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_FifthCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local DecapChance = math.random(3)
						if DecapChance == 1 && (self.KLK_RyukoMeter >= 50 && self.KLK_DisableSpecials == false) then
							self.KLK_ImmuneTime = CurTime() + 6.5
							self.KLK_Combo_Cycle = 1
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_FourthCombo_3
						else
							local NextChange = math.random(2)
							if NextChange == 1 then
								self.KLK_Combo_Cycle = 0.65
								self.KLK_Combo_Range = 125
								self.KLK_CurMeleeAnim = self.KLK_FirstCombo_2
							else
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_FourthCombo_1
							end
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
				if cycle <= 0.05 then
					self.KLK_DashTime = CurTime() + 0.75
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SixthCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						if self.KLK_ValorLevel > 0 then
							local NextChange = math.random(14)
							if NextChange == 1 or NextChange == 2 or NextChange == 3 or NextChange == 4 then
								self.KLK_Combo_Cycle = 0.3
								self.KLK_Combo_Range = 2000
								self.KLK_CurMeleeAnim = self.KLK_SixthCombo_2
							elseif NextChange == 5 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 2000
								self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_1
								self.KLK_DashAirCharging = true
							elseif NextChange == 6 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_4
							elseif NextChange == 7 or NextChange == 8 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
							elseif NextChange == 9 or NextChange == 10 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
							elseif NextChange == 11 or NextChange == 12 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_1
							else
								self.KLK_Combo_Cycle = 0.5
								self.KLK_Combo_Range = 1250
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_2
							end
						else
							local NextChange = math.random(6)
							if NextChange == 1 then
								self.KLK_Combo_Cycle = 0.3
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_SixthCombo_2
							elseif NextChange == 2 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_1
								self.KLK_DashAirCharging = true
							elseif NextChange == 3 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_4
							elseif NextChange == 4 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
							elseif NextChange == 5 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
							else
								self.KLK_Combo_Cycle = 0.3
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_SixthCombo_2
							end
						end
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SixthCombo_2 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						if self.KLK_ValorLevel > 0 then
							local NextChange = math.random(8)
							if NextChange == 1 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_4
							elseif NextChange == 2 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_1
							elseif NextChange == 3 or NextChange == 4 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
							elseif NextChange == 5 or NextChange == 6 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
							else
								self.KLK_Combo_Cycle = 0.5
								self.KLK_Combo_Range = 1250
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_2
							end
						else
							local NextChange = math.random(4)
							if NextChange == 1 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_4
							elseif NextChange == 2 then
								self.KLK_Combo_Cycle = 0.75
								self.KLK_Combo_Range = 500
								self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_1
							elseif NextChange == 3 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_3
							elseif NextChange == 4 then
								self.KLK_Combo_Cycle = 0.45
								self.KLK_Combo_Range = 2500
								self.KLK_CurMeleeAnim = self.KLK_ThirteenthCombo_4
							end
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SixthCombo_3 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 1
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_SixthCombo_4
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SixthCombo_4 then
				if IsValid(self:GetEnemy()) && cycle >= 0.99 then
					self:KLK_ResetAttacks()
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SeventhCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && (self.KLK_RyukoMeter >= 50 && self.KLK_DisableSpecials == false) then
						self.KLK_ImmuneTime = CurTime() + 6.5
						self.KLK_Combo_Cycle = 1
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_FourthCombo_3
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SeventhCombo_2 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(2)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.6
							self.KLK_Combo_Range = 1750
							self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_4
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 1
							self.KLK_Combo_Range = 750
							self.KLK_CurMeleeAnim = self.KLK_TenthCombo_3
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SeventhCombo_3 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.6
						self.KLK_Combo_Range = 1750
						self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_4
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SeventhCombo_4 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && (self.KLK_RyukoMeter >= 50 && self.KLK_DisableSpecials == false) then
						self.KLK_ImmuneTime = CurTime() + 4.25
						self.KLK_Combo_Cycle = 0.95
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_5
						self.KLK_DashGroundCharging = true
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SeventhCombo_5 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= (self.KLK_Combo_Range * self.KLK_SizeDiff)) then
						self.KLK_Combo_Cycle = 0.375
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_6
						self.KLK_DashGroundCharging = true
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SeventhCombo_6 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= (self.KLK_Combo_Range * self.KLK_SizeDiff)) then
						self.KLK_Combo_Cycle = 1
						self.KLK_Combo_Range = 375
						self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_7
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_SeventhCombo_7 then
				if cycle >= self.KLK_Combo_Cycle then
					self:KLK_ResetAttacks()
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_EighthCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.95
						self.KLK_Combo_Range = 1250
						self.KLK_CurMeleeAnim = self.KLK_EighthCombo_2
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_EighthCombo_2 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(5)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = "dashairleft"
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.75
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = "dashairright"
						else
							self.KLK_Combo_Cycle = 0.95
							self.KLK_Combo_Range = 1250
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_3
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_EighthCombo_3 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= (((self.KLK_Combo_Range*2) * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && !self:IsOnGround() then
						self.KLK_Combo_Cycle = 0.95
						self.KLK_Combo_Range = 750
						self.KLK_CurMeleeAnim = self.KLK_EighthCombo_4
						self.KLK_IsAttacking = false
						self.KLK_DashAirCharging = true
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_EighthCombo_4 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= (((self.KLK_Combo_Range*2) * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && !self:IsOnGround() then
						local NextChange = math.random(5)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.85
							self.KLK_Combo_Range = 375
							self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_2
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.65
							self.KLK_Combo_Range = 750
							self.KLK_CurMeleeAnim = self.KLK_TenthCombo_1
						else
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_5
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
						self.KLK_IsDoingAirAttack = false
						self.KLK_IsDoingAirDash = false
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_EighthCombo_5 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && !self:GetEnemy():IsOnGround() then
						local NextChange = math.random(3)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.85
							self.KLK_Combo_Range = 375
							self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_2
						else
							self.KLK_Combo_Cycle = 0.875
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_6
						end
						self.KLK_IsAttacking = false
						return true
					else
						self.KLK_IsAttacking = false
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_EighthCombo_6 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.6
						self.KLK_Combo_Range = 250
						self.KLK_CurMeleeAnim = self.KLK_EighthCombo_7
						self.KLK_IsDoingAirAttack = false
						self.KLK_IsDoingAirDash = false
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_EighthCombo_7 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(2)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.45
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_FirstCombo_3
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 375
							self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_NinthCombo_1 then
				if IsValid(self:GetEnemy()) && cycle >= 0.9 then
					self:KLK_ResetAttacks()
				end
				if cycle <= 0.1 then
					self.KLK_ImmuneTime = CurTime() + 1.5
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_TenthCombo_1 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= (((self.KLK_Combo_Range*2) * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						self.KLK_Combo_Cycle = 0.95
						self.KLK_Combo_Range = 750
						self.KLK_CurMeleeAnim = self.KLK_TenthCombo_2
						self.KLK_IsDoingAirDash = true
						self.KLK_DashAirCharging = true
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_TenthCombo_2 then
				if IsValid(self:GetEnemy()) && cycle > self.KLK_Combo_Cycle then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 then
						local NextChange = math.random(3)
						if NextChange == 1 then
							self.KLK_Combo_Cycle = 0.85
							self.KLK_Combo_Range = 375
							self.KLK_CurMeleeAnim = self.KLK_SeventhCombo_2
						elseif NextChange == 2 then
							self.KLK_Combo_Cycle = 1
							self.KLK_Combo_Range = 750
							self.KLK_CurMeleeAnim = self.KLK_TenthCombo_3
						else
							self.KLK_Combo_Cycle = 0.5
							self.KLK_Combo_Range = 250
							self.KLK_CurMeleeAnim = self.KLK_EighthCombo_5
						end
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_TenthCombo_3 then
				if IsValid(self:GetEnemy()) && cycle >= 0.9 then
					self:KLK_ResetAttacks()
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_TwelfthCombo_1 then
				if cycle > self.KLK_Combo_Cycle && cycle <= 0.7 then
					if (self.MeleeAttackRange <= ((self.KLK_Combo_Range * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) && self.KLK_RyukoStamina > 15 && self.KLK_FanTime >= CurTime() then
						self.KLK_Combo_Cycle = 1
						self.KLK_Combo_Range = 750
						self.KLK_CurMeleeAnim = self.KLK_TwelfthCombo_2
						self.KLK_IsAttacking = false
						return true
					else
						self:KLK_ResetAttacks()
					end
				end
			elseif self.KLK_CurMeleeAnim == self.KLK_TwelfthCombo_2 then
				if IsValid(self:GetEnemy()) && cycle >= 0.9 then
					self:KLK_ResetAttacks()
				end
				if cycle <= 0.1 then
					self.KLK_ImmuneTime = CurTime() + 2
				end
			end
			if cycle < 0.375 && self.KLK_FanTime < CurTime() then
				self:FaceEnemy()
			elseif self.KLK_FanTime >= CurTime() then
				self:FaceEnemy()
			end
		end)
		if self.KLK_BlockMode == false && self.KLK_IsFlinching == false && self.KLK_IsBlocking == false && self.KLK_IsKnocked == false && self.KLK_IsDodging == false && self.KLK_TauntTime <= CurTime() then
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.WalkAnimation = "idletowalk"
				self.RunAnimation = "idletowalk"
			else
				self.WalkAnimation = "idletowalk"
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "idletosprint"
				else
					self.RunAnimation = "idletorun"
				end
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_IsBored()
	if (self.KLK_TookDmgTime + 60) < CurTime() && self.KLK_CombatTime < CurTime() then
		return true
	elseif (self.KLK_TookDmgTime + 30) >= CurTime() or self.KLK_CombatTime >= CurTime() then
		return false
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_CanAttack()
	if IsValid(self:GetEnemy()) then
		local AttackData = {}
		AttackData.start = self:GetPos() + Vector(0,0,25)
		AttackData.endpos = self:GetEnemy():GetPos() + Vector(0,0,25)
		AttackData.filter = {self}
		local AttackDataTrace = util.TraceLine(AttackData)
		if AttackDataTrace.Hit && AttackDataTrace.Entity == self:GetEnemy() && AttackDataTrace.Entity:GetClass() == self:GetEnemy():GetClass() then
			return true
		else
			return false
		end
	else
		return false
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:ResetThemAll()
	self.KLK_BlockMode = false
	self.KLK_IsBlocking = false
	self.KLK_IsFlinching = false
	self.KLK_IsKnocked = false
	self.KLK_KnockedLock = false
	self.KLK_IsAttacking = false
	self.KLK_IsDodging = false
	self.KLK_DashAirCharging = false
	self.KLK_DashGroundCharging = false
	self.KLK_DashLaunchCharging = false
	self.KLK_IsDoingAirAttack = false
	self.KLK_AirAttackLock = false
	self.KLK_IsDoingAirDash = false
	self.KLK_AirDashLock = false
	self.KLK_CanGroundStomp = false
	self:KLK_WeaponSwitch()
	self:SetCollisionGroup(9)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_ResetAttacks()
	if (self.KLK_IsDefeated == true or self:Health() <= 0) then return end
	if self.KLK_BlockMode == false && self.KLK_IsKnocked == false then
		if IsValid(self:GetEnemy()) then
			self.IdleAnimation = "idle"
		end
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		if self.KLK_IsDoingAirAttack == false && self.KLK_IsDoingAirDash == false then
			--self.JumpAnimation = "jumpstart"
		end
	end
	if self.KLK_IsDoingAirAttack == false && self.KLK_CanGroundStomp == false && self.KLK_IsAttacking == false then
		self.KLK_AttackCount = 0
	end
	self.KLK_DashAirCharging = false
	self:SetCollisionGroup(9)
	local ResetChange = math.random(9) -- 10 --
	self.KLK_ShearCounter = 0
	if ResetChange == 1 then
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		self.KLK_Combo_Cycle = 0.4
		self.KLK_Combo_Range = 125
		self.KLK_CurMeleeAnim = self.KLK_FirstCombo_1
	elseif ResetChange == 2 then
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		self.KLK_Combo_Cycle = 0.5
		self.KLK_Combo_Range = 250
		self.KLK_CurMeleeAnim = self.KLK_SecondCombo_1
	elseif ResetChange == 3 then
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		self.KLK_Combo_Cycle = 0.75
		self.KLK_Combo_Range = 75
		self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_1
	elseif ResetChange == 4 then
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		local RangeAttack = math.random(5)
		if RangeAttack == 1 then -- CHARGED ATTACK
			self.KLK_Combo_Cycle = 0.75
			self.KLK_Combo_Range = 375
			self.KLK_CurMeleeAnim = self.KLK_NinthCombo_1
		else -- REGULAR ATTACK
			self.KLK_Combo_Cycle = 0.5
			self.KLK_Combo_Range = 500
			self.KLK_CurMeleeAnim = self.KLK_SixthCombo_1
		end
	elseif ResetChange == 5 then
		if self:IsOnGround() && IsValid(self:GetEnemy()) && self:GetPos():Distance(self:GetEnemy():GetPos()) >= (450 * (1 + self:GetVelocity():Length()/1000)) then
			self.KLK_IsDoingAirDash = false
			self.KLK_IsDoingAirAttack = false
			self.KLK_AirDashLock = false
			self.KLK_AirAttackLock = false
			self.KLK_ShouldJump = true
			self.KLK_Combo_Cycle = 0.95
			self.KLK_Combo_Range = 750
			self.KLK_CurMeleeAnim = self.KLK_EighthCombo_1
		else
			self.KLK_Combo_Cycle = 0.4
			self.KLK_Combo_Range = 125
			self.KLK_CurMeleeAnim = self.KLK_FirstCombo_1
		end
	elseif ResetChange == 6 then -- DODGE
		local DodgeRand = table.Random(self.SideDodgeAnims)
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		self.KLK_Combo_Cycle = 0.45
		self.KLK_Combo_Range = 500
		self.KLK_CurMeleeAnim = DodgeRand
	elseif ResetChange == 7 then
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		if (self.KLK_RyukoMeter >= 50 && self.KLK_DisableSpecials == false) then -- SPIN TO WIN
			self.KLK_Combo_Cycle = 0.675
			self.KLK_Combo_Range = 250
			self.KLK_CurMeleeAnim = self.KLK_TwelfthCombo_1
		else
			self.KLK_Combo_Cycle = 0.4
			self.KLK_Combo_Range = 125
			self.KLK_CurMeleeAnim = self.KLK_FirstCombo_1
		end
	elseif ResetChange == 8 then
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		if (self.KLK_RyukoMeter >= 50 && self.KLK_DisableValor == false) && self.KLK_IsKnocked == false && self:Health() <= self:GetMaxHealth()*0.75 && IsValid(self:GetEnemy()) then -- VALOR BURST
			self:KLK_ValorBurst()
		else
			self.KLK_IsDoingAirAttack = false
			self.KLK_IsDoingAirDash = false
			self.KLK_Combo_Cycle = 0.4
			self.KLK_Combo_Range = 125
			self.KLK_CurMeleeAnim = self.KLK_FirstCombo_1
		end
	elseif ResetChange == 9 then
		self.KLK_IsDoingAirAttack = false
		self.KLK_IsDoingAirDash = false
		self.KLK_Combo_Cycle = 0.55
		self.KLK_Combo_Range = 125
		self.KLK_CurMeleeAnim = self.KLK_ThirdCombo_2
	elseif ResetChange == 10 then -- ATTACK TESTER
		self.KLK_Combo_Cycle = 0.775
		self.KLK_Combo_Range = 250
		self.KLK_CurMeleeAnim = self.KLK_SixthCombo_3
	end
	if self.KLK_RangeCooldown <= CurTime() then
		if self.KLK_RangeHeavyTime <= CurTime() then
			self.KLK_CurRangeAnim = "attackrangeheavy"
			self.KLK_RangeCooldown = CurTime() + math.random(3,9)
			self.KLK_RangeHeavyTime = CurTime() + math.random(27,81)
		else
			if self.KLK_RangeMediumTime <= CurTime() then
				self.KLK_CurRangeAnim = "attackrangemedium"
				self.KLK_RangeCooldown = CurTime() + math.random(2,6)
				self.KLK_RangeMediumTime = CurTime() + math.random(9,27)
			else
				if self.KLK_RangeLightTime <= CurTime() then
					self.KLK_CurRangeAnim = "attackrangelight"
					self.KLK_RangeCooldown = CurTime() + math.random(1,3)
					self.KLK_RangeLightTime = CurTime() + math.random(3,9)
				end
			end
		end
	end
	if self.KLK_CanTaunt == true && self:Health() >= 5500 && self.KLK_IsDefeated == false && self:IsOnGround() && self.KLK_IsBlocking == false && self.KLK_IsKnocked == false && self.KLK_JetTime <= CurTime() then
		self.KLK_CanTaunt = false
		local TauntChance = math.random(3)
		if (TauntChance == 1 or self.KLK_RyukoStamina <= 25 /*or !IsValid(self:GetEnemy())*/) && self.KLK_TookDmgTime <= CurTime() then
			self.IdleAnimation = "idle"
			self.JumpAnimation = "jumpstart"
			self.WalkAnimation = "idletowalk"
			if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
				self.RunAnimation = "idletowalk"
			else
				if self.KLK_ValorLevel > 0 then
					self.RunAnimation = "idletosprint"
				else
					self.RunAnimation = "idletorun"
				end
			end
			local LmaoRand = math.random(6)
			self:KLK_WeaponSwitch()
			self.KLK_RyukoStamina = math.Clamp( self.KLK_RyukoStamina + 15, 0, 100 )
			self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 5, 0, 100 )
			if LmaoRand == 1 then
				self:KLK_CICO(function()
					self.KLK_IsFlinching = false
					self:PlaySequenceAndMove("taunt2", 1, function(self,cycle)
						if cycle < 0.25 then
							self:FaceEnemy()
						end
						if self.KLK_IsFlinching == true then
							return true
						end
					end)
				end)
			elseif LmaoRand == 2 then
				self:KLK_CICO(function()
					self.KLK_IsFlinching = false
					self.KLK_TauntTime = CurTime() + 2
					self:PlaySequenceAndMove("taunt1", 1, function(self,cycle)
						if cycle < 0.25 then
							self:FaceEnemy()
						end
						if self.KLK_IsFlinching == true then
							return true
						end
					end)
				end)
			elseif LmaoRand == 3 then
				self:KLK_CICO(function()
					self.KLK_IsFlinching = false
					self.KLK_TauntTime = CurTime() + 2
					self:PlaySequenceAndMove("taunt4", 1, function(self,cycle)
						if cycle < 0.25 then
							self:FaceEnemy()
						end
						if self.KLK_IsFlinching == true then
							return true
						end
					end)
				end)
			elseif LmaoRand == 4 then
				self:KLK_CICO(function()
					self.KLK_IsFlinching = false
					self.KLK_TauntTime = CurTime() + 2
					self:PlaySequenceAndMove("taunt5", 1, function(self,cycle)
						if cycle < 0.25 then
							self:FaceEnemy()
						end
						if self.KLK_IsFlinching == true then
							return true
						end
					end)
				end)
			elseif LmaoRand == 5 then
				self:KLK_CICO(function()
					self.KLK_IsFlinching = false
					self.KLK_TauntTime = CurTime() + 5
					self:PlaySequenceAndMove("taunt6", 1, function(self,cycle)
						if cycle < 0.25 then
							self:FaceEnemy()
						end
						if self.KLK_IsFlinching == true then
							return true
						end
					end)
				end)
			elseif LmaoRand == 6 then
				self:KLK_CICO(function()
					self.KLK_IsFlinching = false
					self.KLK_TauntTime = CurTime() + 8
					self:PlaySequenceAndMove("taunt7", 1, function(self,cycle)
						if cycle < 0.25 then
							self:FaceEnemy()
						end
						if self.KLK_IsFlinching == true then
							return true
						end
					end)
				end)
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:HandleAnimEvent(evt,kronii,cycle,evttype,cmd)
	local waterdata   = {}
	local waterlength = Vector(0,0,2500)
	waterdata.start   = self:LocalToWorld(self:OBBCenter())
	waterdata.endpos  = waterdata.start + waterlength
	waterdata.filter  = self
	local sploosh = util.TraceLine(waterdata) 
	local splotchdata   = {}
	splotchdata.start   = sploosh.HitPos
	splotchdata.endpos  = waterdata.start - waterlength
	splotchdata.filter  = self
	splotchdata.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
	local waterline = util.TraceLine(splotchdata)
	if cmd == "unchallengedtheme" then
		if self.KLK_DisableMusic == false && self.KLK_MusicTimer < CurTime() then
			self.KLK_MusicTimer = CurTime() + 48
			self:KLK_StopMusic()
			self:EmitSound("KLK-IF.Ryuko.UnchallengedTheme")
		end
	end
	if cmd == "metercooldown" then
		self.KLK_MeterCooldown = CurTime() + 12.5
	end
	if cmd == "resetgroundlock" then
		/*if !self:IsOnGround() then
			self.KLK_HitGroundLock = false
		end*/
	end
	if cmd == "snailtime" then
		game.SetTimeScale(0.1)
	end
	if cmd == "realtime" then
		game.SetTimeScale(1)
	end
	if cmd == "ryukoflashcard" then
		local Effect = EffectData()
		Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*25)
		Effect:SetAngles(self:GetAngles())
		util.Effect("RyukoTitleCard",Effect,true,true)
	end
	if cmd == "lifefiberlost" then
		local Effect = EffectData()
		Effect:SetOrigin(self:GetPos() +self:OBBCenter()*3 +self:GetForward()*-250)
		Effect:SetAngles(self:GetAngles())
		util.Effect("RyukoFinisherCard",Effect,true,true)
	end
	if cmd == "jetjumping" then
		self:KLK_StopBoosters()
		self:EmitSound("KLK-IF.SpecialSFX.RocketsMini")
		ParticleEffectAttach( "senketsu_jet_mini_left", 4, self, 4 )
        ParticleEffectAttach( "senketsu_jet_mini_right", 4, self, 5 )
        ParticleEffectAttach( "senketsu_jet_mini", 4, self, 6 )
		self.BoosterLights = ents.Create("light_dynamic")
		self.BoosterLights:SetPos(self:GetPos() +self:OBBCenter())
		self.BoosterLights:SetKeyValue( "_light", "255 175 215 255" )
		self.BoosterLights:SetKeyValue("distance", "100" )
		self.BoosterLights:SetKeyValue("brightness", 4)
		self.BoosterLights:SetOwner(self)
		self.BoosterLights:SetParent(self)
		self.BoosterLights:Spawn()
		self:DeleteOnRemove(self.BoosterLights)
		self.BoosterLights:Fire("kill", "", 0.5)
	end
	if cmd == "ryukoremove" then
		self:KLK_StopMusic()
		if self.KLK_DisableMusic == false && self.KLK_MusicTimer > CurTime() then self:EmitSound("KLK-IF.Ryuko.DefeatTheme") end
		SafeRemoveEntityDelayed(self,0.1)
	end
	if cmd == "decapintrokira" then
        ParticleEffectAttach( "kirakiratinylocal", 4, self, 12 )
		self.KLK_ShakeTime = CurTime() + 3.5
	end
	if cmd == "decapfullkira" then
        ParticleEffectAttach( "decapbodykira", 4, self, 11 )
	end
	if cmd == "decapswitchpfx" then
        ParticleEffectAttach( "ss_weaponswitch_intro_star", 4, self, 12 )
	end
	if cmd == "decapchargeattack" then
		self.KLK_DashLaunchCharging = true
	end
	if cmd == "decapfly" then
		self.KLK_IsDoingAirAttack = true
		self.KLK_AirAttackLock = false
		self:Jump(100)
	end
	if cmd == "decapfloat" then
		self.KLK_AirAttackLock = true
		self.KLK_DashLaunchCharging = false
	end
	if cmd == "decapdrop" then
		self.KLK_IsDoingAirAttack = false
		self.KLK_CanGroundStomp = true
	end
	if cmd == "aurarelease" then
		self:EmitSound("KLK-IF.SpecialSFX.AuraRelease")
		ParticleEffect( "auraburst_sharp", self:GetPos() +self:GetUp()*1, self:GetAngles(), self )
	end
	if cmd == "recoverefx" then
		ParticleEffect( "ryu_recover_star", self:GetPos() +self:OBBCenter(), self:GetAngles(), self )
	end
	if cmd == "deductmeter" then
		self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter - 50, 0, 100 )
	end
	if cmd == "auraburst" then
		ParticleEffect( "kirakirapillar", self:GetPos() +self:GetForward()*-25 +self:GetUp()*1, self:GetAngles(), self )
		util.ScreenShake(self:GetPos(),30,30,math.Rand(1,1.5),1024)
	end
	if cmd == "pillarkirapfx" then
		ParticleEffect( "kirakirapillar", self:GetPos() +self:GetForward()*-25 +self:GetUp()*1, self:GetAngles(), self )
	end
	if cmd == "chestkirapfx" then
        ParticleEffectAttach( "kirakiratinylocal", 4, self, 9 )
	end
	if cmd == "chestpillarpfx" then
        ParticleEffectAttach( "senketsu_pillar_burst", 4, self, 1 )
        ParticleEffectAttach( "senketsu_pillar_burst", 4, self, 2 )
	end
	if cmd == "headkirapfx" then
        ParticleEffectAttach( "kirakiratinylocal", 4, self, 10 )
	end
	if cmd == "chargekirapfx" then
		ParticleEffectAttach( "kirakiratransform", 4, self, 3 )
	end
	if cmd == "landimpactefx" then
		if self:IsOnGround() then
			if self:WaterLevel() >= 1 && waterline.Hit then
				self:EmitSound("KLK-IF.Movement.HeavySplash")
				ParticleEffect("klk_water_sharp", waterline.HitPos, Angle(0,0,0), nil)
			else 
				self:EmitSound("KLK-IF.Movement.HeavyStomp")
				ParticleEffect( "dust_sharp", self:GetPos() +self:GetUp()*5, self:GetAngles(), self )
			end
			util.ScreenShake(self:GetPos(),60,60,math.Rand(2,3),2048)
		end
	end
	if cmd == "flashkirapfx" then
		ParticleEffect( "kirakiraflash", self:GetPos() +self:GetForward()*50 +self:GetUp()*45, self:GetAngles(), self )
	end
	if cmd == "flashformkirapfx" then
		ParticleEffect( "kirakiraflash", self:GetPos() +self:GetForward()*50 +self:GetUp()*45, self:GetAngles(), self )
		ParticleEffect( "kirakirawing_strip", self:GetPos() +self:GetForward()*10 +self:OBBCenter()*1.25, self:GetAngles(), self )
	end
	if cmd == "wingskirapfx" then
		ParticleEffect( "kirakirawing_l", self:GetPos() +self:GetForward()*-25 +self:GetUp()*45, self:GetAngles(), self )
		ParticleEffect( "kirakirawing_floor", self:GetPos() +self:GetUp()*5, self:GetAngles(), self )
	end
	if cmd == "kirakiraskillpfx" then
		ParticleEffectAttach( "kirakiraskill", 4, self, 1 )
		self.lighteffect = ents.Create("light_dynamic")
		self.lighteffect:SetPos(self:GetPos() +self:OBBCenter())
		self.lighteffect:SetKeyValue( "_light", "225 75 115 255" )
		self.lighteffect:SetKeyValue("distance", "125" )
		self.lighteffect:SetKeyValue("brightness", 6)
		self.lighteffect:SetParent(self)
		self.lighteffect:Spawn()
		self:DeleteOnRemove(self.lighteffect)
		self.lighteffect:Fire("kill", "", 1)
	end
	if cmd == "animepfx" then
        ParticleEffectAttach( "kirakiraanime_efx", 4, self, 1 )
	end
	if cmd == "animepfxrainbow" then
        ParticleEffectAttach( "kirakirahelper_1", 4, self, 1 )
	end
	if cmd == "valorcharging" then
        ParticleEffectAttach( "ryu_actionlines_floor", 4, self, 0 )
	end
	if cmd == "valorkira" then
        ParticleEffectAttach( "ryu_kirakiraburst", 4, self, 0 )
	end
	if cmd == "blockingdmg" then
        if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
		ParticleEffect( "blockhit_star", self:GetPos() +self:OBBCenter() +self:GetForward()*35, self:GetAngles(), self )
	end
	if cmd == "kirakiraflash" then
		ParticleEffect( "kirakiraslash_core", self:GetPos() +self:GetUp()*5, self:GetAngles(), self )
		self.lighteffect = ents.Create("light_dynamic")
		self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
		self.lighteffect:SetKeyValue( "_light", "225 75 115 255" )
		self.lighteffect:SetKeyValue("distance", "1250" )
		self.lighteffect:SetKeyValue("brightness", 6)
		self.lighteffect:SetParent(self)
		self.lighteffect:Spawn()
		self:DeleteOnRemove(self.lighteffect)
		self.lighteffect:Fire("kill", "", 0.25)
	end
	if cmd == "kirakirasmash" then
		ParticleEffect( "kirakirasmash_core", self:GetPos() +self:GetUp()*5 +self:GetForward()*50, self:GetAngles(), self )
		self.lighteffect = ents.Create("light_dynamic")
		self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5 +self:GetForward()*50)
		self.lighteffect:SetKeyValue( "_light", "225 75 115 255" )
		self.lighteffect:SetKeyValue("distance", "125" )
		self.lighteffect:SetKeyValue("brightness", 6)
		self.lighteffect:SetParent(self)
		self.lighteffect:Spawn()
		self:DeleteOnRemove(self.lighteffect)
		self.lighteffect:Fire("kill", "", 0.25)
	end
	if cmd == "spinning_efx" then
		ParticleEffect( "dust_spin", self:GetPos(), self:GetAngles(), self )
	end
	if cmd == "spintowin_efx" then
        ParticleEffectAttach( "dust_spin_ex", 4, self, 0 )
	end
	if cmd == "movingveryfast" then
		self.KLK_RapidTime = CurTime() + 3
		self:KLK_StopBoosters()
		self:EmitSound("KLK-IF.SpecialSFX.Rockets")
		ParticleEffectAttach( "senketsu_jet_left", 4, self, 4 )
        ParticleEffectAttach( "senketsu_jet_right", 4, self, 5 )
        ParticleEffectAttach( "senketsu_jet", 4, self, 6 )
		self.BoosterLights = ents.Create("light_dynamic")
		self.BoosterLights:SetPos(self:GetPos() +self:OBBCenter())
		self.BoosterLights:SetKeyValue( "_light", "255 175 215 255" )
		self.BoosterLights:SetKeyValue("distance", "100" )
		self.BoosterLights:SetKeyValue("brightness", 4)
		self.BoosterLights:SetOwner(self)
		self.BoosterLights:SetParent(self)
		self.BoosterLights:Spawn()
		self:DeleteOnRemove(self.BoosterLights)
		self.BoosterLights:Fire("kill", "", 3)
	end
	if cmd == "movingstupidlyfast" then
		if self.KLK_DisableMusic == false then
			self.KLK_MusicTimer = CurTime() + 15
			self:KLK_StopMusic()
			self:EmitSound("KLK-IF.Ryuko.FinisherTheme")
		end
		self:KLK_StopBoosters()
		self:EmitSound("KLK-IF.SpecialSFX.RocketsFinisher")
		self.KLK_RapidTime = CurTime() + 6.8
		self.KLK_JetTime = CurTime() + 10
		self.KLK_FinishTime = CurTime() + 2.5
		ParticleEffectAttach( "senketsu_jet_finisher_left", 4, self, 4 )
        ParticleEffectAttach( "senketsu_jet_finisher_right", 4, self, 5 )
        ParticleEffectAttach( "senketsu_jet_finisher", 4, self, 6 )
		self.BoosterLights = ents.Create("light_dynamic")
		self.BoosterLights:SetPos(self:GetPos() +self:OBBCenter())
		self.BoosterLights:SetKeyValue( "_light", "255 175 215 255" )
		self.BoosterLights:SetKeyValue("distance", "100" )
		self.BoosterLights:SetKeyValue("brightness", 4)
		self.BoosterLights:SetOwner(self)
		self.BoosterLights:SetParent(self)
		self.BoosterLights:Spawn()
		self:DeleteOnRemove(self.BoosterLights)
		self.BoosterLights:Fire("kill", "", 6.8)
	end
	if IsValid(self) then
		if cmd == "sbsnippit" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.8 +self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,-30))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()							
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0064) + ent:Armor()*(0.0192) + ((260)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0064) + (260))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-15, math.random(-15, 15), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*-250)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*-250)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbfrenzyslash" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashinv_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.2 +self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(5,0,20))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0132) + ent:Armor()*(0.0396) + ((430)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0132) + (430))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*-250)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*-250)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbfrenzykick" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_martial_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter())
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,15))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0132) + ent:Armor()*(0.0396) + ((430)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0132) + (430))*self.KLK_ValorDamageBonus) end,
				range = 200,
				type = dmg,
				viewpunch = Angle(-30, math.random(-30, 30), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "martialhit_star", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*175 +self:GetForward()*375)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*175 +self:GetForward()*375)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*175 +self:GetForward()*375)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Kick")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "sbfrenzyoverhead" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter())
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-15,0,-90))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter())
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.25,0.25),1048)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0144) + ent:Armor()*(0.0432) + ((360)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0144) + (360))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90,
				force = (self:GetUp()*250 +self:GetForward()*125)
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						self.lighteffect = ents.Create("light_dynamic")
						self.lighteffect:SetPos(self:GetEnemy():GetPos() +self:GetEnemy():GetUp()*5)
						self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
						self.lighteffect:SetKeyValue("distance", "250" )
						self.lighteffect:SetKeyValue("brightness", 6)
						self.lighteffect:Spawn()
						self:DeleteOnRemove(self.lighteffect)
						self.lighteffect:Fire("kill", "", 0.25)
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								self:GetEnemy().KLK_KnockedTime = CurTime() + 10
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*-175)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*-175)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*25 +self:GetForward()*150)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbcleaver" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter() +self:GetRight()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(180,-10,60))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*10)
			Effect:SetAngles(self:GetAngles() +Angle(-30,80,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			if !IsValid(self.Puncheroo) then
				self.Puncheroo = self:CreateProjectile(nil, {}, "proj_ryuko_punchdustefx")
				self.Puncheroo:SetPos(self:GetPos() + self:GetUp()*5 + self:GetForward()*-350 )
				self.Puncheroo:SetAngles(self:GetAngles())
				self.Puncheroo.Tremor = true
				self.Puncheroo:Spawn()
				self.Puncheroo:Activate()
				self.Puncheroo:SetOwner(self)
			end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 20
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.048) + ent:Armor()*(0.144) + ((1300)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.048) + (1300))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-60, math.random(-60, 60), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*625)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*625)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*625)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.SlashCrit")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "dmbloodripper" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter() +self:GetRight()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(180,0,135))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*6)
			Effect:SetAngles(self:GetAngles() +Angle(45,90,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			if !IsValid(self.Puncheroo) then
				self.Puncheroo = self:CreateProjectile(nil, {}, "proj_ryuko_punchdustefx")
				self.Puncheroo:SetPos(self:GetPos() + self:GetUp()*5 + self:GetForward()*50 )
				self.Puncheroo:SetAngles(self:GetAngles())
				self.Puncheroo.Tremor = true
				self.Puncheroo:Spawn()
				self.Puncheroo:Activate()
				self.Puncheroo:SetOwner(self)
			end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 20
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.068) + ent:Armor()*(0.0576) + ((1800)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.068) + (1800))*self.KLK_ValorDamageBonus) end,
				range = 250,
				type = dmg,
				viewpunch = Angle(-60, math.random(-60, 60), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					self.KLK_MeterCooldown = CurTime() + 8
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 5, 0, 100 )
					if IsValid(self:GetEnemy()) then
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*625)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*625)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*625)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.SlashCrit")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "dmkamaitachi" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1 +self:GetRight()*-8)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(180,-5,40))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*1 +self:GetRight()*-5)
			Effect:SetAngles(self:GetAngles() +Angle(-50,85,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.25,0.25),1048)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 20
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.088) + ent:Armor()*(0.264) + ((2300)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.088) + (2300))*self.KLK_ValorDamageBonus) end,
				range = 175,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 5, 0, 100 )
					if IsValid(self:GetEnemy()) then
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-500 +self:GetForward()*1000)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-500 +self:GetForward()*1000)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*-500 +self:GetForward()*1000)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.SlashCrit")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			local GroundProjData = {}
			GroundProjData.start = self:GetPos() + Vector(0,0,25)
			GroundProjData.endpos = self:GetPos() + Vector(0,0,-1250)
			GroundProjData.filter = {self}
			local GroundProjTrace = util.TraceLine(GroundProjData)
			self:EmitSound("KLK-IF.AttackSFX.ShockWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_dmkamaitachi")
			self.TestProjectile:SetPos(GroundProjTrace.HitPos + self:GetUp()*25 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_dmkamaitachi")
			self.TestProjectile:SetPos(GroundProjTrace.HitPos + self:GetUp()*25 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,-15,0))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_dmkamaitachi")
			self.TestProjectile:SetPos(GroundProjTrace.HitPos + self:GetUp()*25 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,15,0))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "senisoshitsu" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter() +self:GetRight()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(180,0,135))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetRight()*6)
			Effect:SetAngles(self:GetAngles() +Angle(45,90,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			if !IsValid(self.Puncheroo) then
				self.Puncheroo = self:CreateProjectile(nil, {}, "proj_ryuko_punchdustefx")
				self.Puncheroo:SetPos(self:GetPos() + self:GetUp()*5 + self:GetForward()*50 )
				self.Puncheroo:SetAngles(self:GetAngles())
				self.Puncheroo.Tremor = true
				self.Puncheroo:Spawn()
				self.Puncheroo:Activate()
				self.Puncheroo:SetOwner(self)
			end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 20
			local dmg = DMG_DIRECT
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = (math.huge),
				range = 250,
				type = dmg,
				viewpunch = Angle(-60, math.random(-60, 60), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					self.KLK_MeterCooldown = CurTime() + 8
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 100, 0, 100 )
					if IsValid(self:GetEnemy()) then
						ParticleEffect( "finisherkira", self:GetEnemy():GetPos() +self:GetEnemy():GetUp()*5, self:GetEnemy():GetAngles(), self )
						self:GetEnemy():SetGroundEntity(NULL)
						for i=1,3 do self:GetEnemy():EmitSound("KLK-IF.SpecialSFX.FinisherConnect") end
						if self:GetEnemy():IsPlayer() or (self:GetEnemy():IsNextBot() and self:GetEnemy().IsDrGNextbot) then
							self:GetEnemy():NextThink(CurTime())
							self:GetEnemy():Kill(self)
						else
							self:GetEnemy():TakeDamage(1e9, self, self)
							self:GetEnemy():Fire("kill", "", 0.25)
						end
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbkmtcsideslash" then
			self.KLK_KMTCCounter = 0
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.4 +self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(20,0,10))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.008) + ent:Armor()*(0.024) + ((300)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.008) + (300))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*275 +self:GetForward()*75)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbkmtctripleslashfirst" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.35 + self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(15,-5,-60))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*1.25 + self:GetForward()*8)
			Effect:SetAngles(self:GetAngles() +Angle(-28,75,15))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			local WaveEfx = EffectData()
			WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*1.25 +self:GetForward()*8)
			WaveEfx:SetAngles(self:GetAngles() +Angle(-28,75,15))
			WaveEfx:SetScale(1)
			WaveEfx:SetEntity(self)
			util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.012) + ent:Armor()*(0.036) + ((400)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.012) + (400))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-15, math.random(-15, 15), 0),
				angle = 120
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 2, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*275 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbkmtctripleslashsecond" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.65 + self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,3))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*1.525 + self:GetForward()*8)
			Effect:SetAngles(self:GetAngles() +Angle(86,85,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			local WaveEfx = EffectData()
			WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*1.525 +self:GetForward()*8)
			WaveEfx:SetAngles(self:GetAngles() +Angle(86,85,0))
			WaveEfx:SetScale(1)
			WaveEfx:SetEntity(self)
			util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.012) + ent:Armor()*(0.036) + ((400)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.012) + (400))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-15, math.random(-15, 15), 0),
				angle = 120
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 2, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*275 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbkmtctripleslashthird" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.5 + self:GetForward()*10 + self:GetRight()*5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(5,0,55))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*1.4 + self:GetForward()*10 + self:GetRight()*5)
			Effect:SetAngles(self:GetAngles() +Angle(35,95,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			local WaveEfx = EffectData()
			WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*1.4 +self:GetForward()*10 + self:GetRight()*5)
			WaveEfx:SetAngles(self:GetAngles() +Angle(35,95,0))
			WaveEfx:SetScale(1)
			WaveEfx:SetEntity(self)
			util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.012) + ent:Armor()*(0.036) + ((400)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.012) + (400))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-15, math.random(-15, 15), 0),
				angle = 120
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 2, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								self:GetEnemy().KLK_KnockedTime = CurTime() + 10
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*275 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbkmtcoverhead" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1 +self:GetRight()*-8)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(180,-5,40))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*1 +self:GetRight()*-5)
			Effect:SetAngles(self:GetAngles() +Angle(-50,85,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			local WaveEfx = EffectData()
			WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*1 +self:GetRight()*-5)
			WaveEfx:SetAngles(self:GetAngles() +Angle(-50,85,0))
			WaveEfx:SetScale(1.5)
			WaveEfx:SetEntity(self)
			util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.25,0.25),1048)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0324) + ent:Armor()*(0.0972) + ((910)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0324) + (910))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-30, math.random(-30, 30), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 2, 0, 100 )
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								self:GetEnemy().KLK_KnockedTime = CurTime() + 10
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-250 +self:GetForward()*875)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-750 +self:GetForward()*1500)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*-750 +self:GetForward()*1500)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbrangelight" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter() + self:GetForward()*5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-15,0,-90))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*5)
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0132) + ent:Armor()*(0.0396) + ((430)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0132) + (430))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			self:EmitSound("KLK-IF.AttackSFX.SlashWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbrangelight")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*35 + self:GetForward()*10 )
			if IsValid(self:GetEnemy()) then
				self.TestProjectile:SetAngles(((self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter() +self:GetEnemy():GetVelocity()*(self.TestProjectile:GetPos():Distance(self:GetEnemy():GetPos())/math.random(1000,1500)))-self.TestProjectile:GetPos()):Angle())
			else
				self.TestProjectile:SetAngles(self:GetAngles())
			end
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbrangemedium" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashinv_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.8 +self:GetForward()*10 +self:GetRight()*5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,20))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*0.6875 +self:GetForward()*10 +self:GetRight()*5)
			Effect:SetAngles(self:GetAngles() +Angle(-110,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0192) + ent:Armor()*(0.0576) + ((580)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0192) + (580))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			self:EmitSound("KLK-IF.AttackSFX.ShockWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbrangemedium")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*35 + self:GetForward()*10 )
			if IsValid(self:GetEnemy()) then
				self.TestProjectile:SetAngles(((self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter() +self:GetEnemy():GetVelocity()*(self.TestProjectile:GetPos():Distance(self:GetEnemy():GetPos())/math.random(2250,2750)))-self.TestProjectile:GetPos()):Angle())
			else
				self.TestProjectile:SetAngles(self:GetAngles())
			end
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbrangeheavy" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.95 + self:GetForward()*5 + self:GetRight()*-10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-10,0,-15))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*0.85 +self:GetForward()*5 + self:GetRight()*-10)
			Effect:SetAngles(self:GetAngles() +Angle(107,125,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			local WaveEfx = EffectData()
			WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*0.85 +self:GetForward()*5 + self:GetRight()*-10)
			WaveEfx:SetAngles(self:GetAngles() +Angle(107,125,0))
			WaveEfx:SetScale(1)
			WaveEfx:SetEntity(self)
			util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
			Effect:SetAngles(self:GetAngles())
			util.Effect("PunchSonicBoom",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 15
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0324) + ent:Armor()*(0.0972) + ((910)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0324) + (910))*self.KLK_ValorDamageBonus) end,
				range = 200,
				type = dmg,
				viewpunch = Angle(-45, math.random(-45, 45), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						self.KLK_PunchConnect = true
						self.KLK_PunchCount = 0
						self.KLK_PunchDist = 0
						ParticleEffect( "martialhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*500 +self:GetForward()*1500)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*500 +self:GetForward()*1500)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*500 +self:GetForward()*1500)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Launched")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			self:EmitSound("KLK-IF.AttackSFX.RampantBlade")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbrangeheavy")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*35 + self:GetForward()*10 )
			if IsValid(self:GetEnemy()) then
				self.TestProjectile:SetAngles(((self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter() +self:GetEnemy():GetVelocity()*(self.TestProjectile:GetPos():Distance(self:GetEnemy():GetPos())/math.random(3500,4000)))-self.TestProjectile:GetPos()):Angle())
			else
				self.TestProjectile:SetAngles(self:GetAngles())
			end
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbcrossfirst" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.8 +self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,-30))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*0.6875 +self:GetForward()*10)
			Effect:SetAngles(self:GetAngles() +Angle(-60,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0192) + ent:Armor()*(0.0576) + ((580)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0192) + (580))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*-125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*-125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbcrosssecond" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashinv_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.8 +self:GetForward()*10 +self:GetRight()*5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,20))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*0.6875 +self:GetForward()*10 +self:GetRight()*5)
			Effect:SetAngles(self:GetAngles() +Angle(-110,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0192) + ent:Armor()*(0.0576) + ((580)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0192) + (580))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*-125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*-125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbslashwave" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter() + self:GetForward()*5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-15,0,-90))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*5)
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0132) + ent:Armor()*(0.0396) + ((430)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0132) + (430))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			self:EmitSound("KLK-IF.AttackSFX.SlashWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbslashwave")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*-5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbslashwavesecond" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter() + self:GetForward()*10 + self:GetRight()*-15)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-15,0,65))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*10 + self:GetRight()*-15)
			Effect:SetAngles(self:GetAngles() +Angle(25,85,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0132) + ent:Armor()*(0.0396) + ((430)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0132) + (430))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			self:EmitSound("KLK-IF.AttackSFX.SlashWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbslashwave")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*-5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbrampantblade" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter() + self:GetForward()*10 + self:GetRight()*-15)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-15,0,65))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*10 + self:GetRight()*-15)
			Effect:SetAngles(self:GetAngles() +Angle(25,85,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0132) + ent:Armor()*(0.0396) + ((430)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0132) + (430))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								self:GetEnemy().KLK_KnockedTime = CurTime() + 10
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			self:EmitSound("KLK-IF.AttackSFX.RampantBlade")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbrampantblade")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*-5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbshockwave" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter())
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(135,0,90))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*5)
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.25,0.25),1048)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0104) + ent:Armor()*(0.0312) + ((360)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0104) + (360))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*250 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			self:EmitSound("KLK-IF.AttackSFX.ShockWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbshockwave")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*-5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbshockwave")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*-5 )
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,-20,0))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbshockwave")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,20,0))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbshockwavelight" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.25 + self:GetForward()*-5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-15,0,-90))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*1.25 +self:GetForward()*-5)
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.028) + ent:Armor()*(0.084) + ((800)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.028) + (800))*self.KLK_ValorDamageBonus) end,
				range = 175,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-375 +self:GetForward()*750)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-375 +self:GetForward()*750)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*-375 +self:GetForward()*750)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			local GroundProjData = {}
			GroundProjData.start = self:GetPos() + Vector(0,0,25)
			GroundProjData.endpos = self:GetPos() + Vector(0,0,-1250)
			GroundProjData.filter = {self}
			local GroundProjTrace = util.TraceLine(GroundProjData)
			self:EmitSound("KLK-IF.AttackSFX.ShockWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbshockwave")
			self.TestProjectile:SetPos(GroundProjTrace.HitPos + self:GetUp()*25 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbshockwaveheavy" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.25 +self:GetForward()*-5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(135,0,90))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*1.25 +self:GetForward()*-5)
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.25,0.25),1048)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.05) + ent:Armor()*(0.15) + ((1350)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.05) + (1350))*self.KLK_ValorDamageBonus) end,
				range = 175,
				type = dmg,
				viewpunch = Angle(-20, math.random(-20, 20), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
					if IsValid(self:GetEnemy()) then
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-375 +self:GetForward()*875)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-375 +self:GetForward()*875)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*-375 +self:GetForward()*875)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			local GroundProjData = {}
			GroundProjData.start = self:GetPos() + Vector(0,0,25)
			GroundProjData.endpos = self:GetPos() + Vector(0,0,-1250)
			GroundProjData.filter = {self}
			local GroundProjTrace = util.TraceLine(GroundProjData)
			self:EmitSound("KLK-IF.AttackSFX.ShockWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbshockwave")
			self.TestProjectile:SetPos(GroundProjTrace.HitPos + self:GetUp()*25 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbshockwave")
			self.TestProjectile:SetPos(GroundProjTrace.HitPos + self:GetUp()*25 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,-20,0))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbshockwave")
			self.TestProjectile:SetPos(GroundProjTrace.HitPos + self:GetUp()*25 + self:GetForward()*5 )
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,20,0))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbambushslice" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.85 + self:GetForward()*10 + self:GetRight()*-10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(35,-15,0))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*0.75 + self:GetForward()*8 + self:GetRight()*-10)
			Effect:SetAngles(self:GetAngles() +Angle(125,-15,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 15
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0266) + ent:Armor()*(0.0798) + ((765)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0266) + (765))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-30, math.random(-30, 30), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*375)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*375)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
			-- ADD PROJECTILE ATTACKS HERE
			self:EmitSound("KLK-IF.AttackSFX.ShockWave")
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbambushingslice")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*-5 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbambushingslice")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*-5 + self:GetRight()*100 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_sbambushingslice")
			self.TestProjectile:SetPos(self:GetPos() + self:GetUp()*30 + self:GetForward()*5 + self:GetRight()*-100 )
			self.TestProjectile:SetAngles(self:GetAngles())
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
		elseif cmd == "sbleftstraight" then
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*100)
			Effect:SetAngles(self:GetAngles())
			util.Effect("PunchSonicBoom",Effect,true,true)
			util.Effect("PunchShockwave",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.056) + ent:Armor()*(0.168) + ((1500)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.056) + (1500))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-45, math.random(-45, 45), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						self.KLK_PunchConnect = true
						self.KLK_PunchCount = 0
						self.KLK_PunchDist = 0
						self.Puncheroo = self:CreateProjectile(nil, {}, "proj_ryuko_punchdustefx")
						self.Puncheroo:SetPos(self:GetPos() + self:GetUp()*5 + self:GetForward()*-5 )
						self.Puncheroo:SetAngles(self:GetAngles())
						self.Puncheroo:Spawn()
						self.Puncheroo:Activate()
						self.Puncheroo:SetOwner(self)
						ParticleEffect( "martialhit_star", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*500)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*500)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*250 +self:GetForward()*500)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "fanbladepunch" then
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			local Effect = EffectData()
			Effect:SetAngles(self:GetAngles())
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*100)
			util.Effect("PunchShockwave",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 15
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0398) + ent:Armor()*(0.1194) + ((1095)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0398) + (1095))*self.KLK_ValorDamageBonus) end,
				range = 150,
				type = dmg,
				viewpunch = Angle(-45, math.random(-45, 45), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					self.KLK_MeterCooldown = CurTime() + 8
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 5, 0, 100 )
					if IsValid(self:GetEnemy()) then
						self.KLK_PunchConnect = true
						self.KLK_PunchCount = 0
						self.KLK_PunchDist = 0
						self.Puncheroo = self:CreateProjectile(nil, {}, "proj_ryuko_punchdustefx")
						self.Puncheroo:SetPos(self:GetPos() + self:GetUp()*5 + self:GetForward()*-5 )
						self.Puncheroo:SetAngles(self:GetAngles())
						self.Puncheroo:Spawn()
						self.Puncheroo:Activate()
						self.Puncheroo:SetOwner(self)
						ParticleEffect( "martialhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*750 +self:GetForward()*1500)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*750 +self:GetForward()*1500)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*750 +self:GetForward()*1500)
						end
						for i=1,10 do self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3)) end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.MartialCrit")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "sbhomerun" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.95 + self:GetForward()*5 + self:GetRight()*-10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-10,0,-15))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*0.85 +self:GetForward()*5 + self:GetRight()*-10)
			Effect:SetAngles(self:GetAngles() +Angle(107,125,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			local WaveEfx = EffectData()
			WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*0.85 +self:GetForward()*5 + self:GetRight()*-10)
			WaveEfx:SetAngles(self:GetAngles() +Angle(107,125,0))
			WaveEfx:SetScale(1)
			WaveEfx:SetEntity(self)
			util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*50)
			Effect:SetAngles(self:GetAngles())
			util.Effect("PunchSonicBoom",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 15
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0324) + ent:Armor()*(0.0972) + ((910)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0324) + (910))*self.KLK_ValorDamageBonus) end,
				range = 200,
				type = dmg,
				viewpunch = Angle(-45, math.random(-45, 45), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_PunchConnect = true
						self.KLK_PunchCount = 0
						self.KLK_PunchDist = 0
						self.Puncheroo = self:CreateProjectile(nil, {}, "proj_ryuko_punchdustefx")
						self.Puncheroo:SetPos(self:GetPos() + self:GetUp()*5 + self:GetForward()*-5 )
						self.Puncheroo:SetAngles(self:GetAngles())
						self.Puncheroo:Spawn()
						self.Puncheroo:Activate()
						self.Puncheroo:SetOwner(self)
						ParticleEffect( "martialhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								self:GetEnemy().KLK_KnockedTime = CurTime() + 10
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*750 +self:GetForward()*1500)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*750 +self:GetForward()*1500)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*750 +self:GetForward()*1500)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Launched")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbuppercut" then
			ParticleEffectAttach( "klkdash_up", 4, self, 0 )
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0144) + ent:Armor()*(0.0432) + ((460)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0144) + (460))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-30, math.random(-10, 10), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						ParticleEffect( "martialhit_star", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*205 +self:GetForward()*155)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*205 +self:GetForward()*155)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*205 +self:GetForward()*155)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "sbuppercutlaunch" then
			ParticleEffectAttach( "klkdash_up", 4, self, 0 )
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			self:Jump(100)
			self:SetVelocity(self:GetUp()*500 +self:GetForward()*125)
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0144) + ent:Armor()*(0.0432) + ((460)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0144) + (460))*self.KLK_ValorDamageBonus) end,
				range = 150,
				type = dmg,
				viewpunch = Angle(-30, math.random(-10, 10), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						ParticleEffect( "martialhit_star", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*575 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*575 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*375 +self:GetForward()*175)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "sbraid" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.125 + self:GetForward()*5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(-15,0,-90))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter()*1.125 +self:GetForward()*5)
			Effect:SetAngles(self:GetAngles() +Angle(0,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			local WaveEfx = EffectData()
			WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*1.125 +self:GetForward()*5)
			WaveEfx:SetAngles(self:GetAngles() +Angle(0,90,0))
			WaveEfx:SetScale(1)
			WaveEfx:SetEntity(self)
			util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 10
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.024) + ent:Armor()*(0.072) + ((700)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.024) + (700))*self.KLK_ValorDamageBonus) end,
				range = 200,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
					self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						self.lighteffect = ents.Create("light_dynamic")
						self.lighteffect:SetPos(self:GetEnemy():GetPos() +self:GetEnemy():GetUp()*5)
						self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
						self.lighteffect:SetKeyValue("distance", "250" )
						self.lighteffect:SetKeyValue("brightness", 6)
						self.lighteffect:Spawn()
						self:DeleteOnRemove(self.lighteffect)
						self.lighteffect:Fire("kill", "", 0.25)
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								self:GetEnemy().KLK_KnockedTime = CurTime() + 10
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*875)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*875)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*375 +self:GetForward()*750)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbshear" then
			if self.KLK_ShearCounter == 0 then
				self.KLK_ShearCounter = 1
				self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashinv_efx")
				self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1.175 + self:GetForward()*5)
				self.TestProjectile:SetAngles(self:GetAngles() +Angle(10,0,3))
				self.TestProjectile:Spawn()
				self.TestProjectile:Activate()
				self.TestProjectile:SetOwner(self)
				self.TestProjectile:SetParent(self)
				local Effect = EffectData()
				Effect:SetOrigin(self:GetPos() +self:OBBCenter()*1.075 +self:GetForward()*5)
				Effect:SetAngles(self:GetAngles() +Angle(100,-15,0))
				Effect:SetScale(1)
				Effect:SetEntity(self)
				util.Effect("SwipeWindEffect",Effect,true,true)
				local WaveEfx = EffectData()
				WaveEfx:SetOrigin(self:GetPos() +self:OBBCenter()*1.075 +self:GetForward()*5)
				WaveEfx:SetAngles(self:GetAngles() +Angle(100,-15,0))
				WaveEfx:SetScale(1)
				WaveEfx:SetEntity(self)
				util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			elseif self.KLK_ShearCounter == 1 then
				self.KLK_ShearCounter = 0
				self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashinv_efx")
				self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.95 + self:GetForward()*5)
				self.TestProjectile:SetAngles(self:GetAngles() +Angle(15,0,27))
				self.TestProjectile:Spawn()
				self.TestProjectile:Activate()
				self.TestProjectile:SetOwner(self)
				self.TestProjectile:SetParent(self)
				local Effect = EffectData()
				Effect:SetOrigin(self:GetPos() + self:OBBCenter()*0.85 + self:GetForward()*5)
				Effect:SetAngles(self:GetAngles() +Angle(120,-65,0))
				Effect:SetScale(1)
				Effect:SetEntity(self)
				util.Effect("SwipeWindEffect",Effect,true,true)
				local WaveEfx = EffectData()
				WaveEfx:SetOrigin(self:GetPos() + self:OBBCenter()*0.85 + self:GetForward()*5)
				WaveEfx:SetAngles(self:GetAngles() +Angle(120,-65,0))
				WaveEfx:SetScale(1)
				WaveEfx:SetEntity(self)
				util.Effect("SwipeWaveEffect",WaveEfx,true,true)
			end
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0232) + ent:Armor()*(0.0696) + ((680)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0232) + (680))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*175 +self:GetForward()*-75)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*175 +self:GetForward()*-75)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*150 +self:GetForward()*175)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbcrossfirst" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.8 +self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,-30))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*0.6875 +self:GetForward()*10)
			Effect:SetAngles(self:GetAngles() +Angle(-60,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0192) + ent:Armor()*(0.0576) + ((580)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0192) + (580))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbcrosssecond" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashinv_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.8 +self:GetForward()*10 +self:GetRight()*5)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,20))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*0.6875 +self:GetForward()*10 +self:GetRight()*5)
			Effect:SetAngles(self:GetAngles() +Angle(-110,90,0))
			Effect:SetScale(1)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.0192) + ent:Armor()*(0.0576) + ((580)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.0192) + (580))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 360
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_base", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*125)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "sbsplitdemon" then
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slashcleaver_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*1 +self:GetRight()*-8)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(180,-5,40))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() + self:OBBCenter()*1 +self:GetRight()*-5)
			Effect:SetAngles(self:GetAngles() +Angle(-50,85,0))
			Effect:SetScale(1.5)
			Effect:SetEntity(self)
			util.Effect("SwipeWindEffect",Effect,true,true)
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.25,0.25),1048)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.014) + ent:Armor()*(0.042) + ((450)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.014) + (450))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-20, math.random(-15, 15), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								self:GetEnemy().KLK_KnockedTime = CurTime() + 10
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-375 +self:GetForward()*750)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-250 +self:GetForward()*875)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*-250 +self:GetForward()*875)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Slash"..math.random(1,3))
				end
			end)
		elseif cmd == "paybackheadbutt" then
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.01) + ent:Armor()*(0.03) + ((350)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.01) + (350))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(45, math.random(-15, 15), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
						ParticleEffect( "martialhit_star", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*-250)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*250 +self:GetForward()*-250)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*-250 +self:GetForward()*125)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "paybackfrontkick" then
			local Effect = EffectData()
			Effect:SetOrigin(self:GetPos() +self:OBBCenter() +self:GetForward()*100)
			Effect:SetAngles(self:GetAngles())
			util.Effect("PunchSonicBoom",Effect,true,true)
			util.Effect("PunchShockwave",Effect,true,true)
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.036) + ent:Armor()*(0.108) + ((1000)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.036) + (1000))*self.KLK_ValorDamageBonus) end,
				range = 100,
				type = dmg,
				viewpunch = Angle(-30, math.random(-30, 30), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						local Effect = EffectData()
						Effect:SetOrigin(self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter())
						Effect:SetAngles(self:GetEnemy():GetAngles())
						util.Effect("PunchShockwaveSmall",Effect,true,true)
						ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
						ParticleEffect( "martialhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*750)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*125 +self:GetForward()*750)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*125 +self:GetForward()*750)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "dragonkick" then
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.012) + ent:Armor()*(0.036) + ((400)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.012) + (400))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-30, math.random(-30, 30), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "martialhit_star", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						self.lighteffect = ents.Create("light_dynamic")
						self.lighteffect:SetPos(self:GetEnemy():GetPos() +self:GetEnemy():GetUp()*5)
						self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
						self.lighteffect:SetKeyValue("distance", "250" )
						self.lighteffect:SetKeyValue("brightness", 6)
						self.lighteffect:Spawn()
						self:DeleteOnRemove(self.lighteffect)
						self.lighteffect:Fire("kill", "", 0.25)
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-875 +self:GetForward()*375)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*-875 +self:GetForward()*375)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*-875 +self:GetForward()*375)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "dragonkicklaunch" then
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.KLK_RyukoStamina = self.KLK_RyukoStamina - 5
			local dmg = DMG_CLUB
			local enemy = self:GetClosestEnemy()
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.036) + ent:Armor()*(0.108) + ((1000)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.036) + (1000))*self.KLK_ValorDamageBonus) end,
				range = 125,
				type = dmg,
				viewpunch = Angle(-30, math.random(-30, 30), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						local Effect = EffectData()
						Effect:SetOrigin(self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter())
						Effect:SetAngles(self:GetEnemy():GetAngles())
						util.Effect("PunchShockwaveSmall",Effect,true,true)
						ParticleEffect( "martialhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						self.lighteffect = ents.Create("light_dynamic")
						self.lighteffect:SetPos(self:GetEnemy():GetPos() +self:GetEnemy():GetUp()*5)
						self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
						self.lighteffect:SetKeyValue("distance", "250" )
						self.lighteffect:SetKeyValue("brightness", 6)
						self.lighteffect:Spawn()
						self:DeleteOnRemove(self.lighteffect)
						self.lighteffect:Fire("kill", "", 0.25)
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*500 +self:GetForward()*875)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*500 +self:GetForward()*875)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*500 +self:GetForward()*875)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.Martial"..math.random(1,3))
				end
			end)
		elseif cmd == "valorburst" then
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.75,0.75),2048)
			local effectdata = EffectData()
			effectdata:SetOrigin(self:GetPos() +self:OBBCenter()*0.5)
			ParticleEffect( "ryu_valorblast", self:GetPos(), self:GetAngles(), self )
			ParticleEffect( "kirakiraslash_core", self:GetPos(), self:GetAngles(), self )
			ParticleEffect( "kirakirashock_core", self:GetPos(), self:GetAngles(), self )
			self.lighteffect = ents.Create("light_dynamic")
			self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
			self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
			self.lighteffect:SetKeyValue("distance", "2500" )
			self.lighteffect:SetKeyValue("brightness", 4)
			self.lighteffect:Spawn()
			self:DeleteOnRemove(self.lighteffect)
			self.lighteffect:Fire("kill", "", 0.25)
			if cmd == "valorburst" then
				self:SetSkin(1)
				self.KLK_Synchronized = true
			end
			if IsValid(self) then
				for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter(),250)) do
					if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:Disposition(PoorSap) == 1 then
						PoorSap:TakeDamage(((PoorSap:GetMaxHealth()*(0.02*self.KLK_ValorHits)) + (600+self.KLK_ValorSoak)) * self.KLK_ValorDamageBonus, self, self)
						PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
						ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
						if PoorSap:IsNextBot() then
							if PoorSap.DrG_IsKLK == true then
								--PoorSap:Jump(100)
								PoorSap:SetVelocity(self:GetUp()*600 +self:GetForward()*1750)
							elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
								PoorSap:LeaveGround()
								--PoorSap:Jump(100)
								PoorSap:SetVelocity(self:GetUp()*600 +self:GetForward()*1750)
							end
						elseif !PoorSap:IsNextBot() then
							PoorSap:SetGroundEntity(NULL)
							PoorSap:SetLocalVelocity(self:GetUp()*600 +self:GetForward()*1750)
						end
					elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
						PoorSap:SetGroundEntity(NULL)
						ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
						PoorSap:TakeDamage( (((600*self.KLK_OwnDMGMult)+self.KLK_ValorSoak) * self.KLK_ValorDamageBonus) + (PoorSap:Health()*0.02) + (PoorSap:Armor()*0.06), self, PoorSap )
						PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
						PoorSap:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*875)
					end
				end
			end
		elseif cmd == "valorparry" then
			if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
			self.TestProjectile = self:CreateProjectile(nil, {}, "proj_ryuko_slash_efx")
			self.TestProjectile:SetPos(self:GetPos() + self:OBBCenter()*0.8 +self:GetForward()*10)
			self.TestProjectile:SetAngles(self:GetAngles() +Angle(0,0,-30))
			self.TestProjectile:Spawn()
			self.TestProjectile:Activate()
			self.TestProjectile:SetOwner(self)
			self.TestProjectile:SetParent(self)
			self:EmitSound("KLK-IF.Movement.HeavyStomp")
			ParticleEffect( "dust_sharp", self:GetPos() +self:GetUp()*5, self:GetAngles(), self )
			local dmg = DMG_SLASH
			local enemy = self:GetClosestEnemy()							
			self:Attack({
				damage = function(ent) return ent:IsPlayer() and ((ent:Health()*(0.05) + ent:Armor()*(0.15) + ((1350)*self.KLK_OwnDMGMult))*self.KLK_ValorDamageBonus) or ((ent:GetMaxHealth()*(0.05) + (1350))*self.KLK_ValorDamageBonus) end,
				range = 150,
				type = dmg,
				viewpunch = Angle(-15, math.random(-15, 15), 0),
				angle = 90
			},
			function(self, hit)
				if #hit > 0 then
					if IsValid(self:GetEnemy()) then
						if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
						--self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry + 1, 0, 100 )
						ParticleEffect( "slashhit_heavy", self:GetEnemy():GetPos() +self:GetEnemy():OBBCenter(), self:GetEnemy():GetAngles(), self )
						if self:GetEnemy():IsNextBot() then
							if self:GetEnemy().DrG_IsKLK == true then
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*750)
							elseif self:GetEnemy().DrG_IsKLK != true && self:GetEnemy().IsDrGNextbot then
								self:GetEnemy():LeaveGround()
								--self:GetEnemy():Jump(100)
								self:GetEnemy():SetVelocity(self:GetUp()*375 +self:GetForward()*750)
							end
						elseif !self:GetEnemy():IsNextBot() then
							self:GetEnemy():SetGroundEntity(NULL)
							self:GetEnemy():SetLocalVelocity(self:GetUp()*375 +self:GetForward()*750)
						end
						self:GetEnemy():EmitSound("KLK-IF.HitSFX.SlashCrit")
					end
				else
					self:EmitSound("KLK-IF.AttackSFX.BKZSlash")
				end
			end)
		elseif cmd == "counterburst" then
			util.ScreenShake(self:GetPos(),150,150,math.Rand(0.75,0.75),2048)
			local effectdata = EffectData()
			effectdata:SetOrigin(self:GetPos() +self:OBBCenter()*0.5)
			ParticleEffect( "ryu_valorblast", self:GetPos(), self:GetAngles(), self )
			ParticleEffect( "kirakiraslash_core", self:GetPos(), self:GetAngles(), self )
			ParticleEffect( "kirakirashock_core", self:GetPos(), self:GetAngles(), self )
			self.lighteffect = ents.Create("light_dynamic")
			self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
			self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
			self.lighteffect:SetKeyValue("distance", "1250" )
			self.lighteffect:SetKeyValue("brightness", 6)
			self.lighteffect:Spawn()
			self:DeleteOnRemove(self.lighteffect)
			self.lighteffect:Fire("kill", "", 0.25)
			if IsValid(self) then
				for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter(),250)) do
					if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:Disposition(PoorSap) == 1 then
						PoorSap:TakeDamage(((PoorSap:GetMaxHealth()*(0.04*self.KLK_ValorHits)) + (1100+self.KLK_ValorSoak)) * self.KLK_ValorDamageBonus, self, self)
						PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
						ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
						if PoorSap:IsNextBot() then
							if PoorSap.DrG_IsKLK == true then
								--PoorSap:Jump(100)
								PoorSap:SetVelocity(self:GetUp()*600 +self:GetForward()*875)
							elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
								PoorSap:LeaveGround()
								--PoorSap:Jump(100)
								PoorSap:SetVelocity(self:GetUp()*600 +self:GetForward()*875)
							end
						elseif !PoorSap:IsNextBot() then
							PoorSap:SetGroundEntity(NULL)
							PoorSap:SetLocalVelocity(self:GetUp()*600 +self:GetForward()*875)
						end
					elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
						PoorSap:SetGroundEntity(NULL)
						ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
						PoorSap:TakeDamage( (((600*self.KLK_OwnDMGMult)+self.KLK_ValorSoak) * self.KLK_ValorDamageBonus) + (PoorSap:Health()*0.02) + (PoorSap:Armor()*0.06), self, PoorSap )
						PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
						PoorSap:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*875)
					end
				end
			end
		end
	end
	if cmd == "resetattacks" then
		self:KLK_ResetAttacks()
	end
	if cmd == "resetvars" then
		self:ResetThemAll()
	end

	--=====: Special Handlers :=====--

	local bgroup = string.Explode(" ", cmd, false)
	if bgroup[1] == "bodygroup" then
		self:SetBodygroup(2,tonumber(bgroup[2]))
		self:EmitSound("KLK-IF.SpecialSFX.WeapSwitch")
		ParticleEffectAttach( "ss_weaponswitch_intro_star", 4, self, 11 )
	end
	local colgroup = string.Explode(" ", cmd, false)
	if colgroup[1] == "collision" then
		self:SetCollisionGroup(tonumber(colgroup[2]))
	end
	local shakegroup = string.Explode(" ", cmd, false)
	if shakegroup[1] == "shaketime" then
		self.KLK_ShakeTime = CurTime() +tonumber(shakegroup[2])
	end
	local immunegroup = string.Explode(" ", cmd, false)
	if immunegroup[1] == "immunetime" then
		self.KLK_ImmuneTime = CurTime() +tonumber(immunegroup[2])
	end
	
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:SBFanningBlade()
	if IsValid(self) then
		for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter(),125)) do
			if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:Disposition(PoorSap) == 1 then
				PoorSap:TakeDamage(((PoorSap:GetMaxHealth()*0.011) + 275) * self.KLK_ValorDamageBonus, self, self)
				PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
				ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
				if PoorSap:IsNextBot() then
					if PoorSap.DrG_IsKLK == true then
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*65 +self:GetForward()*725)
					elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
						PoorSap:LeaveGround()
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*65 +self:GetForward()*725)
					end
				elseif !PoorSap:IsNextBot() then
					PoorSap:SetGroundEntity(NULL)
					PoorSap:SetLocalVelocity(self:GetUp()*65 +self:GetForward()*725)
				end
			elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
				ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
                PoorSap:SetGroundEntity(NULL)
				PoorSap:TakeDamage( ((275*self.KLK_OwnDMGMult) * self.KLK_ValorDamageBonus) + (PoorSap:Health()*0.011) + (PoorSap:Armor()*0.033), self, PoorSap )
				PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
				PoorSap:SetLocalVelocity(self:GetUp()*65 +self:GetForward()*725)
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:LaunchingTackle()
	if IsValid(self) then
		for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter(),100)) do
			if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:Disposition(PoorSap) == 1 then
				if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
				self.KLK_DashLaunchCharging = false
				PoorSap:TakeDamage(((PoorSap:GetMaxHealth()*0.036) + 1000) * self.KLK_ValorDamageBonus, self, self)
				PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
				ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
				ParticleEffect( "martialhit_star", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )				
				if PoorSap:IsNextBot() then
					if PoorSap.DrG_IsKLK == true then
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*375 +self:GetForward()*325)
					elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
						PoorSap:LeaveGround()
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*375 +self:GetForward()*325)
					end
				elseif !PoorSap:IsNextBot() then
					PoorSap:SetGroundEntity(NULL)
					PoorSap:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*325)
				end
			elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
				if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
				self.KLK_DashLaunchCharging = false
                PoorSap:SetGroundEntity(NULL)
				ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
				ParticleEffect( "martialhit_star", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
				PoorSap:TakeDamage( ((1000*self.KLK_OwnDMGMult) * self.KLK_ValorDamageBonus) + (PoorSap:Health()*0.036) + (PoorSap:Armor()*0.108), self, PoorSap )
				PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
				PoorSap:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*325)
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:AirTackle()
	if IsValid(self) then
		for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter() +self:GetForward()*(self.KLK_AttackRange*0.5),self.KLK_AttackRange*0.5)) do
			if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:Disposition(PoorSap) == 1 then
				if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
				self.KLK_DashAirCharging = false
				PoorSap:TakeDamage(((PoorSap:GetMaxHealth()*0.028) + 800) * self.KLK_ValorDamageBonus, self, self)
				
				PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
				local Effect = EffectData()
				Effect:SetOrigin(PoorSap:GetPos() +PoorSap:OBBCenter())
				Effect:SetAngles(PoorSap:GetAngles())
				util.Effect("PunchShockwaveSmall",Effect,true,true)
				ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
				ParticleEffect( "martialhit_heavy", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )		
				if PoorSap:IsNextBot() then
					if PoorSap.DrG_IsKLK == true then
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*400 +self:GetForward()*125)
					elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
						PoorSap:LeaveGround()
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*400 +self:GetForward()*125)
					end
				elseif !PoorSap:IsNextBot() then
					PoorSap:SetGroundEntity(NULL)
					PoorSap:SetLocalVelocity(self:GetUp()*425 +self:GetForward()*125)
				end
			elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
				if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
				self.KLK_DashAirCharging = false
                PoorSap:SetGroundEntity(NULL)
				local Effect = EffectData()
				Effect:SetOrigin(PoorSap:GetPos() +PoorSap:OBBCenter())
				Effect:SetAngles(PoorSap:GetAngles())
				util.Effect("PunchShockwaveSmall",Effect,true,true)
				ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
				ParticleEffect( "martialhit_heavy", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )			
				PoorSap:TakeDamage( ((800*self.KLK_OwnDMGMult) * self.KLK_ValorDamageBonus) + (PoorSap:Health()*0.028) + (PoorSap:Armor()*0.084), self, PoorSap )
				PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
				PoorSap:SetLocalVelocity(self:GetUp()*150 +self:GetForward()*75)
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:ShoulderTackle()
	if IsValid(self) then
		for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter() +self:GetForward()*(self.KLK_AttackRange*0.5),self.KLK_AttackRange*0.5)) do
			if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:Disposition(PoorSap) == 1 then
				if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
				self.KLK_DashGroundCharging = false
				PoorSap:TakeDamage(((PoorSap:GetMaxHealth()*0.036) + 1000) * self.KLK_ValorDamageBonus, self, self)
				PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
				local Effect = EffectData()
				Effect:SetOrigin(PoorSap:GetPos() +PoorSap:OBBCenter())
				Effect:SetAngles(PoorSap:GetAngles())
				util.Effect("PunchShockwaveSmall",Effect,true,true)
				ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
				ParticleEffect( "martialhit_heavy", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )						
				if PoorSap:IsNextBot() then
					if PoorSap.DrG_IsKLK == true then
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
					elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
						PoorSap:LeaveGround()
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
					end
				elseif !PoorSap:IsNextBot() then
					PoorSap:SetGroundEntity(NULL)
					PoorSap:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
				end
			elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
				if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
				self.KLK_DashGroundCharging = false
                PoorSap:SetGroundEntity(NULL)
				ParticleEffect( "klk_soundbarrier", self:GetPos() +self:OBBCenter() +self:GetForward()*25, self:GetAngles(), self )
				ParticleEffect( "martialhit_star", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )	
				PoorSap:TakeDamage( ((1000*self.KLK_OwnDMGMult) * self.KLK_ValorDamageBonus) + (PoorSap:Health()*0.036) + (PoorSap:Armor()*0.108), self, PoorSap )
				PoorSap:EmitSound("KLK-IF.HitSFX.Martial"..math.random(1,3))
				PoorSap:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:WhilePatrolling()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnReachedPatrol()
	self:Wait(math.random(3, 7))
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnIdle()
	self:AddPatrolPos(self:RandomPos(1500))
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnChaseEnemy()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnTakeDamage(dmg, hg)
	if self.KLK_IsDefeated == true or self:Health() <= 0 then return end
	if self.KLK_ValorBursting == true then
		self.KLK_ValorSoak = self.KLK_ValorSoak + (dmg:GetDamage()/4)
		self.KLK_ValorHits = self.KLK_ValorHits + 1
	end
	if self.KLK_ImmuneTime > CurTime() then dmg:ScaleDamage(0) return end
	self.KLK_ValorHitLimit = self.KLK_ValorHitLimit + dmg:GetDamage()
	if dmg:GetInflictor():IsPlayer() then
		if GetConVar("drg_killlakill_easymode"):GetBool() then dmg:ScaleDamage((1/self.KLK_ValorDamageBonus)*self.KLK_PlyDMGMult) else dmg:ScaleDamage((0.2/self.KLK_ValorDamageBonus)*self.KLK_PlyDMGMult) end
	elseif dmg:GetAttacker().DrG_IsKLK == true or (IsValid(dmg:GetInflictor()) && IsValid(dmg:GetInflictor():GetOwner()) && dmg:GetInflictor():GetOwner().DrG_IsKLK == true) then
		dmg:ScaleDamage(1/self.KLK_ValorDamageBonus)
	else
		dmg:ScaleDamage(0.2/self.KLK_ValorDamageBonus)
	end
	if self.KLK_ValorHitLimit >= (11000*self.KLK_ValorDamageBonus) && self.KLK_DisableValor == false then 
		dmg:ScaleDamage(0)
		self:KLK_ValorBurst()
	return end
	dmg:SetDamage(math.Clamp(dmg:GetDamage() - ((100*self.KLK_ValorArmor)*self.KLK_ValorArmorBonus), 0, dmg:GetDamage()))
	if dmg:GetDamage() > 10 then
		self.KLK_TookDmgTime = CurTime() + 5
	end
	self.KLK_IsDodging = false
	local waterdata   = {}
	local waterlength = Vector(0,0,2500)
	waterdata.start   = self:LocalToWorld(self:OBBCenter())
	waterdata.endpos  = waterdata.start + waterlength
	waterdata.filter  = self
	local sploosh = util.TraceLine(waterdata) 
	local splotchdata   = {}
	splotchdata.start   = sploosh.HitPos
	splotchdata.endpos  = waterdata.start - waterlength
	splotchdata.filter  = self
	splotchdata.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
	local waterline = util.TraceLine(splotchdata)
	if self.KLK_IsAttacking == false then
		if dmg:GetDamage() <= (1500*self.KLK_ValorPoiseBonus) then
			if self:GetCooldown("NextRyukoDodge") <= 0 && dmg:GetDamage() > 10 && self.KLK_IsKnocked == false && self.KLK_ValorMode == false then
				if self:IsOnGround() then
					if self.KLK_BlockMode == false then
						self.KLK_BlockMode = true
						if hg == 0 or hg == 2 or hg == 4 or hg == 5 or hg == 6 or hg == 7 then
							dmg:ScaleDamage(0.001/self.KLK_ValorDamageBonus)
						else
							dmg:ScaleDamage(0.2/self.KLK_ValorDamageBonus)
						end
						self.IdleAnimation = "blockstart"
						self.WalkAnimation = "blockstart"
						self.RunAnimation = "blockstart"
						self:KLK_ResetAttacks()
					elseif self.KLK_BlockMode == true && self.KLK_IsBlocking == false then
						self.KLK_BlockTime = CurTime() + 0.125
						if hg == 1 or hg == 3 or hg == 8 then
							dmg:ScaleDamage(0.2/self.KLK_ValorDamageBonus)
						else
							dmg:ScaleDamage(0.001/self.KLK_ValorDamageBonus)
						end
						if self.KLK_KnockHits >= math.random(20) && self.KLK_DisableCounter == false && self.KLK_RyukoMeter >= 50 && self:GetCooldown("NextRyukoValor") <= 0 then
							dmg:ScaleDamage(0)
							self.KLK_KnockHits = 0
							self:KLK_ResetAttacks()
							self:KLK_CounterBurst()
						else
							self:KLK_ResetAttacks()
							self.KLK_KnockHits = self.KLK_KnockHits + 1
							self.KLK_IsBlocking = true
							self:KLK_CICO(function()
								self.KLK_IsBlocking = false
								self:PlaySequenceAndMove("BlockHit", 1, function()
									self:FaceEnemy()
									if self.KLK_IsBlocking == true then 
										return true
									end
								end)
							end)
						end
					end
				else
					if self.KLK_IsFlinching == false && self:GetCooldown("NextRyukoFlinch") <= 0 then
						self:SetCooldown("NextRyukoFlinch",0.1)
						if hg == 1 or hg == 3 or hg == 8 then
							dmg:ScaleDamage(0.2/self.KLK_ValorDamageBonus)
						else
							dmg:ScaleDamage(0.001/self.KLK_ValorDamageBonus)
						end
						self:KLK_ResetAttacks()
						self.KLK_IsFlinching = true
						self:SetVelocity(self:GetForward()*-250 +self:GetUp()*0)
						self:KLK_CICO(function()
							self.KLK_IsFlinching = false
							self:PlaySequenceAndMove("attackairparry", 1, function()
								self:FaceEnemy()
								if self.KLK_IsBlocking == true then 
									return true
								end
							end)
						end)
					end
				end
			end
		else
			if self.KLK_RyukoParry >= 10 && self:IsOnGround() && self.KLK_DisableValParry == false && self:GetCooldown("NextRyukoValParry") <= 0 && self.KLK_IsKnocked == false then
				dmg:ScaleDamage(0)
				self:KLK_ValorParry()
			else
				if self.KLK_KnockHits >= math.random(10) && self.KLK_DisableCounter == false && self.KLK_RyukoMeter >= 50 && self:GetCooldown("NextRyukoValor") <= 0 then
					dmg:ScaleDamage(0)
					self:KLK_WeaponSwitch()
					self.KLK_KnockHits = 0
					self:KLK_ResetAttacks()
					self:KLK_CounterBurst()
				else
					self.KLK_KnockHits = self.KLK_KnockHits + 1
					if dmg:GetDamage() <= (3000*self.KLK_ValorPoiseBonus) then
						self:KLK_FlinchMedium()
					else
						self:KLK_FlinchHeavy()
					end
				end
			end
		end
	elseif self.KLK_IsAttacking == true && dmg:GetDamage() > 0 then
		if self.KLK_CanParry == true && self.KLK_IsFlinching == false && self.KLK_IsKnocked == false && dmg:GetDamage() > (100*self.KLK_ValorPoiseBonus) then
			self.KLK_CanParry = false
			if dmg:GetDamage() >= (1500*self.KLK_ValorPoiseBonus) then 
				if self.KLK_RyukoParry >= 10 && self:IsOnGround() && self.KLK_DisableValParry == false && self:GetCooldown("NextRyukoValParry") <= 0 && self.KLK_IsKnocked == false then
					dmg:ScaleDamage(0)
					self:KLK_ValorParry()
				else
					if self.KLK_KnockHits >= math.random(10) && self.KLK_DisableCounter == false && self.KLK_RyukoMeter >= 50 && self:GetCooldown("NextRyukoValor") <= 0 then
						dmg:ScaleDamage(0)
						self:KLK_WeaponSwitch()
						self.KLK_KnockHits = 0
						self:KLK_ResetAttacks()
						self:KLK_CounterBurst()
					else
						self.KLK_KnockHits = self.KLK_KnockHits + 1
						if dmg:GetDamage() <= (3000*self.KLK_ValorPoiseBonus) then
							self:KLK_FlinchMedium()
						else
							self:KLK_FlinchHeavy()
						end
					end
				end
			return end
			self.KLK_ParryTime = CurTime() + 0.05
			dmg:ScaleDamage(0)
			self:EmitSound("KLK-IF.Ryuko.Recover")
			self:KLK_ResetAttacks()
			self:KLK_WeaponSwitch()
			if self:IsOnGround() then 
				self:KLK_CICO(function()
					self:PlaySequenceAndMove("attackparry", 1, function(self,cycle)
						self:FaceEnemy()
						if self.KLK_IsFlinching == true /*or (cycle >= 0.75 && IsValid(self:GetEnemy()))*/ then 
							return true
						end
					end)
				end)
			else 
				self:SetVelocity(self:GetForward()*-250 +self:GetUp()*0)
				self:KLK_CICO(function()
					self:PlaySequenceAndMove("attackairparry", 1, function(self,cycle)
						self:FaceEnemy()
						if self.KLK_IsFlinching == true /*or (cycle >= 0.75 && IsValid(self:GetEnemy()))*/ then 
							return true
						end
					end)
				end)
			end
		elseif self.KLK_CanParry == false && self.KLK_ParryTime < CurTime() then
			if self.KLK_RyukoParry >= 10 && self:IsOnGround() && self.KLK_DisableValParry == false && self:GetCooldown("NextRyukoValParry") <= 0 && self.KLK_IsKnocked == false then
				dmg:ScaleDamage(0)
				self:KLK_ValorParry()
			else
				if self.KLK_BlockHits >= math.random(10) && self:IsOnGround() && self:GetCooldown("NextRyukoDodge") <= 0 && self.KLK_IsKnocked == false then
					self:KLK_WeaponSwitch()
					self.KLK_IsDodging = true
					self.KLK_BlockHits = 0
					self.KLK_ImmuneTime = CurTime() + 0.75
					self:SetCooldown("NextRyukoDodge",0.75)
					local EvadeRand = table.Random(self.GroundDodgeAnims)
					self:KLK_ResetAttacks()
					self:EmitSound("KLK-IF.Ryuko.Jump")
					self:KLK_CICO(function()
						self:PlaySequenceAndMove(EvadeRand, 1, function(self,cycle)
							self.KLK_DashTime = CurTime() + 0.425
							if cycle > 0.65 && IsValid(self:GetEnemy()) then
								self.KLK_IsDodging = false
								return true
							elseif cycle > 0.95 then
								self.KLK_IsDodging = false
							end
						end)
					end)
				else
					self:KLK_WeaponSwitch()
					if self.KLK_IsFlinching == false && self:GetCooldown("NextRyukoFlinch") <= 0 then
						self:SetCooldown("NextRyukoFlinch",0.1)
						self.KLK_BlockHits = self.KLK_BlockHits + 1
						if (dmg:GetDamage() >= (100*self.KLK_ValorPoiseBonus) && dmg:GetDamage() <= (1000*self.KLK_ValorPoiseBonus)) then
							if self:IsOnGround() && !dmg:IsExplosionDamage() && self.KLK_IsKnocked == false then
								if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 1, 0, 100 ) end
								self:EmitSound("KLK-IF.Ryuko.PainLight")
								local FlinchAnim = nil
								if hg == 1 or hg == 8 then
									if dmg:GetDamage() > (500*self.KLK_ValorPoiseBonus) then
										FlinchAnim = "hitheadheavy"
									else
										FlinchAnim = "hitheadlight"
									end
								elseif hg == 2 then
									FlinchAnim = "hitchest"
								elseif hg == 3 then
									if dmg:GetDamage() > (500*self.KLK_ValorPoiseBonus) then
										FlinchAnim = "hitstomachheavy"
									else
										FlinchAnim = "hitstomachlight"
									end
								elseif hg == 4 then
									FlinchAnim = "hitfaceleft"
								elseif hg == 5 then
									FlinchAnim = "hitfaceright"
								elseif hg == 6 then
									FlinchAnim = "hitlegleft"
								elseif hg == 7 then
									FlinchAnim = "hitlegright"
								elseif hg == 0 then
									FlinchAnim = table.Random(self.MultiFlinchAnims)
								end
								self.KLK_IsFlinching = true
								self:KLK_ResetAttacks()
								if self:WaterLevel() >= 1 && waterline.Hit then ParticleEffect("klk_water_block", waterline.HitPos, self:GetAngles(), nil) elseif self:IsOnGround() then ParticleEffectAttach( "dust_block", 4, self, 0 ) end
								self:KLK_CICO(function()
									self.KLK_IsFlinching = false
									self:PlaySequenceAndMove(FlinchAnim, 1, function(self,cycle)
										self:FaceEnemy()
										if self.KLK_IsFlinching == true then 
											return true
										end
									end)
								end)
							else
								if self.KLK_KnockHits >= math.random(10) && self.KLK_DisableCounter == false && self.KLK_RyukoMeter >= 50 && self:GetCooldown("NextRyukoValor") <= 0 then
									dmg:ScaleDamage(0)
									self:KLK_WeaponSwitch()
									self.KLK_KnockHits = 0
									self:KLK_ResetAttacks()
									self:KLK_CounterBurst()
								else
									self.KLK_KnockHits = self.KLK_KnockHits + 1
									self:KLK_FlinchMedium()
								end
							end
						elseif dmg:GetDamage() >= (1000*self.KLK_ValorPoiseBonus) then
							if self.KLK_KnockHits >= math.random(10) && self.KLK_DisableCounter == false && self.KLK_RyukoMeter >= 50 && self:GetCooldown("NextRyukoValor") <= 0 then
								dmg:ScaleDamage(0)
								self:KLK_WeaponSwitch()
								self.KLK_KnockHits = 0
								self:KLK_ResetAttacks()
								self:KLK_CounterBurst()
							else
								self.KLK_KnockHits = self.KLK_KnockHits + 1
								if dmg:GetDamage() <= (2000*self.KLK_ValorPoiseBonus) then
									self:KLK_FlinchMedium()
								else
									self:KLK_FlinchHeavy()
								end
							end
						end
					end
				end
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_ValorParry()
	local ValParryType = "attackparry"
	if IsValid(self:GetEnemy()) && (self:GetPos():Distance(self:GetEnemy():GetPos()) <= ((125 * self.KLK_SizeDiff) * (1 + self:GetVelocity():Length()/1000))) then ValParryType = "attackvalorparry" end
	self:SetCooldown("NextRyukoValParry",0.75)
	self.KLK_RyukoParry = math.Clamp( self.KLK_RyukoParry - 10, 0, 100 )
	self.KLK_ImmuneTime = CurTime() + 0.875
	self.KLK_BlockMode = false
	self.KLK_IsBlocking = false
	self:ResetThemAll()
	self:KLK_ResetAttacks()
	self:KLK_WeaponSwitch()
	self.IdleAnimation = "idle"
	self.JumpAnimation = "jumpstart"
	self.WalkAnimation = "idletowalk"
	if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
		self.RunAnimation = "idletowalk"
	else
		if self.KLK_ValorLevel > 0 then
			self.RunAnimation = "idletosprint"
		else
			self.RunAnimation = "idletorun"
		end
	end
	self:KLK_CICO(function()
		self:PlaySequenceAndMove(ValParryType, 1, function(self,cycle)
			self:FaceEnemy()
			if cycle > 0.75 then return true end
		end)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_CounterBurst()
	if (self.KLK_IsDefeated == true or self:Health() <= 0) or self:GetCooldown("NextRyukoValor") > 1 then return end
	self:SetCooldown("NextRyukoValor",5)
	self:KLK_WeaponSwitch()
	self.KLK_ValorBursting = true
	self.KLK_KnockedLock = false
	self.KLK_BlockMode = false
	self.KLK_IsBlocking = false
	self.KLK_BlockHits = 0
	self.KLK_KnockHits = 0
	self.KLK_ImmuneTime = CurTime() + 1
	self.KLK_Charging = CurTime() + 0.5
	self:KLK_ResetAttacks()
	self:ResetThemAll()
	self.KLK_IsKnocked = false
	self.IdleAnimation = "idle"
	self.JumpAnimation = "jumpstart"
	self.WalkAnimation = "idletowalk"
	if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
		self.RunAnimation = "idletowalk"
	else
		if self.KLK_ValorLevel > 0 then
			self.RunAnimation = "idletosprint"
		else
			self.RunAnimation = "idletorun"
		end
	end
	self:KLK_CICO(function()
		self:PlaySequenceAndMove("counterburst", 1, function(self,cycle)
			if cycle < 0.1 then
				self:SetCooldown("NextRyukoDodge",5)
				self.KLK_IsKnocked = false
				self.IdleAnimation = "idle"
				self.JumpAnimation = "jumpstart"
				self.WalkAnimation = "idletowalk"
				if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
					self.RunAnimation = "idletowalk"
				else
					if self.KLK_ValorLevel > 0 then
						self.RunAnimation = "idletosprint"
					else
						self.RunAnimation = "idletorun"
					end
				end
			end
			if cycle >= 0.9 then
				self.KLK_ValorBursting = false
				self.KLK_ValorSoak = 0
				self.KLK_ValorHits = 1
				self.KLK_IsKnocked = false
				self.IdleAnimation = "idle"
				self.JumpAnimation = "jumpstart"
				self.WalkAnimation = "idletowalk"
				if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
					self.RunAnimation = "idletowalk"
				else
					if self.KLK_ValorLevel > 0 then
						self.RunAnimation = "idletosprint"
					else
						self.RunAnimation = "idletorun"
					end
				end
			end
		end)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_ValorBurst()
	if (self.KLK_IsDefeated == true or self:Health() <= 0) or self:GetCooldown("NextRyukoValor") > 1 or (self.KLK_NoLimits == false && self.KLK_ValorCount >= self.KLK_ValorLimit) then return end
	self.KLK_ValorCount = self.KLK_ValorCount + 1
	if !IsValid(self.ValorLights) then
		self.ValorLights = ents.Create("light_dynamic")
		self.ValorLights:SetPos(self:GetPos() +self:OBBCenter())
		self.ValorLights:SetKeyValue( "_light", "255 175 215 255" )
		self.ValorLights:SetKeyValue("distance", "100" )
		self.ValorLights:SetKeyValue("brightness", 4)
		self.ValorLights:SetOwner(self)
		self.ValorLights:SetParent(self)
		self.ValorLights:Spawn()
		self:DeleteOnRemove(self.ValorLights)
	end
	self:SetCooldown("NextRyukoValor",5)
	self:KLK_WeaponSwitch()
	self.KLK_CombatTime = CurTime() + 60
	self.KLK_BoredTimer = CurTime() + 60
	self.KLK_IsAttacking = false
	self.KLK_ValorBursting = true
	self.KLK_KnockedLock = false
	self.KLK_ValorLevel = self.KLK_ValorLevel + 1
	self.KLK_ValorArmorBonus = 3
	--self.KLK_ValorArmorBonus = self.KLK_ValorArmorBonus + (0.5 / math.Clamp(self.KLK_Handicap,1,10))
	self.KLK_ValorDamageBonus = self.KLK_ValorDamageBonus + (1 / math.Clamp(self.KLK_Handicap,1,10))
	--self.KLK_ValorPoiseBonus = self.KLK_ValorPoiseBonus + (1.5 / math.Clamp(self.KLK_Handicap,1,10))
	self.KLK_ValorRegenBonus = 2
	self.KLK_BlockHits = 0
	self.KLK_ImmuneTime = CurTime() + 4.5
	self.KLK_Charging = CurTime() + 2
	self:KLK_ResetAttacks()
	self:ResetThemAll()
	self.KLK_IsKnocked = false
	self.IdleAnimation = "idle"
	self.JumpAnimation = "jumpstart"
	self.WalkAnimation = "idletowalk"
	if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
		self.RunAnimation = "idletowalk"
	else
		self.RunAnimation = "idletosprint"
	end
	self.GroundDodgeAnims = {"rapiddashleft","rapiddashright","rapiddashback"}
	self.SideDodgeAnims = {"rapiddashleft","rapiddashright"}
	self.KLK_ThirteenthCombo_1 = "rapiddashfront"
	self.KLK_ThirteenthCombo_2 = "rapiddashback"
	self.KLK_ThirteenthCombo_3 = "rapiddashleft"
	self.KLK_ThirteenthCombo_4 = "rapiddashright"
	if self.KLK_DisableMusic == false then
		if self.KLK_ValorLevel == 3 then
			self.KLK_MusicTimer = CurTime() + 102
			self:KLK_StopMusic()
			self:EmitSound("KLK-IF.Ryuko.ValorModeTheme")
		elseif self.KLK_ValorLevel > 3 && self.KLK_MusicTimer < CurTime() then
			self.KLK_MusicTimer = CurTime() + 48
			self:KLK_StopMusic()
			self:EmitSound("KLK-IF.Ryuko.UnchallengedTheme")
		elseif self.KLK_ValorLevel <= 2 && self:Health() <= self:GetMaxHealth()*0.375 && self.KLK_MusicTimer < CurTime() then
			self.KLK_MusicTimer = CurTime() + 33
			self:KLK_StopMusic()
			self:EmitSound("KLK-IF.Ryuko.TriumphantTheme")
		end
	end
	self:KLK_CICO(function()
		self:PlaySequenceAndMove("valorburst", 1, function(self,cycle)
			if cycle < 0.1 then
				self:SetCooldown("NextRyukoDodge",10)
				self.KLK_IsKnocked = false
				self.IdleAnimation = "idle"
				self.JumpAnimation = "jumpstart"
				self.WalkAnimation = "idletowalk"
				if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
					self.RunAnimation = "idletowalk"
				else
					if self.KLK_ValorLevel > 0 then
						self.RunAnimation = "idletosprint"
					else
						self.RunAnimation = "idletorun"
					end
				end
			end
			if cycle >= 0.9 then
				self.KLK_ValorBursting = false
				self.KLK_ValorSoak = 0
				self.KLK_ValorHits = 1
				self.KLK_IsKnocked = false
				self.IdleAnimation = "idle"
				self.JumpAnimation = "jumpstart"
				self.WalkAnimation = "idletowalk"
				if self.KLK_RyukoStamina <= 50 or self:KLK_IsBored() then
					self.RunAnimation = "idletowalk"
				else
					if self.KLK_ValorLevel > 0 then
						self.RunAnimation = "idletosprint"
					else
						self.RunAnimation = "idletorun"
					end
				end
			end
		end)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_FlinchMedium()
	if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 2, 0, 100 ) end
	self:EmitSound("KLK-IF.Ryuko.PainHeavy")
	self.KLK_IsFlinching = true
	self.KLK_IsKnocked = true
	self.KLK_HitGroundLock = false
	if self.KLK_KnockedLock == false then
		self.KLK_KnockedLock = true
		/*if IsValid(self:GetEnemy()) && self:GetEnemy():IsPlayer() then
			self.KLK_KnockedTime = CurTime() + 5
		else
			self.KLK_KnockedTime = CurTime() + 10
		end*/
		self.KLK_KnockedTime = CurTime() + 10
	end
	self.KLK_CanParry = false
	self.KLK_BlockMode = false
	self.KLK_IsBlocking = false
	self:KLK_ResetAttacks()
	self:Jump(100)
	self:SetVelocity(self:GetUp()*150 +self:GetForward()*-75)
	self.JumpAnimation = "hitlaunchupfallloop"
	self.IdleAnimation = "hitlaunchupdrop"
	self.WalkAnimation = "hitlaunchupdrop"
	self.RunAnimation = "hitlaunchupdrop"
	self:KLK_CICO(function()
		self.KLK_IsFlinching = false
		self:PlaySequenceAndMove("hitlaunchup", 1, function(self,cycle)
			self:FaceEnemy()
			if self.KLK_IsFlinching == true then 
				return true
			end
		end)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_FlinchHeavy()
	if self.KLK_MeterCooldown <= CurTime() then self.KLK_RyukoMeter = math.Clamp( self.KLK_RyukoMeter + 4, 0, 100 ) end
	self:EmitSound("KLK-IF.Ryuko.PainHeavy")
	self.KLK_IsFlinching = true
	self.KLK_IsKnocked = true
	self.KLK_HitGroundLock = false
	if self.KLK_KnockedLock == false then
		self.KLK_KnockedLock = true
		if IsValid(self:GetEnemy()) && self:GetEnemy():IsPlayer() then
			self.KLK_KnockedTime = CurTime() + 5
		else
			self.KLK_KnockedTime = CurTime() + 10
		end
	end
	self.KLK_CanParry = false
	self.KLK_BlockMode = false
	self.KLK_IsBlocking = false
	self.KLK_RecoverTime = CurTime() + 1.5
	self.KLK_RollTime = CurTime() + 1.75
	self:KLK_ResetAttacks()
	self:Jump(100)
	self:SetVelocity(self:GetUp()*250 +self:GetForward()*-500)
	self.JumpAnimation = "wallsplatfallloop"
	self.IdleAnimation = "wallsplatendloop"
	self.WalkAnimation = "wallsplatendloop"
	self.RunAnimation = "wallsplatendloop"
	self:KLK_CICO(function()
		self.KLK_IsFlinching = false
		self:PlaySequenceAndMove("hitlaunchback", 1, function(self,cycle)
			self:FaceEnemy()
			if self.KLK_IsFlinching == true then 
				return true
			end
		end)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_CICO(callback)
	local oldThread = self.BehaveThread
	self.BehaveThread = coroutine.create(function()
		callback(self)
		self.BehaveThread = oldThread
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
  -- Animations/Sounds --
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnLeaveGround()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnLandOnGround()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnRemove()
	self:KLK_StopMusic()
	game.SetTimeScale(1)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnAnimEvent()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_StopMusic()
	if self.KLK_DisableMusic == false then
		self:StopSound("KLK-IF.Ryuko.FinisherTheme")
		self:StopSound("KLK-IF.Ryuko.LosingThemeShort")
		self:StopSound("KLK-IF.Ryuko.LosingThemeLong")
		self:StopSound("KLK-IF.Ryuko.TransformTheme")
		self:StopSound("KLK-IF.Ryuko.TriumphantTheme")
		self:StopSound("KLK-IF.Ryuko.UnchallengedTheme")
		self:StopSound("KLK-IF.Ryuko.ValorModeTheme")
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_StopBoosters()
	self:StopSound("KLK-IF.SpecialSFX.RocketsMini")
	self:StopSound("KLK-IF.SpecialSFX.Rockets")
	self:StopSound("KLK-IF.SpecialSFX.RocketsFinisher")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:KLK_WeaponSwitch()
	if self:GetBodygroup(2) == 1 or self:GetBodygroup(2) == 2 then
		self:SetBodygroup(2,0)
		self:EmitSound("KLK-IF.SpecialSFX.WeapSwitch")
		ParticleEffectAttach( "ss_weaponswitch_intro_star", 4, self, 11 )
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnDeath(dmg)
	self.KLK_IsDefeated = true
	self:ResetThemAll()
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self:StopParticles()
	self:PlaySequenceAndMove("defeatanimation")
	game.SetTimeScale(1)
	self:PauseCoroutine(3.5)
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
--=========================================================================================================================================--
-- DO NOT TOUCH --
--=========================================================================================================================================--
AddCSLuaFile()
DrGBase.AddNextbot(ENT)
--=========================================================================================================================================--
---------------------------------------------------------------------------------------------------------------------------------------------
--== PROJECTILES ==--
---------------------------------------------------------------------------------------------------------------------------------------------
local sbslashwave = {}
if not DrGBase then return end -- return if DrGBase isn't installed
sbslashwave.Base = "proj_drg_default"
-- Misc --
sbslashwave.IsDrGProjectile = true
sbslashwave.DrG_IsKLK = true
sbslashwave.PrintName = "Scissor Blade: Slash Wave"
sbslashwave.Category = "DrGBase"
sbslashwave.Models = {"models/hunter/misc/sphere075x075.mdl"}
sbslashwave.Spawnable = false
sbslashwave.AttachEffects = {""}
-- Physics --
sbslashwave.Physgun = false
sbslashwave.Gravgun = false
sbslashwave.Gravity = false
sbslashwave.Ground1Elev = 0
sbslashwave.Ground2Elev = 0
sbslashwave.FrontElev = 0
sbslashwave.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
sbslashwave.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function sbslashwave:Initialize()
	
	self.Entity:SetModel("models/hunter/misc/sphere075x075.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*1250)
	end
		
	self.LifeTime = CurTime() + 1
	
    ParticleEffectAttach( "kirakiraexp_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function sbslashwave:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbslashwave:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	ParticleEffect( "kirakiraslash_core", self:GetPos(), self:GetAngles(), nil )
	self:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbslashwave:Think()
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local Ground1ProjData = {}
	Ground1ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground1ProjData.endpos = self:GetPos() + Vector(0,0,-25)
	Ground1ProjData.filter = {self}
	local Ground1ProjTrace = util.TraceLine(Ground1ProjData)
	local Ground2ProjData = {}
	Ground2ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground2ProjData.endpos = self:GetPos() +Vector(0,0,-15)
	Ground2ProjData.filter = {self}
	local Ground2ProjTrace = util.TraceLine(Ground2ProjData)
	local FrontProjData = {}
	FrontProjData.start = self:GetPos()
	FrontProjData.endpos = self:GetPos() +self:GetForward()*125 +Vector(0,0,-20)
	FrontProjData.filter = {self}
	local FrontProjTrace = util.TraceLine(FrontProjData)
	if Ground1ProjTrace.HitWorld then
		self.Ground1Elev = 0
	elseif !Ground1ProjTrace.HitWorld && !Ground1ProjTrace.Entity:IsNPC() && !Ground1ProjTrace.Entity:IsPlayer() && !Ground1ProjTrace.Entity:IsNextBot() then
		self.Ground1Elev = -250
	end
	if Ground2ProjTrace.HitWorld then
		self.Ground2Elev = 375
	elseif !Ground2ProjTrace.HitWorld && !Ground2ProjTrace.Entity:IsNPC() && !Ground2ProjTrace.Entity:IsPlayer() && !Ground2ProjTrace.Entity:IsNextBot() then
		self.Ground2Elev = 0
	end
	if FrontProjTrace.HitWorld then
		self.FrontElev = 375
	elseif !FrontProjTrace.HitWorld && !FrontProjTrace.Entity:IsNPC() && !FrontProjTrace.Entity:IsPlayer() && !FrontProjTrace.Entity:IsNextBot() then
		self.FrontElev = 0
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*1250 +self.Entity:GetAngles():Up()*(self.Ground1Elev+self.Ground2Elev+self.FrontElev))
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbslashwave:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		entity:TakeDamage(((entity:GetMaxHealth()*0.02)+600)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
		end
		self:Explosion()
	elseif entity:IsPlayer() then
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		entity:TakeDamage( ((600*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.02) + (entity:Armor()*0.06), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		entity:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
		self:Explosion()
	end
	
end
-------------------------------------------------------------------------------------
function sbslashwave:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( sbslashwave, "proj_ryuko_sbslashwave" )
---------------------------------------------------------------------------------------------------------------------------------------------
local sbrampantblade = {}
if not DrGBase then return end -- return if DrGBase isn't installed
sbrampantblade.Base = "proj_drg_default"
-- Misc --
sbrampantblade.IsDrGProjectile = true
sbrampantblade.DrG_IsKLK = true
sbrampantblade.PrintName = "Scissor Blade: Rampant Blade"
sbrampantblade.Category = "DrGBase"
sbrampantblade.Models = {"models/hunter/tubes/tube1x1x3c.mdl"}
sbrampantblade.Spawnable = false
sbrampantblade.AttachEffects = {""}
-- Physics --
sbrampantblade.Physgun = false
sbrampantblade.Gravgun = false
sbrampantblade.Gravity = false
sbrampantblade.Ground1Elev = 0
sbrampantblade.Ground2Elev = 0
sbrampantblade.FrontElev = 0
sbrampantblade.NextHit = 0
sbrampantblade.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
sbrampantblade.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function sbrampantblade:Initialize()
	
	self.Entity:SetModel("models/hunter/tubes/tube1x1x3c.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	self.rampanteffect = ents.Create("prop_dynamic")
	self.rampanteffect:SetModel("models/hunter/tubes/tube4x4x05d.mdl")
	self.rampanteffect:PhysicsInit(SOLID_VPHYSICS)
	self.rampanteffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.rampanteffect:SetSolid(SOLID_VPHYSICS)
	self.rampanteffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.rampanteffect:SetMaterial("models/effects/comball_tape.mdl")
	self.rampanteffect:SetColor(Color(255,0,97,255))
	self.rampanteffect:DrawShadow( false )
	self.rampanteffect:SetPos(self.Entity:GetPos() +self:GetUp()*50 +self:GetForward()*-85)
	self.rampanteffect:SetAngles(self.Entity:GetAngles() +Angle(45,180,90))
	self.rampanteffect:Spawn()
	self.rampanteffect:Activate()
	self.rampanteffect:SetOwner(self.Entity)
	self.rampanteffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.rampanteffect)

	self.bladeeffectmain = ents.Create("prop_dynamic")
	self.bladeeffectmain:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectmain:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectmain:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectmain:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectmain:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectmain:DrawShadow( false )
	self.bladeeffectmain:SetBodygroup(0,3)
	self.bladeeffectmain:SetPos(self.Entity:GetPos() +self:GetUp()*50 +self:GetForward()*-90)
	self.bladeeffectmain:SetAngles(self.Entity:GetAngles() +Angle(-45,180,90))
	self.bladeeffectmain:Spawn()
	self.bladeeffectmain:Activate()
	self.bladeeffectmain:SetOwner(self.Entity)
	self.bladeeffectmain:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectmain)

	self.bladeeffectex_1 = ents.Create("prop_dynamic")
	self.bladeeffectex_1:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectex_1:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectex_1:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectex_1:DrawShadow( false )
	self.bladeeffectex_1:SetBodygroup(0,1)
	self.bladeeffectex_1:SetPos(self.Entity:GetPos() +self:GetUp()*35 +self:GetForward()*-105 +self:GetRight()*15)
	self.bladeeffectex_1:SetAngles(self.Entity:GetAngles() +Angle(135,190,90))
	self.bladeeffectex_1:Spawn()
	self.bladeeffectex_1:Activate()
	self.bladeeffectex_1:SetOwner(self.Entity)
	self.bladeeffectex_1:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectex_1)

	self.bladeeffectex_2 = ents.Create("prop_dynamic")
	self.bladeeffectex_2:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectex_2:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectex_2:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectex_2:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectex_2:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectex_2:DrawShadow( false )
	self.bladeeffectex_2:SetBodygroup(0,1)
	self.bladeeffectex_2:SetPos(self.Entity:GetPos() +self:GetUp()*35 +self:GetForward()*-105 +self:GetRight()*-15)
	self.bladeeffectex_2:SetAngles(self.Entity:GetAngles() +Angle(135,170,90))
	self.bladeeffectex_2:Spawn()
	self.bladeeffectex_2:Activate()
	self.bladeeffectex_2:SetOwner(self.Entity)
	self.bladeeffectex_2:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectex_2)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*1250)
	end
		
	self.LifeTime = CurTime() + 1.5
	
    ParticleEffectAttach( "kirakiraexp_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function sbrampantblade:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrampantblade:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrampantblade:Think()
	if IsValid(self.rampanteffect) then
        ParticleEffectAttach( "kirakira_synchronize", 4, self.rampanteffect, 0 )
	end
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local Ground1ProjData = {}
	Ground1ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground1ProjData.endpos = self:GetPos() + Vector(0,0,-25)
	Ground1ProjData.filter = {self}
	local Ground1ProjTrace = util.TraceLine(Ground1ProjData)
	local Ground2ProjData = {}
	Ground2ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground2ProjData.endpos = self:GetPos() +Vector(0,0,-15)
	Ground2ProjData.filter = {self}
	local Ground2ProjTrace = util.TraceLine(Ground2ProjData)
	local FrontProjData = {}
	FrontProjData.start = self:GetPos()
	FrontProjData.endpos = self:GetPos() +self:GetForward()*125 +Vector(0,0,-20)
	FrontProjData.filter = {self}
	local FrontProjTrace = util.TraceLine(FrontProjData)
	if Ground1ProjTrace.HitWorld then
		self.Ground1Elev = 0
	elseif !Ground1ProjTrace.HitWorld && !Ground1ProjTrace.Entity:IsNPC() && !Ground1ProjTrace.Entity:IsPlayer() && !Ground1ProjTrace.Entity:IsNextBot() then
		self.Ground1Elev = -250
	end
	if Ground2ProjTrace.HitWorld then
		self.Ground2Elev = 375
	elseif !Ground2ProjTrace.HitWorld && !Ground2ProjTrace.Entity:IsNPC() && !Ground2ProjTrace.Entity:IsPlayer() && !Ground2ProjTrace.Entity:IsNextBot() then
		self.Ground2Elev = 0
	end
	if FrontProjTrace.HitWorld then
		self.FrontElev = 375
	elseif !FrontProjTrace.HitWorld && !FrontProjTrace.Entity:IsNPC() && !FrontProjTrace.Entity:IsPlayer() && !FrontProjTrace.Entity:IsNextBot() then
		self.FrontElev = 0
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*1250 +self.Entity:GetAngles():Up()*(self.Ground1Elev+self.Ground2Elev+self.FrontElev))
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrampantblade:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && self.NextHit < CurTime() && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		ParticleEffect( "slashhit_heavy", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		ParticleEffect( "kirakiraslash_core", entity:GetPos(), entity:GetAngles(), entity )
		self.NextHit = CurTime() + 0.125
		entity:TakeDamage(((entity:GetMaxHealth()*0.0456)+1240)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Rampant")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*875)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*875)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*875)
		end
	elseif entity:IsPlayer() && self.NextHit < CurTime() then
		ParticleEffect( "slashhit_heavy", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		ParticleEffect( "kirakiraslash_core", entity:GetPos(), entity:GetAngles(), entity )
		self.NextHit = CurTime() + 0.5
		entity:TakeDamage( ((1240*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.0456) + (entity:Armor()*0.1368), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Rampant")
		entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*875)
	end
	
end
-------------------------------------------------------------------------------------
function sbrampantblade:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( sbrampantblade, "proj_ryuko_sbrampantblade" )
---------------------------------------------------------------------------------------------------------------------------------------------
local sbshockwave = {}
if not DrGBase then return end -- return if DrGBase isn't installed
sbshockwave.Base = "proj_drg_default"
-- Misc --
sbshockwave.IsDrGProjectile = true
sbshockwave.DrG_IsKLK = true
sbshockwave.PrintName = "Scissor Blade: Shock Wave"
sbshockwave.Category = "DrGBase"
sbshockwave.Models = {"models/hunter/misc/sphere075x075.mdl"}
sbshockwave.Spawnable = false
sbshockwave.AttachEffects = {""}
-- Physics --
sbshockwave.Physgun = false
sbshockwave.Gravgun = false
sbshockwave.Gravity = false
sbshockwave.StopMoving = false
sbshockwave.Ground1Elev = 0
sbshockwave.Ground2Elev = 0
sbshockwave.FrontElev = 0
sbshockwave.NextHit = CurTime() + 0.25
sbshockwave.NextEffect = 0
sbshockwave.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
sbshockwave.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function sbshockwave:Initialize()
	
	self.Entity:SetModel("models/hunter/misc/sphere075x075.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*750)
	end
		
	self.LifeTime = CurTime() + 0.5
	
    ParticleEffectAttach( "kirakiraexp_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function sbshockwave:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbshockwave:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbshockwave:Think()
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local Ground1ProjData = {}
	Ground1ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground1ProjData.endpos = self:GetPos() + Vector(0,0,-25)
	Ground1ProjData.filter = {self}
	local Ground1ProjTrace = util.TraceLine(Ground1ProjData)
	local Ground2ProjData = {}
	Ground2ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground2ProjData.endpos = self:GetPos() +Vector(0,0,-15)
	Ground2ProjData.filter = {self}
	local Ground2ProjTrace = util.TraceLine(Ground2ProjData)
	local FrontProjData = {}
	FrontProjData.start = self:GetPos()
	FrontProjData.endpos = self:GetPos() +self:GetForward()*125 +Vector(0,0,-20)
	FrontProjData.filter = {self}
	local FrontProjTrace = util.TraceLine(FrontProjData)
	if Ground1ProjTrace.HitWorld then
		self.Ground1Elev = 0
	elseif !Ground1ProjTrace.HitWorld && !Ground1ProjTrace.Entity:IsNPC() && !Ground1ProjTrace.Entity:IsPlayer() && !Ground1ProjTrace.Entity:IsNextBot() then
		self.Ground1Elev = -250
	end
	if Ground2ProjTrace.HitWorld then
		self.Ground2Elev = 375
	elseif !Ground2ProjTrace.HitWorld && !Ground2ProjTrace.Entity:IsNPC() && !Ground2ProjTrace.Entity:IsPlayer() && !Ground2ProjTrace.Entity:IsNextBot() then
		self.Ground2Elev = 0
	end
	if FrontProjTrace.HitWorld then
		self.FrontElev = 375
	elseif !FrontProjTrace.HitWorld && !FrontProjTrace.Entity:IsNPC() && !FrontProjTrace.Entity:IsPlayer() && !FrontProjTrace.Entity:IsNextBot() then
		self.FrontElev = 0
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) && self.StopMoving == false then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*750 +self.Entity:GetAngles():Up()*(self.Ground1Elev+self.Ground2Elev+self.FrontElev))
	end
	if self.NextEffect < CurTime() then
		self.NextEffect = CurTime() + 0.25
		self:EmitSound("KLK-IF.AttackSFX.EnergyExp")
		ParticleEffect( "kirakirashock_core", self:GetPos(), self:GetAngles(), self )
		self.lighteffect = ents.Create("light_dynamic")
		self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
		self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
		self.lighteffect:SetKeyValue("distance", "250" )
		self.lighteffect:SetKeyValue("brightness", 6)
		self.lighteffect:Spawn()
		self.lighteffect:Fire("kill", "", 0.25)
		if IsValid(self:GetOwner()) then
			for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter(),50)) do
				if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:GetOwner():Disposition(PoorSap) == 1 then
					PoorSap:TakeDamage((PoorSap:GetMaxHealth()*(0.00656*self.DMGBonus))+(264*self.DMGBonus), self:GetOwner(), self)
					PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
					if PoorSap:IsNextBot() then
						if PoorSap.DrG_IsKLK == true then
							--PoorSap:Jump(100)
							PoorSap:SetVelocity(self:GetUp()*250 +self:GetForward()*375)
						elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
							PoorSap:LeaveGround()
							--PoorSap:Jump(100)
							PoorSap:SetVelocity(self:GetUp()*250 +self:GetForward()*375)
						end
					elseif !PoorSap:IsNextBot() then
						PoorSap:SetGroundEntity(NULL)
						PoorSap:SetLocalVelocity(self:GetUp()*250 +self:GetForward()*375)
					end
				elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
					PoorSap:SetGroundEntity(NULL)
					ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
					PoorSap:TakeDamage( ((264*self.OwnDMGBonus) * self.DMGBonus) + (PoorSap:Health()*0.00656) + (PoorSap:Armor()*0.01968), self, PoorSap )
					PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					PoorSap:SetLocalVelocity(self:GetUp()*250 +self:GetForward()*375)
				end
			end
		end
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbshockwave:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && self.NextHit < CurTime() && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		ParticleEffect( "kirakirashock_core", entity:GetPos(), entity:GetAngles(), entity )
		entity:TakeDamage(((entity:GetMaxHealth()*0.0197)+593)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*250 +self:GetForward()*375)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*250 +self:GetForward()*375)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*250 +self:GetForward()*375)
		end
	elseif entity:IsPlayer() && self.NextHit < CurTime() then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		ParticleEffect( "kirakirashock_core", entity:GetPos(), entity:GetAngles(), entity )
		entity:TakeDamage( ((593*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.0197) + (entity:Armor()*0.0591), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		entity:SetLocalVelocity(self:GetUp()*250 +self:GetForward()*375)
	end
	
end
-------------------------------------------------------------------------------------
function sbshockwave:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self.StopMoving = true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( sbshockwave, "proj_ryuko_sbshockwave" )
---------------------------------------------------------------------------------------------------------------------------------------------
local sbambushingslice = {}
if not DrGBase then return end -- return if DrGBase isn't installed
sbambushingslice.Base = "proj_drg_default"
-- Misc --
sbambushingslice.IsDrGProjectile = true
sbambushingslice.DrG_IsKLK = true
sbambushingslice.PrintName = "Scissor Blade: Rampant Blade"
sbambushingslice.Category = "DrGBase"
sbambushingslice.Models = {"models/hunter/misc/sphere075x075.mdl"}
sbambushingslice.Spawnable = false
sbambushingslice.AttachEffects = {""}
-- Physics --
sbambushingslice.Physgun = false
sbambushingslice.Gravgun = false
sbambushingslice.Gravity = false
sbambushingslice.StopMoving = false
sbambushingslice.Ground1Elev = 0
sbambushingslice.Ground2Elev = 0
sbambushingslice.FrontElev = 0
sbambushingslice.NextHit = CurTime() + 0.25
sbambushingslice.NextEffect = 0
sbambushingslice.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
sbambushingslice.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function sbambushingslice:Initialize()
	
	self.Entity:SetModel("models/hunter/misc/sphere075x075.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*500)
	end
		
	self.LifeTime = CurTime() + 1
	self.NextEffect = CurTime() + 0.25
	
    ParticleEffectAttach( "kirakiraexp_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function sbambushingslice:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbambushingslice:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbambushingslice:Think()
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local Ground1ProjData = {}
	Ground1ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground1ProjData.endpos = self:GetPos() + Vector(0,0,-25)
	Ground1ProjData.filter = {self}
	local Ground1ProjTrace = util.TraceLine(Ground1ProjData)
	local Ground2ProjData = {}
	Ground2ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground2ProjData.endpos = self:GetPos() +Vector(0,0,-15)
	Ground2ProjData.filter = {self}
	local Ground2ProjTrace = util.TraceLine(Ground2ProjData)
	local FrontProjData = {}
	FrontProjData.start = self:GetPos()
	FrontProjData.endpos = self:GetPos() +self:GetForward()*125 +Vector(0,0,-20)
	FrontProjData.filter = {self}
	local FrontProjTrace = util.TraceLine(FrontProjData)
	if Ground1ProjTrace.HitWorld then
		self.Ground1Elev = 0
	elseif !Ground1ProjTrace.HitWorld && !Ground1ProjTrace.Entity:IsNPC() && !Ground1ProjTrace.Entity:IsPlayer() && !Ground1ProjTrace.Entity:IsNextBot() then
		self.Ground1Elev = -250
	end
	if Ground2ProjTrace.HitWorld then
		self.Ground2Elev = 375
	elseif !Ground2ProjTrace.HitWorld && !Ground2ProjTrace.Entity:IsNPC() && !Ground2ProjTrace.Entity:IsPlayer() && !Ground2ProjTrace.Entity:IsNextBot() then
		self.Ground2Elev = 0
	end
	if FrontProjTrace.HitWorld then
		self.FrontElev = 375
	elseif !FrontProjTrace.HitWorld && !FrontProjTrace.Entity:IsNPC() && !FrontProjTrace.Entity:IsPlayer() && !FrontProjTrace.Entity:IsNextBot() then
		self.FrontElev = 0
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) && self.StopMoving == false then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*500 +self.Entity:GetAngles():Up()*(self.Ground1Elev+self.Ground2Elev+self.FrontElev))
	end
	if self.NextEffect < CurTime() then
		self.NextEffect = CurTime() + 0.25
		self:EmitSound("KLK-IF.AttackSFX.EnergyExp")
		ParticleEffect( "kirakirashock_core", self:GetPos(), self:GetAngles(), self )
		self.lighteffect = ents.Create("light_dynamic")
		self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
		self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
		self.lighteffect:SetKeyValue("distance", "250" )
		self.lighteffect:SetKeyValue("brightness", 6)
		self.lighteffect:Spawn()
		self.lighteffect:Fire("kill", "", 0.25)
		if IsValid(self:GetOwner()) then
			for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter(),50)) do
				if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:GetOwner():Disposition(PoorSap) == 1 then
					PoorSap:TakeDamage((PoorSap:GetMaxHealth()*(0.00668*self.DMGBonus))+(267*self.DMGBonus), self:GetOwner(), self)
					PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
				if PoorSap:IsNextBot() then
					if PoorSap.DrG_IsKLK == true then
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
					elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
						PoorSap:LeaveGround()
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
					end
				elseif !PoorSap:IsNextBot() then
					PoorSap:SetGroundEntity(NULL)
					PoorSap:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
				end
				elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
					PoorSap:SetGroundEntity(NULL)
					ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
					PoorSap:TakeDamage( ((267*self.OwnDMGBonus) * self.DMGBonus) + (PoorSap:Health()*0.00668) + (PoorSap:Armor()*0.02004), self, PoorSap )
					PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					PoorSap:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
				end
			end
		end
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbambushingslice:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && self.NextHit < CurTime() && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos(), entity:GetAngles(), entity )
		ParticleEffect( "kirakirashock_core", entity:GetPos(), entity:GetAngles(), entity )
		entity:TakeDamage(((entity:GetMaxHealth()*0.0267)+767)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*125)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*125)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*125)
		end
	elseif entity:IsPlayer() && self.NextHit < CurTime() then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos(), entity:GetAngles(), entity )
		ParticleEffect( "kirakirashock_core", entity:GetPos(), entity:GetAngles(), entity )
		entity:TakeDamage( ((767*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.0267) + (entity:Armor()*0.0801), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*125)
	end
	
end
-------------------------------------------------------------------------------------
function sbambushingslice:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self.StopMoving = true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( sbambushingslice, "proj_ryuko_sbambushingslice" )
---------------------------------------------------------------------------------------------------------------------------------------------
local dmkamaitachi = {}
if not DrGBase then return end -- return if DrGBase isn't installed
dmkamaitachi.Base = "proj_drg_default"
-- Misc --
dmkamaitachi.IsDrGProjectile = true
dmkamaitachi.DrG_IsKLK = true
dmkamaitachi.PrintName = "Scissor Blade: Rampant Blade"
dmkamaitachi.Category = "DrGBase"
dmkamaitachi.Models = {"models/hunter/misc/sphere075x075.mdl"}
dmkamaitachi.Spawnable = false
dmkamaitachi.AttachEffects = {""}
-- Physics --
dmkamaitachi.Physgun = false
dmkamaitachi.Gravgun = false
dmkamaitachi.Gravity = false
dmkamaitachi.StopMoving = false
dmkamaitachi.Ground1Elev = 0
dmkamaitachi.Ground2Elev = 0
dmkamaitachi.FrontElev = 0
dmkamaitachi.NextHit = CurTime() + 0.25
dmkamaitachi.NextEffect = 0
dmkamaitachi.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
dmkamaitachi.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function dmkamaitachi:Initialize()
	
	self.Entity:SetModel("models/hunter/misc/sphere075x075.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*500)
	end
		
	self.LifeTime = CurTime() + 2.25
	self.NextEffect = CurTime() + 0.25
	
    ParticleEffectAttach( "kirakiraexp_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function dmkamaitachi:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function dmkamaitachi:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function dmkamaitachi:Think()
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local Ground1ProjData = {}
	Ground1ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground1ProjData.endpos = self:GetPos() + Vector(0,0,-25)
	Ground1ProjData.filter = {self}
	local Ground1ProjTrace = util.TraceLine(Ground1ProjData)
	local Ground2ProjData = {}
	Ground2ProjData.start = self:GetPos() + Vector(0,0,5)
	Ground2ProjData.endpos = self:GetPos() +Vector(0,0,-15)
	Ground2ProjData.filter = {self}
	local Ground2ProjTrace = util.TraceLine(Ground2ProjData)
	local FrontProjData = {}
	FrontProjData.start = self:GetPos()
	FrontProjData.endpos = self:GetPos() +self:GetForward()*125 +Vector(0,0,-20)
	FrontProjData.filter = {self}
	local FrontProjTrace = util.TraceLine(FrontProjData)
	if Ground1ProjTrace.HitWorld then
		self.Ground1Elev = 0
	elseif !Ground1ProjTrace.HitWorld && !Ground1ProjTrace.Entity:IsNPC() && !Ground1ProjTrace.Entity:IsPlayer() && !Ground1ProjTrace.Entity:IsNextBot() then
		self.Ground1Elev = -250
	end
	if Ground2ProjTrace.HitWorld then
		self.Ground2Elev = 375
	elseif !Ground2ProjTrace.HitWorld && !Ground2ProjTrace.Entity:IsNPC() && !Ground2ProjTrace.Entity:IsPlayer() && !Ground2ProjTrace.Entity:IsNextBot() then
		self.Ground2Elev = 0
	end
	if FrontProjTrace.HitWorld then
		self.FrontElev = 375
	elseif !FrontProjTrace.HitWorld && !FrontProjTrace.Entity:IsNPC() && !FrontProjTrace.Entity:IsPlayer() && !FrontProjTrace.Entity:IsNextBot() then
		self.FrontElev = 0
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) && self.StopMoving == false then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*500 +self.Entity:GetAngles():Up()*(self.Ground1Elev+self.Ground2Elev+self.FrontElev))
	end
	if self.NextEffect < CurTime() then
		self.NextEffect = CurTime() + 0.25
		self:EmitSound("KLK-IF.AttackSFX.EnergyExp")
		ParticleEffect( "kirakirashock_core", self:GetPos(), self:GetAngles(), self )
		self.lighteffect = ents.Create("light_dynamic")
		self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
		self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
		self.lighteffect:SetKeyValue("distance", "250" )
		self.lighteffect:SetKeyValue("brightness", 6)
		self.lighteffect:Spawn()
		self.lighteffect:Fire("kill", "", 0.25)
		if IsValid(self:GetOwner()) then
			for _, PoorSap in pairs(ents.FindInSphere(self:GetPos() +self:OBBCenter(),50)) do
				if IsValid(PoorSap) && (PoorSap:IsNPC() or PoorSap:IsNextBot()) && self:GetOwner():Disposition(PoorSap) == 1 then
					PoorSap:TakeDamage((PoorSap:GetMaxHealth()*(0.00733*self.DMGBonus))+(283*self.DMGBonus), self:GetOwner(), self)
					PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
				if PoorSap:IsNextBot() then
					if PoorSap.DrG_IsKLK == true then
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
					elseif PoorSap.DrG_IsKLK != true && PoorSap.IsDrGNextbot then
						PoorSap:LeaveGround()
						--PoorSap:Jump(100)
						PoorSap:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
					end
				elseif !PoorSap:IsNextBot() then
					PoorSap:SetGroundEntity(NULL)
					PoorSap:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
				end
				elseif IsValid(PoorSap) && PoorSap:IsPlayer() then
					PoorSap:SetGroundEntity(NULL)
					ParticleEffect( "slashhit_base", PoorSap:GetPos() +PoorSap:OBBCenter(), PoorSap:GetAngles(), PoorSap )
					PoorSap:TakeDamage( ((283*self.OwnDMGBonus) * self.DMGBonus) + (PoorSap:Health()*0.00733) + (PoorSap:Armor()*0.02199), self, PoorSap )
					PoorSap:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
					PoorSap:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
				end
			end
		end
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function dmkamaitachi:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && self.NextHit < CurTime() && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos(), entity:GetAngles(), entity )
		ParticleEffect( "kirakirashock_core", entity:GetPos(), entity:GetAngles(), entity )
		entity:TakeDamage(((entity:GetMaxHealth()*0.0293)+833)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*125)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*125)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*125)
		end
	elseif entity:IsPlayer() && self.NextHit < CurTime() then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos(), entity:GetAngles(), entity )
		ParticleEffect( "kirakirashock_core", entity:GetPos(), entity:GetAngles(), entity )
		entity:TakeDamage( ((833*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.0293) + (entity:Armor()*0.0879), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*125)
	end
	
end
-------------------------------------------------------------------------------------
function dmkamaitachi:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self.StopMoving = true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( dmkamaitachi, "proj_ryuko_dmkamaitachi" )
---------------------------------------------------------------------------------------------------------------------------------------------
local sbrangelight = {}
if not DrGBase then return end -- return if DrGBase isn't installed
sbrangelight.Base = "proj_drg_default"
-- Misc --
sbrangelight.IsDrGProjectile = true
sbrangelight.DrG_IsKLK = true
sbrangelight.PrintName = "Scissor Blade: Incision"
sbrangelight.Category = "DrGBase"
sbrangelight.Models = {"models/hunter/tubes/tube1x1x3c.mdl"}
sbrangelight.Spawnable = false
sbrangelight.AttachEffects = {""}
-- Physics --
sbrangelight.Physgun = false
sbrangelight.Gravgun = false
sbrangelight.Gravity = false
sbrangelight.Ground1Elev = 0
sbrangelight.Ground2Elev = 0
sbrangelight.FrontElev = 0
sbrangelight.NextHit = 0
sbrangelight.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
sbrangelight.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function sbrangelight:Initialize()
	
	self.Entity:SetModel("models/hunter/tubes/circle2x2c.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	self.rampanteffect = ents.Create("prop_dynamic")
	self.rampanteffect:SetModel("models/hunter/tubes/circle2x2c.mdl")
	self.rampanteffect:PhysicsInit(SOLID_VPHYSICS)
	self.rampanteffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.rampanteffect:SetSolid(SOLID_VPHYSICS)
	self.rampanteffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.rampanteffect:SetMaterial("models/effects/comball_tape.mdl")
	self.rampanteffect:SetColor(Color(255,0,97,255))
	self.rampanteffect:DrawShadow( false )
	self.rampanteffect:SetPos(self.Entity:GetPos())
	self.rampanteffect:SetAngles(self.Entity:GetAngles())
	self.rampanteffect:Spawn()
	self.rampanteffect:Activate()
	self.rampanteffect:SetOwner(self.Entity)
	self.rampanteffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.rampanteffect)

	self.bladeeffectmain = ents.Create("prop_dynamic")
	self.bladeeffectmain:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectmain:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectmain:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectmain:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectmain:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectmain:DrawShadow( false )
	self.bladeeffectmain:SetModelScale(0.5)
	self.bladeeffectmain:SetBodygroup(0,0)
	self.bladeeffectmain:SetPos(self.Entity:GetPos() +self:GetForward()*-25)
	self.bladeeffectmain:SetAngles(self.Entity:GetAngles())
	self.bladeeffectmain:Spawn()
	self.bladeeffectmain:Activate()
	self.bladeeffectmain:SetOwner(self.Entity)
	self.bladeeffectmain:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectmain)

	self.bladeeffectex_1 = ents.Create("prop_dynamic")
	self.bladeeffectex_1:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectex_1:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectex_1:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectex_1:DrawShadow( false )
	self.bladeeffectex_1:SetModelScale(0.5)
	self.bladeeffectex_1:SetBodygroup(0,0)
	self.bladeeffectex_1:SetPos(self.Entity:GetPos() +self:GetUp()*5 +self:GetForward()*-25)
	self.bladeeffectex_1:SetAngles(self.Entity:GetAngles() +Angle(0,0,180))
	self.bladeeffectex_1:Spawn()
	self.bladeeffectex_1:Activate()
	self.bladeeffectex_1:SetOwner(self.Entity)
	self.bladeeffectex_1:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectex_1)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*1250)
	end
		
	self.LifeTime = CurTime() + 5
	
    ParticleEffectAttach( "kirakirarange_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function sbrangelight:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangelight:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	ParticleEffect( "kirakiraslash_core", self:GetPos(), self:GetAngles(), nil )
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangelight:Think()
	if IsValid(self.rampanteffect) then
        ParticleEffectAttach( "kirakira_synchronize", 4, self.rampanteffect, 0 )
	end
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*1250)
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangelight:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		entity:TakeDamage(((entity:GetMaxHealth()*0.02)+600)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*125 +self:GetForward()*375)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
		end
		self:Explosion()
	elseif entity:IsPlayer() then
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		entity:TakeDamage( ((600*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.02) + (entity:Armor()*0.06), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		entity:SetLocalVelocity(self:GetUp()*125 +self:GetForward()*375)
		self:Explosion()
	end
	
end
-------------------------------------------------------------------------------------
function sbrangelight:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( sbrangelight, "proj_ryuko_sbrangelight" )
---------------------------------------------------------------------------------------------------------------------------------------------
local sbrangemedium = {}
if not DrGBase then return end -- return if DrGBase isn't installed
sbrangemedium.Base = "proj_drg_default"
-- Misc --
sbrangemedium.IsDrGProjectile = true
sbrangemedium.DrG_IsKLK = true
sbrangemedium.PrintName = "Scissor Blade: Laceration"
sbrangemedium.Category = "DrGBase"
sbrangemedium.Models = {"models/hunter/tubes/tube1x1x3c.mdl"}
sbrangemedium.Spawnable = false
sbrangemedium.AttachEffects = {""}
-- Physics --
sbrangemedium.Physgun = false
sbrangemedium.Gravgun = false
sbrangemedium.Gravity = false
sbrangemedium.Ground1Elev = 0
sbrangemedium.Ground2Elev = 0
sbrangemedium.FrontElev = 0
sbrangemedium.NextHit = 0
sbrangemedium.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
sbrangemedium.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function sbrangemedium:Initialize()
	
	self.Entity:SetModel("models/hunter/tubes/circle2x2c.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	self.rampanteffect = ents.Create("prop_dynamic")
	self.rampanteffect:SetModel("models/hunter/tubes/circle2x2c.mdl")
	self.rampanteffect:PhysicsInit(SOLID_VPHYSICS)
	self.rampanteffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.rampanteffect:SetSolid(SOLID_VPHYSICS)
	self.rampanteffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.rampanteffect:SetMaterial("models/effects/comball_tape.mdl")
	self.rampanteffect:SetColor(Color(255,0,97,255))
	self.rampanteffect:DrawShadow( false )
	self.rampanteffect:SetPos(self.Entity:GetPos())
	self.rampanteffect:SetAngles(self.Entity:GetAngles())
	self.rampanteffect:Spawn()
	self.rampanteffect:Activate()
	self.rampanteffect:SetOwner(self.Entity)
	self.rampanteffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.rampanteffect)

	self.bladeeffectmain = ents.Create("prop_dynamic")
	self.bladeeffectmain:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectmain:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectmain:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectmain:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectmain:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectmain:DrawShadow( false )
	self.bladeeffectmain:SetModelScale(0.5)
	self.bladeeffectmain:SetBodygroup(0,1)
	self.bladeeffectmain:SetPos(self.Entity:GetPos() +self:GetForward()*-25)
	self.bladeeffectmain:SetAngles(self.Entity:GetAngles())
	self.bladeeffectmain:Spawn()
	self.bladeeffectmain:Activate()
	self.bladeeffectmain:SetOwner(self.Entity)
	self.bladeeffectmain:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectmain)

	self.bladeeffectex_1 = ents.Create("prop_dynamic")
	self.bladeeffectex_1:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectex_1:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectex_1:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectex_1:DrawShadow( false )
	self.bladeeffectex_1:SetModelScale(0.5)
	self.bladeeffectex_1:SetBodygroup(0,1)
	self.bladeeffectex_1:SetPos(self.Entity:GetPos() +self:GetUp()*5 +self:GetForward()*-25)
	self.bladeeffectex_1:SetAngles(self.Entity:GetAngles() +Angle(0,0,180))
	self.bladeeffectex_1:Spawn()
	self.bladeeffectex_1:Activate()
	self.bladeeffectex_1:SetOwner(self.Entity)
	self.bladeeffectex_1:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectex_1)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*2500)
	end
		
	self.LifeTime = CurTime() + 5
	
    ParticleEffectAttach( "kirakirarange_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function sbrangemedium:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangemedium:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	ParticleEffect( "kirakirashock_core", self:GetPos(), self:GetAngles(), nil )
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangemedium:Think()
	if IsValid(self.rampanteffect) then
        ParticleEffectAttach( "kirakira_synchronize", 4, self.rampanteffect, 0 )
	end
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*2500)
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangemedium:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && self.NextHit < CurTime() && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		entity:TakeDamage(((entity:GetMaxHealth()*0.0197)+593)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*250 +self:GetForward()*375)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*250 +self:GetForward()*375)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*250 +self:GetForward()*375)
		end
		self:Explosion()
	elseif entity:IsPlayer() && self.NextHit < CurTime() then
		self.NextHit = CurTime() + 0.25
		ParticleEffect( "slashhit_base", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		entity:TakeDamage( ((593*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.0197) + (entity:Armor()*0.0591), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Energy")
		entity:SetLocalVelocity(self:GetUp()*250 +self:GetForward()*375)
		self:Explosion()
	end
	
end
-------------------------------------------------------------------------------------
function sbrangemedium:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( sbrangemedium, "proj_ryuko_sbrangemedium" )
---------------------------------------------------------------------------------------------------------------------------------------------
local sbrangeheavy = {}
if not DrGBase then return end -- return if DrGBase isn't installed
sbrangeheavy.Base = "proj_drg_default"
-- Misc --
sbrangeheavy.IsDrGProjectile = true
sbrangeheavy.DrG_IsKLK = true
sbrangeheavy.PrintName = "Scissor Blade: Evisceration"
sbrangeheavy.Category = "DrGBase"
sbrangeheavy.Models = {"models/hunter/tubes/tube1x1x3c.mdl"}
sbrangeheavy.Spawnable = false
sbrangeheavy.AttachEffects = {""}
-- Physics --
sbrangeheavy.Physgun = false
sbrangeheavy.Gravgun = false
sbrangeheavy.Gravity = false
sbrangeheavy.Ground1Elev = 0
sbrangeheavy.Ground2Elev = 0
sbrangeheavy.FrontElev = 0
sbrangeheavy.NextHit = 0
sbrangeheavy.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
sbrangeheavy.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function sbrangeheavy:Initialize()
	
	self.Entity:SetModel("models/hunter/tubes/circle4x4c.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	self.rampanteffect = ents.Create("prop_dynamic")
	self.rampanteffect:SetModel("models/hunter/tubes/circle4x4c.mdl")
	self.rampanteffect:PhysicsInit(SOLID_VPHYSICS)
	self.rampanteffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.rampanteffect:SetSolid(SOLID_VPHYSICS)
	self.rampanteffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.rampanteffect:SetMaterial("models/effects/comball_tape.mdl")
	self.rampanteffect:SetColor(Color(255,0,97,255))
	self.rampanteffect:DrawShadow( false )
	self.rampanteffect:SetPos(self.Entity:GetPos())
	self.rampanteffect:SetAngles(self.Entity:GetAngles())
	self.rampanteffect:Spawn()
	self.rampanteffect:Activate()
	self.rampanteffect:SetOwner(self.Entity)
	self.rampanteffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.rampanteffect)

	self.bladeeffectmain = ents.Create("prop_dynamic")
	self.bladeeffectmain:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectmain:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectmain:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectmain:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectmain:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectmain:DrawShadow( false )
	self.bladeeffectmain:SetBodygroup(0,0)
	self.bladeeffectmain:SetPos(self.Entity:GetPos() +self:GetForward()*-25)
	self.bladeeffectmain:SetAngles(self.Entity:GetAngles())
	self.bladeeffectmain:Spawn()
	self.bladeeffectmain:Activate()
	self.bladeeffectmain:SetOwner(self.Entity)
	self.bladeeffectmain:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectmain)

	self.bladeeffectex_1 = ents.Create("prop_dynamic")
	self.bladeeffectex_1:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.bladeeffectex_1:PhysicsInit(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetMoveType(MOVETYPE_VPHYSICS)
	self.bladeeffectex_1:SetSolid(SOLID_VPHYSICS)
	self.bladeeffectex_1:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.bladeeffectex_1:DrawShadow( false )
	self.bladeeffectex_1:SetBodygroup(0,0)
	self.bladeeffectex_1:SetPos(self.Entity:GetPos() +self:GetUp()*5 +self:GetForward()*-25)
	self.bladeeffectex_1:SetAngles(self.Entity:GetAngles() +Angle(0,0,180))
	self.bladeeffectex_1:Spawn()
	self.bladeeffectex_1:Activate()
	self.bladeeffectex_1:SetOwner(self.Entity)
	self.bladeeffectex_1:SetParent(self.Entity)
	self:DeleteOnRemove(self.bladeeffectex_1)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*3750)
	end
		
	self.LifeTime = CurTime() + 5
	
    ParticleEffectAttach( "kirakirarange_core", 1, self, 0 )
	
end
-------------------------------------------------------------------------------------
function sbrangeheavy:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangeheavy:Explosion()
	self.lighteffect = ents.Create("light_dynamic")
	self.lighteffect:SetPos(self:GetPos() +self:GetUp()*5)
	self.lighteffect:SetKeyValue( "_light", "255 75 115 255" )
	self.lighteffect:SetKeyValue("distance", "250" )
	self.lighteffect:SetKeyValue("brightness", 6)
	self.lighteffect:Spawn()
	self.lighteffect:Fire("kill", "", 0.25)
	ParticleEffect( "kirakirashock_core", self:GetPos(), self:GetAngles(), nil )
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangeheavy:Think()
	if IsValid(self.rampanteffect) then
        ParticleEffectAttach( "kirakira_synchronize", 4, self.rampanteffect, 0 )
	end
	if IsValid(self:GetOwner()) then
		self.DMGBonus = self:GetOwner().KLK_ValorDamageBonus
		if GetConVar("drg_killlakill_easymode"):GetBool() then
			self.OwnDMGBonus = 0.05
		else
			self.OwnDMGBonus = 1
		end
	else
		self.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
		self.OwnDMGBonus = 1
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*3750)
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function sbrangeheavy:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
	
	if (entity:IsNPC() or entity:IsNextBot()) && self.NextHit < CurTime() && ((IsValid(self:GetOwner()) && self:GetOwner():Disposition(entity) != D_LI) or !IsValid(self:GetOwner())) then
		ParticleEffect( "slashhit_heavy", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		self.NextHit = CurTime() + 0.5
		entity:TakeDamage(((entity:GetMaxHealth()*0.0456)+1240)*self.DMGBonus, self.Owner, self)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Rampant")
		if entity:IsNextBot() then
			if entity.DrG_IsKLK == true then
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*250)
			elseif entity.DrG_IsKLK != true && entity.IsDrGNextbot then
				entity:LeaveGround()
				--entity:Jump(100)
				entity:SetVelocity(self:GetUp()*375 +self:GetForward()*250)
			end
		elseif !entity:IsNextBot() then
			entity:SetGroundEntity(NULL)
			entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*250)
		end
	elseif entity:IsPlayer() && self.NextHit < CurTime() then
		ParticleEffect( "slashhit_heavy", entity:GetPos() +entity:OBBCenter(), entity:GetAngles(), entity )
		self.NextHit = CurTime() + 0.5
		entity:TakeDamage( ((1240*self.OwnDMGBonus) * self.DMGBonus) + (entity:Health()*0.0456) + (entity:Armor()*0.1368), self, entity )
		entity:SetGroundEntity(NULL)
		entity:EmitSound("KLK-IF.HitSFX.Slash"..math.random(1,3))
		entity:EmitSound("KLK-IF.HitSFX.Rampant")
		entity:SetLocalVelocity(self:GetUp()*375 +self:GetForward()*250)
	end
	
end
-------------------------------------------------------------------------------------
function sbrangeheavy:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( sbrangeheavy, "proj_ryuko_sbrangeheavy" )
---------------------------------------------------------------------------------------------------------------------------------------------
local punchdustefx = {}
if not DrGBase then return end -- return if DrGBase isn't installed
punchdustefx.Base = "proj_drg_default"
-- Misc --
punchdustefx.IsDrGProjectile = true
punchdustefx.DrG_IsKLK = true
punchdustefx.PrintName = "Punch Effect: Dust Separation"
punchdustefx.Category = "DrGBase"
punchdustefx.Models = {"models/hunter/misc/sphere075x075.mdl"}
punchdustefx.Spawnable = false
punchdustefx.AttachEffects = {""}
-- Physics --
punchdustefx.Physgun = false
punchdustefx.Gravgun = false
punchdustefx.Gravity = false
punchdustefx.Tremor = false
punchdustefx.RagFinish = false
punchdustefx.TremorCount = 0
punchdustefx.TremorTime = CurTime()
punchdustefx.NextHit = CurTime() + 0.25
punchdustefx.NextEffect = 0
punchdustefx.DMGBonus = 1 / math.Clamp(GetConVar("drg_killlakill_handicap"):GetFloat(),1,10)
punchdustefx.OwnDMGBonus = 1

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function punchdustefx:Initialize()
	
	self.Entity:SetModel("models/hunter/misc/sphere075x075.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( true )
	self.Entity:DrawShadow( true )
	self.Entity:SetNoDraw( true )
	self.Entity:SetColor(Color(255,0,97,255))

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(50)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
		phys:SetVelocity(self.Entity:GetAngles():Forward()*2500)
	end
		
	self.LifeTime = CurTime() + 0.25
	
    ParticleEffectAttach( "dust_punch", 4, self, 0 )
	
end
-------------------------------------------------------------------------------------
function punchdustefx:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function punchdustefx:Explosion()
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function punchdustefx:Think()
	if self.Tremor == true && self.TremorCount < 10 && self.TremorTime <= CurTime() && self.RagFinish == false then
		self.TremorTime = CurTime() + 0.025
		self.TremorCount = self.TremorCount + 1
		util.ScreenShake(self:GetPos(),15,15,math.Rand(0.5,0.5),1048)
		local Effect = EffectData()
		Effect:SetOrigin(self:GetPos() +self:GetUp()*50)
		Effect:SetAngles(self:GetAngles())
		util.Effect("PunchShockwave",Effect,true,true)
	end
	local phys = self.Entity:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:SetVelocity(self.Entity:GetAngles():Forward()*2500)
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function punchdustefx:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
end
-------------------------------------------------------------------------------------
function punchdustefx:PhysicsCollide(data, physobj)
	if CLIENT then return end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( punchdustefx, "proj_ryuko_punchdustefx" )
---------------------------------------------------------------------------------------------------------------------------------------------
local ryukoslash_efx = {}
if not DrGBase then return end -- return if DrGBase isn't installed
ryukoslash_efx.Base = "proj_drg_default"
-- Misc --
ryukoslash_efx.IsDrGProjectile = true
ryukoslash_efx.DrG_IsKLK = true
ryukoslash_efx.PrintName = "Ryuko's Slash Effect"
ryukoslash_efx.Category = "DrGBase"
ryukoslash_efx.Models = {"models/ryuko/klk-if/slash/slashattack.mdl"}
ryukoslash_efx.Spawnable = false
ryukoslash_efx.AttachEffects = {""}
-- Physics --
ryukoslash_efx.Physgun = false
ryukoslash_efx.Gravgun = false
ryukoslash_efx.Gravity = false
ryukoslash_efx.NextChange = 0
ryukoslash_efx.NextGroup = 0

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function ryukoslash_efx:Initialize()
	
	self.Entity:SetModel("models/ryuko/klk-if/slash/slashattack.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.Entity:SetPos(self:GetPos())
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( false )
	self.Entity:DrawShadow( false )

	self.swordeffect = ents.Create("prop_dynamic")
	self.swordeffect:SetModel("models/ryuko/klk-if/slash/slashattack.mdl")
	self.swordeffect:PhysicsInit(SOLID_VPHYSICS)
	self.swordeffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.swordeffect:SetSolid(SOLID_VPHYSICS)
	self.swordeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.swordeffect:DrawShadow( false )
	self.swordeffect:SetNoDraw( true )
	self.swordeffect:SetPos(self.Entity:GetPos())
	self.swordeffect:SetAngles(self.Entity:GetAngles())
	self.swordeffect:Spawn()
	self.swordeffect:Activate()
	self.swordeffect:SetOwner(self.Entity)
	self.swordeffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.swordeffect)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(5)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
	end
		
	self.LifeTime = CurTime() + 1.25
	self.NextEffect = CurTime() + 0.025
	
end
-------------------------------------------------------------------------------------
function ryukoslash_efx:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukoslash_efx:Explosion()
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukoslash_efx:Think()
	if self.NextEffect < CurTime() && self.NextGroup < 4 then
		self.NextEffect = CurTime() + 0.025
		if IsValid(self) then
			self.swordeffect:Remove()
			self.swordeffect = ents.Create("prop_dynamic")
			self.swordeffect:SetModel("models/ryuko/klk-if/slash/slashattack.mdl")
			self.swordeffect:PhysicsInit(SOLID_VPHYSICS)
			self.swordeffect:SetMoveType(MOVETYPE_VPHYSICS)
			self.swordeffect:SetSolid(SOLID_VPHYSICS)
			self.swordeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.swordeffect:DrawShadow( false )
			self.swordeffect:SetPos(self.Entity:GetPos())
			self.swordeffect:SetAngles(self.Entity:GetAngles())
			self.swordeffect:Spawn()
			self.swordeffect:Activate()
			self.swordeffect:SetOwner(self.Entity)
			self.swordeffect:SetParent(self.Entity)
			self.swordeffect:SetBodygroup(0,self.NextGroup)
			self:DeleteOnRemove(self.swordeffect)
		end
		self.NextGroup = self.NextGroup + 1
	elseif self.NextEffect < CurTime() && self.NextGroup >= 4 then
		self:Remove()
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukoslash_efx:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
end
-------------------------------------------------------------------------------------
function ryukoslash_efx:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( ryukoslash_efx, "proj_ryuko_slash_efx" )
---------------------------------------------------------------------------------------------------------------------------------------------
local ryukoslashinv_efx = {}
if not DrGBase then return end -- return if DrGBase isn't installed
ryukoslashinv_efx.Base = "proj_drg_default"
-- Misc --
ryukoslashinv_efx.IsDrGProjectile = true
ryukoslashinv_efx.DrG_IsKLK = true
ryukoslashinv_efx.PrintName = "Ryuko's Slash Effect"
ryukoslashinv_efx.Category = "DrGBase"
ryukoslashinv_efx.Models = {"models/ryuko/klk-if/slash/slashattack_wide.mdl"}
ryukoslashinv_efx.Spawnable = false
ryukoslashinv_efx.AttachEffects = {""}
-- Physics --
ryukoslashinv_efx.Physgun = false
ryukoslashinv_efx.Gravgun = false
ryukoslashinv_efx.Gravity = false
ryukoslashinv_efx.NextChange = 0
ryukoslashinv_efx.NextGroup = 0

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function ryukoslashinv_efx:Initialize()
	
	self.Entity:SetModel("models/ryuko/klk-if/slash/slashattack_wide.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.Entity:SetPos(self:GetPos())
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( false )
	self.Entity:DrawShadow( false )

	self.swordeffect = ents.Create("prop_dynamic")
	self.swordeffect:SetModel("models/ryuko/klk-if/slash/slashattack_wide.mdl")
	self.swordeffect:PhysicsInit(SOLID_VPHYSICS)
	self.swordeffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.swordeffect:SetSolid(SOLID_VPHYSICS)
	self.swordeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.swordeffect:DrawShadow( false )
	self.swordeffect:SetNoDraw( true )
	self.swordeffect:SetPos(self.Entity:GetPos())
	self.swordeffect:SetAngles(self.Entity:GetAngles())
	self.swordeffect:Spawn()
	self.swordeffect:Activate()
	self.swordeffect:SetOwner(self.Entity)
	self.swordeffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.swordeffect)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(5)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
	end
		
	self.LifeTime = CurTime() + 1.25
	self.NextEffect = CurTime() + 0.025
	
end
-------------------------------------------------------------------------------------
function ryukoslashinv_efx:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukoslashinv_efx:Explosion()
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukoslashinv_efx:Think()
	if self.NextEffect < CurTime() && self.NextGroup < 4 then
		self.NextEffect = CurTime() + 0.025
		if IsValid(self) then
			self.swordeffect:Remove()
			self.swordeffect = ents.Create("prop_dynamic")
			self.swordeffect:SetModel("models/ryuko/klk-if/slash/slashattack_wide.mdl")
			self.swordeffect:PhysicsInit(SOLID_VPHYSICS)
			self.swordeffect:SetMoveType(MOVETYPE_VPHYSICS)
			self.swordeffect:SetSolid(SOLID_VPHYSICS)
			self.swordeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.swordeffect:DrawShadow( false )
			self.swordeffect:SetPos(self.Entity:GetPos())
			self.swordeffect:SetAngles(self.Entity:GetAngles())
			self.swordeffect:Spawn()
			self.swordeffect:Activate()
			self.swordeffect:SetOwner(self.Entity)
			self.swordeffect:SetParent(self.Entity)
			self.swordeffect:SetBodygroup(0,self.NextGroup)
			self:DeleteOnRemove(self.swordeffect)
		end
		self.NextGroup = self.NextGroup + 1
	elseif self.NextEffect < CurTime() && self.NextGroup >= 4 then
		self:Remove()
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukoslashinv_efx:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
end
-------------------------------------------------------------------------------------
function ryukoslashinv_efx:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( ryukoslashinv_efx, "proj_ryuko_slashinv_efx" )
---------------------------------------------------------------------------------------------------------------------------------------------
local ryukocleaver_efx = {}
if not DrGBase then return end -- return if DrGBase isn't installed
ryukocleaver_efx.Base = "proj_drg_default"
-- Misc --
ryukocleaver_efx.IsDrGProjectile = true
ryukocleaver_efx.DrG_IsKLK = true
ryukocleaver_efx.PrintName = "Ryuko's Slash Effect"
ryukocleaver_efx.Category = "DrGBase"
ryukocleaver_efx.Models = {"models/ryuko/klk-if/slash/slashattack_cleaver.mdl"}
ryukocleaver_efx.Spawnable = false
ryukocleaver_efx.AttachEffects = {""}
-- Physics --
ryukocleaver_efx.Physgun = false
ryukocleaver_efx.Gravgun = false
ryukocleaver_efx.Gravity = false
ryukocleaver_efx.NextChange = 0
ryukocleaver_efx.NextGroup = 0

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function ryukocleaver_efx:Initialize()
	
	self.Entity:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.Entity:SetPos(self:GetPos())
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( false )
	self.Entity:DrawShadow( false )

	self.swordeffect = ents.Create("prop_dynamic")
	self.swordeffect:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
	self.swordeffect:PhysicsInit(SOLID_VPHYSICS)
	self.swordeffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.swordeffect:SetSolid(SOLID_VPHYSICS)
	self.swordeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.swordeffect:SetModelScale(1.5)
	self.swordeffect:DrawShadow( false )
	self.swordeffect:SetNoDraw( true )
	self.swordeffect:SetPos(self.Entity:GetPos())
	self.swordeffect:SetAngles(self.Entity:GetAngles())
	self.swordeffect:Spawn()
	self.swordeffect:Activate()
	self.swordeffect:SetOwner(self.Entity)
	self.swordeffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.swordeffect)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(5)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
	end
		
	self.LifeTime = CurTime() + 1.25
	self.NextEffect = CurTime() + 0.025
	
end
-------------------------------------------------------------------------------------
function ryukocleaver_efx:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukocleaver_efx:Explosion()
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukocleaver_efx:Think()
	if self.NextEffect < CurTime() && self.NextGroup < 4 then
		self.NextEffect = CurTime() + 0.025
		if IsValid(self) then
			self.swordeffect:Remove()
			self.swordeffect = ents.Create("prop_dynamic")
			self.swordeffect:SetModel("models/ryuko/klk-if/slash/slashattack_cleaver.mdl")
			self.swordeffect:PhysicsInit(SOLID_VPHYSICS)
			self.swordeffect:SetMoveType(MOVETYPE_VPHYSICS)
			self.swordeffect:SetSolid(SOLID_VPHYSICS)
			self.swordeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.swordeffect:SetModelScale(1.5)
			self.swordeffect:DrawShadow( false )
			self.swordeffect:SetPos(self.Entity:GetPos())
			self.swordeffect:SetAngles(self.Entity:GetAngles())
			self.swordeffect:Spawn()
			self.swordeffect:Activate()
			self.swordeffect:SetOwner(self.Entity)
			self.swordeffect:SetParent(self.Entity)
			self.swordeffect:SetBodygroup(0,self.NextGroup)
			self:DeleteOnRemove(self.swordeffect)
		end
		self.NextGroup = self.NextGroup + 1
	elseif self.NextEffect < CurTime() && self.NextGroup >= 4 then
		self:Remove()
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukocleaver_efx:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
end
-------------------------------------------------------------------------------------
function ryukocleaver_efx:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( ryukocleaver_efx, "proj_ryuko_slashcleaver_efx" )
---------------------------------------------------------------------------------------------------------------------------------------------
local ryukomartial_efx = {}
if not DrGBase then return end -- return if DrGBase isn't installed
ryukomartial_efx.Base = "proj_drg_default"
-- Misc --
ryukomartial_efx.IsDrGProjectile = true
ryukomartial_efx.DrG_IsKLK = true
ryukomartial_efx.PrintName = "Ryuko's Slash Effect"
ryukomartial_efx.Category = "DrGBase"
ryukomartial_efx.Models = {"models/ryuko/klk-if/slash/martialattack.mdl"}
ryukomartial_efx.Spawnable = false
ryukomartial_efx.AttachEffects = {""}
-- Physics --
ryukomartial_efx.Physgun = false
ryukomartial_efx.Gravgun = false
ryukomartial_efx.Gravity = false
ryukomartial_efx.NextChange = 0
ryukomartial_efx.NextGroup = 0

if SERVER then
	--AddCSLuaFile()
-------------------------------------------------------------------------------------
function ryukomartial_efx:Initialize()
	
	self.Entity:SetModel("models/ryuko/klk-if/slash/martialattack.mdl")

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.Entity:SetPos(self:GetPos())
	self.Entity:SetAngles(self:GetAngles())
	self.Entity:SetTrigger( false )
	self.Entity:DrawShadow( false )

	self.martialeffect = ents.Create("prop_dynamic")
	self.martialeffect:SetModel("models/ryuko/klk-if/slash/martialattack.mdl")
	self.martialeffect:PhysicsInit(SOLID_VPHYSICS)
	self.martialeffect:SetMoveType(MOVETYPE_VPHYSICS)
	self.martialeffect:SetSolid(SOLID_VPHYSICS)
	self.martialeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.martialeffect:DrawShadow( false )
	self.martialeffect:SetNoDraw( true )
	self.martialeffect:SetPos(self.Entity:GetPos())
	self.martialeffect:SetAngles(self.Entity:GetAngles())
	self.martialeffect:Spawn()
	self.martialeffect:Activate()
	self.martialeffect:SetOwner(self.Entity)
	self.martialeffect:SetParent(self.Entity)
	self:DeleteOnRemove(self.martialeffect)

	local phys = self.Entity:GetPhysicsObject()
	if(phys:IsValid()) then 
		phys:SetMass(5)
		phys:SetDragCoefficient(0)
		phys:SetBuoyancyRatio(0)
		phys:EnableGravity(false)
		phys:EnableDrag(false)
		phys:Wake()
	end
		
	self.LifeTime = CurTime() + 1.25
	self.NextEffect = CurTime() + 0.025
	
end
-------------------------------------------------------------------------------------
function ryukomartial_efx:Draw()
	self.Entity:DrawModel()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukomartial_efx:Explosion()
	self.Entity:Remove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukomartial_efx:Think()
	if self.NextEffect < CurTime() && self.NextGroup < 4 then
		self.NextEffect = CurTime() + 0.025
		if IsValid(self) then
			self.martialeffect:Remove()
			self.martialeffect = ents.Create("prop_dynamic")
			self.martialeffect:SetModel("models/ryuko/klk-if/slash/martialattack.mdl")
			self.martialeffect:PhysicsInit(SOLID_VPHYSICS)
			self.martialeffect:SetMoveType(MOVETYPE_VPHYSICS)
			self.martialeffect:SetSolid(SOLID_VPHYSICS)
			self.martialeffect:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.martialeffect:DrawShadow( false )
			self.martialeffect:SetPos(self.Entity:GetPos())
			self.martialeffect:SetAngles(self.Entity:GetAngles())
			self.martialeffect:Spawn()
			self.martialeffect:Activate()
			self.martialeffect:SetOwner(self.Entity)
			self.martialeffect:SetParent(self.Entity)
			self.martialeffect:SetBodygroup(0,self.NextGroup)
			self:DeleteOnRemove(self.martialeffect)
		end
		self.NextGroup = self.NextGroup + 1
	elseif self.NextEffect < CurTime() && self.NextGroup >= 4 then
		self:Remove()
	end
	if self.LifeTime < CurTime() then
		self:Remove()
	end
	self:NextThink(CurTime())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ryukomartial_efx:Touch( entity ) 
	if not entity:IsValid() then return end
	if not self.Owner:IsValid() then return end
	if entity == self.Owner then return end
end
-------------------------------------------------------------------------------------
function ryukomartial_efx:PhysicsCollide(data, physobj)
	if CLIENT then return end
	if data.HitEntity:IsWorld() then
		self:Explosion()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
end
scripted_ents.Register( ryukomartial_efx, "proj_ryuko_martial_efx" )
---------------------------------------------------------------------------------------------------------------------------------------------
--== PARTICLES ==--
---------------------------------------------------------------------------------------------------------------------------------------------
game.AddParticles( "particles/ryuko_pfx.pcf" )
game.AddParticles( "particles/klk_blood_pfx.pcf" )
local particlename = {
"kirakirapillar", 
"kirakiraskill", 
"kirakiratiny", 
"kirakiratinylocal", 
"kirakiratransform", 
"kirakirawrist", 
"kirakirawristtiny", 
"kirakiralight", 
"kirakirarainbow1", 
"kirakirarainbow2", 
"kirakirarainbow3", 
"kirakirarainbow4", 
"kirakirarainbow5", 
"kirakirarainbow6", 
"kirakirawing_l", 
"kirakirawing_r", 
"kirakirawing_strip", 
"kirakirawing_floor", 
"kirakirastreaks_l", 
"kirakirastreaks_r", 
"kirakirapillarstreaks", 
"kirakiraflash", 
"dust_conquer", 
"dust_conquer_charge", 
"dust_conquer_ring", 
"dust_conquer_settle", 
"dust_conquer_sharp", 
"dust_conquer_specks", 
"dust_fear", 
"dust_fear_ring", 
"dust_fear_sharp", 
"dust_fear_wave", 
"dust_roll", 
"dust_sharp", 
"dust_sharp_ring", 
"dust_sharp_ring_upper", 
"dust_sharp_settle", 
"dust_sharp_shock", 
"dust_sharp_shockwave", 
"dust_soft", 
"dust_subjugate", 
"dust_subjugate_outer", 
"dust_subjugate_outer_settle", 
"dust_subjugate_ring", 
"mudrock", 
"slashhit_base", 
"slashhit_flash_1", 
"slashhit_flash_2", 
"slashhit_flash_3", 
"slashhit_flash_4", 
"slashhit_helper_1", 
"slashhit_helper_2", 
"slashhit_helper_3", 
"slashhit_helper_4", 
"slashhit_streak",
"slashhit_heavy",
"slashhit_heavy_crack_1",
"slashhit_heavy_crack_2",
"slashhit_heavy_helpings_1",
"slashhit_heavy_helpings_2",
"slashhit_heavy_helpings_3",
"slashhit_heavy_ring",
"slashhit_heavy_streak",
"martialhit_glow",
"martialhit_glow_bright",
"martialhit_helper_1",
"martialhit_helper_2",
"martialhit_helper_3",
"martialhit_helper_4",
"martialhit_pepper_1",
"martialhit_pepper_2",
"martialhit_pepper_3",
"martialhit_pepper_4",
"martialhit_pepper_5",
"martialhit_pepper_6",
"martialhit_pepper_7",
"martialhit_ring",
"martialhit_spike",
"martialhit_spike_shadow",
"martialhit_star",
"martialhit_starshadow",
"martialhit_starstreak_1",
"martialhit_starstreak_2",
"martialhit_starstreak_dark_1",
"martialhit_starstreak_dark_2",
"martialhit_heavy",
"martialhit_heavy_helper_base",
"martialhit_heavy_helper_1",
"martialhit_heavy_helper_2",
"martialhit_heavy_helper_3",
"martialhit_heavy_helper_4",
"martialhit_heavy_helper_5",
"martialhit_heavy_slowhelper_base",
"martialhit_heavy_slowhelper_1",
"martialhit_heavy_slowhelper_2",
"martialhit_heavy_slowhelper_3",
"martialhit_heavy_slowhelper_4",
"martialhit_heavy_slowhelper_5",
"martialhit_heavy_ring",
"dust_dash",
"dust_dash_mudrock",
"dust_dash_shadow",
"dust_dash_smoke",
"blockhit_glow",
"blockhit_pepper",
"blockhit_ring",
"blockhit_spike",
"blockhit_star",
"blockhit_starstreak_1",
"blockhit_starstreak_2",
"kirakiraanime_efx",
"kirakiraanime_efx_white",
"kirakiraexp_core",
"kirakiraexp_helper_1",
"kirakiraexp_helper_2",
"kirakiraexp_helper_3",
"kirakiraexp_helper_4",
"kirakiraexp_helper_5",
"kirakiraexp_orb",
"kirakirarange_core",
"kirakirarange_helper_1",
"kirakirarange_helper_2",
"kirakirarange_helper_3",
"kirakirarange_helper_4",
"kirakirarange_helper_5",
"kirakirarange_orb",
"kirakirahelper_1",
"kirakirahelper_2",
"kirakirahelper_3",
"kirakirahelper_4",
"kirakirahelper_5",
"kirakirahelper_6",
"kirakirahelper_7",
"klk_slashattack",
"klk_soundbarrier",
"kirakira_synchronize",
"dust_spin_ex",
"dust_spin_ex_mudrock",
"dust_spin_ex_suck",
"dust_spin_ex_rings",
"dust_spin_ex_wind_1",
"dust_spin_ex_wind_2",
"dust_spin_ex_wind_3",
"dust_spin_mudrock",
"kirakirashock_burst",
"kirakirashock_core",
"kirakirashock_flash",
"kirakirashock_floor",
"kirakirashock_ring",
"kirakirashock_helper_1",
"kirakirashock_helper_2",
"kirakirashock_helper_3",
"kirakirashock_helper_4",
"kirakirashock_helper_5",
"kirakiraslash_burst",
"kirakiraslash_core",
"kirakiraslash_flash",
"kirakiraslash_floor",
"kirakiraslash_helper_1",
"kirakiraslash_helper_2",
"kirakiraslash_helper_3",
"kirakiraslash_helper_4",
"kirakiraslash_helper_5",
"kirakirasmash_burst",
"kirakirasmash_core",
"kirakirasmash_flash",
"kirakirasmash_floor",
"ryu_actionlines",
"ryu_actionlines_floor",
"ryu_actionlines_floordust",
"ryu_actionlines_floorrocks",
"ryu_actionlines_floorwave",
"ryu_kirakiraburst",
"ryu_recover_ring",
"ryu_recover_star",
"ryu_recover_star_ex",
"ryu_recover_star_ex_1",
"ryu_recover_star_ex_2",
"ryu_recover_star_ex_3",
"ryu_valorblast",
"senketsu_jet",
"senketsu_jet_left",
"senketsu_jet_right",
"senketsu_jet_mini",
"senketsu_jet_mini_left",
"senketsu_jet_mini_right",
"senketsu_jet_finisher",
"senketsu_jet_finisher_left",
"senketsu_jet_finisher_right",
"senketsu_jet_stars",
"senketsu_jet_stars_l",
"senketsu_jet_stars_r",
"senketsu_jet_finisher_stars",
"senketsu_jet_finisher_stars_l",
"senketsu_jet_finisher_stars_r",
"senketsu_steam_b_l",
"senketsu_steam_b_r",
"senketsu_steam_t_c",
"senketsu_steam_t_l",
"senketsu_steam_t_r",
"ss_weaponswitch_intro_ring",
"ss_weaponswitch_intro_star",
"ss_weaponswitch_outro_ring",
"ss_weaponswitch_outro_star",
"ss_weaponswitch_next_ring",
"ss_weaponswitch_next_star",
"ss_weaponswitch_final_ring",
"ss_weaponswitch_final_star",
"dust_block",
"dust_block_l",
"dust_block_r",
"dust_block_sharp_l",
"dust_block_sharp_r",
"dust_fear_slash",
"dust_fear_slash_l",
"dust_fear_slash_r",
"dust_fear_slash_sharp_l",
"dust_fear_slash_sharp_r",
"dust_punch",
"dust_punch_mudrock",
"dust_punch_l",
"dust_punch_r",
"auraburst_sharp",
"auraburst_settle",
"finisherkira",
"finisherkira_bulb",
"finisherkira_burst",
"finisherkira_floor",
"finisherkira_pillar",
"finisherkira_ring",
"finisherkira_ring_floor",
"finisherkira_shiny",
"senketsu_pillar_burst",
"klkdash_up",
"klkdash_down",
"klkdash_left",
"klkdash_right",
"klkdash_forward",
"klkdash_backward",
"klkdash_air_left",
"klkdash_air_right",
"klkdash_air_forward",
"klkdash_air_backward",
"klkdash_up_ex",
"klkdash_down_ex",
"klkdash_left_ex",
"klkdash_right_ex",
"klkdash_forward_ex",
"klkdash_backward_ex",
"klkdash_air_left_ex",
"klkdash_air_right_ex",
"klkdash_air_forward_ex",
"klkdash_air_backward_ex",
"decapbodykira",
"satsukiflash",
"satsukikirakiratiny",
"satsukikirakiratransform",
"satsukilight",
"satsukilight_floor",
"satsukipillar",
"satsukipillarstreaks",
"satsukispiral1",
"satsukistreaks_l",
"satsukistreaks_r",
"satsukitinylocal",
"satsukiwing_l",
"satsukiwing_r",
"satsukiwing_strip", 
"satsukiwing_floor",
"sat_actionlines_floor",
"sat_kirakiraburst",
"klk_water_block",
"klk_water_block_l",
"klk_water_block_r",
"klk_water_block_sharp_l",
"klk_water_block_sharp_r",
"klk_water_block_splotch",
"klk_water_block_stream_l",
"klk_water_block_stream_r",
"klk_water_dash",
"klk_water_dash_shadow",
"klk_water_dash_smoke",
"klk_water_dash_splash",
"klk_water_dash_splotch",
"klk_water_dash_upheave",
"klk_water_drop",
"klk_water_drop_splotch",
"klk_water_drop_trail",
"klk_water_drop_upheave",
"klk_water_minisplash",
"klk_water_roll",
"klk_water_roll_plop",
"klk_water_roll_settle",
"klk_water_roll_splotch",
"klk_water_roll_upheave",
"klk_water_sharp",
"klk_water_sharp_plop",
"klk_water_sharp_splotch",
"klk_water_sharp_settle",
"klk_water_soft",
"klk_water_subjugate_outer",
"klk_water_subjugate_outer_settle",
"lifefiber_bleed",
"lifefiber_explode",
"lifefiber_flash",
"nui_poof",
"nui_poof_helpers",
"nui_flash",
"nui_kirakiraexp_orb",
"nui_kirakiraexp_flash",
"nui_kirakiraexp_helper_1",
"nui_kirakiraexp_helper_2",
"nui_kirakirarange_orb",
"nui_kirakirarange_core",
"nui_kirakirarange_helper_1",
"nui_kirakirarange_helper_2",
"nui_kirakiraburst",
"nui_kirakiraskill",
"nui_gettinjumped_burst",
"nui_gettinjumped_floor",
"nui_seriousmode_burst",
"nui_seriousmode_flash",
"nui_seriousmode_floor",
"nui_seriousmode_helper_1",
"nui_seriousmode_helper_2",
"nui_lifefiber_aura",
"nui_lifefiber_aura_helpers",
"nui_lifefiber_aura_ring",
"nui_lifefiber_bomb",
"nui_lifefiber_bomb_flash",
"nui_lifefiber_bomb_helpers_1",
"nui_lifefiber_bomb_helpers_2",
"nui_lifefiber_bomb_helpers_3",
"nui_lifefiber_bomb_ring",
"nui_lifefiber_bomb_smoke",
"nui_lifefiber_bomb_strings",
"nui_lifefiber_create",
"nui_lifefiber_enlarge",
"nui_lifefiber_enlarge_core",
"nui_kirahands",
"nui_kirakiraglory",
"kirakira_ryuko-3",
"kirakira_ryuko-3_floor",
"kirakira_satsuki-3",
"kirakira_satsuki-3_floor",
"kirakira_synchdust",
"lifefiber_bullet",
"lifefiber_string",
"lifefiber_laser_ball",
"lifefiber_laser_ball_helper",
"lifefiber_laser_burst",
"lifefiber_laser_flash",
"lifefiber_laser_head",
"lifefiber_laser_nova",
"lifefiber_laser_pillar",
"lifefiber_laser_solar",
"lifefiber_laser_death",
"lifefiber_laser_needle",
"lifefiber_laser_streaks",
"lifefiber_laser_tower",
"lifefiber_laser_hit",
"lifefiber_laser_glow",
"lifefiber_bullet_hit",
"lifefiber_bullet_strings",
"fearattack_blood",
"fearattack_blood_helper",
"fearattack_blood_pepper",
"fearattack_blood_extra",
"fearattack_blood_streaks",
"fearattack_ring",
"fearattack_star",
"fearattack_star_thin",
"lifefiber_Ryuko_vapor",
"lifefiber_Ryuko_explode",
"lifefiber_Ryuko_explode_floor",
"lifefiber_Ryuko_flash",
"lifefiber_Ryuko_implode",
"lifefiber_Ryuko_implode_floor",
"lifefiber_Ryuko_floorglare",
"lifefiber_Ryuko_wallglare",
"lifefiber_Ryuko_rainbowlights",
"lifefiber_Ryuko_rainbowglory",
"lifefiber_Ryuko_rainbowpillars",
"rag_kirakiraburst",
"rag_kirakiraexp_burst_1",
"rag_kirakiraexp_burst_2",
"rag_kirakiraexp_burst_3",
"rag_kirakiraexp_burst_4",
"rag_kirakiraexp_burst_5",
"rag_kirakiraexp_burst_6",
"rag_kirakiraexp_flash",
"rag_kirakiraexp_floor",
"rag_kirakiraexp_helper_1",
"rag_kirakiraexp_helper_2",
"rag_kirakiraskill",
"ragyobullet_intro_star",
"ragyobullet_intro_ring",
"ragyobullet_next_star",
"ragyobullet_next_ring",
"ragyobullet_outro_star",
"ragyobullet_outro_ring",
"ragyobullet_final_star",
"ragyobullet_final_ring"
}
---------------------------------------------------------------------------------------------------------------------------------------------
--PATH addons/realistichandcuffs/lua/entities/npc_bailer/cl_init.lua:
include('shared.lua')

function ENT:Initialize ()
	self.aps = 40
	self.lastRot = CurTime()
	self.curRot = 0
end

function ENT:Draw()
	self.curRot = self.curRot + (self.aps * (CurTime() - self.lastRot))
	if (self.curRot > 360) then self.curRot = self.curRot - 360 end
	self.lastRot = CurTime()
	
	local Maxs = self:LocalToWorld(self:OBBMaxs())
	local EntPos = self:GetPos()
	local TextPos = Vector(EntPos.x,EntPos.y,Maxs.z+8)
	local Text = RHandcuffsConfig.BailerText
	
	cam.Start3D2D(TextPos, Angle(180, self.curRot, -90), .1)
		draw.SimpleText(Text, "rhc_npc_text", 0, 0, Color(255,255,255,255), TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	cam.End3D2D()	
	cam.Start3D2D(TextPos, Angle(180, self.curRot + 180, -90), .1)
		draw.SimpleText(Text, "rhc_npc_text", 0, 0, Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
	
	self:DrawModel()	
end

function ENT:OnRemove( )
end	

--PATH addons/sl_main_system/lua/entities/npc_lezardboss.lua:

if not DrGBase then return end -- return if DrGBase isn't installed
ENT.Base = "drgbase_nextbot" -- DO NOT TOUCH (obviously)

local hitjoueur = {
	"mad_sfx_sololeveling/punch/se_Punch_FaceHit.ogg",
	"mad_sfx_sololeveling/punch/se_Punch_Hit01.ogg",
	"mad_sfx_sololeveling/punch/se_Punch_Hit02.ogg"
}

local swing_attack = {
	"mad_sfx_sololeveling/punch/chopper_Punch01.ogg",
	"mad_sfx_sololeveling/punch/chopper_Punch02.ogg",
	"mad_sfx_sololeveling/punch/chopper_Punch03.ogg"
}

-- Misc --
ENT.PrintName = "Chef des Homme L√©zard"
ENT.Category = "SL - NPC"
ENT.Models = {"models/mad_lezardboss.mdl"}
ENT.BloodColor = BLOOD_COLOR_RED
ENT.CollisionBounds = Vector(30, 30, 60)
ENT.type = "boss"

-- Stats --
ENT.xp = 6000
ENT.money = 100000
ENT.Damage = 300
ENT.SpawnHealth = 8500

ENT.WalkSpeed = 100
ENT.RunSpeed = 500

ENT.HPBarOffset = 35
ENT.HPBarScale = 0.5

-- Detection --
ENT.EyeBone = ""
ENT.EyeOffset = Vector(0, 0, 0)
ENT.EyeAngle = Angle(0, 0, 0)
ENT.SightFOV = 150
ENT.SightRange = 1000
ENT.MinLuminosity = 0
ENT.MaxLuminosity = 1
ENT.HearingCoefficient = 1

-- Sounds --
ENT.OnDamageSounds = {""}
ENT.OnDeathSounds = {""}

-- AI --
ENT.Omniscient = false
ENT.SpotDuration = 10
ENT.RangeAttackRange = 0
ENT.MeleeAttackRange = 100
ENT.ReachEnemyRange = 100
ENT.AvoidEnemyRange = 0

-- Relationships --
ENT.Factions = {FACTION_ZOMBIES}

-- Movements/animations --
ENT.WalkAnimation = ACT_WALK
ENT.WalkAnimRate = 1
ENT.RunAnimation = ACT_RUN
ENT.RunAnimRate = 1
ENT.IdleAnimation = ACT_IDLE
ENT.IdleAnimRate = 1

-- Possession --
ENT.PossessionEnabled = true

if SERVER then

	-- Init/Think --

	function ENT:CustomInitialize()
		self:SetDefaultRelationship(D_HT)
		self:DrawShadow(false)
		self:SetHP(self:Health())
		self:SetHPY(self:Health())
		self:SetModelScale(1.7)

		self.StartHealth = self:Health()

		self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE)
	
		timer.Simple(0, function()
			self:SetHP(self:Health())
			self:SetHPY(self:Health())
			self:SetDMGDealt(0)
		end)
	end


	if CLIENT then
		function ENT:CustomThink()
			if self:GetCooldown("DS1_"..self:GetClass().."_HPYDegrade") <= 0 then
				local var = self:GetHPY()
				self:SetDMGDealt(0)
				self:SetHPY(math.Clamp(var-(self.StartHealth/250),self:Health(),self.StartHealth))
			end
		end
	end

	-- AI --
ENT.Omniscient = false
ENT.SpotDuration = 10

local function SpotTimerName(self, ent)
    return "DrGBaseNB" .. self:GetCreationID() .. "SpotENT" .. ent:GetCreationID()
end

function ENT:SpotEntity(ent)
    if not IsValid(ent) then return end
    if GetConVar("ai_ignoreplayers"):GetBool() then return end
    if ent:IsPlayer() and not ent:Alive() then return end

    if ent:GetNoDraw() == false then
        local distanceThreshold = 300  -- D√©finissez ici la distance maximale d'aggro
        
        -- V√©rifiez si nous avons d√©j√† une cible
        if self.CurrentTarget and IsValid(self.CurrentTarget) then
            local currentDistance = self.CurrentTarget:GetPos():Distance(self:GetPos())
            if currentDistance > distanceThreshold then
                -- Si la cible actuelle est trop loin, r√©initialisez-la
                self:LoseEntity(self.CurrentTarget)
                self.CurrentTarget = nil
            else
                -- Si la cible est valide et √† port√©e, ne faites rien
                return
            end
        end

        if self:GetSpotDuration() == 0 then return end
        local spotted = self:HasSpotted(ent)
        self._DrGBaseLastTimeSpotted[ent] = CurTime()
        self._DrGBaseSpotted[ent] = true
        local disp = self:GetRelationship(ent, true)
        
        if disp == D_HT or disp == D_LI or disp == D_FR then
            self._DrGBaseRelationshipCachesSpotted[disp][ent] = true
        end
        
        self:UpdateKnownPosition(ent)
        
        if self._DrGBasePatrolSound and self._DrGBasePatrolSound:GetSound().Entity == ent then
            self:RemovePatrol(self._DrGBasePatrolSound)
        end
        
        if not spotted then
            self:OnSpotted(ent)
            self.CurrentTarget = ent  -- Enregistrer l'entit√© comme cible actuelle
            if ent:IsPlayer() then
                if ent:GetNoDraw() == true then
                    self:LoseEntity(ent)
                end
                net.Start("DrGBaseNextbotPlayerAwareness")
                net.WriteEntity(self)
                net.WriteBit(true)
                net.Send(ent)
            end
        end
        
        local timerName = SpotTimerName(self, ent)
        timer.Remove(timerName)
        if self:GetSpotDuration() <= 0 then return end
        
        timer.Create(timerName, self:GetSpotDuration(), 1, function()
            if not IsValid(self) or not IsValid(ent) then return end
            self:LoseEntity(ent)
            self.CurrentTarget = nil  -- R√©initialiser la cible actuelle
        end)
    end
end

function ENT:OnReachedPatrol()
end

function ENT:OnIdle()
end

	function ENT:OnMeleeAttack(enemy)
		if not IsValid(enemy) then return end
		if not IsValid(self) then return end
		self.cdAttack = self.cdAttack or 0
		if self.cdAttack < CurTime() then
			self.cdAttack = CurTime() + 1
			if self:Health() < 1 then return end
			self:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO )
			timer.Simple(0.7, function()
				if self:Health() < 1 then return end
				if IsValid(self) && IsValid(enemy) then
					if IsValid(self) && IsValid(enemy) && enemy:GetPos():Distance(self:GetPos()) < 450 then
						enemy:TakeDamage(self.Damage, self, self)	
						timer.Simple(0.001, function()
							if enemy:Health() <= 0 then
								local currentXP = enemy:getDarkRPVar("xp") or 0
								-- Calcule 50% de l'XP
								local xpToRemove = currentXP * 0.5
								-- Enl√®ve 50% de l'XP au joueur
								enemy:addXP(-xpToRemove)
				
								-- R√©initialise les cristaux
								enemy:SetDataItemSL_INV("crystal", 0)
								enemy:SetDataItemSL_INV("crystal2", 0)
								enemy:SetDataItemSL_INV("crystal3", 0)
								enemy:SetDataItemSL_INV("crystal4", 0)
							end
						end)
						enemy:EmitSound( hitjoueur[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO )	
					end
				end
			end)
			self:PlaySequenceAndMove("attack"..math.random(2), 1, self.FaceEnemy)
		end
	end




	-- Cr√©ez une table locale pour stocker les d√©g√¢ts inflig√©s par chaque joueur pour cet NPC sp√©cifique
	ENT.playerDamage = {}

	function ENT:OnTakeDamage(damage)
		self:SetHP(math.Clamp(self:Health()-damage:GetDamage(),0,self.StartHealth))
		self:SetCooldown("DS1_"..self:GetClass().."_HPYDegrade", 1.5)
		if IsValid(damage:GetAttacker()) and damage:GetAttacker():IsPlayer() then
			local attacker = damage:GetAttacker()

			-- Ajoutez les d√©g√¢ts inflig√©s √† la table du joueur pour cet NPC
			self.playerDamage[attacker] = (self.playerDamage[attacker] or 0) + damage:GetDamage()
		end
	end

	function ENT:OnDeath(dmginfo, hitgroup)
		local totalDamage = 0
		local eligiblePlayers = {} -- Tableau pour stocker les joueurs √©ligibles

		local ent = ents.Create("mad_crystal")
		ent:SetNWInt("item", "crystal4")
		ent:SetPos(self:GetPos())
		ent:Spawn()
	
		-- Calculez le total des d√©g√¢ts inflig√©s pour cet NPC
		for _, damage in pairs(self.playerDamage) do
			totalDamage = totalDamage + damage
		end
	
		-- Distribuez l'argent √©quitablement entre les joueurs
		if totalDamage > 0 then
			for player, damage in pairs(self.playerDamage) do
				local moneyEarned = math.floor(self.money * damage / totalDamage)
				local xpEarned = math.floor(self.xp * damage / totalDamage)
	
				if player:GetUserGroup() == "vip" then
					player:addXP(xpEarned*1.2,true,true)
					net.Start("SL:Notification")
					net.WriteString(self.PrintName.. " vaincu : + ".. xpEarned*1.2 .." XP")
					net.Send(player)
					player:addMoney(moneyEarned*1.2)
					net.Start("SL:Notification")
					net.WriteString("Vous avez gagnez : + ".. formatMoney(moneyEarned*1.2))
					net.Send(player)
				else
					player:addXP(xpEarned,true,true)
					net.Start("SL:Notification")
					net.WriteString(self.PrintName.. " vaincu : + "..xpEarned.." XP")
					net.Send(player)
					player:addMoney(moneyEarned)
					net.Start("SL:Notification")
					net.WriteString("Vous avez gagnez : + ".. formatMoney(moneyEarned))
					net.Send(player)
				end

				-- V√©rifier si le joueur est √©ligible pour une comp√©tence
				local playerLevel = player:getDarkRPVar("level")
				local playerClass = player:GetNWInt("Classe")
				for skillName, skillData in pairs(SKILLS_SL) do
					if skillData.classe == playerClass and playerLevel >= skillData.level then
						table.insert(eligiblePlayers, player)
						break
					end
				end
			end
		end
	
		-- Distribution des comp√©tences avec une chance de 10 % par joueur √©ligible
		for _, player in ipairs(eligiblePlayers) do
			if math.random() <= 0.2 then
				local playerClass = player:GetNWInt("Classe")
				local playerLevel = player:getDarkRPVar("level")
				local availableSkills = {} -- Tableau pour stocker les comp√©tences disponibles pour ce joueur
				for skillName, skillData in pairs(SKILLS_SL) do
					if skillData.classe == playerClass and playerLevel >= skillData.level and player:HasSkill(skillName) == false then
						if skillData.ismagie == false then
							table.insert(availableSkills, skillName)
						elseif skillData.ismagie == true then
							if player:GetNWInt("Magie") == skillData.element then
								table.insert(availableSkills, skillName)
							end
						end
					end
				end
	
				-- S√©lectionnez une comp√©tence al√©atoire parmi les comp√©tences disponibles pour le joueur
				local randomSkill = availableSkills[math.random(#availableSkills)]
				local skillData = SKILLS_SL[randomSkill]
	
				-- Ajouter la comp√©tence au joueur
				if skillData then
					player:AddDataSkillsSL(randomSkill, skillData.level)
					net.Start("SL:Notification")
					net.WriteString("Vous avez obtenu le skill : "..skillData.name)
					net.Send(player)
				end
			end
		end
	
		-- R√©initialisez la table des d√©g√¢ts pour la prochaine instance de NPC
		self.playerDamage = {}
	
		self:PlaySequenceAndWait("die")
	end
	


end

if CLIENT then
	ENT.RenderGroup = RENDERGROUP_OPAQUE
	ENT.HUDMat_Main = Material("mad_sololeveling/mob/boss_hpbar.png", "smooth unlitgeneric")
	ENT.HUDMat_Bar = Material("mad_sololeveling/mob/hpbar.png", "smooth unlitgeneric")
	ENT.HUDMat_Bar2 = Material("hud/ds1/boss_hpbar_ylw.png", "smooth unlitgeneric")
	local tab = {["$pp_colour_addr"]=0,["$pp_colour_addg"]=0,["$pp_colour_addb"]=0,["$pp_colour_brightness"]=0,["$pp_colour_contrast"]=0.1,["$pp_colour_colour"]=0,["$pp_colour_mulr"]=50, ["$pp_colour_mulg"]=0, ["$pp_colour_mulb"]=0 }
		function ENT:CustomDraw()
			-- if self:GetNetworkVars()["Phantom"]!=nil then
			-- if self:GetPhantom() then
				-- render.SetStencilWriteMask(0xFF)
				-- render.SetStencilTestMask(0xFF)
				-- render.ClearStencil()
				-- render.SetStencilEnable(true)
				-- render.SetStencilReferenceValue(1)
				-- render.SetStencilCompareFunction(STENCIL_ALWAYS)
				-- render.SetStencilPassOperation(STENCIL_REPLACE)
				-- render.SetStencilFailOperation(STENCIL_KEEP)
				-- render.SetStencilZFailOperation(STENCIL_KEEP)
				-- self:DrawModel()
				-- render.SetStencilCompareFunction(STENCIL_EQUAL)
				-- DrawSobel(0.1)
				-- -- halo.Add({self}, Color(255,0,0)) -- crashes the game apparently, epic
				-- DrawColorModify(tab)
				-- DrawMaterialOverlay("effects/tp_refract", 0.02)
				-- DrawMaterialOverlay("effects/water_warp01", -0.01)
				-- render.SetStencilEnable(false)
			-- end
			-- end
			if self:IsDead() and (math.Round(self:GetHPY())<=math.Round(self:GetHP())) then return end
				local angle = EyeAngles()
				angle = Angle(0,angle.y,0)
				angle.y = angle.y + math.sin(CurTime())*10
				angle:RotateAroundAxis(angle:Up(),-90)
				angle:RotateAroundAxis(angle:Forward(),90)
				
				local pos = self:GetBonePosition(self:LookupBone("Bip001_Head")) + Vector(0,0,self.HPBarOffset)
				cam.Start3D2D(pos,angle,self.HPBarScale)
					local hp = math.Round(self:GetHP())
					local hp2 = math.Round(self:GetHPY())
					local hpmax = self.SpawnHealth
					local text = self.PrintName
					local text2 = tostring(math.Round(self:GetDMGDealt()))
					surface.SetFont("Trebuchet24")
					local tW, tH = surface.GetTextSize(text)
	
					local pad = 0.01
					surface.SetDrawColor(255,255,255,255)
					surface.SetMaterial(self.HUDMat_Bar2)
					surface.DrawTexturedRect(-(self.HUDMat_Main:Width()/6)+8, -(self.HUDMat_Main:Height())+5, (self.HUDMat_Bar2:Width()*1.05)*(hp2/hpmax), self.HUDMat_Bar2:Height()/2, 1)
					surface.SetMaterial(self.HUDMat_Bar)
					surface.DrawTexturedRect(-(self.HUDMat_Main:Width()/6)+8, -(self.HUDMat_Main:Height())+5, (self.HUDMat_Bar:Width()*1.05)*(hp/hpmax), self.HUDMat_Bar:Height()/2, 1)
					surface.SetMaterial(self.HUDMat_Main)
					surface.DrawTexturedRect(-(self.HUDMat_Main:Width()/6), -(self.HUDMat_Main:Height()), self.HUDMat_Main:Width()/3, self.HUDMat_Main:Height(), 2)
	
					draw.SimpleText(text, "M_Font5", -(self.HUDMat_Main:Width()/6)+8, -(self.HUDMat_Main:Height()+16), Color(200,0,0))
					if text2 != "0" then draw.SimpleText(text2, "M_Font5", (self.HUDMat_Main:Width()/6)-16, -(self.HUDMat_Main:Height()+16), Color(200,0,0)) end
				cam.End3D2D()
			self:DS1_Draw()
		end
		function ENT:DS1_Draw()
			
		end
	end
	function ENT:SetupDataTables()
		self:NetworkVar("Float", 0, "HP")
		self:NetworkVar("Float", 1, "HPY")
		self:NetworkVar("Float", 2, "DMGDealt")
		self:NetworkVar("Bool", 0, "Phantom")
	end

-- DO NOT TOUCH --
AddCSLuaFile()
DrGBase.AddNextbot(ENT)

--PATH addons/pcasino/lua/entities/pcasino_roulette_table/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Roulette Table"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LastRoundNumber")
	self:NetworkVar("Int", 1, "StartRoundIn")
end

-- This is a lot of confusing math and took me ages to actually get right on the grid. Just accept it for what it is, I cache it, so it's not really a big deal... right? :/
-- I essentially map each bet "type" based on some math, because they're all in a grid. Best way I could think of without manually mapping every button.
function ENT:GetCurrentPad(pos)
	if not self.padCache then
		self.padCache = {}
		-- Set priority
		self.padCache[1] = {} -- The outer buttons, they don't overlap and there's not many of them, so we can do them first.
		self.padCache[2] = {} -- The 2x2 overlaps, they overlap the most so they should be done second.
		self.padCache[3] = {} -- The 1x2 or 2x1 crossovers, they also overlap so they should be done before the base numbers. We put the row bets in here too.
		self.padCache[4] = {} -- The base numbers

		local startPos = Vector(4.1, -13.3, 14)
		local sizeW, sizeH = -6.2, 4.4
		-- 1 to 36 numbers
		for i=1, 36 do
			self.padCache[4]["num_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%3))), y = (startPos.y + (sizeH*math.floor((i-1)/3)))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%3)+1))), y = (startPos.y + (sizeH*(math.floor((i-1)/3)+1)))}
			}

			-- Add the numbers it covers
			self.padCache[4]["num_"..i].numbers = {[i] = true}

			-- Add the payout if won
			self.padCache[4]["num_"..i].payout = 35
		end

		local startPos = Vector(-1.1, -10.2, 14)
		local sizeW, sizeH = -2, 2.21
		local row = 0
		local newI
		-- The 2x2 bets
		for i=1, 22 do
			self.padCache[2]["2x2_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%2))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*math.floor((i-1)/2))) + (sizeH*math.floor((i-1)/2))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%2)+1))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*(math.floor((i-1)/2)+1))) + (sizeH*math.floor((i-1)/2))}
			}

			-- Add the numbers it covers
			newI = i + row
			self.padCache[2]["2x2_"..i].numbers = {}
			self.padCache[2]["2x2_"..i].numbers[newI] = true
			self.padCache[2]["2x2_"..i].numbers[newI+1] = true
			self.padCache[2]["2x2_"..i].numbers[newI+3] = true
			self.padCache[2]["2x2_"..i].numbers[newI+4] = true
			
			-- The end of a row
			if i%2 == 0 then
				row = row + 1
			end

			-- Add the payout if won
			self.padCache[2]["2x2_"..i].payout = 8
		end

		local startPos = Vector(-1.1, -12.4, 14)
		local sizeW, sizeH = -2, 2.21
		local row = 0
		local newI
		-- The horizontal bets
		for i=1, 24 do
			self.padCache[3]["hrztl_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%2))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*math.floor((i-1)/2))) + (sizeH*math.floor((i-1)/2))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%2)+1))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*(math.floor((i-1)/2)+1))) + (sizeH*math.floor((i-1)/2))}
			}

			-- Add the numbers it covers
			newI = i + row
			self.padCache[3]["hrztl_"..i].numbers = {}
			self.padCache[3]["hrztl_"..i].numbers[newI] = true
			self.padCache[3]["hrztl_"..i].numbers[newI+1] = true

			-- The end of a row
			if i%2 == 0 then
				row = row + 1
			end

			-- Add the payout if won
			self.padCache[3]["hrztl_"..i].payout = 17
		end

		local startPos = Vector(2.1, -10.2, 14)
		local sizeW, sizeH = -2, 2.21
		-- The vertical bets
		for i=1, 33 do
			self.padCache[3]["vrtcl_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%3))) + ((sizeW*2.15)*((i-1)%3)), y = (startPos.y + (sizeH*math.floor((i-1)/3))) + (sizeH*math.floor((i-1)/3))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%3)+1))) + ((sizeW*2.15)*((i-1)%3)), y = (startPos.y + (sizeH*(math.floor((i-1)/3)+1))) + (sizeH*math.floor((i-1)/3))}
			}

			-- Add the numbers it covers
			self.padCache[3]["vrtcl_"..i].numbers = {}
			self.padCache[3]["vrtcl_"..i].numbers[i] = true
			self.padCache[3]["vrtcl_"..i].numbers[i+3] = true

			-- Add the payout if won
			self.padCache[3]["vrtcl_"..i].payout = 17
		end

		local startPos = Vector(5.3, -13.3, 14)
		local sizeW, sizeH = -2, 4.4
		local start
		-- Row bets
		for i=1, 12 do
			self.padCache[3]["row_"..i] = {
				boundsA = {x = startPos.x, y = (startPos.y + (sizeH*(i-1)))},
				boundsB = {x = (startPos.x + sizeW), y = (startPos.y + (sizeH*(i)))},
			}

			-- Add the numbers it covers
			start = (i-1)*3
			self.padCache[3]["row_"..i].numbers = {[start+1] = true, [start+2] = true, [start+3] = true}

			-- Add the payout if won
			self.padCache[3]["row_"..i].payout = 11
		end

		-- 0 is bigger, so we gotta do it manually
		self.padCache[4]["num_0"] = {
			boundsA = {x = 4.3, y = -18.6},
			boundsB = {x = -14.3, y = -13.6}
		}
		-- Add the numbers it covers
		self.padCache[4]["num_0"].numbers = {[0] = true}
		-- Add the payout if won
		self.padCache[4]["num_0"].payout = 35

		local startPos = Vector(4.1, 39.5, 14)
		local sizeW, sizeH = -6.2, 4.4
		-- Sets of 12
		for i=1, 3 do
			self.padCache[1]["2to1_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*(i-1))), y = startPos.y},
				boundsB = {x = (startPos.x + (sizeW*(i))), y = (startPos.y + sizeH)}
			}

			-- Add the numbers it covers
			self.padCache[1]["2to1_"..i].numbers = {}
			for n=i, 36, 3 do
				self.padCache[1]["2to1_"..i].numbers[n] = true
			end

			-- Add the payout if won
			self.padCache[1]["2to1_"..i].payout = 2
		end

		local startPos = Vector(9.3, -13.4, 14.6)
		local sizeW, sizeH = -5, 17.7
		local start
		-- Sets of 12
		for i=1, 3 do
			self.padCache[1]["12s_"..i] = {
				boundsA = {x = startPos.x, y = (startPos.y + (sizeH*(i-1)))},
				boundsB = {x = (startPos.x + sizeW), y = (startPos.y + (sizeH*(i)))},
			}

			-- Add the numbers it covers
			self.padCache[1]["12s_"..i].numbers = {}
			start = 12*(i-1)+1
			for n=start, start+11 do
				self.padCache[1]["12s_"..i].numbers[n] = true
			end

			-- Add the payout if won
			self.padCache[1]["12s_"..i].payout = 2
		end

		local startPos = Vector(14.5, -13.4, 14.6)
		local sizeW, sizeH = -5, 8.85
		local types = {"1to18", "even", "red", "black", "odd", "19to36"}
		for k, v in ipairs(types) do
			self.padCache[1][v] = {
				boundsA = {x = startPos.x, y = (startPos.y + (sizeH*(k-1)))},
				boundsB = {x = (startPos.x + sizeW), y = (startPos.y + (sizeH*(k)))},
			}

			-- Add the numbers it covers
			self.padCache[1][v].numbers = {}
			for i=1, 36 do
				if (v == "1to18") and (i <= 18) then
					self.padCache[1][v].numbers[i] = true
				elseif (v == "19to36") and (i >= 19) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "even") and (i%2 == 0) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "odd") and (i%2 == 1) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "red") and table.HasValue({1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36}, i) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "black") and table.HasValue({2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35}, i) then 
					self.padCache[1][v].numbers[i] = true
				end
			end

			-- Add the payout if won
			self.padCache[1][v].payout = 1
		end

		-- Raise bet
		self.padCache[1]["bet_raise"] = {
			boundsA = {x = -20, y = -5.2},
			boundsB = {x = -23.7, y = -0.567747},
		}
		-- Lower bet
		self.padCache[1]["bet_lower"] = {
			boundsA = {x = -20, y = 10.5},
			boundsB = {x = -23.7, y = 15.5},
		}

		-- Find the center point of all the 3d2d inputs
		for i, _ in ipairs(self.padCache) do
			for k, v in pairs(_) do
				self.padCache[i][k].origin = {x = v.boundsA.x+((v.boundsB.x - v.boundsA.x)/2), y = v.boundsA.y+((v.boundsB.y - v.boundsA.y)/2)}
			end
		end
	end
	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if (pos.x < v.boundsA.x) and (pos.x > v.boundsB.x) and (pos.y > v.boundsA.y) and (pos.y < v.boundsB.y) and (pos.z > 13) and (pos.z < 15) then
				return k, v
			end
		end
	end

	return false
end
function ENT:GetPadByName(padName)
	if not self.padCache then
		self:GetCurrentPad(Vector(0, 0, 0)) -- Generate the cache
	end

	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if k == padName then
				return k, v
			end
		end
	end
end
function ENT:GetPadsFromNumber(number)
	local pads = {}

	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if v.numbers and v.numbers[number] then
				table.insert(pads, k)
			end
		end
	end

	return pads
end

PerfectCasino.Core.RegisterEntity("pcasino_roulette_table", {
	-- Bet data
	bet = {
		betLimit = {d = 3000, t = "num"},
		default = {d = 500, t = "num"},
		max = {d = 1000, t = "num"},
		min = {d = 100, t = "num"},
		iteration = {d = 100, t = "num"}
	},
	general = {
		betPeriod = {d = 30, t = "num"} -- The default bet
	}
},
"models/freeman/owain_roulette_table.mdl")
--PATH addons/pcasino/lua/entities/pcasino_sign_interior_standing/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end

local draw_simpletext = draw.SimpleText
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	local pos = self:GetPos()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), -90)

	cam.Start3D2D(pos + (self:GetUp() * 26) + (self:GetForward() * 2.4) + (self:GetRight() * 7.1), ang, 0.05)
			PerfectCasino.UI.WrapText(self.data.general.text, 15, "pCasino.Title.Static", 140, 100, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()

	ang:RotateAroundAxis(ang:Right(), 180)

	cam.Start3D2D(pos + (self:GetUp() * 26) + (self:GetForward() * -2.4) + (self:GetRight() * -7.1), ang, 0.05)
			PerfectCasino.UI.WrapText(self.data.general.text, 15, "pCasino.Title.Static", 140, 100, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/pcasino/lua/entities/pcasino_sign_plaque/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Plaque"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_plaque", {
	-- General data
	general = {
		text = {d = "Cool Casino", t = "string"} -- The text to show
	}
},
"models/freeman/owain_casinosign_text.mdl")
--PATH lua/entities/pfx1_03~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Ember field"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]embers_~"
--PATH lua/entities/pfx1_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire Trail"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flametrail"
--PATH lua/entities/pfx1_07.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Black Smoke Cloud"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]big_smoke"
--PATH lua/entities/pfx1_08_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Green]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_green"
--PATH lua/entities/pfx1_08~_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Blue]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_blue"
--PATH lua/entities/pfx1_0e.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Default]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]fireplace_default"
--PATH lua/entities/pfx2_04~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Swirl 2"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]swirl_rnd"
--PATH lua/entities/pfx3_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Cherry Tree Petals"
ENT.Category         = "PPE: Nature"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[3]sakura_env"


--PATH lua/entities/pfx4_00_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Basic Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f_s"
--PATH lua/entities/pfx4_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Arcs"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]arcs_electric_1"
--PATH lua/entities/pfx4_05~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Arcs [Small]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]arcs_electric_1_small"
--PATH lua/entities/pfx4_06_2.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_r"
--PATH lua/entities/pfx5_00_alt.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Alt Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_b"
--PATH lua/entities/pfx5_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Simple Galaxy Model"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]simple_galaxy"
--PATH lua/entities/pfx6_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Bullet Tracer"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]bullet_tracer_generic"
--PATH lua/entities/pfx8_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Orb 1"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]ball_core"
--PATH lua/entities/pfx9_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Colorful Trail"
ENT.Category         = "PPE: Trails"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[9]colorful_trail_1"
--PATH lua/entities/picklejar/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Jar of Pickles"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/picklejar.mdl")
	
end
--PATH lua/entities/proj_drg_grenade.lua:
if not DrGBase then return end -- return if DrGBase isn't installed
ENT.Base = "proj_drg_default"
ENT.IsDrGGrenade = true

-- Misc --
ENT.PrintName = "HE Grenade"
ENT.Category = "DrGBase"
ENT.Models = {"models/weapons/w_eq_fraggrenade.mdl"}
ENT.Spawnable = true

-- Physics --
ENT.Physgun = true
ENT.Gravgun = true

-- Grenade --
ENT.Bounce = 0.75
ENT.OnBounceSounds = {"weapons/hegrenade/he_bounce-1.wav"}

function ENT:GetDamage()
	return math.Clamp(self:GetNW2Float("DrGBaseDamage", 250), 0, math.huge)
end
function ENT:GetRange()
	return math.Clamp(self:GetNW2Float("DrGBaseRange", 250), 0, math.huge)
end
function ENT:GetDelay()
	return math.Clamp(self:GetNW2Float("DrGBaseDelay", 3), 0, math.huge)
end

function ENT:IsUnpined()
	return self:GetNW2Bool("DrGBaseUnpined")
end
function ENT:HasDetonated()
	return self:GetNW2Bool("DrGBaseDetonated")
end

if SERVER then
	AddCSLuaFile()

	function ENT:_BaseInitialize()
		self._DrGBaseBounceSoundDelay = 0
	end
	function ENT:OnContact(ent)
		if self:GetVelocity():IsZero() then return end
		self:Timer(0, function()
			self:SetVelocity(self:GetVelocity()*self.Bounce)
		end)
		if CurTime() < self._DrGBaseBounceSoundDelay then return end
		if istable(self.OnBounceSounds) and #self.OnBounceSounds > 0 then
			self._DrGBaseBounceSoundDelay = CurTime() + 0.25
			self:EmitSound(self.OnBounceSounds[math.random(#self.OnBounceSounds)])
		end
	end

	function ENT:Use()
		self:Unpin()
	end
	function ENT:OnTakeDamage()
		self:Timer(0.1, self.Detonate)
	end

	-- Grenade --

	function ENT:SetDamage(damage)
		self:SetNW2Float("DrGBaseDamage", damage)
	end
	function ENT:SetRange(range)
		self:SetNW2Float("DrGBaseRange", range)
	end
	function ENT:SetDelay(delay)
		self:SetNW2Float("DrGBaseDelay", delay)
	end

	function ENT:Unpin(mute)
		if self:IsUnpined() then return end
		if not mute then self:EmitSound("weapons/pinpull.wav") end
		self:SetNW2Bool("DrGBaseUnpined", true)
		self:Timer(self:GetDelay(), self.Detonate)
	end

	function ENT:Detonate()
		if self:HasDetonated() then return end
		self:SetNW2Bool("DrGBaseDetonated", true)
		if not self:OnDetonate() then self:Remove() end
	end
	function ENT:OnDetonate()
		self:Explosion(self:GetDamage(), self:GetRange())
	end

end

--PATH addons/sl_main_system/lua/entities/retour_portail_sl/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/sandwich1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Sandwich"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Sandwich.mdl")
	
end
--PATH lua/entities/sent_catmullrom_camera_viewpnt/cl_init.lua:
include("shared.lua")

--PATH addons/sl_bouffe/lua/entities/sl_winerose2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Wine (Rose)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/wine_rose2.mdl")
	
end
--PATH lua/entities/sodacan04/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Soda (Pepsi)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Sodacan04.mdl")
	
end
--PATH lua/entities/sodacanb01/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Monster Energy"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Sodacanb01.mdl")
	
end
--PATH addons/autorun_taxi_teleport/lua/entities/teleport_taxi/cl_init.lua:
--[[
-----------------------------------------------------------
                    Informations
-----------------------------------------------------------
Ce fichier provient du site web https://aide-serveur.fr/ et a √©t√© publi√© et cr√©√© par Autorun__.
Toute forme de revente, de republication, d'envoi √† des tiers, etc. est strictement interdite, car cet addon est payant.
Discord : Autorun__
Serveur Discord : Discord.gg/GgH8eKmFpt
-----------------------------------------------------------
--]]

include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

--PATH addons/autorun_taxi_teleport/lua/entities/teleport_taxi/shared.lua:
--[[
-----------------------------------------------------------
                    Informations
-----------------------------------------------------------
Ce fichier provient du site web https://aide-serveur.fr/ et a √©t√© publi√© et cr√©√© par Autorun__.
Toute forme de revente, de republication, d'envoi √† des tiers, etc. est strictement interdite, car cet addon est payant.
Discord : Autorun__
Serveur Discord : Discord.gg/GgH8eKmFpt
-----------------------------------------------------------
--]]

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Taxi Teleport"
ENT.Author = "Autorun__"
ENT.Category = "Taxi Teleport Autorun"

ENT.Spawnable = true
ENT.AdminOnly = false
--PATH lua/entities/vegcarrot/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Carrot"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/carrot.mdl")
	
end
--PATH lua/entities/winered2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Wine (Red)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/wine_red2.mdl")
	
end
--PATH lua/entities/winerose1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Wine (Rose)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/wine_rose1.mdl")
	
end
--PATH lua/effects/drg_blood_explosion.lua:
function EFFECT:Init(data)
	local ent = data:GetEntity()
	if not IsValid(ent) then return end
	local color = data:GetFlags()
	for i = 0, (ent:GetBoneCount()-1) do
		if ent:GetBoneName(i) == "__INVALIDBONE__" then continue end
		local pos, angles = ent:GetBonePosition(i)
		if color == BLOOD_COLOR_RED then
			ParticleEffect("blood_impact_red_01_goop", pos, angles, ent)
		elseif color == BLOOD_COLOR_YELLOW then
			ParticleEffect("blood_impact_yellow_01", pos, angles, ent)
		elseif color == BLOOD_COLOR_GREEN then
			ParticleEffect("blood_impact_green_01", pos, angles, ent)
		elseif color == BLOOD_COLOR_ANTLION then
			ParticleEffect("blood_impact_antlion_01", pos, angles, ent)
		elseif color == BLOOD_COLOR_ZOMBIE then
			ParticleEffect("blood_impact_zombie_01", pos, angles, ent)
		elseif color == BLOOD_COLOR_ANTLION_WORKER then
			ParticleEffect("blood_impact_antlion_worker_01", pos, angles, ent)
		end
	end
end

function EFFECT:Think() return false end
function EFFECT:Render() end

--PATH lua/effects/punchshockwave.lua:
local dietime = 0

function EFFECT:Init( Effect )

	self.pos = Effect:GetOrigin()
	self.ang = Effect:GetAngles()
	
	--ParticleEffect( "martialhit_heavy_helper_base", self.DummyProj:GetPos(), self.DummyProj:GetAngles(), self.DummyProj )
	ParticleEffect("martialhit_heavy_helper_base",self.pos,self.ang)

	local emitter1 = ParticleEmitter(self.pos, true )
	local particle1 = emitter1:Add( "ryu_shockwave_ring",self.pos+Vector(0,0,5))
	if particle1 then
		particle1:SetAngles(Angle(0,self.ang.y,0))
		particle1:SetVelocity( Vector( 0, 0, 0 ) )
		particle1:SetDieTime( 0.125 )
		particle1:SetStartAlpha( 150 )
		particle1:SetEndAlpha( 0 )
		particle1:SetStartSize( 25 )
		particle1:SetEndSize( 150 )
		particle1:SetLighting(false)
		particle1:SetCollide(false)
	end
	emitter1:Finish()

	local emitter2 = ParticleEmitter(self.pos, true )
	local particle2 = emitter2:Add( "ryu_shockwave_ring",self.pos+Vector(0,0,5))
	if particle2 then
		particle2:SetAngles(Angle(0,self.ang.y - 180,0))
		particle2:SetVelocity( Vector( 0, 0, 0 ) )
		particle2:SetDieTime( 0.125 )
		particle2:SetStartAlpha( 150 )
		particle2:SetEndAlpha( 0 )
		particle2:SetStartSize( 25 )
		particle2:SetEndSize( 150 )
		particle2:SetLighting(false)
		particle2:SetCollide(false)
	end
	emitter2:Finish()

end

function EFFECT:Think()
end

function EFFECT:Render()
end

--PATH addons/sl_main_system/lua/effects/sl_effect5.lua:
EFFECT.mat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
    self.Ent = data:GetEntity()
    self.Pos = data:GetOrigin()

    self.LifeTime = 1
    self.DieTime = CurTime() + self.LifeTime

    if not IsValid( self.Ent ) then return end

    self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )

    self.Model:SetMaterial("models/alyx/emptool_glow")
    self.Model:SetColor( Color(127,255,255) )
    self.Model:SetParent( self.Ent, 0 )
    self.Model:SetMoveType( MOVETYPE_NONE )
    self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
    self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
    self.Model:AddEffects( EF_BONEMERGE )
    
    for i = 0,self.Ent:GetBoneCount() do
        self.Model:ManipulateBoneScale( i, Vector(1,1,1) * 1.1 )
    end

    for i = 0, self.Ent:GetNumBodyGroups() do
        self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
    end
end

function EFFECT:Think()
    if self.DieTime < CurTime() or not IsValid( self.Ent ) or (self.Ent.Alive and not self.Ent:Alive()) then 
        if IsValid( self.Model ) then
            self.Model:Remove()
        end

        return false
    end

    if IsValid( self.Model ) then
        self.Model:SetColor( Color(127* (self.DieTime - CurTime()) / self.LifeTime,255,255,255) )
    end

    return true
end

function EFFECT:Render()
    if not IsValid( self.Ent ) then return end

end

--PATH lua/effects/swipewaveeffect.lua:
local dietime = 0

function EFFECT:Init( Effect )

	self.pos = Effect:GetOrigin()
	self.ang = Effect:GetAngles()
	self.scale = Effect:GetScale()
	self.randang = math.random(360)

	local emitter1 = ParticleEmitter(self.pos, true )
	local particle1 = emitter1:Add( "ryu_impact_ring",self.pos+Vector(0,0,5))
	if particle1 then
		particle1:SetAngles(self.ang +Angle(0,0,self.randang))
		particle1:SetVelocity( Vector( 0, 0, 0 ) )
		particle1:SetColor( 255, 200, 200 )
		particle1:SetDieTime( 0.375 )
		particle1:SetStartAlpha( 255 )
		particle1:SetEndAlpha( 0 )
		particle1:SetStartSize( 90 * self.scale )
		particle1:SetEndSize( 210 * self.scale )
		particle1:SetLighting(false)
		particle1:SetCollide(false)
	end
	emitter1:Finish()

	local emitter2 = ParticleEmitter(self.pos, true )
	local particle2 = emitter2:Add( "ryu_impact_ring",self.pos+Vector(0,0,5))
	if particle2 then
		particle2:SetAngles(self.ang +Angle(180,0,self.randang))
		particle2:SetVelocity( Vector( 0, 0, 0 ) )
		particle2:SetColor( 255, 200, 200 )
		particle2:SetDieTime( 0.375 )
		particle2:SetStartAlpha( 255 )
		particle2:SetEndAlpha( 0 )
		particle2:SetStartSize( 90 * self.scale )
		particle2:SetEndSize( 210 * self.scale )
		particle2:SetLighting(false)
		particle2:SetCollide(false)
	end
	emitter2:Finish()

end

function EFFECT:Think()
end

function EFFECT:Render()
end

--PATH lua/effects/wraith_wireflicker_short.lua:
local mat_glow = Material( "models/mana/c_wirefade" )
local mat_wraith
local mat_overlay = "effects/shield_screen.vmt"

local cmd_matproxy = GetConVar( "hl2_mana_matproxy" )

EFFECT.FxMaterial = ""
EFFECT.Time = 0.2 -- Effect's desired life span.
EFFECT.Color = Vector( 1, 6, 48 ) -- Desired Color.

function EFFECT:Init( data )

	if ( GetConVar( "mat_fillrate" ):GetBool() ) then return end

	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.FxMaterial = mat_glow

	local pEntity = LocalPlayer()
-- You can cut this one. It's for viewmodel purposes.
	if ( ent == pEntity ) && ( !pEntity:ShouldDrawLocalPlayer() ) then
		self.ViewModel = true
		self.FxMaterial = Material( "models/mana/c_wirefade_noz" )

		ent = pEntity:GetHands()
	end
	
	self.ParentEntity = ent
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
	
	return false
	
end

function EFFECT:Render()

end

function EFFECT:RenderOverlay( entity )

	local fFraction = ( self.LifeTime - CurTime() ) / self.Time
	
	fFraction = math.Clamp( fFraction, 0, 1 )
	
	local origin = entity:GetPos()

	local EyeNormal = origin - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local offset 
	
	if ( self.ViewModel ) then
		local iFov = 54
		local wEntity = LocalPlayer():GetActiveWeapon()
		if ( IsValid( wEntity ) && wEntity.ViewModelFOV ) then
			iFov = wEntity.ViewModelFOV
		end
		
		local add = -54 + iFov
		add = add * 0.3
		
		offset = EyeAngles():Forward() * ( 12 - add )
	else
		offset = EyeNormal * Distance * 0.01
	end
	
	local Pos = EyePos() + offset

	local clr = self.Color

	local fFlicker = math.sin( CurTime() * math.random( 16, 64 ) )
	
	local owner = entity
	local dlight = DynamicLight( owner:EntIndex() )
	if ( dlight ) then
		local vLightOrigin = owner:GetBonePosition( 1 )
		if ( !vLightOrigin ) then 
			vLightOrigin = owner:GetPos()
		end
		
		dlight.pos = vLightOrigin
		dlight.r = math.min( clr.r * 10, 255 )
		dlight.g = math.min( clr.g * 10, 255 )
		dlight.b = math.min( clr.b * 10, 255 )
		dlight.brightness = 6 * fFraction 
		dlight.Size = 140 * fFraction * fFlicker
		dlight.Decay = 1024
		dlight.Style = 1
		dlight.DieTime = CurTime() + self.Time
	end

	self.FxMaterial:SetFloat( "$emissiveBlendStrength", 1 )
	self.FxMaterial:SetVector( "$emissiveBlendTint", clr * fFraction * fFlicker )
	self.FxMaterial:SetVector( "$emissiveBlendScrollVector", Vector( -3, 3 ) )
	self.FxMaterial:SetFloat( "$FleshBorderWidth", 3 + 3 * ( 1 - fFraction ) )
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride( self.FxMaterial )
		render.SetBlend( fFlicker * fFraction )
		entity:DrawModel()
		render.MaterialOverride()
		render.SetColorModulation( 1, 1, 1 )
		render.SetBlend( 1 )
	cam.End3D()
	
end

function EFFECT:RenderParent()
	
	self:DrawModel()
	
	self.SpawnEffect:RenderOverlay( self )

end