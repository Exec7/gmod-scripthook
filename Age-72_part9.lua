--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 9/12 - 06/04/2025


--PATH lua/autorun/aoc_212th.lua:
player_manager.AddValidModel( "EC Test", 		"models/starwars/grady/212th_engineer/212th_ec_flametrooper.mdl" );
list.Set( "PlayerOptionsModel", "EC Test", 	"models/starwars/grady/212th_engineer/212th_ec_flametrooper.mdl" );
--lua/autorun/aoc_republic_navy_by_grady.lua:
player_manager.AddValidModel( "Republic Navy Black", 		"models/starwars/grady/navy/republic_navy_black.mdl" );
list.Set( "PlayerOptionsModel", "Republic Navy Black", 	"models/starwars/grady/navy/republic_navy_black.mdl" );

player_manager.AddValidModel( "Republic Navy TEST", 		"models/starwars/grady/aoc/navy/republic_navy_clone.mdl" );
list.Set( "PlayerOptionsModel", "Republic Navy TEST", 	"models/starwars/grady/aoc/navy/republic_navy_clone.mdl" );

player_manager.AddValidModel( "Republic Navy TEST2", 		"models/starwars/grady/aoc/navy/republic_navy_human2.mdl" );
list.Set( "PlayerOptionsModel", "Republic Navy TEST2", 	"models/starwars/grady/aoc/navy/republic_navy_human2.mdl" );

player_manager.AddValidModel( "Republic Navy TEST3", 		"models/starwars/grady/aoc/navy/republic_navy_human1.mdl" );
list.Set( "PlayerOptionsModel", "Republic Navy TEST3", 	"models/starwars/grady/aoc/navy/republic_navy_human1.mdl" );

player_manager.AddValidModel( "Republic Navy TEST4", 		"models/starwars/grady/aoc/navy/republic_navy_human3.mdl" );
list.Set( "PlayerOptionsModel", "Republic Navy TEST4", 	"models/starwars/grady/aoc/navy/republic_navy_human3.mdl" );
--addons/arccw_weapons/lua/arccw/shared/arccw_sw_effects.lua:
game.AddParticles( "particles/astw2_halo_flamethrower.pcf" )
-- game.AddParticles( "particles/gravity_hammer_fx.pcf" )
game.AddParticles( "particles/iv04_halo_reach_gravity_hammer_effects.pcf" )
game.AddParticles( "particles/iv04_halo_reach_explosions.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects2.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects_human_spv3.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects_covie_spv3.pcf" )
game.AddParticles( "particles/astw2_halo_pack_weapon_projectiles.pcf" )
game.AddParticles( "particles/astw2_gravity_hammer_fx.pcf" )
game.AddParticles( "particles/astw2_halo_pack_explosions.pcf" )
game.AddParticles( "particles/simfphys_halo_muzzle_effects.pcf" )
game.AddParticles( "particles/astw2_halo_4_forerunner_fx.pcf" )
game.AddParticles( "particles/astw2_halo_3_equipment_fx.pcf" )
game.AddParticles( "particles/astw2_halo_3_equipment_explosion_fx.pcf" )

--CASING EFFECTS
PrecacheParticleSystem( "astw2_halo_ce_casing_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_casing_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_casing_sniper" )
PrecacheParticleSystem( "astw2_halo_ce_casing_shotgun" )

--EQUIPMENT STUFF
PrecacheParticleSystem( "astw2_halo_3_bubbleshield_fx" )
PrecacheParticleSystem( "astw2_halo_3_power_drain_fx" )
PrecacheParticleSystem( "astw2_halo_3_power_drain_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_shield_deplete_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_impact_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_shield_depleted_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx_flare" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx_vapor" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx_flare" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx_vapor" )
PrecacheParticleSystem( "astw2_halo_3_gravlift_fx" )
PrecacheParticleSystem( "astw2_halo_3_superflare_fx" )
PrecacheParticleSystem( "astw2_halo_3_regenerator_fx" )
PrecacheParticleSystem( "astw2_halo_3_regenerator_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_flamethrower_pilot_fx" )
PrecacheParticleSystem( "astw2_halo_3_hammer_fx" )
PrecacheParticleSystem( "astw2_halo_3_hammer_fx_current" )
PrecacheParticleSystem( "astw2_halo_3_sword_fx" )

--Projectile Effects
PrecacheParticleSystem( "astw2_halo_ce_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_ce_rocket_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_ce_fuel_rod_trail" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_beam_tracer" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_beam_blue_tracer" )
PrecacheParticleSystem( "astw2_halo_2_needler_trail" )
PrecacheParticleSystem( "astw2_halo_2_enforcer_needler_trail" )
PrecacheParticleSystem( "astw2_halo_2_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_2_fuel_rod_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_3_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_3_needler_trail" )
PrecacheParticleSystem( "astw2_halo_3_frag_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_3_rocket_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_3_spiker_trail" )
PrecacheParticleSystem( "astw2_halo_3_flood_ranged_form_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_shredder_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_spiker_trail" )
PrecacheParticleSystem( "astw2_halo_reach_concussion_round_trail" )
PrecacheParticleSystem( "astw2_halo_reach_grenade_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_3_nuke_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_aerial_dark_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_phantom_projectile_fx" )
PrecacheParticleSystem( "astw2_halo_2_impact_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_impact_carbine" )
PrecacheParticleSystem( "astw2_halo_2_impact_needler" )
PrecacheParticleSystem( "astw2_halo_2_impact_plasma_rifle" )
--Misc Effects
PrecacheParticleSystem( "flame_halo_3" )
PrecacheParticleSystem( "astw2_halo_3_gravity_hammer_fx" )
--Explosion Effects
PrecacheParticleSystem( "halo_reach_explosion_unsc" )
PrecacheParticleSystem( "halo_reach_explosion_covenant" )
PrecacheParticleSystem( "halo_reach_gravity_hammer_smash" )
PrecacheParticleSystem( "astw2_halo_2_brute_shot_explosion" )
PrecacheParticleSystem( "astw2_halo_2_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_2_mortar_explosion" )
PrecacheParticleSystem( "astw2_halo_2_rocket_explosion" )
PrecacheParticleSystem( "astw2_halo_2_overcharge_impact" )
PrecacheParticleSystem( "astw2_halo_2_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_2_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_2_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_3_brute_shot_explosion" )
PrecacheParticleSystem( "astw2_halo_3_firebomb_explosion" )
PrecacheParticleSystem( "astw2_halo_3_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_3_overcharge_impact" )
PrecacheParticleSystem( "astw2_halo_3_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_3_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_3_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_3_rocket_explosion" )
PrecacheParticleSystem( "astw2_halo_3_spike_grenade_explosion" )
PrecacheParticleSystem( "astw2_halo_3_hunter_projectile_impact" )
PrecacheParticleSystem( "astw2_halo_spv3_hunter_projectile_impact" )
PrecacheParticleSystem( "astw2_halo_ce_sml_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_concussion_rifle_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_custom_mac_explosion" )
PrecacheParticleSystem( "astw2_halo_custom_nuke_explosion_XXL" )
PrecacheParticleSystem( "astw2_halo_custom_nuke_explosion_huge" )
PrecacheParticleSystem( "astw2_halo_phantom_projectile_impact_fx" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_impact_blue" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_impact_red" )
--Muzzle Effects
PrecacheParticleSystem( "astw2_halo_aerial_muzzle_dark_carbine" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_turret_covenant" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_focus_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_mauler" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_particle_carbine" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_shredder" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_spiker" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_DMR" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_SMG_specops" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_sniper_rifle_specops" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_gravity_wrench_charge" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_rocket_launcher" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sentinel_beam_red" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sentinel_beam_blue" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_hunter_cannon_charge" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_magnum_ODST" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_SMG_ODST" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_rocket_launcher" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_machine_gun_turret" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_missile_pod" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spartan_laser" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spartan_laser_charge" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_turret" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spiker" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_mauler" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_mauler_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_nuke_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_laser_painter_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_laser_painter_blue_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_warthog_chaingun" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_warthog_gauss_cannon" )
PrecacheParticleSystem( "astw2_halo_4_muzzle_forerunner_aiming_beam" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_DMR" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_repeater" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_focus_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_concussion_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_focus_rifle_impact" )
PrecacheParticleSystem( "astw2_halo_3_sentinel_impact_blue" )
PrecacheParticleSystem( "astw2_halo_3_sentinel_impact_red" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_blue" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_red" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_monitor" )
PrecacheParticleSystem( "simphys_halo_warthog_gauss_muzzle" )
--Decal Effects
game.AddDecal( "astw2_halo_reach_impact_nuke_explosion", "effects/halo_reach/impact_nuke_explosion" )
game.AddDecal( "astw2_halo_reach_impact_soft_terrain_explosion", "effects/halo_reach/impact_soft_terrain_explosion" )
game.AddDecal( "astw2_halo_reach_impact_hard", "effects/halo_reach/impact_hard" )
game.AddDecal( "astw2_halo_reach_impact_hard_medium", "effects/halo_reach/impact_hard_medium" )
game.AddDecal( "astw2_halo_3_sword_impact_medium", "effects/halo3/sword_impact_medium" )
game.AddDecal( "astw2_halo_3_impact_gauss", "effects/halo3/blast_scorch_ring" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_blue", "effects/halo3/plasma_impact_medium_blue" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_blue_sentinel", "effects/halo3/plasma_impact_medium_blue_sentinel" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_red", "effects/halo3/plasma_impact_medium_red" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_red_laser", "effects/halo3/plasma_impact_medium_red_laser" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_green", "effects/halo3/plasma_impact_medium_green" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_green_carbine", "effects/halo3/plasma_impact_medium_green_carbine" )
game.AddDecal( "astw2_halo_3_plasma_impact_large_purple", "effects/halo3/plasma_impact_large_purple" )
game.AddDecal( "astw2_halo_3_plasma_impact_large_green", "effects/halo3/plasma_impact_large_green" )
game.AddDecal( "astw2_halo_3_napalm_splat_large", "effects/halo3/napalm_splat_large1" )
game.AddDecal( "astw2_halo_3_blast_scorch_large", "effects/halo3/blast_scorch_large" )
game.AddDecal( "astw2_halo_2_phantom_plasma_burn", "effects/halo2/phantom_plasma_burn" )
game.AddDecal( "astw2_halo_2_plasma_burn_inner_glow", "effects/halo2/plasma_burn_inner_glow" )
game.AddDecal( "astw2_halo_2_plasma_blue_fizzle", "effects/halo2/plasma_blue_fizzle" )
game.AddDecal( "astw2_halo_2_plasma_blue_glow", "effects/halo2/plasma_blue_glow" )
game.AddDecal( "astw2_halo_2_plasma_burn_inner_glow_brute", "effects/halo2/plasma_burn_inner_glow_brute" )
game.AddDecal( "astw2_halo_2_plasma_red_glow", "effects/halo2/plasma_red_glow" )
game.AddDecal( "astw2_halo_2_plasma_red_fizzle", "effects/halo2/plasma_red_fizzle" )
game.AddDecal( "astw2_halo_2_plasma_explosion_glow_inner", "effects/halo2/plasma_explosion_glow_inner" )
game.AddDecal( "astw2_halo_2_plasma_beam_rifle_glow", "effects/halo2/beam_rifle_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_inner_glow", "effects/halo2/plasma_green_inner_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_glow", "effects/halo2/plasma_green_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_fizzle", "effects/halo2/plasma_green_fizzle" )
game.AddDecal( "astw2_halo_2_default_scorch", "effects/halo2/default_scorch" )
game.AddDecal( "astw2_halo_2_default_blast", "effects/halo2/default_blast" ) 

game.AddParticles( "particles/dc17_muzzleparticle.pcf" )
game.AddParticles( "particles/dc17_muzzleparticlemasita.pcf" )
game.AddParticles( "particles/muzzleflashes_test.pcf" )
game.AddParticles( "particles/muzzleflashes_test_b.pcf" )
game.AddDecal("sw_laser_scorch", 	"decals/vsw/glow_burn")
game.AddDecal("sw_laser_green", 	"decals/vsw/glow_green") 
game.AddDecal("sw_laser_blue", 		"decals/vsw/glow_blue") 
game.AddDecal("sw_laser_yellow", 	"decals/vsw/glow_yellow") 
game.AddDecal("sw_laser_red", 		"decals/vsw/glow_red")
PrecacheParticleSystem( "wpn_muzzleflash_dc17_purple" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_green" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_orange" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_red" )
PrecacheParticleSystem( "muzzleflash_smg" )
PrecacheParticleSystem( "muzzleflash_smg_bizon" )
PrecacheParticleSystem( "muzzleflash_shotgun" )
PrecacheParticleSystem( "muzzleflash_slug" )
PrecacheParticleSystem( "muzzleflash_slug_flame" )
PrecacheParticleSystem( "muzzleflash_pistol" )
PrecacheParticleSystem( "muzzleflash_pistol_cleric" )
PrecacheParticleSystem( "muzzleflash_pistol_deagle" )
PrecacheParticleSystem( "muzzleflash_suppressed" )
PrecacheParticleSystem( "muzzleflash_mp5" )
PrecacheParticleSystem( "muzzleflash_MINIMI" )
PrecacheParticleSystem( "muzzleflash_m79" )
PrecacheParticleSystem( "muzzleflash_m14" )
PrecacheParticleSystem( "muzzleflash_ak47" )
PrecacheParticleSystem( "muzzleflash_ak74" )
PrecacheParticleSystem( "muzzleflash_m82" )
PrecacheParticleSystem( "muzzleflash_m3" )
PrecacheParticleSystem( "muzzleflash_famas" )
PrecacheParticleSystem( "muzzleflash_g3" )
PrecacheParticleSystem( "muzzleflash_1" )
PrecacheParticleSystem( "muzzleflash_3" )
PrecacheParticleSystem( "muzzleflash_4" )
PrecacheParticleSystem( "muzzleflash_5" )
PrecacheParticleSystem( "muzzleflash_6" )
--addons/arccw_base_modified/lua/arccw/shared/sh_attachments.lua:
ArcCW.AttachmentBlacklistTable = ArcCW.AttachmentBlacklistTable or {}

function ArcCW:PlayerCanAttach(ply, wep, attname, slot, detach)
    -- The global variable takes priority over everything
    if !ArcCW.EnableCustomization then return false end

    -- Attach and Detach require a player (usually the owner)
    if !IsValid(ply) then return false end

    -- Spectators taking off your attachments is funny, but also cursed
    if wep:GetOwner() != ply then return false end

    -- Allow hooks to block or force allow attachment usage
    local ret = hook.Run("ArcCW_PlayerCanAttach", ply, wep, attname, slot, detach)

    if ret == nil and engine.ActiveGamemode() == "terrortown" then
        local mode = ArcCW.ConVars["ttt_customizemode"]:GetInt()
        if mode == 1 and !ply.ArcCW_AllowCustomize then return false
        elseif mode == 2 and !ply.ArcCW_AllowCustomize and GetRoundState() == ROUND_ACTIVE then return false
        elseif mode == 3 and !ply.ArcCW_AllowCustomize and !ply:IsActiveTraitor() and !ply:IsActiveDetective() then return false end
    elseif ret == nil and ArcCW.ConVars["enable_customization"]:GetInt() <= 0 then
        return false
    end

    return (ret == nil and true) or ret
end

function ArcCW:GetAttsForSlot(slot, wep, random)
    local ret = {}

    for id, atttbl in pairs(ArcCW.AttachmentTable) do

        if !ArcCW:SlotAcceptsAtt(slot, wep, id) then continue end
        if random and (atttbl.NoRandom or (atttbl.RandomWeight or 1) <= 0) then continue end

        table.insert(ret, id)
    end

    return ret
end

function ArcCW:GetAttList(name, filter)
    if self.AttachmentCachedLists[name] then return self.AttachmentCachedLists[name] end
    self.AttachmentCachedLists[name] = {}
    for k, v in pairs(self.AttachmentTable) do
        local k2, v2 = filter(k, v)
        if k2 then
            self.AttachmentCachedLists[name][k2] = v2
        end
    end
    return self.AttachmentCachedLists[name]
end

local function weighted_random(tbl, amt)
    amt = amt or 1
    local max = 0
    for k, v in pairs(tbl) do max = max + v end
    local ret = {}
    for i = 1, amt do
        local rng = math.random() * max
        for k, v in pairs(tbl) do
            rng = rng - v
            if rng <= 0 then
                ret[k] = (ret[k] or 0) + 1
                break
            end
        end
    end
    return ret
end

function ArcCW:RollRandomAttachment(all, wep, slot)
    for k, v in pairs(self:RollRandomAttachments(1, all, wep, slot)) do return k end
end

function ArcCW:RollRandomAttachments(amt, all, wep, slot)
    if wep == nil then
        -- cache the list results and randomly get one
        local tbl = self:GetAttList("random" .. (all and "_all" or ""), function(k, v)
            if ((!v.Free and !v.InvAtt) or all) and !v.NoRandom and (v.RandomWeight or 1) >= 0 then
                return k, v.RandomWeight or 1
            end
        end)
        return weighted_random(tbl, amt)
    else
        -- can't cache this because it is weapon-dependent
        local tbl = {}
        for id, atttbl in pairs(ArcCW.AttachmentTable) do
            if ((!atttbl.Free and !atttbl.InvAtt) or all) and (atttbl.NoRandom or (atttbl.RandomWeight or 1) <= 0) then continue end
            if !wep:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then continue end
            if slot != nil and !ArcCW:SlotAcceptsAtt(slot.Slot, wep, id) then continue end
            tbl[id] = atttbl.RandomWeight or 1
        end
        return weighted_random(tbl, amt)
    end
end

function ArcCW:SlotAcceptsAtt(slot, wep, att)
    local slots = {}

    if isstring(slot) then
        slots[slot] = true
    elseif istable(slot) then
        for _, i in pairs(slot) do
            slots[i] = true
        end
    end

    local atttbl = ArcCW.AttachmentTable[att]
    if !atttbl then return false end

    if atttbl.Hidden or atttbl.Blacklisted or ArcCW.AttachmentBlacklistTable[att] then return false end

    local Owner = wep.GetOwner and wep:GetOwner()
    if (atttbl.NotForNPC or atttbl.NotForNPCs) and Owner and Owner:IsNPC() then
        return false
    end
    if atttbl.AdminOnly and IsValid(Owner) and !(Owner:IsPlayer() and Owner:IsAdmin()) then return false end

    if wep.RejectAttachments and wep.RejectAttachments[att] then return false end

    if isstring(atttbl.Slot) then
        if !slots[atttbl.Slot] then return false end
    elseif istable(atttbl.Slot) then
        local yeah = false

        for _, i in pairs(atttbl.Slot) do
            if slots[i] then
                yeah = true
                break
            end
        end

        if !yeah then
            return false
        end
    end

    if wep and atttbl.Hook_Compatible then
        local compat = atttbl.Hook_Compatible(wep, {slot = slot, att = att})
        if compat == true then
            return true
        elseif compat == false then
            return false
        end
    end

    return true
end

function ArcCW:WeaponAcceptsAtt(wep, att)
    if wep.ArcCW and wep.Attachments then
        local tbl = {}
        for i, v in pairs(wep.Attachments) do
            table.insert(tbl, i)
        end
        return ArcCW:SlotAcceptsAtt(wep, wep, att)
    end
    return false
end

function ArcCW:PlayerGetAtts(ply, att)
    if !IsValid(ply) then return 0 end
    if ArcCW.ConVars["attinv_free"]:GetBool() then return 999 end

    if att == "" then return 999 end

    local atttbl = ArcCW.AttachmentTable[att]

    if !atttbl then return 0 end

    if atttbl.Free then return 999 end

    if !IsValid(ply) then return 0 end

    if !ply:IsAdmin() and atttbl.AdminOnly then
        return 0
    end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    if !ply.ArcCW_AttInv then return 0 end

    if !ply.ArcCW_AttInv[att] then return 0 end

    return ply.ArcCW_AttInv[att]
end

function ArcCW:PlayerGiveAtt(ply, att, amt)
    amt = amt or 1

    if !IsValid(ply) then return end

    if !ply.ArcCW_AttInv then
        ply.ArcCW_AttInv = {}
    end

    local atttbl = ArcCW.AttachmentTable[att]

    if !atttbl then print("Invalid att " .. att) return end
    if atttbl.Free then return end -- You can't give a free attachment, silly
    if atttbl.AdminOnly and !(ply:IsPlayer() and ply:IsAdmin()) then return false end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then
        if ply.ArcCW_AttInv[att] == 1 then return end
        ply.ArcCW_AttInv[att] = 1
    else
        ply.ArcCW_AttInv[att] = (ply.ArcCW_AttInv[att] or 0) + amt
    end
end

function ArcCW:PlayerTakeAtt(ply, att, amt)
    amt = amt or 1

    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return end

    if !IsValid(ply) then return end

    if !ply.ArcCW_AttInv then
        ply.ArcCW_AttInv = {}
    end

    local atttbl = ArcCW.AttachmentTable[att]
    if !atttbl or atttbl.Free then return end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    ply.ArcCW_AttInv[att] = ply.ArcCW_AttInv[att] or 0

    if ply.ArcCW_AttInv[att] < amt then
        return false
    end

    ply.ArcCW_AttInv[att] = ply.ArcCW_AttInv[att] - amt
    if ply.ArcCW_AttInv[att] <= 0 then
        ply.ArcCW_AttInv[att] = nil
    end
    return true
end

if CLIENT then

local function postsetup(wpn)
    if wpn.SetupModel then
        wpn:SetupModel(true)
        if wpn:GetOwner() == LocalPlayer() then
            wpn:SetupModel(false)
        end
        wpn:AdjustAtts()
    else
        timer.Simple(0.1, function()
            postsetup(wpn)
        end)
    end
end

net.Receive("arccw_networkatts", function(len, ply)
   local wpn = net.ReadEntity()
    if !IsValid(wpn) then return end
    if !wpn.ArcCW then return end

    local attnum = net.ReadUInt(8)
    wpn.Attachments = wpn.Attachments or {}
    wpn.SubSlotCount = 0

    for i = 1, attnum do
        local attid = net.ReadUInt(ArcCW.GetBitNecessity())

        wpn.Attachments[i] = wpn.Attachments[i] or {}

        if attid == 0 then
            if !istable(wpn.Attachments[i]) then continue end
            wpn.Attachments[i].Installed = nil
            continue
        end

        local att = ArcCW.AttachmentIDTable[attid]
        wpn.Attachments[i].Installed = att

        if wpn.Attachments[i].SlideAmount then
            wpn.Attachments[i].SlidePos = net.ReadFloat()
        end

        if ArcCW.AttachmentTable[att].ToggleStats then
            wpn.Attachments[i].ToggleNum = net.ReadUInt(8)
        end

        wpn:AddSubSlot(i, att)
    end

    wpn.CertainAboutAtts = true

    postsetup(wpn)
end)

net.Receive("arccw_sendattinv", function(len, ply)
    if !IsValid(LocalPlayer()) then return end -- This might be called before we are valid
    LocalPlayer().ArcCW_AttInv = {}

    local count = net.ReadUInt(32)

    for i = 1, count do
        local attid = net.ReadUInt(ArcCW.GetBitNecessity())
        local acount = net.ReadUInt(32)

        local att = ArcCW.AttachmentIDTable[attid]

        LocalPlayer().ArcCW_AttInv[att] = acount
    end

    -- This function will not exist until initialized (by having an ArcCW weapon exist)!
    -- It also obviously needs menu2 open
    if ArcCW.InvHUD_FormAttachmentSelect and IsValid(ArcCW.InvHUD) and IsValid(ArcCW.InvHUD_Menu2) then
        ArcCW.InvHUD_FormAttachmentSelect()
    end
end)

net.Receive("arccw_sendatthp", function(len, ply)
    local wpn = LocalPlayer():GetActiveWeapon()

    while net.ReadBool() do
        local slot = net.ReadUInt(8)
        local hp = net.ReadFloat()

        wpn.Attachments[slot].HP = hp
    end
end)

elseif SERVER then

hook.Add("PlayerDeath", "ArcCW_DeathAttInv", function(ply)
    ply.ArcCW_AttInv = ply.ArcCW_AttInv or {}
    if !table.IsEmpty(ply.ArcCW_AttInv)
            and ArcCW.ConVars["attinv_loseondie"]:GetInt() >= 2
            and !ArcCW.ConVars["attinv_free"]:GetBool() then
        local boxEnt = ents.Create("arccw_att_dropped")
        boxEnt:SetPos(ply:GetPos() + Vector(0, 0, 4))
        boxEnt.GiveAttachments = ply.ArcCW_AttInv
        boxEnt:Spawn()
        boxEnt:SetNWString("boxname", ply:GetName() .. "'s Death Box")
        local count = 0
        for i, v in pairs(boxEnt.GiveAttachments) do count = count + v end
        boxEnt:SetNWInt("boxcount", count)
    end
end)

hook.Add("PlayerSpawn", "ArcCW_SpawnAttInv", function(ply, trans)
    if trans then return end

    if ArcCW.ConVars["attinv_loseondie"]:GetInt() >= 1 then
        ply.ArcCW_AttInv = {}
    end
    local amt = ArcCW.ConVars["attinv_giveonspawn"]:GetInt()
    if amt > 0 then
        local giv = ArcCW:RollRandomAttachments(amt)
        for k, v in pairs(giv) do
            ArcCW:PlayerGiveAtt(ply, k, v)
        end
    end
    ArcCW:PlayerSendAttInv(ply)
end)

net.Receive("arccw_rqwpnnet", function(len, ply)
    local wpn = net.ReadEntity()

    if !wpn.ArcCW then return end

    wpn:RecalcAllBuffs()
    wpn:NetworkWeapon(ply)
end)

net.Receive("arccw_slidepos", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)
    local pos = net.ReadFloat()

    if !wpn.ArcCW then return end

    if !wpn.Attachments[slot] then return end

    wpn.Attachments[slot].SlidePos = pos
end)


net.Receive("arccw_togglenum", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)
    local num = net.ReadUInt(8)

    if !wpn.ArcCW then return end

    if !wpn.Attachments[slot] then return end

    wpn.Attachments[slot].ToggleNum = num

    wpn:AdjustAtts()
    wpn:NetworkWeapon()
    wpn:SetupModel(false)
    wpn:SetupModel(true)
end)


net.Receive("arccw_asktoattach", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)
    local attid = net.ReadUInt(24)

    local att = ArcCW.AttachmentIDTable[attid]

    if !wpn.ArcCW then return end
    if !wpn.Attachments[slot] then return end
    if !att then return end

    wpn:Attach(slot, att)
end)

net.Receive("arccw_asktodetach", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)

    if !wpn.ArcCW then return end
    if !wpn.Attachments[slot] then return end

    wpn:Detach(slot)
end)

net.Receive("arccw_asktodrop", function(len, ply)

    local attid = net.ReadUInt(24)
    local att = ArcCW.AttachmentIDTable[attid]

    if ArcCW.ConVars["attinv_free"]:GetBool() then return end
    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return end
    if ArcCW.ConVars["enable_customization"]:GetInt() < 0 then return end
    if !ArcCW.ConVars["enable_dropping"]:GetBool() then return end

    if !att then return end

    local atttbl = ArcCW.AttachmentTable[att]

    if !atttbl then return end
    if atttbl.Free then return end
    if ArcCW:PlayerGetAtts(ply, att) < 1 then return end

    -- better to do it like this in case you don't want to generate the attachment entities
    local ent = ents.Create("arccw_att_base")
    if !IsValid(ent) then return end
    ent:SetPos(ply:EyePos() + ply:EyeAngles():Forward() * 32)

    ent:SetNWInt("attid", attid)

    ent.GiveAttachments = {[att] = 1}
    ent.Model = atttbl.DroppedModel or atttbl.Model or "models/Items/BoxSRounds.mdl"
    ent.Icon = atttbl.Icon
    ent.PrintName = atttbl.PrintName or att

    ent:Spawn()
    timer.Simple(0, function()
        local phys = ent:GetPhysicsObject()
        if phys:IsValid() then
            phys:SetVelocity(ply:EyeAngles():Forward() * 32 * math.max(phys:GetMass(), 4))
        end
    end)
    ArcCW:PlayerTakeAtt(ply, att, 1)
    ArcCW:PlayerSendAttInv(ply)
end)

if SERVER then
    net.Receive("arccw_applypreset", function(len, ply)
        local wpn = net.ReadEntity()

        if wpn:GetOwner() != ply or !wpn.ArcCW then return end
        if ply.ArcCW_DisableAutosave or ply.ArcCW_Sandbox_RandomAtts then
            ply.ArcCW_Sandbox_RandomAtts = nil
            return
        end

        for k, v in pairs(wpn.Attachments) do
            wpn:Detach(k, true, true)
        end

        wpn.Attachments.BaseClass = nil -- AGHHHHHHHHHH
        for k, v in SortedPairs(wpn.Attachments) do
            local attid = net.ReadUInt(ArcCW.GetBitNecessity())

            local attname = ArcCW.AttachmentIDTable[attid or 0] or ""
            local atttbl = ArcCW.AttachmentTable[attname]
            if !atttbl then continue end

            wpn:Attach(k, attname, true, true)

            if net.ReadBool() then
                v.SlidePos = net.ReadFloat()
                v.SlidePos = atttbl.MountPositionOverride or v.SlidePos
            else
                v.SlidePos = 0.5
            end

            if atttbl.ToggleStats then
                v.ToggleNum = math.Clamp(net.ReadUInt(8), 1, #atttbl.ToggleStats)
            else
                v.ToggleNum = 1
            end
        end

        wpn:AdjustAtts()
        wpn:RefreshBGs()

        if ply.ArcCW_Sandbox_FirstSpawn then
            -- Curiously, RestoreAmmo has a sync delay only in singleplayer
            ply.ArcCW_Sandbox_FirstSpawn = nil
            wpn:RestoreAmmo()
        end

        wpn:NetworkWeapon()
        wpn:SetupModel(false)
        wpn:SetupModel(true)

        net.Start("arccw_applypreset")
            net.WriteEntity(wpn)
        net.Send(ply)
    end)
else
    net.Receive("arccw_applypreset", function()
        local wpn = net.ReadEntity()
        if !IsValid(wpn) then return end
        wpn:SavePreset("autosave")
    end)
end

function ArcCW:PlayerSendAttInv(ply)
    if ArcCW.ConVars["attinv_free"]:GetBool() then return end

    if !IsValid(ply) then return end

    if !ply.ArcCW_AttInv then return end

    net.Start("arccw_sendattinv")

    net.WriteUInt(table.Count(ply.ArcCW_AttInv), 32)

    for att, count in pairs(ply.ArcCW_AttInv) do
        local atttbl = ArcCW.AttachmentTable[att]
        local attid = atttbl.ID
        net.WriteUInt(attid, ArcCW.GetBitNecessity())
        net.WriteUInt(count, 32)
    end

    net.Send(ply)
end

end

--addons/arccw_base_modified/lua/arccw/shared/sh_controls.lua:
net.Receive("arccw_firemode", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    wpn:ChangeFiremode()
end)

net.Receive("arccw_ubgl", function(len, ply)
    local on = net.ReadBool()
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    if on then
        wpn:SelectUBGL()
    else
        wpn:DeselectUBGL()
    end
end)

if CLIENT then
    net.Receive("arccw_togglecustomize", function()
        if !LocalPlayer():GetActiveWeapon() or !LocalPlayer():GetActiveWeapon().ArcCW then return end
        LocalPlayer():GetActiveWeapon():ToggleCustomizeHUD(net.ReadBool())
    end)
elseif SERVER then
    net.Receive("arccw_togglecustomize", function(len, ply)
        local wpn = ply:GetActiveWeapon()
        local onoff = net.ReadBool()

        if !wpn.ArcCW then return end

        wpn:ToggleCustomizeHUD(onoff)
    end)
end

hook.Add("EntityTakeDamage", "ArcCW_CloseOnHurt", function(ply, dmg)
    if ply:IsPlayer() and ply:GetActiveWeapon() and ply:GetActiveWeapon().ArcCW
            and tobool(ply:GetInfo("arccw_attinv_closeonhurt"))
            and ply:GetActiveWeapon():GetState() == ArcCW.STATE_CUSTOMIZE then
        net.Start("arccw_togglecustomize")
            net.WriteBool(false)
        net.Send(ply)
        ply:GetActiveWeapon():ToggleCustomizeHUD(false)
    end
end)
--addons/arccw_base_modified/lua/arccw/shared/sh_convars.lua:
ArcCW.ConVars = {}

ArcCW.ConVars["enable_penetration"] = CreateConVar("arccw_enable_penetration", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)
ArcCW.ConVars["enable_ricochet"] = CreateConVar("arccw_enable_ricochet", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)
ArcCW.ConVars["enable_customization"] = CreateConVar("arccw_enable_customization", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", -1, 1)
ArcCW.ConVars["enable_dropping"] = CreateConVar("arccw_enable_dropping", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)
ArcCW.ConVars["enable_sway"] = CreateConVar("arccw_enable_sway", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)

ArcCW.ConVars["bodydamagemult_cancel"] = CreateConVar("arccw_bodydamagemult_cancel", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)

ArcCW.ConVars["attinv_lockmode"] = CreateConVar("arccw_attinv_lockmode", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Once owned, players can use attachments as much as they like.")
ArcCW.ConVars["attinv_free"] = CreateConVar("arccw_attinv_free", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "All attachments can always be used.")
ArcCW.ConVars["attinv_loseondie"] = CreateConVar("arccw_attinv_loseondie", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "All attachments reset on death. If set to 2, drops all attachments in a box.", 0, 2)

ArcCW.ConVars["atts_spawnrand"] = CreateConVar("arccw_atts_spawnrand", 0, FCVAR_ARCHIVE, "Randomly give attachments to player spawned SWEPs.", 0, 1)
ArcCW.ConVars["atts_ubglautoload"] = CreateConVar("arccw_atts_ubglautoload", 0, FCVAR_ARCHIVE, "Automatically load underbarrel weapons when attached.", 0, 1)
ArcCW.ConVars["atts_pickx"] = CreateConVar("arccw_atts_pickx", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Limit weapons to this many maximum attachments. 0 = disable system.", 0)

ArcCW.ConVars["npc_replace"] = CreateConVar("arccw_npc_replace", 0, FCVAR_ARCHIVE, "Replace NPC weapons with ArcCW weapons.")
ArcCW.ConVars["npc_atts"] = CreateConVar("arccw_npc_atts", 1, FCVAR_ARCHIVE, "Randomly give NPC weapons attachments.")

ArcCW.ConVars["truenames"] = CreateConVar("arccw_truenames", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use true names instead of fake names, where applicable. Requires restart.")

ArcCW.ConVars["equipmentammo"] = CreateConVar("arccw_equipmentammo", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Generate unique ammo types for throwables.", 0, 1) -- Automatically assign unique ammo types to each throwable weapon. Prone to running into the ammo type limit.
ArcCW.ConVars["equipmentsingleton"] = CreateConVar("arccw_equipmentsingleton", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Make grenades and equipment not use ammo, and remove themselves on use.", 0, 1)
ArcCW.ConVars["equipmenttime"] = CreateConVar("arccw_equipmenttime", 180, FCVAR_ARCHIVE, "How long equipment such as Claymores will remain on the map before self-destructing.")

ArcCW.ConVars["mult_damage"] = CreateConVar("arccw_mult_damage", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for damage done by all weapons.")
ArcCW.ConVars["mult_npcdamage"] = CreateConVar("arccw_mult_npcdamage", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for damage done by weapons used by NPCs.")
ArcCW.ConVars["mult_hipfire"] = CreateConVar("arccw_mult_hipfire", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for hip fire spread.")
ArcCW.ConVars["mult_reloadtime"] = CreateConVar("arccw_mult_reloadtime", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how long weapons take to reload.", 0.01)
ArcCW.ConVars["mult_sighttime"] = CreateConVar("arccw_mult_sighttime", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how long weapons take to enter sights.", 0.1)
ArcCW.ConVars["mult_rpm"] = CreateConVar("arccw_mult_rpm", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how fast weapons fire. May be disastrous on performance.", 0.01)
ArcCW.ConVars["mult_range"] = CreateConVar("arccw_mult_range", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for range of all weapons.")
ArcCW.ConVars["mult_recoil"] = CreateConVar("arccw_mult_recoil", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for recoil of all weapons.")
ArcCW.ConVars["mult_accuracy"] = CreateConVar("arccw_mult_accuracy", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for mechanical inprecision of weapons.")
ArcCW.ConVars["mult_movedisp"] = CreateConVar("arccw_mult_movedisp", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for moving inaccuracy of weapons.")
ArcCW.ConVars["mult_penetration"] = CreateConVar("arccw_mult_penetration", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how far weapons should penetrate.")
ArcCW.ConVars["mult_startunloaded"] = CreateConVar("arccw_mult_startunloaded", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "All weapons spawn unloaded.")
ArcCW.ConVars["mult_shootwhilesprinting"] = CreateConVar("arccw_mult_shootwhilesprinting", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Allow any weapon to shoot while sprinting.")
ArcCW.ConVars["mult_defaultammo"] = CreateConVar("arccw_mult_defaultammo", 3, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for default ammo supply.")
ArcCW.ConVars["mult_attchance"] = CreateConVar("arccw_mult_attchance", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for random attachment chance on NPCs and in TTT.")
ArcCW.ConVars["mult_heat"] = CreateConVar("arccw_mult_heat", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much heat increases per shot on certain weapons.", 0)
ArcCW.ConVars["mult_sway"] = CreateConVar("arccw_mult_sway", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much sway exists when in sights.", 0)
ArcCW.ConVars["mult_malfunction"] = CreateConVar("arccw_mult_malfunction", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how often malfunctions occur.", 0)
ArcCW.ConVars["mult_meleedamage"] = CreateConVar("arccw_mult_meleedamage", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for melee damage.", 0)
ArcCW.ConVars["mult_meleetime"] = CreateConVar("arccw_mult_meleetime", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for melee speed.", 0)
ArcCW.ConVars["mult_bottomlessclip"] = CreateConVar("arccw_mult_bottomlessclip", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Enable bottomless clip.", 0, 1)
ArcCW.ConVars["mult_infiniteammo"] = CreateConVar("arccw_mult_infiniteammo", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Enable infinite reserve ammo.", 0, 1)
ArcCW.ConVars["mult_crouchdisp"] = CreateConVar("arccw_mult_crouchdisp", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for hip dispersion while crouching.", 0)
ArcCW.ConVars["mult_crouchrecoil"] = CreateConVar("arccw_mult_crouchrecoil", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for recoil while crouching.", 0)
ArcCW.ConVars["mult_movespeed"] = CreateConVar("arccw_mult_movespeed", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much weapons should affect your regular movespeed.", 0)
ArcCW.ConVars["mult_movespeedads"] = CreateConVar("arccw_mult_movespeedads", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much weapons should affect your movespeed while aiming down sights.", 0)
ArcCW.ConVars["mult_movespeedfire"] = CreateConVar("arccw_mult_movespeedfire", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much weapons should affect your movespeed while firing them.", 0)
ArcCW.ConVars["add_sway"] = CreateConVar("arccw_add_sway", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Add this much sway to all weapons.", 0)

ArcCW.ConVars["override_crosshair_off"] = CreateConVar("arccw_override_crosshair_off", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Set to true to force everyone's crosshairs off.", 0, 1)
ArcCW.ConVars["override_hud_off"] = CreateConVar("arccw_override_hud_off", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Set to true to force everyone's HUDs off.", 0, 1)
ArcCW.ConVars["override_nearwall"] = CreateConVar("arccw_override_nearwall", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Disable weapon length and near-walling.", 0, 1)
ArcCW.ConVars["override_lunge_off"] = CreateConVar("arccw_override_lunge_off", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Disable melee lunging.", 0, 1)

ArcCW.ConVars["ammo_detonationmode"] = CreateConVar("arccw_ammo_detonationmode", 2, FCVAR_REPLICATED, "The type of ammo detonation to use. -1 = don't explode, 0 = simple explosion, 1 = fragmentation, 2 = full", -1, 2)
ArcCW.ConVars["ammo_autopickup"] = CreateConVar("arccw_ammo_autopickup", 1, FCVAR_REPLICATED, "Whether to pick up ammo when walking over in addition to pressing Use.", 0, 1)
ArcCW.ConVars["ammo_largetrigger"] = CreateConVar("arccw_ammo_largetrigger", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether to use larger trigger boxes for ammo, similar to HL2. Only useful when autopickup is true.", 0, 1)
ArcCW.ConVars["ammo_rareskin"] = CreateConVar("arccw_ammo_rareskin", 0.08, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Chance for a rare skin to appear. Only specific models have these.", 0, 1)
ArcCW.ConVars["ammo_chaindet"] = CreateConVar("arccw_ammo_chaindet", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether to allow ammoboxes to detonate each other. If disabled, they will still be destroyed but !explode.", 0, 1)
ArcCW.ConVars["ammo_replace"] = CreateConVar("arccw_ammo_replace", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "If enabled, all vanilla ammo entities will be forcefully replaced with ArcCW equivalents.", 0, 1)

ArcCW.ConVars["mult_ammohealth"] = CreateConVar("arccw_mult_ammohealth", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much health ammo boxes have. Set to -1 for indestructible boxes.", -1)
ArcCW.ConVars["mult_ammoamount"] = CreateConVar("arccw_mult_ammoamount", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much ammo are in ammo boxes.", 0)

ArcCW.ConVars["limityear_enable"] = CreateConVar("arccw_limityear_enable", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Limit the maximum year for weapons.")
ArcCW.ConVars["limityear"] = CreateConVar("arccw_limityear", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Limit the maximum year for weapons.")

ArcCW.ConVars["doorbust"] = CreateConVar("arccw_doorbust", 0, FCVAR_ARCHIVE, "Whether to allow door busting. 1 - break down, 2 - open only", 0, 2)
ArcCW.ConVars["doorbust_threshold"] = CreateConVar("arccw_doorbust_threshold", 80, FCVAR_ARCHIVE, "The amount of damage needed to bust a normal sized door.")
ArcCW.ConVars["doorbust_time"] = CreateConVar("arccw_doorbust_time", 180, FCVAR_ARCHIVE, "The amount of time to keep the door busted by.", 1)

ArcCW.ConVars["driveby"] = CreateConVar("arccw_driveby", 0, FCVAR_ARCHIVE, "Enable special checks that allow you to fire out of vehicles (assuming some vehicle weaponizer addon exists).", 0, 1)

ArcCW.ConVars["clicktocycle"] = CreateConVar("arccw_clicktocycle", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether to make it so left clicking after shooting cycles instead of on mouse release.")
ArcCW.ConVars["throwinertia"] = CreateConVar("arccw_throwinertia", 1, FCVAR_ARCHIVE, "Set to make throwable equipment inherit the player's velocity.", 0, 1)

ArcCW.ConVars["bullet_enable"] = CreateConVar("arccw_bullet_enable", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use physical bullets with drop and travel time.")
ArcCW.ConVars["bullet_velocity"] = CreateConVar("arccw_bullet_velocity", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED)
ArcCW.ConVars["bullet_drag"] = CreateConVar("arccw_bullet_drag", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED)
ArcCW.ConVars["bullet_lifetime"] = CreateConVar("arccw_bullet_lifetime", 10, FCVAR_ARCHIVE + FCVAR_REPLICATED)
ArcCW.ConVars["bullet_gravity"] = CreateConVar("arccw_bullet_gravity", 600, FCVAR_ARCHIVE + FCVAR_REPLICATED)

ArcCW.ConVars["weakensounds"] = CreateConVar("arccw_weakensounds", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Reduce all weapons' firing volume by this much decibels, making it easier to hide shooting sounds. Clamped to 60-150dB.")

ArcCW.ConVars["desync"] = CreateConVar("arccw_desync", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Turning this on prevents cheaters from predicting the bullet direction/spread, making the nospread cheat useless.")

ArcCW.ConVars["aimassist"] = CreateConVar("arccw_aimassist", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Enable A I M B O T", 0, 1)
ArcCW.ConVars["aimassist_head"] = CreateConVar("arccw_aimassist_head", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "My advice for you: aim for the head!", 0, 1)
ArcCW.ConVars["aimassist_cone"] = CreateConVar("arccw_aimassist_cone", 5, FCVAR_ARCHIVE + FCVAR_REPLICATED, "The angle of the cone within which targets can be seeked.", 1, 360)
ArcCW.ConVars["aimassist_distance"] = CreateConVar("arccw_aimassist_distance", 1024, FCVAR_ARCHIVE + FCVAR_REPLICATED, "The distance within which aim assist will trigger.", 128)
ArcCW.ConVars["aimassist_intensity"] = CreateConVar("arccw_aimassist_intensity", 0.5, FCVAR_ARCHIVE + FCVAR_REPLICATED, "How strong the assist is.", 0, 10)

ArcCW.ConVars["malfunction"] = CreateConVar("arccw_malfunction", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 2)

ArcCW.ConVars["attinv_giveonspawn"] = CreateConVar("arccw_attinv_giveonspawn", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Give this many random attachments to players on spawn.", 0)

ArcCW.ConVars["reloadincust"] = CreateConVar("arccw_reloadincust", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Allow players to reload when customizing.", 0, 1)
ArcCW.ConVars["freeaim"] = CreateConVar("arccw_freeaim", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 2)

-- developer stuff
ArcCW.ConVars["reloadatts_mapcleanup"] = CreateConVar("arccw_reloadatts_mapcleanup", 0, 0, "Whether to reload ArcCW attachments on admin clean up.")
ArcCW.ConVars["reloadatts_registerentities"] = CreateConVar("arccw_reloadatts_registerentities", 1, 0, "Register attachment entities. This may increase time to reload attachments.")
ArcCW.ConVars["reloadatts_showignored"] = CreateConVar("arccw_reloadatts_showignored", 0, 0, "Whether to include attachments set to Ignore.")
ArcCW.ConVars["dev_debug"] = CreateConVar("arccw_dev_debug", 0, 0, "Developer debug HUD showing cool time shit.", 0, 1)
ArcCW.ConVars["dev_shootinfo"] = CreateConVar("arccw_dev_shootinfo", 0, 0, "Show debug overlay firing information. Only works when developer is set to 1.", 0, 3)
ArcCW.ConVars["dev_alwaysready"] = CreateConVar("arccw_dev_alwaysready", 0, 0, "Always draw using the ready animation.", 0, 1)
--CreateConVar("arccw_dev_cust2beta", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use the new beta customize hud.", 0, 1)

if engine.ActiveGamemode() == "terrortown" then
    ArcCW.ConVars["ttt_replace"] = CreateConVar("arccw_ttt_replace", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use custom code to forcefully replace TTT weapons with ArcCW ones.", 0, 1)
    ArcCW.ConVars["ttt_ammo"] = CreateConVar("arccw_ttt_ammo", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Replace TTT ammo with ArcCW ones, takes precedence over the default convar.", 0, 1)
    ArcCW.ConVars["ttt_atts"] = CreateConVar("arccw_ttt_atts", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Automatically set up ArcCW weapons with an attachment loadout.", 0, 1)
    ArcCW.ConVars["ttt_customizemode"] = CreateConVar("arccw_ttt_customizemode", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "If set to 1, disallow customization on ArcCW weapons. If set to 2, players can customize during setup and postgame. If set to 3, only T and Ds can customize.", 0, 3)
    ArcCW.ConVars["ttt_bodyattinfo"] = CreateConVar("arccw_ttt_bodyattinfo", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether a corpse contains info on the attachments of the murder weapon. 1 means detective only and 2 means everyone.", 0, 2)
end
--addons/arccw_weapons/lua/arccw/shared/attachments/15a_barrel_longrange.lua:
att.PrintName = "15a Long-range Barrel"
att.Description = "DC-15a long-range barrel. Designed for Sniper purposes."
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_bipod1.png")
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = {"15a_barrel"}
att.ActivateElements = {"15a_barrel_longrange"}

att.Mult_MoveSpeed = 0.9

att.Mult_Range = 1.25
att.Mult_Recoil = 0.95
att.Mult_SightTime = 1.35
att.Mult_AccuracyMOA = 0.75

att.Mult_ShootPitch = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/15s_stock_extended.lua:
att.PrintName = "15s Extended Stock"
att.Description = "Extended Stock for DC-15s. Improves the recoil."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"15s_stock"}
att.ActivateElements = {"15s_stock_skeleton"}

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.15
att.Mult_Sway = 0.70
att.Mult_SpeedMult = 1.3
att.Mult_DrawTime = 0.76
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 0.90
--addons/arccw_weapons/lua/arccw/shared/attachments/15s_stock_skeleton.lua:
att.PrintName = "15a Skeleton Stock"
att.Description = "Extended Stock for DC-15s. Improves the recoil."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"15s_stock"}
att.ActivateElements = {"15s_stock_extended"}

att.Mult_Damage = 1
att.Mult_SightTime = 1.15
att.Mult_Sway = 0.75
att.Mult_SpeedMult = 1.1
att.Mult_DrawTime = 1
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 0.75
--addons/arccw_weapons/lua/arccw/shared/attachments/a180_barrel_extended.lua:
att.PrintName = "Extended Barrel"
att.Description = "Improves ranged performance, but at the cost of mobility."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "a180_barrele"
att.ActivateElements = {"a180_barrele"}

att.Mult_MoveSpeed = 0.9

att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_AccuracyMOA = 0.8
att.Mult_ShootPitch = 0.95

--addons/arccw_weapons/lua/arccw/shared/attachments/a180_grip.lua:
att.PrintName = "Tactical Grip"
att.Description = "Improves recoil at the cost of aim time."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "a180_grip"
att.ActivateElements = {"a180_grip"}

att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.1
att.Mult_MoveSpeed = 0.95
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_follow.lua:
att.PrintName = "Verfolgungsrakete"
att.Description = ""
att.Icon = Material("interfaz/iconos/jedi/2908166817_3227357796.png")

att.Desc_Pros = {
    "Verfolgt das ausgewhltes Ziel",
}

att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo_rocket"

att.Override_ShootEntity = "arccw_rocket_follow"
--lua/arccw/shared/attachments/arccw_hcog.lua:
att.PrintName = "Lawai HCOG (1.85x)"
att.Icon = Material("entities/arccw_hcog.png", "mips smooth")
att.Description = "The HCOG is available for most primary Pilot weapons. The sight consists of a red chevron surrounded by a clear frame, giving the user a less obstructed view than the default iron sights. It has a low zoom level. "

att.SortOrder = 4

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/optic_hcog.mdl"

att.AdditionalSights = {
    {
        Pos = Vector(0, 10, -1.35),
        Ang = Angle(0, 0, 0),
        Magnification = 1,
        IgnoreExtra = true
    },
}

att.Holosight = true
att.HolosightReticle = Material("hud/holosight/tit_hcog.png", "mips smooth")
att.HolosightNoFlare = true
att.HolosightSize = 5
att.HolosightBone = "holosight"
att.Colorable = true
att.ModelScale = Vector(1.4, 1.4, 1.4)

att.HolosightMagnification = 1

att.Mult_SightTime = 1.01

att.Colorable = false
--addons/arccw_weapons/lua/arccw/shared/attachments/muzzle_dc15a_mod.lua:
att.PrintName = "DC15-A Muzzle Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/dc15a_muzzle.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_s5_scope.lua:
att.PrintName = "S5 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/s5_default_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.2),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 13
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/s5_default_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_masita_demolition.lua:
att.PrintName = "Demolition expert"
att.Icon = Material("interfaz/iconos/kraken/sith snip marksmanship/1630896351_777900936.png")
att.Description = "You're a Demolition's expert. You can load an extra rounds for that one last punch."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "perk"

att.NotForNPC = true

att.Add_ClipSize = 5
att.Hook_Compatible = function(wep)
    if (wep.Primary.Ammo ~= "RPG_Round" and wep.Primary.Ammo ~= "SMG1_Grenade") then return false end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_grip_e11r.lua:
att.PrintName = "SW-Grip E-11R"
att.AbbrevName = "E11-r Grip"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11r_grip"

att.Model = "models/arccw/sw_battlefront/props/e11r_grip/e11r_grip.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(-90, 0, 0)
att.ModelOffset = Vector(0.5, -5.6, -0.1)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true
att.Mult_SightTime = 0.95
att.Mult_Sway = 0.85
att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 0.85
att.Mult_HolsterTime = 0.9

att.Mult_HipDispersion = 0.85


--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_mag_powerpack.lua:
att.PrintName = "SW-Power Pack"
att.AbbrevName = "40-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Power pack to offer more punch"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11_powerpack"

att.Model = "models/arccw/sw_battlefront/props/powerpack/power_pack.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 180)
att.ModelOffset = Vector(1.659, 0, 0.299)
att.ModelScale = Vector(0.8, 0.8, 0.8)

att.AutoStats = true

att.HideIfBlocked = true
att.Mult_Damage = 1.15

att.Override_ClipSize = 40

att.Mult_SightTime = 1.05
att.Mult_Sway = 1.1
att.Mult_RPM = 0.85

att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--lua/arccw/shared/attachments/uc_40mm_flash.lua:
att.PrintName = "40mm Stun Grenades" -- trol
att.AbbrevName = "Stun"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Less-than-lethal grenades that create a blinding flash and deafening bang.\nWhile typically used as hand grenades, the larger projectile allows for a more visible and audible effect."
att.Desc_Pros = {
    "uc.40mm.flash"
}
att.Desc_Cons = {
    "uc.40mm.nodmg"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.Override_ShootEntity = "arccw_uc_40mm_flash"

att.AutoStats = true

--att.Mult_Recoil = 1

att.ActivateElements = {"40mm_flash"}
--lua/arccw/shared/attachments/uc_ammo_sg_drgn.lua:
att.PrintName = "\"DRGN\" Dragon's Breath"

att.SortOrder = -1
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Novelty magnesium-based round that projects a spectacular jet of sparks and fire. Burning at over 3,000 F, the blast isn't immediately lethal, but can easily set objects and people ablaze.

Only compatible with manual action shotguns due to a weak pressure curve.]]
att.Desc_Pros = {
    "uc.ignite",
    "uc.pellet.12",
}
att.Desc_Cons = {
    "uc.accuracy.35",
    "uc.dragon",
    "uc.alwaysphys",
}
att.Desc_Neutrals = {
    "uc.manualonly",
}
att.Slot = {"ud_ammo_shotgun", "uc_ammo"}
att.ActivateElements = {"uc_manualonly"}
att.AutoStats = true

att.Add_Num = 12

-- zombies don't take damage from DMG_BURN (hardcoded to set them on fire)
local dontburn = {
    npc_zombie = true,
    npc_zombie_torso = true,
    npc_zombine = true,
    npc_fastzombie = true,
    npc_fastzombie_torso = true,
    npc_headcrab = true,
    npc_headcrab_fast = true,
    npc_headcrab_black = true,
}

att.Hook_PhysBulletHit = function(wep, data)
    if SERVER and data.tr.Entity then
        local d = data.bullet.Travelled * ArcCW.HUToM
        local dur = 6 - d * 2 / wep.Range
        if dur > 0 then
            data.tr.Entity:Extinguish()
            data.tr.Entity:Ignite(dur)
        end

        local delta = math.Clamp(d / data.bullet.Range, 0, 1)

        -- Impact is disabled (no bullet holes) so we do damage ourselves
        local dmg = DamageInfo()
        dmg:SetAttacker(data.bullet.Attacker)
        dmg:SetInflictor(data.bullet.Weapon)
        dmg:SetDamage(Lerp(delta, data.bullet.DamageMax, data.bullet.DamageMin))
        dmg:SetDamagePosition(data.bullet.Pos)
        dmg:SetDamageForce(data.bullet.Vel)
        dmg:SetDamageType(dontburn[data.tr.Entity:GetClass()] and DMG_BUCKSHOT or (DMG_BURN + DMG_BUCKSHOT))

        data.tr.Entity:TakeDamageInfo(dmg)
    end

    local effect = EffectData()
    effect:SetOrigin(data.tr.HitPos)
    util.Effect("StunstickImpact",effect)
    
    if data.tr.HitWorld then
        util.Decal("FadingScorch",data.tr.HitPos - data.tr.HitNormal,data.tr.HitPos + data.tr.HitNormal)
    end
end

att.Override_PhysBulletImpact = false

att.Override_DamageType = DMG_BURN + DMG_BUCKSHOT

att.Override_HullSize = 2
att.Override_HullSize_Priority = 100
att.Add_AccuracyMOA = 35
att.Mult_Damage = .5
att.Mult_DamageMin = .5

att.Override_AlwaysPhysBullet = true
att.Override_PhysBulletMuzzleVelocity = 100
att.Mult_PhysBulletGravity = 0.75
att.Override_PhysBulletDrag = 4

att.Override_PhysTracerProfile = "uc_dragon"
att.Override_MuzzleEffect = "muzzleflash_dragonbreath"

att.Override_UC_ShellColor = Color(0.9 * 255, 0.3 * 255, 0.1 * 255)

att.Hook_AddShootSound = function(wep, data)
    wep:EmitSound("DB_ADD", data.volume,data.pitch,1,CHAN_WEAPON - 1) -- lua/arccw/shared/sh_0_uc.lua
end

att.GivesFlags = {"needsmanual"}
att.Hook_Compatible = function(wep)
    if (!wep.ManualAction and !wep.UC_CanManualAction) or !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then return false end
end
--lua/arccw/shared/attachments/uc_ammo_tr.lua:
att.PrintName = "\"TR\" Tracer Rounds"
att.AbbrevName = "\"TR\" Tracer"

att.SortOrder = 1
att.Icon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth")
att.Description = "A pyrotechnic charge inside the bullet creates a bright, colorful trail behind it during flight. The bright trails can help the shooter predict ballistic trajectories without using sights."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.tracer"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_ammo"

att.AutoStats = true

att.Mult_HipDispersion = 0.85

att.ToggleStats = {
    {
        PrintName = "Green",
        Override_PhysTracerProfile = "uc_tracer_g"
    },
    {
        PrintName = "Red",
        Override_PhysTracerProfile = "uc_tracer_r"
    },
    {
        PrintName = "White",
        Override_PhysTracerProfile = "uc_tracer_w"
    },
}
att.Override_Tracer = "arccw_uc_tracer"

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_choke_cyl.lua:
att.PrintName = "Cylinder Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A mildly tight shotgun choke. Tightens pellet spread at the cost of straight recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = 1.1
att.Mult_AccuracyMOA = .9
--lua/arccw/shared/attachments/uc_fg_autotrigger.lua:
att.PrintName = "Forced Reset Trigger"

att.Icon = Material("entities/att/arccw_uc_forcedresettrigger.png", "mips smooth")
att.Description = "Trigger system that pushes back against the shooter's finger, allowing them to fire much more rapidly. By the definition of the ATF, this does not count as full-automatic, for the time being at least."
att.Desc_Pros = {
    "uc.auto"
}
att.Desc_Cons = {
    "uc.frcd_visrec"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true
att.SortOrder = 2

att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() or wep.TriggerDelay then return false end

    -- for i, v in pairs(wep.Firemodes) do
    --     if !v then continue end
    --     if !v.Mode then continue end
    --     if v.Mode == 2 then
    --         -- Not available if gun has automatic firemode
    --         return false
    --     -- elseif v.Mode < 0 then
    --     --     -- Use burst variant
    --     --     return false
    --     end
    -- end
end

att.Override_Firemodes_Priority = 100
att.Override_Firemodes = {
    {
        PrintName = "fcg.frcd",
        Mode = 2,
    },
    {
        Mode = 0
    }
}

--att.Mult_RPM = 1.25
att.Mult_RecoilSide = 1.25
att.Mult_VisualRecoilMult = 2
att.Mult_MalfunctionMean = .85

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"

att.ExcludeFlags = {"needsmanual"}
--lua/arccw/shared/attachments/uc_grip_handstop.lua:
att.PrintName = "Handstop"
att.AbbrevName = "Handstop"
att.Icon = Material("entities/att/acwatt_uc_grip_handstop.png", "mips smooth")
att.Description = "Prevents the hand from sliding down the barrel, allowing improved point shooting precision."

att.SortOrder = 1100

att.AutoStats = true
att.Slot = "foregrip"

--att.LHIK = true

att.ModelOffset = Vector(2, 0, -0.8)
att.Model = "models/weapons/arccw/atts/uc_handstop.mdl"
att.ModelSkin = 1

--[[] need to add add_activepos
att.Override_ActivePos = Vector(-0.5, -0.5, 0.5)
att.Override_ActiveAng = Angle(0, 0, -7) no it looks shit on everything STOP!!!]]

att.Mult_HipDispersion = 0.8
att.Mult_ShootSpeedMult = 0.9
att.Mult_Sway = 0.85
--lua/arccw/shared/attachments/uc_muzzle_supp_pbs1.lua:
att.PrintName = "PBS-1 Suppressor"

att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_pbs1.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nGas redirection causes the side benefit of straightening recoil."
att.Desc_Neutrals = {"uc.exclusive.762", "uc.supptail"}

att.AutoStats = true
att.Slot = {"ur_ak_muzzle"}

att.SortOrder = 149

att.Model = "models/weapons/arccw/atts/uc_pbs1.mdl"
att.ModelOffset = Vector(2.9, 0, 0)
att.ModelScale = Vector(1.3, 1.3, 1.3)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_RecoilSide = 0.75

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep)
    if wep.Primary.Ammo != "ar2" then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_muzzle_supp_tac.lua:
att.PrintName = "Mountain Armory Tactical Suppressor" -- fictional
att.AbbrevName = "Tactical Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_tactical.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nLow-profile and enhances ballistics, but slightly cumbersome."
att.Desc_Neutrals = {"uc.exclusive.rifle", "uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_tactical.mdl"
att.ModelOffset = Vector(2.25, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Range = 1.1

att.Add_BarrelLength = 4
att.Mult_SightTime = 1.07
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep,data)
    if !ArcCW.UC.RifleAmmoTypes[wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo)] then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_tp_overload.lua:
att.PrintName = "Overload"

att.Icon = Material("entities/att/arccw_uc_tp_overload.png", "smooth mips")
att.Description = "With a little grease and some physical force, most magazines can be made to accept an extra round."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 8

att.Add_ClipSize = 1

att.Hook_Compatible = function(wep)
    if wep.RejectMagSizeChange or wep:GetCapacity() == 1 then return false end
end

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_tp_pointman.lua:
att.PrintName = "Pointman"

att.Icon = Material("entities/att/arccw_uc_tp_pointman.png", "smooth mips")
att.Description = "Firearms and dexterity training for quick response in breaching situations. Drills in confined spaces allow you to more effectively handle long weapons in close quarters.\n\nThe pointman is always the first to enter, and the first to identify and disable threats."
att.Desc_Pros = {
    "uc.pointman"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 7

att.Add_BarrelLength = -10
att.M_Hook_Mult_RPM = function(wep, data)
    if wep:GetCurrentFiremode().Mode == 1 then
        data.mult = data.mult * 1.15
    end
end

att.NotForNPCs = true
--lua/arccw/client/cl_0_uc_wepsel.lua:
surface.CreateFont("UCWepSel", {
    font = "Bahnschrift",
    size = 36,
    weight = 0,
    blursize = 0,
    antialias = true,
})

surface.CreateFont("UCWepSel2", {
    font = "Bahnschrift Light",
    size = 17,
    weight = 0,
    blursize = 0,
    antialias = true,
})

surface.CreateFont("UCWepSel3", {
    font = "Bahnschrift Light",
    size = 13,
    weight = 0,
    blursize = 0,
    antialias = true,
})

local PANEL = {}

local matOverlay_AdminOnly = Material("icon16/shield.png")
local matOverlay_NPCWeapon = Material("icon16/monkey.png")
local matOverlay_NPCWeaponSelected = Material("icon16/monkey_tick.png")

AccessorFunc(PANEL, "m_Color", "Color")
AccessorFunc(PANEL, "m_Type", "ContentType")
AccessorFunc(PANEL, "m_SpawnName", "SpawnName")
AccessorFunc(PANEL, "m_NPCWeapon", "NPCWeapon")
AccessorFunc(PANEL, "m_bAdminOnly", "AdminOnly")
AccessorFunc(PANEL, "m_bIsNPCWeapon", "IsNPCWeapon")

function PANEL:Init()
    self:SetPaintBackground(false)
    -- local sw, sh = self:GetParent():GetParent():GetParent():GetSize()
    self:SetSize(384*0.9, 128) -- TODO: get real long n har. nvm
    self:SetText("")
    self:SetDoubleClickingEnabled(false)
    self.Image = self:Add("DImage")
    self.Image:SetPos(3, 3)
    self.Image:SetSize(128 - 6, 128 - 6)
    self.Image:SetVisible(false)
    self.Border = 0
end

function PANEL:SetName(name, spname, other)
    self:SetTooltip(name .. "\n" .. spname)
    self.WEP_NAME = name
    self.WEP_MANU = other.manu
    self.WEP_YEAR = other.year
    self.WEP_CALI = other.cali
    --self.Label:SetText( name )
    --self.Label2:SetText( name )
    self.m_NiceName = name
end

function PANEL:SetMaterial(name)
    self.m_MaterialName = name
    local mat = Material(name)

    -- Look for the old style material
    if not mat or mat:IsError() then
        name = name:Replace("entities/", "VGUI/entities/")
        name = name:Replace(".png", "")
        mat = Material(name)
    end

    -- Couldn't find any material.. just return
    if not mat or mat:IsError() then
        mat = Material("entities/ucepicfail.png")
    end

    self.Image:SetMaterial(mat)
end

function PANEL:DoRightClick()
    local pCanvas = self:GetSelectionCanvas()
    if IsValid(pCanvas) and pCanvas:NumSelectedChildren() > 0 and self:IsSelected() then return hook.Run("SpawnlistOpenGenericMenu", pCanvas) end
    self:OpenMenu()
end

function PANEL:DoClick()
end

function PANEL:OpenMenu()
end

function PANEL:OnDepressionChanged(b)
end

function PANEL:Paint(w, h)
    if self.Depressed and not self.Dragging then
        if self.Border ~= 8 then
            self.Border = 8
            self:OnDepressionChanged(true)
        end
    else
        if self.Border ~= 0 then
            self.Border = 0
            self:OnDepressionChanged(false)
        end
    end

    surface.SetDrawColor(255, 255, 255, 255)

    if not dragndrop.IsDragging() and (self:IsHovered() or self.Depressed or self:IsChildHovered()) then
        surface.SetMaterial(Material("entities/uchover.png"))
        surface.DrawTexturedRect(self.Border, self.Border, w, h)
    end

    --surface.SetMaterial( matOverlay_Normal )
    --self.Label:Show()
    local c_w, c_s = Color(255, 255, 255, 200), Color(0, 0, 0, 127)

    -- Name
    if assert(self.WEP_NAME, "Holy balls no weapon name??") then
        surface.SetFont("UCWepSel")
        surface.SetTextPos((128 + 16) + 2, (50 - 24) + 2)
        surface.SetTextColor(c_s)
        surface.DrawText(self.WEP_NAME or "idk")
        surface.SetTextPos(128 + 16, 50 - 24)
        surface.SetTextColor(color_white)
        surface.DrawText(self.WEP_NAME or "idk")
    end

    local ya = false

    if self.WEP_MANU then
        -- Manufacturer
        surface.SetFont("UCWepSel2")
        surface.SetTextPos((128 + 16) + 2, (50 - 24 + 32) + 2)
        surface.SetTextColor(c_s)
        surface.DrawText(self.WEP_MANU or "idk")
        surface.SetTextPos(128 + 16, 50 - 24 + 32)
        surface.SetTextColor(c_w)
        surface.DrawText(self.WEP_MANU or "idk")
        ya = true
    end

    if self.WEP_CALI then
        -- Caliber
        surface.SetFont("UCWepSel3")
        surface.SetTextPos((128 + 16) + 2, (50 - 24 + 32 + (ya and 16 or 0)) + 2)
        surface.SetTextColor(c_s)
        surface.DrawText(self.WEP_CALI or "idk")
        surface.SetTextPos(128 + 16, 50 - 24 + 32 + (ya and 16 or 0))
        surface.SetTextColor(c_w)
        surface.DrawText(self.WEP_CALI or "idk")
    end

    if self.WEP_YEAR then
        -- Year
        surface.SetFont("UCWepSel3")
        surface.SetTextPos((128 + 16) + 2, (50 - 31) + 2)
        surface.SetTextColor(c_s)
        surface.DrawText(self.WEP_YEAR or "9999")
        surface.SetTextPos(128 + 16, 50 - 31)
        surface.SetTextColor(c_w)
        surface.DrawText(self.WEP_YEAR or "9999")
    end

    render.PushFilterMag(TEXFILTER.ANISOTROPIC)
    render.PushFilterMin(TEXFILTER.ANISOTROPIC)
    self.Image:PaintAt(3 + self.Border, 3 + self.Border, 128 - 8 - self.Border * 2, 128 - 8 - self.Border * 2)
    render.PopFilterMin()
    render.PopFilterMag()

    --surface.DrawTexturedRect( self.Border, self.Border, w-self.Border*2, h-self.Border*2 )
    if self:GetAdminOnly() then
        surface.SetMaterial(matOverlay_AdminOnly)
        surface.DrawTexturedRect(self.Border + 8, self.Border + 8, 16, 16)
    end

    -- This whole thing could be more dynamic
    if self:GetIsNPCWeapon() then
        surface.SetMaterial(matOverlay_NPCWeapon)

        if self:GetSpawnName() == GetConVar("gmod_npcweapon"):GetString() then
            surface.SetMaterial(matOverlay_NPCWeaponSelected)
        end

        surface.DrawTexturedRect(w - self.Border - 24, self.Border + 8, 16, 16)
    end

    self:ScanForNPCWeapons()
end

function PANEL:ScanForNPCWeapons()
    if self.HasScanned then return end
    self.HasScanned = true

    for _, v in pairs(list.Get("NPCUsableWeapons")) do
        if v.class == self:GetSpawnName() then
            self:SetIsNPCWeapon(true)
            break
        end
    end
end

function PANEL:PaintOver(w, h)
    self:DrawSelections()
end

function PANEL:ToTable(bigtable)
    local tab = {}
    tab.type = self:GetContentType()
    tab.nicename = self.m_NiceName
    tab.material = self.m_MaterialName
    tab.admin = self:GetAdminOnly()
    tab.spawnname = self:GetSpawnName()
    tab.weapon = self:GetNPCWeapon()
    table.insert(bigtable, tab)
end

function PANEL:Copy()
    local copy = vgui.Create("UCWepSel", self:GetParent())
    copy:SetContentType(self:GetContentType())
    copy:SetSpawnName(self:GetSpawnName())
    copy:SetName(self.m_NiceName, self:GetSpawnName())
    copy:SetMaterial(self.m_MaterialName)
    copy:SetNPCWeapon(self:GetNPCWeapon())
    copy:SetAdminOnly(self:GetAdminOnly())
    copy:CopyBase(self)
    copy.DoClick = self.DoClick
    copy.OpenMenu = self.OpenMenu
    copy.OpenMenuExtra = self.OpenMenuExtra

    return copy
end

vgui.Register("UCWepSel", PANEL, "DButton")
--lua/autorun/atrt_sounds.lua:
sound.Add( {
	name = "atrt.step1",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step1.wav"
} )

sound.Add( {
	name = "atrt.step2",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step2.wav"
} )

sound.Add( {
	name = "atrt.shoot",
	channel = CHAN_BODY,
	volume = 1.0,
	level = 90,
	pitch = { 95, 105 },
	sound = {
	"KingPommes/starwars/atrt/shoot1.wav",
	"KingPommes/starwars/atrt/shoot2.wav" }
} )

sound.Add( {
	name = "atrt.standup",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/standup.wav"
} )

sound.Add( {
	name = "atrt.sitdown",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/sitdown.wav"
} )
--addons/weapons_other/lua/autorun/autorun_breachingcharge.lua:
////////////////////////////////////////////////////////////////
//  Breaching Charge, Autorun
//  Programmed by Sevan Buechele
//  @   Copyright 2018  Sevan Buechele
//  @   All Rights Reserved.
/////////////////////////////////////////////////////////////

/*|Ammo Type|*/
game.AddAmmoType({
	name = "ammo_breachingcharge",
	dmgtype = DMG_BLAST
})

/*|Console Variables|*/
CreateConVar("sv_breachingcharge_startingammo",3,FCVAR_SERVER_CAN_EXECUTE,"This setting changes the initial ammo given.")
CreateConVar("sv_breachingcharge_enabledoorbust",0,FCVAR_SERVER_CAN_EXECUTE,"This allows doors to be busted down.")
CreateConVar("sv_breachingcharge_enablepropunfreeze",0,FCVAR_SERVER_CAN_EXECUTE,"This allows props to be unfrozen.")
CreateConVar("sv_breachingcharge_canplace",0,FCVAR_SERVER_CAN_EXECUTE,"This setting changes what surface the breaching charge can be placed on.")
CreateConVar("sv_breachingcharge_debughands",0,FCVAR_SERVER_CAN_EXECUTE,"This setting fixes custom hands that are incompatible.")
--addons/aoc_fire_system/lua/ch_fire_system/shared/fire_config.lua:
CH_FireSystem = CH_FireSystem or {}
CH_FireSystem.Config = CH_FireSystem.Config or {}
CH_FireSystem.Config.FiretruckModels = CH_FireSystem.Config.FiretruckModels or {}

-- Set Language
-- Available languages: English: en - French: fr - Danish: da - German: de - Russian: ru - Spanish: es - Chinese: cn
CH_FireSystem.Config.Language = "en" -- Set the language of the script.

--[[
	General Config
--]]
CH_FireSystem.Config.MaterialTypes = { -- Full list of material types (ground types), that fire can spread on. For example: wood, grass, carpet.
	MAT_DIRT,
	MAT_WOOD,
	MAT_COMPUTER,
	MAT_FOLIAGE,
	MAT_PLASTIC,
	MAT_SAND,
	MAT_SLOSH,
	MAT_TILE,
	MAT_GRASS,
	MAT_VENT -- THE LAST LINE SHOULD NOT HAVE A COMMA AT THE END. BE AWARE OF THIS WHEN EDITING THIS!
}
-- List of potential MAT enums: https://wiki.garrysmod.com/page/Enums/MAT

CH_FireSystem.Config.AllowedTeams = { -- This is a list of fire fighter teams. You can add fire chief and stuff like that, and they can do the things fire fighters can.
	-- Please note that this table has to be set up as the one above. If you add more teams, you must add a comma to the team at the top. Only the last team should not have a comma. By default there is only one team, so no comma is needed.
	"Fire Fighter",
	"Fire Fighter Chief" -- THE LAST TEAM SHOULD NOT HAVE A COMMA
}

CH_FireSystem.Config.MaxFires = 250 -- Maximum amount of fires that can spawn/spread. [Default = 250]
CH_FireSystem.Config.RandomFireInterval = 300 -- Interval between random fires are generated around the map. [Default = 300 (5 minutes)]
CH_FireSystem.Config.RemoveAllOnLastDC = false -- Remove all fires when there are no more players on the server (to prevent lag?). [Default = false]
CH_FireSystem.Config.SpreadInterval = 120 -- Time between fire spreads (in seconds). [Default = 120 (2 minutes)]
CH_FireSystem.Config.ExtinguishPay = 10 -- Payment for turning off a fire. [Default = 10]
CH_FireSystem.Config.NotifyOnExtinguish = true -- Send the player a notification that they've received money for extinguishing fire. [Default = true]
CH_FireSystem.Config.AutoTurnOff = 600 -- Fire will automatically turn off after x seconds. 0 and it will burn until put out with extinguisher. [Default = 600/10 minutes]
CH_FireSystem.Config.RandomizeFireSpawn = true -- Will randomize if a fire spawns or not when CH_FireSystem.Config.RandomFireInterval hits 0. true is enabled, false is disabled. [Default = true]
CH_FireSystem.Config.FireFightersRequired = 1 -- How many fire fighters are required before fires will start? [Default = 1]

CH_FireSystem.Config.EnableSmokeEffect = false -- Disable/Enable the smoke effect that emits from fire (true/false) [Default = false]

CH_FireSystem.Config.ExtinguishAllFiresOnFFLeave = true -- Should all fires turn off when the last fire fighter leave their job. [Default = true]

--[[
	Fire Damage Config
--]]
CH_FireSystem.Config.FireFighterDamage = 2 -- The amount of damage fire fighters should take from standing in fire. [Default = 2]
CH_FireSystem.Config.FireDamage = 4 -- The amount of damage everyone else should take from standing in fire. [Default = 4]
CH_FireSystem.Config.VehicleDamage = 6 -- The amount of damage vehicles should take from being in fire. [Default = 6]
CH_FireSystem.Config.DamageInterval = 0.5 -- The amount of time between taking damage when standing in fire (in seconds). [Default = 0.5]
CH_FireSystem.Config.RemovePropTimer = 10 -- Time amount of seconds before a prop is removed after it ignites (if it is not extinguished). [Default = 10]

CH_FireSystem.Config.BurntPropColor = Color(120, 120, 120, 255) -- If a prop hits the fire, it will set on fire and turn into this color (burnt color). [Default = Color(120, 120, 120, 255)]
CH_FireSystem.Config.IgniteProps = true -- Should props ignite when touched by fire? [Default = true]  
CH_FireSystem.Config.SetPlayersOnFire = true -- Should players actually ignite when touched by fire? [Default = true]
CH_FireSystem.Config.PlayerOnFireDuration = 10 -- Amount of seconds the player should be on fire? [Default = 10]

CH_FireSystem.Config.EnableSmokeDamage = true -- Basically changes the distance between fire and player before damage is taken. For realistic, say it's the smoke "killing" the player.

--[[
	Firetruck NPC Config
--]]
CH_FireSystem.Config.NPCModel = "models/odessa.mdl" -- This is the model of the NPC to get a firetruck from.
CH_FireSystem.Config.MaxTrucks = 3 -- The maximum amount of firetrucks allowed in total on the server.
CH_FireSystem.Config.UseRequiredULXRanks = true -- Should the firetrucks be restricted by ulx ranks? [Default = true]

CH_FireSystem.Config.NPCDisplayName = "Fireman Sam" -- NAME (text for overhead display)
CH_FireSystem.Config.NPCDisplayDescription = "Retrieve a firetruck here" -- Text for overhead display
CH_FireSystem.Config.OverheadTextDisplay = false -- Should the new overhead text display show?
CH_FireSystem.Config.OverheadSpinningBubble = true -- Should the chat bubble model spin on top of the firetruck NPC?
CH_FireSystem.Config.DistanceTo3D2D = 400000 -- Distance between player and supply crate/money bag before text appears.

--[[
	Fire Axe Config
--]]
CH_FireSystem.Config.AxeFireRange = 450 -- If there is fire within this range of the door, firefighters can open it. [Default = 450]
CH_FireSystem.Config.AxePlayerDamage = 5 -- How much damage should the fire axe do to players. [Default = 5 (0 for disabled)]

--[[
	Fire Pyro Job
--]]
CH_FireSystem.Config.EnablePyroJob = true -- If you want to enable the pyro job and the cheap molotov cocktail, set this to true. If not, set it to false. [Default = true]

--[[
	Fire Extinguisher Citizen
--]]
CH_FireSystem.Config.FireExtRemoveTimer = 20 -- The amount of seconds before the fire fighter is removed from the citizen after he start using it. [Default = 20 (Recommended)]
CH_FireSystem.Config.ExtinguishCitizenPay = 4 -- Payment for turning off a fire as a non-firefighter. [Default = 4]

--[[
	Fire Extinguish Config
--]]
CH_FireSystem.Config.ExtinguisherRandomSpeed = math.random( 2, 4 ) -- Modify the amount of "damage" the extinguisher will do to fire. Default means between 1 and 3. To make it faster put for example math.random( 3, 5 )
CH_FireSystem.Config.HoseRandomSpeed = math.random( 4, 6 ) -- Modify the amount of "damage" the fire hose will do to fires. Keep in mind the "Weapons DLC" is required to get the fire hose.

--[[
	Fire Extinguisher Cabinet
--]]
CH_FireSystem.Config.CabinetCooldown = 600 -- Cooldown between taking a fire extinguisher from the cabinet. IN SECONDS

--[[
	Fire Admin Chat Commands
--]]
CH_FireSystem.Config.ChatCommandFireOff = "!fireoff"
CH_FireSystem.Config.ChatCommandSpawnFire = "!spawnfire"
CH_FireSystem.Config.ChatCommandValidFires = "!validfires"
CH_FireSystem.Config.ChatCommandStartAllFires = "!startall"
CH_FireSystem.Config.ChatCommandFireAmount = "!fireamount"

--[[
	XP SUPPORT
--]]
CH_FireSystem.Config.DarkRPLevelSystemEnabled = false -- DARKRP LEVEL SYSTEM BY vrondakis https://github.com/uen/Leveling-System
CH_FireSystem.Config.SublimeLevelSystemEnabled = false -- Sublime Levels by HIGH ELO CODERS https://www.gmodstore.com/market/view/6431
CH_FireSystem.Config.EssentialsXPSystemEnabled = false -- Brick's Essentials and/or DarkRP Essentials by Brickwall https://www.gmodstore.com/market/view/5352 & https://www.gmodstore.com/market/view/7244
CH_FireSystem.Config.EXP2SystemEnabled = false -- Elite XP SYstem (EXP2) By Axspeo https://www.gmodstore.com/market/view/4316
CH_FireSystem.Config.GlorifiedLevelingXPSystem = false -- GlorifiedLeveling by GlorifiedPig https://www.gmodstore.com/market/view/7254

CH_FireSystem.Config.ExtinguishFireMinXP = 50 -- Amount of XP given when extinguishing fire (minimum amount)
CH_FireSystem.Config.ExtinguishFireMaxXP = 50 -- Amount of XP given when extinguishing fire (maximum amount). The amount is randomized between these two values.
--addons/tools/lua/autorun/denyphysgun.lua:
properties.Add("denyphysgun", {
	MenuLabel = "Untouchable machen",
	Order = 401,
	MenuIcon = "icon16/link.png",
	Filter = function(self, ent, ply)
		if not IsValid(ent) then return false end
		if ent:IsPlayer() then return false end
        if not AOCRP.Admin:IsTeamMember(ply) then return false end

		return not ent:GetNWBool("untouchable")
	end,
	Action = function(self, ent)
		self:MsgStart()
		    net.WriteEntity(ent)
		self:MsgEnd()
	end,
	Receive = function(self, length, ply)
		local ent = net.ReadEntity()
		if not IsValid(ent) then return end
		if not properties.CanBeTargeted(ent, ply) then return end
		if not self:Filter(ent, ply) then return end
        if not AOCRP.Admin:IsTeamMember(ply) then return false end

		ent:SetNWBool("untouchable", true)
		ent:SetUnFreezable(ent:GetNWBool("untouchable", true))
	end
})

properties.Add("denyphysgun_off", {
	MenuLabel = "Touchable machen",
	Order = 401,
	MenuIcon = "icon16/link_break.png",
	Filter = function(self, ent, ply)
		if not IsValid(ent) then return false end
		if ent:IsPlayer() then return false end
        if not AOCRP.Admin:IsTeamMember(ply) then return false end

		return ent:GetNWBool("untouchable")
	end,
	Action = function(self, ent)
		self:MsgStart()
		    net.WriteEntity(ent)
		self:MsgEnd()
	end,
	Receive = function(self, length, ply)
		local ent = net.ReadEntity()
		if not IsValid(ent) then return end
		if not properties.CanBeTargeted(ent, ply) then return end
		if not self:Filter(ent, ply) then return end
        if not AOCRP.Admin:IsTeamMember(ply) then return false end

		ent:SetNWBool("untouchable", false)
		ent:SetUnFreezable(ent:GetNWBool("untouchable", false))
	end
})

hook.Add("PhysgunPickup", "stikAllowPhysgunPickup", function(_, entity)
	if entity:GetNWBool("untouchable", false) then return false end
end)
--addons/billy_gas/lua/gmodadminsuite/sh_offline_player_data.lua:
AddCSLuaFile()

GAS.OfflinePlayerData = {callbacks = {}, data = {}}

if (CLIENT) then
	local function L(phrase, ...)
		if (#({...}) == 0) then
			return GAS:Phrase(phrase)
		else
			return GAS:PhraseFormat(phrase, ...)
		end
	end

	GAS:netReceive("offline_player_data", function()
		local account_id = net.ReadUInt(31)
		local nick = net.ReadString()
		local usergroup = net.ReadString()
		GAS.OfflinePlayerData.data[account_id] = {nick = nick, usergroup = usergroup}
		
		if (GAS.OfflinePlayerData.callbacks[account_id]) then
			for i,v in ipairs(GAS.OfflinePlayerData.callbacks[account_id]) do
				table.remove(GAS.OfflinePlayerData.callbacks[account_id], i)
				v(true, GAS.OfflinePlayerData.data[account_id])
			end
		end
	end)

	GAS:netReceive("offline_player_data_failed", function()
		local account_id = net.ReadUInt(31)
		GAS.OfflinePlayerData.data[account_id] = false

		if (GAS.OfflinePlayerData.callbacks[account_id]) then
			for i,v in ipairs(GAS.OfflinePlayerData.callbacks[account_id]) do
				table.remove(GAS.OfflinePlayerData.callbacks[account_id], i)
				v(false)
			end
		end
	end)

	GAS:InitPostEntity(function()
		if (system.GetCountry() and #system.GetCountry() > 0) then
			GAS:netStart("offline_player_data_country_code")
				net.WriteString(system.GetCountry())
			net.SendToServer()
		end
	end)
else
	GAS:untimer("offline_player_data_update")

	local cached_offline_data = {}

	GAS_OfflinePlayerData_CountryCodes = GAS_OfflinePlayerData_CountryCodes or {}
	function GAS.OfflinePlayerData:Update(ply)
		GAS.Database:Prepare("REPLACE INTO gas_offline_player_data (`server_id`, `account_id`, `nick`, `usergroup`, `ip_address`, `country_code`, `last_seen`) VALUES(?,?,?,?,?,?,CURRENT_TIMESTAMP())", {GAS.ServerID, ply:AccountID(), utf8.force(ply:Nick()), ply:GetUserGroup(), (ply:IPAddress():gsub(":%d+$","")), GAS_OfflinePlayerData_CountryCodes[ply] or NULL})
	end

	local function sql_init()
		GAS.Database:ServerID(function()
			local function update_data()
				GAS.Database:BeginTransaction()
				for _,ply in ipairs(player.GetHumans()) do
					local data_hash = util.CRC(ply:Nick() .. ply:GetUserGroup() .. ply:IPAddress() .. (GAS_OfflinePlayerData_CountryCodes[ply] or ""))
					if (data_hash ~= cached_offline_data[ply]) then
						cached_offline_data[ply] = data_hash
						GAS.OfflinePlayerData:Update(ply)
					end
				end
				GAS.Database:CommitTransaction()
			end
			update_data()
			GAS:timer("offline_player_data_update", 60, 0, update_data)
		end)
	end
	if (GAS.Database.MySQLDatabase) then
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS `gas_offline_player_data` (
				`server_id` int(11) NOT NULL,
				`account_id` int(11) UNSIGNED NOT NULL,
				`nick` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
				`usergroup` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
				`ip_address` varchar(15) CHARACTER SET ascii NOT NULL,
				`country_code` char(3) CHARACTER SET ascii COLLATE ascii_general_ci DEFAULT NULL,
				`last_seen` timestamp NOT NULL,
				PRIMARY KEY (`server_id`, `account_id`)
			);

		]], function()

			GAS.Database:Query("SHOW COLUMNS FROM `gas_offline_player_data` WHERE `Field`='country_code'", function(rows)
				if (not rows or #rows == 0) then
					GAS.Database:Query("ALTER TABLE `gas_offline_player_data` ADD `country_code` CHAR(3) CHARACTER SET ascii COLLATE ascii_general_ci DEFAULT NULL AFTER `ip_address`, ADD INDEX (`country_code`), ADD INDEX (`usergroup`), ADD INDEX (`ip_address`)", sql_init)
				else
					sql_init()
				end
			end)

		end)
	else
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS "gas_offline_player_data" (
				"server_id" INTEGER NOT NULL,
				"account_id" INTEGER NOT NULL,
				"nick" TEXT NOT NULL,
				"usergroup" TEXT NOT NULL,
				"ip_address" TEXT NOT NULL,
				"country_code" TEXT DEFAULT NULL,
				"last_seen" INTEGER NOT NULL,
				PRIMARY KEY ("server_id", "account_id")
			);

			CREATE INDEX IF NOT EXISTS gas_opd_usergroup_index ON gas_offline_player_data ("usergroup");
			CREATE INDEX IF NOT EXISTS gas_opd_country_code_index ON gas_offline_player_data ("country_code");
			CREATE INDEX IF NOT EXISTS gas_opd_ip_address_index ON gas_offline_player_data ("ip_address");

		]], function()

			GAS.Database:Query("PRAGMA table_info(`gas_offline_player_data`)", function(rows)
				local found = false
				for _,row in ipairs(rows) do
					if (row.name == "country_code") then
						found = true
						break
					end
				end
				if (not found) then
					GAS.Database:Query("ALTER TABLE `gas_offline_player_data` ADD COLUMN `country_code` TEXT DEFAULT NULL", sql_init)
				else
					sql_init()
				end
			end)

		end)
	end

	GAS:netInit("offline_player_data")
	GAS:netInit("offline_player_data_failed")

	GAS:netReceive("offline_player_data", function(ply)
		local account_id = net.ReadUInt(31)
		local target_ply = player.GetByAccountID(account_id)
		if (IsValid(target_ply)) then
			GAS:netStart("offline_player_data")
				net.WriteUInt(account_id, 31)
				net.WriteString(target_ply:Nick())
				net.WriteString(target_ply:GetUserGroup())
			net.Send(ply)
		else
			GAS.Database:Prepare("SELECT `nick`, `usergroup` FROM gas_offline_player_data WHERE `server_id`=? AND `account_id`=?", {GAS.ServerID, account_id}, function(rows)
				if (not rows or #rows == 0) then
					GAS:netStart("offline_player_data_failed")
						net.WriteUInt(account_id, 31)
					net.Send(ply)
				else
					GAS:netStart("offline_player_data")
						net.WriteUInt(account_id, 31)
						net.WriteString(rows[1].nick)
						net.WriteString(rows[1].usergroup)
					net.Send(ply)
				end
			end)
		end
	end)

	GAS:netInit("offline_player_data_country_code")
	GAS:netReceive("offline_player_data_country_code", function(ply)
		local country_code = net.ReadString()
		if (GAS_OfflinePlayerData_CountryCodes[ply]) then return end
		if (#country_code > 0 and #country_code <= 3) then
			GAS_OfflinePlayerData_CountryCodes[ply] = country_code
			GAS.Database:Prepare("UPDATE gas_offline_player_data SET `country_code`=? WHERE `account_id`=?", {country_code:upper(), ply:AccountID()})
		end
	end)

	GAS:hook("onPlayerChangedName", "offline_player_data:ChangeName", function(ply, _, name)
		GAS.Database:Prepare("UPDATE gas_offline_player_data SET `nick`=? WHERE `account_id`=?", {name, ply:AccountID()})
	end)
end

function GAS.OfflinePlayerData:SteamID64(steamid64, callback)
	print("deprecated", steamid64)
	debug.Trace()
	return GAS.OfflinePlayerData:AccountID(GAS:SteamID64ToAccountID(steamid64), callback)
end

function GAS.OfflinePlayerData:AccountID(account_id, callback)
	local ply = player.GetByAccountID(account_id)
	if (IsValid(ply)) then
		GAS.OfflinePlayerData.data[account_id] = {nick = ply:Nick(), usergroup = ply:GetUserGroup()}
		callback(true, GAS.OfflinePlayerData.data[account_id])
	else
		if (CLIENT) then
			if (GAS.OfflinePlayerData.data[account_id] ~= nil) then
				if (GAS.OfflinePlayerData.data[account_id] == false) then
					callback(false)
				else
					callback(true, GAS.OfflinePlayerData.data[account_id])
				end
			else
				GAS.OfflinePlayerData.callbacks[account_id] = GAS.OfflinePlayerData.callbacks[account_id] or {}
				table.insert(GAS.OfflinePlayerData.callbacks[account_id], callback)
				GAS:netStart("offline_player_data")
					net.WriteUInt(account_id, 31)
				net.SendToServer()
			end
		else
			GAS.Database:Prepare("SELECT `nick`, `usergroup` FROM gas_offline_player_data WHERE `server_id`=? AND `account_id`=?", {GAS.ServerID, account_id}, function(rows)
				if (#rows == 0) then
					callback(false)
				else
					callback(true, {nick = rows[1].nick, usergroup = rows[1].usergroup})
				end
			end)
		end
	end
end
--addons/billy_gas/lua/gmodadminsuite/sh_permissions.lua:
if (SERVER) then AddCSLuaFile() end

if (SERVER) then
	local function OpenPermissions_Init()
		GAS:unhook("OpenPermissions:Ready", "GAS:OpenPermissions")

		GAS.OpenPermissions = OpenPermissions:RegisterAddon("gmodadminsuite", {
			Name = "GmodAdminSuite",
			Color = Color(30,34,42),
			Icon = "icon16/shield.png",
			Logo = {
				Path = "gmodadminsuite/gmodadminsuite.vtf",
				Width = 256,
				Height = 256
			}
		})

		GAS.OpenPermissions:AddToTree({
			Label = "See IP Addresses",
			Icon = "icon16/server_connect.png",
			Value = "see_ip_addresses",
			Default = OpenPermissions.CHECKBOX.CROSSED
		})

		local modules_tree = GAS.OpenPermissions:AddToTree({
			Label = "Modules",
			Icon = "icon16/server.png"
		})

		for module_name, module_data in pairs(GAS.Modules.Info) do
			if (not module_data.OperatorOnly and not module_data.NoMenu and not module_data.Hidden and not module_data.Public) then
				modules_tree:AddToTree({
					Label = module_data.Name,
					Value = module_name,
					Tip = "Can access the menu of " .. module_data.Name .. "?",
					Icon = module_data.Icon
				})
			end
		end
	end
	if (OpenPermissions_Ready == true) then
		OpenPermissions_Init()
	else
		GAS:hook("OpenPermissions:Ready", "GAS:OpenPermissions", OpenPermissions_Init)
	end
end

function GAS:CanAccessMenu(ply)
	if (OpenPermissions:IsOperator(ply)) then return true end
	for module_name in pairs(GAS.Modules.Config.Enabled) do
		if (OpenPermissions:HasPermission(ply, "gmodadminsuite/" .. module_name)) then
			return true
		end
	end
	return false
end
--addons/weapon_jedi/lua/lscs/autorun/lscs_soundscripts.lua:
-- i just put them here so they arent always in my face

for i = 1, 5 do
	local SND =  {
		name = "saber_idle"..i,
		channel = CHAN_VOICE_BASE,
		volume = 1,
		level = 75,
		pitch = 100,
		sound = "lscs/saber/saberhum"..i..".wav",
	}
	sound.Add( SND )
end

sound.Add( {
	name = "saber_hup",
	channel = CHAN_STATIC,
	volume = 0.4,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/saberhup1.mp3",
		"lscs/saber/saberhup2.mp3",
		"lscs/saber/saberhup3.mp3",
		"lscs/saber/saberhup5.mp3",
		"lscs/saber/saberhup6.mp3",
		"lscs/saber/saberhup7.mp3",
		"lscs/saber/saberhup8.mp3",
		"lscs/saber/saberhup9.mp3",
	}
} )

sound.Add( {
	name = "saber_spin1",
	channel = CHAN_STATIC,
	volume = 0.8,
	level = 100,
	pitch = 100,
	sound = "lscs/saber/saberspin1.wav"
} )
sound.Add( {
	name = "saber_spin2",
	channel = CHAN_STATIC,
	volume = 0.8,
	level = 100,
	pitch = 100,
	sound = "lscs/saber/saberspin2.wav"
} )
sound.Add( {
	name = "saber_spin3",
	channel = CHAN_STATIC,
	volume = 0.8,
	level = 100,
	pitch = 100,
	sound = "lscs/saber/saberspin3.wav"
} )

sound.Add( {
	name = "saber_block",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/saberblock1.mp3",
		"lscs/saber/saberblock2.mp3",
		"lscs/saber/saberblock3.mp3",
		"lscs/saber/saberblock4.mp3",
		"lscs/saber/saberblock5.mp3",
		"lscs/saber/saberblock6.mp3",
		"lscs/saber/saberblock7.mp3",
		"lscs/saber/saberblock8.mp3",
		"lscs/saber/saberblock9.mp3",
	}
} )

sound.Add( {
	name = "saber_pblock",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 100,
	pitch = { 100, 100 },
	sound = {
		"lscs/saber/saberbounce1.mp3",
		"lscs/saber/saberbounce2.mp3",
		"lscs/saber/saberbounce3.mp3",
	}
} )

sound.Add( {
	name = "saber_turnon",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 75,
	pitch = { 100, 100 },
	sound = "lscs/saber/saberon.mp3",
} )

sound.Add( {
	name = "saber_turnoff",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 75,
	pitch = { 100, 100 },
	sound = "lscs/saber/saberoff.mp3",
} )

sound.Add( {
	name = "saber_hit",
	channel = CHAN_STATIC,
	volume = 1,
	level = 125,
	pitch = 100,
	sound = {
		"lscs/saber/saberhit1.mp3",
		"lscs/saber/saberhit2.mp3",
		"lscs/saber/saberhit3.mp3",
	}
} )

sound.Add( {
	name = "saber_deflect_bullet",
	channel = CHAN_STATIC,
	volume = 0.35,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/reflect1.mp3",
		"lscs/saber/reflect2.mp3",
		"lscs/saber/reflect3.mp3",
	}
} )

sound.Add( {
	name = "saber_lighthit",
	channel = CHAN_STATIC,
	volume = 0.75,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/lighthit1.wav",
		"lscs/saber/lighthit2.wav",
		"lscs/saber/lighthit3.wav",
		"lscs/saber/lighthit4.wav",
		"lscs/saber/lighthit5.wav",
	}
} )

sound.Add( {
	name = "saber_hitwall",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 100,
	pitch = { 95, 105 },
	sound = {
		"lscs/saber/saberhitwall1.mp3",
		"lscs/saber/saberhitwall2.mp3",
		"lscs/saber/saberhitwall3.mp3",
	}
} )

sound.Add( {
	name = "saber_hitwall_spark",
	channel = CHAN_STATIC,
	volume = 0.75,
	level = 100,
	pitch = { 95, 105 },
	sound = {
		"lscs/saber/spark1.wav",
		"lscs/saber/spark2.wav",
		"lscs/saber/spark3.wav",
		"lscs/saber/spark4.wav",
		"lscs/saber/spark5.wav",
		"lscs/saber/spark6.wav",
	}
} )

sound.Add( {
	name = "nanosword_hup",
	channel = CHAN_STATIC,
	volume = 1,
	level = 110,
	pitch = { 120, 130 },
	sound = {
		"weapons/stunstick/stunstick_swing1.wav",
		"weapons/stunstick/stunstick_swing2.wav",
	}
} )

sound.Add( {
	name = "nanosword_turnon",
	channel = CHAN_STATIC,
	volume = 0.1,
	level = 75,
	pitch = 100,
	sound = "lscs/nanosword/activate.ogg",
} )

sound.Add( {
	name = "nanosword_turnoff",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 75,
	pitch = 80,
	sound = {
		"weapons/stunstick/spark1.wav",
		"weapons/stunstick/spark2.wav",
		"weapons/stunstick/spark3.wav",
	}
} )

sound.Add( {
	name = "nanosword_idle",
	channel = CHAN_STATIC,
	volume = 0.15,
	level = 75,
	pitch = 75,
	sound = "ambient/energy/electric_loop.wav",
} )

--addons/weapon_jedi/lua/lscs/content/lscs_blades.lua:
-- Blauer Lichtschwertkristall
local blade = {}
blade.PrintName = "Blauer Kyberkristall"
blade.Author = "Blu-x92 / Luna"
blade.id = "blue"
blade.color_blur = Color(0,65,255)
blade.color_core = Color(255,255,255)
blade.length = 45
blade.width = 0.9
blade.widthWiggle = 0.6
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true
blade.no_trail = true
blade.sounds = {
	Attack = "saber_hup",
	Attack1 = "saber_spin1",
	Attack2 = "saber_spin2",
	Attack3 = "saber_spin3",
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

-- Grner Lichtschwertkristall
blade.PrintName = "Grner Kyberkristall"
blade.id = "green"
blade.color_blur = Color(0,150,0)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.no_trail = true
blade.sounds.Idle = "lscs/saber/saberhum5.wav"
LSCS:RegisterBlade(blade)

-- Roter Lichtschwertkristall
blade.PrintName = "Roter Kyberkristall"
blade.id = "red"
blade.color_blur = Color(200,0,0)
blade.width = 0.8
blade.widthWiggle = 0.7
blade.sounds.Idle = "lscs/saber/saberhum2.wav"
blade.no_trail = true
blade.sounds = {
	Activate = "lightsaber/saber_on2.wav",
	Disable = "lightsaber/saber_off2.wav",
	Idle =  "lightsaber/saber_loop2.wav",
}
LSCS:RegisterBlade(blade)

-- Gelber Lichtschwertkristall
blade.PrintName = "Gelber Kyberkristall"
blade.id = "citrine"
blade.color_blur = Color(200, 150, 0)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.no_trail = true
blade.sounds.Idle = "lscs/saber/saberhum1.wav"
blade.sounds = {
	Attack = "saber_hup",
	Attack1 = "saber_spin1",
	Attack2 = "saber_spin2",
	Attack3 = "saber_spin3",
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

-- Ahsoka Tano Lichtschwertkristall
blade.PrintName = "Ahsoka | Rechts"
blade.Spawnable = false
blade.id = "ahsokarighti"
blade.color_blur = Color(96,213,41)
blade.color_core = Color(136,242,92)
blade.length = 33
blade.width = 0.65
blade.widthWiggle = 1
blade.no_trail = true
blade.sounds.Idle = "lscs/saber/saberhum3.wav"
LSCS:RegisterBlade( blade )

-- Ahsoka Tano Lichtschwertkristall 2
blade.PrintName = "Ahsoka | Links"
blade.id = "ahsokalefti"
blade.color_blur = Color(210,233,68)
blade.color_core = Color(249,255,156)
blade.length = 17
blade.width = 0.65
blade.widthWiggle = 1
blade.no_trail = true
blade.sounds.Idle = "lscs/saber/saberhum3.wav"
LSCS:RegisterBlade( blade )

-- special case: model based blade
local blade = {}
blade.PrintName = "Nano Particles"
blade.Author = "Blu-x92 / Luna"
blade.id = "nanoparticles"
blade.color_blur = Color(0,127,255)
blade.color_core = Color(0,0,0)
blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
blade.mdl_poseparameter = "blade_retract"
blade.length = 27
blade.dynamic_light = true
blade.no_trail = true
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade )

-- special case: model based blade
local blade = {}
blade.PrintName = "BX Ding"
blade.Author = "Blu-x92 / Luna"
blade.id = "bx1blade"
blade.Spawnable = false  -- uncomment to unlist in q-menu
blade.color_blur = Color(0,127,255, 0)
blade.color_core = Color(0,0,0)
blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
blade.mdl_poseparameter = "blade_retract"
blade.length = 27
blade.dynamic_light = true
blade.no_trail = true
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade )


local blade = {}
blade.PrintName = "Electrostaff Yellow" -- nice name in the menu
blade.Author = "Deltaa"
blade.Spawnable = false
blade.id = "electrostaff" -- internal ID. Always lower case.
blade.color_blur = Color(255,253,123, 200)
blade.color_core = Color(255,241,41, 255)
blade.length = 12 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 1 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "particle/particle_glow_04" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = false -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "armas3/vibro_equip.ogg",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade(blade) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Electrostaff Purple" -- nice name in the menu
blade.Author = "Deltaa"
blade.Spawnable = false
blade.id = "electrostaff_mg" -- internal ID. Always lower case.
blade.color_blur = Color(208,81,255)
blade.color_core = Color(156,23,204)
blade.length = 12 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 1 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "particle/particle_glow_04" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = false -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "armas3/vibro_equip.ogg",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade(blade) -- register it to the system. This will also register a new entity


local blade = {}
blade.PrintName = "Arcblade"
blade.Author = "Blu-x92 / Luna"
blade.id = "arcsabermodel"
blade.Spawnable = false 
blade.color_blur = Color(255,166,0)
blade.color_core = Color(0,0,0)
blade.mdl = "models/lauch/weapons/knife/w_knife.mdl"
blade.mdl_poseparameter = "blade_retract"
blade.length = 30
blade.width = 0.9 -- width
blade.dynamic_light = true
blade.no_trail = true
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade(blade)
--addons/lvs_base/lua/lvs_framework/init.lua:

local StartTime = SysTime()

if SERVER then
	AddCSLuaFile("includes/circles/circles.lua")
end

local function FileIsEmpty( filename )
	if file.Size( filename, "LUA" ) <= 1 then -- this is suspicous
		local data = file.Read( filename, "LUA" )

		if data and string.len( data ) <= 1 then -- confirm its empty

			print("[LVS] - refusing to load '"..filename.."'! File is Empty!" )

			return true
		end
	end

	return false
end

for _, filename in pairs( file.Find("lvs_framework/autorun/*.lua", "LUA") ) do
	if FileIsEmpty( "lvs_framework/autorun/"..filename ) then continue end

	if string.StartWith( filename, "sv_") then -- sv_ prefix only load serverside
		if SERVER then
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	if string.StartWith( filename, "cl_") then -- cl_ prefix only load clientside
		if SERVER then
			AddCSLuaFile("lvs_framework/autorun/"..filename)
		else
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	-- everything else is shared
	if SERVER then
		AddCSLuaFile("lvs_framework/autorun/"..filename)
	end
	include("lvs_framework/autorun/"..filename)
end

hook.Run( "LVS:Initialize" )

print("[LVS] - initialized ["..math.Round((SysTime() - StartTime) * 1000,2).."ms]")

if CLIENT then
	hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
		timer.Simple(20, function()
			LVS.CheckUpdates()

			local convar = GetConVar( "no_error_hitboxes" )

			if not convar then return end

			convar:SetBool( false )
		end)
	end )

	return
end

resource.AddWorkshop("2912816023")

local ValveWierdBlastDamageClass = {
	["npc_strider"] = true, -- takes 70 damage for each blast damage as constant value ...
	["npc_combinegunship"] = true, -- takes 44 damage as constant value ...
	["func_breakable_surf"] = true, -- this entity dont care about anything that isnt a trace attack or blast damage
}

function LVS:BlastDamage( pos, forward, attacker, inflictor, damage, damagetype, radius, force )

	local dmginfo = DamageInfo()
	dmginfo:SetAttacker( attacker )
	dmginfo:SetInflictor( inflictor )
	dmginfo:SetDamage( damage )
	dmginfo:SetDamageType( damagetype == DMG_BLAST and DMG_SONIC or damagetype )

	if damagetype ~= DMG_BLAST then
		dmginfo:SetDamagePosition( pos )
		dmginfo:SetDamageForce( forward * force )

		util.BlastDamageInfo( dmginfo, pos, radius )

		return
	end

	util.BlastDamageInfo( dmginfo, pos, radius )

	local FragmentAngle = 10
	local NumFragments = 16
	local NumFragmentsMissed = 0

	local RegisteredHits = {}

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - forward * radius,
		filter = { attacker, inflictor },
	} )

	local startpos = trace.HitPos

	for i = 1, NumFragments do
		local ang = forward:Angle() + Angle( math.random(-FragmentAngle,FragmentAngle), math.random(-FragmentAngle,FragmentAngle), 0 )
		local dir = ang:Forward()

		local endpos = pos + dir * radius

		local trace = util.TraceLine( {
			start = startpos,
			endpos = endpos,
			filter = { attacker, inflictor },
		} )

		debugoverlay.Line( startpos, trace.HitPos, 10, Color( 255, 0, 0, 255 ), true )

		if not trace.Hit then
			NumFragmentsMissed = NumFragmentsMissed + 1

			continue
		end

		if not IsValid( trace.Entity ) then continue end

		if not RegisteredHits[ trace.Entity ] then
			RegisteredHits[ trace.Entity ] = {}
		end

		table.insert( RegisteredHits[ trace.Entity ], {
			origin = trace.HitPos,
			force = dir * force,
		} )
	end

	if NumFragmentsMissed == NumFragments then return end

	local DamageBoost = NumFragments / ( NumFragments - NumFragmentsMissed )

	for ent, data in pairs( RegisteredHits ) do
		local NumHits = #data
		local AverageOrigin = vector_origin
		local AverageForce = vector_origin

		for _, HitData in pairs( data ) do
			AverageOrigin = AverageOrigin + HitData.origin
			AverageForce = AverageForce + HitData.force
		end

		AverageOrigin = AverageOrigin / NumHits
		AverageForce = AverageForce / NumHits

		local TotalDamage = ( ( NumHits * DamageBoost ) / NumFragments ) * damage

		--debugoverlay.Cross( AverageOrigin, 50, 10, Color( 255, 0, 255 ) )

		-- hack
		if ValveWierdBlastDamageClass[ ent:GetClass() ] then

			util.BlastDamage( inflictor, attacker, pos, radius, damage )

			continue
		end

		local dmginfo = DamageInfo()
		dmginfo:SetAttacker( attacker )
		dmginfo:SetInflictor( inflictor )
		dmginfo:SetDamage( TotalDamage )
		dmginfo:SetDamageForce( AverageForce )
		dmginfo:SetDamagePosition( AverageOrigin )
		dmginfo:SetDamageType( DMG_BLAST )

		ent:TakeDamageInfo( dmginfo )
	end
end

function LVS:FixVelocity()
	local tbl = physenv.GetPerformanceSettings()

	if tbl.MaxVelocity < 4000 then
		local OldVel = tbl.MaxVelocity

		tbl.MaxVelocity = 4000
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxVelocity detected! Increasing! "..OldVel.." => 4000")
	end

	if tbl.MaxAngularVelocity < 7272 then
		local OldAngVel = tbl.MaxAngularVelocity

		tbl.MaxAngularVelocity = 7272
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxAngularVelocity detected! Increasing! "..OldAngVel.." => 7272")
	end
end

hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
	timer.Simple(20, function()
		LVS.CheckUpdates()
	end)
end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_bulletsystem.lua:
local LVS = LVS

LVS._ActiveBullets = {}

function LVS:RemoveBullet( index )
	LVS._ActiveBullets[ index ] = nil
end

function LVS:GetBullet( index )
	if not LVS._ActiveBullets then return end

	return LVS._ActiveBullets[ index ]
end

local NewBullet = {}
NewBullet.__index = NewBullet 

function NewBullet:SetPos( pos )
	self.curpos = pos
end

function NewBullet:GetBulletIndex()
	return self.bulletindex
end

function NewBullet:Remove()
	local index = self.bulletindex

	if SERVER then
		-- prevents ghost bullets if the client fails to detect the hit
		net.Start( "lvs_remove_bullet", true )
			net.WriteInt( index, 13 )
		net.SendPVS( self:GetPos() )
	end

	LVS:RemoveBullet( index )
end

function NewBullet:GetPos()
	if not self.curpos then return self.Src end

	return self.curpos
end

function NewBullet:SetGravity( new )
	self.Gravity = new
end

function NewBullet:GetGravity()
	return self.Gravity or vector_origin
end

function NewBullet:GetDir()
	return self.Dir or vector_origin
end

function NewBullet:SetDir( newdir )
	self.Dir = newdir
end

function NewBullet:GetTimeAlive()
	return CurTime() - self.StartTime
end

function NewBullet:GetSpawnTime()
	if SERVER then
		return self.StartTime
	else
		return math.min( self.StartTimeCL, CurTime() ) -- time when the bullet is received on client
	end
end

function NewBullet:GetLength()
	return math.min((CurTime() - self:GetSpawnTime()) * 14,1)
end

function NewBullet:HandleWaterImpact( traceStart, traceEnd, Filter )
	if self.HasHitWater then return end

	local traceWater = util.TraceLine( {
		start = traceStart,
		endpos = traceEnd,
		filter = Filter,
		mask = MASK_WATER,
	} )

	if not traceWater.Hit then return end

	self.HasHitWater = true

	local effectdata = EffectData()
	effectdata:SetOrigin( traceWater.HitPos )
	effectdata:SetScale( 10 + self.HullSize * 0.5 )
	effectdata:SetFlags( 2 )
	util.Effect( "WaterSplash", effectdata, true, true )
end

function NewBullet:HandleFlybySound( EarPos )
	if self.Muted or not LVS.EnableBulletNearmiss then return end

	local BulletPos = self:GetPos()

	local EarDist = (EarPos - BulletPos):LengthSqr()

	if self.OldEarDist and self.OldEarDist < EarDist then

		if EarDist < 250000 then
			local effectdata = EffectData()
			effectdata:SetOrigin( EarPos + (BulletPos - EarPos):GetNormalized() * 20 )
			effectdata:SetFlags( 2 )
			util.Effect( "TracerSound", effectdata )
		end

		self.Muted = true
	end

	self.OldEarDist = EarDist
end

function NewBullet:DoBulletFlight( TimeAlive )

	local StartPos = self.Src
	local StartDirection = self.StartDir

	local Velocity = self.Velocity

	local PosOffset

	-- startpos, direction and curtime of creation is networked to client. 
	-- the bullet position is simulated by doing startpos + dir * time * velocity
	if self.EnableBallistics then
		local PosTheoretical = StartDirection * TimeAlive * Velocity

		PosOffset = PosTheoretical + self:GetGravity() * (TimeAlive ^ 2)

		self:SetDir( (StartPos + PosOffset - StartPos):GetNormalized() )
	else
		PosOffset = self.Dir * TimeAlive * Velocity
	end

	if SERVER then
		self:SetPos( StartPos + PosOffset )
	else

		-- "parent" the bullet to the vehicle for a very short time on client. This will give the illusion of the bullet not lagging behind even tho it is fired later on client
		if IsValid( self.Entity ) and self.SrcEntity then
			local mul = self:GetLength()
			local inv = 1 - mul

			self:SetPos( StartPos * mul + self.Entity:LocalToWorld( self.SrcEntity ) * inv + PosOffset )

			return
		end

		-- if no parent detected, run same code as server
		self:SetPos( StartPos + PosOffset )
	end
end

function NewBullet:OnCollide( trace )
	if CLIENT then return end

	if trace.Entity == self.LastDamageTarget then return end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	local dmginfo = DamageInfo()
	dmginfo:SetDamage( self.Damage )
	dmginfo:SetAttacker( Attacker )
	dmginfo:SetInflictor( Inflictor )
	dmginfo:SetDamageType( DMG_AIRBOAT )
	dmginfo:SetDamagePosition( trace.HitPos )

	if self.Force1km then
		local Mul = math.min( (self.Src - trace.HitPos):Length() / 39370, 1 )
		local invMul = math.max( 1 - Mul, 0 )

		dmginfo:SetDamageForce( self.Dir * (self.Force * invMul + self.Force1km * Mul) )
	else
		dmginfo:SetDamageForce( self.Dir * self.Force )
	end

	if self.Callback then
		self.Callback( Attacker, trace, dmginfo )
	end

	if trace.Entity:GetClass() == "func_breakable_surf" then
		-- this will cause the entire thing to just fall apart
		dmginfo:SetDamageType( DMG_BLAST )
	end

	trace.Entity:DispatchTraceAttack( dmginfo, trace )

	self.LastDamageTarget = trace.Entity
end

function NewBullet:DoSplashDamage( trace )
	if not self.SplashDamage or not self.SplashDamageRadius then return false end

	if self.SplashDamageEffect ~= "" then
		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetNormal( trace.HitWorld and trace.HitNormal or self.Dir )
		effectdata:SetMagnitude( self.SplashDamageRadius / 250 )
		util.Effect( self.SplashDamageEffect, effectdata )
	end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	LVS:BlastDamage( trace.HitPos, self.Dir, Attacker, Inflictor, self.SplashDamage, self.SplashDamageType, self.SplashDamageRadius, self.SplashDamageForce )

	self.SplashDamage = nil
	self.SplashDamageRadius = nil
	self.SplashDamageEffect = nil

	return true
end

function NewBullet:HandleCollision( traceStart, traceEnd, Filter )
	local TraceMask = self.HullSize <= 1 and MASK_SHOT_PORTAL or MASK_SHOT_HULL

	local traceLine
	local traceHull

	if self.HullTraceResult then
		traceHull = self.HullTraceResult
	else
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )

		local trace = util.TraceHull( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mins = self.Mins,
			maxs = self.Maxs,
			mask = TraceMask,
			ignoreworld = true
		} )

		if traceLine.Entity == trace.Entity and trace.Hit and traceLine.Hit then
			trace = traceLine
		end

		if trace.Hit then
			self.HullTraceResult = trace
			traceHull = trace

			self:OnCollide( trace )

			if self:DoSplashDamage( trace ) then
				self:Remove()
			end
		else
			traceHull = { Hit = false }
		end
	end

	if not traceLine then
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )
	end

	if not traceLine.Hit then
		return
	end

	self:OnCollide( traceLine )

	self:DoSplashDamage( traceLine )

	self:Remove()

	if SERVER then return end

	if not traceLine.HitSky then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceLine.HitPos )
		effectdata:SetEntity( traceLine.Entity )
		effectdata:SetStart( traceStart )
		effectdata:SetNormal( traceLine.HitNormal )
		effectdata:SetSurfaceProp( traceLine.SurfaceProps )
		util.Effect( "Impact", effectdata )
	end
end

local function GetEarPos()
	if SERVER then return vector_origin end

	local EarPos

	local ply = LocalPlayer()
	local ViewEnt = ply:GetViewEntity()

	if ViewEnt == ply then
		if IsValid( ply:lvsGetVehicle() ) then
			EarPos = ply:lvsGetView()
		else
			EarPos = ply:GetShootPos()
		end
	else
		EarPos = ViewEnt:GetPos()
	end

	return EarPos
end

local function HandleBullets()
	local T = CurTime()
	local FT = FrameTime()

	local EarPos = GetEarPos()

	for id, bullet in pairs( LVS._ActiveBullets ) do
		if bullet:GetSpawnTime() + 5 < T then -- destroy all bullets older than 5 seconds
			bullet:Remove()

			continue
		end

		local TimeAlive = bullet:GetTimeAlive()

		if TimeAlive < 0 then continue end -- CurTime() is predicted, this can be a negative number in some cases.

		local Filter = bullet.Filter

		local traceStart = bullet:GetPos()
			bullet:DoBulletFlight( TimeAlive )
		local traceEnd = bullet:GetPos()

		if CLIENT then
			--debugoverlay.Line( traceStart, traceEnd, Color( 255, 255, 255 ), true )

			-- bullet flyby sounds
			bullet:HandleFlybySound( EarPos )

			-- bullet water impact effects
			bullet:HandleWaterImpact( traceStart, traceEnd, Filter )
		end

		bullet:HandleCollision( traceStart, traceEnd, Filter )
	end
end

local vector_one = Vector(1,1,1)

if SERVER then
	util.AddNetworkString( "lvs_fire_bullet" )
	util.AddNetworkString( "lvs_remove_bullet" )

	hook.Add( "Tick", "!!!!lvs_bullet_handler", function( ply, ent ) -- from what i understand, think can "skip" on lag, while tick still simulates all steps
		HandleBullets()
	end )

	local Index = 0
	local MaxIndex = 4094 -- this is the util.effect limit

	function LVS:FireBullet( data )

		Index = Index + 1

		if Index > MaxIndex then
			Index = 1
		end

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = data.TracerName or "lvs_tracer_orange"
		bullet.Src = data.Src or vector_origin
		bullet.Dir = (data.Dir + VectorRand() * (data.Spread or vector_origin) * 0.5):GetNormalized()
		bullet.StartDir = bullet.Dir
		bullet.Force = data.Force or 10

		if data.Force1km then
			bullet.Force1km = data.Force1km
		end

		bullet.HullSize = data.HullSize or 5
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Velocity = data.Velocity or 2500
		bullet.Attacker = IsValid( data.Attacker ) and data.Attacker or (IsValid( data.Entity ) and data.Entity or game.GetWorld())
		bullet.Damage = data.Damage or 10
		bullet.Entity = data.Entity
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = data.SrcEntity or vector_origin
		bullet.Callback = data.Callback
		bullet.SplashDamage = data.SplashDamage
		bullet.SplashDamageForce = data.SplashDamageForce or 500
		bullet.SplashDamageRadius = data.SplashDamageRadius
		bullet.SplashDamageEffect = data.SplashDamageEffect or "lvs_bullet_impact"
		bullet.SplashDamageType = data.SplashDamageType or DMG_SONIC
		bullet.StartTime = CurTime()
		bullet.EnableBallistics = data.EnableBallistics == true

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		if InfMap then
			for _, ply in ipairs( player.GetAll() ) do
				local NewPos = Vector( bullet.Src.x, bullet.Src.y, bullet.Src.z ) - InfMap.unlocalize_vector( Vector(), ply.CHUNK_OFFSET )

				net.Start( "lvs_fire_bullet", true )
					net.WriteInt( Index, 13 )
					net.WriteString( bullet.TracerName )
					net.WriteFloat( NewPos.x )
					net.WriteFloat( NewPos.y )
					net.WriteFloat( NewPos.z )
					net.WriteAngle( bullet.Dir:Angle() )
					net.WriteFloat( bullet.StartTime )
					net.WriteFloat( bullet.HullSize )
					net.WriteEntity( bullet.Entity )
					net.WriteFloat( bullet.SrcEntity.x )
					net.WriteFloat( bullet.SrcEntity.y )
					net.WriteFloat( bullet.SrcEntity.z )
					net.WriteFloat( bullet.Velocity )
					net.WriteBool( bullet.EnableBallistics )
				net.Send( ply )
			end
		else
			net.Start( "lvs_fire_bullet", true )
				net.WriteInt( Index, 13 )
				net.WriteString( bullet.TracerName )
				net.WriteFloat( bullet.Src.x )
				net.WriteFloat( bullet.Src.y )
				net.WriteFloat( bullet.Src.z )
				net.WriteAngle( bullet.Dir:Angle() )
				net.WriteFloat( bullet.StartTime )
				net.WriteFloat( bullet.HullSize )
				net.WriteEntity( bullet.Entity )
				net.WriteFloat( bullet.SrcEntity.x )
				net.WriteFloat( bullet.SrcEntity.y )
				net.WriteFloat( bullet.SrcEntity.z )
				net.WriteFloat( bullet.Velocity )
				net.WriteBool( bullet.EnableBallistics )
			net.SendPVS( bullet.Src )
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet
	end
else
	net.Receive( "lvs_remove_bullet", function( length )
		LVS:RemoveBullet( net.ReadInt( 13 ) )
	end)

	net.Receive( "lvs_fire_bullet", function( length )
		local Index = net.ReadInt( 13 )

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = net.ReadString()
		bullet.Src = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())
		bullet.Dir = net.ReadAngle():Forward()
		bullet.StartDir = bullet.Dir
		bullet.StartTime = net.ReadFloat()
		bullet.HullSize = net.ReadFloat()
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Entity = net.ReadEntity()
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())

		if bullet.SrcEntity == vector_origin then
			bullet.SrcEntity = nil
		end

		bullet.Velocity = net.ReadFloat()

		bullet.EnableBallistics = net.ReadBool()

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		bullet.StartTimeCL = CurTime() + RealFrameTime()

		local ply = LocalPlayer()

		if IsValid( ply ) then
			bullet.Muted = bullet.Entity == ply:lvsGetVehicle() or bullet.Entity:GetOwner() == ply
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet

		local effectdata = EffectData()
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( bullet.Dir )
		effectdata:SetMaterialIndex( Index )
		util.Effect( bullet.TracerName, effectdata )
	end )

	hook.Add( "Think", "!!!!_lvs_bullet_think_cl", function()
		HandleBullets()
	end )
end
--addons/tools/lua/autorun/materials.lua:
list.Add( "OverrideMaterials", "models/lordtrilobite/glass_clear_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/glass_dirty_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_crate1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_exteriorpanels_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_exteriorgreebles02_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_floor1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_floor2_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_floor2_dirty_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalceiling1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalceiling1_dirty_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalgrate01_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall1_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall2_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall2_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall3_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall3_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall6_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall6_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall8_mat")

list.Add( "OverrideMaterials", "001wmetal" )
list.Add( "OverrideMaterials", "01wcamo" )
list.Add( "OverrideMaterials", "02wcamo" )
list.Add( "OverrideMaterials", "03wcamo" )
list.Add( "OverrideMaterials", "04wcamo" )
list.Add( "OverrideMaterials", "05wcamo" )
list.Add( "OverrideMaterials", "06wcamo" )
list.Add( "OverrideMaterials", "07wcamo" )
list.Add( "OverrideMaterials", "08wcamo" )
list.Add( "OverrideMaterials", "09wcamo" )
list.Add( "OverrideMaterials", "10wcamo" )
list.Add( "OverrideMaterials", "11wcamo" )
list.Add( "OverrideMaterials", "12wcamo" )
list.Add( "OverrideMaterials", "13wcamo" )
list.Add( "OverrideMaterials", "14wcamo" )
list.Add( "OverrideMaterials", "15wcamo" )
list.Add( "OverrideMaterials", "16wcamo" )
list.Add( "OverrideMaterials", "17wcamo" )
list.Add( "OverrideMaterials", "18wcamo" )

list.Add( "OverrideMaterials", "warcamo01" )
list.Add( "OverrideMaterials", "warcamo02" )
list.Add( "OverrideMaterials", "warcamo03" )
list.Add( "OverrideMaterials", "warcamo04" )
list.Add( "OverrideMaterials", "warcamo05" )
list.Add( "OverrideMaterials", "warcamo06" )
list.Add( "OverrideMaterials", "warcamo07" )
list.Add( "OverrideMaterials", "warcamo08" )
list.Add( "OverrideMaterials", "warmetal01" )
list.Add( "OverrideMaterials", "warmetal02" )
list.Add( "OverrideMaterials", "warmetal03" )

list.Add( "OverrideMaterials", "ace/sw/holoproj" )
list.Add( "OverrideMaterials", "ace/sw/hologram" )
list.Add( "OverrideMaterials","ace/sw/holobarrier" )
--addons/tools/lua/autorun/rb655_extended_spawnmenu.lua:

AddCSLuaFile()

if ( SERVER ) then

	util.AddNetworkString( "rb655_playsound" )

	concommand.Add( "rb655_playsound_all", function( ply, cmd, args )
		if ( !ply:IsSuperAdmin() or !args[ 1 ] or string.Trim( args[ 1 ] ) == "" ) then return end

		net.Start( "rb655_playsound" )
		net.WriteString( args[ 1 ] or "" )
		net.Broadcast()
	end )

	return

end

local cl_addTabs = CreateClientConVar( "rb655_create_sm_tabs", "0", true, true )

--[[local function removeOldTabls()
	for k, v in pairs( g_SpawnMenu.CreateMenu.Items ) do
		if (v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.npcs" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.entities" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.weapons" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.vehicles" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.postprocess" ) ) then
			g_SpawnMenu.CreateMenu:CloseTab( v.Tab, true )
		end
	end
end

hook.Add( "PopulateContent", "rb655_extended_spawnmenu", function( pnlContent, tree, node )
	removeOldTabls() removeOldTabls() removeOldTabls() -- For some reason it doesn't work with only one call
end )]]

local function getGameList()
	local games = engine.GetGames()
	table.insert( games, {
		title = "All",
		folder = "GAME",
		icon = "all",
		mounted = true
	} )
	table.insert( games, {
		title = "Garry's Mod",
		folder = "garrysmod",
		mounted = true
	} )
	return games
end

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

local theSound = nil

function rb655_playsound( snd )

	if ( theSound ) then theSound:Stop() end

	theSound = CreateSound( LocalPlayer(), snd )
	theSound:Play()

end

net.Receive( "rb655_playsound", function( len )
	rb655_playsound( net.ReadString() )
end )

spawnmenu.AddContentType( "sound", function( container, obj )
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "sound" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( "icon16/sound.png" )

	icon.DoClick = function()
		rb655_playsound( obj.spawnname )
	end

	icon.OpenMenu = function( icon )
		local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.copy", function() SetClipboardText( obj.spawnname ) end ):SetIcon( "icon16/page_copy.png" )
			menu:AddOption( "Play on all clients", function() RunConsoleCommand( "rb655_playsound_all", obj.spawnname ) end ):SetIcon( "icon16/sound.png" )
			menu:AddOption( "Stop all sounds", function() RunConsoleCommand( "stopsound" ) end ):SetIcon( "icon16/sound_mute.png" )
			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end ):SetIcon( "icon16/bin_closed.png" )
		menu:Open()
	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

local function OnSndNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )

	ViewPanel:Clear( true )

	local Path = node:GetFolder()

	local files = file.Find( Path .. "/*.wav", node:GetPathID() )
	files = table.Add( files, file.Find( Path .. "/*.mp3", node:GetPathID() ) )
	files = table.Add( files, file.Find( Path .. "/*.ogg", node:GetPathID() ) )

	local offset = 0
	local limit = 512
	if ( node.offset ) then offset = node.offset or 0 end

	for k, v in pairs( files ) do
		if ( k > limit + offset ) then
			if ( !node.Done ) then
				offset = offset + limit
				local mats = ( self.Parent or node ):AddNode( ( self.Text or node:GetText() ) .. " (" .. offset .. " - " .. offset + limit .. ")" )
				mats:SetFolder( node:GetFolder() )
				mats.Text = self.Text or node:GetText()
				mats.Parent = self.Parent or node
				mats:SetPathID( node:GetPathID() )
				mats:SetIcon( node:GetIcon() )
				mats.offset = offset
				mats.OnNodeSelected = function( self, node )
					OnSndNodeSelected( self, node, self.Text, node:GetFolder(), node:GetPathID(), node:GetIcon(), ViewPanel, pnlContent )
				end
			end
			node.Done = true
		break end
		if ( k <= offset ) then continue end

		local p = Path .. "/"
		if ( string.StartWith( path, "addons/" ) || string.StartWith( path, "download/" ) ) then
			p = string.sub( p, string.find( p, "/sound/" ) + 1 )
		end

		p = string.sub( p .. v, 7 )

		spawnmenu.CreateContentIcon( "sound", ViewPanel, { spawnname = p, nicename = string.Trim( v ) } )

	end

	pnlContent:SwitchPanel( ViewPanel )

end

local function AddBrowseContentSnd( node, name, icon, path, pathid )

	local ViewPanel = node.ViewPanel
	local pnlContent = node.pnlContent

	if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end

	local fi, fo = file.Find( path .. "sound", pathid )
	if ( !fo && !fi ) then return end

	local sounds = node:AddFolder( name, path .. "sound", pathid, false, false, "*.*" )
	sounds:SetIcon( icon )

	sounds.OnNodeSelected = function( self, node )
		OnSndNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )
	end

end

language.Add( "spawnmenu.category.browsesounds", "Browse Sounds" )

local addon_sounds = {}
local files, folders = file.Find( "addons/*", "GAME" )
for _, addon in SortedPairs( folders ) do

	if ( !file.IsDir( "addons/" .. addon .. "/sound/", "GAME" ) ) then continue end

	table.insert( addon_sounds, addon )

end

local function RefreshAddonSounds( browseAddonSounds )
		for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		if ( !addon.downloaded ) then continue end
		if ( !addon.mounted ) then continue end
		if ( !table.HasValue( select( 2, file.Find( "*", addon.title ) ), "sound" ) ) then continue end

		AddBrowseContentSnd( browseAddonSounds, addon.title, "icon16/bricks.png", "", addon.title )
	end
end
local function RefreshGameSounds( browseGameSounds )
	local games = getGameList()

	for _, game in SortedPairsByMemberValue( games, "title" ) do
		if ( !game.mounted ) then continue end
		AddBrowseContentSnd( browseGameSounds, game.title, "games/16/" .. ( game.icon or game.folder ) .. ".png", "", game.folder )
	end
end

local browseGameSounds
local browseAddonSounds
hook.Add( "PopulateContent", "SpawnmenuLoadSomeSounds", function( pnlContent, tree, browseNode ) timer.Simple( 0.5, function()

	if ( !IsValid( tree ) || !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local browseSounds = tree:AddNode( "#spawnmenu.category.browsesounds", "icon16/sound.png" )
	browseSounds.ViewPanel = ViewPanel
	browseSounds.pnlContent = pnlContent

	--[[ --------------------------------------------------------------------------------------- ]]

	browseAddonSounds = browseSounds:AddNode( "#spawnmenu.category.addons", "icon16/folder_database.png" )
	browseAddonSounds.ViewPanel = ViewPanel
	browseAddonSounds.pnlContent = pnlContent

	RefreshAddonSounds( browseAddonSounds )

	--[[ --------------------------------------------------------------------------------------- ]]

	local browseLegacySounds = browseSounds:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	browseLegacySounds.ViewPanel = ViewPanel
	browseLegacySounds.pnlContent = pnlContent

	for _, addon in SortedPairsByValue( addon_sounds ) do

		AddBrowseContentSnd( browseLegacySounds, addon, "icon16/bricks.png", "addons/" .. addon .. "/", "GAME" )

	end

	--[[ --------------------------------------------------------------------------------------- ]]

	AddBrowseContentSnd( browseSounds, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/", "GAME" )

	--[[ --------------------------------------------------------------------------------------- ]]

	browseGameSounds = browseSounds:AddNode( "#spawnmenu.category.games", "icon16/folder_database.png" )
	browseGameSounds.ViewPanel = ViewPanel
	browseGameSounds.pnlContent = pnlContent

	RefreshGameSounds( browseGameSounds )

end ) end )

hook.Add( "GameContentChanged", "ES_RefreshSpawnmenuSounds", function()

	if ( IsValid( browseAddonSounds ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseAddonSounds:Clear()
		browseAddonSounds.ViewPanel:Clear( true )

		RefreshAddonSounds( browseAddonSounds )

	end

	if ( IsValid( browseGameSounds ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseGameSounds:Clear()
		browseGameSounds.ViewPanel:Clear( true )

		RefreshGameSounds( browseGameSounds )

	end

end )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

local function IsMaterialUsableOnEntities( matPath )
	-- A png file? No thanks
	if ( string.GetExtensionFromFilename( matPath ) ) then return false end

	local mat = Material( matPath )
	if ( !string.find( mat:GetShader(), "LightmappedGeneric" )
	&& !string.find( mat:GetShader(), "WorldVertexTransition" )
	&& !string.find( mat:GetShader(), "Spritecard" )
	&& !string.find( mat:GetShader(), "Water" )
	&& !string.find( mat:GetShader(), "Cable" )
	--&& !string.find( mat:GetShader(), "UnlitGeneric" )
	&& !string.find( mat:GetShader(), "Refract" ) ) then
		return true
	end

	return false
end

local DisplayedWarning = false
local function DisplayOneTimeWarning()
	if ( DisplayedWarning ) then return end
	DisplayedWarning = true

	Derma_Message( "Please note that not all materials are usable on entities, such as map textures, etc.\nYou can still try though!", "Warning", "OK" )
end

spawnmenu.AddContentType( "material", function( container, obj )
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "material" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	if ( string.GetExtensionFromFilename( obj.spawnname ) == "png" ) then
		icon:SetMaterial( obj.spawnname )
	else
		icon.Image:SetImage( obj.spawnname )
	end

	icon.DoClick = function()
		if ( !IsMaterialUsableOnEntities( obj.spawnname ) ) then DisplayOneTimeWarning() end

		RunConsoleCommand( "material_override", obj.spawnname )
		spawnmenu.ActivateTool( "material" )
		surface.PlaySound( "garrysmod/ui_click.wav" )
	end

	icon.OpenMenu = function( icon )
		local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.copy", function() SetClipboardText( obj.spawnname ) end ):SetIcon( "icon16/page_copy.png" )

			local str = "Use with Material Tool"
			if ( !IsMaterialUsableOnEntities( obj.spawnname ) ) then
				str = "Try to use with Material Tool (Probably won't work)"
			end
			menu:AddOption( str, function()
				RunConsoleCommand( "material_override", obj.spawnname )
				spawnmenu.ActivateTool( "material" )
			end ):SetIcon( "icon16/pencil.png" )

			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end ):SetIcon( "icon16/bin_closed.png" )
		menu:Open()
	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

local function OnMatNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )

	ViewPanel:Clear( true )

	local Path = node:GetFolder()

	local files = file.Find( Path .. "/*.vmt", node:GetPathID() )
	files = table.Add( files, file.Find( Path .. "/*.png", node:GetPathID() ) )

	local offset = 0
	local limit = 512
	if ( node.offset ) then offset = node.offset or 0 end

	for k, v in pairs( files ) do
		if ( k > limit + offset ) then
			if ( !node.Done ) then
				offset = offset + limit
				local mats = ( self.Parent or node ):AddNode( ( self.Text or node:GetText() ) .. " (" .. offset .. " - " .. offset + limit .. ")" )
				mats:SetFolder( node:GetFolder() )
				mats.Text = self.Text or node:GetText()
				mats.Parent = self.Parent or node
				mats:SetPathID( node:GetPathID() )
				mats:SetIcon( node:GetIcon() )
				mats.offset = offset
				mats.OnNodeSelected = function( self, node )
					OnMatNodeSelected( self, node, self.Text, node:GetFolder(), node:GetPathID(), node:GetIcon(), ViewPanel, pnlContent )
				end
			end
			node.Done = true
		break end
		if ( k <= offset ) then continue end

		local p = Path .. "/"
		if ( string.StartWith( path, "addons/" ) || string.StartWith( path, "download/" ) ) then
			p = string.sub( p, string.find( p, "/materials/" ) + 1 )
		end

		p = string.sub( p .. v, 11 )

		if ( string.GetExtensionFromFilename( p ) == "vmt" ) then
			p = string.StripExtension( p )
			v = string.StripExtension( v )
		end

		if ( Material( p ):GetShader() == "Spritecard" ) then continue end

		spawnmenu.CreateContentIcon( "material", ViewPanel, { spawnname = p, nicename = v } )
	end

	pnlContent:SwitchPanel( ViewPanel )

end

local function AddBrowseContentMaterial( node, name, icon, path, pathid )

	local ViewPanel = node.ViewPanel
	local pnlContent = node.pnlContent

	if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end

	local fi, fo = file.Find( path .. "materials", pathid )
	if ( !fi && !fo ) then return end

	local materials = node:AddFolder( name, path .. "materials", pathid, false, false, "*.*" )
	materials:SetIcon( icon )

	materials.OnNodeSelected = function( self, node )
		OnMatNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )
	end

end

language.Add( "spawnmenu.category.browsematerials", "Browse Materials" )

local addon_mats = {}
local files, folders = file.Find( "addons/*", "GAME" )
for _, addon in SortedPairs( folders ) do

	if ( !file.IsDir( "addons/" .. addon .. "/materials/", "GAME" ) ) then continue end

	table.insert( addon_mats, addon )

end

local function RefreshAddonMaterials( node )
	for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		if ( !addon.downloaded ) then continue end
		if ( !addon.mounted ) then continue end
		if ( !table.HasValue( select( 2, file.Find( "*", addon.title ) ), "materials" ) ) then continue end

		AddBrowseContentMaterial( node, addon.title, "icon16/bricks.png", "", addon.title )

	end
end
local function RefreshGameMaterials( node )
	local games = getGameList()

	for _, game in SortedPairsByMemberValue( games, "title" ) do
		if ( !game.mounted ) then continue end
		AddBrowseContentMaterial( node, game.title, "games/16/" .. ( game.icon or game.folder ) .. ".png", "", game.folder )
	end
end

local browseAddonMaterials
local browseGameMaterials
hook.Add( "PopulateContent", "SpawnmenuLoadSomeMaterials", function( pnlContent, tree, browseNode ) timer.Simple( 0.5, function()

	if ( !IsValid( tree ) || !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local browseMaterials = tree:AddNode( "#spawnmenu.category.browsematerials", "icon16/picture_empty.png" )
	browseMaterials.ViewPanel = ViewPanel
	browseMaterials.pnlContent = pnlContent

	--[[ --------------------------------------------------------------------------------------- ]]

	browseAddonMaterials = browseMaterials:AddNode( "#spawnmenu.category.addons", "icon16/folder_database.png" )
	browseAddonMaterials.ViewPanel = ViewPanel
	browseAddonMaterials.pnlContent = pnlContent

	RefreshAddonMaterials( browseAddonMaterials )

	--[[ --------------------------------------------------------------------------------------- ]]

	local browseLegacyMaterials = browseMaterials:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	browseLegacyMaterials.ViewPanel = ViewPanel
	browseLegacyMaterials.pnlContent = pnlContent

	for _, addon in SortedPairsByValue( addon_mats ) do

		AddBrowseContentMaterial( browseLegacyMaterials, addon, "icon16/bricks.png", "addons/" .. addon .. "/", "GAME" )

	end

	--[[ --------------------------------------------------------------------------------------- ]]

	AddBrowseContentMaterial( browseMaterials, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/", "GAME" )

	--[[ --------------------------------------------------------------------------------------- ]]

	browseGameMaterials = browseMaterials:AddNode( "#spawnmenu.category.games", "icon16/folder_database.png" )
	browseGameMaterials.ViewPanel = ViewPanel
	browseGameMaterials.pnlContent = pnlContent

	RefreshGameMaterials( browseGameMaterials )

end ) end )

hook.Add( "GameContentChanged", "ES_RefreshSpawnmenuMaterials", function()

	if ( IsValid( browseAddonMaterials ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseAddonMaterials:Clear()
		browseAddonMaterials.ViewPanel:Clear( true )

		RefreshAddonMaterials( browseAddonMaterials )

	end

	if ( IsValid( browseGameMaterials ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseGameMaterials:Clear()
		browseGameMaterials.ViewPanel:Clear( true )

		RefreshGameMaterials( browseGameMaterials )

	end

end )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_entities", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.entities", "icon16/bricks.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Categorised = {}

	local SpawnableEntities = list.Get( "SpawnableEntities" )
	if ( SpawnableEntities ) then
		for k, v in pairs( SpawnableEntities ) do
			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			table.insert( Categorised[ v.Category ], v )
		end
	end

	for CategoryName, v in SortedPairs( Categorised ) do

		local node = node_w:AddNode( CategoryName, "icon16/bricks.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", CatPropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", node_w.PropPanel, t )
		end

		function node:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end
end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_post_processing", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.postprocess", "icon16/picture.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	-- Get the table

	local Categorised = {}
	local PostProcess = list.Get( "PostProcess" )

	if ( PostProcess ) then
		for k, v in pairs( PostProcess ) do
			v.category = v.category or "Other"
			v.name = k
			Categorised[ v.category ] = Categorised[ v.category ] or {}
			table.insert( Categorised[ v.category ], v )
		end
	end

	-- Put table into panels

	for CategoryName, v in SortedPairs( Categorised ) do

		local node = node_w:AddNode( CategoryName, "icon16/picture.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create( "ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, pp in SortedPairsByMemberValue( v, "PrintName" ) do
			if ( pp.func ) then pp.func( CatPropPanel ) pp.func( node_w.PropPanel ) continue end

			local t = {
				name = pp.name,
				icon = pp.icon
			}

			spawnmenu.CreateContentIcon( "postprocess", CatPropPanel, t )
			spawnmenu.CreateContentIcon( "postprocess", node_w.PropPanel, t )
		end

		function node:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end
	end

end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_npcs", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.npcs", "icon16/monkey.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local NPCList = list.Get( "NPC" )
	local Categories = {}

	for k, v in pairs( NPCList ) do
		local Category = v.Category or "Other"
		local Tab = Categories[ Category ] or {}

		Tab[ k ] = v

		Categories[ Category ] = Tab
	end

	for CategoryName, v in SortedPairs( Categories ) do

		local node = node_w:AddNode( CategoryName, "icon16/monkey.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for name, ent in SortedPairsByMemberValue( v, "Name" ) do
			local t = {
				nicename	= ent.Name or name,
				spawnname	= name,
				material	= "entities/" .. name .. ".png",
				weapon		= ent.Weapons,
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( "npc", CatPropPanel, t )
			spawnmenu.CreateContentIcon( "npc", node_w.PropPanel, t )
		end

		function node:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end
end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_vehicles", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.vehicles", "icon16/car.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Categorised = {}
	local Vehicles = list.Get( "Vehicles" )
	if ( Vehicles ) then
		for k, v in pairs( Vehicles ) do
			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			v.ClassName = k
			v.PrintName = v.Name
			v.ScriptedEntityType = "vehicle"
			table.insert( Categorised[ v.Category ], v )
		end
	end

	for CategoryName, v in SortedPairs( Categorised ) do

		local node = node_w:AddNode( CategoryName, "icon16/car.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", node_w.PropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", CatPropPanel, t )
		end

		function node:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end

end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_weapons", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.weapons", "icon16/gun.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Weapons = list.Get( "Weapon" )
	local Categorised = {}

	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable && !weapon.AdminSpawnable ) then continue end

		Categorised[ weapon.Category ] = Categorised[ weapon.Category ] or {}
		table.insert( Categorised[ weapon.Category ], weapon )
	end

	for CategoryName, v in SortedPairs( Categorised ) do
		local node = node_w:AddNode( CategoryName, "icon16/gun.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", CatPropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", node_w.PropPanel, t )
		end

		function node:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end

end )

--addons/admin_sam/lua/sam/config/sh_config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

sam.permissions.add("manage_config", nil, "superadmin")

local updates = {}
function config.hook(keys, func)
	for i = #keys, 1, -1 do
		keys[keys[i]] = true
		keys[i] = nil
	end

	local id = table.insert(updates, {
		keys = keys,
		func = func
	})

	if config.loaded then
		func()
	end

	return id
end

function config.get_updated(key, default)
	local setting = {}
	config.hook({key}, function()
		setting.value = config.get(key, default)
	end)
	return setting
end

function config.remove_hook(key)
	updates[key] = nil
end

hook.Add("SAM.LoadedConfig", "RunHooks", function()
	for k, v in pairs(updates) do
		v.func()
	end
end)

hook.Add("SAM.UpdatedConfig", "RunHooks", function(key, value, old)
	for k, v in pairs(updates) do
		if v.keys[key] then
			v.func(value, old)
		end
	end
end)
--addons/admin_sam/lua/sam/config/cl_config.lua:
if SAM_LOADED then return end

local sam = sam
local sfs = sam.sfs
local config = sam.config
local type = sam.type

local encoders = sfs.Encoder.encoders

function config.set(key, value, force)
	if not sam.isstring(key) then
		error("invalid setting name")
	end

	if not encoders[type(value)] then
		error("not supported value type")
	end

	if not force and config.get(key) == value then return end
	sam.netstream.Start("Config.Set", key, value)
end

function config.get(key, default)
	local value = sam.get_global("Config", {})[key]
	if value ~= nil then
		return value
	end
	return default
end

local menu_settings = {}
function config.add_menu_setting(title, func)
	local i = #menu_settings + 1
	for k, v in ipairs(menu_settings) do
		if v.title == title then
			i = k
			break
		end
	end
	menu_settings[i] = {
		title = title,
		func = func,
	}
end

function config.get_menu_settings()
	return menu_settings
end

hook.Add("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig", function(key, value)
	if key == "Config" then
		config.loaded = true
		hook.Call("SAM.LoadedConfig", nil, value)
		hook.Remove("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig")
	end
end)

--addons/admin_sam/lua/sam/player/sh_nw_vars.lua:
if SAM_LOADED then return end

local netstream = sam.netstream

local nwvars = {}

if SERVER then
	function sam.player.set_nwvar(ply, key, value, force)
		local id = ply:EntIndex()
		if force or nwvars[id][key] ~= value then
			nwvars[id][key] = value
			netstream.Start(nil, "SetNWVar", id, key, value)
		end
	end
end

if CLIENT then
	function sam.player.set_nwvar(ply, key, value)
		local id_vars = nwvars[ply:EntIndex()]
		id_vars[key] = value
	end

	netstream.Hook("SetNWVar", function(id, key, value)
		local id_vars = nwvars[id]
		if id_vars == nil then
			nwvars[id] = {
				[key] = value
			}
		else
			id_vars[key] = value
		end
	end)

	netstream.Hook("SendNWVars", function(vars)
		nwvars = vars
	end)

	netstream.Hook("RemoveNWVar", function(id)
		nwvars[id] = nil
	end)
end

function sam.player.get_nwvar(ply, key, default)
	local value = nwvars[ply:EntIndex()]
	if value then
		value = value[key]
		if value ~= nil then
			return value
		end
	end
	return default
end

if SERVER then
	hook.Add("OnEntityCreated", "SAM.NWVars", function(ent)
		if ent:IsPlayer() and ent:IsValid() then
			nwvars[ent:EntIndex()] = {}
		end
	end)

	hook.Add("SAM.PlayerNetReady", "SAM.SendNWVars", function(ply)
		netstream.Start(ply, "SendNWVars", nwvars)
	end)

	hook.Add("EntityRemoved", "SAM.RemoveNWVars", function(ent)
		if ent:IsPlayer() then
			local id = ent:EntIndex()
			nwvars[id] = nil
			netstream.Start(nil, "RemoveNWVar", id)
		end
	end)
end

--addons/admin_sam_sui/lua/sui/libs/tdlib/cl_tdlib.lua:
--[[
	Three's Derma Lib
	Made by Threebow

	You are free to use this anywhere you like, or sell any addons
	made using this, as long as I am properly accredited.
]]

local pairs = pairs
local ipairs = ipairs
local Color = Color
local render = render
local SysTime = SysTime
local Lerp, RealFrameTime = Lerp, RealFrameTime
local RoundedBox, RoundedBoxEx, NoTexture = draw.RoundedBox, draw.RoundedBoxEx, draw.NoTexture
local SetDrawColor, DrawRect = surface.SetDrawColor, surface.DrawRect
local DrawPoly = surface.DrawPoly
local sui = sui

local Panel = FindMetaTable("Panel")

--[[
	Constants
]]
local BLUR = CreateMaterial("SUI.TDLib.Blur", "gmodscreenspace", {
	["$basetexture"] = "_rt_fullframefb",
	["$blur"] = (1 / 3) * 7,
})

local COL_WHITE_1 = Color(255, 255, 255)
local COL_WHITE_2 = Color(255, 255, 255, 30)

--[[
	credits to http://slabode.exofire.net/circle_draw.shtml
]]
local calculate_circle do
	local cos = math.cos
	local sin = math.sin
	local round = math.Round
	local sqrt = math.sqrt
	local pi = math.pi
	calculate_circle = function(circle, x_centre, y_centre, r)
		if circle.x == x_centre and circle.y == y_centre and circle.r == r then return end

		local step = (2 * pi) / round(6 * sqrt(r))

		local i = 0
		for theta = 2 * pi, 0, -step do
			local x = x_centre + r * cos(theta)
			local y = y_centre - r * sin(theta)
			i = i + 1
			circle[i] = {
				x = x,
				y = y
			}
		end

		for i = i + 1, #circle do
			circle[i] = nil
		end

		circle.x = x_centre
		circle.y = y_centre
		circle.r = r
	end
end

--[[
void DrawArc(float cx, float cy, float r, float start_angle, float arc_angle, int num_segments)
{
	float theta = arc_angle / float(num_segments - 1);//theta is now calculated from the arc angle instead, the - 1 bit comes from the fact that the arc is open

	float tangetial_factor = tanf(theta);

	float radial_factor = cosf(theta);


	float x = r * cosf(start_angle);//we now start at the start angle
	float y = r * sinf(start_angle);

	glBegin(GL_LINE_STRIP);//since the arc is not a closed curve, this is a strip now
	for(int ii = 0; ii < num_segments; ii++)
	{
		glVertex2f(x + cx, y + cy);

		float tx = -y;
		float ty = x;

		x += tx * tangetial_factor;
		y += ty * tangetial_factor;

		x *= radial_factor;
		y *= radial_factor;
	}
	glEnd();
}
]]

local copy_color = function(color)
	return Color(color.r, color.g, color.b, color.a)
end

local color_alpha = function(color, a)
	color.a = a
	return color
end

--[[
	Collection of various utilities
]]

local TDLibUtil = {}

function TDLibUtil.DrawCircle(circle, x, y, r, color)
	calculate_circle(circle, x, y, r)

	SetDrawColor(color)
	NoTexture()
	DrawPoly(circle)
end
local DrawCircle = TDLibUtil.DrawCircle

do
	local SetMaterial = surface.SetMaterial
	local UpdateScreenEffectTexture, DrawTexturedRect, SetScissorRect = render.UpdateScreenEffectTexture, surface.DrawTexturedRect, render.SetScissorRect

	local scrW, scrH = ScrW(), ScrH()
	hook.Add("OnScreenSizeChanged", "SUI.TDLib", function()
		scrW, scrH = ScrW(), ScrH()
	end)

	function TDLibUtil.BlurPanel(s)
		local x, y = s:LocalToScreen(0, 0)

		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		for i = 1, 2 do
			UpdateScreenEffectTexture()
			DrawTexturedRect(x * -1, y * -1, scrW, scrH)
		end
	end

	function TDLibUtil.DrawBlur(x, y, w, h)
		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		SetScissorRect(x, y, x + w, y + h, true)
			for i = 1, 2 do
				UpdateScreenEffectTexture()
				DrawTexturedRect(-1, -1, scrW, scrH)
			end
		SetScissorRect(0, 0, 0, 0, false)
	end
end

local LibClasses = {}

do
	local on_funcs = {}

	function LibClasses:On(name, func)
		local old_func = self[name]

		if not old_func then
			self[name] = func
			return self
		end

		local name_2 = name .. "_funcs"

		-- we gotta avoid creating 13535035 closures
		if not on_funcs[name] then
			on_funcs[name] = function(s, a1, a2, a3, a4)
				local funcs = s[name_2]
				local i, n = 0, #funcs
				::loop::
				i = i + 1
				if i <= n then
					funcs[i](s, a1, a2, a3, a4)
					goto loop
				end
			end
		end

		if not self[name_2] then
			self[name] = on_funcs[name]
			self[name_2] = {
				old_func,
				func
			}
		else
			table.insert(self[name_2], func)
		end

		return self
	end
end

do
	local UnPredictedCurTime = UnPredictedCurTime

	local transition_func = function(s)
		local transitions = s.transitions
		local i, n = 0, #transitions
		::loop::
		i = i + 1

		if i <= n then
			local v = transitions[i]
			local name = v.name
			local v2 = s[name]
			if v.func(s) then
				if v.start_0 then
					v.start_1, v.start_0 = UnPredictedCurTime(), nil
				end

				if v2 ~= 1 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_1) / v.time, v2, 1)
				end
			else
				if v.start_1 then
					v.start_0, v.start_1 = UnPredictedCurTime(), nil
				end

				if v2 ~= 0 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_0) / v.time, v2, 0)
				end
			end

			goto loop
		end
	end

	function LibClasses:SetupTransition(name, time, func)
		self[name] = 0

		local transition = {
			name = name,
			time = time,
			func = func,
			start_0 = 0,
			start_1 = 0,
		}

		if self.transitions then
			for k, v in ipairs(self.transitions) do
				if v.name == name then
					self.transitions[k] = transition
					return self
				end
			end
			table.insert(self.transitions, transition)
		else
			self.transitions = {transition}
			self:On("Think", transition_func)
		end

		return self
	end
end

function LibClasses:ClearPaint()
	self.Paint = nil
	self.Paint_funcs = nil
	local SetPaintBackgroundEnabled = self.SetPaintBackgroundEnabled
	if SetPaintBackgroundEnabled then
		SetPaintBackgroundEnabled(self, false)
	end
	return self
end

function LibClasses:RoundedBox(id, r, x, y, w, h, c)
	self.colors = self.colors or {}
	local colors = self.colors

	local id_c = colors[id]
	if not id_c then
		id_c = Color(c:Unpack())
		colors[id] = id_c
	end

	sui.lerp_color(id_c, c)
	RoundedBox(r, x, y, w, h, id_c)
end

do
	local SetFGColor = Panel.SetFGColor

	local set_color = function(s, col)
		s.m_colText = col
		SetFGColor(s, col.r, col.g, col.b, col.a)
	end

	local paint = function(s)
		local col = s.sui_textcolor
		sui.lerp_color(col, s.new_col)
		set_color(s, col)
	end

	function LibClasses:TextColor(c, use_paint)
		local col = self.sui_textcolor
		if not col then
			col = Color(c:Unpack())
			self.sui_textcolor = col

			if use_paint then
				self:On("Paint", paint)
			end
		end

		if use_paint then
			self.new_col = c
		else
			sui.lerp_color(col, c)
			self:SetTextColor(col)
		end
	end
end

do
	local fade_hover_Paint = function(s, w, h)
		if s.FadeHovers ~= 0 then
			color_alpha(s.fadehover_color, s.fadehover_old_alpha * s.FadeHovers)
			if s.fadehover_radius > 0 then
				RoundedBox(s.fadehover_radius, 0, 0, w, h, s.fadehover_color)
			else
				SetDrawColor(s.fadehover_color)
				DrawRect(0, 0, w, h)
			end
		end
	end

	function LibClasses:FadeHover(color, time, radius, func)
		color = copy_color(color or COL_WHITE_2)
		self.fadehover_color = color
		self.fadehover_radius = radius or 0
		self.fadehover_old_alpha = color.a
		self:SetupTransition("FadeHovers", time or 0.8, func or TDLibUtil.HoverFunc)
		self:On("Paint", fade_hover_Paint)
		return self
	end
end

function LibClasses:BarHover(color, height, time)
	color = color or COL_WHITE_1
	height = height or 2
	time = time or 1.6
	self:SetupTransition("BarHovers", time, TDLibUtil.HoverFunc)
	self:On("Paint", function(s, w, h)
		if s.BarHovers ~= 0 then
			local bar = Round(w * s.BarHovers)
			SetDrawColor(color)
			DrawRect((w / 2) - (bar / 2), h - height, bar, height)
		end
	end)
	return self
end

do
	local paint = function(s, w, h)
		draw.RoundedBox(0, 0, 0, w, h, s.SUI_GetColor("line"))
	end

	function LibClasses:Line(dock, m1, m2, m3, m4)
		self.making_line = true

		local line = self:Add("SAM.Panel")
		line:Dock(dock or TOP)

		if self.line_margin then
			line:DockMargin(unpack(self.line_margin))
		else
			line:DockMargin(m1 or 0, m2 or 0, m3 or 0, m4 or 10)
		end

		line.no_scale = true
		line:SetTall(1)
		line.Paint = paint

		self.making_line = false
		return line
	end

	function LibClasses:LineMargin(m1, m2, m3, m4)
		self.line_margin = {m1 or 0, m2 or 0, m3 or 0, m4 or 0}
		return self
	end
end

do
	local background_Paint_1 = function(s)
		s:SetBGColor(s.background_color)
	end

	local background_Paint_2 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, true, true, true, true)
	end

	local background_Paint_3 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, s.background_r_tl, s.background_r_tr, s.background_r_bl, s.background_r_br)
	end

	function LibClasses:Background(color, radius, r_tl, r_tr, r_bl, r_br)
		self.background_color = color
		if isnumber(radius) and radius ~= 0 then
			self.background_radius = radius
			if isbool(r_tl) or isbool(r_tr) or isbool(r_bl) or isbool(r_br) then
				self.background_r_tl = r_tl
				self.background_r_tr = r_tr
				self.background_r_bl = r_bl
				self.background_r_br = r_br
				self:On("Paint", background_Paint_3)
			else
				self:On("Paint", background_Paint_2)
			end
		else
			self:SetPaintBackgroundEnabled(true)
			self:On("ApplySchemeSettings", background_Paint_1)
			self:On("PerformLayout", background_Paint_1)
		end
		return self
	end
end

function LibClasses:CircleClick(color, speed, target_radius)
	self.circle_click_color = color or COL_WHITE_2

	speed = speed or 5
	target_radius = isnumber(target_radius) and target_radius or false

	local radius, alpha, click_x, click_y = 0, -1, 0, 0
	local circle = {}
	self:On("Paint", function(s, w)
		if alpha >= 0 then
			DrawCircle(circle, click_x, click_y, radius, ColorAlpha(self.circle_click_color, alpha))
			local frame_time = RealFrameTime()
			radius, alpha = Lerp(frame_time * speed, radius, target_radius or w), Lerp(frame_time * speed, alpha, -1)
		end
	end)
	self:On("DoClick", function()
		click_x, click_y = self:CursorPos()
		radius, alpha = 0, self.circle_click_color.a
	end)
	return self
end

do
	local min = math.min
	function LibClasses:CircleClick2(color, speed, target_radius, start_radius)
		color = color or COL_WHITE_2
		local _color = Color(color:Unpack())

		speed = speed or 5
		target_radius = isnumber(target_radius) and target_radius or false

		local radius, alpha = 0, -1
		local circle = {}
		self:On("Paint", function(s, w, h)
			if alpha >= 0 then
				_color.a = alpha
				DrawCircle(circle, w / 2, h / 2, radius, _color)

				local frame_time = RealFrameTime()
				radius, alpha = Lerp(frame_time * speed, radius, target_radius or min(w, h) / 2), Lerp(frame_time * speed, alpha, -1)
			end
		end)

		self:On("DoClick", function()
			radius, alpha = start_radius or 0, color.a
		end)

		return self
	end
end

-- https://github.com/Facepunch/garrysmod/pull/1520#issuecomment-410458090
function LibClasses:Outline(color, width)
	color = color or COL_WHITE_1
	width = width or 1
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, w, width)
		DrawRect(0, h - width, w, width)
		DrawRect(0, width, width, h - (width * 2))
		DrawRect(w - width, width, width, h - (width * 2))
	end)
	return self
end

function LibClasses:LinedCorners(color, len)
	color = color or COL_WHITE_1
	len = len or 15
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, len, 1)
		DrawRect(0, 1, 1, len - 1)
		DrawRect(w - len, h - 1, len, 1)
		DrawRect(w - 1, h - len, 1, len - 1)
	end)
	return self
end

function LibClasses:SideBlock(color, size, side)
	color = color or COL_WHITE_1
	size = size or 3
	side = side or LEFT
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		if side == LEFT then
			DrawRect(0, 0, size, h)
		elseif side == TOP then
			DrawRect(0, 0, w, size)
		elseif size == RIGHT then
			DrawRect(w - size, 0, size, h)
		elseif side == BOTTOM then
			DrawRect(0, h - size, w, size)
		end
	end)
	return self
end

function LibClasses:Blur()
	self:On("Paint", TDLibUtil.BlurPanel)
	return self
end

do
	local STENCILOPERATION_REPLACE = STENCILOPERATION_REPLACE
	local STENCILOPERATION_ZERO = STENCILOPERATION_ZERO
	local STENCILCOMPARISONFUNCTION_NEVER = STENCILCOMPARISONFUNCTION_NEVER
	local STENCILCOMPARISONFUNCTION_EQUAL = STENCILCOMPARISONFUNCTION_EQUAL

	local ClearStencil = render.ClearStencil
	local SetStencilEnable = render.SetStencilEnable
	local SetStencilWriteMask = render.SetStencilWriteMask
	local SetStencilTestMask = render.SetStencilTestMask
	local SetStencilFailOperation = render.SetStencilFailOperation
	local SetStencilPassOperation = render.SetStencilPassOperation
	local SetStencilZFailOperation = render.SetStencilZFailOperation
	local SetStencilCompareFunction = render.SetStencilCompareFunction
	local SetStencilReferenceValue = render.SetStencilReferenceValue

	local color_white = color_white

	local avatar_setplayer = function(s, ply, size)
		s.avatar:SetPlayer(ply, size)
	end

	local avatar_setsteamid = function(s, steamid, size)
		s.avatar:SetSteamID(steamid, size)
	end

	function LibClasses:CircleAvatar()
		local avatar = self:Add("AvatarImage")
		avatar:Dock(FILL)
		avatar:SetPaintedManually(true)
		self.avatar = avatar
		self.SetSteamID = avatar_setsteamid
		self.SetPlayer = avatar_setplayer

		local circle = {}
		local PaintManual = avatar.PaintManual
		self.Paint = function(s, w, h)
			ClearStencil()
			SetStencilEnable(true)

			SetStencilWriteMask(1)
			SetStencilTestMask(1)

			SetStencilFailOperation(STENCILOPERATION_REPLACE)
			SetStencilPassOperation(STENCILOPERATION_ZERO)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
			SetStencilReferenceValue(1)

			local a = w / 2
			DrawCircle(circle, a, a, a, color_white)

			SetStencilFailOperation(STENCILOPERATION_ZERO)
			SetStencilPassOperation(STENCILOPERATION_REPLACE)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
			SetStencilReferenceValue(1)

			PaintManual(avatar)

			SetStencilEnable(false)
		end
		return self
	end
end

do
	function LibClasses:AnimationThinkInternal()
		local systime = SysTime()

		if self.Term and self.Term <= systime then
			self:Remove()

			return
		end

		local m_AnimList = self.m_AnimList
		if not m_AnimList then return end

		for i = #m_AnimList, 1, -1 do
			local anim = m_AnimList[i]
			if systime >= anim.StartTime then
				local frac = math.TimeFraction(anim.StartTime, anim.EndTime, systime)
				frac = math.Clamp(frac, 0, 1)

				local Think = anim.Think
				if Think then
					Think(anim, self, frac ^ (1.0 - (frac - 0.5)))
				end

				if frac == 1 then
					local OnEnd = anim.OnEnd
					if OnEnd then
						OnEnd(anim, self)
					end

					m_AnimList[i] = nil
				end
			end
		end
	end

	local sort = function(a, b)
		return a.EndTime > b.EndTime
	end

	function LibClasses:NewAnimation(length, delay, ease, callback)
		delay = delay or 0
		ease = ease or -1

		if self.m_AnimQueue then
			delay = delay + self:AnimTail()
			self.m_AnimQueue = false
		else
			delay = delay + SysTime()
		end

		local anim = {
			StartTime = delay,
			EndTime = delay + length,
			Ease = ease,
			OnEnd = callback
		}

		self:SetAnimationEnabled(true)

		if self.m_AnimList == nil then
			self.m_AnimList = {}
		end

		table.insert(self.m_AnimList, anim)
		table.sort(self.m_AnimList, sort)

		self.AnimationThink = self.AnimationThinkInternal

		return anim
	end

	local MoveThink = function(anim, panel, frac)
		if not anim.startx then
			anim.startx = panel.x
			anim.starty = panel.y
		end

		local x = Lerp(frac, anim.startx, anim.x)
		local y = Lerp(frac, anim.starty, anim.y)
		panel:SetPos(x, y)
	end

	function LibClasses:MoveTo(x, y, length, delay, ease, callback)
		if self.x == x and self.y == y then return end

		local anim = self:NewAnimation(length, delay, ease, callback)
		anim.x = x
		anim.y = y
		anim.Think = MoveThink
	end

	local SetSize = Panel.SetSize
	local SizeThink = function(anim, panel, frac)
		if not anim.startw then
			anim.startw, anim.starth = panel:GetSize()
		end

		local w, h
		if anim.sizew and anim.sizeh then
			w = Lerp(frac, anim.startw, anim.w)
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, w, h)
		elseif anim.sizew then
			w = Lerp(frac, anim.startw, anim.w)
			SetSize(panel, w, panel.starth)
		else
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, panel.startw, h)
		end

		if panel:GetDock() > 0 then
			panel:InvalidateParent()
		end
	end

	function LibClasses:SizeTo(w, h, length, delay, ease, callback)
		local anim = self:NewAnimation(length, delay, ease, callback)

		if w ~= -1 then
			anim.sizew = true
		end

		if h ~= -1 then
			anim.sizeh = true
		end

		anim.w, anim.h = w, h
		anim.Think = SizeThink

		return anim
	end

	local SetVisible = Panel.SetVisible
	local IsVisible = Panel.IsVisible

	local is_visible = function(s)
		local state = s.visible_state
		if state ~= nil then
			return state
		else
			return IsVisible(s)
		end
	end

	function LibClasses:AnimatedSetVisible(visible, cb)
		if visible == is_visible(self) then
			if cb then
				cb()
			end
			return
		end

		if visible then
			SetVisible(self, true)
		end

		self.visible_state = visible
		self:Stop()

		self:AlphaTo(visible and 255 or 0, 0.2, 0, function()
			SetVisible(self, visible)
			self:InvalidateParent(true)
			if cb then
				cb()
			end
		end)

		self:InvalidateParent(true)
	end

	function LibClasses:AnimatedToggleVisible()
		self:AnimatedSetVisible(not is_visible(self))
	end

	function LibClasses:AnimatedIsVisible()
		return is_visible(self)
	end
end

function Panel:SUI_TDLib()
	for k, v in pairs(LibClasses) do
		self[k] = v
	end
	return self
end

TDLibUtil.Install = Panel.SUI_TDLib

local count = 0
TDLibUtil.Start = function()
	count = count + 1
	for k, v in pairs(LibClasses) do
		if not Panel["SUI_OLD" .. k] then
			local old = Panel[k]
			if old == nil then
				old = v
			end
			Panel[k], Panel["SUI_OLD" .. k] = v, old
		end
	end
end

TDLibUtil.End = function()
	count = count - 1
	if count > 0 then return end
	for k, v in pairs(LibClasses) do
		local old = Panel["SUI_OLD" .. k]
		if old == v then
			Panel[k] = nil
		else
			Panel[k] = old
		end
		Panel["SUI_OLD" .. k] = nil
	end
end

TDLibUtil.HoverFunc = function(p)
	return p:IsHovered() and not p:GetDisabled()
end

TDLibUtil.DrawOutlinedBox = function(radius, x, y, w, h, bg, outline, thickness)
	thickness = thickness or 2
	draw.RoundedBox(radius, x, y, w, h, outline)
	draw.RoundedBox(radius, x + thickness, y + thickness, w - (thickness * 2), h - (thickness * 2), bg)
end

do
	local cos, sin, sqrt = math.cos, math.sin, math.sqrt
	local clamp, floor = math.Clamp, math.floor
	local min, max = math.min, math.max

	local calc_ellipse_points = function(rx, ry)
		local points = sqrt(((rx * ry) / 2) * 6)
		return max(points, 8)
	end

	local M_PI = 3.14159265358979323846
	calc_rect = function(c, r, x, y, w, h)
		if
			(c.r == r) and
			(c.x == x and c.y == y) and
			(c.w == w and c.h == h)
		then return end

		r = clamp(r, 0, min(w, h) / 2)

		local rx, ry = r, r
		if w >= 0.02 then
			rx = min(rx, w / 2.0 - 0.01)
		end
		if h >= 0.02 then
			ry = min(ry, h / 2.0 - 0.01)
		end

		local points = max(calc_ellipse_points(rx, ry) / 4, 1)
		points = floor(points)

		local half_pi = M_PI / 2
		local angle_shift = half_pi / (points + 1)

		local phi = 0
		for i = 1, points + 2 do
			c[i] = {
				x = x + rx * (1 - cos(phi)),
				y = y + ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = half_pi
		for i = points + 3, 2 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y +     ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 2 * half_pi
		for i = (2 * (points + 2)) + 1, 3 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 3 * half_pi
		for i = (3 * (points + 2)) + 1, 4 * (points + 2) do
			c[i] = {
				x = x +     rx * (1 - cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		local last = (points + 2) * 4 + 1
		c[last] = c[1]

		for i = last + 1, #c do
			c[i] = nil
		end

		c.r = r
		c.x, c.y = x, y
		c.w, c.h = w, h
	end

	TDLibUtil.RoundedBox = function(c, r, x, y, w, h, color)
		calc_rect(c, r, x, y, w, h)

		SetDrawColor(color)
		NoTexture()
		DrawPoly(c)
	end
end

TDLibUtil.LibClasses = LibClasses

sui.TDLib = TDLibUtil
--addons/admin_sam_sui/lua/sui/cl_base.lua:
local hook = hook
local bit = bit
local math = math

local Color = Color
local ipairs = ipairs
local RealFrameTime = RealFrameTime

local color_white = color_white
local color_black = color_black

local sui = sui

local isfunction = sui.isfunction
local isstring = sui.isstring

local floor = math.floor

function sui.scale(v)
	return ScrH() * (v / 900)
end

function sui.hex_rgb(hex)
	hex = tonumber(hex:gsub("^([%w])([%w])([%w])$", "%1%1%2%2%3%3", 1), 16)

	return Color(
		bit.band(bit.rshift(hex, 16), 0xFF),
		bit.band(bit.rshift(hex, 8), 0xFF),
		bit.band(hex, 0xFF)
	)
end

function sui.rgb_hex(c)
	return bit.tohex((c.r * 0x10000) + (c.g * 0x100) + c.b, 6)
end
local rgb_hex = sui.rgb_hex

function sui.lerp_color(from, to)
	local frac = RealFrameTime() * 10
	from.r = Lerp(frac, from.r, to.r)
	from.g = Lerp(frac, from.g, to.g)
	from.b = Lerp(frac, from.b, to.b)
	from.a = Lerp(frac, from.a, to.a)
end

do
	local colors = {
		["41b9ff"] = Color(44, 62, 80),
		["00c853"] = Color(44, 62, 80),
		["181818"] = Color(242, 241, 239),
		["212121"] = Color(242, 241, 239),
	}

	function sui.contrast_color(color)
		local c = colors[rgb_hex(color)]
		if c then return c end

		local luminance = (0.299 * color.r + 0.587 * color.g + 0.114 * color.b) / 255
		return luminance > 0.5 and color_black or color_white
	end
end

do
	local SetDrawColor = surface.SetDrawColor
	local SetMaterial = surface.SetMaterial
	local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
	function sui.draw_material(mat, x, y, size, col, rot)
		SetDrawColor(col)

		if x == -1 then
			x = size / 2
		end

		if y == -1 then
			y = size / 2
		end

		if mat then
			SetMaterial(mat)
		end

		DrawTexturedRectRotated(x, y, size, size, rot or 0)
	end
end

do
	local hsv_t = {
		[0] = function(v, p, q, t)
			return v, t, p
		end,
		[1] = function(v, p, q, t)
			return q, v, p
		end,
		[2] = function(v, p, q, t)
			return p, v, t
		end,
		[3] = function(v, p, q, t)
			return p, q, v
		end,
		[4] = function(v, p, q, t)
			return t, p, v
		end,
		[5] = function(v, p, q, t)
			return v, p, q
		end
	}

	function sui.hsv_to_rgb(h, s, v)
		local i = floor(h * 6)
		local f = h * 6 - i

		return hsv_t[i % 6](
			v * 255, -- v
			(v * (1 - s)) * 255, -- p
			(v * (1 - f * s)) * 255, -- q
			(v * (1 - (1 - f) * s)) * 255 -- t
		)
	end
end

local Panel = FindMetaTable("Panel")
local SetSize = Panel.SetSize
local GetWide = Panel.GetWide
local GetTall = Panel.GetTall
function sui.scaling_functions(panel)
	local scale_changed
	local SUI = CURRENT_SUI

	local dock_top = function(s, h)
		if not h then return end

		if not scale_changed then
			s.real_h = h
		end

		if not s.no_scale then
			h = SUI.Scale(h)
		end

		if GetTall(s) == h then return end

		SetSize(s, GetWide(s), h)
	end

	local dock_right = function(s, w)
		if not w then return end

		if not scale_changed then
			s.real_w = w
		end

		if not s.no_scale then
			w = SUI.Scale(w)
		end

		if GetWide(s) == w then return end

		SetSize(s, w, GetTall(s))
	end

	local size_changed = function(s, w, h)
		if s.using_scale then return end

		s.using_scale = true

		local dock = s:GetDock()

		if dock ~= FILL then
			if dock == NODOCK then
				dock_top(s, h)
				dock_right(s, w)
			elseif dock == TOP or dock == BOTTOM then
				dock_top(s, h)
			else
				dock_right(s, w)
			end
		end

		s.using_scale = nil
	end

	local wide_changed = function(s, w)
		size_changed(s, w)
	end

	local tall_changed = function(s, h)
		size_changed(s, nil, h)
	end

	function panel:ScaleChanged()
		scale_changed = true
		size_changed(self, self.real_w, self.real_h)
		scale_changed = nil
		if self.OnScaleChange then
			self:OnScaleChange()
		end
	end

	local on_remove = function(s)
		SUI.RemoveScaleHook(s)
	end

	function panel:ScaleInit()
		self.SetSize = size_changed
		self.SetWide = wide_changed
		self.SetTall = tall_changed
		SUI.OnScaleChanged(self, self.ScaleChanged)
		self:On("OnRemove", on_remove)
	end
end

do
	local utf8 = {}

	local str_rel_to_abs = function(str, v, str_n)
		return v > 0 and v or math.max(str_n + v + 1, 1)
	end

	local utf8_decode = function(str, start_pos, str_n)
		start_pos = str_rel_to_abs(str, start_pos or 1, str_n)

		local b1 = str:byte(start_pos, start_pos)
		if not b1 then return nil end
		if b1 < 0x80 then return start_pos, start_pos, b1 end
		if b1 > 0xF4 or b1 < 0xC2 then return nil end

		local cont_byte_count = b1 >= 0xF0 and 3 or b1 >= 0xE0 and 2 or b1 >= 0xC0 and 1
		local end_pos = start_pos + cont_byte_count
		local code_point = 0

		if str_n < end_pos then return nil end

		local bytes = {str:byte(start_pos + 1, end_pos)}
		for i = 1, #bytes do
			local b_x = bytes[i]
			if bit.band(b_x, 0xC0) ~= 0x80 then return nil end
			code_point = bit.bor(bit.lshift(code_point, 6), bit.band(b_x, 0x3F))
			b1 = bit.lshift(b1, 1)
		end

		code_point = bit.bor(code_point, bit.lshift(bit.band(b1, 0x7F), cont_byte_count * 5))

		return start_pos, end_pos, code_point
	end

	local replacement = string.char(239, 191, 189)

	function utf8.force(str)
		local end_pos = #str
		if end_pos == 0 then return str, end_pos end

		local ret = ""
		local cur_pos = 1

		repeat
			local seq_start_pos, seq_end_pos = utf8_decode(str, cur_pos, end_pos)

			if not seq_start_pos then
				ret = ret .. replacement
				cur_pos = cur_pos + 1
			else
				ret = ret .. str:sub(seq_start_pos, seq_end_pos)
				cur_pos = seq_end_pos + 1
			end
		until cur_pos > end_pos

		return ret, #ret
	end

	-- https://gist.github.com/gdeglin/4128882

	local utf8_char_bytes = function(c)
		if c > 0 and c <= 127 then
			return 1
		elseif c >= 194 and c <= 223 then
			return 2
		elseif c >= 224 and c <= 239 then
			return 3
		elseif c >= 240 and c <= 244 then
			return 4
		end
	end
	utf8.char_bytes = utf8_char_bytes

	function utf8.len(str)
		local length = #str

		local len = 0

		local pos = 1
		while pos <= length do
			len = len + 1
			pos = pos + utf8_char_bytes(str:byte(pos))
		end

		return len
	end

	function utf8.sub(str, i, j)
		j = j or -1

		if i == nil then return "" end

		local l = (i >= 0 and j >= 0) or utf8.len(str)
		local start_char = (i >= 0) and i or l + i + 1
		local end_char = (j >= 0) and j or l + j + 1

		if start_char > end_char then return "" end

		local pos = 1
		local length = #str
		local len = 0

		local start_byte, end_byte = 1, length

		while pos <= length do
			len = len + 1

			if len == start_char then
				start_byte = pos
			end

			pos = pos + utf8_char_bytes(str:byte(pos))

			if len == end_char then
				end_byte = pos - 1
				break
			end
		end

		return str:sub(start_byte, end_byte)
	end

	sui.utf8 = utf8
end

--
-- thanks falco!
-- https://github.com/FPtje/DarkRP/blob/4fd2c3c315427e79bb7624702cfaefe9ad26ac7e/gamemode/modules/base/cl_util.lua#L42
--
do
	local utf8 = utf8
	local surface = surface

	local max_width, original_width, can_fix

	local fix_width = function()
		if can_fix then
			can_fix = false
			max_width = original_width
		end
	end

	local char_wrap = function(text, remaining_width)
		local total_width  = 0

		local new_text = ""
		for char in text:gmatch(utf8.charpattern) do
			total_width  = total_width  + surface.GetTextSize(char)
			if total_width >= remaining_width then
				total_width = surface.GetTextSize(char)
				fix_width()
				remaining_width = max_width

				new_text = new_text .. ("\n" .. char)
			else
				new_text = new_text .. char
			end
		end

		return new_text, total_width
	end

	function sui.wrap_text(text, font, width, first_width)
		text = sui.utf8.force(text)

		local total_width = 0
		can_fix = first_width and true or false
		max_width, original_width = first_width or width, width

		surface.SetFont(font)

		local space_width = surface.GetTextSize(" ")

		text = text:gsub("(%s?[%S]*)", function(word)
			local char = word:sub(1, 1)
			if char == "\n" then
				total_width = 0
				fix_width()
			end

			local wordlen = surface.GetTextSize(word)
			total_width = total_width + wordlen

			if wordlen >= max_width then
				local split_word
				split_word, total_width = char_wrap(word, max_width - (total_width - wordlen))
				return split_word
			elseif total_width < max_width then
				return word
			end

			fix_width()

			total_width = wordlen

			if char == " " then
				total_width = total_width - space_width
				return "\n" .. word:sub(2)
			end

			return "\n" .. word
		end)

		return text
	end
end

function sui.register(classname, panel_table, parent_class)
	sui.TDLib.Install(panel_table)

	if not panel_table.Add then
		function panel_table:Add(pnl)
			return vgui.Create(pnl, self)
		end
	end

	if not panel_table.NoOverrideClear and not panel_table.Clear then
		function panel_table:Clear()
			local children = self:GetChildren()
			for i = 1, #children do
				children[i]:Remove()
			end
		end
	end

	local SUI = CURRENT_SUI

	for k, v in pairs(SUI.panels_funcs) do
		panel_table[k] = v
	end

	panel_table.SUI_GetColor = function(name)
		return SUI.GetColor(name)
	end

	SUI.panels[classname] = panel_table

	return vgui.Register(SUI.name .. "." .. classname, panel_table, parent_class)
end

local Material; do
	local C_Material, material_str = select(2, debug.getupvalue(_G.Material, 1)), "0001010" -- [["mips smooth"]]
	Material = function(name)
		return C_Material(name, material_str)
	end
end
sui.Material = Material

local function prepare_theme(theme)
	for k, v in pairs(theme) do
		if IsColor(v) then continue end

		if istable(v) then
			prepare_theme(v)
		elseif isstring(v) and v:sub(1, 1) == "#" then
			theme[k] = sui.hex_rgb(v:sub(2))
		end
	end
end

function sui.new(addon_name, default_scaling, panels_funcs)
	local SUI = {
		name = addon_name,
		panels = {},
		panels_funcs = panels_funcs or {}
	}

	CURRENT_SUI = SUI

	do
		local themes = table.Copy(sui.themes)
		local current_theme_table

		function SUI.GetColor(color_name)
			return current_theme_table[color_name]
		end

		function SUI.SetTheme(theme_name)
			SUI.current_theme = theme_name
			current_theme_table = themes[theme_name]
			hook.Call(addon_name .. ".ThemeChanged")
		end

		function SUI.GetThemes()
			return themes
		end

		function SUI.AddToTheme(theme_name, tbl)
			local theme = themes[theme_name]
			for k, v in pairs(tbl) do
				theme[k] = v
			end
			prepare_theme(theme)
		end

		function SUI.RemoveTheme(theme_name)
			themes[theme_name] = nil
			if theme_name == SUI.current_theme then
				SUI.SetTheme(next(themes))
			end
		end

		function SUI.AddTheme(theme_name, tbl)
			prepare_theme(tbl)
			themes[theme_name] = tbl
		end

		SUI.themes = themes
	end

	local Scale
	do
		local scale = 1

		if default_scaling then
			SUI.Scale = sui.scale
		else
			function SUI.Scale(v)
				return floor((v * scale) + 0.5)
			end
		end
		Scale = SUI.Scale

		function SUI.ScaleEven(v)
			v = Scale(v)
			if v % 2 ~= 0 then
				v = v + 1
			end
			return v
		end

		function SUI.SetScale(_scale)
			if _scale == scale then return end

			scale = _scale
			SUI.scale = _scale

			for k, v in pairs(SUI.fonts) do
				SUI.CreateFont(k:sub(#addon_name + 1), v.font, v.size, v.weight)
			end

			SUI.CallScaleChanged()
		end

		local n = 0
		local keys = {}
		local hooks = {}
		_G[addon_name .. "_HOOKS"] = keys
		_G[addon_name .. "_KEYS"] = hooks
		_G[addon_name .. "_N"] = function()
			return n
		end
		function SUI.OnScaleChanged(name, func)
			if not isfunction(func) then
				error("Invalid function?")
			end

			if not name then
				error("Invalid name?")
			end

			if not isstring(name) then
				local _func = func
				func = function()
					local isvalid = name.IsValid
					if isvalid and isvalid(name) then
						_func(name)
					else
						SUI.RemoveScaleHook(name, true)
					end
				end
			end

			local pos = keys[name]
			if pos then
				hooks[pos + 1] = func
			else
				hooks[n + 1] = name
				hooks[n + 2] = func
				keys[name] = n + 1
				n = n + 2
			end
		end

		function SUI.RemoveScaleHook(name, in_hook)
			local pos = keys[name]
			if not pos then return end

			if in_hook then
				hooks[pos] = nil
				hooks[pos + 1] = nil
			else
				local new_name = hooks[n - 1]
				if new_name then
					hooks[pos], hooks[pos + 1] = new_name, hooks[n]
					hooks[n - 1], hooks[n] = nil, nil
					keys[new_name] = pos
				end
				n = n - 2
			end
			keys[name] = nil
		end

		function SUI.CallScaleChanged()
			if n == 0 then return end

			local i, c_n = 2, n
			::loop::
			local func = hooks[i]
			if func then
				func()
				i = i + 2
			else
				local _n, _i = c_n, i
				if n ~= c_n then
					_n = n
					i = i + 2
				else
					c_n = c_n - 2
				end

				local new_name = hooks[_n - 1]
				if new_name then
					hooks[_i - 1], hooks[_i] = new_name, hooks[_n]
					hooks[_n - 1], hooks[_n] = nil, nil
					keys[new_name] = _i - 1
				end

				n = n - 2
			end

			if i <= c_n then
				goto loop
			end
		end

		function SUI.GetScale()
			return scale
		end

		SUI.scale = 1
	end

	do
		local fonts = {}

		function SUI.CreateFont(font_name, font, size, weight)
			font_name = addon_name .. font_name

			fonts[font_name] = fonts[font_name] or {
				font = font,
				size = size,
				weight = weight
			}

			surface.CreateFont(font_name, {
				font = font,
				size = Scale(size),
				weight = weight,
				extended = true
			})

			return font_name
		end

		function SUI.GetFont(font_name)
			return addon_name .. font_name
		end

		function SUI.GetFontHeight(font_name)
			local font = fonts[addon_name .. font_name] or fonts[font_name]
			if not font then return 0 end

			return floor(Scale(font.size or 0))
		end

		SUI.fonts = fonts
	end

	do
		local materials = {}

		local delay = 0.008
		local next_run = UnPredictedCurTime()

		function SUI.Material(mat, allow_delay)
			local _mat = materials[mat]
			if _mat then return _mat end

			if allow_delay then
				if UnPredictedCurTime() < next_run then return end
				next_run = UnPredictedCurTime() + delay
			end

			materials[mat] = Material(mat)

			return materials[mat]
		end

		SUI.materials = materials
	end

	SUI.SetTheme("Dark")

	for _, f in ipairs(file.Find("sui/vgui/sui_*.lua", "LUA")) do
		include("sui/vgui/" .. f)
	end

	for _, f in ipairs(file.Find(string.format("sui/vgui/%s_*.lua", addon_name:lower()), "LUA")) do
		include("sui/vgui/" .. f)
	end

	return SUI
end

sui.themes = sui.themes or {}
function sui.add_theme(name, tbl)
	prepare_theme(tbl)
	sui.themes[name] = tbl
end

function sui.valid_options()
	local objs = {}
	objs.IsValid = function()
		local valid = true
		for i = 1, #objs do
			local obj = objs[i]
			if obj:IsValid() and obj.valid == false then
				valid = false
				break
			end
		end
		return valid
	end
	objs.Add = function(obj)
		table.insert(objs, obj)
	end
	return objs
end

do
	local label = vgui.Create("Label")
	label:SetVisible(false)
	label:SetMouseInputEnabled(false)
	label:SetKeyboardInputEnabled(false)

	local SetFontInternal = label.SetFontInternal
	local SetText = label.SetText
	local GetTextSize = label.GetTextSize
	function sui.get_text_size(text, font)
		SetFontInternal(label, font)
		SetText(label, text)
		return GetTextSize(label)
	end
end

do
	local SURFACE = Color(31, 31, 31)
	local PRIMARY = Color(65, 185, 255)

	local ON_SURFACE = Color(255, 255, 255)
	local ON_SURFACE_HIGH_EMPHASIS = ColorAlpha(ON_SURFACE, 221)
	local ON_SURFACE_MEDIUM_EMPHASIS = ColorAlpha(ON_SURFACE, 122)
	local ON_SURFACE_DISABLED = ColorAlpha(ON_SURFACE, 97)

	local ON_PRIMARY = Color(60, 60, 60)

	sui.add_theme("Dark", {
		frame = Color(18, 18, 18),
		frame_blur = false,

		title = ON_SURFACE,
		header = SURFACE,

		close = ON_SURFACE_MEDIUM_EMPHASIS,
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = PRIMARY,
		button_text = "#050709",
		button_hover = ColorAlpha(ON_PRIMARY, 100),
		button_click = ColorAlpha(ON_PRIMARY, 240),
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = ColorAlpha(PRIMARY, 97),
		scroll_grip = PRIMARY,

		scroll_panel = Color(29, 29, 29),
		scroll_panel_outline = false,

		text_entry_bg = Color(34, 34, 34),
		text_entry_bar_color = Color(0, 0, 0, 0),
		text_entry = ON_SURFACE_HIGH_EMPHASIS,
		text_entry_2 = ON_SURFACE_MEDIUM_EMPHASIS,
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(39, 39, 39),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 30),
		property_sheet_tab_active = PRIMARY,

		toggle_button = ON_SURFACE_DISABLED,
		toggle_button_switch = ON_SURFACE_HIGH_EMPHASIS,

		toggle_button_active = ColorAlpha(PRIMARY, 65),
		toggle_button_switch_active = PRIMARY,

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 65),
		slider_hover = ColorAlpha(PRIMARY, 5),
		slider_pressed = ColorAlpha(PRIMARY, 30),

		on_sheet = Color(43, 43, 43, 200),
		on_sheet_hover = Color(200, 200, 200, 20),

		--=--
		query_box_bg = "#181818",
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--

		--=--
		menu = "#212121",

		menu_option = "#212121",
		menu_option_text = "#bdbdbd",
		menu_option_hover = "#3b3b3b",
		menu_option_hover_text = "#fefefe",

		menu_spacer = "#303030",
		--=--

		line = "#303030",

		--=--
		column_sheet = "#263238",
		column_sheet_bar = "#202020",

		column_sheet_tab = "#202020",
		column_sheet_tab_hover = "#2e2e2e",
		column_sheet_tab_active = "#383838",

		column_sheet_tab_icon = "#909090",
		column_sheet_tab_icon_hover = "#f0f0f0",
		column_sheet_tab_icon_active = "#34a1e0",
		--=--

		--=--
		collapse_category_header = "#272727",
		collapse_category_header_hover = "#2a2a2a",
		collapse_category_header_active = "#2e2e2e",

		collapse_category_header_text = "#aaaaaa",
		collapse_category_header_text_hover = "#dcdcdc",
		collapse_category_header_text_active = "#34A1E0",

		collapse_category_item = "#343434",
		collapse_category_item_hover = "#464646",
		collapse_category_item_active = "#535353",

		collapse_category_item_text = "#aaaaaa",
		collapse_category_item_text_hover = "#dcdcdc",
		collapse_category_item_text_active = "#ffffff",
		--=--
	})
end

do
	local PRIMARY = Color(65, 185, 255)

	local ON_PRIMARY = Color(220, 220, 220)

	sui.add_theme("Blur", {
		frame = Color(30, 30, 30, 220),
		frame_blur = true,

		title = Color(255, 255, 255),
		header = Color(60, 60, 60, 200),

		close = Color(200, 200, 200),
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = ColorAlpha(PRIMARY, 130),
		button_text = ON_PRIMARY,
		button_hover = Color(0, 0, 0, 30),
		button_click = PRIMARY,
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = Color(0, 0, 0, 100),
		scroll_grip = PRIMARY,

		scroll_panel = Color(255, 255, 255, 10),
		scroll_panel_outline = false,

		text_entry_bg = Color(0, 0, 0, 0),
		text_entry_bar_color = Color(200, 200, 200, 153),
		text_entry = Color(240, 240, 240, 221),
		text_entry_2 = Color(200, 200, 200, 153),
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(60, 60, 60, 200),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 40),
		property_sheet_tab_active = PRIMARY,

		toggle_button = Color(244, 67, 54),
		toggle_button_switch = Color(230, 230, 230),

		toggle_button_active = PRIMARY,
		toggle_button_switch_active = Color(230, 230, 230),

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 100),
		slider_hover = ColorAlpha(PRIMARY, 40),
		slider_pressed = ColorAlpha(PRIMARY, 70),

		on_sheet = Color(60, 60, 60, 180),
		on_sheet_hover = Color(30, 30, 30, 70),

		--=--
		query_box_bg = Color(0, 0, 0, 100),
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--
	})
end

--addons/admin_sam_sui/lua/sui/vgui/sui_zmenu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4
local max_height = 300

local PerformLayout = function(s)
	local w, h = s:ChildrenSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end
	s:SetSize(math.max(s:GetMinimumWidth(), w), h)
end

function PANEL:Init()
	self:GetCanvas():DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
	self:On("PerformLayoutInternal", PerformLayout)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, NAME .. ".ScrollPanel")
--addons/admin_sam/lua/sam/menu/tabs/config/reports.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local not_empty = function(s)
	return s and s ~= ""
end

local number_entry = function(setting, config_key, default)
	local entry = setting:Add("SAM.TextEntry")
	entry:SetWide(50)
	entry:SetPlaceholder("")
	entry:SetBackground(Color(34, 34, 34))
	entry:SetNumeric(true)
	entry:DisallowFloats()
	entry:DisallowNegative()
	entry:SetCheck(not_empty)
	entry:SetConfig(config_key, default)

	return entry
end

config.add_tab("Reports", function(parent)
	local body = parent:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:LineMargin(0, 6, 0, 0)

	local i = 0
	body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)

		if not body.making_line then
			body:Line()
		end
	end)

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Enable")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Commands")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(200)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.Commands")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Max Reports (Number of reports that can show on your screen)")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.MaxReports", 4)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Auto Close Time (Time to wait before automatically closing claimed reports)")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(70)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetCheck(function(time)
			time = sam.parse_length(time)
			if not time then
				return false
			end
		end)
		entry:SetConfig("Reports.AutoCloseTime", "10m")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Always Show (Show the popups even if you are not on duty)")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports.AlwaysShow", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("On Duty Jobs")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(300)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.DutyJobs", "")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Position")
		setting:DockMargin(8, 6, 8, 0)

		local combo = setting:Add("SAM.ComboBox")
		combo:SetWide(60)
		combo:AddChoice("Left", nil, true)
		combo:AddChoice("Right")
		combo:SetConfig("Reports.Position", "Left")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("X Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.XPadding", 5)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Y Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.YPadding", 5)
	end

	return body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 2)
--addons/admin_sam_modules/lua/sam/modules/aocrp_commands.lua:


sam.command.new_argument("rangauswahl")
    :OnExecute(function(arg, input, ply, _, result)
        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value, data)
            print("SetResult to "..data)
            set_result(data)
            default = data
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            for k, v in pairs(AOCRP.Ranks) do
                self:AddChoice(v.name .. "/".. v.navyprefix, v.rankid)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()



sam.command.new_argument("gearauswahl")
    :OnExecute(function(arg, input, ply, _, result)
        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value, data)
            print("SetResult to "..data)
            set_result(data)
            default = data
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            for k, v in pairs(AOCRP.Gears) do
                self:AddChoice(AOCRP.Units[v.unitid].prefix .. " # " .. v.name, v.gearid)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()


sam.command.new_argument("unitauswahl")
    :OnExecute(function(arg, input, ply, _, result)
        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value, data)
            print("SetResult to "..data)
            set_result(data)
            default = data
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            for k, v in pairs(AOCRP.Units) do
                self:AddChoice(v.name, v.unitid)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()


sam.command.new_argument("subunitauswahl")
    :OnExecute(function(arg, input, ply, _, result)
        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value, data)
            print("SetResult to "..data)
            set_result(data)
            default = data
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            for k, v in pairs(AOCRP.SubUnits) do
                self:AddChoice(v.name, v.subunitid)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()

sam.command.set_category("AOCRP")

sam.command.new("rang")
    :SetPermission("rang") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte den Rang eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("rangauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, rang)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            AOCRP.HUD:CallRankNotify(target, rang)

            AOCRP.UnitLog:AddCharPlusUnit(target:GetCloneID(), target:GetUnitID(), target:GetCloneID() .. " wurde durch das ROK zum "..AOCRP.Ranks[tonumber(rang)].name.." ernnant.")
            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "rankid", rang, function()
                target:SetRankID(rang)
            end)
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} zum {V} ernannt.", {
            A = calling_ply, T = targets, V = AOCRP.Ranks[tonumber(rang)].name
        })
    end)
:End()

sam.command.new("temprang")
    :SetPermission("temprang") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte den Rang eines Spielers temporr")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("rangauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, rang)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            --AOCRP.HUD:CallRankNotify(target, rang)
            target:SetRankID(rang)
--[[             AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "rankid", rang, function()
                target:SetRankID(rang)
            end) ]]
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} temporr zum {V} ernannt.", {
            A = calling_ply, T = targets, V = AOCRP.Ranks[tonumber(rang)].name
        })
    end)
:End()


sam.command.new("cloneid")
    :SetPermission("cloneid") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte die CloneID eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("number", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
        min = 111111,
        max = 999999,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, cloneid)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            AOCRP.CharSys:IsCloneIDFree(cloneid, function(free) 
                if free then
                    AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "cloneid", cloneid)
                    target:SetCloneID(cloneid)

                    sam.player.send_message(nil, "AOCRP | {A} hat die CloneID von {T} zu {V} gendert.", {
                        A = calling_ply, T = targets, V = cloneid
                    })
                else
                    calling_ply:ChatPrint("*** Die gewnschte Klon-ID ist nicht frei.")
                end
            
            end)

        end
 


    end)
:End()



sam.command.new("name")
    :SetPermission("name") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte den Name des aktuellen Charakters vom Spieler")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Name",
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, name)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "name", name, function()
                target:SetCloneName(name)

                
                sam.player.send_message(nil, "AOCRP | {A} hat {T} zu {V} umbenannt.", {
                    A = calling_ply, T = targets, V = name
                })
            end)
        end
 

    end)
:End()

sam.command.new("tempname")
    :SetPermission("tempname") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte den Name des aktuellen Charakters vom Spieler TEMPORR")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Name",
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, name)
        local enable_disable

        sam.player.send_message(nil, "AOCRP | {A} hat {T} temporr zu {V} umbenannt.", {
                A = calling_ply, T = targets, V = name
        })
        for i = 1, #targets do
            local target = targets[i]
            target:SetCloneName(name)

        end
 


    end)
:End()






sam.command.new("gear")
    :SetPermission("gear") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte den Gear eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("gearauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, gear)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "gearid", gear, function()
                target:SetGearID(gear)
                target:ApplyGear()
            end)
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end


        sam.player.send_message(nil, "AOCRP | {A} hat {T} ins Gear {V} gesetzt.", {
            A = calling_ply, T = targets, V = AOCRP.Gear.Data[tonumber(gear)].name
        })
    end)
:End()

sam.command.new("tempgear")
    :SetPermission("tempgear") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte den Gear eines Spielers temporr")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("gearauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, gear)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            --AOCRP.HUD:CallRankNotify(target, rang)
            target:SetGearID(gear)
            target:ApplyGear()
--[[             AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "rankid", rang, function()
                target:SetRankID(rang)
            end) ]]
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} temporr ins Gear {V} gesetzt.", {
            A = calling_ply, T = targets, V = AOCRP.Gear.Data[tonumber(gear)].name
        })
    end)
:End()


--[[ 
sam.command.new("subunit")
    :SetPermission("subunit") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte die SubUnit eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("subunitauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, unit)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "subunit", unit, function()
                target:SetSubUnitID(unit)
            end)
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} zur Untereinheit {V} versetzt.", {
            A = calling_ply, T = targets, V = AOCRP.SubUnits[tonumber(unit)].name
        })
    end)
:End() ]]


sam.command.new("hidecloneid")
    :SetPermission("hidecloneid") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Verstecke die KlonID eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })


    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            local hide = !target:GetHideCloneID()

            local num = 0
            if hide then
                num = 1
            end

            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "hidecloneid", num, function()
                target:SetHideCloneID(hide)
            end)
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat den Wert 'KlonID-Verstecken' bei {T} umgeschaltet.", {
            A = calling_ply, T = targets
        })
    end)
:End()

sam.command.new("temphidecloneid")
    :SetPermission("temphidecloneid") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Verstecke die KlonID eines Spielers temporr")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })


    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            local hide = !target:GetHideCloneID()

            target:SetHideCloneID(hide)

        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat den Wert 'KlonID-Verstecken' bei {T} temporr umgeschaltet.", {
            A = calling_ply, T = targets
        })
    end)
:End()

sam.command.new("unit")
    :SetPermission("unit") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte die Unit eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("unitauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, unit)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.UnitLog:AddCharPlusUnit(target:GetCloneID(), target:GetUnitID(), target:GetCloneID() .. " wurde durch das ROK aus der Einheit ("..AOCRP.Units[tonumber(unit)].name..") verwiesen.")

            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "unitid", unit, function()
                target:SetUnitID(unit)
                AOCRP.UnitLog:AddCharPlusUnit(target:GetCloneID(), target:GetUnitID(), target:GetCloneID() .. " wurde durch das ROK der Einheit ("..AOCRP.Units[tonumber(unit)].name..") zugewiesen.")
            end)
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} zur {V} versetzt.", {
            A = calling_ply, T = targets, V = AOCRP.Units[tonumber(unit)].name
        })
    end)
:End()

sam.command.new("tempunit")
    :SetPermission("tempunit") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte die Unit eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("unitauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, unit)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            target:SetUnitID(tonumber(unit))
            --target:ChatPrint("Du wurdest befrdert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} zur {V} versetzt.", {
            A = calling_ply, T = targets, V = AOCRP.Units[tonumber(unit)].name
        })
    end)
:End()


sam.command.new("reloadtemp")
    :SetPermission("reloadtemp") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setze alle temporren Sachen auf Standard zurck.")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :OnExecute(function(calling_ply, targets)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            target:ReloadCharacter()
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat die Temporrdaten von {T} zurckgesetzt.", {
            A = calling_ply, T = targets
        })
    end)
:End()

sam.command.new("money")
    :SetPermission("money") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Gebe dem Spieler Geld.")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("number", {
        optional = false,
    })

    :OnExecute(function(calling_ply, targets, amount)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            target:addMoney(amount,"Administrativ gesetzt")

            AOCRP.Misc:LogMoney(calling_ply, target, amount)
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} {V} Credits gegeben/genommen.", {
            A = calling_ply, T = targets, V = amount
        })
    end)
:End()


sam.command.new("xray")
    :SetPermission("xray") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Admin-Xray.")

    :OnExecute(function(calling_ply)
        
        calling_ply:SendLua('LocalPlayer().AdminXray = !LocalPlayer().AdminXray')
 

        sam.player.send_message(nil, "AOCRP | {A} hat sein Admin-Xray aktiviert/deaktiviert.", {
            A = calling_ply
        })
    end)
:End()






sam.command.new("revive")
    :SetPermission("revive") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Revived den Spieler, wenn er Tot ist.")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })


    :OnExecute(function(calling_ply, targets)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            if !target:Alive() then
                AOCRP.Medic:DoRevive(target,nil)
            end
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} wiederbelebt.", {
            A = calling_ply, T = targets
        })
    end)
:End()


--[[ 
local insertObj = mysql:Insert("players");
insertObj:Insert("sid64", self:SteamID64());
insertObj:Insert("lastip", self:IPAddress());
insertObj:Insert("auth", AOCRP.Player:GenerateNewAuthKey())
insertObj:Insert("firstip", self:IPAddress());
insertObj:Callback(function(result, status, lastID)
    self:LoadPlayerData()
end);
insertObj:Execute(); ]]



function GetUnixTimestamp(date, time)
    -- Check if the date and time strings match the expected format
    local date_pattern = "%d+%.%d+%.%d+"
    local time_pattern = "%d+:%d+"
    
    if not string.match(date, date_pattern) or not string.match(time, time_pattern) then
        return nil
    end
    
    -- Split the date string into day, month, and year
    local day, month, year = string.match(date, "(%d+)%.(%d+)%.(%d+)")
    
    -- Split the time string into hours and minutes
    local hours, minutes = string.match(time, "(%d+):(%d+)")
    
    -- Create a table representing the date and time
    local datetime = {
        year = tonumber(year),
        month = tonumber(month),
        day = tonumber(day),
        hour = tonumber(hours),
        min = tonumber(minutes),
        sec = 0
    }
    
    -- Use the os.time function to convert the date and time table to a Unix timestamp
    local timestamp = os.time(datetime)
    
    return timestamp
end


sam.command.new("termin")
    :SetPermission("termin") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Erstelle einen Termin.")
   
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Datum im Format TT.MM.JJJJ"
    })
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Startzeit im Format HH:MM"
    })
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Typ (Event, Mission, Tryout, Training)"
    })
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Titel"
    })
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Beschreibung"
    })

    :OnExecute(function(calling_ply, date,time,typ,title,desc)
        
        local timestamp = GetUnixTimestamp(date, time)

        if timestamp != nil then
            local insertObj = mysql:Insert("events");
            insertObj:Insert("unix", timestamp);
            insertObj:Insert("type", typ);
            insertObj:Insert("name", title)
            insertObj:Insert("description", desc);
            insertObj:Callback(function(result, status, lastID)
                AOCRP:ReloadEvents()

                sam.player.send_message(nil, "AOCRP | {A} hat einen neuen Termin angelegt. ("..title..")", {
                    A = calling_ply
                })
            end);
            insertObj:Execute();
        else 
            calling_ply:ChatPrint("*** Fehlerhafte Eingabe.")
        end


    end)
:End()


sam.command.new("admininfo")
    :SetPermission("admininfo") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Admininfo aufn Screen.")
   


    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Anzuzeigender Text"
    })



    :OnExecute(function(calling_ply, text)

        --AOCRP.HUD:CallNotify(player.GetHumans(), text, Color(255,0,0), "Administrativer Hinweis")
        AOCRP.HUD:Notification(player.GetHumans(), {title="Administrativer Hinweis", text=text, titlecolor=Color(255, 0, 0), sound="everfall/miscellaneous/ux/award/eor_mvpappear_05.mp3"})
        
        sam.player.send_message(nil, "AOCRP | {A} hat eine Admin-Info rausgeschickt", {
            A = calling_ply
        })
    


    end)
:End()



sam.command.new("eventinfo")
    :SetPermission("eventinfo") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Eventinfo aufn Screen.")
   
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Anzuzeigender Text"
    })


    :OnExecute(function(calling_ply, text)

        --AOCRP.HUD:CallNotify(player.GetHumans(), text, Color(0,119,255), "Eventinformation")
        AOCRP.HUD:Notification(player.GetHumans(), {title="Eventinformation", text=text, titlecolor=Color(0, 119, 255), sound="everfall/miscellaneous/ux/award/eor_mvpappear_05.mp3"})

        
        sam.player.send_message(nil, "AOCRP | {A} hat eine Event-Info rausgeschickt", {
            A = calling_ply
        })
    


    end)
:End()




sam.command.new("modinfo")
    :SetPermission("modinfo") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Modinfo aufn Screen.")
   
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Anzuzeigender Text"
    })


    :OnExecute(function(calling_ply, text)

        --AOCRP.HUD:CallNotify(player.GetHumans(), text, Color(0,255,34), "Moderativer Hinweis")
        AOCRP.HUD:Notification(player.GetHumans(), {title="Moderativer Hinweis", text=text, titlecolor=Color(0,255,34), sound="everfall/miscellaneous/ux/award/eor_mvpappear_05.mp3"})
        
        sam.player.send_message(nil, "AOCRP | {A} hat eine Mod-Info rausgeschickt", {
            A = calling_ply
        })
    


    end)
:End()



--addons/admin_sam/lua/sam/modules/chat.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Chat")

command.new("pm")
	:SetPermission("pm", "user")

	:AddArg("player", {allow_higher_target = true, single_target = true, cant_target_self = true})
	:AddArg("text", {hint = "message", check = function(str)
		return str:match("%S") ~= nil
	end})

	:GetRestArgs()

	:Help("pm_help")

	:OnExecute(function(ply, targets, message)
		if ply:sam_get_pdata("unmute_time") then
			return ply:sam_send_message("you_muted")
		end

		local target = targets[1]

		ply:sam_send_message("pm_to", {
			T = targets, V = message
		})

		if ply ~= target then
			target:sam_send_message("pm_from", {
				A = ply, V = message
			})
		end
	end)
:End()

do
	sam.permissions.add("see_admin_chat", nil, "admin")

	local reports_enabled = sam.config.get_updated("Reports", true)
	command.new("asay")
		:SetPermission("asay", "user")

		:AddArg("text", {hint = "message"})
		:GetRestArgs()

		:Help("asay_help")

		:OnExecute(function(ply, message)
			if reports_enabled.value and not ply:HasPermission("see_admin_chat") then
				local success, time = sam.player.report(ply, message)
				if success == false then
					ply:sam_send_message("You need to wait {S Red} seconds.", {
						S = time
					})
				else
					ply:sam_send_message("to_admins", {
						A = ply, V = message
					})
				end
				return
			end

			local targets = {ply}

			local players = player.GetHumans()
			for i = 1, #players do
				local v = players[i]
				if v:HasPermission("see_admin_chat") and v ~= ply then
					table.insert(targets, v)
				end
			end

			sam.player.send_message(targets, "to_admins", {
				A = ply, V = message
			})
		end)
	:End()

	if SERVER then
		sam.hook_last("PlayerSay", "SAM.Chat.Asay", function(ply, text)
			if text:sub(1, 1) == "@" then
				ply:Say("!asay " .. text:sub(2))
				return ""
			end
		end)
	end
end

do
	command.new("mute")
		:SetPermission("mute", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("mute_help")

		:OnExecute(function(ply, targets, length, reason)
			local current_time = SysTime()

			for i = 1, #targets do
				local target = targets[i]
				target:sam_set_pdata("unmute_time", length ~= 0 and (current_time + length * 60) or 0)
			end

			sam.player.send_message(nil, "mute", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unmute")
		:SetPermission("unmute", "admin")
		:AddArg("player", {optional = true})
		:Help("unmute_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:sam_set_pdata("unmute_time", nil)
			end

			sam.player.send_message(nil, "unmute", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		sam.hook_first("PlayerSay", "SAM.Chat.Mute", function(ply, text)
			local unmute_time = ply:sam_get_pdata("unmute_time")
			if not unmute_time then return end

			if text:sub(1, 1) == "!" and text:sub(2, 2):match("%S") ~= nil then
				local args = sam.parse_args(text:sub(2))

				local cmd_name = args[1]
				if not cmd_name then return end

				local cmd = command.get_command(cmd_name)
				if cmd then
					return
				end
			end

			if unmute_time == 0 or unmute_time > SysTime() then
				return ""
			else
				ply:sam_set_pdata("unmute_time", nil)
			end
		end)
	end
end

do
	command.new("gag")
		:SetPermission("gag", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("gag_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = true
				if length ~= 0 then
					timer.Create("SAM.UnGag" .. target:SteamID64(), length * 60, 1, function()
						RunConsoleCommand("sam", "ungag", "#" .. target:EntIndex())
					end)
				end
			end

			sam.player.send_message(nil, "gag", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("ungag")
		:SetPermission("ungag", "admin")

		:AddArg("player", {optional = true})
		:Help("ungag_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = nil
				timer.Remove("SAM.UnGag" .. target:SteamID64())
			end

			sam.player.send_message(nil, "ungag", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("PlayerCanHearPlayersVoice", "SAM.Chat.Gag", function(_, ply)
			if ply.sam_gagged then
				return false
			end
		end)

		hook.Add("PlayerInitialSpawn", "SAM.Gag", function(ply)
			local gag_time = ply:sam_get_pdata("gagged")
			if gag_time then
				ply:sam_set_pdata("gagged", nil)
				RunConsoleCommand("sam", "gag", "#" .. ply:EntIndex(), gag_time / 60, "LTAP")
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Gag", function(ply)
			if ply.sam_gagged then
				ply:sam_set_pdata("gagged", timer.TimeLeft("SAM.UnGag" .. ply:SteamID64()) or 0)
			end
		end)
	end
end
--addons/admin_sam_modules/lua/sam/modules/command_notify_for_ranks.lua:
--
-- Make command notifying only for ranks you select.
-- permission is command_notify. (by default admin+ has it)
-- You can NOT use this with 'command_hide_admin_name.lua'
--
if SAM_LOADED then return end

sam.permissions.add("command_notify", nil, "admin")

if SERVER then
	local get_players = function()
		local players = {}
		for _, v in ipairs(player.GetAll()) do
			if v:HasPermission("command_notify") then
				table.insert(players, v)
			end
		end
		return players
	end

	sam.player.old_send_message = sam.player.old_send_message or sam.player.send_message
	function sam.player.send_message(ply, msg, tbl)
		if ply == nil and debug.traceback():find("lua/sam/command/", 1, true) then
			sam.player.old_send_message(get_players(), msg, tbl)
		else
			sam.player.old_send_message(ply, msg, tbl)
		end
	end
end
--addons/admin_sam/lua/sam/modules/teleport.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Teleport")

local find_empty_pos -- https://github.com/FPtje/DarkRP/blob/b147d6fa32799136665a9fd52d35c2fe87cf7f78/gamemode/modules/base/sv_util.lua#L149
do
	local is_empty = function(vector, ignore)
		local point = util.PointContents(vector)
		local a = point ~= CONTENTS_SOLID
			and point ~= CONTENTS_MOVEABLE
			and point ~= CONTENTS_LADDER
			and point ~= CONTENTS_PLAYERCLIP
			and point ~= CONTENTS_MONSTERCLIP
		if not a then return false end

		local ents_found = ents.FindInSphere(vector, 35)
		for i = 1, #ents_found do
			local v = ents_found[i]
			if (v:IsNPC() or v:IsPlayer() or v:GetClass() == "prop_physics" or v.NotEmptyPos) and v ~= ignore then
				return false
			end
		end

		return true
	end

	local distance, step, area = 600, 30, Vector(16, 16, 64)
	local north_vec, east_vec, up_vec = Vector(0, 0, 0), Vector(0, 0, 0), Vector(0, 0, 0)

	find_empty_pos = function(pos, ignore)
		if is_empty(pos, ignore) and is_empty(pos + area, ignore) then
			return pos
		end

		for j = step, distance, step do
			for i = -1, 1, 2 do
				local k = j * i

				-- North/South
				north_vec.x = k
				if is_empty(pos + north_vec, ignore) and is_empty(pos + north_vec + area, ignore) then
					return pos + north_vec
				end

				-- East/West
				east_vec.y = k
				if is_empty(pos + east_vec, ignore) and is_empty(pos + east_vec + area, ignore) then
					return pos + east_vec
				end

				-- Up/Down
				up_vec.z = k
				if is_empty(pos + up_vec, ignore) and is_empty(pos + up_vec + area, ignore) then
					return pos + up_vec
				end
			end
		end

		return pos
	end
end

command.new("bring")
	:DisallowConsole()
	:SetPermission("bring", "admin")

	:AddArg("player", {cant_target_self = true})

	:Help("bring_help")

	:OnExecute(function(ply, targets)
		if not ply:Alive() then
			return ply:sam_send_message("dead")
		end

		if ply:InVehicle() then
			return ply:sam_send_message("leave_car")
		end

		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		local teleported = {admin = ply}
		local all = targets.input == "*"

		for i = 1, #targets do
			local target = targets[i]

			if target:sam_get_exclusive(ply) then
				if not all then
					ply:sam_send_message(target:sam_get_exclusive(ply))
				end
				continue
			end

			if not target:Alive() then
				target:Spawn()
			end

			target.sam_tele_pos, target.sam_tele_ang = target:GetPos(), target:EyeAngles()

			target:ExitVehicle()
			target:SetVelocity(Vector(0, 0, 0))
			target:SetPos(find_empty_pos(ply:GetPos(), target))
			target:SetEyeAngles((ply:EyePos() - target:EyePos()):Angle())

			table.insert(teleported, target)
		end

		if #teleported > 0 then
			sam.player.send_message(nil, "bring", {
				A = ply, T = teleported
			})
		end
	end)
:End()

command.new("bringetp")
	:DisallowConsole()
	:SetPermission("bringetp", "admin")


	:OnExecute(function(ply)
		if not ply:Alive() then
			return ply:sam_send_message("dead")
		end

		if ply:InVehicle() then
			return ply:sam_send_message("leave_car")
		end

		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		local teleported = {admin = ply}
			
		for k, v in pairs(player.GetAll()) do

			if !v.AOC_ETP then continue end
			local target = v

			if target:sam_get_exclusive(ply) then
				if not all then
					ply:sam_send_message(target:sam_get_exclusive(ply))
				end
				continue
			end

			if not target:Alive() then
				target:Spawn()
			end

			target.sam_tele_pos, target.sam_tele_ang = target:GetPos(), target:EyeAngles()

			target:ExitVehicle()
			target:SetVelocity(Vector(0, 0, 0))
			target:SetPos(find_empty_pos(ply:GetPos(), target))
			target:SetEyeAngles((ply:EyePos() - target:EyePos()):Angle())
			target.AOC_ETP = false

			table.insert(teleported, target)
		end

		if #teleported > 0 then
			sam.player.send_message(nil, "bring", {
				A = ply, T = teleported
			})
		end
	end)
:End()

command.new("goto")
	:DisallowConsole()
	:SetPermission("goto", "admin")

	:AddArg("player", {single_target = true, allow_higher_target = true, cant_target_self = true})

	:Help("goto_help")

	:OnExecute(function(ply, targets)
		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		if not ply:Alive() then
			ply:Spawn()
		end

		local target = targets[1]
		ply.sam_tele_pos, ply.sam_tele_ang = ply:GetPos(), ply:EyeAngles()

		ply:ExitVehicle()
		ply:SetVelocity(Vector(0, 0, 0))
		ply:SetPos(find_empty_pos(target:GetPos(), ply))
		ply:SetEyeAngles((target:EyePos() - ply:EyePos()):Angle())

		sam.player.send_message(nil, "goto", {
			A = ply, T = targets
		})
	end)
:End()

command.new("return")
	:SetPermission("return", "admin")

	:AddArg("player", {single_target = true, optional = true})

	:Help("return_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		local last_pos, last_ang = target.sam_tele_pos, target.sam_tele_ang
		if not last_pos then
			return sam.player.send_message(ply, "no_location", {
				T = targets
			})
		end

		if target:sam_get_exclusive(ply) then
			return ply:sam_send_message(target:sam_get_exclusive(ply))
		end

		if not target:Alive() then
			return ply:sam_send_message(target:Name() .. " is dead!")
		end

		target:ExitVehicle()
		target:SetVelocity(Vector(0, 0, 0))
		target:SetPos(last_pos)
		target:SetEyeAngles(last_ang)

		target.sam_tele_pos, target.sam_tele_ang = nil, nil

		sam.player.send_message(nil, "returned", {
			A = ply, T = targets
		})
	end)
:End()
--addons/admin_sam/lua/sam/modules/user.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("User Management")

command.new("setrank")
	:Aliases("adduser", "changerank", "giverank")

	:SetPermission("setrank")

	:AddArg("player", {single_target = true})
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrank_help")

	:OnExecute(function(ply, targets, rank, length)
		targets[1]:sam_set_rank(rank, length)

		sam.player.send_message(nil, "setrank", {
			A = ply, T = targets, V = rank, V_2 = sam.format_length(length)
		})
	end)
:End()

command.new("setrankid")
	:Aliases("adduserid", "changerankid", "giverankid")

	:SetPermission("setrankid")

	:AddArg("steamid")
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrankid_help")

	:OnExecute(function(ply, promise, rank, length)
		local a_name = ply:Name()

		promise:done(function(data)
			local steamid, target = data[1], data[2]
			if target then
				target:sam_set_rank(rank, length)

				sam.player.send_message(nil, "setrank", {
					A = ply, T = {target, admin = ply}, V = rank, V_2 = sam.format_length(length)
				})
			else
				sam.player.set_rank_id(steamid, rank, length)

				sam.player.send_message(nil, "setrank", {
					A = a_name, T = steamid, V = rank, V_2 = sam.format_length(length)
				})
			end
		end)
	end)
:End()

command.new("addrank")
	:SetPermission("manage_ranks")

	:AddArg("text", {hint = "rank name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})
	:AddArg("rank", {hint = "inherit from"})
	:AddArg("number", {hint = "immunity", min = 2, max = 99, optional = true})
	:AddArg("length", {hint = "ban limit", optional = true})

	:Help("addrank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit, immunity, ban_limit)
		sam.ranks.add_rank(rank, inherit, immunity, ban_limit)

		sam.player.send_message(nil, "addrank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("removerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})

	:Help("removerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank)
		sam.ranks.remove_rank(rank)

		sam.player.send_message(nil, "removerank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("renamerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})
	:AddArg("text", {hint = "new name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})

	:Help("renamerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_name)
		sam.ranks.rename_rank(rank, new_name)

		sam.player.send_message(nil, "renamerank", {
			A = ply, T = rank, V = new_name
		})
	end)
:End()

command.new("changeinherit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("rank", {hint = "inherits from"})

	:Help("changeinherit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit)
		if rank == inherit then return end

		sam.ranks.change_inherit(rank, inherit)

		sam.player.send_message(nil, "changeinherit", {
			A = ply, T = rank, V = inherit
		})
	end)
:End()

command.new("changerankimmunity")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("number", {hint = "new immunity", min = 2, max = 99})

	:Help("changerankimmunity_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_immunity)
		sam.ranks.change_immunity(rank, new_immunity)

		sam.player.send_message(nil, "rank_immunity", {
			A = ply, T = rank, V = new_immunity
		})
	end)
:End()

command.new("changerankbanlimit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "superadmin"
	end})
	:AddArg("length")

	:Help("changerankbanlimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_limit)
		sam.ranks.change_ban_limit(rank, new_limit)

		sam.player.send_message(nil, "rank_ban_limit", {
			A = ply, T = rank, V = sam.format_length(new_limit)
		})
	end)
:End()

command.new("givepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("givepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.give_permission(rank, permission)

		sam.player.send_message(nil, "giveaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("takepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("takepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.take_permission(rank, permission)

		sam.player.send_message(nil, "takeaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("changeranklimit")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "limit"})
	:AddArg("number", {hint = "value"})

	:Help("changeranklimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, limit, value)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.set_limit(rank, limit, value)

		sam.player.send_message(nil, "changeranklimit", {
			A = ply, T = rank, V = limit, V_2 = value
		})
	end)
:End()
--addons/aocrp_pixelui/lua/pixelui/elements/cl_color_picker.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

local gradientMat = Material("nil")
PIXEL.GetImgur("i0xcO1R", function(mat)
    gradientMat = mat
end)

local colorWheelMat = Material("nil")
PIXEL.GetImgur("k5mtok6", function(mat)
    colorWheelMat = mat
end)

local pickerMat = Material("nil")
PIXEL.GetImgur("t0k86qy", function(mat)
    pickerMat = mat
end)

function PANEL:Init()
    self.Hue = 0
    self.SmoothHue = 0

    self.Lightness = 0
    self.Saturation = 0

    self.TriX = 0
    self.TriY = 0

    self:UpdateColor()
    self:UpdatePositions()
end

function PANEL:OnChange(color) end

function PANEL:UpdateColor()
    self.Color = PIXEL.HSLToColor(self.Hue, self.Saturation, self.Lightness)
    self:OnChange(self.Color)
end

function PANEL:SetColor(color)
    local h, s, l = ColorToHSL(color)
    h = h / (360 / 5)
    self.Hue = h
    self.Saturation = s
    self.Lightness = l

    self.Color = color
    self:OnChange(color)

    self:UpdatePositions()
end

function PANEL:UpdatePositions()
    local hue = self.Hue
    local third = (2 / 3) * math.pi
    local sat = self.Saturation
    local light = 1 - self.Lightness

    local hX = math.cos(hue)
    local hY = math.sin(hue)
    local sX = math.cos(hue - third)
    local sY = math.sin(hue - third)
    local vX = math.cos(hue + third)
    local vY = math.sin(hue + third)

    local mX = (sX + vX) / 2
    local mY = (sY + vY) / 2
    local a = (1 - 2 * math.abs(light - 0.5)) * sat

    self.TriX = sX + (vX - sX) * light + (hX - mX) * a
    self.TriY = sY + (vY - sY) * light + (hY - mY) * a
end

function PANEL:Think()
    local cursorX, cursorY = self:CursorPos()
    local cX, cY = self:GetCenter()
    local triangleRadius = self:GetTriangleRadius()

    if not self.Pressed then return end

    local diffX = cursorX - cX
    local diffY = cursorY - cY
    local rad = math.atan2(diffY, diffX)

    if rad < 0 then
        rad = rad + (2 * math.pi)
    end

    if self.PressedWheel then
        self.Hue = rad
        self:UpdatePositions()
        self:UpdateColor()
        return
    end

    local rad0 = (rad + 2 * math.pi - self.Hue) % (2 * math.pi)
    local rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
    local a = 0.5 * triangleRadius
    local b = math.tan(rad1) * a
    local r = math.sqrt(diffX * diffX + diffY * diffY)
    local maxR = math.sqrt(a * a + b * b)

    if r > maxR then
        local dx = math.tan(rad1) * r
        local rad2 = math.Clamp(math.atan(dx / maxR), -math.pi / 3, math.pi / 3)
        rad = rad + (rad2 - rad1)
        rad0 = (rad + 2 * math.pi - self.Hue) % (2 * math.pi)
        rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
        b = math.tan(rad1) * a
        maxR = math.sqrt(a * a + b * b)
        r = maxR
    end

    self.TriX = math.cos(rad) * r / triangleRadius
    self.TriY = math.sin(rad) * r / triangleRadius

    local triangleSideLen = math.sqrt(3) * triangleRadius
    local light = ((math.sin(rad0) * r) / triangleSideLen) + 0.5
    local widthShare = 1.0 - math.abs(light - 0.5) * 2.0
    local saturation = (((math.cos(rad0) * r) + (triangleRadius / 2)) / (1.5 * triangleRadius)) / widthShare
    saturation = math.Clamp(saturation, 0, 1)

    self.Lightness = 1 - light
    self.Saturation = saturation

    self:UpdateColor()
end

function PANEL:OnMousePressed()
    self:MouseCapture(true)
    self.Pressed = true

    local cX, cY = self:GetCenter()
    local cursorX, cursorY = self:CursorPos()
    local cursor = Vector(cursorX, cursorY)
    local center = Vector(cX, cY, 0)

    if cursor:Distance(center) > self:GetTriangleRadius() then
        self.PressedWheel = true
        return
    end

    self.PressedTriangle = true
end

function PANEL:OnMouseReleased()
    self:MouseCapture(false)
    self.Pressed = false
    self.PressedWheel = false
    self.PressedTriangle = false
end

function PANEL:GetCenter()
    return self:GetWide() / 2, self:GetTall() / 2
end

function PANEL:GetRadius()
    return self:GetTall() / 2
end

function PANEL:GetTriangleRadius()
    return self:GetRadius() * 0.7
end

function PANEL:GetRingThickness()
    return self:GetRadius() * 0.2
end

function PANEL:GetHueColor()
    return PIXEL.HSLToColor(self.Hue, 1, 0.5)
end

local whiteTexture = surface.GetTextureID("vgui/white")
function PANEL:Paint(w, h)
    local cX, cY = self:GetCenter()
    local radius = self:GetRadius()
    local triangleRadius = self:GetTriangleRadius()

    surface.SetTexture(whiteTexture)

    local triangleAng = self.Hue
    local triangleOff = math.pi * 2 / 3
    local vertices = {
        {
            x = cX + math.cos(triangleAng - triangleOff) * triangleRadius,
            y = cY + math.sin(triangleAng - triangleOff) * triangleRadius,
            u = 0.5,
            v = 0.99
        },
        {
            x = cX + math.cos(triangleAng) * triangleRadius,
            y = cY + math.sin(triangleAng) * triangleRadius,
            u = 0.99,
            v = 0.01
        },
        {
            x = cX + math.cos(triangleAng + triangleOff * 1) * triangleRadius,
            y = cY + math.sin(triangleAng + triangleOff * 1) * triangleRadius,
            u = 0.01,
            v = 0.01
        }
    }

    local col = self:GetHueColor()
    surface.SetDrawColor(col)
    surface.DrawPoly(vertices)

    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(gradientMat)
    surface.DrawPoly(vertices)
    surface.DrawPoly(vertices)

    vertices[1].u = 0.99
    vertices[1].v = 0.01

    vertices[2].u = 0.01
    vertices[2].v = 0.01

    vertices[3].u = 0.5
    vertices[3].v = 0.99

    surface.SetDrawColor(0, 0, 0, 255)
    surface.SetMaterial(gradientMat)
    surface.DrawPoly(vertices)

    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(colorWheelMat)
    surface.DrawTexturedRect(cX - radius, cY - radius, radius * 2, radius * 2)

    local pickerSize = PIXEL.Scale(5)
    local pickerVerts = {
        {
            x = cX + self.TriX * triangleRadius + pickerSize,
            y = cY + self.TriY * triangleRadius + pickerSize,
            u = 1,
            v = 1
        },
        {
            x = cX + self.TriX * triangleRadius - PIXEL.Scale(5),
            y = cY + self.TriY * triangleRadius + PIXEL.Scale(5),
            u = 0,
            v = 1
        },
        {
            x = cX + self.TriX * triangleRadius - PIXEL.Scale(5),
            y = cY + self.TriY * triangleRadius - PIXEL.Scale(5),
            u = 0,
            v = 0
        },
        {
            x = cX + self.TriX * triangleRadius + pickerSize,
            y = cY + self.TriY * triangleRadius - pickerSize,
            u = 1,
            v = 0
        }
    }

    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(pickerMat)
    surface.DrawPoly(pickerVerts)

    local hpX = cX + math.cos(self.Hue) * (radius - self:GetRingThickness() / 2)
    local hpY = cY + math.sin(self.Hue) * (radius - self:GetRingThickness() / 2)
    local size = PIXEL.Scale(16)
    local huePickerVerts = {
        {
            x = hpX + size / 2,
            y = hpY + size / 2,
            u = 1,
            v = 1
        },
        {
            x = hpX - size / 2,
            y = hpY + size / 2,
            u = 0,
            v = 1
        },
        {
            x = hpX - size / 2,
            y = hpY - size / 2,
            u = 0,
            v = 0
        },
        {
            x = hpX + size / 2,
            y = hpY - size / 2,
            u = 1,
            v = 0
        }
    }
    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(pickerMat)
    surface.DrawPoly(huePickerVerts)
end

vgui.Register("PIXEL.ColorPicker", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/menus/cl_message_popup.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "ButtonText", "ButtonText", FORCE_STRING)

PIXEL.RegisterFont("UI.Message", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetDraggable(true)
    self:SetSizable(true)

    self:SetMinWidth(PIXEL.Scale(240))
    self:SetMinHeight(PIXEL.Scale(80))

    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetTextAlign(TEXT_ALIGN_CENTER)
    self.Message:SetFont("UI.Message")

    self.ButtonHolder = vgui.Create("Panel", self)

    self.Button = vgui.Create("PIXEL.TextButton", self.ButtonHolder)
    self.Button.DoClick = function(s, w, h)
        self:Close(true)
    end
end

function PANEL:LayoutContent(w, h)
    self.Message:SetSize(self.Message:CalculateSize())
    self.Message:Dock(TOP)
    self.Message:DockMargin(0, 0, 0, PIXEL.Scale(8))

    self.Button:SizeToText()
    self.ButtonHolder:Dock(TOP)
    self.ButtonHolder:SetTall(self.Button:GetTall())
    self.Button:CenterHorizontal()

    if self.ButtonHolder:GetWide() < self.Button:GetWide() then
        self.ButtonHolder:SetWide(self.Button:GetWide())
    end

    if self:GetWide() < PIXEL.Scale(240) then
        self:SetWide(PIXEL.Scale(240))
        self:Center()
    end

    if self.HasSized and self.HasSized > 1 then return end
    self.HasSized = (self.HasSized or 0) + 1

    self:SizeToChildren(true, true)
    self:Center()
end

function PANEL:SetText(text) self.Message:SetText(text) end
function PANEL:GetText(text) return self.Message:GetText() end

function PANEL:SetButtonText(text) self.Button:SetText(text) end
function PANEL:GetButtonText(text) return self.Button:GetText() end

vgui.Register("PIXEL.Message", PANEL, "PIXEL.Frame")

PIXEL.UI.Overrides.Derma_Message = PIXEL.UI.Overrides.Derma_Message or Derma_Message

Derma_Message = PIXEL.UI.CreateToggleableOverride(PIXEL.UI.Overrides.Derma_Message, function(text, title, buttonText)
    buttonText = buttonText or "OK"

    local msg = vgui.Create("PIXEL.Message")
    msg:SetTitle(title)
    msg:SetText(text)
    msg:SetButtonText(buttonText)

    msg:MakePopup()
    msg:DoModal()

    return msg
end, PIXEL.UI.ShouldOverrideDermaPopups)
--addons/sit_everywhere/lua/sitanywhere/ground_sit.lua:
SitAnywhere = SitAnywhere or {}
SitAnywhere.GroundSit = true
local TAG = "SitAnyG_"

hook.Add("SetupMove", TAG .. "SetupMove", function(ply, mv)
	local butts = mv:GetButtons()

	if not ply:GetNWBool(TAG) then
		return
	end

	local getUp = bit.band(butts, IN_JUMP) == IN_JUMP or ply:GetMoveType() ~= MOVETYPE_WALK or ply:InVehicle() or not ply:Alive()

	if getUp then
		ply:SetNWBool(TAG, false)
	end

	local move = bit.band(butts, IN_DUCK) == IN_DUCK

	butts = bit.bxor(bit.bor(butts, bit.bor(IN_JUMP, IN_DUCK)), IN_JUMP)

	if move then
		butts =  bit.bxor(bit.bor(bit.bor(butts, IN_WALK), IN_SPEED), IN_SPEED)

		mv:SetButtons(butts)
		return
	end

	mv:SetButtons(butts)
	mv:SetSideSpeed(0)
	mv:SetForwardSpeed(0)
	mv:SetUpSpeed(0)
end)

hook.Add("CalcMainActivity", TAG .. "CalcMainActivity", function(ply, vel)
	local seq = ply:LookupSequence("pose_ducking_02")
	if ply:GetNWBool(TAG) and seq and vel:Length2DSqr() < 1 then
		return ACT_MP_SWIM, seq
	else
		return
	end
end)


if SERVER then
	local AllowGroundSit = CreateConVar("sitting_allow_ground_sit", "1", {FCVAR_ARCHIVE}, "Allows people to sit on the ground on your server", 0, 1)
	hook.Add("HandleSit", "GroundSit", function(ply, dists, EyeTrace)
		if #dists == 0 and ply:GetInfoNum("sitting_ground_sit", 1) == 1 and AllowGroundSit:GetBool() and ply:EyeAngles().p > 80 then
			local t = hook.Run("OnGroundSit", ply, EyeTrace)
			if t == false then
				return
			end

			if not ply:GetNWBool(TAG) then
				ply:SetNWBool(TAG, true)
				ply.LastSit = CurTime() + 1
				return true
			end
		end
	end)

	concommand.Add("ground_sit", function(ply)
		if AllowGroundSit:GetBool() and (not ply.LastSit or ply.LastSit < CurTime()) then
			ply:SetNWBool(TAG, not ply:GetNWBool(TAG))
			ply.LastSit = CurTime() + 1
		end
	end)
else
	CreateClientConVar("sitting_ground_sit", "1.00", true, true, "Toggles the ability for you to sit on the ground", 0, 1)
end

--addons/sse_101/lua/autorun/sw_ent_pack.lua:
AddCSLuaFile()

SSE = {}
SSE.Config = {}
SSE.Version = "1.0.6"



if CLIENT then
    include("sse/cl_lib.lua")
    include("sse/sh_sse_config.lua")
    SSE.Imgui = include("sse/cl_imgui.lua")

end

if SERVER then
    AddCSLuaFile("sse/cl_lib.lua")
    AddCSLuaFile("sse/sh_sse_config.lua")
    AddCSLuaFile("sse/cl_imgui.lua")

    include("sse/sh_sse_config.lua")


    resource.AddFile("resource/fonts/agencyfb.ttf")
end


function SSE:AntiSpam(ply)

    if !IsValid(ply) then return end

    if ply.SSE_LastUse == nil then ply.SSE_LastUse = 0 end

    if ply.SSE_LastUse > CurTime() then ply:ChatPrint("*** "..SSE.Config.AntiSpamText) print("AntispamTrue") return true end

    ply.SSE_LastUse = CurTime() + SSE.Config.AntiSpamTime
    print("AntispamFalse")
    return false

end

--addons/tools/lua/autorun/textscreens_util.lua:
local function checkAdmin(ply)
	-- The server console always has access. `ply` is NULL in this case
	local isConsole = ply == nil or ply == NULL
	if isConsole then
		return true
	end
	local canAdmin = hook.Run("TextscreensCanAdmin", ply) -- run custom hook function to check admin
	if canAdmin == nil then -- if hook hasn't returned anything, default to super admin check
		canAdmin = ply:IsSuperAdmin()
	end
	return canAdmin
end

-- allow servers to disable rainbow effect for everyone
CreateConVar("ss_enable_rainbow", 1, {FCVAR_NOTIFY, FCVAR_REPLICATED}, "Determines whether rainbow textscreens will render for all clients. When disabled, rainbow screens will render as solid white.", 0, 1)

-- allow servers to restrict the number of characters per line for everyone
CreateConVar("ss_max_characters", 0, {FCVAR_NOTIFY, FCVAR_REPLICATED}, "Determines the maximum number of characters per line for all clients. When set to 0, the maximum number of characters is infinite.", 0)

if SERVER then
	AddCSLuaFile()
	AddCSLuaFile("textscreens_config.lua")
	include("textscreens_config.lua")
	CreateConVar("sbox_maxtextscreens", "1", {FCVAR_NOTIFY, FCVAR_REPLICATED}, "Determines the maximum number of textscreens users can spawn.")
	CreateConVar("ss_call_to_home", 0, {FCVAR_NOTIFY, FCVAR_REPLICATED}, "Determines whether anonymous usage analytics can be sent to the addon author.", 0, 1)

	--local rainbow_enabled = cvars.Number('ss_enable_rainbow', 1)

	local version = "1.20.1"

	local function GetOS()
		if system.IsLinux() then return "linux" end
		if system.IsWindows() then return "windows" end
		if system.IsOSX() then return "osx" end
		return "unknown"
	end

	local submitted = false
	local function submitAnalytics()
		if GetConVar("ss_call_to_home"):GetInt() ~= 1 or submitted then return end

		submitted = true
		http.Post("https://jross.me/textscreens/analytics.php", {
			["operating_system"] = GetOS(),
			["server_dedicated"] = game.IsDedicated() and "true" or "false",
			["server_name"] = GetHostName(),
			["server_ip"] = util.CRC(game.GetIPAddress()),
			["version"] = version
		})
	end

	-- Set ss_call_to_home to 1 to opt-in to anonymous stat tracking
	-- These won't be used for anything other than putting a smile on my face :)
	hook.Add("Initialize", "CallToHomeSS", function()
		timer.Simple(15, function()
			submitAnalytics()
		end)
	end)

	cvars.AddChangeCallback("ss_call_to_home", function(convar_name, value_old, value_new)
		if value_new == "1" then
			submitAnalytics()
		end
	end)

	local function StringRandom(int)
		math.randomseed(os.time())
		local s = ""

		for i = 1, int do
			s = s .. string.char(math.random(65, 90))
		end

		return s
	end

	local textscreens = {}

	local function SpawnPermaTextscreens()
		print("[3D2D Textscreens] Spawning textscreens...")
		textscreens = file.Read("sammyservers_textscreens.txt", "DATA")
		if not textscreens or textscreens == "" then
			textscreens = {}
			print("[3D2D Textscreens] Spawned 0 textscreens for map " .. game.GetMap())
			return
		end
		textscreens = util.JSONToTable(textscreens)

		local existingTextscreens = {}
		for k,v in pairs(ents.FindByClass("sammyservers_textscreen")) do
			if not v.uniqueName then continue end
			existingTextscreens[v.uniqueName] = true
		end

		local count = 0
		for k, v in pairs(textscreens) do
			if v.MapName ~= game.GetMap() then continue end
			if existingTextscreens[v.uniqueName] then continue end

			local textScreen = ents.Create("sammyservers_textscreen")
			textScreen:SetPos(Vector(v.posx, v.posy, v.posz))
			textScreen:SetAngles(Angle(v.angp, v.angy, v.angr))
			textScreen.uniqueName = v.uniqueName
			textScreen:Spawn()
			textScreen:Activate()
			textScreen:SetMoveType(MOVETYPE_NONE)

			for lineNum, lineData in pairs(v.lines or {}) do
				textScreen:SetLine(lineNum, lineData.text, Color(lineData.color.r, lineData.color.g, lineData.color.b, lineData.color.a), lineData.size, lineData.font, lineData.rainbow or 0)
			end

			textScreen:SetIsPersisted(true)
			count = count + 1
		end

		print("[3D2D Textscreens] Spawned " .. count .. " textscreens for map " .. game.GetMap())
	end

	hook.Add("InitPostEntity", "loadTextScreens", function()
		timer.Simple(10, SpawnPermaTextscreens)
	end)

	hook.Add("PostCleanupMap", "loadTextScreens", SpawnPermaTextscreens)

	-- If a player, use ChatPrint method, else print directly to server console
	local function printMessage(ply, msg)
		local isConsole = ply == nil or ply == NULL
		if isConsole then
			print(msg)
		else
			ply:ChatPrint(msg)
		end
	end
	concommand.Add("SS_TextScreen", function(ply, cmd, args)
		if not checkAdmin(ply) or not args or not args[1] or not args[2] or not (args[1] == "delete" or args[1] == "add") then
			printMessage(ply, "not authorised, or bad arguments")
			return
		end
		local ent = Entity(args[2])
		if not IsValid(ent) or ent:GetClass() ~= "sammyservers_textscreen" then return false end

		if args[1] == "add" then
			local pos = ent:GetPos()
			local ang = ent:GetAngles()
			local toAdd = {}
			toAdd.posx = pos.x
			toAdd.posy = pos.y
			toAdd.posz = pos.z
			toAdd.angp = ang.p
			toAdd.angy = ang.y
			toAdd.angr = ang.r
			-- So we can reference it easily later because EntIndexes are so unreliable
			toAdd.uniqueName = StringRandom(10)
			toAdd.MapName = game.GetMap()
			toAdd.lines = ent.lines
			table.insert(textscreens, toAdd)
			file.Write("sammyservers_textscreens.txt", util.TableToJSON(textscreens))
			ent:SetIsPersisted(true)

			return printMessage(ply, "Textscreen made permanent and saved.")
		else
			for k, v in pairs(textscreens) do
				if v.uniqueName == ent.uniqueName then
					textscreens[k] = nil
				end
			end

			ent:Remove()
			file.Write("sammyservers_textscreens.txt", util.TableToJSON(textscreens))

			return printMessage(ply, "Textscreen removed and is no longer permanent.")
		end
	end)

	-- Add to pocket blacklist for DarkRP
	-- Not using gamemode == "darkrp" because there are lots of flavours of darkrp
	hook.Add("loadCustomDarkRPItems", "sammyservers_pocket_blacklist", function()
		GAMEMODE.Config.PocketBlacklist["sammyservers_textscreen"] = true
	end)
end

if CLIENT then
	include("textscreens_config.lua")

	properties.Add("addPermaScreen", {
		MenuLabel = "Make perma textscreen",
		Order = 2001,
		MenuIcon = "icon16/transmit.png",
		Filter = function(self, ent, ply)
			if not IsValid(ent) or ent:GetClass() ~= "sammyservers_textscreen" then return false end
			if ent:GetIsPersisted() then return false end

			return checkAdmin(ply)
		end,
		Action = function(self, ent)
			if not IsValid(ent) then return false end

			return RunConsoleCommand("SS_TextScreen", "add", ent:EntIndex())
		end
	})

	properties.Add("removePermaScreen", {
		MenuLabel = "Remove perma textscreen",
		Order = 2002,
		MenuIcon = "icon16/transmit_delete.png",
		Filter = function(self, ent, ply)
			if not IsValid(ent) or ent:GetClass() ~= "sammyservers_textscreen" then return false end
			if not ent:GetIsPersisted() then return false end

			return checkAdmin(ply)
		end,
		Action = function(self, ent)
			if not IsValid(ent) then return end

			return RunConsoleCommand("SS_TextScreen", "delete", ent:EntIndex())
		end
	})
end

--addons/vyhub-gmod/lua/vyhub/shared/sh_01_config.lua:
-- DEFAULTS
VyHub.Config.date_format = VyHub.Config.date_format or "%Y-%m-%d %H:%M:%S %z"

if SERVER then
    VyHub.Config.advert_interval = VyHub.Config.advert_interval or 180 
    VyHub.Config.advert_prefix = VyHub.Config.advert_prefix or "[] " 

    -- Do not allow too small refresh intervals
    if VyHub.Config.player_refresh_time < 5 then
        VyHub.Config.player_refresh_time = 5
    end
    if VyHub.Config.group_refresh_time < 5 then
        VyHub.Config.group_refresh_time = 5
    end

    VyHub.Config.ban_message = VyHub.Config.ban_message or ">>> Ban Message <<<" .. "\n\n"
    .. VyHub.lang.other.reason .. ": %reason%" .. "\n" 
    .. VyHub.lang.other.ban_date .. ": %ban_date%" .. "\n" 
    .. VyHub.lang.other.unban_date .. ": %unban_date%" .. "\n" 
    .. VyHub.lang.other.admin .. ": %admin%" .. "\n" 
    .. VyHub.lang.other.id .. ": %id%" .. "\n\n" 
    .. VyHub.lang.other.unban_url .. ": %unban_url%" .. "\n\n" 

    VyHub.Config.commands_shop = VyHub.Config.commands_shop or { '!shop' }
    VyHub.Config.commands_bans = VyHub.Config.commands_bans or { '!bans' }
    VyHub.Config.commands_warnings = VyHub.Config.commands_warnings or { '!warnings' }
    VyHub.Config.commands_news = VyHub.Config.commands_news or { '!news' }
    VyHub.Config.commands_profile = VyHub.Config.commands_profile or { '!user' }
    VyHub.Config.commands_warn = VyHub.Config.commands_warn or { '!warn' }
    VyHub.Config.commands_dashboard = VyHub.Config.commands_dashboard or { '!dashboard' }

    VyHub.Config.strict_group_sync = VyHub.Config.strict_group_sync or false
end

--addons/vyhub-gmod/lua/vyhub/client/cl_dashboard.lua:
local f = string.format

VyHub.Dashboard = VyHub.Dashboard or {}

VyHub.Dashboard.ui = VyHub.Dashboard.ui or nil

VyHub.Dashboard.html_ready = false
VyHub.Dashboard.html_generated = VyHub.Dashboard.html_generated or false

local dashboard_html = dashboard_html or "Loading, please try again. If this does not help, please ask the server owner to check for errors in the server console. In most cases, vyhub-gmod has not been downloaded correctly and is missing files."

function VyHub.Dashboard:create_ui()
	VyHub.Dashboard.html_ready = false

	local xsize = ScrW() - ScrW()/4
	local ysize = ScrH() - ScrH()/4
	local xpos  = ScrW()/2 - xsize/2
	local ypos  = ScrH()/2 - ysize/2
	local title = "VyHub Server-Dashboard"
	local box_color = Color(94, 0, 0, 255)

	VyHub.Dashboard.ui = vgui.Create("DFrame")
	VyHub.Dashboard.ui:SetSize(xsize, ysize)
	VyHub.Dashboard.ui:SetPos(xpos, ypos)
	VyHub.Dashboard.ui:SetDraggable(true)
	VyHub.Dashboard.ui:SetTitle(title)
	VyHub.Dashboard.ui:SetDeleteOnClose(false)
	function VyHub.Dashboard.ui.Paint(self, w, h)
		surface.SetDrawColor(box_color)
		surface.DrawRect(0, 0, w, 24)
	end

	VyHub.Dashboard.ui_html = vgui.Create("DHTML", VyHub.Dashboard.ui)
	VyHub.Dashboard.ui_html:SetSize(xsize, ysize - 24)
	VyHub.Dashboard.ui_html:SetPos(0, 24)
	VyHub.Dashboard.ui_html:SetHTML(dashboard_html)

	function VyHub.Dashboard.ui_html:OnDocumentReady()
		MsgN("VyHub Dashboard: HTML Loaded")
		VyHub.Dashboard.html_ready = true
		VyHub.Dashboard.ui_html:RunJavascript('local_steamid64 = ' .. LocalPlayer():SteamID64())
	end

	VyHub.Dashboard.ui_html:AddFunction("vyhub", "warning_toggle", function (warning_id)
		LocalPlayer():ConCommand(f("vh_warning_toggle %s", warning_id))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "warning_delete", function (warning_id)
		LocalPlayer():ConCommand(f("vh_warning_delete %s", warning_id))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "ban_set_status", function (ban_id, status)
		LocalPlayer():ConCommand(f("vh_ban_set_status %s %s", ban_id, status))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "warning_create", function (steamid, reason)
		LocalPlayer():ConCommand(f('vh_warn %s "%s"', steamid, VyHub.Util:escape_concommand_str(reason)))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "ban_create", function (steamid, minutes, reason)
		LocalPlayer():ConCommand(f('vh_ban %s "%s" "%s"', steamid, minutes, VyHub.Util:escape_concommand_str(reason)))
	end)
end

function VyHub.Dashboard:load_html()
	VyHub.Dashboard.html_generated = true
	dashboard_html = [[
		<html>
			<head>
				<meta charset="utf-8">
				<meta name="viewport" content="width=device-width, initial-scale=1">

				<link rel="stylesheet" href="http://cdn.vyhub.net/assets/roboto-v30-latin/roboto-v30-latin.css">
				<link rel="stylesheet" href="http://cdn.vyhub.net/assets/font-awesome-4.7.0/css/font-awesome.min.css">
				<link rel="stylesheet" href="http://cdn.vyhub.net/assets/bootswatch-darkly.min.css">

				<style>
					::selection {
						background: #b5b5b5; /* WebKit/Blink Browsers */
					}

					body{
						overflow-x: hidden;
						overflow-y: scroll;
						font-family: Roboto !important;
					}

					.vh-input {
						background-color: #303030; 
						color: white; 
						height: 30px;
					}

					.nav-pills .active {
						background-color: #303030;
						font-weight: bold;
						margin-left: 4px;
					}

					.user-tab {
						padding: 3px 6px 3px 6px;
						border-radius: 8px;
						text-overflow: ellipsis;
						overflow:hidden; 
					}

					#user_name {
						width: 50%;
						text-overflow: ellipsis;
						overflow: hidden;
					}
				</style>
			</head>
			<body>	
				<div class="row" style="margin: 10px">
					<div class="col-xs-4 col-lg-3">
						<div class="input-group">
							<div class="input-group-addon"><i class="fa fa-search"></i></div>
							<input style="height: 40px;" id="user_search" type="text" class="form-control vh-input" onclick="$('#user_search').val(''); generate_user_list();" onkeyup="generate_user_list()" >
						</div>
						<br/>
						<ul class="nav nav-pills nav-stacked" id="user_list">

						</ul>
					</div>
					<div class="col-xs-8 col-lg-9">
						<div id="user_content_empty">
							]] .. VyHub.lang.dashboard.select_user .. [[
						</div>
						<div class="tab-content" id="user_content" style="display: none;">
							<h3 style="margin: 5px 0px 0px 0;">
								<div class="row">
									<div class="col-xs-9">
										<span id="user_name">
											<span class="label label-default" style="background-color: #5E0000; border-radius: .25em 0 0 .25em;">
												<i class="fa fa-user"></i> &nbsp;<span id="user_content_name"></span>
											</span>
											<span class="label label-default" style="border-radius: 0 .25em .25em 0;">
												<span id="user_content_username"></span>
											</span>
										</span>
									</div>
									<div class="col-xs-3">
										<span id="user_memberships" class="pull-right">
										</span>
									</div>
								</div>
							</h3>

							<hr/>

							<h4><span class="label label-default"><i class="fa fa-exclamation-triangle"></i> &nbsp;]] .. VyHub.lang.other.warnings .. [[</span></h3>

							<div class="row perm-warning_edit">
								<div class="col-xs-10">
									<input id="user_warn" type="text" class="form-control vh-input" onclick="$('#user_warn').val('');" placeholder="]] .. VyHub.lang.other.reason .. [[" />
								</div>
								<div class="col-xs-2" style="padding-left: 0;">
									<button style="height: 30px;" onclick="create_warning()" class="btn btn-warning btn-xs btn-block"><i class="fa fa-exclamation-triangle"></i> &nbsp; ]] .. VyHub.lang.dashboard.action_warn .. [[</button>
								</div>
							</div>

							<br/>

							<table class="table table-condensed table-hover">
								<tr>
									<th width="10px"></th>
									<th>]] .. VyHub.lang.other.reason .. [[</th>
									<th>]] .. VyHub.lang.other.admin .. [[</th>
									<th>]] .. VyHub.lang.other.date .. [[</th>
									<th class="text-right">]] .. VyHub.lang.other.actions .. [[</th>
								</tr>

								<tbody id="user_content_warnings">
								</tbody>
							</table>

							<div>
								<span class="label label-success"><i class="fa fa-check"></i>&nbsp; ]] .. VyHub.lang.other.active .. [[</span>
								<span class="label label-warning"><i class="fa fa-hourglass"></i>&nbsp; ]] .. VyHub.lang.other.inactive .. [[</span>
								<span class="label label-default"><i class="fa fa-times"></i>&nbsp; ]] .. VyHub.lang.other.disabled .. [[</span>
							</div>

							<hr />
							
							<h4><span class="label label-default"><i class="fa fa-gavel"></i> &nbsp;]] .. VyHub.lang.other.bans .. [[</span></h3>

							<div class="row perm-ban_edit">
								<div class="col-xs-8">
									<input id="user_ban_reason" type="text" class="form-control vh-input" onclick="$('#user_ban_reason').val('');" placeholder="]] .. VyHub.lang.other.reason .. [[" />
								</div>
								<div class="col-xs-2" style="padding-left: 0;">
									<input id="user_ban_minutes" type="text" class="form-control vh-input" onclick="$('#user_ban_minutes').val('');" placeholder="]] .. VyHub.lang.other.minutes .. [[" />
								</div>
								<div class="col-xs-2" style="padding-left: 0;">
									<button style="height: 30px;" onclick="create_ban()" class="btn btn-danger btn-xs btn-block"><i class="fa fa-gavel"></i> &nbsp; ]] .. VyHub.lang.dashboard.action_ban .. [[</button>
								</div>
							</div>

							<br/>

							<table class="table table-condensed table-hover">
								<tr>
									<th width="10px"></th>
									<th>]] .. VyHub.lang.other.reason .. [[</th>
									<th>]] .. VyHub.lang.other.admin .. [[</th>
									<th>]] .. VyHub.lang.other.date .. [[</th>
									<th>]] .. VyHub.lang.other.minutes .. [[</th>
									<th class="text-right">]] .. VyHub.lang.other.actions .. [[</th>
								</tr>

								<tbody id="user_content_bans">
								</tbody>
							</table>

							<div>
								<span class="label label-success"><i class="fa fa-check"></i>&nbsp; ]] .. VyHub.lang.other.active .. [[</span>
								<span class="label label-info"><i class="fa fa-globe"></i>&nbsp; ]] .. VyHub.lang.other.active_global .. [[</span>
								<span class="label label-warning"><i class="fa fa-times"></i>&nbsp; ]] .. VyHub.lang.other.unbanned .. [[</span>
								<span class="label label-danger"><i class="fa fa-hourglass"></i>&nbsp; ]] .. VyHub.lang.other.inactive .. [[</span>
							</div>
						</div>
					</div>
				</div>
			</body>

			<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
			<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/moment.min.js"></script>
			<script>
				var perms = null;
				var users = [];
				var users_by_id = {};
				var current_user = null;
				var local_steamid64 = null;

				function escape(str) {
					return $("<div>").text(str).html();
				}

				function format_date(iso_str) {
					return moment(iso_str).format('YYYY-MM-DD HH:mm');
				}

				function load_data(new_data) {
					users = new_data;
					users_by_id = {};
					
					new_data.forEach(function(user) {
						users_by_id[user.id] = user;
					});

					generate_user_list() 
				}

				function load_perms(new_perms) {
					perms = new_perms;
				}
				
				function enforce_perms() {
					if (perms == null) { return; }

					Object.keys(perms).forEach(function(perm) {
						var has_perm = perms[perm];

						if (has_perm) {
							$('.perm-' + perm).show();
						} else {
							$('.perm-' + perm).hide();
						}
					});
				}

				function generate_user_list() {
					$('#user_list').html('');

					var filter = null;

					if ($('#user_search').val()) {
						filter = $('#user_search').val().toLowerCase();
					}

					var ids = [];

					var only_local_user = perms == null || (!perms.warning_show && !perms.ban_show);

					users.forEach(function(user) {
						var activity = user.activities[0];

						if (activity == null) { return; }
						if (only_local_user && user.identifier !== local_steamid64) { return; }

						if (filter != null) {
							if (activity.extra.Nickname.toLowerCase().indexOf(filter) == -1 && user.username.toLowerCase().indexOf(filter) == -1) {
								return;
							}
						}

						var color = 'white';
						if (user.memberships.length > 0) {
							color = user.memberships[0].group.color;
						}

						var warn_badge_color = ((user.warnings.length == 0) ? '#444' : "#f0ad4e");
						var ban_badge_color = ((user.bans.length == 0) ? '#444' : "#d9534f");

						$('#user_list').append(' \
						<li class="user-tab" id="user_tab_' + user.id + '" onclick="generate_user_overview(\'' + user.id + '\')" style="cursor:pointer; color: ' + color + ';"> \
							' + escape(activity.extra.Nickname) + ' \
							<span class="badge pull-right" style="background-color: ' + ban_badge_color + ';">' + user.bans.length + ' <i class="fa fa-gavel"></i></span> \
							<span class="badge pull-right" style="background-color: ' + warn_badge_color + '; margin-left: 3px; margin-right: 3px;">' + user.warnings.length + ' <i class="fa fa-exclamation-triangle"></i></span> \
						</li> \
						');

						ids.push(user.id);
					});

					if (ids.length == 1) {
						generate_user_overview(ids[0]);
					} else if (ids.length == 0) {
						$('#user_content_empty').show();
						$('#user_content').hide();
					}
				}

				function generate_user_overview(user_id) {
					current_user = null;

					$('#user_content_empty').hide();
					$('#user_content').hide();

					var user = users_by_id[user_id];
					if (user == null) {	return; }

					var activity = user.activities[0];
					if (activity == null) { return; }

					current_user = user;

					$('#user_content_name').text(activity.extra.Nickname);
					$('#user_content_username').text(user.username);

					if (activity.extra.Nickname === user.username) {
						$('#user_content_username').hide();
					} else {
						$('#user_content_username').show();
					}

					$('.user-tab').removeClass("active");
					$('#user_tab_' + user_id).addClass("active");

					$('#user_content_warnings').html('');
					user.warnings.forEach(function(warning) {
						var row_class = "success";

						if (warning.disabled) {
							row_class = "active";
						} else if (!warning.active) {
							row_class = "warning";
						}

						$('#user_content_warnings').append(' \
							<tr> \
								<td class="' + row_class + '"></td> \
								<td>' + escape(warning.reason) + '</td> \
								<td>' + escape(warning.creator.username) + '</td> \
								<td>' + format_date(warning.created_on) + '</td> \
								<td class="text-right"> \
									<button class="btn btn-default btn-xs perm-warning_edit" onclick="vyhub.warning_toggle(\'' + warning.id + '\')"><i class="fa fa-play"></i><i class="fa fa-pause"></i></button> \
									<button class="btn btn-default btn-xs perm-warning_delete" onclick="vyhub.warning_delete(\'' + warning.id + '\')"><i class="fa fa-trash"></i></button> \
								</td> \
							</tr> \
						');
					});

					$('#user_content_bans').html('');
					user.bans.forEach(function(ban) {
						var minutes = '';

						if (ban.length != null) {
							minutes = Math.round(ban.length/60);
						}

						var row_class = "success";

						if (ban.status == "UNBANNED") {
							row_class = "warning";
						} else if (!ban.active) {
							row_class = "danger";
						} else if (ban.serverbundle == null) {
							row_class = "info";
						}

						var actions = "";

						if (ban.status == "ACTIVE") {
							actions += '<button class="btn btn-default btn-xs perm-ban_edit" onclick="vyhub.ban_set_status(\'' + ban.id + '\', \'UNBANNED\')"><i class="fa fa-check"></i> &nbsp;]] .. VyHub.lang.other.unban .. [[</button>';
						} else if (ban.status == "UNBANNED") {
							actions += '<button class="btn btn-default btn-xs perm-ban_edit" onclick="vyhub.ban_set_status(\'' + ban.id + '\', \'ACTIVE\')"><i class="fa fa-gavel"></i> &nbsp;]] .. VyHub.lang.other.reban .. [[</button>';
						}

						$('#user_content_bans').append(' \
							<tr> \
								<td class="' + row_class + '"></td> \
								<td>' + escape(ban.reason) + '</td> \
								<td>' + escape(ban.creator.username) + '</td> \
								<td>' + format_date(ban.created_on) + '</td> \
								<td>' + minutes + '</td> \
								<td class="text-right">' + actions + '</td> \
							</tr> \
						');
					});

					$('#user_memberships').html('');

					user.memberships.forEach(function(membership) {
						$('#user_memberships').append('<span class="label label-default" style="background-color: ' + membership.group.color + ';">' + membership.group.name + '</span>');
					});

					$('#user_content').show();

					enforce_perms();
				}

				function reload_current_user() {
					if (current_user != null) {
						generate_user_overview(current_user.id);
					}
				}

				function create_warning() {
					if (current_user == null) {
						return;
					}

					var reason = $('#user_warn').val();

					vyhub.warning_create(current_user.identifier, reason);

					$('#user_warn').val('');
				}

				function create_ban() {
					if (current_user == null) {
						return;
					}

					var reason = $('#user_ban_reason').val();
					var minutes = $('#user_ban_minutes').val();

					vyhub.ban_create(current_user.identifier, minutes, reason);

					$('#user_ban_reason').val('');
					$('#user_ban_minutes').val('');
				}
			</script>
		</html>
	]]
end


function VyHub.Dashboard:load_users(users_json) 
	VyHub.Dashboard.ui_html:RunJavascript("load_data(" .. users_json .. ");")
	VyHub.Dashboard.ui_html:RunJavascript("reload_current_user();")
end

function VyHub.Dashboard:load_perms(perms_json) 
	VyHub.Dashboard.ui_html:RunJavascript("load_perms(" .. perms_json .. ");")
end

concommand.Add("vh_dashboard", function ()
	if VyHub.Dashboard.ui == nil or not VyHub.Dashboard.ui:IsValid() then
		VyHub.Dashboard:create_ui()
		VyHub.Dashboard.ui:Show()
		VyHub.Dashboard.ui:MakePopup()
	else
		-- VyHub.Dashboard:create_ui()

--		if VyHub.Dashboard.ui != nil and VyHub.Dashboard.ui:IsValid() and VyHub.Dashboard.ui:IsVisible() then
--			VyHub.Dashboard.ui:Hide()
--		else
			VyHub.Dashboard.ui:Show()
			VyHub.Dashboard.ui:MakePopup()
--		end
	end

	net.Start("vyhub_dashboard")
	net.SendToServer()
end)


net.Receive("vyhub_dashboard", function()
	local data_length = net.ReadUInt(16)
	local data_raw = net.ReadData(data_length)
	local perms_json = net.ReadString()
	local users_json = util.Decompress(data_raw)

	timer.Create("vyhub_dashboard_html_ready", 0.3, 20, function ()
		if not VyHub.Dashboard.html_ready then
			MsgN("VyHub Dashboard: Waiting for HTML to load.")
			return
		end

		timer.Remove("vyhub_dashboard_html_ready")

		VyHub.Dashboard:load_perms(perms_json)
		VyHub.Dashboard:load_users(users_json)
	end)
end)


net.Receive("vyhub_dashboard_reload", function()
	if VyHub.Dashboard.ui and VyHub.Dashboard.ui:IsVisible() then
		MsgN("Reloading dashboard data, because server told us.")
		net.Start("vyhub_dashboard")
		net.SendToServer()
	end
end)

hook.Add("vyhub_lang_loaded", "vyhub_dashboard_vyhub_lang_loaded", function ()
	VyHub.Dashboard:load_html()
end)

if VyHub.Dashboard.html_generated then
	VyHub.Dashboard:load_html()
end


--addons/vyhub-gmod/lua/vyhub/client/cl_group.lua:
VyHub.groups_mapped = VyHub.groups_mapped or nil

net.Receive("vyhub_group_data", function()
	local num = net.ReadUInt(8)
	local groups_mapped_new = {}

	for i=1, num do
		-- Currently only the name and color of the group is transferred
		local name_game = net.ReadString()
		local name = net.ReadString()
		local color = net.ReadString()

		groups_mapped_new[name_game] = {
			name = name,
			color = color,
		}
	end

	VyHub.groups_mapped = groups_mapped_new
end)
--lua/wos/anim_extension/holdtypes/a_combo3.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo3"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo3" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo3" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/g_combo4.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo4"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo4" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo4" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_language.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local translationFiles = file.Find( "z_anticrash/languages/*.lua", "LUA" )
local translations = {}
local languages = {}
local langConvarName = "gmod_language"
 
-- intialize languages  
for _,translation in pairs(translationFiles) do

	local f = "z_anticrash/languages/"..translation

	if SERVER then
		AddCSLuaFile(f)
	end
	
	-- get the lang code from file name
	local langCode = string.match(translation,"(%a+).lua")
	langCode = langCode:upper()
	
	-- add the code to the range of languages
	table.insert(languages,langCode)
 
	-- store the translations in the var
	translations[langCode] = include( f )
	
end

function SH_ANTICRASH.GetLanguages()
	return languages
end

function SH_ANTICRASH.GetLanguage()

	if SERVER then
		return SH_ANTICRASH.SETTINGS.SYSTEMLANG
	end
	
	langConvar = GetConVar( langConvarName )
	return langConvar:GetString():upper()
	
end

function SH_ANTICRASH.Translate(str)

	local playerLang = SH_ANTICRASH.GetLanguage()
	local translatedStr = (translations[playerLang] and translations[playerLang][str]) or translations["EN"][str]
	
	return translatedStr or str

end

local function CleanupStrFormat(str)
	
	-- Partial string format
	local formattedStr = string.gsub(str, "$([%w_]*)", function(cleanupType)
		
		local type = SH_ANTICRASH.VARS.CLEANUP.TYPESBYKEY[cleanupType]
		
		if type ~= nil then
			return type.name:lower()
		end
		
		return cleanupType
		
	end)
	
	return formattedStr

end

function SH_ANTICRASH.Format(str)

	local formattedStr = str

	-- Full string format
	if string.StartWith(str,"##") then

		local str = string.sub( str, 3 )
		local strSplitTbl = string.Split(str,' %')
		local translatedStr = SH_ANTICRASH.Translate(strSplitTbl[1])

		-- Keep format parms only
		table.remove(strSplitTbl,1)
		
		-- Replace format parms
		translatedStr = string.format( translatedStr, unpack(strSplitTbl))

		-- Cleanup Format String
		translatedStr = CleanupStrFormat(translatedStr)
		
		formattedStr = translatedStr
		
	end
	
	-- Partial string format
	local formattedStr = string.gsub(formattedStr, "#(%w*)", function(match)
		return SH_ANTICRASH.Translate(match)
	end)
	
	return formattedStr
	
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/tr.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local tr = {
	
	-- Stats
	lag = "GECIKME",
	collisions = "CARPISMALAR",
	props = "PROPLAR",
	propsFrozen = "DONDURULMUS PROPLAR",
	npcs = "NPC'LER",
	vehicles = "ARACLAR",
	players = "OYUNCULAR",
	uptime = "BULUNMA SURESI",
	entities = "VARLIKLAR",
	spawned = "CIKARILMIS",
	fps = "FPS",
	tickrate = "TICKRATE",
	runAntiLagMeasures = "ANTI-LAG AYARLARINI CALISTIR",
	
	-- Users
	search = "Ara",
	constraints = "SINIRLAMALAR",
	showEntities = "Varliklari Goster",
	hideEntities = "Varliklari Gizle",
	resetMap = "Haritayi Sifirla",
	freezeEntities = "Varliklari Dondur",
	removeEntities = "Varliklari Kaldir",
	
	-- Global
	noCollideEntities = "Carpismayan Varliklar",
	
	-- Lag
	heavyLag = "Agir lag algilandi!",
	lagIsStuck = "Uyari: gecikme sikisti!",
	crashPrevented = "Sunucu cokmesi engellendi!",
	cleaningMap = "+ Harita temizleniyor...",
	removingEnts = "+ %s varliklari kaldiriliyor",
	revertChanges = "+ %s varliklari %s dakika icerisinde cikartildiyse kaldiriliyor",
	freezeingEnts = "+ %s varliklari kaldiriliyor",
	noCollidingEnts = "+ %s varliklari icin carpismalar kapatiliyor",
	offenderWarning = "%s supheli varlik sayisi (%s)!",
	freezingAllEntities = "Tum varliklar donduruluyor (%s)",
	
	-- Dupes
	dupesNotEnabled = "Dupelar bu sunucunda etkin degil!",
	advDupesNotEnabled = "Gelismis Dupelar bu sunucuda etkin degil!",
	dupeExceedsSize = "Bu dupe maksimum siniri asiyor! (boyut:%s, maks:%s)",
	dupeInformation = "%s dupe olusturuyor. Buna %s varliklari ve %s kisitlamalari dahil",
	
	-- Notifications
	triggeredAntiLagMeasures = "anti gecikme ayarini tetikledin!",
	ranAntilagMeasures = "anti gecikme ayarini calistir!",
	hasNoEntities = "varliga sahip degil!",
	youRemovedFrom = "%s varliklarini %s'dan kaldirdin!",
	removedYourObjects = "cikardigin objeleri kaldirdin!",
	youFrozeFrom = "%s varliklarini %s tarafindan dondurdun!",
	frozeYourObjects = "canlandirdigin objeleri dondur!",
	enabledSpawnAbility = "obje canlandirma ozelligini tekrardan aktif et!",
	disabledSpawnAbility = "objeleri canlandirma ozelligini deaktif et!",
	youEnabledSpawnAbility = "%'nin obje canlandirma ozelligini aktif ettin!",
	youDisabledSpawnAbility = "%'nin obje canlandirma ozelligini deaktif ettin!",
	
	resetTheMap = "haritayi sifirla!",
	noEntNameFound = "Hicbir %s bulunamadi!",
	noEntitiesFound = "Hicbir varlik bulunamadi!",
	noUnfrozenEntsFound = "Dondurulmamis varlik bulunamadi!",
	noUnCollidedEntsFound = "Carpismasi kapatilan bir nesne bulunamadi!",
	freezeAllEnts = "%s butun %s lari dondurdu! (%s)",
	noCollideAllEnts = "%s tum %s larin carpismasi kapatildi! (%s)",
	removedAllEntName = "%s butun %s lari kaldirdi! (%s)",
	entitiesLowCase = "varliklar",
	removingOutOfBounds = "Sinirlar kaldiriliyor %s",
	
	-- Console Log
	removedEntitiesFrom = "%s %s'nin varliklarini %s tarafiyla kaldirildi!",
	frozeEntitiesFrom = "%s %s'nin varliklarini %s tarafiyla dondurdu!",
	enabledSpawningCapabilities = "%s %s'nin canlandirma ozelliklerini aktif etti!",
	disabledSpawningCapabilities = "%s %s'nin canlandirma ozelliklerini deaktif etti!",
	removingHighCollision = "Yuksek carpisma %s (%s) %s tarafindan kaldiriliyor!",
	
}

return tr
--addons/lvs_base/lua/autorun/client/lvs_vehicle_tab.lua:

hook.Add( "PopulateVehicles", "!!!add_lvs_to_vehicles", function( pnlContent, tree, node )
	local CategoryNameTranslate = {}
	local Categorised = {}
	local SubCategorised = {}

	local SpawnableEntities = table.Copy( list.Get( "SpawnableEntities" ) )
	local Variants = {
		[1] = "[LVS] - ",
		[2] = "[LVS] -",
		[3] = "[LVS]- ",
		[4] = "[LVS]-",
		[5] = "[LVS] ",
	}

	for _, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not v.t.ClassName or not v.t.VehicleCategory then continue end

		if not isstring( v.t.ClassName ) or v.t.ClassName == "" or not SpawnableEntities[ v.t.ClassName ] then continue end

		SpawnableEntities[ v.t.ClassName ].Category = "[LVS] - "..v.t.VehicleCategory

		if not v.t.VehicleSubCategory then continue end

		SpawnableEntities[ v.t.ClassName ].SubCategory = v.t.VehicleSubCategory
	end

	if SpawnableEntities then
		for k, v in pairs( SpawnableEntities ) do

			local Category = v.Category

			if not isstring( Category ) then continue end

			if not Category:StartWith( "[LVS]" ) and not v.LVS then continue end

			v.SpawnName = k

			for _, start in pairs( Variants ) do
				if Category:StartWith( start ) then
					local NewName = string.Replace(Category, start, "")
					CategoryNameTranslate[ NewName ] = Category
					Category = NewName

					break
				end
			end

			if v.SubCategory then
				SubCategorised[ Category ] = SubCategorised[ Category ] or {}
				SubCategorised[ Category ][ v.SubCategory ] = SubCategorised[ Category ][ v.SubCategory ] or {}

				table.insert( SubCategorised[ Category ][ v.SubCategory ], v )
			end

			Categorised[ Category ] = Categorised[ Category ] or {}

			table.insert( Categorised[ Category ], v )
		end
	end

	local lvsNode = tree:AddNode( "[LVS]", "icon16/lvs.png" )

	if Categorised["[LVS]"] then
		local v = Categorised["[LVS]"]

		lvsNode.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end

		lvsNode.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end
	end

	local IconList = list.Get( "ContentCategoryIcons" )

	for CategoryName, v in SortedPairs( Categorised ) do
		if CategoryName:StartWith( "[LVS]" ) then continue end

		local Icon = "icon16/lvs_noicon.png"

		if IconList and IconList[ CategoryNameTranslate[ CategoryName ] ] then
			Icon = IconList[ CategoryNameTranslate[ CategoryName ] ]
		end

		local node = lvsNode:AddNode( CategoryName, Icon )

		node.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				if ent.SubCategory then
					continue
				end

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end
		node.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end

		local SubCat = SubCategorised[ CategoryName ]

		if not SubCat then continue end

		for SubName, data in SortedPairs( SubCat ) do

			local SubIcon = "icon16/lvs_noicon.png"

			if IconList then
				if IconList[ "[LVS] - "..CategoryName.." - "..SubName ] then
					SubIcon = IconList[ "[LVS] - "..CategoryName.." - "..SubName ]
				else
					if IconList[ "[LVS] - "..SubName ] then
						SubIcon = IconList[ "[LVS] - "..SubName ]
					end
				end
			end

			local subnode = node:AddNode( SubName, SubIcon )

			subnode.DoPopulate = function( self )
				if self.PropPanel then return end

				self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
				self.PropPanel:SetVisible( false )
				self.PropPanel:SetTriggerSpawnlistChange( false )

				for k, ent in SortedPairsByMemberValue( data, "PrintName" ) do
					spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.SpawnName,
						material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
						admin		= ent.AdminOnly
					} )
				end
			end
			subnode.DoClick = function( self )
				self:DoPopulate()
				pnlContent:SwitchPanel( self.PropPanel )
			end
		end
	end

	-- User Stuff
	hook.Run( "LVS.PopulateVehicles", lvsNode, pnlContent, tree )

	-- CONTROLS
	local node = lvsNode:AddNode( "Controls", "icon16/keyboard.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientControls()
	end

	-- CLIENT SETTINGS
	local node = lvsNode:AddNode( "Client Settings", "icon16/wrench.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientSettings()
	end

	-- SERVER SETTINGS
	local node = lvsNode:AddNode( "Server Settings", "icon16/wrench_orange.png" )
	node.DoClick = function( self )
		if LocalPlayer():IsSuperAdmin() then
			LVS:OpenMenu()
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
end )

list.Set( "ContentCategoryIcons", "[LVS]", "icon16/lvs.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Artillery", "icon16/lvs_artillery.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Cars", "icon16/lvs_cars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Armored", "icon16/lvs_armor.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Civilian", "icon16/lvs_civilian.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Military", "icon16/lvs_military.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Pack", "icon16/lvs_cars_pack.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Helicopters", "icon16/lvs_helicopters.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Combine", "icon16/lvs_combine.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Resistance", "icon16/lvs_resistance.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Planes", "icon16/lvs_planes.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Bombers", "icon16/lvs_bomb.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Fighters", "icon16/lvs_fighter.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Civilian", "icon16/lvs_civilian.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Tanks", "icon16/lvs_tanks.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Light", "icon16/lvs_light.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Medium", "icon16/lvs_medium.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Heavy", "icon16/lvs_heavy.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - RP", "icon16/lvs_rp.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Star Wars", "icon16/lvs_starwars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Gunships", "icon16/lvs_sw_gunship.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Hover Tanks", "icon16/lvs_sw_hover.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Walkers", "icon16/lvs_sw_walker.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Starfighters", "icon16/lvs_sw_starfighter.png" )

--addons/wos-passiveevent-ageo/lua/autorun/client/wos_pes_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.PES = wOS.PES or {}

include("wos/pes/loader/loader.lua")
include("wos/css/loader/loader.lua")

hook.Add("AOCRP_Loaded", "wOS.PES.Load", function()
    include("wos/pes/loader/loader.lua")
    include("wos/css/loader/loader.lua")
end)
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/map/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addons = {}

wOS.PES.Modules:RegisterAddon( "map", addons )

net.Receive( "wOS.PES.Maps", function()
	addons.Maps = net.ReadTable()
end )
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/snooze-randomevents/cl_core.lua:

local addon = {}

surface.CreateFont( "wOS.PES.SnoozeText", {
	font = "Arial",
	extended = false,
	size = ScreenScale(8),
	weight = 1300,
} )


net.Receive("wOS.PES.SnoozeEvent", function(len)
	local name = net.ReadString()
	local time = net.ReadFloat() + CurTime()
	local id = net.ReadFloat()

	addon.OpenSnoozeMenu( name, time, id )

end)

addon.OpenSnoozeMenu = function( name, time, id )
	local w, h = ScrW(), ScrH()
	local txtConfig = (wOS.PES.Config and wOS.PES.Config.SnoozeText)

	if !txtConfig then
		ErrorNoHalt("Looks like your PES Config is broken wOS.PES.Config.SnoozeText was not found")
		return
	end

	if istable(txtConfig) then
		txtConfig = txtConfig[math.random(#txtConfig)]
	end

	txtConfig = string.Replace(txtConfig, "[[name]]", name)

	local bool = hook.Call("wOS.PES.SnoozeButton", nil, name, time, id) -- Something else overrides are render

	if bool then return end

	local dframe = vgui.Create("DFrame")

	local size = 0.27*h

	dframe:SetSize(size, size)
	dframe:SetPos(0, h*0.5 - size*0.5 )
	dframe:MakePopup()
	dframe:ShowCloseButton(false)
	dframe:SetDraggable(false)
	dframe:SetTitle("")
	dframe.Paint = function(self, ww, hh)
		if time < CurTime() then self:Remove() return end

		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0, 0, ww, hh)

		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect(0, 0, ww, hh)

		local word = wOS.PES.WrapText( string.Replace(txtConfig, "[[time]]", string.FormattedTime(time - CurTime(), "%02i:%02i:%02i") ), "wOS.PES.SnoozeText", ww*0.94 )

		draw.DrawText( word, "wOS.PES.SnoozeText", ww*0.02, ww*0.02, color_white, TEXT_ALIGN_LEFT ) 
	end

	local yes = vgui.Create("DButton", dframe)
	yes:SetPos(size*0.2, size*0.92)
	yes:SetSize(size*0.3, size*0.08)
	yes:SetText("Yes")
	yes.DoClick = function()
		dframe:Remove()
		net.Start("wOS.PES.SnoozeEvent")
			net.WriteFloat(id)
		net.SendToServer()
	end

	local no = vgui.Create("DButton", dframe)
	no:SetPos(size*0.5, size*0.92)
	no:SetSize(size*0.3, size*0.08)
	no:SetText("No")
	no.DoClick = function()
		dframe:Remove()
	end
end

function TESTTHISDRIVE( name, time, id )
	addon.OpenSnoozeMenu( name, time, id )
end
--addons/wos-passiveevent-ageo/lua/wos/css/loader/loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

if CLIENT then
	include( "wos/css/config/sh_config.lua" )

	include( "wos/css/vgui/wos_css_scrollpanel.lua" )
	include( "wos/css/vgui/wos_css_nodebackground.lua" )
	
	include( "wos/css/core/cl_core.lua" )
	include( "wos/css/core/cl_admin_menu.lua" )
	include( "wos/css/core/cl_net.lua" )	

	include( "wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua")
	include( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua" )

	include( "wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua")
	include(  "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua" )

	include( "wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua")
	include(  "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua" )

	include(  "wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua" )

end

if SERVER then
	AddCSLuaFile( "wos/css/config/sh_config.lua" )

	include( "wos/css/config/sh_config.lua" )
	include( "wos/css/config/sv_config.lua" )
	
	AddCSLuaFile( "wos/css/vgui/wos_css_scrollpanel.lua" )
	AddCSLuaFile( "wos/css/vgui/wos_css_nodebackground.lua" )

	AddCSLuaFile( "wos/css/core/cl_core.lua" )
	AddCSLuaFile( "wos/css/core/cl_admin_menu.lua" )
	AddCSLuaFile( "wos/css/core/cl_net.lua" )
	
	wOS.PES:ServerInclude( "wos/css/core/sv_net.lua" )
	wOS.PES:ServerInclude( "wos/css/core/sv_core.lua" )
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua")
	include( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_system/sv_wos_simulation_system.lua")
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua")
	include(  "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_tool/sv_wos_simulation_tool.lua")
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua")
	include(  "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_wall/sv_wos_simulation_wall.lua")

	wOS.PES:ServerInclude( "wos/css/entities/wos_pes_basiczone/sv_wos_pes_basiczone.lua")	

	AddCSLuaFile( "wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua")
	wOS.PES:ServerInclude( "wos/css/entities/wos_pes_basicobj/sv_wos_pes_basicobj.lua")	

	include( "wos/css/wrappers/sv_data.lua" )
	wOS.PES:ServerInclude( "wos/css/core/sv_wrapper.lua")

end
--addons/wos-passiveevent-ageo/lua/wos/css/vgui/wos_css_nodebackground.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")
local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)
local bgWhite = Color(200,200,200)

PANEL.CreationType = WOS_PES.CREATOR.SIMULATION

PANEL.BaseSettings = {
    ["Time Limit"] =  {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 60,
    },
    ["Maximum Players"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 1,
        Default = 4,
    },
    ["Prevent Damage from Outside"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = true,
    },
    ["Enable Lives"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = false,
    },
    ["Player Lives"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 0,
    },
    ["Share Lives"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = true,
    },
    ["Respawn Time"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 0,
    },
}

PANEL.GameSettings = {
    ["Time Limit"] = 60,
    ["Maximum Players"] = 4,
    ["Prevent Damage from Outside"] = true,
    ["Enable Lives"] = false,
    ["Player Lives"] = 0,
    ["Share Lives"] = true,
    ["Respawn Time"] = 0
}

function PANEL:Init()

end

function PANEL:CreateStartNode()
    local start = self:AddNode("Player Spawn", true)
    start.Type = "Simulation Player Spawn"
    start:CreateLinks()
    start:SetMainLink(false)
    start:SetAsStart( true )
    start:RecalculateDirty()

    start.DeleteButton:Remove()
    return start
end

function PANEL:CreateSaveBox( event_tbl )
    local dummy_frame = vgui.Create( "DFrame" )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame)
    dframe:MakePopup()
    dframe:SetSize(300, 300)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    dummy_frame.Think = function( pan ) 
        if not IsValid( dframe ) then
            pan:Remove()
        end
    end

    local textentry = vgui.Create("DTextEntry", dframe)
    textentry:SetSize(280, 20)
    textentry:SetPos(10, 30)
    textentry:SetPlaceholderText("Simulation Name")
    if self.Name != "" then
        textentry:SetText(self.Name)
    end

    local descriptentry = vgui.Create("DTextEntry", dframe)
    descriptentry:SetSize(280, 20)
    descriptentry:SetPos(10, 60)
    descriptentry:SetText( "No description available" )
    descriptentry:SetPlaceholderText("Simulation Description")
    if self.Description then
        descriptentry:SetText(self.Description)
    end

    local importbut = vgui.Create("DCheckBoxLabel", dframe)
    importbut:SetSize(20,20)
    importbut:SetPos(10, 90)
    importbut:SetText("Allow for import/export")
    importbut:SetChecked( self.Importable )

    local urlbut = vgui.Create("DCheckBoxLabel", dframe)
    urlbut:SetSize(20,20)
    urlbut:SetPos(10, 250)
    urlbut:SetText("Export to URL on Confirm")
    urlbut:SetChecked( false )

    local but = vgui.Create("DButton", dframe)
    but:SetSize(60, 20)
    but:SetText("Confirm")
    but:SetPos(225, 270)
    but.DoClick =  function()
        event_tbl.Name = textentry:GetText()
        if #event_tbl.Name < 1 then
            notification.AddLegacy( "[wOS-PES] Can not leave simulation name blank!", NOTIFY_ERROR, 3 )
            return
        end
        event_tbl.Description = descriptentry:GetText()
        event_tbl.Importable = importbut:GetChecked()
        event_tbl.Settings = self:GetGameSettings()
        event_tbl.Export = urlbut:GetChecked()
        dummy_frame:Remove()
        wOS.PES.NetworkSimulation(event_tbl)
        wOS.PES:GetActiveMenu():Remove()
        wOS.CombatSim:OpenToolMenu()
    end

    urlbut.OnChange = function(self, val)
        if val then
            but:SetText("Confirm and Export")
            but:SetSize(120, 20)
            but:SetPos(165, 270)            
        else
            but:SetText("Confirm")
            but:SetSize(60, 20)
            but:SetPos(225, 270)
        end
    end

end

function PANEL:AddToolBox( tools )
    local gsetting = vgui.Create("DButton", tools)
    gsetting:SetSize(60, 60)
    gsetting:Dock(BOTTOM)
    gsetting:DockMargin(6,5,6,5)
    gsetting:SetText("Game\nSettings")
	gsetting.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end
    gsetting.DoClick = function( pan )
        local frame = wOS.CombatSim:OpenToolSettingsMenu( self:GetBaseSettings(), self:GetGameSettings() )

        local dummy_frame = vgui.Create( "DFrame", self )
        dummy_frame:SetSize( ScrW(), ScrH() )
        dummy_frame:SetTitle( "" )
        dummy_frame:SetDraggable( false )
        dummy_frame:ShowCloseButton( false )
        dummy_frame.Paint = function( pan, ww, hh )
            draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
            if not IsValid( frame ) then pan:Remove() return end
            frame:MoveToFront()
        end
        dummy_frame:MakePopup()
        frame:SetParent( dummy_frame )
    end
end

function PANEL:SetDefaultSettings()

end

function PANEL:SetupTool()
   net.Start( "wOS.CSS.ToolEditVar" )
   net.SendToServer()
end

function PANEL:GetBaseSettings()
    return self.BaseSettings
end

function PANEL:SaveGameSettings( settings )
    self.GameSettings = settings
end

function PANEL:GetGameSettings()
    return self.GameSettings or {}
end

vgui.Register( "WOS_CSS_NodeBG", PANEL, "WOS_PES_NodeBG" )
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--addons/billy_gas/lua/vgui/bvgui/option_selector.lua:
local PANEL = {}

function PANEL:Init()
	self.Color = bVGUI.BUTTON_COLOR_BLUE
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)

	self.SelectedX = bVGUI.Lerp(0,0,.5)
	self.SelectedWidth = bVGUI.Lerp(0,0,.5)

	self.ButtonLabels = {}
	self.TotalWidth = 0
	self.ButtonCount = 0
	self.Selected = 1

	self.ClickableArea = vgui.Create("bVGUI.BlankPanel", self)
	self.ClickableArea:SetMouseInputEnabled(true)
	self.ClickableArea:SetCursor("hand")
	function self.ClickableArea:OnMouseReleased(m)
		self:GetParent():OnMouseReleased(m)
	end
end

function PANEL:SetColor(col)
	self.Color = col
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)
end

local grey_col = Color(150,150,150)
local dark_grey_col = bVGUI.DarkenColor(grey_col, 0.5)
function PANEL:Paint(w,h)
	if (IsValid(self.HelpLabel)) then
		h = 26
	end

	self.SelectedX:DoLerp()
	self.SelectedWidth:DoLerp()

	draw.RoundedBoxEx(4,0,0,self.TotalWidth,h - 4,grey_col,true,true)
	draw.RoundedBoxEx(4,0,h - 4,self.TotalWidth,4,grey_col,false,false,true,true)

	if (self.LerpedColor == nil) then
		self.LerpedColor = Color(self.Color.r, self.Color.g, self.Color.b)
	else
		self.LerpedColor.r = Lerp(FrameTime() * 10, self.LerpedColor.r, self.Color.r)
		self.LerpedColor.g = Lerp(FrameTime() * 10, self.LerpedColor.g, self.Color.g)
		self.LerpedColor.b = Lerp(FrameTime() * 10, self.LerpedColor.b, self.Color.b)
	end

	if (self.LerpDarkColor == nil) then
		self.LerpDarkColor = Color(self.DarkColor.r, self.DarkColor.g, self.DarkColor.b)
	else
		self.LerpDarkColor.r = Lerp(FrameTime() * 10, self.LerpDarkColor.r, self.DarkColor.r)
		self.LerpDarkColor.g = Lerp(FrameTime() * 10, self.LerpDarkColor.g, self.DarkColor.g)
		self.LerpDarkColor.b = Lerp(FrameTime() * 10, self.LerpDarkColor.b, self.DarkColor.b)
	end

	draw.RoundedBoxEx(4, self.SelectedX:GetValue(), 0, self.SelectedWidth:GetValue(), h, self.LerpedColor, self.Selected == 1, self.Selected == self.ButtonCount, false, false)

	surface.SetDrawColor(dark_grey_col)
	surface.DrawRect(0,h - 4,self.TotalWidth,4)

	surface.SetDrawColor(self.LerpDarkColor)
	surface.DrawRect(self.SelectedX:GetValue(), h - 4, self.SelectedWidth:GetValue(), 4)
end

function PANEL:AddButton(text, col)
	self.ButtonCount = self.ButtonCount + 1
	local btn = vgui.Create("DLabel", self)
	btn.BtnIndex = table.insert(self.ButtonLabels, btn)
	btn.BtnColor = col
	btn:SetTextColor(bVGUI.COLOR_WHITE)
	btn:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	btn:SetContentAlignment(5)
	btn:SetText(text)
	self:InvalidateLayout(true)
end

function PANEL:PerformLayout(w,h)
	local x = 5
	for i,v in ipairs(self.ButtonLabels) do
		if (i == self.Selected) then
			self.SelectedX:SetTo((v:GetPos()) - 5)
			self.SelectedWidth:SetTo(v:GetWide() + 10)
		end
		v:SizeToContentsX()
		if (IsValid(self.HelpLabel)) then
			v:SetTall(26 - 4)
		else
			v:SetTall(h - 4)
		end
		v:AlignLeft(x)
		x = x + v:GetWide() + 10
	end
	self.TotalWidth = x - 5
	if (IsValid(self.Label)) then
		self.Label:AlignLeft(self.TotalWidth + 10)
	end
	if (IsValid(self.HelpLabel)) then
		local h = self.HelpLabel:GetTall() + 30
		if (self:GetTall() ~= h) then
			self:SetTall(h)
		end
	end
	self.ClickableArea:SetSize(self.TotalWidth, 26)
end

function PANEL:SetSelectedButton(index)
	self.Selected = index
	self:InvalidateLayout(true)
end
function PANEL:GetSelectedButton()
	return self.ButtonLabels[self.Selected]:GetText(), self.ButtonLabels[self.Selected]
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		local x,y = self:ScreenToLocal(gui.MousePos())
		for i,v in ipairs(self.ButtonLabels) do
			local btn_x, btn_y, btn_w = v:GetBounds()
			if (y <= 25 and x >= btn_x - 5 and x <= btn_x + btn_w + 5) then
				self:SetSelectedButton(i)
				if (v.BtnColor ~= nil) then
					self:SetColor(v.BtnColor)
				end
				if (self.OnChange) then
					self:OnChange()
				end
				break
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContentsX()
	self.Label:SetTall(21)
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetContentAlignment(4)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.HelpLabel:SetTextColor(bVGUI.COLOR_WHITE)
	self.HelpLabel:SetText(text)
	self.HelpLabel:SetWide(500)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:AlignTop(30)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	function self.HelpLabel:PerformLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:GetValue()
	return self.ButtonLabels[self.Selected]:GetText()
end
function PANEL:SetValue(val)
	for i,v in ipairs(self.ButtonLabels) do
		if (v:GetText() == val) then
			self:SetSelectedButton(i)
			self.SelectedX:SetValue(self.SelectedX.to)
			self.SelectedWidth:SetValue(self.SelectedWidth.to)
			break
		end
	end
end

function PANEL:SizeToButtons()
	local w = 0
	for i,v in ipairs(self.ButtonLabels) do
		w = w + v:GetWide() + 10
	end
	self:SetWide(w)
end

derma.DefineControl("bVGUI.OptionSelector", nil, PANEL, "bVGUI.BlankPanel")
--addons/tools/lua/vgui/dparticlecontroller.lua:
local PANEL = {}

function PANEL:Init()
	self.CategoryTable = {}

	self.HorizontalDivider = vgui.Create( "DHorizontalDivider", self )
	self.HorizontalDivider:Dock( FILL )
	self.HorizontalDivider:SetLeftWidth( 192 )
	self.HorizontalDivider:SetLeftMin( 100 )
	self.HorizontalDivider:SetRightMin( 100 )
	if ( ScrW() >= 1024 ) then self.HorizontalDivider:SetLeftMin( 192 ) self.HorizontalDivider:SetRightMin( 400 ) end
	self.HorizontalDivider:SetDividerWidth( 6 )
	self.HorizontalDivider:SetCookieName( "SpawnMenuCreationMenuDiv" )

	self.ContentNavBar = vgui.Create( "ContentSidebar", self.HorizontalDivider )
	self.HorizontalDivider:SetLeft( self.ContentNavBar )

    self:FillContent()
end

function PANEL:EnableModify()
	self.ContentNavBar:EnableModify()
end

function PANEL:EnableSearch( ... )
	self.ContentNavBar:EnableSearch( ... )
end

function PANEL:CallPopulateHook( HookName )
end

function PANEL:FillContent()
    local files = file.Find("particles/*.pcf", "GAME")

    for k, v in pairs(files) do
        local item = self.ContentNavBar.Tree:AddNode( v, "icon16/page.png" )
        item.DoPopulate = function( s )
            game.AddParticles("particles/" .. v)
            -- If we've already populated it - forget it.
			if ( s.PropPanel ) then return end

			-- Create the container panel
			s.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			s.PropPanel:SetVisible( false )
			s.PropPanel:SetTriggerSpawnlistChange( false )

			for _, pp in pairs(util.GetParticleList( "particles/" .. v )) do
				spawnmenu.CreateContentIcon( "particles", s.PropPanel, {
					name = pp,
                    part = v,
				} )
			end

        end

        item.DoClick = function( s )

			s:DoPopulate()
			self:SwitchPanel( s.PropPanel )

		end
    end
end

function PANEL:SwitchPanel( panel )

	if ( IsValid( self.SelectedPanel ) ) then
		self.SelectedPanel:SetVisible( false )
		self.SelectedPanel = nil
	end

	self.SelectedPanel = panel

	if ( !IsValid( panel ) ) then return end

	self.HorizontalDivider:SetRight( self.SelectedPanel )
	self.HorizontalDivider:InvalidateLayout( true )

	self.SelectedPanel:SetVisible( true )
	self:InvalidateParent()

end

function PANEL:OnSizeChanged()
	self.HorizontalDivider:LoadCookies()
end

vgui.Register("DParticleViewer", PANEL, "EditablePanel")

spawnmenu.AddCreationTab( "Particles", function()
    local PViewer = vgui.Create( "DParticleViewer" )
    return PViewer
end, "icon16/fire.png", 96, "See all your particles" )
--addons/billy_gas/lua/vgui/gas_workshop_item.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "workshop")
	else
		return GAS:PhraseFormat(phrase, "workshop", ...)
	end
end

file.CreateDir("gmodadminsuite/workshop")

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:Dock(TOP)
	self:SetTall(105)
	self:SetLoading(true)

	self.ItemImage = vgui.Create("bVGUI.LoadingPanel", self)
	self.ItemImage:Dock(LEFT)
	self.ItemImage:SetMouseInputEnabled(false)
	self.ItemImage:DockPadding(10,10,10,10)
	self.ItemImage:SetLoading(false)
	self.ItemImage:SetWide(105)

		self.ItemImage.ImagePnl = vgui.Create("DImage", self.ItemImage)
		self.ItemImage.ImagePnl:Dock(FILL)

	self.Content = vgui.Create("bVGUI.BlankPanel", self)
	self.Content:Dock(FILL)
	self.Content:SetMouseInputEnabled(false)
	self.Content:DockPadding(0,10,10,10)

		self.Content.ItemName = vgui.Create("DLabel", self.Content)
		self.Content.ItemName:Dock(TOP)
		self.Content.ItemName:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 16))
		self.Content.ItemName:SetTextColor(bVGUI.COLOR_WHITE)
		self.Content.ItemName:SetContentAlignment(4)
		self.Content.ItemName:SetText("")

		self.Content.Description = vgui.Create("DLabel", self.Content)
		self.Content.Description:Dock(FILL)
		self.Content.Description:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
		self.Content.Description:SetTextColor(bVGUI.COLOR_WHITE)
		self.Content.Description:SetContentAlignment(7)
		self.Content.Description:SetText("")
		self.Content.Description:SetWrap(true)
end

function PANEL:OnMouseReleased(m)
	if (m ~= MOUSE_LEFT) then return end
	local menu = DermaMenu()

	menu:AddOption(L"copy_item_id", function()
		GAS:SetClipboardText(self.ItemInfo.publishedfileid)
	end):SetIcon("icon16/page_copy.png")

	local open_workshop_page, _ = menu:AddSubMenu(L"open_workshop_page") _:SetIcon("materials/gmodadminsuite/steam.png")

		open_workshop_page:AddOption(L"steam_browser", function()
			GAS:OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. self.ItemInfo.publishedfileid)
		end):SetIcon("materials/gmodadminsuite/steam.png")

		open_workshop_page:AddOption(L"copy_link", function()
			GAS:SetClipboardText("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. self.ItemInfo.publishedfileid)
		end):SetIcon("icon16/page_copy.png")

	menu:AddOption(L"open_creator_profile", function()
		GAS:OpenURL("https://steamcommunity.com/profiles/" .. self.ItemInfo.creator)
	end):SetIcon("icon16/user_gray.png")

	menu:Open()
end

function PANEL:SetItemInfo(item_info)
	self.ItemInfo = item_info
	self.ItemID = tonumber(item_info.publishedfileid)

	self.Content.ItemName:SetText(item_info.title or L"error")
	self.Content.ItemName:SizeToContentsY()

	self.Content.Description:SetText(item_info.description or L"error")

	if (file.Read("gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png", "DATA")) then
		self.ItemImage:SetLoading(false)
		self.ItemImage.ImagePnl:SetImage("data/gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png")
	else
		self.ItemImage:SetLoading(true)
		http.Fetch(item_info.preview_url, function(body, len, headers, code)
			self.ItemImage:SetLoading(false)
			if (len > 0 and code == 200) then
				file.Write("gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png", body)
				self.ItemImage.ImagePnl:SetImage("data/gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png")
			else
				self.ItemImage.ImagePnl:SetImage("missing")
			end
		end)
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(40,64,87)
	surface.DrawRect(0,0,w,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	surface.DrawTexturedRect(0,0,w,h)
end

derma.DefineControl("GAS.Workshop.Item", nil, PANEL, "bVGUI.LoadingPanel")
--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_nodebackground.lua:
--[[-------------------------------------------------------------------]]--[[

	Copyright wiltOS Technologies LLC, 2021

	Contact: www.wiltostech.com

----------------------------------------]]--

























































































































































local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")
local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)
local bgWhite = Color(200,200,200)

PANEL.CreationType = WOS_PES.CREATOR.EVENT
PANEL.MatrixCore = Matrix()
PANEL.ZoomScale = 1
PANEL.PES_Element = true

function PANEL:PushBackgroundScale()
    local zoom_scale = self:GetZoomScale()
    local scale = ( 1 - zoom_scale )*0.5
    self.MatrixCore:SetScale( Vector( zoom_scale, zoom_scale, 1 ) )
    local tall, wide = self:GetTall(), self:GetWide()
    self.MatrixCore:SetTranslation( Vector( wide*scale, tall*scale, 0 ) )
    cam.PushModelMatrix(self.MatrixCore)
end

function PANEL:PopBackgroundScale()
    cam.PopModelMatrix()
end

function PANEL:Init()
    self.DirtyNodes = false
    self.LastKey = 0
    self.Nodes = {}
    self.Name = ""
    self.Links = {}

    self._x = 0
    self._y = 0

    self._tx = 0
    self._ty = 0

    self._background = vgui.Create("DButton", self)
    self._background:SetSize(1920*4, 1920*4)
    self._background:Center()
    self._background:SetText("")
    //self._background:NoClipping( true )
    self._background.PES_BACKGROUND = true
    self._background.Paint = function(sef, w, h)

        self.WasClippedDisabled = DisableClipping( true )
        self:PushBackgroundScale()

		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bgMaterial)
		surface.DrawTexturedRectUV(0,0,w,h,0,0,w*self:GetZoomScale(), h*self:GetZoomScale())

        for pnl, triggerLinks in pairs(self.Links) do
            if !IsValid(pnl) then
                self:NodeRemove(pnl)
                continue
            end

            for triggerName, panelTable in pairs(triggerLinks) do
                for index, oPnl in ipairs(panelTable) do
                    if !IsValid(oPnl) then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    local x,y = pnl:GetPos()
                    local w,h = oPnl:GetPos()
                    local posY, id, col = pnl:GetTriggerPos(triggerName)

                    if !posY then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    h = h + oPnl:GetTall()*0.5
                    y = y + posY

                    x = x + pnl:GetWide() + pnl:GetWide()*0.04
                    col = col or color_white

                    surface.SetDrawColor( col )
                    surface.DrawLine( x, y, w, h )
                end
            end
        end

        // Draw the child nodes
        for _, child in ipairs( sef:GetChildren() ) do
            if not child.RecursiveManualPaint then continue end
            child:RecursiveManualPaint()
        end

        DisableClipping( self.WasClippedDisabled )
        self:PopBackgroundScale()
    end

    local ohover = self._background.TestHover
    self._background.TestHover = function( bg, mx, my )
        mx, my = self:GetZoomedCursorPos(mx, my)
        mx, my = bg:ScreenToLocal( mx, my )
        local bx, by = bg:GetSize()
        return ( mx >= 0 ) && ( my >= 0 ) && ( mx <= bx ) && ( my <= by )
    end

    self._background.OnDepressed = function( s )
        if input.IsMouseDown( MOUSE_LEFT ) then
            self.SelectedPanel = nil
        end
        self:StartDragging()
    end

    self._background.OnReleased = function( s )
        self:StopDragging()
    end

    local tools = vgui.Create("DPanel", self)
    tools:SetWide(70)
    tools:SetHeight(self:GetTall()-60)
	tools.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
	end

    local addNode = vgui.Create("DButton", tools)
    addNode:SetSize(60,60)
    addNode:Dock(TOP)
    addNode:DockMargin(6,5,6,5)
    addNode:SetText("Add\nNode")
    addNode.DoClick = function()
		self:OpenNode()
	end
	addNode.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end

    local printEvent = vgui.Create("DButton", tools)
    printEvent:SetSize(60, 60)
    printEvent:Dock(TOP)
    printEvent:DockMargin(6,5,6,5)
    printEvent:SetText("Save\nEvent")
	printEvent.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end
    printEvent.DoClick = function( pan )
        if not self:SanityCheckNodes() then return end
        local tbl = {
            Name = "",
            oldname = self.Name,
            Nodes = {},
        }

        if self.Imported then
            tbl.oldname = ""
        end

        for index, node in ipairs(self.Nodes) do

            if node.IsOpen then
                node:NodeClose()
            end

            local eventTbl = {
                ID = node.ID,
                Type = node.Type,
                Triggers = {},
                Pos = {},
                _vars = node:GetVars(),
                _toggles = {},
            }

            eventTbl.Pos.x, eventTbl.Pos.y = node:GetPos()

            local nodeData = wOS.PES.Nodes:Get(node.Type)

            if !nodeData and node:IsStart() then
                nodeData = {Triggers = {"Instant"}}
            end

            if self.Links[node] then
                for triggerName, panelTable in pairs(self.Links[node]) do
                    local tbl = {}
                    for _, oPnl in pairs(panelTable) do
                        tbl[#tbl + 1] = oPnl.ID
                    end
                    eventTbl.Triggers[triggerName] = tbl
                end
            end

            if nodeData and nodeData.Vars then
                for name, varData in pairs( nodeData.Vars ) do // make this run a getValue on it.
                    // Why not make this one line? Because lua don't like dealing with one liners and bools apparently??
                    local var = node:GetVar( name )
                    if var == nil then
                        var = varData.Default
                    end
                    eventTbl._vars[name] = var

                    local disabled = node:GetVarDisabled( name )
                    if not disabled then continue end
                    eventTbl._toggles[name] = disabled
                end
            end

            if nodeData and nodeData.Triggers then
                for index, tdata in ipairs(nodeData.Triggers) do

                    local triggerName = tdata
                    if istable( tdata ) then
                        triggerName = tdata.Type or triggerName
                    end

                    local triggerData = wOS.PES.Triggers:Get(triggerName)
					if not triggerData then break end
                    for name, varData in pairs( triggerData.Vars ) do
                        // Why not make this one line? Because lua don't like dealing with one liners and bools apparently??
                        local var = node:GetVar( name )
                        if var == nil then
                            var = varData.Default
                        end
                        eventTbl._vars[name] = var
                        local disabled = node:GetVarDisabled( name )
                        if not disabled then continue end
                        eventTbl._toggles[name] = disabled
                    end
                end
            end

            tbl.Nodes[node.ID] = eventTbl
        end
        self:CreateSaveBox( tbl )
    end
    self._tools = tools
end

function PANEL:AddToolBox( tools )
    -- for overrides
end

function PANEL:SetupTool()
    -- for overrides
end

function PANEL:CreateSaveBox( event_tbl )
    local dummy_frame = vgui.Create( "DFrame" )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:SetDraggable( false )
    dummy_frame:ShowCloseButton( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame)
    dframe:MakePopup()
    dframe:SetSize(300, 300)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    dummy_frame.Think = function( pan )
        if not IsValid( dframe ) then
            pan:Remove()
        end
    end

    local textentry = vgui.Create("DTextEntry", dframe)
    textentry:SetSize(280, 20)
    textentry:SetPos(10, 30)
    textentry:SetPlaceholderText("Event Name")
    if self.Name != "" then
        textentry:SetText(self.Name)
    end

    local descriptentry = vgui.Create("DTextEntry", dframe)
    descriptentry:SetSize(280, 20)
    descriptentry:SetPos(10, 60)
    descriptentry:SetText( "No description available" )
    descriptentry:SetPlaceholderText("Simulation Description")
    if self.Description then
        descriptentry:SetText(self.Description)
    end

    local random = vgui.Create("DTextEntry", dframe)
    random:SetSize(280, 20)
    random:SetPos(10, 110)
    random:SetPlaceholderText("Event Randomness")
    random:SetPlaceholderText("Random Chance")
    if self.random != nil then
        random:SetText(self.random)
    end

    local randombuton = vgui.Create("DCheckBoxLabel", dframe)
    randombuton:SetSize(20,20)
    randombuton:SetPos(10, 90)
    randombuton:SetText("Start Event Randomly?")
    randombuton.OnChange = function(self, val)
        random:SetEnabled(val)
        if !val then random:SetText("") end
    end

    if self.random != nil and self.random != 0 then
        randombuton:SetChecked(true)
        random:SetEnabled(true)
    else
        random:SetEnabled(false)
    end

    local importbut = vgui.Create("DCheckBoxLabel", dframe)
    importbut:SetSize(20,20)
    importbut:SetPos(10, 140)
    importbut:SetText("Allow for import/export")
    importbut:SetChecked( self.Importable )

    local urlbut = vgui.Create("DCheckBoxLabel", dframe)
    urlbut:SetSize(20,20)
    urlbut:SetPos(10, 250)
    urlbut:SetText("Export to URL on Confirm")
    urlbut:SetChecked( false )

    local but = vgui.Create("DButton", dframe)
    but:SetSize(60, 20)
    but:SetText("Confirm")
    but:SetPos(225, 270)
    but.DoClick =  function()
        event_tbl.Name = textentry:GetText()
        if #event_tbl.Name < 1 then
            notification.AddLegacy( "[wOS-PES] Can not leave event name blank!", NOTIFY_ERROR, 3 )
            return
        end
        event_tbl.Description = descriptentry:GetText()
        event_tbl.Importable = importbut:GetChecked()
        event_tbl.random = math.Round( math.abs(tonumber(random:GetText()) or 0))
        event_tbl.Export = urlbut:GetChecked()
        dummy_frame:Remove()
        wOS.PES.NetworkEvent(event_tbl)

    end


    urlbut.OnChange = function(self, val)
        if val then
            but:SetText("Confirm and Export")
            but:SetSize(120, 20)
            but:SetPos(165, 270)
        else
            but:SetText("Confirm")
            but:SetSize(60, 20)
            but:SetPos(225, 270)
        end
    end

end

function PANEL:OnSizeChanged(nW, nH)
    self._background:Center()
    self._tools:SetHeight(nH-60)
    self._tools:SetPos(nW - self._tools:GetWide(), 30)
end

function PANEL:GetCenter()
    local aX = self._background:GetWide()/2 - self._x
    local aY = self._background:GetTall()/2 - self._y

    return aX, aY
end

function PANEL:GetZoomScale()
    return self.ZoomScale
end


    -- local base_offsetx = lcx - boundx/2
    -- local base_offsety = lcy - boundy/2
    -- local new_lcx, new_lcy = lcx - (boundx/2)*zoomscale, lcy - (boundy/2)*zoomscale
function PANEL:GetZoomedCursorPos(mx, my)
    if self:GetZoomScale() >= 1 then return mx, my end
    local bg = self._background
    local zoomscale = self:GetZoomScale()

    local ox, oy = self:LocalToScreen( self:GetPos() )
    local lcx, lcy = (ScrW() - ox*0.5)*0.5, (ScrH() - oy*0.5)*0.5
    local mouse_offx, mouse_offy = mx - lcx, my - lcy

    mx = lcx + mouse_offx/zoomscale
    my = lcy + mouse_offy/zoomscale

    return mx, my
end

function PANEL:CreateStartNode()
    local start = self:AddNode("Start", true)
    start.Type = nil
    start:CreateLinks()
    start:SetMainLink(false)
    start:SetAsStart( true )

    //I pulled this out of the node vgui because this won't always be done
    start.DeleteButton:Remove()
    start.ExpandButton:Remove()
    return start
end

function PANEL:AddNode(name, nofunc)
    local id = #self.Nodes + 1
    local x,y = self:GetCenter()
    local dbutton = vgui.Create("WOS_PES_NODE", self._background)

    dbutton.main = self
	local wide = 280 * (ScrW()/1920)
    local tall = wide*0.8
	dbutton:SetSize( wide, tall )
    dbutton:SetPos( x-wide/2, y-tall/2  )

	dbutton.ID = id
	dbutton:SetFont( "wOS.PES.NodeText" )
    dbutton.TextName = name
	dbutton.Type = name

    if not nofunc then
        dbutton:RecalculateName()
        dbutton:CreateLinks()
    end

    self.Nodes[id] = dbutton

    return dbutton
end

function PANEL:StartDragging()
    self.Dragging = true

    if IsValid(self.ViewingNode) then
        self.ViewingNode:NodeClose()
        self.ViewingNode = false
    end

    local x,y = self:GetCursorPos()

    self.mousepos = {x = x, y = y}
end

local speed = 100

function PANEL:OpenEventSelector( events )
    if self.EventList then
        self.EventList:Remove()
    end
    self.EventList = vgui.Create( "DFrame", self )
    self.EventList:SetSize( ScrW(), ScrH() )
    self.EventList:SetTitle( "" )
    self.EventList:ShowCloseButton( false )
    self.EventList:SetDraggable( false )
    self.EventList.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    self.EventList:MakePopup()

	local pnl = vgui.Create("DFrame", self)
	pnl:SetSize(ScrW() / 1.5, ScrH()/1.5)
	pnl:MakePopup()
	pnl:Center()
	pnl:SetTitle("")
	pnl:SetDraggable(false)
	pnl:ShowCloseButton(false)
	pnl.Think = function( pan )
		pan:MoveToFront()
	end
	pnl.Paint = function(self, w,h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

    self.EventList.Think = function( pan )
        if not IsValid( pnl ) then
            pan:Remove()
        end
    end


	local close = vgui.Create("DButton", pnl)
	close:SetSize(20,20)
	close:SetPos(pnl:GetWide() - 20, 0)
    close:SetText("")
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() pnl:Remove() end

	local cats = vgui.Create("DPanel", pnl)
	cats:Dock(LEFT)
	cats:SetWide(200)
	cats:DockMargin(0,0, 5, 0)

	cats.Known = {}

	local pnls = {}

	local recalculateButs

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)

	local List = vgui.Create( "DIconLayout", scroll )
	List:Dock( FILL )
	List:SetSpaceY( 10 )
	List:SetSpaceX( 10 )

	local impbutt = vgui.Create("DButton", cats)
	impbutt:Dock(BOTTOM)
	impbutt:DockMargin(4,4,4,4)
	impbutt:SetTall(20)
	impbutt:SetText( "Import From URL" )
    impbutt.DoClick = function( pan )
        pnl:Hide()
        local dframe = vgui.Create("DFrame", self.EventList )
        dframe:MakePopup()
        dframe:ShowCloseButton( false )
        dframe:SetDraggable( false )
        dframe:SetSize(300, 300)
        dframe:SetTitle( "" )
        dframe.Think = function( pan )
            pan:MoveToFront()
        end
        dframe:Center()

        local textentry = vgui.Create("DLabel", dframe )
        textentry:SetWrap( true )
        textentry:SetText("")
        textentry:SetPos( 10, 35 )
        textentry:SetSize( 280, 130 )
        textentry.Paint = function( pan, ww, hh )
            local text = "Input a URL below that leads DIRECTLY to the exported event text\n\n----------WARNING----------\n\nVERIFY THAT ALL SOURCES ARE COMPLETELY TRUSTED BEFORE IMPORTING AN EVENT!"
            text = wOS.PES.WrapText( text, "Trebuchet18", ww*0.95 )
            draw.DrawText(text, "Trebuchet18", ww/2, 0, color_white, TEXT_ALIGN_CENTER )
        end

        local utextentry = vgui.Create("DTextEntry", dframe )
        utextentry:SetSize(260, 30)
        utextentry:SetText( "INPUT URL HERE" )
        utextentry:SetPos(20, 180)

        local no = vgui.Create("DButton", dframe)
        no:SetSize(260, 20)
        no:SetText("GO BACK")
        no:SetPos(20, 260)
        no.Data = pan.Data
        no.DoClick =  function( pann )
            pnl:Show()
            dframe:Remove()
        end

        local yes = vgui.Create("DButton", dframe)
        yes:SetSize(260, 20)
        yes:SetText("FETCH EVENT")
        yes:SetPos(20, 230)
        yes.Data = pan.Data
        yes.DoClick =  function( pann )
            local text = utextentry:GetText()
            if #text < 1 then return end
            wOS.PES.RequestURLImport(text, function( data )
                local estruct = {}
                if data.Event then
                    estruct = data.Event
                else
                    estruct = data
                end
                wOS.PES:OpenNodeMenu( estruct, data.Dirty )
            end )
        end
    end

	local newbutt = vgui.Create("DButton", cats)
	newbutt:Dock(BOTTOM)
	newbutt:DockMargin(4,4,4,4)
	newbutt:SetTall(20)
	newbutt:SetText( "Create New Event" )
    newbutt.DoClick = function( pan )
        pnl:Hide()
        local dframe = vgui.Create("DFrame", self.EventList )
        dframe:MakePopup()
        dframe:ShowCloseButton( false )
        dframe:SetDraggable( false )
        dframe:SetSize(300, 100)
        dframe:SetTitle( "" )
        dframe.Think = function( pan )
            pan:MoveToFront()
        end
        dframe:Center()

        local textentry = vgui.Create("DLabel", dframe )
        textentry:SetWrap( true )
        textentry:SetText("Making a new event will completely delete any unsaved progress. Are you sure you want to create a new event?" )
        textentry:SetPos( 10, 5 )
        textentry:SetSize( 280, 65 )

        local no = vgui.Create("DButton", dframe)
        no:SetSize(60, 20)
        no:SetText("No")
        no:SetPos(25, 75)
        no.Data = pan.Data
        no.DoClick =  function( pann )
            pnl:Show()
            dframe:Remove()
        end

        local yes = vgui.Create("DButton", dframe)
        yes:SetSize(60, 20)
        yes:SetText("Yes")
        yes:SetPos(225, 75)
        yes.Data = pan.Data
        yes.DoClick =  function( pann )
            wOS.PES:OpenNodeMenu(nil,nil,true)
        end
    end

	local textentry = vgui.Create("DTextEntry", cats)
	textentry:Dock(TOP)
	textentry:DockMargin(4,4,4,4)
	textentry:SetTall(30)
	textentry.OnChange = function(self)
		recalculateButs()
	end

	local catScroll = vgui.Create("DScrollPanel", cats)
	catScroll:Dock(FILL)

	local catB = vgui.Create("DButton", catScroll)
	catB:Dock(TOP)
	catB:SetText("All")
	catB.DoClick = function()
		cats.Category = nil
		recalculateButs()
	end

	recalculateButs = function()
		local value = string.lower(textentry:GetText())

		for index, col in ipairs(pnls) do
			if string.find(string.lower(col.Name), value) and ( not cats.Category or ( col.Category == cats.Category)) then
				col:Show()
			else
				col:Hide()
			end
		end
		List:Layout()
	end

	for _, data in ipairs( events ) do
        local button = List:Add("DButton")
		button:SetSize(200, 200)
		button:SetText("")
		button.Name = data.Name
        button.Data = data

		local nam = wOS.PES.WrapText(data.Name, "wOS.PES.NodeText", button:GetWide()*0.9 )
		local descript = wOS.PES.WrapText(data.Description or "No description available", "DermaDefault", button:GetWide()*0.9 )

		button.Paint = function(self, w,h)
			draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
			draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))

            local offset = h*0.02
            draw.DrawText(nam, "wOS.PES.NodeText", w/2, offset, color_black, TEXT_ALIGN_CENTER )

            surface.SetFont( "wOS.PES.NodeText" )
            local _, dH = surface.GetTextSize( nam )
            offset = offset + dH * 1.2

			draw.DrawText(descript, "DermaDefault", w*0.05, offset, color_black, TEXT_ALIGN_LEFT )

            //Add more as we go along
            if data.IsSimulation then
                draw.SimpleText("SIMULATION", "wOS.PES.CategoryText", w/2, h*0.98, Color( 0, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            else
                draw.SimpleText("EVENT", "wOS.PES.CategoryText", w/2, h*0.98, Color( 0, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            end
		end

		button.DoClick = function( pan )

            pnl:Hide()
            local dframe = vgui.Create("DFrame", self.EventList )
            dframe:MakePopup()
            dframe:ShowCloseButton( true )
            dframe:SetDraggable( false )
            dframe:SetSize(300, 100)
            dframe:SetTitle( "" )
            dframe.Think = function( pan )
                pan:MoveToFront()
            end
            dframe.OnClose = function()
                self.EventList:Remove()
            end
            dframe:Center()

            local textentry = vgui.Create("DLabel", dframe )
            textentry:SetWrap( true )
            textentry:SetText("Loading a new layout will completely delete any unsaved progress. Are you sure you want to load this event?\n    NAME: " .. pan.Data.Name )
            textentry:SetPos( 10, 20 )
            textentry:SetSize( 280, 65 )

            local no = vgui.Create("DButton", dframe)
            no:SetSize(60, 20)
            no:SetText("No")
            no:SetPos(25, 75)
            no.Data = pan.Data
            no.DoClick =  function( pann )
                pnl:Show()
                dframe:Remove()
            end

            local yes = vgui.Create("DButton", dframe)
            yes:SetSize(60, 20)
            yes:SetText("Yes")
            yes:SetPos(225, 75)
            yes.Data = pan.Data
            yes.DoClick =  function( pann )
                if pann.DisableButt then return end
                pann.DisableButt = true
                no:Hide()
                yes:Hide()
                textentry:SetText("Fetching your requested layout from the server..\n\nNOTE: This may take a few seconds depending on the size" )
                if pann.Data.IsSimulation then
                    wOS.PES.RequestSimulationData(pann.Data.Name, function( simdata )
                        if not IsValid( self.EventList ) then return end
                        wOS.PES:OpenNodeMenu( simdata.Event, true )
                    end, pann.Data.ID )
                else
                    wOS.PES.RequestEventData(pann.Data.Name, function( simdata )
                        if not IsValid( self.EventList ) then return end
                        wOS.PES:OpenNodeMenu( simdata )
                    end )
                end
            end

		end
		button.Category = data.Category

		if data.Category and not cats.Known[data.Category] then
			local category = data.Category
			cats.Known[category] = true
			local catB = vgui.Create("DButton", catScroll)
			catB:Dock(TOP)
			catB:SetText(category)
			catB.DoClick = function( pan )
				cats.Category = category
				recalculateButs()
			end
		end

		pnls[#pnls + 1] = button
	end
end

function PANEL:OpenEventDeleter()

    local dummy_frame = vgui.Create( "DFrame", self )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame )
    dframe:MakePopup()
    dframe:ShowCloseButton( false )
    dframe:SetDraggable( false )
    dframe:SetSize(300, 100)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    local textentry = vgui.Create("DLabel", dframe )
    textentry:SetWrap( true )
    textentry:SetText("This action can not be undone. Are you sure you want to delete this event?" )
    textentry:SetPos( 10, 5 )
    textentry:SetSize( 280, 65 )

    local no = vgui.Create("DButton", dframe)
    no:SetSize(60, 20)
    no:SetText("Cancel")
    no:SetPos(25, 75)
    no.DoClick =  function( pann )
        dummy_frame:Remove()
    end

    local yes = vgui.Create("DButton", dframe)
    yes:SetSize(60, 20)
    yes:SetText("Delete")
    yes:SetPos(225, 75)
    yes.DoClick =  function( pann )
        if self.CreationType == WOS_PES.CREATOR.EVENT then
            net.Start( "wOS.PES.RequestEventDelete" )
                net.WriteString( self.Name )
            net.SendToServer()
        elseif self.CreationType == WOS_PES.CREATOR.SIMULATION then
            net.Start( "wOS.CSS.RequestSimDelete" )
                net.WriteString( self.Name )
            net.SendToServer()

            net.Start("wOS.CombatSim.ResetTool")
            net.SendToServer()
            hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )
            self:GetParent():Remove()
            return
        else return end

        wOS.PES:OpenNodeMenu(nil,nil,true)
    end

end

function PANEL:OpenNode()

    local dummy_frame = vgui.Create( "DFrame", self )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

	local pnl = vgui.Create("DFrame", self)
	pnl:SetSize(ScrW() / 1.5, ScrH()/1.5)
	pnl:MakePopup()
	pnl:Center()
	pnl:SetTitle("")
	pnl:SetDraggable(false)
	pnl:ShowCloseButton(false)
	pnl.Think = function( pan )
		pan:MoveToFront()
	end
	pnl.Paint = function(self, w,h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

    dummy_frame.Think = function( pan )
        if not IsValid( pnl ) then
            pan:Remove()
        end
    end


	local close = vgui.Create("DButton", pnl)
	close:SetSize(20,20)
	close:SetPos(pnl:GetWide() - 20, 0)
    close:SetText("")
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() pnl:Remove() end

	local cats = vgui.Create("DPanel", pnl)
	cats:Dock(LEFT)
	cats:SetWide(200)
	cats:DockMargin(0,0, 5, 0)

	cats.Known = {}

	local pnls = {}

	local recalculateButs

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)

	local List = vgui.Create( "DIconLayout", scroll )
	List:Dock( FILL )
	List:SetSpaceY( 10 )
	List:SetSpaceX( 10 )

	local textentry = vgui.Create("DTextEntry", cats)
	textentry:Dock(TOP)
	textentry:DockMargin(4,4,4,4)
	textentry:SetTall(30)
	textentry.OnChange = function(self)
		recalculateButs()
	end

	local catScroll = vgui.Create("DScrollPanel", cats)
	catScroll:Dock(FILL)

	local catB = vgui.Create("DButton", catScroll)
	catB:Dock(TOP)
	catB:SetText("All")
	catB.DoClick = function()
		cats.Category = nil
		recalculateButs()
	end

	recalculateButs = function()
		local value = string.lower(textentry:GetText())

		for index, col in ipairs(pnls) do
			if string.find(string.lower(col.Name), value) and ( not cats.Category or ( col.Category == cats.Category)) then
				col:Show()
			else
				col:Hide()
			end
		end
		List:Layout()
	end

	local tbl = wOS.PES.Nodes:GetAll()

	for name, data in SortedPairs(tbl) do
        if data.Hidden then continue end
        if data.UserGroups then
            if not table.HasValue( data.UserGroups, LocalPlayer():GetUserGroup() ) then continue end
        end
        if data.SupportedTypes then
            local block = data.SupportedTypes != self.CreationType
            if istable( data.SupportedTypes ) then
                block = !table.HasValue( data.SupportedTypes, self.CreationType )
            end
            if block then continue end
        end
        local button = List:Add("DButton")
		button:SetSize(200, 200)
		button:SetText("")
		button.Name = name

		local nam = wOS.PES.WrapText(data.Name, "wOS.PES.NodeText", button:GetWide()*0.9 )
		local descript = wOS.PES.WrapText(data.Description, "DermaDefault", button:GetWide()*0.9 )

		button.Paint = function(self, w,h)
			draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
			draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))

            local offset = h*0.02
            draw.DrawText(nam, "wOS.PES.NodeText", w/2, offset, color_black, TEXT_ALIGN_CENTER )

            surface.SetFont( "wOS.PES.NodeText" )
            local _, dH = surface.GetTextSize( nam )
            offset = offset + dH * 1.2

			draw.DrawText(descript, "DermaDefault", w*0.05, offset, color_black, TEXT_ALIGN_LEFT )
		end

		button.DoClick = function( pan )
			self:AddNode(name)
			pnl:Remove()
		end

		button.Category = data.Category

		if data.Category and not cats.Known[data.Category] then
			local category = data.Category
			cats.Known[category] = true
			local catB = vgui.Create("DButton", catScroll)
			catB:Dock(TOP)
			catB:SetText(category)
			catB.DoClick = function( pan )
				cats.Category = category
				recalculateButs()
			end
		end

		pnls[#pnls + 1] = button
	end
end

function PANEL:DragThink()
    local x,y = self:GetCursorPos()
    if !self.mousepos then
        self.mousepos = {x = x, y = y}
    end
    local dX = x - self.mousepos.x
    local dY = y - self.mousepos.y

    local oldMouseY = self.mousepos.y
    self.mousepos = {x = x, y = y}

    self._tx = dX + self._x
    self._ty = dY + self._y
    local posChanged = false

    if self.tx != self._x then
        posChanged = true
        self._x = math.Approach(self._x, self._tx, FrameTime() * speed*self:GetWide())
    end

    if self.ty != self._y then
        local x,y = self._background:GetPos()

        posChanged = true
        self._y = math.Approach(self._y, self._ty, FrameTime() * speed*self:GetTall())
    end

    if posChanged then
        local aX = self:GetWide()/2 -self._background:GetWide()/2
        local aY = self:GetTall()/2 -self._background:GetTall()/2
        local x,y = self._background:GetPos()

        self._background:SetPos( aX+self._x,  aY + self._y)
    end
end

function PANEL:CopyNode()
    if not IsValid( self.SelectedPanel ) then return end
    if self.SelectedPanel:IsStart() then return end
    LocalPlayer():EmitSound( "garrysmod/balloon_pop_cute.wav", 75, 75 )
    self.StoredPanel = self.SelectedPanel:GetCopy()
end

function PANEL:PasteNode()
    if not self.StoredPanel then return end
    LocalPlayer():EmitSound( "garrysmod/balloon_pop_cute.wav", 75, 130 )
    local node = self:AddNode(self.StoredPanel.Type)

    node:SetVars( table.Copy( self.StoredPanel.Vars ) )
	node:SetDisableVars( table.Copy( self.StoredPanel.Toggles ) )
    local bx, by = self:GetCenter()
    local mx, my = self:GetCursorPos()
    mx = mx - ScrW()/2
    my = my - ScrH()/2
    local sw, sh = node:GetSize()
    node:SetPos( bx + mx - sw/2, by + my - sh/2 )
end

function PANEL:CutNode()
    if not IsValid( self.SelectedPanel ) then return end
    if self.SelectedPanel:IsStart() then return end
    self:CopyNode()
    self:NodeRemove(self.SelectedPanel)
end

function PANEL:ComboThink()

    if input.IsKeyDown( KEY_DELETE ) then
        if not IsValid( self.SelectedPanel ) then return end
        self:NodeRemove( self.SelectedPanel )
        self.SelectedPanel = nil
        self.LastKey = 0
        return
    end

    // Yo I hate the way this is done but it pretty much ensures you don't accidentally fuck a node up, so it stays until a better way

	// one for loop and if it doesn't break check last key?
	if input.IsKeyDown( KEY_LCONTROL ) || input.IsKeyDown( KEY_RCONTROL ) then
        if input.IsKeyDown( KEY_C ) then
            self.LastKey = KEY_C
        elseif input.IsKeyDown( KEY_V ) then
            self.LastKey = KEY_V
        elseif input.IsKeyDown( KEY_X ) then
            self.LastKey = KEY_X
        else
            if self.LastKey == KEY_C then
                self:CopyNode()
            elseif self.LastKey == KEY_V then
                self:PasteNode()
            elseif self.LastKey == KEY_X then
                self:CutNode()
            end
            self.LastKey = 0
        end
    end
end

function PANEL:OnMouseWheeled( delta )
    if not (input.IsKeyDown( KEY_LCONTROL ) || input.IsKeyDown( KEY_RCONTROL )) then return end
    self.ZoomScale = math.Clamp( self.ZoomScale + delta*0.02, 0.1, 1 )
end


function PANEL:Think()

    if not self.ToolBoxHook then
        self:AddToolBox( self._tools )
        self.ToolBoxHook = true
    end

    if self.Dragging then
        self:DragThink()
        return
    end

    self:ComboThink()

end

function PANEL:StopDragging()
    self.Dragging = false
end

/*
	Name: wOS.PES:MakeLink(pnl, oPnl, type)
	Description: Make a link to a node using the trigger Type
	Args: Panel pnl, Panel oPnl, String type
	Returns: boolean success
*/
function PANEL:MakeLink(pnl, oPnl, type)
    if pnl == oPnl then return false end
    if not oPnl then return false end
    if not oPnl:GetMainLink() then return false end
    self.Links[pnl] = self.Links[pnl] || {}
    self.Links[pnl][type] = self.Links[pnl][type] || {}
    if table.HasValue(self.Links[pnl][type], oPnl) then return false end
    table.insert(self.Links[pnl][type], oPnl)
	return true
end

/*
	Name: wOS.PES:RemoveLink(pnl, type, oPnl = nil)
	Description: Removes either a single link of all links of the trigger type
	Args: Panel pnl, String type, Panel oPnl
	Returns: boolean success
*/

function PANEL:RemoveLink(pnl, type, oPnl)
    if not self.Links[pnl] then return false end
    if not self.Links[pnl][type] then return false end

    if oPnl then
        table.RemoveByValue(self.Links[pnl][type],oPnl)
    else
        self.Links[pnl][type] = {}
    end

    return true
end

function PANEL:GetLinks(pnl)
    return self.Links[pnl] || {}
end

/*
	Name: wOS.PES:NodeRemove(node)
	Description: Removes a node from the menu
	Args: Panel node
	Returns: boolean success
*/
function PANEL:NodeRemove(node)
    if node:IsStart() then return false end
    self.Links[node] = nil

    local id = 1

    if IsValid(node) then
        node:Remove()
    end

    local invalidIndexs = {}

    for index, node in ipairs(self.Nodes) do
        if !IsValid(node) then
            invalidIndexs[#invalidIndexs + 1] = index
        else
            node.ID = id
            id = id + 1
            if not node:IsStart() then
                node:RecalculateName()
            end
        end
    end

    for x = 1, #invalidIndexs do
        table.remove(self.Nodes,invalidIndexs[#invalidIndexs])
    end
	return true
end

function PANEL:SelectNode( pan )
    self.SelectedPanel = nil
    if not IsValid( pan ) then return end
    self.SelectedPanel = pan
end

function PANEL:SanityCheckNodes()
    local TK_OK = true
    local ends = false
    for index, node in ipairs(self.Nodes) do
        if node.Type == "End" then
            ends = true
        end
        node:RecalculateDirty()
        if not node.NodeDirty then continue end
        TK_OK = false
    end

    if not TK_OK then
        surface.PlaySound( "buttons/button10.wav" )
        notification.AddLegacy( "[wOS-PES] Event could not be saved: Nodes have unresolved errors ( make sure all variables are filled out! )", NOTIFY_ERROR, 3 )
    end

    if not ends then
        TK_OK = false
        surface.PlaySound( "buttons/button10.wav" )
        notification.AddLegacy( "[wOS-PES] Event could not be saved: No END node to terminate event logic ( infinite events consume memory )", NOTIFY_ERROR, 3 )
    end

    return TK_OK
end

function PANEL:Paint()
    local globs = vgui.GetWorldPanel():GetChildren()
    for _, child in ipairs( globs ) do
        local class = child:GetClassName()
        if not ( child.SetLegacyType ) and not ( child.StartTime and child.fx and child.fy ) then continue end
        child:MakePopup()
    end
end

function PANEL:GetCursorPos()
    return self:GetZoomedCursorPos( input.GetCursorPos() )
end

vgui.Register( "WOS_PES_NodeBG", PANEL, "Panel" )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/tentity.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "TableEntity"
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the entity you are aiming at to the list", key = "gui/lmb.png", },
    { text = "Remove the last added entity from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

    if varTable.Internal then return false end
    if not value or #value < 1 then
        return false
    end
    
    for index, data in pairs(value) do
        if not data.Index then continue end
        local ent = ents.GetByIndex(data.Index)
        if IsValid(ent) then
            if ent:CreatedByMap() then
                value[index] = {
                    mapID = data.Index,
                }
            else
                value[index] = wOS.PES.ReadEntity(ent)
            end
        end
    end

    return true
end

VAR.UseTool = true

VAR.DermaElement = function(varTable, varData)
    varData = varData or {}
    local element = vgui.Create("DModelPanel")
    
    element.Data = {}
    for index, data in pairs( varData ) do
        if data.mapID then
            local ent = ents.GetByIndex( data.mapID )
            element.Data[ index ] =  {
                Position =  ent:GetPos(),
                Index = data.mapID,
            }
            continue
        end
        element.Data[ index ] = data
    end

    return element -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        local ent = dermaElement.Data[1]
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data[#dermaElement.Data + 1] = {
            Position = ent:GetPos(),
            Index = ent:EntIndex()
        }
        ply:ChatPrint( "Entity Added: " .. ent:GetClass() )
    end
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}
    dermaElement.Data[#dermaElement.Data] = nil
end

VAR.OnStart = function(node, varData, var)
    local tEnts = {}
    for index, entData in ipairs(varData || {}) do
        local ent
        if entData.mapID then
            ent = ents.GetByIndex(entData.mapID)
        else
            ent = wOS.PES:SpawnEntity(entData)
        end

        if not ent then continue end 

        if not istable( ent ) then
            tEnts[#tEnts + 1] = ent
            continue
        end

        -- for _, entity in pairs( ent ) do
        --     if not IsValid( entity ) then continue end
        --     tEnts[#tEnts + 1] = entity
        -- end

    end
    
    node:SetVar(var.Name, tEnts)

    return #tEnts != 0

end

VAR.OnEnd = function(node, varData, var)
    if not node:ShouldCleanAll() then return end
    for index, ent in ipairs(varData || {}) do
        if IsValid(ent) and !ent:CreatedByMap() then
            ent:SetSaveValue( "m_bFadingOut", true )
            ent:Remove()
        end
    end
end

/*
		Angles	=	-0.125 104.219 0.125
		Class	=	prop_physics
		Color:
				a	=	255
				b	=	255
				g	=	255
				r	=	255
		Model	=	models/props_borealis/bluebarrel001.mdl
		Pos	=	-3299.468750 -2135.687500 90.125000
		SubMaterials:
*/

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Data || {}

    for index, ent in ipairs(tVec) do
        if not isvector(ent.Position) then continue end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/tvector.lua:
--[[-------------------------------------------------------------------]]--[[
                            
Copyright wiltOS Technologies LLC, 2021

Contact: www.wiltostech.com
    
----------------------------------------]]--


local VAR = {}

VAR.Name = "TableVector"
VAR.UseTool = true
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the position you are AIMING AT to the list", key = "gui/lmb.png", },
    { text = "Add your current EYE position to the list", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position to the list", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not istable( value ) then return false end
    if table.Count(value) == 0 then return false end

    for index, vec in ipairs(value) do
        if not isvector( vec ) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    panel.Values = value

    function panel:Paint(ww, hh) end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Vector")
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Values or #panel.Values < 1 then
            pan:AddLine( "Vector needs to be set!" )
            return
        end

        for id, vec in pairs( panel.Values or {} ) do
            local line = pan:AddLine( vec )
            line.ID = id
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
        table.remove( panel.Values, line.ID )
        pan:RefreshList()
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Values || {}
end

VAR.PrimaryAttack = function(wep, ply, panel)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    panel.Values = panel.Values || {}
    panel.Values[#panel.Values + 1] = pos
    panel:RefreshList()
end

VAR.SecondaryAttack = function(wep, ply, panel)
    panel.Values = panel.Values || {}
    panel.Values[#panel.Values] = nil
end

VAR.OnStart = function(node, value, var)

    local val  = {}

    for index, vec in ipairs(value) do
        if !isvector(vec) then

            vec = Vector(vec)
            if vec then
                val[index] = vec
                continue
            end
        end
        val[index] = vec
    end
    node:SetVar(var.Name, val)
end

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Values || {}
    for index, vec in ipairs(tVec) do
        if not isvector(vec) then continue end

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end


return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/core/cl_admin_menu.lua:

// This is the admin config in game editor
function wOS.PES:OpenAdminSettings()
	local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Admin Menu" )
	local size = ScrH()*(512/1080)
	pnl:SetSize(size, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	pnl.Paint = function(self, w , h)
		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0,0, w, h)
	end

	local txtentry = vgui.Create("DTextEntry", pnl)
	txtentry:Dock(TOP)
	txtentry:DockMargin(10, 5, 10, 0)

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)
	scroll:DockMargin(5,5,5,5)

	local savebutton = vgui.Create("DButton", pnl)
	savebutton:Dock(BOTTOM)
	savebutton:SetText("Save Settings")
	savebutton:DockMargin(5,5,5,5)

	local varDerma = {}

	savebutton.DoClick = function()
		local changes = {}

		for name, data in pairs(wOS.PES.Settings.GetList()) do
			local varType = wOS.PES.Vars:Get(data.Type)
			if not varType then continue end
			local oldValue = wOS.PES.Settings.Get(name)
			local element = varDerma[name]
			local value = varType.GetValue(element)
			if value == oldValue then continue end
			changes[name] = value
		end

		local maxAmount = table.Count(changes)
		if maxAmount == 0 then
			ErrorNoHalt("Something went wrong no changes found, are you sure you changed something?")
		end
		
		net.Start("wOS.PES.RequestSettings")
			net.WriteUInt(table.Count(changes), 8)
			-- record the changes in a table

			for name, value in pairs(changes) do
				net.WriteString(name)
				net.WriteType(value) // might want to be changed to Table?
			end
		net.SendToServer()
	end

	for name, data in pairs(wOS.PES.Settings.GetList()) do
		local dbutton = vgui.Create("DButton", scroll)
		dbutton:Dock(TOP)
		dbutton:SetText(name)

		local varType = wOS.PES.Vars:Get(data.Type)
		local value = wOS.PES.Settings.Get(name)

		local element = varType.DermaElement(data, value)

        local back = vgui.Create("DPanel", scroll)

        if !IsValid(element) then
            element = vgui.Create("DPanel")
        end

        element:SetParent(back)
        element:Dock(TOP)
        element:DockMargin(2,2,2,2)
        element._catderma = cat
        element.varTable = varTable

        back.element = element

		varDerma[name] = element

		back:Dock(TOP)
		back:DockMargin(0, 0,0,30)

        if varType.UseTool then
            local useTool = vgui.Create("DButton", back)
            useTool:Dock(TOP)
            useTool:DockMargin(8,2,8,2)
            useTool:SetTall(30)
            useTool:SetText("Sadly we don't support this yet")
            useTool.DoClick = function() end
        end

		dbutton.DoClick = function()
			if back:GetTall() <= 0 then
				back:SetTall(back._OldSize)
			else
				back._OldSize = back:GetTall()
				back:SetTall(0)
			end
		end
	end

	return pnl
end

// Scheduled event manager
function wOS.PES:OpenScheduledMenu()
	local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Admin Menu" )
	local size = 512*(ScrH()/1080)
	pnl:SetSize(size, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	pnl.Paint = function(self, w , h)
		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0,0, w, h)
		
		if not self.Loaded then
			draw.SimpleText("Loading Data ...", "DermaDefault", w/2, h/2,  color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			return
		end
		if not self.NoData then return end
		draw.SimpleText("No events scheduled", "DermaDefault", w/2, h/2,  color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	wOS.PES.RequestSchedule(function(eventList)
		pnl.Selected = nil
		pnl.EventList = eventList
		if IsValid(pnl.Scroll) then
			pnl.Scroll:Remove()
		else
			if IsValid( pnl.selectButton ) then
				pnl.selectButton:Remove()
			end
			local selectButton = vgui.Create("DButton", pnl)
			selectButton:Dock(BOTTOM)
			selectButton:SetText("Remove Event")

			selectButton.DoClick = function()
				if not pnl.Selected then return end
				local id = pnl.Selected
				if not pnl.EventList then return end
				if not pnl.EventList[id] then return end
				net.Start("wOS.PES.RequestScheduleDelete")
					net.WriteString(pnl.EventList[id].Name)
					net.WriteDouble(pnl.EventList[id].Time)
				net.SendToServer()
			end
			pnl.selectButton = selectButton
		end

		pnl.Loaded = true
		if table.Count(pnl.EventList) == 0 then
			pnl.NoData = true
		else
			local scroll = vgui.Create("DScrollPanel", pnl)
			scroll:Dock(FILL)
			scroll:DockMargin(5,5,5,5)

			for index, data in SortedPairsByMemberValue(pnl.EventList, "Time", true) do
				local dbutton = vgui.Create("DButton", scroll)
				dbutton:Dock(TOP)
				dbutton:SetText(data.Name .. "    " .. data.Map .. "   " .. os.date( "%H:%M:%S - %d/%m/%Y" , data.Time ))
				dbutton.ID = index
				dbutton.DoClick = function( pan )
					pnl.Selected = pan.ID
				end
				dbutton.Paint = function(pan, w, h)
					if pnl.Selected != pan.ID then
						surface.SetDrawColor(255,255,255)
					else
						surface.SetDrawColor(200,200,200)
					end
					surface.DrawRect(0,0, w, h)
				end
			end
			pnl.Scroll = scroll
		end
	end)

	return pnl
end
--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_net.lua:


function net.WriteActivePESEvent(event)
	if table.IsEmpty(event) then
		net.WriteUInt(0, 1)
	else
		net.WriteUInt(1, 1)
		net.WriteTable(event) // For now this is what we will go with but should optimise further than this
	end
end

// This exists because we want to be consistent under the hood, for when we optimise this packet
function net.ReadActivePESEvent() 
	local valid = net.ReadUInt(1)
	if valid == 1 then
		return net.ReadTable()
	else
		return {}
	end
end

function net.WritePESEventHeader(event, dirty)
	net.WriteString(event.Name)
	net.WriteString(event.Description or "No description available")
	net.WriteUInt(#event.Nodes, 32)
	net.WriteDouble(event.random or 0)
	net.WriteBool( event.Importable )
	net.WriteBool( dirty or false )
end

function net.ReadPESEventHeader()
	local event = {}
	event.Name = net.ReadString()
	event.Description = net.ReadString()
	event.NodeCount = net.ReadUInt(32)
	event.random = net.ReadDouble()
	event.Importable = net.ReadBool()
	event.Dirty = net.ReadBool()

	return event
end

function net.WriteCSSSimulationHeader( simdata, dirty )

	net.WriteTable( simdata.Settings )
	net.WriteBool( simdata.Importable )

end


function net.ReadCSSSimulationHeader()
	local sim = {}
	sim.Settings = net.ReadTable()
	sim.Importable = net.ReadBool()
	sim.Event = {}
	sim.Dirty = true
	
	return sim
end 

//////////////////////////////////////////////////////////////////////
--addons/wos-passiveevent-ageo/lua/wos/css/loader/loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

if CLIENT then
	include( "wos/css/config/sh_config.lua" )

	include( "wos/css/vgui/wos_css_scrollpanel.lua" )
	include( "wos/css/vgui/wos_css_nodebackground.lua" )
	
	include( "wos/css/core/cl_core.lua" )
	include( "wos/css/core/cl_admin_menu.lua" )
	include( "wos/css/core/cl_net.lua" )	

	include( "wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua")
	include( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua" )

	include( "wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua")
	include(  "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua" )

	include( "wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua")
	include(  "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua" )

	include(  "wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua" )

end

if SERVER then
	AddCSLuaFile( "wos/css/config/sh_config.lua" )

	include( "wos/css/config/sh_config.lua" )
	include( "wos/css/config/sv_config.lua" )
	
	AddCSLuaFile( "wos/css/vgui/wos_css_scrollpanel.lua" )
	AddCSLuaFile( "wos/css/vgui/wos_css_nodebackground.lua" )

	AddCSLuaFile( "wos/css/core/cl_core.lua" )
	AddCSLuaFile( "wos/css/core/cl_admin_menu.lua" )
	AddCSLuaFile( "wos/css/core/cl_net.lua" )
	
	wOS.PES:ServerInclude( "wos/css/core/sv_net.lua" )
	wOS.PES:ServerInclude( "wos/css/core/sv_core.lua" )
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua")
	include( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_system/sv_wos_simulation_system.lua")
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua")
	include(  "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_tool/sv_wos_simulation_tool.lua")
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua")
	include(  "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_wall/sv_wos_simulation_wall.lua")

	wOS.PES:ServerInclude( "wos/css/entities/wos_pes_basiczone/sv_wos_pes_basiczone.lua")	

	AddCSLuaFile( "wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua")
	wOS.PES:ServerInclude( "wos/css/entities/wos_pes_basicobj/sv_wos_pes_basicobj.lua")	

	include( "wos/css/wrappers/sv_data.lua" )
	wOS.PES:ServerInclude( "wos/css/core/sv_wrapper.lua")

end
--gamemodes/starwarsrp/entities/weapons/aoc_st_stab.lua:
SWEP.Category                 = "AOCRP - Eingestellte Waffen"
SWEP.PrintName                = "Schockstab"            
SWEP.Author                    = "Lt. Sammy"
SWEP.Instructions            = ""
SWEP.Spawnable                 = true
SWEP.AdminOnly                 = false
SWEP.HoldType = "melee2"
SWEP.Primary.ClipSize        = -1
SWEP.Primary.DefaultClip    = -1
SWEP.Primary.Automatic        = true
SWEP.Primary.Ammo            = "None"
SWEP.Secondary.ClipSize        = -1
SWEP.Secondary.DefaultClip    = -1
SWEP.Secondary.Automatic    = true
SWEP.Secondary.Ammo            = "None"
SWEP.Weight                    = 3
SWEP.AutoSwitchTo            = false
SWEP.AutoSwitchFrom            = false
SWEP.Slot                    = 0
SWEP.SlotPos                = 4
SWEP.DrawAmmo                = false
SWEP.DrawCrosshair            = true

local FireSound 			= Sound ("weapons/smack.wav"); 
local MissSound			= Sound ("weapons/miss.wav");



SWEP.ViewModelFOV = 66.733668341709
SWEP.ViewModelFlip = false
SWEP.UseHands = false
SWEP.ViewModel = "models/weapons/c_stunstick.mdl"
SWEP.WorldModel = "models/tfa/comm/gg/prp_magna_guard_weapon_combined.mdl"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["FX+++"] = { type = "Sprite", sprite = "particle/bendibeam", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-38.961, 0, 0), size = { x = 5.556, y = 5.556 }, color = Color(255, 176, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = true},
	["FX+"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-36.883, 0, 0), size = { x = 5.7, y = 5.7 }, color = Color(255, 196, 0, 190), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = true},
	["FX++"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-38.961, 0, 0), size = { x = 5.7, y = 5.7 }, color = Color(255, 196, 0, 190), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = true},
	["FX"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-41.04, 0, 0), size = { x = 5.7, y = 5.7 }, color = Color(255, 196, 0, 190), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = true},
	["Staff"] = { type = "Model", model = "models/tfa/comm/gg/prp_magna_guard_weapon_season4.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, -5.715, 3.635), angle = Angle(73.636, 45.583, 0), size = Vector(1, 1.1, 1.1), color = Color(209, 204, 203, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["FX++++"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-36.883, 0, 0), size = { x = 5.751, y = 5.751 }, color = Color(255, 196, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["FX++"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(38.96, 0, 0), size = { x = 5.751, y = 5.751 }, color = Color(255, 196, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["FX"] = { type = "Sprite", sprite = "particle/bendibeam", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(36.882, 0, 0), size = { x = 5, y = 5 }, color = Color(255, 193, 0, 255), nocull = true, additive = true, vertexalpha = false, vertexcolor = true, ignorez = false},
	["Staff"] = { type = "Model", model = "models/tfa/comm/gg/prp_magna_guard_weapon_season4.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 1.6, 0), angle = Angle(78.311, 80.649, 31.558), size = Vector(0.95, 1.2, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["FX+++"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-34.806, 0, 0), size = { x = 5.751, y = 5.751 }, color = Color(255, 196, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["FX+"] = { type = "Sprite", sprite = "particle/bendibeam", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-36.883, 0, 0), size = { x = 5, y = 5 }, color = Color(255, 193, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["FX+++++++"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(36.882, 0, 0), size = { x = 5.751, y = 5.751 }, color = Color(255, 196, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["FX+++++"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(-38.961, 0, 0), size = { x = 5.751, y = 5.751 }, color = Color(255, 196, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["FX++++++"] = { type = "Sprite", sprite = "particle/particle_glow_04", bone = "ValveBiped.Bip01_R_Hand", rel = "Staff", pos = Vector(34.805, 0, 0), size = { x = 5.751, y = 5.751 }, color = Color(255, 196, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}


SWEP.ReloadDelay = 0
SWEP.CurrentState = 1

local stateToHoldType = {} 
stateToHoldType[1] = "melee2"
stateToHoldType[2] = "knife"
stateToHoldType[3] = "slam"

function SWEP:Equip() 
    --self:EmitSound("armas3/vibro_equip.ogg")
    self:SetHoldType(stateToHoldType[1] )
end


function SWEP:Deploy() 
    self:EmitSound("armas3/vibro_equip.ogg")
end


function SWEP:PrimaryAttack()
    
    self.Weapon:SetNextPrimaryFire( CurTime() + 1.2 )
    
     local trace = self.Owner:GetEyeTrace();
    if trace.HitPos:Distance(self.Owner:GetShootPos()) <= 100 then
            self.Owner:SetAnimation( PLAYER_ATTACK1 );
            self.Weapon:SendWeaponAnim( ACT_VM_HITCENTER );
                bullet = {}
                bullet.Num    = 1
                bullet.Src    = self.Owner:GetShootPos()
                bullet.Dir    = self.Owner:GetAimVector()
                bullet.Spread = Vector(0, 0, 0)
                bullet.Tracer = 0
                bullet.Force  = 3
                bullet.Damage = 50
            self.Owner:FireBullets(bullet)
            self.Weapon:EmitSound( FireSound )            
    else
        self.Owner:SetAnimation( PLAYER_ATTACK1 );
        self.Weapon:SendWeaponAnim( ACT_VM_HITCENTER );
        self.Weapon:EmitSound( MissSound )
    end
    
    self.Weapon:SetNextPrimaryFire( CurTime() + 1.2 )
end


function SWEP:Reload() 
    if SERVER then 
    if !IsFirstTimePredicted() then return end
    if CurTime() > self.ReloadDelay then 
        
        self.ReloadDelay = CurTime() + 1 

        self.CurrentState = self.CurrentState + 1
        if self.CurrentState > #stateToHoldType then 
            self.CurrentState = 1
        end 

        
        self:SetHoldType(stateToHoldType[self.CurrentState])
 
    end 
    end
end



function SWEP:SecondaryAttack()
    
    if !IsFirstTimePredicted() then return end 
    self:SetNextSecondaryFire(CurTime()+1)


    self.Owner:SetAnimation( PLAYER_ATTACK1 );
    self.Weapon:SendWeaponAnim( ACT_VM_HITCENTER );

    if !SERVER then return end 
 
        local trace = self.Owner:GetEyeTrace();
        if trace.HitPos:Distance(self.Owner:GetShootPos()) <= 100 and IsValid(trace.Entity) then

            self.Owner:EmitSound( FireSound )         
            GMSERV:AddStatus(trace.Entity, self.Owner, "stun", 5, 5, false) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
        else
            print("penis")
            self.Owner:EmitSound( MissSound )
        end

end 

/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	self:SetWeaponHoldType( "melee2" )

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

--addons/arccw_base_modified/lua/weapons/arccw_base/sh_freeaim.lua:
local ang0 = Angle(0, 0, 0)
SWEP.ClientFreeAimAng = Angle(ang0)

function SWEP:ShouldFreeAim()
    if self:GetOwner():IsNPC() then return false end
    if (ArcCW.ConVars["freeaim"]:GetInt() == 0 or self:GetBuff_Override("NeverFreeAim", self.NeverFreeAim))  and !self:GetBuff_Override("AlwaysFreeAim", self.AlwaysFreeAim) then return false end
    return true
end

function SWEP:FreeAimMaxAngle()
    local ang = self.FreeAimAngle and self:GetBuff("FreeAimAngle") or math.Clamp(self:GetBuff("HipDispersion") / 80, 3, 10)
    return ang
end

function SWEP:ThinkFreeAim()
    if self:ShouldFreeAim() then
        local diff = self:GetOwner():EyeAngles() - self:GetLastAimAngle()
        --diff = diff * 2

        local freeaimang = Angle(self:GetFreeAimAngle())

        local max = self:FreeAimMaxAngle()

        local delta = math.min(self:GetSightDelta(),
                self:CanShootWhileSprint() and 1 or (1 - self:GetSprintDelta()),
                self:GetState() == ArcCW.STATE_CUSTOMIZE and 0 or 1)

        max = max * delta

        diff.p = math.NormalizeAngle(diff.p)
        diff.y = math.NormalizeAngle(diff.y)

        diff = diff * Lerp(delta, 1, 0.25)

        freeaimang.p = math.Clamp(math.NormalizeAngle(freeaimang.p) + math.NormalizeAngle(diff.p), -max, max)
        freeaimang.y = math.Clamp(math.NormalizeAngle(freeaimang.y) + math.NormalizeAngle(diff.y), -max, max)

        local ang2d = math.atan2(freeaimang.p, freeaimang.y)
        local mag2d = math.sqrt(math.pow(freeaimang.p, 2) + math.pow(freeaimang.y, 2))

        mag2d = math.min(mag2d, max)

        freeaimang.p = mag2d * math.sin(ang2d)
        freeaimang.y = mag2d * math.cos(ang2d)

        self:SetFreeAimAngle(freeaimang)

        if CLIENT then
            self.ClientFreeAimAng = freeaimang
        end
    end

    self:SetLastAimAngle(self:GetOwner():EyeAngles())
end

function SWEP:GetFreeAimOffset()
    if !self:ShouldFreeAim() then return ang0 end
    if CLIENT then
        return self.ClientFreeAimAng
    else
        return self:GetFreeAimAngle()
    end
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_ttt.lua:
function SWEP:OnRestore()
end

function SWEP:GetHeadshotMultiplier(victim, dmginfo)
    return 2.5 -- Hey hey hey, don't forget about me!!!
end

function SWEP:IsEquipment()
    return WEPS.IsEquipment(self)
end

SWEP.IsSilent = false

-- The OnDrop() hook is useless for this as it happens AFTER the drop. OwnerChange
-- does not occur when a drop happens for some reason. Hence this thing.
function SWEP:PreDrop()
    if self.Throwing then
        if self:GetGrenadePrimed() then
            self:Throw()
        end
    else
        if SERVER and IsValid(self:GetOwner()) and self.Primary.Ammo != "none" then
            local ammo = self:Ammo1()

            -- Do not drop ammo if we have another gun that uses this type
            for _, w in ipairs(self:GetOwner():GetWeapons()) do
                if IsValid(w) and w != self and w:GetPrimaryAmmoType() == self:GetPrimaryAmmoType() then
                ammo = 0
                end
            end

            self.StoredAmmo = ammo

            if ammo > 0 then
                self:GetOwner():RemoveAmmo(ammo, self.Primary.Ammo)
            end
        end
    end

    net.Start("arccw_togglecustomize")
        net.WriteBool(false)
    net.Send(self:GetOwner())
    self:ToggleCustomizeHUD(false)
end

function SWEP:DampenDrop()
    -- For some reason gmod drops guns on death at a speed of 400 units, which
    -- catapults them away from the body. Here we want people to actually be able
    -- to find a given corpse's weapon, so we override the velocity here and call
    -- this when dropping guns on death.
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:SetVelocityInstantaneous(Vector(0,0,-75) + phys:GetVelocity() * 0.001)
        phys:AddAngleVelocity(phys:GetAngleVelocity() * -0.99)
    end
end

SWEP.StoredAmmo = 0

-- Picked up by player. Transfer of stored ammo and such.
function SWEP:Equip(newowner)
    if SERVER then
        if self:IsOnFire() then
            self:Extinguish()
        end

        self.fingerprints = self.fingerprints or {}

        if !table.HasValue(self.fingerprints, newowner) then
            table.insert(self.fingerprints, newowner)
        end
    end

    if SERVER and IsValid(newowner) and self.StoredAmmo > 0 and self.Primary.Ammo != "none" then
        local ammo = newowner:GetAmmoCount(self.Primary.Ammo)
        local given = math.min(self.StoredAmmo, self.Primary.ClipMax - ammo)

        newowner:GiveAmmo( given, self.Primary.Ammo)
        self.StoredAmmo = 0
    end
end

function SWEP:WasBought(buyer)
    if self.TTT_DoNotAttachOnBuy then return end

    for i, k in pairs(self.Attachments) do
        k.RandomChance = 100
    end
    -- if ArcCW.ConVars["ttt_atts"]:GetBool() then
    --     self:NPC_SetupAttachments()
    -- end
end

function SWEP:TTT_PostAttachments()
    self.IsSilent = self:GetBuff_Override("Silencer")

    if !self.IsSilent then
        self.IsSilent = true
    end
end

function SWEP:TTT_Init()
    if engine.ActiveGamemode() != "terrortown" then return end

    if SERVER then
        self.fingerprints = {}
    end

    if self.Throwing then
        self.Primary.ClipMax = 0
    end

    if ArcCW.ConVars["ttt_atts"]:GetBool() then
        if SERVER then
            self:NPC_SetupAttachments()
        end
    elseif !IsValid(self:GetOwner()) then
        -- If attachments aren't randomized, client will not need to ask for att info.
        self.CertainAboutAtts = true
    end

    if self.ForgetDefaultBehavior then return end

    self.Primary.ClipMax = ArcCW.TTTAmmoToClipMax[self.Primary.Ammo] or self.RegularClipSize * 2 or self.Primary.ClipSize * 2

    -- This will overwrite mag reducers, so give it a bit of time
    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetClip1(self:GetCapacity() or self.RegularClipSize or self.Primary.ClipSize)
        self.Primary.DefaultClip = self.ForceDefaultAmmo or self.ForceDefaultClip or self:GetCapacity()
    end)

    if self.Throwing and self.Primary.Ammo and !self.ForceDefaultClip then
        self.Primary.Ammo = "none"
        self.Primary.DefaultClip = 0
        self:SetClip1(-1)
        self.Singleton = true
    end
end

--- TTT2 uses this to populate custom convars in the equip menu
function SWEP:AddToSettingsMenu(parent)
end
--addons/arccw_weapons/lua/weapons/arccw_btrs_41.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "BTRS"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/arccw/btrs_41_viewmodel.mdl"
SWEP.WorldModel = "models/arccw/btrs_41_world.mdl"
SWEP.IconOverride = "entities/btrs_41.png"
SWEP.WorldModelOffset = {
    pos = Vector(-3.3, 4, -7.2),
    ang = Angle(-10, -90, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

SWEP.ViewModelFOV = 70


SWEP.IconOverride = "materials/entities/btrs_41.png"
SWEP.DefaultBodygroups = "09"

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 435
SWEP.DamageMin = 103 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 220 -- how far bullets will retain their maximum damage for
SWEP.Range = 550 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_AIRBOAT
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_green" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 10 -- DefaultClip is automatically set.

SWEP.ManualAction = true -- pump/bolt action
SWEP.NoLastCycle = true -- do not cycle on last shot

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 3
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.4
SWEP.VisualRecoilMult = 2
SWEP.RecoilPunch = 1.8
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 330 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 2 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 330 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 99 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 15 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "weapons/anti_tank_shot.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.FiremodeSound = "weapons/tfa_ww2_pzb39/pzb39_safety.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.BulletBones = {
    [1] = "bullet.010",
    [2] = "bullet.009",
    [3] = "bullet.008",
    [4] = "bullet.007",
    [5] = "bullet.006",
    [6] = "bullet.005",
    [7] = "bullet.004",
    [8] = "bullet.003",
    [9] = "bullet.002",
    [10] = "bullet.001",
}

-- O

SWEP.IronSightStruct = {
    Pos = Vector(-3.155, 0, 2.04),
    Ang = Angle(0.2, 0.05, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(2, -5,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 1, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10, 0, -5.897)
SWEP.CustomizeAng = Angle(30.149, 20.547, 40)

SWEP.InBipodPos = Vector(-2, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["btrs_41_bipod"] = {
        VMBodygroups = {{ind = 3, bg = 1}},-- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
		Bone = "body", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(-2.4, 0, 7),
            vang = Angle(90, 0, -0),
            wpos = Vector(12, 0.85, -7.4),
            wang = Angle(-10, 0, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        VMScale = Vector(1, 1, 1),
        Bone = "body", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.5, 0, 19),
            vang = Angle(90, 00, 0),
            wpos = Vector(25, .85, -7.9),
            wang = Angle(-10, 0, -180)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "body", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-1, -1, 2.3),
            vang = Angle(90, 0, 0),
            wpos = Vector(3.5, 1.8, -2.5),
            wang = Angle(90, 0, 90)
        },
    },
    [4] = {
        PrintName = "Bipod", -- print name
        Slot = {"btrs_41_bipod"},
        DefaultAttName = "Undeployed", -- used to display the "no attachment" text        -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"anti_vehicle_btrs", "ammo"},
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
    },                              
}

SWEP.Animations = {
    ["ready"] = {
        Source = "base_ready",
    },
    ["idle"] = {
        Source = "base_idle",
    },
    ["fire"] = {
        Source = {"base_fire"},
    },
    ["fire_empty"] = {
        Source = {"base_firelast"},
    },
    ["fire_iron"] = {
        Source = {"iron_fire"},
    },
    ["fire_iron_empty"] = {
        Source = {"iron_fire_last"},
    },
    ["idle_sights"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
	["reload_empty"] = {
        Source = "base_reload",
        LHIK = true,
    },
    ["cycle"] = {
        Source = "base_fire_end",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
    },
    ["idle_inspect"] = {
        Source = "base_inspect",
    },
    ["exit_inspect"] = {
        Source = "base_idle",
    },
	["draw"] = {
        Source = "base_draw",
        SoundTable = {
            {
                s = "w/dt12/gunfoley_pistol_draw_var_11.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "base_holster",
        SoundTable = {
            {
                s = "w/dt12/gunfoley_pistol_sheathe_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}

sound.Add({
    name =          "TFA_WW2_PZB39.OpenLever",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_leveropen.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.OpenRightAmmoBox",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_openrightammobox.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.InsertRound",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_insertround.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.CloseRightAmmobox",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_closerightammobox.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.Safety",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_safety.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.CloseLever",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_leverclose.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.Tap",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_tap.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.pzb39_ammoboxout",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_leverclose.wav"
})

sound.Add({
    name =          "TFA_WW2_PZB39.AmmoBoxin",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/tfa_ww2_pzb39/pzb39_ammoboxin.wav"
})
--addons/arccw_weapons/lua/weapons/arccw_dc17_training_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17 (Training)"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "Heavy blaster pistol for CQB enviroments"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dc17_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc17_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(11, 0, -4.4),
    ang = Angle(175, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

SWEP.IconOverride = "materials/entities/rw_sw_trd_dc17.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 1
SWEP.RangeMin = 90
SWEP.DamageMin = 1
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_orange"
SWEP.TracerCol = Color(255, 170, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 240
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(250, 183, 0)

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-5.4, -0, 0.4),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, -3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(2, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {""}
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic_lp",
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(-0.4, -3.1, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(5, 1.13, -5.3),
            wang = Angle(-6, 0, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.3, 0, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, 1.12, -2.8),
            wang = Angle(-5, 0, 180)
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.4, -1.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(10.2, 1.12, -4.2),
            wang = Angle(-6, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.24, -2, -2),
            vang = Angle(90, 0, -90),
            wpos = Vector(8, 1.7, -4.6),
            wang = Angle(-10, 0, 180)
        },
    },          
    [7] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.5, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(0, 0, -0),
            wang = Angle(-15, 0, 180)
        },
    },   
    [8] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [9] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "Idle",
    },
    ["fire"] = {
        Source = "Fire",
    },
    ["fire_sights"] = {
        Source = "",
        Time = -1,
    },
    ["idle_sights"] = {
        Source = "",
        Time = -1,
    },
    ["enter_sight"] = {
        Source = "neutral",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 2.5,
        SoundTable = {
            {s = "reloads/pistols.wav", t = 1 / 30}, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dc17m_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17m Rifle"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-17m Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/viewmodels/c_dc17m.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc-17m.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-26, 11, -4),
    ang = Angle(170, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc17m.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "00000000000"
SWEP.DefaultWMBodygroups = "00000000"

SWEP.Damage = 45
SWEP.RangeMin = 190
SWEP.DamageMin = 27
SWEP.Range = 550
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.29
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 330
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "shared/SW01_Weapons_Blasters_Shared_Corebass_Close_Thumb_VAR_01 0 0 0.ogg"
SWEP.ShootSound = "dc17m/dc17m.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-6.53, -8, 0.9),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"", ""}

SWEP.AttachmentElements = {
    ["dc17m_ext_v2"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.05, 0.4, 3.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(7, 1.5, -7),
            wang = Angle(-10, 0, 180)
        },
        -- CorrectiveAng = Angle(-2.4, -0, 0)
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 4.8, 6.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 1.5, -3),
            wang = Angle(170, 180, 0),
        },
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.5, 0.75, 12),
            vang = Angle(90, 0, 30),
            wpos = Vector(16, 3, -8),
            wang = Angle(-10, 0, -60)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.05, 1.15, 19.45),
            vang = Angle(90, 0, -90),
            wpos = Vector(22.1, 1.51, -8.7),
            wang = Angle(-10, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc17m_ext_v2"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
            wpos = Vector(0, 0, -0),
            wang = Angle(-15, 90, -90)
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.4, 1.6, 2),
            vang = Angle(90, 0, -70),
            wpos = Vector(6, 3, -5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 2, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(0, 0, -0),
            wang = Angle(-15 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "Fire"
    },
    ["fire_iron"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "Draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "Holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "Reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            --{s = "viper/weapons/sierra552/wfoly_ar_sierra552_reload_xmag_fast_empty_end.ogg", t = 20 / 60},
            {s = "dc17m/reload/SW02_Weapons_Overheat_ManualCooling_VAR_04 0 0 0.ogg", v = 10 , t = 23 / 60},
            {s = "dc17m/reload/magin.ogg", t = 115 / 60},
            {s = "dc17m/reload/maghit.ogg", t = 132 / 60},
            {s = "dc17m/reload/SCIMisc_Ammo Replenish_01.ogg", t = 139 / 60} --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dp24_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DP-24"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-15A Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dp24_v2.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dp24_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(9, 0, -4.5),
    ang = Angle(165, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dp24.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 45
SWEP.RangeMin = 190
SWEP.DamageMin = 27
SWEP.Range = 550
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.29
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 275
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    }, 
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "shared/corebass_0001.ogg"
SWEP.ShootSound = "dp24/dp24.ogg"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.955, -7, 2.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

-- SWEP.DefaultElements = {"", ""}

-- SWEP.AttachmentElements = {
--     ["dc15a"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/DC15A_Rifle.mdl", -- using the model-edit i made in like 2 mins lol
--                 Bone = "v_dlt19_reference001",
--                 Scale = Vector(1.2, 1.2, 1.2),
--                 Offset = {
--                     pos = Vector(.7, -0.3, 0.5),
--                     ang = Angle(0,-90, 0)
--                 },
--             }
--         },
--     },
--     ["muzzle"] = {
--          VMElements = {
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "dlt19_sight",
--                 Scale = Vector(0, 0, 0),                
--                 Offset = {
--                     pos = Vector(-0.5, 4, 27 ),
--                     ang = Angle(-90, 180, 0)
--                 },
--                 IsMuzzleDevice = true
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(3.75, 2.5, -1.5),
--                     ang = Angle(-15, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(3500, 0, -1100),
--                     ang = Angle(-15, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }
-- WMOverride = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.18, 0.06, 1.4),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1, -4.5),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0., 1.65, 6.5),
            vang = Angle(90, 0, -90),
            wang = Angle(165, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0.18, 1.95, 4),
            vmax = Vector(-0.18, 1.83, 10),
            wmin = Vector(10, 1, -3.7), 
            wmax = Vector(15, 1, -4.9)  -- how far this attachment can slide in both directions.
        },  
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.18, 2, 12.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 1, -6.3),
            wang = Angle(-15, 0, 180)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.18, 1.04, 16),
            vang = Angle(90, 0, -90),
            wpos = Vector(23, 1, -8.1),
            wang = Angle(-15, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc15a_magazine_75"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 1.8, 1.5),
            vang = Angle(180, 1.75, -2.5),
            wpos = Vector(9, 1, -3.3),
            wang = Angle(-15, 90, -90)
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 1, 5.7),
            vang = Angle(90, 0, -90),
            wpos = Vector(3, 1.8, -2.5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}
--addons/arccw_weapons/lua/weapons/arccw_sops_de10.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = "Kraken"
SWEP.PrintName = "[P] DE-10"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DE-10 blaster pistol was a stylish and reliable heavy blaster pistol that was manufactured by Antrech Arms, a subsidiary of BlasTech Industries. It was vaunted for its reliability and ease of maintenance, and heavily resembled a slugthrower revolver."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/de10.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/blasterpistol_template.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 30
SWEP.RangeMin = 120
SWEP.DamageMin = 15
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_purple"
SWEP.TracerCol = Color(171, 0, 250)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 1.21
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 128

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/de10.wav"
SWEP.ShootSound = "sops-v2/weapons/de10.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_purple"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(171, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-5.65, -10, 0.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/de10.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-2.6, 3.1, -2),
                    ang = Angle(0, 0, -90)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC-15SA",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 0, 12),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/de10.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(80, -10, 10),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(150, 10, -50),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/de10.mdl"

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.6, -2.6, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(75, 14, -61),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0)
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.7, -2.2, 8),
            vang = Angle(90, 0, -90),
            wpos = Vector(176, 10, -82),
            wang = Angle(-15, 0, 180)

        },
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(-0.3, -0, -1.7),
            vang = Angle(90, 0, -90),
            wpos = Vector(70, 18, -30),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.3, -1.7, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(85, 19, -55),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false
    },
    ["fire"] = {
        Source = {"Fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dlt19d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "DLT-19d"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The DLT-19D heavy blaster rifle was a long-range heavy blaster rifle, longblaster and a variant of the DLT-19 heavy blaster rifle, featuring a scope and two underbarrel devices, one of which was a glowrod."
SWEP.IconOverride = "entities/sopsmisc/dlt19d.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 126
SWEP.RangeMin = 427
SWEP.DamageMin = 101
SWEP.Range = 908
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_laser_big"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 1.54
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 128

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 70
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/dlt19d.mp3"
SWEP.ShootSound = "sops-v2/weapons/dlt19d.mp3"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.8, 0, 1),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/w_dlt19d.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-0.5, 0.6, -0.6),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 32, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/w_dlt19d.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(100, 0, -50),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(455, 15, -145),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/w_dlt19d.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.6, 0, 1.8),
            vang = Angle(0, -90, 0),
            wpos = Vector(75, 25, -75),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.07)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.7, 22, -0.1),
            vang = Angle(0, -90, 90),
            wpos = Vector(265, 20, -100),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.2, 34, -0.25),
            vang = Angle(0, -90, 0),
            wpos = Vector(473, 10, -155),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(1.3, -2.85, -1.4),
            vang = Angle(0, -90, 0),
            wpos = Vector(60, 23, -30),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.45, -4, -0.3),
            vang = Angle(0, -90, 0),
            wpos = Vector(30, 24, -35),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_imperialpuncher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Imperial Firepuncher"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The 773 Firepuncher rifle, also known as the 773 Firepuncher, was a model of sniper rifle manufactured by Merr-Sonn Munitions, Inc. that featured ablative coating and a wide-beam 'burning' mode."
SWEP.IconOverride = "entities/sopsmisc/imperialpuncher.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 182
SWEP.RangeMin = 782
SWEP.DamageMin = 106
SWEP.Range = 1248
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 22

SWEP.Recoil = 1.21
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 102

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/firepuncher/firepuncher.wav"
SWEP.ShootSound = "sops-v2/weapons/firepuncher/firepuncher.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.55, 0, 2),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/firepuncher_v2.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(0.7, 0.7, 0.7),
                Offset = {
                    pos = Vector(-0.4, -8.6, -0.5),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 24, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/firepuncher_v2.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.7, 0.7, 0.7),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(-10, 10, -20),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(300, 15, -110),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/firepuncher_v2.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.35, -3, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(52, 10, -51),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(-0.3, 11, -1.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(200, 10, -67),
            wang = Angle(-15, 0, -180)
        },
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},  
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(0.45, -3.2, -0.55),
            vang = Angle(0, -90, 0),
            wpos = Vector(43, 19, -33),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.6, -7, -0.4),
            vang = Angle(0, -90, 0),
            wpos = Vector(10, 20, -24),
            wang = Angle(-15, 0, 180)
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_t702.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "T-702 Sniper Rifle"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The T-702 sniper rifle was a sniper rifle manufactured for the clone snipers of the Galactic Republic. It was commonly used by Alpha-Class ARC Troopers during Clone Wars."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/t702.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/t702_v2.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-5, 3, -6),
    ang = Angle(-10, -4, 180),
    scale = 1
}
SWEP.WorldModel = "models/weapons/w_snip_sg550.mdl"
SWEP.ViewModelFOV = 65

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 105
SWEP.DamageMin = 105
SWEP.Range = 4000 * 0.025 -- in METRES
SWEP.RangeMin = 0
SWEP.Penetration = 22
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 15
SWEP.ReducedClipSize = 5

SWEP.Recoil = 2
SWEP.RecoilRise = 5

SWEP.Delay = 0.05
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.06 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 777 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 267

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/t702.wav"
SWEP.ShootSound = "sops-v2/weapons/t702.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.778, -3, 1.1),
    Ang = Angle(2, 0, 0),
     Magnification = 1,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

-- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "tag_weapon",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(55, 3, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
    }
}


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-0.15, 0.05, 3.4),
            vang = Angle(0, 0, 0),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        Bone = "tag_weapon", 
        Offset = {
            vpos = Vector(15, -0.5, 2.4),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(13, 0.05, 0.8),
            vang = Angle(0, 0, 0),
        },          
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},  
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "tag_weapon",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0, -0.8, 2.4),
            vang = Angle(0, 0, 20),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        VMScale = Vector(1, 1, 1),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-3, -0.8, 2.4),
            vang = Angle(0, 0, 20),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 101/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 40/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "putaway",
        Time = 36/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["fire"] = {
        Source = "fire",
        Time = 1,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 5/30,
    },
    ["reload"] = {
        Source = "reload",
        Time = 94/24,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "sops-v2/weapons/t702/wpfoly_m82_reload_lift_v1.wav", 		t = 0},
						{s = "sops-v2/weapons/t702/wpfoly_m82_reload_clipout_v1.wav", 	t = 18/24},
						{s = "sops-v2/weapons/t702/wpfoly_m82_reload_clipin_v1.wav", 	t = 60/24},
					},
        Checkpoints = {18, 47},
        FrameRate = 30,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload",
        Time = 94/24,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "sops-v2/weapons/t702/wpfoly_m82_reload_lift_v1.wav", 		t = 0},
						{s = "sops-v2/weapons/t702/wpfoly_m82_reload_clipout_v1.wav", 	t = 18/24},
						{s = "sops-v2/weapons/t702/wpfoly_m82_reload_clipin_v1.wav", 	t = 60/24},
					},
        Checkpoints = {18, 47},
        FrameRate = 30,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
}
--addons/weapons_other/lua/weapons/ec_multitool.lua:
--[[ 
	 Alydus.net
	Do not reupload lua to workshop without permission of the author

	Star Wars Fusion Cutter Repairer
	
	Alydus: (officialalydus@gmail.com | STEAM_0:1:57622640)
--]]

AddCSLuaFile()

if CLIENT then
	SWEP.PrintName = "Multi-Tool"
	SWEP.Slot = 1
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false

	surface.CreateFont("Orbitron40", {font = "Orbitron Regular", size = 40})
end

SWEP.Author = "Alydus & Sammy"
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.WorldModel = ""
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "AOCRP - Tools"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Delay = 0.5

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.5

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_grenade.mdl"
SWEP.ShowViewModel = false
SWEP.DrawViewModel = false
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Pin"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01"] = { scale = Vector(1, 1, 1), pos = Vector(0, -1.297, 0), angle = Angle(0, 0, 0) }
}

SWEP.IronSightsPos = Vector(-13.04, 0, 1.24)
SWEP.IronSightsAng = Vector(0, 0, 0)

SWEP.VElements = {
	["fusioncutter"] = { type = "Model", model = "models/cosmo/starwarscutter.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(-0.519, 0.518, 1.557), angle = Angle(162.468, -180, 24.545), size = Vector(0.82, 0.82, 0.82), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "fusioncutter", pos = Vector(9.869, -0.519, 16.104), size = { x = 10, y = 10 }, color = Color(0, 0, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["lighteffect+"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "fusioncutter", pos = Vector(-1.558, -0.119, 9.67), size = { x = 1.599, y = 1.599 }, color = Color(0, 0, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

SWEP.WElements = {
	["fusioncutter"] = { type = "Model", model = "models/cosmo/starwarscutter.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, 4.675, 3.635), angle = Angle(-8.183, -17.532, -146.105), size = Vector(0.885, 0.885, 0.885), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(16.104, -1.558, -12.988), size = { x = 10, y = 10 }, color = Color(0, 0, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

if SERVER then

	repairDatabase = {}
	repairDatabaseRight = {}

	repairDatabase["func_door"] = function(fusionCutter, ent, trace)

		if ent.IsKeypadControlled then return false end

		ent:Fire("Unlock", 1, 0)
		ent:Fire("Open", 1, 0)


		return true
	end
	repairDatabase["func_door_rotating"] = function(fusionCutter, ent, trace)
		repairDatabase["func_door"](fusionCutter, ent, trace)
	end
	repairDatabase["prop_door"] = function(fusionCutter, ent, trace)
		repairDatabase["func_door"](fusionCutter, ent, trace)
	end
	repairDatabase["prop_door_rotating"] = function(fusionCutter, ent, trace)
		repairDatabase["func_door"](fusionCutter, ent, trace)
	end
	repairDatabase["alydus_destructablefortification"] = function(fusionCutter, ent, trace)
		if alydusDestructableFortificationExtension and GetConVar("alydus_defaultfortificationhealth") then
			local defaultHealth = GetConVar("alydus_defaultfortificationhealth"):GetInt()
			local hp = ent:GetNWInt("fortificationHealth", false)

			if hp == false then
				return false
			end

			if hp <= defaultHealth - 50 then
				hp = hp + 50
			else
				hp = defaultHealth
			end

			if hp != ent:GetNWInt("fortificationHealth") then
				ent:SetNWInt("fortificationHealth", hp)
				return true
			else
				return false
			end
		end
	end

	repairDatabase["droneRefuel"] = function(fusionCutter, ent, trace)
		if ent:IsDroneDestroyed() then
			return false
		else
			if math.Round(ent:GetFuel()) < ent.MaxFuel then
				ent:SetFuel(ent:GetFuel() + 10)
				return true
			else
				return false
			end
		end
	end
	repairDatabase["starwarsVehicleRepair"] = function(fusionCutter, ent, trace)
		local hp = ent:GetNWInt("Health", 0)

		if hp <= ent.StartHealth - 50 then
			hp = hp + 50
		else
			hp = ent.StartHealth
		end

		if hp != ent:GetNWInt("Health", 0) then
			ent:SetNWInt("Health", hp)
			return true
		else
			return false
		end
	end
	repairDatabase["lfsVehicleRepair"] = function(fusionCutter, ent, trace)
		local hp = ent:GetHP()

		if hp <= ent.MaxHealth - 50 then
			hp = hp + 50
		else
			hp = ent.MaxHealth
		end

		if hp != ent:GetHP() then
			ent:SetHP(hp)
			return true
		else
			return false
		end
	end
	repairDatabase["simfphysVehicleRepair"] = function(fusionCutter, ent, trace)
		local hp = ent:GetCurHealth()

		if hp <= ent:GetMaxHealth() - 100 then
			hp = hp + 100
		else
			hp = ent:GetMaxHealth()
		end

		if hp != ent:GetCurHealth() then
			ent:SetOnFire(false)
			ent:SetOnSmoke(false)

			if hp == ent:GetMaxHealth() then
				net.Start("simfphys_lightsfixall")
					net.WriteEntity(ent)
				net.Broadcast()

				if istable(ent.Wheels) then
					for i = 1, table.Count( ent.Wheels ) do
						local Wheel = ent.Wheels[ i ]
						if IsValid(Wheel) then
							Wheel:SetDamaged( false )
						end
					end
				end
			end

			ent:SetCurHealth(hp)
			return true
		else
			return false
		end
	end
	repairDatabase["scarsVehicleRepair"] = function(fusionCutter, ent, trace)
		if ent:IsDamaged() then
			ent.DoRepair = true
			ent:EmitSound("carStools/tune.wav", 100, math.random(80, 150))
			return true
		end
		
		return false
	end

	repairDatabase["keypad"] = function(fusionCutter, ent, trace)
			if SERVER then
				ent:SetHealth(ent:GetMaxHealth())
				ent:Repair()
				return true
			end
	end

	repairDatabase["funkzentrale"] = function(fusionCutter, ent, trace)
		if SERVER then
			SetGlobalBool( "FunkzentraleBroken", false )
			ent:SetSkin( 0 ) 
			ent:SetNWInt( "enginehealth", 1000 )
			return true
		end
	end

	repairDatabase["schild"] = function(fusionCutter, ent, trace)
		if SERVER then
			ent:SetNWInt( "enginehealth", 1000 )
			return true
		end
	end
	repairDatabase["havoc_engine"] = function(fusionCutter, ent, trace)
		if SERVER then
			ent:SetNWInt( "enginehealth", 100 )
			return true
		end
	end
	repairDatabase["life"] = function(fusionCutter, ent, trace)
		if SERVER then
			ent:SetNWInt( "enginehealth", 1000 )
			return true
		end
	end
	repairDatabase["gravitation"] = function(fusionCutter, ent, trace)
		if SERVER then
			ent:SetNWInt( "enginehealth", 600 ) 
			RunConsoleCommand( "sv_gravity", 600 )
			return true
		end
	end



	repairDatabase["prop_physics"] = function(fusionCutter, ent, trace)
		if SERVER then
			if ent.IsJoeFort then
				ent:Remove()
				return true
			end


		end
	end

	repairDatabase["joefort_buildent"] = function(fusionCutter, ent, trace)
		if SERVER then
				ent:Remove()
				return true



		end
	end
	repairDatabaseRight["aoc_keypad"] = function(fusionCutter, ent, trace)
		if SERVER then
				if ent.Log then 
					for k, v in pairs(ent.Log) do
						fusionCutter.Owner:ChatPrint(v)
					end
				end 
				return true
		end
	end
	repairDatabase["aoc_keypad"] = function(fusionCutter, ent, trace)
		if SERVER then
				ent:Hack()
				return true
		end
	end
	repairDatabase["shield_5"] = function(fusionCutter, ent, trace)
		if SERVER then
				ent:Repair()
				return true
		end
	end

	--[[repairDatabase["player"] = function(fusionCutter, ent, trace)
		if SERVER then
			local need = math.min( ent:GetMaxArmor() - ent:Armor(), 30 )

			if ent:Armor() < ent:GetMaxArmor() then
				
				ent:SetArmor( ent:GetMaxArmor() )
				ent:EmitSound( "everfall/equipment/combat_heal/combatheal_var_0"..math.random(1,8)..".mp3" )
				return true
			else
				return false
			end


		end
	end]]

	function exceptionContinue(ent)
		if ent.IS_DRR then
			return "droneRefuel"
		elseif ent.IsSWVehicle then
			return "starwarsVehicleRepair"
		elseif ent.LFS or ent.LVS then
			return "lfsVehicleRepair"
		elseif string.find(ent:GetClass(), "sent_sakarias_car") or string.find(ent:GetClass(), "sent_sakarias_carwheel") or string.find(ent:GetClass(), "sent_sakarias_carwheel_punked") then
			return "scarsVehicleRepair"
		elseif simfphys and simfphys.IsCar and simfphys.IsCar(ent) then
			return "simfphysVehicleRepair"
		end
		return false
	end
end

function SWEP:ShouldDrawViewModel()
	if CLIENT then
		return true
	end
end

function SWEP:PostDrawViewModel(vm, wep, ply)
	if CLIENT then
		local ply = self:GetOwner()
		local fade = math.abs(math.sin(CurTime() * 1.15))
		local bone = "ValveBiped.Grenade_body"

		if IsValid(vm) and IsValid(ply) and ply:HasWeapon(self:GetClass()) and vm:LookupBone(bone) then
			local atch = vm:GetBoneMatrix(vm:LookupBone(bone))
			local pos, ang = vm:GetBonePosition(vm:LookupBone(bone)), vm:GetBoneMatrix(vm:LookupBone(bone)):GetAngles()
			ang:RotateAroundAxis(ang:Right(), 90)

			cam.Start3D2D(pos - ang:Right() * 6 - ang:Forward() * 6.5 + ang:Right() * 5.65, Angle(0, ply:EyeAngles().y, ang.z) + Angle(180, 90, 160), 0.01)
				draw.SimpleText("F-187 Fusion Cutter", "Orbitron40", -300, -180, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				draw.SimpleText("LMB: Attempt Repair", "Orbitron40", -300, -140, Color(200, 200, 200, 255 * fade), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			cam.End3D2D()

			--render.DrawLine(pos + ang:Up() * -5, ply:GetEyeTrace().HitPos)
		end
	end
end

function SWEP:PrimaryAttack()
	if SERVER then
		local ply = self:GetOwner()
		local plyEyeTrace = ply:GetEyeTrace()
		local vm = ply:GetViewModel()
		local bone = "ValveBiped.Grenade_body"
		local enta = ply:GetEyeTrace().Entity

		if IsValid(ply) and IsValid(plyEyeTrace.Entity) then
			if repairDatabase[plyEyeTrace.Entity:GetClass()] or exceptionContinue(plyEyeTrace.Entity) != false then
				if ply:GetPos():Distance(plyEyeTrace.Entity:GetPos()) > 300 then
					ply:EmitSound("items/medshotno1.wav")
				else
					local success = false
					if exceptionContinue(plyEyeTrace.Entity) == false then
						success = repairDatabase[plyEyeTrace.Entity:GetClass()](self, plyEyeTrace.Entity, plyEyeTrace)
					else
						success = repairDatabase[exceptionContinue(plyEyeTrace.Entity)](self, plyEyeTrace.Entity, plyEyeTrace)
					end

					if success == true then
						local effectdata = EffectData()
						effectdata:SetOrigin(plyEyeTrace.HitPos)
						effectdata:SetMagnitude(3)
						effectdata:SetScale(5)
						effectdata:SetRadius(2)
						util.Effect("cball_explode", effectdata, true, true)

						--sound.Play("HL1/ambience/port_suckin1.wav", plyEyeTrace.HitPos, 75, 100, 1)

						if IsValid(vm) and vm:LookupBone(bone) then
							local atch = vm:GetBoneMatrix(vm:LookupBone(bone))
							local pos, ang = vm:GetBonePosition(vm:LookupBone(bone)), vm:GetBoneMatrix(vm:LookupBone(bone)):GetAngles()

							local effectData = EffectData()
							effectData:SetOrigin(pos)
							util.Effect("MuzzleFlash", effectData, true, true)

							local effectData = EffectData()
							effectData:SetOrigin(pos)
							effectData:SetNormal(pos:GetNormalized())
							effectData:SetMagnitude(1)
							effectData:SetScale(1)
							effectData:SetRadius(2)
							util.Effect("Sparks", effectData)
						end
					else
						ply:EmitSound("items/medshotno1.wav")
					end
				end
			else
				--ply:EmitSound("items/medshotno1.wav")
				ply:EmitSound("")
			end
		if enta:IsPlayer() then
            if enta:Armor() < enta:GetMaxArmor() then
				ply:addMoney(3, "Rstungsreparatur")
				ply:ConCommand("say /me Repariert die Rstung von <lg>" .. enta:Nick() .. "</lg>")
				enta:SetArmor( enta:GetMaxArmor() )
				enta:EmitSound( "everfall/equipment/combat_heal/combatheal_var_0"..math.random(1,8)..".mp3" )
				--enta:Freeze(true)
				--timer.Simple( 1, function() enta:Freeze(false) end )
				ply:Freeze(true)
				timer.Simple( 1, function() ply:Freeze(false) end )
			else
				--ply:ChatPrint("[!] > Rstung ist repariert!")
				ply:EmitSound("items/medshotno1.wav")
			end
		end
			self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		end
	end

	return false
end

function SWEP:SecondaryAttack()
	if SERVER then
		local ply = self:GetOwner()
		local plyEyeTrace = ply:GetEyeTrace()
		local vm = ply:GetViewModel()
		local bone = "ValveBiped.Grenade_body"
		local enta = ply:GetEyeTrace().Entity

		if IsValid(ply) and IsValid(plyEyeTrace.Entity) then
			if repairDatabaseRight[plyEyeTrace.Entity:GetClass()] or exceptionContinue(plyEyeTrace.Entity) != false then
				if ply:GetPos():Distance(plyEyeTrace.Entity:GetPos()) > 300 then
					ply:EmitSound("items/medshotno1.wav")
				else
					local success = false
					if exceptionContinue(plyEyeTrace.Entity) == false then
						success = repairDatabaseRight[plyEyeTrace.Entity:GetClass()](self, plyEyeTrace.Entity, plyEyeTrace)
					else
						success = repairDatabaseRight[exceptionContinue(plyEyeTrace.Entity)](self, plyEyeTrace.Entity, plyEyeTrace)
					end

					if success == true then
						local effectdata = EffectData()
						effectdata:SetOrigin(plyEyeTrace.HitPos)
						effectdata:SetMagnitude(3)
						effectdata:SetScale(5)
						effectdata:SetRadius(2)
						util.Effect("cball_explode", effectdata, true, true)

						--sound.Play("HL1/ambience/port_suckin1.wav", plyEyeTrace.HitPos, 75, 100, 1)

						if IsValid(vm) and vm:LookupBone(bone) then
							local atch = vm:GetBoneMatrix(vm:LookupBone(bone))
							local pos, ang = vm:GetBonePosition(vm:LookupBone(bone)), vm:GetBoneMatrix(vm:LookupBone(bone)):GetAngles()

							local effectData = EffectData()
							effectData:SetOrigin(pos)
							util.Effect("MuzzleFlash", effectData, true, true)

							local effectData = EffectData()
							effectData:SetOrigin(pos)
							effectData:SetNormal(pos:GetNormalized())
							effectData:SetMagnitude(1)
							effectData:SetScale(1)
							effectData:SetRadius(2)
							util.Effect("Sparks", effectData)
						end
					else
						ply:EmitSound("items/medshotno1.wav")
					end
				end
			else
				--ply:EmitSound("items/medshotno1.wav")
				ply:EmitSound("")
			end
			self:SetNextSecondaryFire(CurTime() + self.Primary.Delay)
		end
	end

	return false
end

function SWEP:Initialize()
	self:SetHoldType("slam")
	if CLIENT then
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)

		self:CreateModels(self.VElements)
		self:CreateModels(self.WElements)
		
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					vm:SetColor(Color(255,255,255,1))
					vm:SetMaterial("Debug/hsv")
				end
			end
		end
	end
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				local fade = math.abs(math.sin(CurTime() * 1.15))
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				if name != "lighteffect+" then
					render.DrawSprite(drawpos, v.size.x, v.size.y, Color(192, 57, 43, 255 * fade))
				else
					render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				end
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end
	 
	function SWEP:ResetBonePositions(vm)
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
	end

	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
	end
end
--addons/weapon_joe_fort/lua/weapons/fort_datapad_admin/shared.lua:
SWEP.PrintName = "Admin Datapad"
SWEP.Author =	"Joe"

SWEP.Spawnable =	false
SWEP.Adminspawnable =	false
SWEP.Category = "Datapads"
SWEP.ShowWorldModel = false

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	false
SWEP.Primary.Ammo =	"none"
SWEP.Slot = 5

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"
SWEP.UseHands = true


SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 55
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/joes/c_datapad.mdl"
SWEP.WorldModel = "models/joes/w_datapad.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.DrawCrosshair = false

function SWEP:PrimaryAttack()
	if CLIENT then JoeFort:OpenAdminFortMenu() end
	self:SetNextPrimaryFire(CurTime() + 1)
end

function SWEP:SecondaryAttack()

end

function SWEP:Initialize()

end

function SWEP:Holster()
	
	return true
end

function SWEP:OnRemove()

end

--addons/lvs_base/gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvsturret.lua:
TOOL.Category		= "LVS"
TOOL.Name		= "#tool.lvsturret.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

cleanup.Register( "lvsturret" )
CreateConVar("sbox_maxlvsturret", 1, "FCVAR_NOTIFY")

TOOL.ClientConVar[ "delay" ] 		= "0.05"
TOOL.ClientConVar[ "damage" ] 		= "15"
TOOL.ClientConVar[ "speed" ] 		= "30000"
TOOL.ClientConVar[ "size" ] 		= "1"
TOOL.ClientConVar[ "spread" ] 		= "0"
TOOL.ClientConVar[ "penetration" ] 	= "10"
TOOL.ClientConVar[ "splashdamage" ] = "0"
TOOL.ClientConVar[ "splashradius" ] 	= "0"
TOOL.ClientConVar[ "tracer" ] 		= "lvs_tracer_orange"
TOOL.ClientConVar[ "splasheffect" ] 	= "lvs_bullet_impact"

if CLIENT then
	language.Add( "tool.lvsturret.name", "Projectile Turret" )
	language.Add( "tool.lvsturret.desc", "A Tool used to spawn Turrets" )
	language.Add( "tool.lvsturret.0", "Left click to spawn or update a turret" )
	language.Add( "tool.lvsturret.1", "Left click to spawn or update a turret" )
	
	language.Add( "Cleanup_lvsturret", "[LVS] Projectile Turret" )
	language.Add( "Cleaned_lvsturret", "Cleaned up all [LVS] Projectile Turrets" )

	language.Add( "SBoxLimit_lvsturret", "You've reached the Projectile Turret limit!" )
end

function TOOL:LeftClick( trace )

	if CLIENT then return true end
	
	local ply = self:GetOwner()

	if not istable( WireLib ) then
		ply:PrintMessage( HUD_PRINTTALK, "[LVS]: WIREMOD REQUIRED" )
		ply:SendLua( "gui.OpenURL( 'https://steamcommunity.com/sharedfiles/filedetails/?id=160250458' )") 
	end
	
	if IsValid( trace.Entity ) and trace.Entity:GetClass():lower() == "lvs_turret" then 
		self:UpdateTurret( trace.Entity )
	else
		local turret = self:MakeTurret( ply, trace.HitPos + trace.HitNormal * 5 )
		
		undo.Create("Turret")
			undo.AddEntity( turret )
			undo.SetPlayer( ply )
		undo.Finish()
	end
	
	return true
end

function TOOL:RightClick( trace )
	return false
end

if SERVER then
	function TOOL:UpdateTurret( ent )
		if not IsValid( ent ) then return end

		ent:SetShootDelay( self:GetClientNumber( "delay" ) )
		ent:SetDamage( math.Clamp( self:GetClientNumber( "damage" ), 0, 1000 ) )
		ent:SetSpeed( math.Clamp( self:GetClientNumber( "speed" ), 10000, 100000 ) )
		ent:SetSize( math.Clamp( self:GetClientNumber( "size" ), 0, 50 ) )
		ent:SetSpread( math.Clamp( self:GetClientNumber( "spread" ), 0, 1 ) )
		ent:SetPenetration( math.Clamp( self:GetClientNumber( "penetration" ), 0, 500 ) )
		ent:SetSplashDamage( math.Clamp( self:GetClientNumber( "splashdamage" ), 0, 1000 ) )
		ent:SetSplashDamageRadius( math.Clamp( self:GetClientNumber( "splashradius" ), 0, 750 ) )
		ent:SetTracer( self:GetClientInfo( "tracer" ) )
		ent:SetSplashDamageType( self:GetClientInfo( "splasheffect" ) )
	end

	function TOOL:MakeTurret( ply, Pos, Ang )

		if not ply:CheckLimit( "lvsturret" ) then return NULL end

		local turret = ents.Create( "lvs_turret" )
		
		if not IsValid( turret )  then return NULL end

		turret:SetPos( Pos )
		turret:SetAngles( Angle(0,0,0) )
		turret:Spawn()

		turret.Attacker = ply

		self:UpdateTurret( turret )

		ply:AddCount( "lvsturret", turret )
		ply:AddCleanup( "lvsturret", turret )

		return turret
	end
end

local ConVarsDefault = TOOL:BuildConVarList()
function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "lvs_turrets", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Header", { Text = "#tool.lvsturret.name", Description	= "#tool.lvsturret.desc" }  )

	local TracerEffect = {Label = "Tracer Effect", MenuButton = 0, Options={}, CVars = {}}
	local TracerOptions = {
		["LaserBlue"] = "lvs_laser_blue",
		["LaserRed"] = "lvs_laser_red",
		["LaserGreen"] = "lvs_laser_green",
		["TracerGreen"] = "lvs_tracer_green",
		["TracerOrange"] = "lvs_tracer_orange",
		["TracerWhite"] = "lvs_tracer_white",
		["TracerYellow"] = "lvs_tracer_yellow",
		["AutoCannon"] = "lvs_tracer_autocannon",
		["Cannon"] = "lvs_tracer_cannon",
	}
	for id, name in pairs( TracerOptions ) do
		if not file.Exists( "effects/"..name..".lua", "LUA" ) then continue end
		TracerEffect["Options"][id]	= { lvsturret_tracer = name }
	end
	CPanel:AddControl("ComboBox", TracerEffect )

	CPanel:AddControl( "Slider", { Label = "Shoot Delay", Type = "Float", Min = 0, Max = 2.0, Command = "lvsturret_delay" } )

	CPanel:AddControl( "Slider", { Label = "Damage", Type = "Float", Min = 0, Max = 1000, Command = "lvsturret_damage" } )

	CPanel:AddControl( "Slider", { Label = "Bullet Speed", Type = "Float", Min = 10000, Max = 100000, Command = "lvsturret_speed" } )

	CPanel:AddControl( "Slider", { Label = "Bullet Spread", Type = "Float", Min = 0, Max = 1, Command = "lvsturret_spread" } )

	CPanel:AddControl( "Slider", { Label = "Hull Size", Type = "Float", Min = 0, Max = 50, Command = "lvsturret_size" } )

	CPanel:AddControl( "Slider", { Label = "Armor Penetration (mm)", Type = "Float", Min = 0, Max = 500, Command = "lvsturret_penetration" } )

	CPanel:AddControl( "Slider", { Label = "Splash Damage", Type = "Float", Min = 0, Max = 1000, Command = "lvsturret_splashdamage" } )

	CPanel:AddControl( "Slider", { Label = "Splash Radius", Type = "Float", Min = 0, Max = 750, Command = "lvsturret_splashradius" } )

	local SplashType = {Label = "Splash Type", MenuButton = 0, Options={}, CVars = {}}
	SplashType["Options"][ "Shrapnel" ] = { lvsturret_splasheffect = "lvs_bullet_impact" }
	SplashType["Options"][ "Explosive" ] = { lvsturret_splasheffect =  "lvs_bullet_impact_explosive" }
	CPanel:AddControl("ComboBox", SplashType )
end

--gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/permaprops.lua:
/*
	PermaProps
	Created by Entoros, June 2010
	Facepunch: http://www.facepunch.com/member.php?u=180808
	Modified By Malboro 28 / 12 / 2012
	
	Ideas:
		Make permaprops cleanup-able
		
	Errors:
		Errors on die

	Remake:
		By Malboro the 28/12/2012
*/

TOOL.Category		=	"Age of Clones"
TOOL.Name			=	"PermaProps"
TOOL.Command		=	nil
TOOL.ConfigName		=	""

if CLIENT then
	language.Add("Tool.permaprops.name", "PermaProps")
	language.Add("Tool.permaprops.desc", "Save a props permanently")
	language.Add("Tool.permaprops.0", "LeftClick: Add RightClick: Remove Reload: Update")

	surface.CreateFont("PermaPropsToolScreenFont", { font = "Arial", size = 40, weight = 1000, antialias = true, additive = false })
	surface.CreateFont("PermaPropsToolScreenSubFont", { font = "Arial", size = 30, weight = 1000, antialias = true, additive = false })
end

function TOOL:LeftClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end
	
	if !PermaProps.HasPermission( ply, "Save") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if ent.PermaProps then ply:ChatPrint( "That entity is already permanent !" ) return end

	local content = PermaProps.PPGetEntTable(ent)
	if not content then return end

	local max = 1




	--PermaProps.SQL.Query("INSERT INTO permaprops (id, map, content) VALUES(NULL, ".. sql.SQLStr(game.GetMap()) ..", ".. sql.SQLStr(util.TableToJSON(content)) ..");")


		local insertObj = mysql:Insert("permaprops");
		insertObj:Insert("map", game.GetMap());
        insertObj:Insert("content", util.TableToJSON(content));
		insertObj:Callback(function(result, status, lastID)
			
			local new_ent = PermaProps.PPEntityFromTable(content, max)
			if !new_ent or !new_ent:IsValid() then return end

			PermaProps.SparksEffect( ent )
			ply:ChatPrint("You saved " .. ent:GetClass() .. " with model ".. ent:GetModel() .. " to the database.")
			ent:Remove()
		end);
		insertObj:Execute();





	return true

end

function TOOL:RightClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end

	if !PermaProps.HasPermission( ply, "Delete") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if not ent.PermaProps then ply:ChatPrint( "That is not a PermaProp !" ) return end
	if not ent.PermaProps_ID then ply:ChatPrint( "ERROR: ID not found" ) return end

	--PermaProps.SQL.Query("DELETE FROM permaprops WHERE id = ".. ent.PermaProps_ID ..";")
		local deleteObj = mysql:Delete("permaprops");

		deleteObj:Where("id", ent.PermaProps_ID);
		deleteObj:Callback(function(result, status, lastID)
			
			ply:ChatPrint("You erased " .. ent:GetClass() .. " with a model of " .. ent:GetModel() .. " from the database.")
			ent:Remove()

		end);
	deleteObj:Execute();



	return true

end

function TOOL:Reload(trace)

	if CLIENT then return true end

	if not PermaProps then self:GetOwner():ChatPrint( "ERROR: Lib not found" ) return end

	if (not trace.Entity:IsValid() and PermaProps.HasPermission( self:GetOwner(), "Update")) then self:GetOwner():ChatPrint( "You have reload all PermaProps !" ) PermaProps.ReloadPermaProps() return false end

	if trace.Entity.PermaProps then

		local ent = trace.Entity
		local ply = self:GetOwner()

		if !PermaProps.HasPermission( ply, "Update") then return end

		if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
		
		local content = PermaProps.PPGetEntTable(ent)
		if not content then return end

		--PermaProps.SQL.Query("UPDATE permaprops set content = ".. sql.SQLStr(util.TableToJSON(content)) .." WHERE id = ".. ent.PermaProps_ID .." AND map = ".. sql.SQLStr(game.GetMap()) .. ";")
		local updateObj = mysql:Update("permaprops");
		updateObj:Update("content", util.TableToJSON(content));
		updateObj:Where("id", ent.PermaProps_ID);
		updateObj:Where("map", game.GetMap());
		updateObj:Callback(function(result, status, lastID)
				

				local new_ent = PermaProps.PPEntityFromTable(content, ent.PermaProps_ID)
				if !new_ent or !new_ent:IsValid() then return end

				PermaProps.SparksEffect( ent )

				ply:ChatPrint("You updated the " .. ent:GetClass() .. " in the database.")

				ent:Remove()


			end);
		updateObj:Execute(); 



	else

		return false

	end

	return true

end

function TOOL.BuildCPanel(panel)

	panel:AddControl("Header",{Text = "PermaProps", Description = "PermaProps\n\nSaves entities across map changes\n"})
	panel:AddControl("Button",{Label = "Open Configuration Menu", Command = "pp_cfg_open"})

end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(143, 0, 0)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("PermaPropsToolScreenFont")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("PermaPropsToolScreenSubFont")
	local w2, h2 = surface.GetTextSize(" ")

	draw.SimpleText("AOCRP", "PermaPropsToolScreenFont", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	draw.SimpleText("PermaProps", "PermaPropsToolScreenSubFont", 128, 128 + (h + h2) / 2 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end

--lua/weapons/gold_katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Gold katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Gold"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 190, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, -45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 216, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 180, 0), size = Vector(0.15, 0.15, 0.3), color = Color(255, 216, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/blocks/cube1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.601, 0, 9), angle = Angle(0, 90, -5), size = Vector(0.009, 0.019, 0.1), color = Color(255, 216, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 190, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils+++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 180, 0), size = Vector(0.15, 0.15, 0.3), color = Color(255, 216, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 190, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 216, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 190, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/blocks/cube1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.601, 0, 9), angle = Angle(0, 90, -5), size = Vector(0.009, 0.019, 0.1), color = Color(255, 216, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 30
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 60
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/gold_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Gold Sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Gold"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.599), angle = Angle(0, 90, 0), size = Vector(0.119, 0.449, 0.119), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.599), angle = Angle(0, 90, 0), size = Vector(0.119, 0.449, 0.119), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} }
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 35
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.5
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.9
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/ls_ap_mine_swep.lua:
AddCSLuaFile()

hook.Add("Initialize", "ls_add_ap_mine_ammo", function()
    game.AddAmmoType( {
        name = "LS_AP_MINE",
        dmgtype = DMG_BLAST, 
        plydmg = 0,
        npcdmg = 0,
        force = 0,
        maxcarry = 5,
        minsplash = 0,
        maxsplash = 0
    } )
end)
if CLIENT then
    language.Add("LS_AP_MINE_ammo", "Anti-Personnel Mine")
end

SWEP.Base = "ls_base_mine_swep"

SWEP.PrintName = "Anti-Personnel Mine"
SWEP.Author = "List-Scripts"
SWEP.Instructions = ""
SWEP.Category = "Star Wars - Mines"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.DefaultClip = 5 -- the default amount of ammo the swep comes with
SWEP.Primary.Ammo = "LS_AP_MINE" -- the ammo type of the swep

SWEP.Mine = "ls_ap_mine" -- class of the mine entity to be used
SWEP.AngleLimitation = false -- the max angle the mine can be placed at, false for no limit
SWEP.PlaceDelay = 0.5 -- the delay between placing mines
SWEP.CanUndo = false -- whether the mine can be undone by the player

-- put the model for view and world model here, which the player hold in his hand
-- use the swep construction kit for help with positioning if wanted
SWEP.VElements = {
	["mine"] = { type = "Model", model = "models/props/starwars/weapons/ap_mine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 2.596, 0.518), angle = Angle(-180, 0, 0)}
}

SWEP.WElements = {
	["mine"] = { type = "Model", model = "models/props/starwars/weapons/ap_mine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 2.596, 1.557), angle = Angle(-180, 0, 0)}
}
--addons/arccw_weapons/lua/weapons/masita_dc17m_launcher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17m Launcher"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17m_launcher_new.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/c_dc17m_grenade.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc17m_antiarmour.mdl"
SWEP.ViewModelFOV = 55
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-13, 7, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Grenade Launcher properties
SWEP.ShootEntity = "arccw_nade_launcher17m"
SWEP.MuzzleVelocity = 4000

-- Damage & Tracer
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1
SWEP.ExtendedClipSize = 1
SWEP.ReducedClipSize = 1

SWEP.Recoil = 0.1
SWEP.RecoilSide = 0.175
SWEP.RecoilRise = 0.76

SWEP.Delay = 60 / 105
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PrintName = "ROCKET",
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 1
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 125 
SWEP.SightsDispersion = 0 
SWEP.JumpDispersion = 200

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"
SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "armas/disparos/dc17m/dc17m_grenade_fire0.wav"
SWEP.ShootSound = "armas/disparos/dc17m/dc17m_grenade_fire0.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 167, 0)


SWEP.IronSightStruct = {
    Pos = Vector(-4.14, -0.32, 2.207),
    Ang = Angle(2.267, -0.76, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 3, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(0, 2, 2)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)


-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(3.3, -0.1, 4.9),
            vang = Angle(0, -0.5, 0),
        },
        CorrectiveAng = Angle(0, 1, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(13, -1.76, 2.7),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Rocket",
        DefaultAttName = "Standard",
        Slot = {"ammo_rocket"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0, -1.4, 2.4),
            vang = Angle(0, 0, 0),
        },
    },
}



SWEP.Animations = {
    ["enter_inspect"]= {
        Source = "pose",
        SoundTable = {
            {
                s = "masita/weapons/dc17m/dc17m_grenade_pose.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee", 
        SoundTable = {
            {s = "armas/disparos/dc17m/melee0.wav", t = 0.1 },
        },
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false
    },
    ["idle_iron"] = {
        Source = false
    },
    ["idle_sight"] = {
        Source = false
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "masita/weapons/dc17m/dc17m_grenade_draw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "masita/weapons/dc17m/dc17m_grenade_holster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "masita/weapons/dc17m/dc17m_grenade_reload.wav", t = 0.1 }, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/masita_dual_dc17s_blue.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Dual DC-17s [Blue]"
SWEP.Trivia_Class = "Heavy Dual Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dual_dc17s_blue.png"

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/c_reaper_nope.mdl"
SWEP.WorldModel = "models/rising/base/c_akimbo.mdl"
SWEP.ViewModelFOV = 80
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.DefaultWMSkin = 1
SWEP.DefaultSkin = 1

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 348
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc17s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc17", "dc17+"}

SWEP.AttachmentElements = {
    ["dc17"] = {
        VMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single.mdl",
                Bone = "ReaperShot1",
                ModelSkin = 1,
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-16.912, -2, 3.986),
                    ang = Angle(0, -20, 90)
                }
            }
        },
    },
    ["dc17+"] = {
         VMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single.mdl",
                Bone = "ReaperShot2",
                ModelSkin = 1,
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-16.912, -0.872, 3.986),
                    ang = Angle(0, -20, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                ModelSkin = 1,
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                ModelSkin = 1,
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/weapon/ven/ggn/dc17s_single_world.mdl"

--SWEP.Attachments 
SWEP.Attachments = {   
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["bash"] = {
        Source = "bash"
    },
    ["fire"] = {
        Source = {"shoot", "shoot2"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 0.5}, 
            {s = "weapons/reapershotsound/draw.wav", t = 2}
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "weapons/reapershotsound/throw.wav"
    }),
}
--lua/weapons/neon_axe/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Stylish neon..."
SWEP.Instructions = "You know what to do..."

SWEP.PrintName = "Neon axe"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 70
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "melee"

SWEP.ShowWorldModel = false

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.HoldType = "melee"
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 99
SWEP.Primary.DelayMiss = 0.8
SWEP.Primary.DelayHit = 1.2
SWEP.Primary.Force = 140

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(16, 4.599, 0), angle = Angle(-45, -25, 70) }
}

SWEP.VElements = {
	["handle_load"] = { type = "Model", model = "models/phxtended/tri2x1x1solid.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-5, 0, 1.5), angle = Angle(180, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(125, 125, 125, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["gear2"] = { type = "Model", model = "models/props_phx/gears/bevel90_24.mdl", bone = "v_weapon.Knife_Handle", rel = "gear", pos = Vector(0, 0, 0.8), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["handle"] = { type = "Model", model = "models/props_junk/harpoon002a.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -12), angle = Angle(-90, 0, 0), size = Vector(0.5, 0.5, 0.5), color = Color(50, 50, 50, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["blade_load"] = { type = "Model", model = "models/phxtended/tri2x1x1solid.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-27, -0.801, -1), angle = Angle(0, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(125, 125, 125, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/props_phx/construct/metal_angle90.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-25, 0.1, -0.48), angle = Angle(0, 45, 0), size = Vector(0.23, 0.23, 0.189), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["rack"] = { type = "Model", model = "models/props_phx/gears/rack18.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-20, -0.431, 0), angle = Angle(-90, 90, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["what"] = { type = "Model", model = "models/props_combine/CombineThumper002.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-26, 7.3, -0.5), angle = Angle(90, 0, -90), size = Vector(0.039, 0.039, 0.039), color = Color(255, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["train"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-20, 0, 0), angle = Angle(90, 90, 0), size = Vector(0.009, 0.012, 0.009), color = Color(145, 145, 145, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["prop+"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-23.5, -0.9, 0), angle = Angle(0, -25, -90), size = Vector(0.2, 0.2, 0.05), color = Color(255, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["rack2"] = { type = "Model", model = "models/props_phx/gears/rack18.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-21, 4.675, -0.5), angle = Angle(90, -90, -45), size = Vector(0.1, 0.1, 0.1), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["gyro"] = { type = "Model", model = "models/maxofs2d/hover_rings.mdl", bone = "v_weapon.Knife_Handle", rel = "gear", pos = Vector(0, 0, 1.5), angle = Angle(0, 0, 0), size = Vector(0.129, 0.129, 0.129), color = Color(255, 0, 0, 255), surpresslightning = true, material = "", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-25.8, -2, 0), angle = Angle(0, -25, -90), size = Vector(0.2, 0.2, 0.05), color = Color(255, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["gear"] = { type = "Model", model = "models/Mechanics/gears2/gear_18t3.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-25, 0, 0), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.119), color = Color(80, 80, 80, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/props_phx/construct/metal_angle90.mdl", bone = "v_weapon.Knife_Handle", rel = "handle", pos = Vector(-25, 0, -0.5), angle = Angle(0, 45, 0), size = Vector(0.2, 0.2, 0.2), color = Color(60, 60, 60, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["decor"] = { type = "Model", model = "models/mechanics/roboticslarge/clawl.mdl", bone = "v_weapon.Knife_Handle", rel = "blade", pos = Vector(-1.67, 4, 0.4), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(100, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}





SWEP.WElements = {
	["handle_load"] = { type = "Model", model = "models/phxtended/tri2x1x1solid.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-5, 0, 1.5), angle = Angle(180, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(125, 125, 125, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["gear2"] = { type = "Model", model = "models/props_phx/gears/bevel90_24.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "gear", pos = Vector(0, 0, 0.8), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["handle"] = { type = "Model", model = "models/props_junk/harpoon002a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 12), angle = Angle(90, 0, 90), size = Vector(0.5, 0.5, 0.5), color = Color(50, 50, 50, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["train"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-20, 0, 0), angle = Angle(90, 90, 0), size = Vector(0.009, 0.012, 0.009), color = Color(145, 145, 145, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/props_phx/construct/metal_angle90.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-25, 0.1, -0.473), angle = Angle(0, 45, 0), size = Vector(0.23, 0.23, 0.189), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["rack"] = { type = "Model", model = "models/props_phx/gears/rack18.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-20, -0.431, 0), angle = Angle(-90, 90, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["decor"] = { type = "Model", model = "models/mechanics/roboticslarge/clawl.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "blade", pos = Vector(-1.67, 4, 0.4), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(100, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["gyro"] = { type = "Model", model = "models/maxofs2d/hover_rings.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "gear", pos = Vector(0, 0, 1.5), angle = Angle(0, 0, 0), size = Vector(0.129, 0.129, 0.129), color = Color(255, 0, 0, 255), surpresslightning = true, material = "", skin = 0, bodygroup = {} },
	["prop+"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-23.5, -0.9, 0), angle = Angle(0, -25, -90), size = Vector(0.2, 0.2, 0.05), color = Color(255, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["rack2"] = { type = "Model", model = "models/props_phx/gears/rack18.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-21, 4.675, -0.5), angle = Angle(90, -90, -45), size = Vector(0.1, 0.1, 0.1), color = Color(255, 0, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["gear"] = { type = "Model", model = "models/Mechanics/gears2/gear_18t3.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-25, 0, 0), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.119), color = Color(80, 80, 80, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["what"] = { type = "Model", model = "models/props_combine/CombineThumper002.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-26, 7.3, -0.5), angle = Angle(90, 0, -90), size = Vector(0.039, 0.039, 0.039), color = Color(255, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-25.8, -2, 0), angle = Angle(0, -25, -90), size = Vector(0.2, 0.2, 0.05), color = Color(255, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/props_phx/construct/metal_angle90.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-25, 0, -0.5), angle = Angle(0, 45, 0), size = Vector(0.2, 0.2, 0.2), color = Color(60, 60, 60, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["blade_load"] = { type = "Model", model = "models/phxtended/tri2x1x1solid.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle", pos = Vector(-27, -0.801, -1), angle = Angle(0, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(125, 125, 125, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}



function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "weapons/iceaxe/iceaxe_swing1.wav" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 90
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 9000
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "weapons/crossbow/bolt_fly4.wav" )
else
self.Owner:EmitSound( "weapons/crossbow/bolt_fly4.wav" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--lua/weapons/neon_dagger/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Stylish neon..."
SWEP.Instructions = "You know what to do..."

SWEP.PrintName = "Neon dagger"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 75
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "knife"

SWEP.ShowWorldModel = false

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 25
SWEP.Primary.DelayMiss = 0.25
SWEP.Primary.DelayHit = 0.32
SWEP.Primary.Force = 140

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["blade_update2+"] = { type = "Model", model = "models/props_phx/gears/rack36.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(4.599, 0.5, 0), angle = Angle(-90, 71.5, 0), size = Vector(0.1, 0.07, 0.1), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["handle"] = { type = "Model", model = "models/dav0r/tnt/tnt.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(-2, 0, 0), angle = Angle(90, 0, 0), size = Vector(0.219, 0.219, 0.219), color = Color(100, 100, 100, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["handle_maybe"] = { type = "Model", model = "models/maxofs2d/hover_plate.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(-1.201, 0, 0), angle = Angle(-90, 0, 0), size = Vector(0.2, 0.319, 0.2), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade_update"] = { type = "Model", model = "models/props_combine/CombineThumper002.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(-1, 0, 0.5), angle = Angle(-90, -4.1, 0), size = Vector(0.029, 0.029, 0.029), color = Color(150, 150, 150, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["handle_update"] = { type = "Model", model = "models/props_combine/headcrabcannister01a.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(-6.801, 0, 0), angle = Angle(0, 3, 0), size = Vector(0.035, 0.035, 0.035), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["IDK what is it"] = { type = "Model", model = "models/hunter/plates/plate05x1.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, 5), angle = Angle(90, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade 1"] = { type = "Model", model = "models/hunter/plates/tri3x1.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(8.3, 0, -0.151), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(1.2, 1, -0.101), angle = Angle(0, 0, 0), size = Vector(0.2, 0.2, 0.05), color = Color(255, 100, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["decor1"] = { type = "Model", model = "models/hunter/plates/tri3x1.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(4.5, 0, -0), angle = Angle(0, 0, 0), size = Vector(0.079, 0.079, 0.15), color = Color(100, 100, 93, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade_update2"] = { type = "Model", model = "models/props_phx/gears/rack36.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(8, 0.18, 0), angle = Angle(-90, 71.5, 0), size = Vector(0.05, 0.09, 0.05), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["train_yeah"] = { type = "Model", model = "models/props_junk/harpoon002a.mdl", bone = "v_weapon.Knife_Handle", rel = "IDK what is it", pos = Vector(6.752, 2.799, 0), angle = Angle(0, 0, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} }
}


SWEP.WElements = {
	["blade_update2+"] = { type = "Model", model = "models/props_phx/gears/rack36.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(4.599, 0.5, 0), angle = Angle(-90, 71.5, 0), size = Vector(0.1, 0.07, 0.1), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["handle"] = { type = "Model", model = "models/dav0r/tnt/tnt.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(-2, 0, 0), angle = Angle(90, 0, 0), size = Vector(0.219, 0.219, 0.219), color = Color(100, 100, 100, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["handle_maybe"] = { type = "Model", model = "models/maxofs2d/hover_plate.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(-1.201, 0, 0), angle = Angle(-90, 0, 0), size = Vector(0.2, 0.319, 0.2), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade_update"] = { type = "Model", model = "models/props_combine/CombineThumper002.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(-1, 0, 0.5), angle = Angle(-90, -4.1, 0), size = Vector(0.029, 0.029, 0.029), color = Color(150, 150, 150, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["handle_update"] = { type = "Model", model = "models/props_combine/headcrabcannister01a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(-6.801, 0, 0), angle = Angle(0, 3, 0), size = Vector(0.035, 0.035, 0.035), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["IDK what is it"] = { type = "Model", model = "models/hunter/plates/plate05x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1, -5), angle = Angle(-90, 0, 90), size = Vector(0.1, 0.1, 0.1), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade 1"] = { type = "Model", model = "models/hunter/plates/tri3x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(8.3, 0, -0.151), angle = Angle(0, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(1.2, 1, -0.101), angle = Angle(0, 0, 0), size = Vector(0.2, 0.2, 0.05), color = Color(255, 100, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["decor1"] = { type = "Model", model = "models/hunter/plates/tri3x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(4.5, 0, 0), angle = Angle(0, 0, 0), size = Vector(0.079, 0.079, 0.15), color = Color(100, 100, 93, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade_update2"] = { type = "Model", model = "models/props_phx/gears/rack36.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(8, 0.18, 0), angle = Angle(-90, 71.5, 0), size = Vector(0.05, 0.09, 0.05), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["train_yeah"] = { type = "Model", model = "models/props_junk/harpoon002a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "IDK what is it", pos = Vector(6.699, 2.799, 0), angle = Angle(0, 0, 0), size = Vector(0.15, 0.2, 0.2), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} }
}


function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "weapons/iceaxe/iceaxe_swing1.wav" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 90
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 9000
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "weapons/crossbow/bolt_fly4.wav" )
else
self.Owner:EmitSound( "weapons/crossbow/bolt_fly4.wav" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--lua/weapons/omniblade/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Stylish neon..."
SWEP.Instructions = "You know what to do..."
SWEP.Contact      = "Type:Melee Class:Special"

SWEP.PrintName = "  Omniblade"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 64
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "knife"

SWEP.ShowWorldModel = false

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 75
SWEP.Primary.DelayMiss = 0.4
SWEP.Primary.DelayHit = 0.5
SWEP.Primary.Force = 140

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, -0.5, -1), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, -30), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(5, 0, 0) }
}


SWEP.VElements = {
	["handle_decor+"] = { type = "Model", model = "models/hunter/tubes/circle2x2.mdl", bone = "v_weapon.Knife_Handle", rel = "handle_base", pos = Vector(-2.401, 0, 0), angle = Angle(90, 0, 0), size = Vector(0.045, 0.045, 0.045), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["n2"] = { type = "Model", model = "models/hunter/plates/platehole1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "handle_decor_n2", pos = Vector(-6, -9.301, 0), angle = Angle(0, 90, 0), size = Vector(0.2, 0.029, 0.397), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["big_decor+"] = { type = "Model", model = "models/props_combine/headcrabcannister01a.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "hand_decor", pos = Vector(-2, 1.5, -2), angle = Angle(90, 0, 0), size = Vector(0.07, 0.07, 0.07), color = Color(255, 120, 0, 150), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["blade_decor"] = { type = "Model", model = "models/squad/sf_tubes/sf_tube1x180.mdl", bone = "v_weapon.Knife_Handle", rel = "handle_base", pos = Vector(-2.6, 5, -1), angle = Angle(0, 90, 90), size = Vector(0.1, 0.1, 0.1), color = Color(255, 120, 0, 175), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["hand_decor"] = { type = "Model", model = "models/hunter/tubes/tube2x2x05.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(5, 0, 0), angle = Angle(0, 90, 90), size = Vector(0.059, 0.059, 0.1), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["handle_base"] = { type = "Model", model = "models/hunter/tubes/tube2x2x05.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, -2.5, 2), angle = Angle(0, 0, 90), size = Vector(0.05, 0.05, 0.05), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["big_decor_decor_xd"] = { type = "Model", model = "models/hunter/misc/platehole1x1c.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "hand_decor", pos = Vector(-1, 2.299, 4.5), angle = Angle(90, 64, 0), size = Vector(0.14, 0.05, 0.14), color = Color(255, 125, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["big_decor++"] = { type = "Model", model = "models/props_combine/headcrabcannister01a.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "hand_decor", pos = Vector(0, 2.549, -2), angle = Angle(90, 0, 0), size = Vector(0.07, 0.07, 0.07), color = Color(255, 120, 0, 150), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["handle_decor"] = { type = "Model", model = "models/hunter/tubes/circle2x2.mdl", bone = "v_weapon.Knife_Handle", rel = "handle_base", pos = Vector(-2.3, 0, 0), angle = Angle(90, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(220, 80, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["blade_base"] = { type = "Model", model = "models/squad/sf_tris/sf_tri1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "handle_base", pos = Vector(-1.831, 0, 3.7), angle = Angle(0, -90, 90), size = Vector(0.449, 0.699, 0.449), color = Color(255, 120, 0, 175), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["handle_decor_n2"] = { type = "Model", model = "models/hunter/tubes/tube2x2x025d.mdl", bone = "v_weapon.Knife_Handle", rel = "handle_base", pos = Vector(-2.01, 0.36, -1), angle = Angle(0, -90, 90), size = Vector(0.1, 0.1, 0.1), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["blade_base+"] = { type = "Model", model = "models/squad/sf_tris/sf_tri1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "handle_base", pos = Vector(-1.8, -1, 3.7), angle = Angle(0, -90, 90), size = Vector(0.3, 2, 0.5), color = Color(255, 120, 0, 175), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["hand_decor+"] = { type = "Model", model = "models/hunter/tubes/tube2x2x05.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(-0.5, 0.699, 0), angle = Angle(0, 95, 90), size = Vector(0.05, 0.05, 0.5), color = Color(220, 80, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} }
}


SWEP.WElements = {
	["handle_decor+"] = { type = "Model", model = "models/hunter/tubes/circle2x2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle_base", pos = Vector(-2.401, 0, 0), angle = Angle(90, 0, 0), size = Vector(0.045, 0.045, 0.045), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["n2"] = { type = "Model", model = "models/hunter/plates/platehole1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle_decor_n2", pos = Vector(-6, -9.301, 0), angle = Angle(0, 90, 0), size = Vector(0.2, 0.029, 0.397), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["big_decor+"] = { type = "Model", model = "models/props_combine/headcrabcannister01a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hand_decor", pos = Vector(-2, 1.5, -2), angle = Angle(90, 0, 0), size = Vector(0.07, 0.07, 0.07), color = Color(255, 120, 0, 150), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["blade_decor"] = { type = "Model", model = "models/squad/sf_tubes/sf_tube1x180.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle_base", pos = Vector(-2.6, 5, -1), angle = Angle(0, 90, 90), size = Vector(0.1, 0.1, 0.1), color = Color(255, 120, 0, 175), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["hand_decor"] = { type = "Model", model = "models/hunter/tubes/tube2x2x05.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(7, 0, 0), angle = Angle(-90, 0, 0), size = Vector(0.059, 0.059, 0.1), color = Color(255, 100, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["handle_base"] = { type = "Model", model = "models/hunter/tubes/tube2x2x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(0, 0, 0), angle = Angle(100, -180, 0), size = Vector(0.05, 0.05, 0.05), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["big_decor_decor_xd"] = { type = "Model", model = "models/hunter/misc/platehole1x1c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hand_decor", pos = Vector(-1, 2.299, 4.5), angle = Angle(90, 64, 0), size = Vector(0.14, 0.05, 0.14), color = Color(255, 125, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["blade_base+"] = { type = "Model", model = "models/squad/sf_tris/sf_tri1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle_base", pos = Vector(-1.8, -1, 3.7), angle = Angle(0, -90, 90), size = Vector(0.3, 2, 0.5), color = Color(255, 120, 0, 175), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["handle_decor_n2"] = { type = "Model", model = "models/hunter/tubes/tube2x2x025d.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle_base", pos = Vector(-2.01, 0.36, -1), angle = Angle(0, -90, 90), size = Vector(0.1, 0.1, 0.1), color = Color(255, 120, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["blade_base"] = { type = "Model", model = "models/squad/sf_tris/sf_tri1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle_base", pos = Vector(-1.831, 0, 3.7), angle = Angle(0, -90, 90), size = Vector(0.449, 0.699, 0.449), color = Color(255, 120, 0, 175), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["handle_decor"] = { type = "Model", model = "models/hunter/tubes/circle2x2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "handle_base", pos = Vector(-2.3, 0, 0), angle = Angle(90, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(220, 80, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["big_decor++"] = { type = "Model", model = "models/props_combine/headcrabcannister01a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hand_decor", pos = Vector(0, 2.549, -2), angle = Angle(90, 0, 0), size = Vector(0.07, 0.07, 0.07), color = Color(255, 120, 0, 150), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} },
	["hand_decor+"] = { type = "Model", model = "models/hunter/tubes/tube2x2x05.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(7, 0, 0), angle = Angle(-90, 0, 0), size = Vector(0.05, 0.05, 0.5), color = Color(220, 80, 0, 255), surpresslightning = true, material = "phoenix_storms/white_brushes", skin = 0, bodygroup = {} }
}


function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 100,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 100,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "weapons/iceaxe/iceaxe_swing1.wav" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 90
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 9000
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "weapons/crossbow/hitbod2.wav" )
if (tr.HitSky) then return end
				local effect = EffectData();
				effect:SetOrigin(tr.HitPos);
				effect:SetNormal( tr.HitNormal );
				local rnum = math.random(1,1)
				if rnum == 1 then
				util.Effect("OmniBladeImpact", effect);
				else
				util.Effect("ManhackSparks", effect);
				end
else
if (tr.HitSky) then return end
				local effect = EffectData();
				effect:SetOrigin(tr.HitPos);
				effect:SetNormal( tr.HitNormal );
				local rnum = math.random(1,1)
				if rnum == 1 then
				util.Effect("omniblade_impact", effect);
				else
				util.Effect("ManhackSparks", effect);
				end
self.Owner:EmitSound( "weapons/crossbow/hitbod1.wav" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--addons/weapons_other/lua/weapons/recondroidcontroller.lua:
AddCSLuaFile()
SWEP.PrintName = "Recon Droid Controller"
SWEP.Author = "Evan"
SWEP.Purpose = "Remote control your recon droid"
SWEP.Instructions = "Left click to take control. Right Click to release it."
SWEP.Category = "Star Wars Utility"
SWEP.Base = "weapon_base"
SWEP.Slot = 3
SWEP.SlotPos = 5
SWEP.DrawAmmo	= false
SWEP.DrawCrosshair = true

SWEP.HoldType 				= "duel"
SWEP.UseHands				= true
SWEP.ViewModel 				= "models/weapons/cstrike/c_pist_elite.mdl"
SWEP.WorldModel 			= "models/weapons/w_pistol.mdl"
SWEP.ShowViewModel 			= false
SWEP.ShowWorldModel 		= false
SWEP.HoldType 				= "duel"
SWEP.ViewModelFOV 			= 100
SWEP.ViewModelFlip 			= false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false;
SWEP.Primary.Ammo	= "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.WElements = {
	["we"] = { 
		type = "Model",
		model = "models/lt_c/sci_fi/holo_tablet.mdl", //models/lt_c/sci_fi/holo_tablet.mdl
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(4, 13, 1),
		angle = Angle(140, 1, 1),
		size = Vector(1.2, 2, 1.2),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.VElements = {
	["ve"] = { 
		type = "Model",
		model = "models/lt_c/sci_fi/holo_tablet.mdl", //models/lt_c/sci_fi/holo_tablet.mdl
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(4.50, 16, 0),
		angle = Angle(100, 270, 90),
		size = Vector(2.2, 2.5, 2),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.ViewModelBoneMods = {

	["v_weapon.elite_right"] = { scale = Vector(0, 0, 0), pos = Vector(0, 0, 100), angle = Angle(0, 0, 0) },
	
	["v_weapon.elite_left"] = { scale = Vector(0, 0, 0), pos = Vector(0, 0, 100), angle = Angle(0, 0, 0) },

	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 8, -12), angle = Angle(5, 50, 8) },
	
	["ValveBiped.Bip01_L_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(5, 0, 0), angle = Angle(40, 30, 0) },
	
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 8, 0), angle = Angle(0, 0, 0) }

}



function SWEP:Deploy()

end

function SWEP:PrimaryAttack()
 
if !IsValid(self.Owner.droid) then return end
if !self.Owner:IsOnGround() then return end
	if self.Owner.droid.broken == true then return end
	self.Owner:SetNWBool("CameraPOV",true)
	self.Owner:SetMoveType(MOVETYPE_NONE)
	self.Owner.ispilot = true
end

function SWEP:Think()

	/*for k, v in pairs(ents.GetAll()) do
	if !v:IsPlayer() then return end
		if self:GetPos():Distance(v:GetPos()) < 300 then
			v.inrange = true
		else 
			v.inrange = false
		end
	
	end*/
	
end



function SWEP:SecondaryAttack()
if !IsValid(self.Owner.droid) then return end
	self.Owner:SetNWBool("CameraPOV",false)
	self.Owner:SetMoveType(MOVETYPE_WALK)
	self.Owner.ispilot = false
end

function SWEP:Reload()

end

function SWEP:Initialize()
	self:SetHoldType("duel")
	
	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

	
function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	function SWEP:HUDShouldDraw( name )
		if ( name == "CHudWeaponSelection" ) then return true end
		if ( name == "CHudChat" ) then return true end
		return false
	end 
	SWEP.vRenderOrder = nil

	function SWEP:ViewModelDrawn()

		
		//print("EVAN")
		local vm = self.Owner:GetViewModel()

		if !IsValid(vm) then return end
		//print("EVAN 1")
		

		if (!self.VElements) then return end
		//print("EVAN 2")
		

		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then

			//print("EVAN 3")

			// we build a render order because sprites need to be drawn after models

			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do

				if (v.type == "Model") then
					//print("EVAN 4")
					table.insert(self.vRenderOrder, 1, k)

				elseif (v.type == "Sprite" or v.type == "Quad") then
					//print("EVAN 5")
					table.insert(self.vRenderOrder, k)

				end

			end

			

		end

		for k, name in ipairs( self.vRenderOrder ) do

		

			local v = self.VElements[name]

			if (!v) then self.vRenderOrder = nil break end
			
			if (v.hide) then continue end
			
			

			local model = v.modelEnt

			local sprite = v.spriteMaterial

			

			if (!v.bone) then continue end
			
			

			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )

			

			if (!pos) then continue end
			
			

			if (v.type == "Model" and IsValid(model)) then
				//print("EVAN 10")
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )

				ang:RotateAroundAxis(ang:Up(), v.angle.y)

				ang:RotateAroundAxis(ang:Right(), v.angle.p)

				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)

				//model:SetModelScale(v.size)

				local matrix = Matrix()

				matrix:Scale(v.size)

				model:EnableMatrix( "RenderMultiply", matrix )

				

				if (v.material == "") then
					//print("EVAN 11")
					model:SetMaterial("")

				elseif (model:GetMaterial() != v.material) then

					model:SetMaterial( v.material )

				end

				

				if (v.skin and v.skin != model:GetSkin()) then
					//print("EVAN 12")
					model:SetSkin(v.skin)

				end

				

				if (v.bodygroup) then

					for k, v in pairs( v.bodygroup ) do

						if (model:GetBodygroup(k) != v) then

							model:SetBodygroup(k, v)

						end

					end

				end

				

				if (v.surpresslightning) then

					render.SuppressEngineLighting(true)

				end

				

				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)

				render.SetBlend(v.color.a/255)

				model:DrawModel()

				render.SetBlend(1)

				render.SetColorModulation(1, 1, 1)

				

				if (v.surpresslightning) then

					render.SuppressEngineLighting(false)

				end

				

			elseif (v.type == "Sprite" and sprite) then

				

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z

				render.SetMaterial(sprite)

				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)

				

			elseif (v.type == "Quad" and v.draw_func) then

				

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z

				ang:RotateAroundAxis(ang:Up(), v.angle.y)

				ang:RotateAroundAxis(ang:Right(), v.angle.p)

				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				

				cam.Start3D2D(drawpos, ang, v.size)

					v.draw_func( self )

				cam.End3D2D()

			end

			

		end

		

	end
	
	
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		if (!self.WElements) then return end
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
	
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end 
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
		end
	end

function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end


	function SWEP:CreateModels( tab )
		if (!tab) then return end
		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			if (!vm:GetBoneCount()) then return end
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
					
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end




--addons/joes_stuff/lua/weapons/remote_trigger/shared.lua:
SWEP.PrintName = "Remote-Trigger"
SWEP.Author =	"Joe"

SWEP.Spawnable =	false
SWEP.Adminspawnable =	false
SWEP.Category = "Joe"
SWEP.ShowWorldModel = false


SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 55
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/thejoe/v_detonator.mdl"
SWEP.WorldModel = "models/thejoe/w_detonator.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.DrawCrosshair = false

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	false
SWEP.Primary.Ammo =	"none"

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"
SWEP.UseHands = true

SWEP.animinprogress = false

SWEP.state = true

function SWEP:PrimaryAttack()
	if not SERVER then return end
	local vm = self.Owner:GetViewModel()
	if vm:GetSequence() != self:LookupSequence("idle_open") then return end
	self:RunAnim("press", function()
		if not self.Owner.activebombs or table.Count(self.Owner.activebombs) <= 0 then return end
		for bomb,_ in pairs(self.Owner.activebombs) do
			if not IsValid(bomb) then continue end
			if bomb.defused then continue end
			if not bomb.activated then continue end
			bomb:Explode()
		end
	end)
	self:SetNextPrimaryFire(CurTime() + 1)
end

function SWEP:SecondaryAttack()
	if not SERVER then return end
	if self.animinprogress then return end
	if not self.Owner.activebombs or table.Count(self.Owner.activebombs) <= 0 then return end
	local deactivate
	for bomb,_ in pairs(self.Owner.activebombs) do
		if not IsValid(bomb) then continue end
		if bomb.activated then
			bomb:DeactivateBomb()
			deactivate = true
		else
			bomb:ActivateBomb()
			deactivate = false
		end
	end
	if deactivate then
		self:RunAnim("cap_open_to_closed", function() self:RunAnim("idle_closed") end)
	elseif deactivate == false then
		self:RunAnim("cap_closed_to_open", function() self:RunAnim("idle_open") end)
	end
	self:SetNextSecondaryFire(CurTime() + 2)
	self.Owner:EmitSound("weapons/slam/mine_mode.wav")
end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
	if not SERVER then return end
	if IsValid(self.bomb) and self.bomb.activated == false then
		self:RunAnim("idle_closed")
	else
		self:RunAnim("idle_open")
	end
end

function SWEP:RunAnim(anim,callback)
	if self.animinprogress then return end
	self.animinprogress = true
	local vm = self.Owner:GetViewModel()

	if isstring(anim) then
		anim = vm:LookupSequence( anim ) 
	end
	vm:SendViewModelMatchingSequence( anim )
	timer.Simple(self:SequenceDuration(anim), function()
		if not IsValid(self) then return end
		self.animinprogress = false
		if callback then callback() end
	end)
end

function SWEP:Holster()
	self.animinprogress = false
	return true
end

function SWEP:OnRemove()

end
--lua/weapons/sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = " Sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 80, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 180, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, -3.5, 5), angle = Angle(90, 0, 90), size = Vector(0.025, 0.05, 0.159), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 13.5), angle = Angle(0, 45, 0), size = Vector(0.029, 0.029, 0.349), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/iron_rails", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 0, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 180, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, -3.5, 5), angle = Angle(90, 0, 90), size = Vector(0.025, 0.05, 0.159), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 14.699), angle = Angle(0, 45, 0), size = Vector(0.029, 0.029, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/iron_rails", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 35
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.5
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.9
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapon_jedi/lua/weapons/weapon_lightsaber_anakin.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Anakin Skywalker"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("anakin")
		self:SetBladeR("blue")
	end
end

if CLIENT then return end 

function SWEP:ForcePowersGive(ply)
	ply:lscsWipeInventory()

	ply:lscsAddInventory("item_force_leap", true)
    ply:lscsAddInventory("item_force_push", true)
	ply:lscsAddInventory("item_force_pull", true)
	ply:lscsAddInventory("item_force_choke", true)
    ply:lscsAddInventory("item_force_throw", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)
    ply:lscsAddInventory("item_force_kick", true)

	ply:lscsAddInventory("item_stance_djemso", true)
	ply:lscsAddInventory("item_stance_shiicho", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/weapon_jedi/lua/weapons/weapon_nanosword.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category			= "[LSCS]"
SWEP.PrintName		= "Dragon's Tooth Sword"
SWEP.Author			= "Blu-x92 / Luna"

SWEP.Slot				= 0
SWEP.SlotPos			= 1

SWEP.Spawnable		= false
SWEP.AdminOnly		= true

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("nanosword")
		self:SetBladeR("nanoparticles")
	end
end

--addons/aoc_nextbots/lua/weapons/weapon_npc_b2.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: B2"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.1
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "everfall/weapons/b2_arm_blaster/style_1/blasters_e5-b2_laser_close_var_01.mp3"
SWEP.ClipSize = 40
SWEP.Damage = 15
SWEP.Spread = 0.1
SWEP.Bullets = 2

function SWEP:Initialize()
	self:SetHoldType("pistol")
end

--addons/aoc_nextbots/lua/weapons/weapon_npc_e5.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: E5"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = "models/npc/weapons/w_e5.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.2
SWEP.Damage = 20
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "everfall/weapons/blasters/e-5/e5.wav"
SWEP.ClipSize = 40
SWEP.Spread = 0.2


--lua/weapons/wood_dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Wood dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Wood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/props_c17/FurnitureDrawer001a_Shard01.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.1, 0.518, 5), angle = Angle(90, 100, -5.844), size = Vector(0.625, 1, 0.432), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -43.248, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/props_c17/FurnitureDrawer001a_Shard01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.1, 0.518, 5), angle = Angle(90, 100, -5.844), size = Vector(0.625, 1, 0.432), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 1
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 30
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapons_other/lua/entities/anim_gmantele_ex.lua:
AddCSLuaFile()

DEFINE_BASECLASS("base_anim")

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.Author = "Axel"
ENT.DoNotDuplicate = true
ENT.PhysgunDisabled = true
ENT.AutomaticFrameAdvance = true
ENT.WorldModel = "models/weapons/w_suitcase_passenger.mdl"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.OpenSound = "doors/metal_move1.wav"
ENT.CloseSound = "doors/door_metal_rusty_move1.wav"
ENT.FullyOpen = "doors/door_metal_thin_open1.wav"


function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "EndDoorTime")
	self:NetworkVar("Bool", 1, "Close")
	self:NetworkVar("Vector", 0, "PlayerColor")
end

if SERVER then
	function ENT:Initialize()
		BaseClass.Initialize(self)
		self:ResetSequence("idle_all_01")
		self:SetEndDoorTime(CurTime() + 2)
	end

	function ENT:Think()
		BaseClass.Think(self)
		if not self.StartWalking and self:GetEndDoorTime() < CurTime() then
			self:ResetSequence("walk_suitcase")
			self.StartWalking = CurTime() + 1.7
			self:SetVelocity(self:GetForward() * 30)
			self:SetMoveType(MOVETYPE_NOCLIP)
			self:SetPoseParameter("move_x", 0.5)
		elseif self.StartWalking and self.StartWalking < CurTime() and not self.ClosingDoor then
			self:SetEndDoorTime(CurTime() + 1)
			self.ClosingDoor = CurTime() + 0.3
		elseif self.ClosingDoor and self.ClosingDoor < CurTime() and not self.Finished then
			self.Finshed = true
			self:ResetSequence("idle_all_01")
			self:SetVelocity(vector_origin)
			self:SetMoveType(MOVETYPE_NONE)
			SafeRemoveEntityDelayed(self, 3)
		end

		self:NextThink(CurTime())
		return true
	end

	function ENT:UpdateTransmitState()
		return TRANSMIT_ALWAYS
	end
end

if CLIENT then
	local function DrawWall(pos, angle, width, height, color)
		if width < 0 or height < 0 then return end
		render.SetColorMaterial()
		render.DrawQuad(
			LocalToWorld(Vector( 0, -height, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( 0, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, -height, 0 ), angle_zero, pos, angle),
			color or COLOR_WHITE
		)
	end

	function ENT:Initialize()
		self:SetIK(false)
		self:DrawShadow(false)
		if not IsValid(self.ClientModel) then
			self.ClientModel = ClientsideModel(self.WorldModel)
			self.ClientModel:SetNoDraw(true)
		end
	end

	function ENT:Think()
		BaseClass.Think(self)

		self:SetNextClientThink(CurTime())
		self:SetRenderBounds(Vector(-16, -16, 0), Vector(16, 16, 64), Vector(75, 75, 75))
		return true
	end

	function ENT:OnRemove()
		if IsValid(self.ClientModel) then
			self.ClientModel:Remove()
		end
	end

	function ENT:DrawTranslucent()
		self:DrawShadow(false)
		if self:GetEndDoorTime() == 0 and not self.DPos or not self.StartTime then
			self.DPos = self:GetPos() + self:GetForward() * 32
			self.StartTime = CurTime()
			self:EmitSound(self.OpenSound)
			return
		end

		local pos, ang = self.DPos, self:GetForward():Angle()
		local dang = self:GetForward():Angle()
		dang:RotateAroundAxis(dang:Right(), - 90)
		dang:RotateAroundAxis(dang:Up(), 90)

		if self:GetEndDoorTime() < CurTime() and not self.CloseLatch then
			self.CloseLatch = true
			self:EmitSound(self.FullyOpen)
		elseif self.CloseLatch and self:GetEndDoorTime() > CurTime() and not self.Close then
			self.Close = true
			self.StartTime = CurTime()
			self:EmitSound(self.CloseSound)
		end

		local dur, elapsed = self:GetEndDoorTime() - self.StartTime, CurTime() - self.StartTime
		local per = math.Clamp(elapsed / dur, 0, 1)


		render.SetStencilEnable(true)
		render.ClearStencil()
		render.SetStencilTestMask(255)
		render.SetStencilWriteMask(255)

		render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
		render.SetStencilReferenceValue(1)

		per = (not self.Close and per or (1 - per))
		DrawWall(pos + ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

		local oldclip = render.EnableClipping(true)
		render.PushCustomClipPlane(self:GetForward(), self:GetForward():Dot(self.DPos))

		render.SetStencilReferenceValue(0)
		self:DrawModel()
		self:DrawBriefcase()

		render.PopCustomClipPlane()

		render.SetStencilReferenceValue(1)
		render.SetStencilPassOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)

		render.SuppressEngineLighting(true)
		render.ResetModelLighting(0, 0, 0)
		render.SetLocalModelLights(
			{
				{
					type = MATERIAL_LIGHT_SPOT,
					color = Vector(0.6, 0.6, 0.6),
					pos = self:GetPos() + self:GetForward() * 120 + self:GetUp() * 64,
					dir = -self:GetForward(),
					outerAngle = 90,
					linearFalloff = true,
				}
			}
		)

		render.PushCustomClipPlane(-self:GetForward(), -self:GetForward():Dot(self.DPos))
		render.DepthRange( 0, 0.1 )
		self:DrawModel()
		self:DrawBriefcase()
		render.DepthRange( 0, 1 )

		render.PopCustomClipPlane()
		render.SuppressEngineLighting(false)
		render.EnableClipping(oldclip)
		render.SetStencilEnable(false)

		dang:RotateAroundAxis(self:GetUp(), 180)
		DrawWall(pos - ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

	end

	function ENT:Draw()
		self:DrawTranslucent()
	end

	local offsetVec = Vector(5, -1, 0)
	local offsetAng = Angle(-90, 0, 0)
	function ENT:DrawBriefcase()
		local boneid = self:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
		if not boneid or not IsValid(self.ClientModel) then return end

		local matrix = self:GetBoneMatrix(boneid)
		if not matrix then return end

		local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

		self.ClientModel.IsBrief = true
		self.ClientModel:SetPos(newPos)
		self.ClientModel:SetAngles(newAng)
		self.ClientModel:DrawModel()
	end
end
--gamemodes/starwarsrp/entities/entities/aoc_fahrzeugspawner.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Fahrzeugterminal"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/console_02_2/console_02_2.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    
    function ENT:Use( activator, caller )
        if activator.AOCRPCurrentVehicle then
			if activator.AOCRPCurrentVehicle:IsValid() then
				activator.AOCRPCurrentVehicle:Remove()
				activator:ChatPrint("*** Dein Fahrzeug wurde eingeparkt.")
				--SetGlobalInt("JR_FahrzeugResourcen", GetGlobalInt("JR_FahrzeugResourcen", 10) + 1)
				activator.AOCRPCurrentVehicle = nil
			else
				activator.AOCRPCurrentVehicle = nil
				activator:ChatPrint("*** Dein zerstrtes Fahrzeug wurde geborgen. Einlagern nicht mglich.")
			end
		else
            net.Start("AOCRP_Fahrzeugspawner")
            net.Send(activator)
		end

    end

    util.AddNetworkString("AOCRP_Fahrzeugspawner")
    util.AddNetworkString("AOCRP_Fahrzeugspawner_Spawn")



    net.Receive( "AOCRP_Fahrzeugspawner_Spawn", function( len, ply )
        local class = net.ReadString()
        local pos = net.ReadVector()
        local ang = net.ReadAngle()
        local name = net.ReadString()

        if !table.HasValue(AOCRP.Gear.Data[ply:GetGearID()].vehicles, class) then ply:ChatPrint("*** Du darfst dieses Fahrzeug nicht ausparken.") return end

        local vehicle = ents.Create( class )
        --button:SetModel( "models/dav0r/buttons/button.mdl" )
        vehicle:SetPos( pos )
        vehicle:SetAngles( ang )
        vehicle:SetNetVar("AOCRP_Owner", ply)
        vehicle:SetNetVar("AOCRP.QIM.Menu", "lvs_generic" ) 
        vehicle:Spawn()

        ply:ConCommand("say /akt parkt einen "..vehicle.PrintName.." im "..name.. " aus.")
        --SetGlobalInt("JR_FahrzeugResourcen", GetGlobalInt("JR_FahrzeugResourcen", 10) - 1)
        ply.AOCRPCurrentVehicle = vehicle
    end )

end



if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self)  -- We want to override rendering, so don't call baseclass.
                                    -- Use this when you need to add to the rendering.
        --self:DrawEntityOutline( 1.0 ) -- Draw an outline of 1 world unit.
        --self:DrawModel()       -- Draw the model.


    end

    local function SpawnBlocked(spawn)

        local entsTbl = ents.FindInBox( spawn:GetPos() + Vector( -200, -200, -200 ), spawn:GetPos() + Vector( 200, 200, 200 ) )
     
        for k, v in ipairs(entsTbl) do
            if v:IsPlayer() or v.LFS or v.LVS then
                return true
            end
        end
        return false
     end

    function AOCRP_FahrzeugspawnerSelectSpawn(class)
        if ValidPanel(AOCRP_FahrzeugspawnerGUI) then AOCRP_FahrzeugspawnerGUI:Remove() end
        AOCRP_FahrzeugspawnerGUI = AOCDerma:DefaultFrame("Landeplatform")
        AOCRP_FahrzeugspawnerGUI:SetSize(AOCW(500),AOCH(800))
        AOCRP_FahrzeugspawnerGUI:Center()

        local fahrzeugeList = AOCDerma:ScrollBar(AOCRP_FahrzeugspawnerGUI) 
        fahrzeugeList:Dock(FILL)

        for k, v in SortedPairs(ents.FindByClass("aoc_fahrzeugmarker")) do

            local text = v:GetPlatformName()
            local btn = AOCDerma:Button(fahrzeugeList, text, function()  
            
                net.Start("AOCRP_Fahrzeugspawner_Spawn")
                net.WriteString(class)
                net.WriteVector(v:GetPos())
                net.WriteAngle(v:GetAngles())
                net.WriteString(v:GetPlatformName())
                net.SendToServer() 

                if ValidPanel(AOCRP_FahrzeugspawnerGUI) then AOCRP_FahrzeugspawnerGUI:Remove() end


            end, "bc")
            btn:Dock(TOP)
            btn:DockMargin(0,0,0,AOCH(5))

            function btn:PaintOver(w,h)
                if SpawnBlocked(v) then
                    self:SetEnabled(false)
                    self.akzent = Color(200,0,0,255)
                    self.akzenthover = Color(255,0,0,255)
                else
                    self:SetEnabled(true)
                    self.akzent = Color(0,200,0,255)
                    self.akzenthover = Color(0,255,0,255)
                end
            end
        end
    end

    function AOCRP_Fahrzeugspawner(fahrzeuge)
        if !fahrzeuge then LocalPlayer():ChatPrint("*** Du hast kein Zugriff auf irgendwelche Fahrzeuge") return end
        if !istable(fahrzeuge) then LocalPlayer():ChatPrint("*** Du hast kein Zugriff auf irgendwelche Fahrzeuge") return end
        if table.IsEmpty(fahrzeuge) then LocalPlayer():ChatPrint("*** Du hast kein Zugriff auf irgendwelche Fahrzeuge") return end
 
        if ValidPanel(AOCRP_FahrzeugspawnerGUI) then AOCRP_FahrzeugspawnerGUI:Remove() end
        AOCRP_FahrzeugspawnerGUI = AOCDerma:DefaultFrame("Fahrzeugterminal")
        AOCRP_FahrzeugspawnerGUI:SetSize(AOCW(500),AOCH(800))
        AOCRP_FahrzeugspawnerGUI:Center()

        local fahrzeugeList = AOCDerma:ScrollBar(AOCRP_FahrzeugspawnerGUI) 
        fahrzeugeList:Dock(FILL)

        for k, v in pairs(fahrzeuge) do

            local entTbl = scripted_ents.Get(v)
            local text = v
            if entTbl then
                text = entTbl.PrintName
            end
            local btn = AOCDerma:Button(fahrzeugeList, text, function() AOCRP_FahrzeugspawnerSelectSpawn(v) end, "lc")
            btn:Dock(TOP)
            btn:DockMargin(0,0,0,AOCH(5))
        end
    end

    net.Receive( "AOCRP_Fahrzeugspawner", function( len, ply )
        AOCRP_Fahrzeugspawner(AOCRP.Gears[LocalPlayer():GetGearID()].vehicles) 
    end )

end
--gamemodes/starwarsrp/entities/entities/aoc_interact.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Unsichtbarer Knopf (Interaktionen)"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.Editable = true

function ENT:SetupDataTables()

    self:NetworkVar( "String", 0, "InteractID", { KeyName = "InteractID",	Edit = { type = "Text"  } } ) 
    self:NetworkVar( "String", 1, "PrintName", { KeyName = "PrintName",	Edit = { type = "Text"  } } ) 


    if SERVER then
        self:SetInteractID("none")
        self:SetPrintName("Air Traffic Control")

    end

end

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate05x05.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(225,0,255))
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )
        --self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end


        



end


if CLIENT then

    
    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end
end
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_crab.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "Crab Droid"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/npc/starwars/crabby/crabdroid.mdl"
ENT.Weapon = "weapon_npc_crab"
ENT.HP = 1200
ENT.ShootingRange = 2000
ENT.LooseRadius = 4000
ENT.Proficiency = 0.2

ENT.Melee = false
ENT.MeleeDamage = 50
ENT.MeleeDelay = 3

ENT.Sounds = {}

ENT.ThrowGrenades = false
ENT.Grenades = {"summe_gr_impact"}

ENT.Anims = {
    ["idle"] = {0},
    ["shoot"] = {0},
    ["reload"] = {0},
    ["walk_slow"] = {"walk"},
    ["walk_fast"] = {"walk"},
    ["melee"] = {"walk"},
    ["jump"] = {0},
}

local walkSounds = {
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_1.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_2.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_3.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_4.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_5.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_6.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_7.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_8.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_9.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_10.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_11.mp3",
    "summe/nextbots/droids/b2/droids_b2_foley_movement_1p_sprint_var_01_12.mp3",
}

ENT.LastWalkSound = 0

function ENT:RunTo(pos, speed)
    if self.LastWalkSound <= CurTime() then
        self:EmitSound(table.Random(walkSounds), 120, 100, 1, CHAN_AUTO) 
        self.LastWalkSound = CurTime() + .3
    end

    if self.Path:GetAge() < 1 then return end
    if self.IsJumping then return end

    if speed and speed < 300 then
        self:PlayAnimation("walk_slow", true)
    else
        self:PlayAnimation("walk_fast", true)
    end

    self.loco:SetDesiredSpeed(speed or 200)
    self:PathFollowerCompute(pos)
end


function ENT:SetWeapon(weaponClass)
    local currentWeapon = self:GetWeapon()

    if currentWeapon then
        currentWeapon:Remove()
    end

    local newWep = ents.Create(weaponClass)
    newWep:Spawn()
    newWep:Activate()
    newWep:SetPos(self:GetPos() + Vector(0, 0, 20))
    newWep:SetSolid(SOLID_NONE)
    newWep:SetParent(self)
    newWep:AddEffects(EF_BONEMERGE)
    newWep:SetOwner(self)

    self.NormalWeaponClip = newWep:Clip1()

    self.weapon = newWep

    function newWep:CanPrimaryFire()
        return true
    end
end

function ENT:DoConfrontEnemy(ent)
    if not ent or not IsValid(ent) then return end

    local shootRange, inRange = self:EnemyInRange()

    if shootRange then
        if self.Path:IsValid() then
            self:PathFollowerStop()
        end


        if not self.IsJumping then
            self:ShootEnemy()
        end

        self.loco:FaceTowards(ent:GetPos())
    else
        if not inRange then
            self:SetEnemy(nil)
            self:GetNewEnemy()
            return
        end

        if self.IsJumping then return end

        if math.random(1, 100) >= 75 then
            self.IsJumping = true
            self:JumpTo(ent:GetPos())

            timer.Simple(2, function()
                self.IsJumping = false
            end)
        else
            self:RunTo(ent:GetPos(), self.Speed * 3)
        end
    end
end

function ENT:OnLandOnGround(ent)
    if not self.IsJumping then return end

    local radius = math.random(150, 300)
    local pos = self:GetPos()
    util.ScreenShake(pos, 20, 5, 1, radius)

    for k, v in pairs(player.FindInSphere(pos, radius)) do
        v:TakeDamage(math.random(0, 75), self, self)
        v:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 128), 0.3, 1)
    end

    self:SetCollisionGroup(COLLISION_GROUP_WORLD)

    timer.Simple(2, function()
        if not IsValid(self) then return end

        self:SetCollisionGroup(COLLISION_GROUP_NONE)
    end)
end

function ENT:OnNPCSpawn()
    self.loco:SetStepHeight(40)
end
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_metro.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "Benjamin Heuer"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/Police.mdl"
ENT.Weapon = "weapon_npc_e5c"
ENT.HP = 400
ENT.ShootingRange = 2000
ENT.LooseRadius = 4000
ENT.Proficiency = .05

ENT.Melee = true
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = false
ENT.Grenades = {"summe_gr_impact"}

ENT.Sounds = {}

ENT.Anims = {
    ["idle"] = {"idle1"},
    ["shoot"] = {"shootar2alt"},
    ["reload"] = {"reload"},
    ["walk_slow"] = {"walk_all"},
    ["walk_fast"] = {"runaimall1_sg"},
    ["melee"] = {"meleeattack01"},
}

function ENT:OnNPCSpawn()
    self:PlayAnimation("idle")
end
--lua/entities/arccw_ammo_plinking_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Plinking Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/plinking_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "plinking"
ENT.AmmoCount = 500

ENT.DetonationDamage = 10
ENT.DetonationRadius = 128
ENT.DetonationSound = nil

DEFINE_BASECLASS(ENT.Base)
function ENT:DetonateRound()
    BaseClass.DetonateRound(self)
    self:EmitSound("weapons/pistol/pistol_fire2.wav", 70, 175, 0.8)
end
--addons/arccw_weapons/lua/entities/arccw_projectile_base_v2.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "Base Projectile"

ENT.Spawnable 			= false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/Items/AR2_Grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 0.05
ENT.Defused = false
ENT.BoxSize = Vector(2, 2, 2)
ENT.SmokeTrail = true

ENT.Drag = true
ENT.Gravity = true
ENT.DragCoefficient = 0.25
ENT.Boost = 0
ENT.Lift = 0
ENT.GunshipWorkaround = true
ENT.HelicopterWorkaround = true

ENT.Damage = 150
ENT.Radius = 300
ENT.ImpactDamage = nil

if SERVER then
    local gunship = {["npc_combinegunship"] = true, ["npc_combinedropship"] = true}

    function ENT:Initialize()
        local pb_vert = self.BoxSize[1]
        local pb_hor = self.BoxSize[2]
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableDrag(self.Drag)
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:EnableGravity(self.Gravity)
            phys:SetMass(5)
            phys:SetBuoyancyRatio(0.4)
        end

        self.SpawnTime = CurTime()

        if self.SmokeTrail then
            util.SpriteTrail(self, 0, Color( 255 , 255 , 255 ), false, 6, 6, 0.5, 1 / (6 + 6) * 0.5, "particle/particle_smokegrenade")
        end
    end

    function ENT:Think()
        if self.Defused or self:WaterLevel() > 0 then return end

        self:GetPhysicsObject():AddVelocity(Vector(0, 0, self.Lift) + self:GetForward() * self.Boost)

        -- Gunships have no physics collection, periodically trace to try and blow up in their face
        if self.GunshipWorkaround and (self.GunshipCheck or 0 < CurTime()) then
            self.GunshipCheck = CurTime() + 0.33
            local tr = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() + self:GetVelocity(),
                filter = self,
                mask = MASK_SHOT
            })
            if IsValid(tr.Entity) and gunship[tr.Entity:GetClass()] then
                self:SetPos(tr.HitPos)
                self:Detonate()
            end
        end
    end

    function ENT:Detonate()
        if !self:IsValid() then return end
        if self.Defused then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() > 0 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
            --self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            util.Effect( "Explosion", effectdata)
            --self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
        end

        util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), self.Radius, self.DamageOverride or self.Damage)

        if SERVER then
            self:FireBullets({
                Attacker = self,
                Damage = 0,
                Tracer = 0,
                Distance = 256,
                Dir = self.HitVelocity or self:GetVelocity(),
                Src = self:GetPos(),
                Callback = function(att, tr, dmg)
                    util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
                end
            })
        end
        self.Defused = true
        self:Remove()
    end

    function ENT:PhysicsCollide(colData, physobj)
        if !self:IsValid() then return end

        if CurTime() - self.SpawnTime < self.FuseTime then
            if IsValid(colData.HitEntity) then
                local v = colData.OurOldVelocity:Length() ^ 0.5
                local dmg = DamageInfo()
                dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
                dmg:SetInflictor(self)
                dmg:SetDamageType(DMG_CRUSH)
                dmg:SetDamage(v)
                dmg:SetDamagePosition(colData.HitPos)
                dmg:SetDamageForce(colData.OurOldVelocity)
                colData.HitEntity:TakeDamageInfo(dmg)
                self:EmitSound("weapons/rpg/shotdown.wav", 80, math.random(90, 110))
            end
            self:Defuse()
            return
        end

        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        -- simulate AP damage on vehicles, mainly simfphys
        local tgt = colData.HitEntity
        while IsValid(tgt) do
            if tgt.GetParent and IsValid(tgt:GetParent()) then
                tgt = tgt:GetParent()
            elseif tgt.GetBaseEnt and IsValid(tgt:GetBaseEnt()) then
                tgt = tgt:GetBaseEnt()
            else
                break
            end
        end

        if self.ImpactDamage and IsValid(tgt) then
            local dmg = DamageInfo()
            dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
            dmg:SetInflictor(self)
            dmg:SetDamageType(DMG_BLAST) -- helicopters
            dmg:SetDamage(self.ImpactDamage)
            dmg:SetDamagePosition(colData.HitPos)
            dmg:SetDamageForce(self:GetForward() * self.ImpactDamage)

            if IsValid(tgt:GetOwner()) and tgt:GetOwner():GetClass() == "npc_helicopter" then
                tgt = tgt:GetOwner()
                dmg:ScaleDamage(0.1)
                dmg:SetDamageType(DMG_BLAST + DMG_AIRBOAT)
                dmg:SetDamageForce(self:GetForward() * 100)
            end

            tgt:TakeDamageInfo(dmg)
        end

        self.HitPos = colData.HitPos
        self.HitVelocity = colData.OurOldVelocity
        self:Detonate()
    end

    -- Combine Helicopters are hard-coded to only take DMG_AIRBOAT damage
    hook.Add("EntityTakeDamage", "ArcCW_HelicopterWorkaround", function(ent, dmginfo)
        if IsValid(ent:GetOwner()) and ent:GetOwner():GetClass() == "npc_helicopter" then ent = ent:GetOwner() end
        if ent:GetClass() == "npc_helicopter" and dmginfo:GetInflictor().HelicopterWorkaround then
            dmginfo:SetDamageType(bit.bor(dmginfo:GetDamageType(), DMG_AIRBOAT))
        end
    end)
end

function ENT:Defuse()
    self.Defused = true
    SafeRemoveEntityDelayed(self, 5)
end

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/arccw_rocket.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "arccw_projectile_base_v2"
ENT.PrintName 			= "Rocket Standard"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/Items/AR2_Grenade.mdl"

ENT.BoxSize = Vector(8, 4, 1)
ENT.DamageOverride = 200
ENT.Radius = 250
ENT.ImpactDamage = 300
ENT.Boost = 200
ENT.DragCoefficient = 0

--addons/arccw_weapons/lua/entities/arccw_thr.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Base A Throwable"
ENT.Spawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE
ENT.Model = "models/arccw/masita/grenades/tdunprimed.mdl"

function ENT:CheckLOS(ent, origin)
    origin = origin or self:GetPos()
    if IsValid(self:GetParent()) then origin = self:GetParent():WorldSpaceCenter() end
    if ent == self:GetParent() then return true end
    local pos = ent:WorldSpaceCenter()
    local tr1 = util.TraceLine({
        start = origin,
        endpos = pos,
        filter = {self, self:GetParent()},
        mask = MASK_SHOT
    })
    if tr1.Fraction > 0.99 or tr1.Entity == ent then return true end

    -- only bother with extra traces if it is a player, npc or nextbot
    if not ent:IsPlayer() and not ent:IsNPC() and not ent:IsNextBot() then return false end
    local mins, maxs = ent:WorldSpaceAABB()

    local tr2 = util.TraceLine({
        start = origin,
        endpos = Vector(pos.x, pos.y, maxs.z),
        filter = {self, self:GetParent()},
        mask = MASK_SHOT
    })
    if tr2.Fraction > 0.99 or tr2.Entity == ent then return true end

    local tr3 = util.TraceLine({
        start = origin,
        endpos = Vector(pos.x, pos.y, mins.z),
        filter = {self, self:GetParent()},
        mask = MASK_SHOT
    })
    if tr3.Fraction > 0.99 or tr3.Entity == ent then return true end

    return false
end

function ENT:DrawTranslucent()
    self:DrawModel()
end

function ENT:Draw()
    self:DrawModel()
end
--lua/entities/arccw_uc_40mm_flash.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm Flash Grenade"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150
ENT.ExplosionEffect = false
ENT.Scorch = false

function ENT:DoDetonation()

    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())

    if self:WaterLevel() >= 1 then
        util.Effect("WaterSurfaceExplosion", effectdata)
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        effectdata:SetMagnitude(4)
        effectdata:SetScale(1)
        effectdata:SetRadius(4)
        effectdata:SetNormal(self:GetVelocity():GetNormalized())
        util.Effect("Sparks", effectdata)
        self:EmitSound("physics/metal/metal_box_break1.wav", 100, 200, 0.5)
    end

    -- TODO: these sounds need to be replaced (dependency)!
    self:EmitSound("weapons/arccw/flashbang/flashbang_explode1.wav", 100, 100, 1, CHAN_AUTO)
    self:EmitSound("weapons/arccw/flashbang/flashbang_explode1_distant.wav", 140, 100, 1, CHAN_AUTO)

    util.Effect( "arccw_flashexplosion", effectdata)

    local flashorigin = self:GetPos()

    local flashpower = 512
    local targets = ents.FindInSphere(flashorigin, flashpower)

    for _, k in pairs(targets) do
        if k:IsPlayer() then
            local dist = k:EyePos():Distance(flashorigin)
            local dp = (k:EyePos() - flashorigin):Dot(k:EyeAngles():Forward())

            local time = Lerp( dp, 2.5, 0.25 )

            time = Lerp( dist / flashpower, time, 0 )

            if k:VisibleVec( flashorigin ) then
                k:ScreenFade( SCREENFADE.IN, Color( 255, 255, 255, 255 ), 2.5, time )
            end

            k:SetDSP(37, false)

        elseif k:IsNPC() then

            k:SetNPCState(NPC_STATE_PLAYDEAD)

            if timer.Exists( k:EntIndex() .. "_arccw_flashtimer" ) then
                timer.Remove( k:EntIndex() .. "_arccw_flashtimer" )
            end

            timer.Create( k:EntIndex() .. "_arccw_flashtimer", 10, 1, function()
                if !k:IsValid() then return end
                k:SetNPCState(NPC_STATE_ALERT)
            end)

        end
    end

end
--lua/entities/arccw_uc_40mm_hv.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm High Velocity"

ENT.GrenadeDamage = false
ENT.GrenadeRadius = 200
ENT.DragCoefficient = 0

ENT.Model = "models/weapons/shell.mdl"

if CLIENT then
    function ENT:Think()
        if self.Ticks % 3 == 0 then
            local emitter = ParticleEmitter(self:GetPos())
            if not self:IsValid() or self:WaterLevel() > 2 then return end
            if not IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity(VectorRand() * 25)
            smoke:SetGravity(Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)))
            smoke:SetDieTime(math.Rand(1.5, 2.0))
            smoke:SetStartAlpha(255)
            smoke:SetEndAlpha(0)
            smoke:SetStartSize(0)
            smoke:SetEndSize(60)
            smoke:SetRoll(math.Rand(-180, 180))
            smoke:SetRollDelta(math.Rand(-0.2, 0.2))
            smoke:SetColor(100, 100, 100)
            smoke:SetAirResistance(5)
            smoke:SetPos(self:GetPos())
            smoke:SetLighting(false)
            emitter:Finish()
        end
        self.Ticks = self.Ticks + 1
    end
end
--addons/arccw_weapons/lua/entities/concussion_grenade_thrown/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Concussion Grenade (Thrown)"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator_thrown.mdl"
ENT.FuseTime = 3
ENT.ArmTime = 0
ENT.ImpactFuse = false

ENT.BlastRadius = 450

ENT.BlastDMG = 275

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
	-- util.SpriteTrail( self, 0, Color(155,255,75,155), false, 12, 0, 0.15, 1, "effects/swbf/red_beam" )
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
		phys:SetMass(1)
            phys:SetBuoyancyRatio(0)
        end
        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
		self.bt = CurTime() + 1
    end
end



function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
	 -- local effectdata = EffectData()
        -- effectdata:SetOrigin( self:GetPos() )
        -- util.Effect( "StunstickImpact", effectdata)
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        end
		self:SetAngles(Angle(0,0,0))
        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
        end
	if !data.HitEntity:IsPlayer() and data.HitEntity:GetClass() != "worldspawn" then
		self:SetParent( data.HitEntity )
		if data.HitEntity:IsPlayer() and data.HitEntity:IsNPC() then
		self:EmitSound(Sound("star_wars_republic_commando/weapons/int_gen_selsonicgrn_01.wav"))
						end
        end
		if data.HitEntity:GetClass() != "worldspawn" then
			self:SetParent( data.HitEntity )
		end
		
        end
	
    end
 

function ENT:Think()
    if SERVER and CurTime() >= self.kt then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos() + Vector(0,0,25))

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
		-- sound.Play( "halo/halo_3/frag_expl_water" .. math.random(1,5) .. ".ogg",  self:GetPos(), 100, 100 )
        else
            ParticleEffect( "astw2_swbf_explosion_concussion_grenade", self:GetPos(), self:GetAngles() )
        end
		
		local inflictor = self
		
		if IsValid(self.Owner) then inflictor = self.Owner end

        util.BlastDamage(self, inflictor, self:GetPos(), self.BlastRadius, self.BlastDMG)
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_grenade0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )
	util.ScreenShake(self:GetPos(),10000,100,0.8,1024)
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(155, 125, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
    end
end
--gamemodes/starwarsrp/entities/entities/ent_climbform_box/shared.lua:
--Made by MrRangerLP

AddCSLuaFile("shared.lua")

ENT.Base 				= "base_gmodentity"
ENT.Type 				= "anim"
ENT.Category 			= "Fun + Games"

ENT.PrintName 			= "Climbgame Box"
ENT.Author				= "MrRangerLP (Meteor)"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false
ENT.DisableDuplicator 	= true
ENT.DoNotDuplicate 		= true

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
end
--addons/joes_stuff/lua/entities/joe_train_bomb/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()

end
--addons/joes_stuff/lua/entities/joe_train_bomb/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
 
ENT.PrintName= "Training Bomb"
ENT.Author= "Joe"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Joe"

--addons/weapon_joe_fort/lua/entities/joefort_ressource_250/cl_init.lua:
include('shared.lua')

--addons/weapon_jedi/lua/entities/lscs_holocron_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_pickupable"
DEFINE_BASECLASS( "lscs_pickupable" )

ENT.Spawnable		= false
ENT.AdminSpawnable		= false

ENT.PickupSound = "physics/metal/weapon_impact_soft3.wav"
ENT.ImpactHardSound = "Concrete_Block.ImpactHard"
ENT.ImpactSoftSound = "weapon.ImpactSoft"

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/lscs/holocron.mdl" )
		BaseClass.Initialize( self )
	end
end
--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterTurret( pod:lvsGetWeapon() )

	self:InvalidateBoneCache()
end
--addons/lvs_base/lua/entities/lvs_base_gunner/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseGunner"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT.LVS_GUNNER = true
ENT.VectorNull = Vector(0,0,0)

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Driver" )
	self:NetworkVar( "Entity",1, "DriverSeat" )

	self:NetworkVar( "Int", 0, "PodIndex")
	self:NetworkVar( "Int", 1, "NWAmmo")
	self:NetworkVar( "Int", 2, "SelectedWeapon" )

	self:NetworkVar( "Float", 0, "NWHeat" )

	self:NetworkVar( "Bool", 0, "NWOverheated" )

	self:NetworkVar( "Vector", 0, "NWAimVector" )

	if SERVER then
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )
	end
end

function ENT:UnlockAimVector()
	self._AimVectorUnlocked = true
end

function ENT:LockAimVector()
	self._AimVectorUnlocked = nil
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAI()
	if IsValid( self:GetDriver() ) then return false end

	local veh = self:GetVehicle()

	if not IsValid( veh ) then return false end

	return veh:GetAIGunners()
end

function ENT:GetAITEAM()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return 0 end

	return Base:GetAITEAM()
end

function ENT:GetVehicle()
	local Pod = self:GetParent()

	if not IsValid( Pod ) then return NULL end

	return Pod:GetParent()
end

function ENT:HasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	return istable( Base.WEAPONS[ self:GetPodIndex() ][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	local weapon = Base.WEAPONS[ self:GetPodIndex() ][ ID ]

	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()

	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {}, SelectedID end

	local CurWeapon = Base.WEAPONS[ self:GetPodIndex() ][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

function ENT:GetCrosshairFilterEnts()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {} end

	return Base:GetCrosshairFilterEnts()
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetVehicleType()
	return "LBaseGunner"
end
--addons/lvs_addons/lua/entities/lvs_base_starfighter/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("sh_camera_eyetrace.lua")
include("cl_hud.lua")
include("cl_flyby.lua")
include("cl_deathsound.lua")

ENT.TrailAlpha = 25

DEFINE_BASECLASS( "lvs_base" )

function ENT:Think()
	BaseClass.Think( self )

	self.EFxScale = self.EFxScale and (self.EFxScale - self.EFxScale * RealFrameTime()) or 0

	self:CalcOnThrottle()
end

function ENT:CalcOnThrottle()
	if not self:GetEngineActive() then 
		self._oldOnTHR = nil

		return
	end

	local Throttle = self:GetThrottle()

	if self._oldOnTHR ~= Throttle then
		if self._oldOnTHR == 0 and Throttle > 0 then
			self._IsAccelerating = true
		end

		if Throttle > (self._oldOnTHR or 0) then
			self._IsAccelerating = true
		else
			self._IsAccelerating = false
		end

		if self._oldOnTHR == 1 then
			self:StopBoost()
		end

		self._oldOnTHR = Throttle
	end

	if self._oldAccelerating ~= self._IsAccelerating then
		self._oldAccelerating = self._IsAccelerating

		if not self._IsAccelerating then return end

		self:StartBoost()
	end
end

function ENT:StartBoost()
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self.EFxScale = 100

	self:OnStartBoost()
end

function ENT:StopBoost()
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self:OnStopBoost()
end

function ENT:GetBoost()
	return (self.EFxScale or 0)
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end
--addons/lvs_addons/lua/entities/lvs_fakehover_aat/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "AAT"
ENT.Author = "Luna"
ENT.Information = "Trade Federation Hover Tank. Later used in the Droid army of the Separatists"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Hover Tanks"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/aat.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 1

ENT.MaxHealth = 2000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-260,0,0)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:SetTurretPitch( num )
	self._turretPitch = num
end

function ENT:SetTurretYaw( num )
	self._turretYaw = num
end

function ENT:GetTurretPitch()
	return (self._turretPitch or 0)
end

function ENT:GetTurretYaw()
	return (self._turretYaw or 0)
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,-60,81) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,60,81) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 20 and AimAnglesL.p >= 20) or (AimAnglesR.p <= -30 and AimAnglesL.p <= -30) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 60)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local ID_L = ent:LookupAttachment( "muzzle_left" )
		local ID_R = ent:LookupAttachment( "muzzle_right" )
		local MuzzleL = ent:GetAttachment( ID_L )
		local MuzzleR = ent:GetAttachment( ID_R )

		if not MuzzleL or not MuzzleR then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_red_short"
		bullet.Force	= 11000
		bullet.HullSize 	= 1
		bullet.Damage	= 25
		bullet.Velocity = 12000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if ent.MirrorPrimary then
			if not IsValid( ent.SNDLeft ) then return end
	
			ent.SNDLeft:PlayOnce()

			return
		end

		if not IsValid( ent.SNDRight ) then return end

		ent.SNDRight:PlayOnce()
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		if ent:GetIsCarried() then
			self:SetPoseParameter("cannon_right_pitch", 0 )
			self:SetPoseParameter("cannon_right_yaw", 0 )

			self:SetPoseParameter("cannon_left_pitch", 0 )
			self:SetPoseParameter("cannon_left_yaw", 0 )

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		ent:SetPoseParameter("cannon_right_pitch", AimAnglesR.p )
		ent:SetPoseParameter("cannon_right_yaw", AimAnglesR.y )

		ent:SetPoseParameter("cannon_left_pitch", AimAnglesL.p )
		ent:SetPoseParameter("cannon_left_yaw", AimAnglesL.y )
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local Driver = ent:GetDriver()

		local MissileAttach = {
			[1] = {
				left = "missile_1l",
				right = "missile_1r"
			},
			[2] = {
				left = "missile_2l",
				right = "missile_2r"
			},
			[3] = {
				left = "missile_3l",
				right = "missile_3r"
			},
		}

		for i = 1, 3 do
			timer.Simple( (i / 5) * 0.75, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end

				local ID_L = ent:LookupAttachment( MissileAttach[i].left )
				local ID_R = ent:LookupAttachment( MissileAttach[i].right )
				local MuzzleL = ent:GetAttachment( ID_L )
				local MuzzleR = ent:GetAttachment( ID_R )

				if not MuzzleL or not MuzzleR then return end

				local swap = false

				for i = 1, 2 do
					local Pos = swap and MuzzleL.Pos or MuzzleR.Pos
					local Start = Pos + ent:GetForward() * 50
					local Dir = (ent:GetEyeTrace().HitPos - Start):GetNormalized()
					if not ent:WeaponsInRange() then
						Dir = swap and MuzzleL.Ang:Up() or MuzzleR.Ang:Up()
					end

					local projectile = ents.Create( "lvs_missile" )
					projectile:SetPos( Start )
					projectile:SetAngles( Dir:Angle() )
					projectile:SetParent( ent )
					projectile:Spawn()
					projectile:Activate()
					projectile.GetTarget = function( missile ) return missile end
					projectile.GetTargetPos = function( missile )
						return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
					end
					projectile:SetAttacker( IsValid( Driver ) and Driver or self )
					projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
					projectile:SetDamage( 300 )
					projectile:SetRadius( 150 )
					projectile:Enable()
					projectile:EmitSound( "LVS.AAT.FIRE_MISSILE" )

					ent:TakeAmmo( 1 )

					swap = true
				end
			end)
		end

		ent:SetHeat( 1 )
		ent:SetOverheated( true )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/aat/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/aat/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/aat/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "LVS.AAT.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/aat/fire_missile.mp3"
} )

sound.Add( {
	name = "LVS.AAT.LASER_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {160, 180},
	sound = {
		"lvs/vehicles/aat/turret/impact1.ogg",
		"lvs/vehicles/aat/turret/impact2.ogg",
		"lvs/vehicles/aat/turret/impact3.ogg",
		"lvs/vehicles/aat/turret/impact4.ogg"
	}
} )
--addons/lvs_addons/lua/entities/lvs_fakehover_aat/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterTurret( pod:lvsGetWeapon() )

	self:InvalidateBoneCache()
end

--addons/lvs_addons/lua/entities/lvs_fakehover_hailfire/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:OnFrame()

end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end
	
	self.nextDFX = self.nextDFX or 0
	
	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05
		
		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lvs_blacksmoke", effectdata )
	end
end


local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)


function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(  math.Clamp(math.Clamp(  60 + Pitch * 50, 80,255) + Doppler,0,255) )
		self.ENG:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0.5,1) )
	end
	
	if self.DIST then
		self.DIST:ChangePitch(  math.Clamp(math.Clamp(  50 + Pitch * 60, 50,255) + Doppler,0,255) )
		self.DIST:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0,1) )
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

--addons/lvs_addons/lua/entities/lvs_fakehover_soundemitter.lua:
AddCSLuaFile()

ENT.Base = "lvs_starfighter_soundemitter"

if SERVER then return end

function ENT:HandleEngineSounds( vehicle )
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()
	local Throttle = vehicle:GetThrottle()
	local Doppler = vehicle:CalcDoppler( ply )

	local DrivingMe = ply:lvsGetVehicle() == vehicle

	local VolumeSetNow = false

	local FirstPerson = false
	if IsValid( pod ) then
		local ThirdPerson = pod:GetThirdPersonMode()

		if ThirdPerson ~= self._lvsoldTP then
			self._lvsoldTP = ThirdPerson
			VolumeSetNow = DrivingMe
		end

		FirstPerson = DrivingMe and not ThirdPerson
	end

	if DrivingMe ~= self._lvsoldDrivingMe then
		VolumeSetNow = true
		self._lvsoldDrivingMe = DrivingMe
	end

	for id, sound in pairs( self._ActiveSounds ) do
		if not sound then continue end

		local data = self.EngineSounds[ id ]

		local Pitch = math.Clamp( data.Pitch + Throttle * data.PitchMul, data.PitchMin, data.PitchMax )
		local PitchMul = data.UseDoppler and Doppler or 1

		local InActive = Throttle > data.FadeOut or Throttle < data.FadeIn
		if data.FadeOut >= 1 and Throttle > 1 then
			InActive = false
		end

		local Volume = InActive and 0 or LVS.EngineVolume

		if data.VolumeMin and data.VolumeMax and not InActive then
			Volume = math.max(Throttle - data.VolumeMin,0) / (1 - data.VolumeMin) * data.VolumeMax * LVS.EngineVolume
		end

		if istable( sound ) then
			sound.ext:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			if sound.int then sound.int:ChangePitch( math.Clamp( Pitch, 0, 255 ), 0.2 ) end

			local fadespeed = VolumeSetNow and 0 or data.FadeSpeed

			if FirstPerson then
				sound.ext:ChangeVolume( 0, 0 )
				if sound.int then sound.int:ChangeVolume( Volume, fadespeed ) end
			else
				sound.ext:ChangeVolume( Volume, fadespeed )
				if sound.int then sound.int:ChangeVolume( 0, 0 ) end
			end
		else
			sound:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			sound:ChangeVolume( Volume, data.FadeSpeed )
		end
	end
end

--addons/lvs_addons/lua/entities/lvs_repshuttle_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Republic Heavy"
ENT.Author = "Ophra"
ENT.Information = "Heavy Fighter of the Republic"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_rep_ps_shuttle_blue001.mdl"


ENT.AITEAM = 1

ENT.MaxVelocity = 2000
ENT.MaxThrust = 1000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.5
ENT.TurnRateYaw = 0.5
ENT.TurnRateRoll = 0.5

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 2000
ENT.MaxShield = 300



function ENT:InitWeapons()
	self.FirePositions = {
		Vector(300,150.6,-55),
		Vector(300,-150.6,-55),
		Vector(300, 150.6,-55),
		Vector(300,-150.6,-55),
	}

	


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 447.85, (ent._swapMissile and -455.29 or 455.29), 58.12 )



		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_green"
 		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(718.61,-32.55,123.5)
		)
			

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(718.61,32.55,123.5)
		)

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/lvs_addons/lua/entities/lvs_repulsorlift_engine.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Float",0, "DamageEffectsTime" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 0, 255, 255 ) )
	end

	function ENT:Think()
		local T = CurTime()
		local vehicle = self:GetBase()

		if not IsValid( vehicle ) or not vehicle:GetEngineActive() or self:GetDamageEffectsTime() < T then self:NextThink( T + 1 ) return true end

		if vehicle:GetHP() >= vehicle:GetMaxHP() then
			self:SetDamageEffectsTime( 0 )

			self:NextThink( T + 1 )

			return true
		end

		local PhysObj = vehicle:GetPhysicsObject()

		local Pos = self:GetPos()
		local Len = vehicle:WorldToLocal( Pos ):Length()

		PhysObj:ApplyForceOffset( -vehicle:GetVelocity() * (PhysObj:GetMass() / Len) * FrameTime() * 50, Pos )

		self:NextThink( T )

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		local vehicle = self:GetBase()
	
		if not IsValid( vehicle ) then return end

		local TimeBork = 2 + (vehicle:GetHP() / vehicle:GetMaxHP()) * 123

		self:SetDamageEffectsTime( CurTime() + TimeBork )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	self:DamageFX( vehicle )
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:DamageFX( vehicle )
	local T = CurTime()
	local HP = vehicle:GetHP()
	local MaxHP = vehicle:GetMaxHP() 

	if (self.nextDFX or 0) > T then return end

	if self:GetDamageEffectsTime() < T then
		if HP <= 0 or HP > MaxHP * 0.5 then return end
	end

	self.nextDFX = T + 0.05

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( vehicle )
	util.Effect( "lvs_engine_blacksmoke", effectdata )

	if HP < MaxHP * 0.5 and self:GetDamageEffectsTime() > T then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetNormal( -self:GetForward() )
			effectdata:SetMagnitude( 2 )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_exhaust_fire", effectdata )
	end
end

--addons/lvs_addons/lua/entities/lvs_sithheavy_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Sith Heavy"
ENT.Author = "Ophra"
ENT.Information = "Heavy Shuttle of the Sith Empire"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_imp_transport_pvp_closed_hatches.mdl"


ENT.AITEAM = 2

ENT.MaxVelocity = 2000
ENT.MaxThrust = 1000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.3
ENT.TurnRateYaw = 0.3
ENT.TurnRateRoll = 0.3

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 2000
ENT.MaxShield = 300



function ENT:InitWeapons()
	self.FirePositions = {
		Vector(300,150.6,-55),
		Vector(300,-150.6,-55),
		Vector(300, 150.6,-55),
		Vector(300,-150.6,-55),
	}

	


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 650, (ent._swapMissile and 25 or -25), 0 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
 		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector( 650, 25 , 0 ))
			

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector( 650, -25, 0 ))
			

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/lvs_addons/lua/entities/lvs_starfighter_arc170/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,64.51,8.36),
	Vector(-163.81,-64.51,8.36),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
	self:AnimWings()
	self:AnimGunner()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 50, 200 )
	end
end

function ENT:AnimGunner()
	local Pod = self:GetTailGunnerSeat()

	if not IsValid( Pod ) then return end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 5, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 6, Angle(0,0, math.max( Pitch, -25 ) ) )

	self:ManipulateBoneAngles( 2, Angle( math.Clamp( Yaw, -30, 30 ),0,0) )
	self:ManipulateBoneAngles( 3, Angle(0,0, math.Clamp( Pitch, -60, 12 ) ) )
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg",100 )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg", 70 )
			end
		end
		
		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 1, Angle(self.smastro,0,0) )
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetFoils() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)

	local Rate = RFT * 0.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-Rate,Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/arc170/sfoils.wav")
		end
	end

	local Ang = (1 - self._sm_wing) * 20

	self:ManipulateBoneAngles( 8, Angle(0,-Ang,0) )
	self:ManipulateBoneAngles( 9, Angle(0,Ang,0) )
	
	self:ManipulateBoneAngles( 10, Angle(0,Ang,0) )
	self:ManipulateBoneAngles( 11, Angle(0,-Ang,0) )

	self:InvalidateBoneCache()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_consulradiance/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Radiant VII Consular Cruiser"
ENT.Author = "CR90"
ENT.Information = "Repub Retrofitted Consular Class Radiant VII Escort"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salty/consularclassradiance.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
	"models/salty/ConsGib1.mdl",
	"models/salty/ConsGib2.mdl",
	"models/salty/ConsGib3.mdl",
	"models/salty/ConsGib4.mdl",

}

ENT.AITEAM = 2

ENT.MaxVelocity = 1900
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.8
ENT.TurnRateYaw = 0.8
ENT.TurnRateRoll = 0.35

ENT.ForceLinearMultiplier = 0.5

ENT.ForceAngleMultiplier = 0.5
ENT.ForceAngleDampingMultiplier = 0.5

ENT.MaxHealth = 8500
ENT.MaxShield = 1000

ENT.FlyByAdvance = 0.90
ENT.FlyBySound = "lvs/vehicles/frigates/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/crash/crashingdown.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/frigates/loop3.wav",
		Pitch = 120,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_n1/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-95,143.87,30.93), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(-95,-143.87,30.93), 0, 20, 2, 2500, 150 )

	self:CreateBonePoseParameter( "cabin", 1, Angle(0,0,0), Angle(0,0,0), Vector(0,0,0), Vector(0,0,50) )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for i = -1,1,2 do
		local pos = self:LocalToWorld( Vector(20,143.87 * i,30.93) )
		render.DrawSprite( pos, Size, Size, Color( 0, 127, 255, 255) )
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(41,143.87 * i,30.93) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/select_ring", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (1000 + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( 20 )
		particle:SetAngles( vNormal:Angle() )
		particle:SetColor( math.Rand( 10, 100 ), math.Rand( 100, 220 ), math.Rand( 240, 255 ) )
	end
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg", 100 )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg", 70 )
			end
		end
		
		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 2, Angle(self.smastro,0,0) )
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_soulless/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Belbullab-22 Starfighter"
ENT.Author = "Luna"
ENT.Information = "Advanced Starfighter of the Confederacy of Independant Systems"
ENT.Category = "AOCRP - KUS - Flugobjekte"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/soulless/soulless1.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 850
ENT.MaxShield = 100

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(80,82,62),
		Vector(80,-82,62),
		Vector(95,82,55),
		Vector(95,-82,55)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0.02 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vulturedroid/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_vwing/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "V-Wing"
ENT.Author = "Luna"
ENT.Information = "Starfighter of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/vwing.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 300
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(3.97,-56.3,53.79),
		Vector(4.01,56.39,46.96),
		Vector(4.01,-56.39,46.96),
		Vector(3.97,56.3,53.79),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.07
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.1 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")

		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 4
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 6, (ent._swapMissile and -57 or 57), 50.5 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		sound_int = "lvs/vehicles/vwing/loop_interior.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--addons/lvs_addons/lua/entities/lvs_turret_aa_red/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--addons/lvs_addons/lua/entities/lvs_walker_atte/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "ATTE"
ENT.Author = "Luna"
ENT.Information = "Assault Walker of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Walkers"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/blu/atte.mdl"
ENT.GibModels = {
	"models/blu/atte.mdl",
	"models/blu/atte_rear.mdl",
	"models/blu/atte_bigfoot.mdl",
	"models/blu/atte_bigleg.mdl",
	"models/blu/atte_smallleg_part1.mdl",
	"models/blu/atte_smallleg_part2.mdl",
	"models/blu/atte_smallleg_part3.mdl"
}

ENT.AITEAM = 2

ENT.MaxHealth = 10000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 140
ENT.HoverTraceLength = 225
ENT.HoverHullRadius = 20

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-220,0,-115)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "RearEntity" )
	self:AddDT( "Entity", "TurretSeat" )
	self:AddDT( "Entity", "GunnerSeat" )

	self:AddDT( "Float", "Move" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Vector", "AIAimVector" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:SetTurretPitch( num )
	self._turretPitch = num
end

function ENT:SetTurretYaw( num )
	self._turretYaw = num
end

function ENT:GetTurretPitch()
	return (self._turretPitch or 0)
end

function ENT:GetTurretYaw()
	return (self._turretYaw or 0)
end

function ENT:GetContraption()
	return {self, self:GetRearEntity()}
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(265,0,100)) ):GetNormalized():Angle() )

	local ID = self:LookupAttachment( "muzzle_right_up" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return AimAngles, trace.HitPos, false end

	local DirAng = self:WorldToLocalAngles( (trace.HitPos - self:GetDriverSeat():LocalToWorld( Vector(0,0,33) ) ):Angle() )

	return AimAngles, trace.HitPos, (math.abs( DirAng.p ) < 12 and math.abs( DirAng.y ) < 35)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.1
	weapon.HeatRateUp = 2.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if ent:GetIsCarried() then ent:SetHeat( 0 ) return true end

		local ID1 = ent:LookupAttachment( "muzzle_right_up" )
		local ID2 = ent:LookupAttachment( "muzzle_left_up" )
		local ID3 = ent:LookupAttachment( "muzzle_right_dn" )
		local ID4 = ent:LookupAttachment( "muzzle_left_dn" )

		local Muzzle1 = ent:GetAttachment( ID3 )
		local Muzzle2 = ent:GetAttachment( ID2 )
		local Muzzle3 = ent:GetAttachment( ID1 )
		local Muzzle4 = ent:GetAttachment( ID4 )

		if not Muzzle1 or not Muzzle2 or not Muzzle3 or not Muzzle4 then return end

		local FirePos = {
			[1] = Muzzle1,
			[2] = Muzzle2,
			[3] = Muzzle3,
			[4] = Muzzle4,
		}

		ent.FireIndex = ent.FireIndex and ent.FireIndex + 1 or 2
	
		if ent.FireIndex > #FirePos then
			ent.FireIndex = 1
		end

		local AimAngles, AimPos, InRange = ent:GetAimAngles()

		local Pos = FirePos[ent.FireIndex].Pos
		local Dir = (AimPos - Pos):GetNormalized()

		if not InRange then return true end

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 15000
		bullet.HullSize 	= 30
		bullet.Damage	= 100
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 8000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if not IsValid( ent.SNDPrimary ) then return end

		ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if IsValid( base ) and base:GetIsCarried() then return end

		local AimAngles = ent:GetAimAngles()

		ent:SetPoseParameter("frontgun_pitch", math.Clamp(AimAngles.p,-5,5) )
		ent:SetPoseParameter("frontgun_yaw", AimAngles.y )
	end
	self:AddWeapon( weapon )

	self:InitTurret()
	self:InitGunner()
end
--addons/lvs_addons/lua/entities/lvs_walker_hsd/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "Homing Spider Droid"
ENT.Author = "Luna"
ENT.Information = "OG-9 Separatist Walker Droid"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Walkers"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/blu/hsd.mdl"
ENT.GibModels = {
	"models/blu/hsd_gib.mdl",
	"models/blu/hsd_foot.mdl",
	"models/blu/hsd_leg_1.mdl",
	"models/blu/hsd_leg_2.mdl",
	"models/blu/hsd_leg_3.mdl",
	"models/blu/hsd_leg_4.mdl",
}

ENT.AITEAM = 1

ENT.MaxHealth = 6000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 250
ENT.HoverTraceLength = 300
ENT.HoverHullRadius = 50

ENT.TurretTurnRate = 100

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()
	self:AddDT( "Int", "UpdateLeg" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "NWGround" )
	self:AddDT( "Bool", "ProjectorBeam" )
	self:AddDT( "Vector", "AIAimVector" )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:HitGround()
	return self:GetNWGround()
end

--addons/arccw_weapons/lua/entities/magna_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Wrist Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false ) 
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp02.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_cis_bulldog", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 10 )
        smoke:SetEndSize( 35 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( math.random(155,255), 45, math.random(155,255) )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_wristrocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_med0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 150, 128)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(32, 128), math.random(32, 128), Color(155, 50, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/arccw_weapons/lua/entities/micro_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Wrist Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp02.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_reb_shotgun", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 45 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 10 )
        smoke:SetEndSize( 35 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
           ParticleEffect( "astw2_swbf_explosion_concussion_grenade", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/jd_oc/explosion_huge" .. math.random(2,3) .. ".mp3",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 324, 125)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(16, 32), math.random(16, 32), Color(255, 175, 75) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/weapons_other/lua/entities/police_shield/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end 
--addons/arccw_weapons/lua/entities/radiation_grenade/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Radiation Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator.mdl"
ENT.FuseTime = 3.5
ENT.ArmTime = 0
ENT.ImpactFuse = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_dirt_0" .. math.random(1,3) .. ".wav"))
        end

        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() >= self.kt then
        self:Detonate()
				self:EmitSound(Sound("weapons/star_wars_battlefront/common/exp_ord_haywireGrenade.wav"))

    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_launcher", self:GetPos(), self:GetAngles() )
			sound.Play( "weapons/star_wars_battlefront/common/exp_ord_haywireGrenade.wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 200, 75)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),4096,100,0.6,1024)
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
		
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(125, 155, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
      
    end
end
--addons/arccw_weapons/lua/entities/rw_sw_nade.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
    self:DrawModel()
end


function ENT:Initialize()
    self.Entity:SetNWBool("smoke", 10, true)
    if SERVER then
        self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
        self:PhysicsInit(SOLID_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    local phys = self:GetPhysicsObject()
    if (IsValid(phys)) then
        phys:SetMass(1)
    end
        self:DrawShadow( true )
    end
    self.ExplodeTimer = CurTime() + 100000
    if CLIENT then
        self.emitter = ParticleEmitter( self:GetPos() , 0 )
    end
end

function ENT:PhysicsCollide( data, phys )
    if  (20 < data.Speed and 0.25 < data.DeltaTime) then
    self.ExplodeTimer = 0
    end
end

function ENT:Think()
    if SERVER and (self.ExplodeTimer and self.ExplodeTimer <= CurTime()) then
        self:Explode()
    end
    self:NextThink(CurTime())

    if CLIENT then
        local pos = self:GetPos() + self:GetForward()
        local emitter = ParticleEmitter( self:GetPos() , 0 )
        local particle = emitter:Add("particle/smokesprites_000"..math.random(1,9), pos )
        for i=1, (1) do
            if (particle) then
                particle:SetVelocity((self:GetForward() * -400)+(VectorRand()* 10) )
                particle:SetDieTime( math.Rand( 0.5, 1.5 ) )
                particle:SetStartAlpha( math.Rand( 75, 50 ) )
                particle:SetEndAlpha( 0 )
                particle:SetStartSize( math.Rand( 20, 20 ) )
                particle:SetEndSize( math.Rand( 15, 15 ) )
                particle:SetRoll( math.Rand(0, 360) )
                particle:SetRollDelta( math.Rand(-1, 1) )
                particle:SetColor( 120 , 120 , 120 ) 
                particle:SetAirResistance( 2500 ) 
                particle:SetGravity( Vector( 0, 0, 0 ) )
            end
        end
    end
    return true
end


function ENT:Think2()
end

function ENT:Explode()
	local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )
    util.Effect("Explosion", effectdata)
    util.BlastDamage( self, self.Owner, self:GetPos(), 300, 200 )
    
    local spos = self:GetPos()
    local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
    util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
    self:Remove()
end

function ENT:OnRemove()
end

--addons/joes_stuff/lua/entities/shield_3/shared.lua:
ENT.Type = "anim"
ENT.Base = "shield_base"
 
ENT.PrintName= "Shield Level 3"
ENT.Author= "Joe + JackJack"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true
ENT.shieldmodel = "models/jackjack/props/circle3.mdl"
ENT.health = 300
ENT.laserlength = 1158
ENT.radius = 1285
ENT.size = 1
--addons/sse_101/lua/entities/sse_armor_canister.lua:
AddCSLuaFile()

ENT.Base = "sse_base"
ENT.Category        = "SSE"
ENT.PrintName		= "Armor Canister"
ENT.Spawnable       = true
ENT.Editable = true
ENT.ConfigName = "ArmorCanister"
ENT.ClientInteraction = false


function ENT:SetupDataTables()

 
    self:NetworkVar( "Float",	0, "HealContent",	{ KeyName = "healcontent",	Edit = { type = "Float",		order = 1, min = 0, max = 1000000 } } )

    if SERVER then
        self:SetHealContent(self:ConfigValue("DefaultHealth"))
    end

end

if SERVER then
        

    local lastUseTime = 0

    function ENT:Use( activator, caller )

        if IsValid(activator) and activator:IsPlayer() then
            local currentTime = CurTime()
            if currentTime - lastUseTime >= self:ConfigValue("Delay") then
                lastUseTime = currentTime

                local healAmount = self:ConfigValue("AddHealth")
                if self:GetHealContent() > 0 then
                    local maxHealth = activator:GetMaxArmor()
                    local currentHealth = activator:Armor()
                    local newHealth = math.min(currentHealth + healAmount, maxHealth)
                    if newHealth > currentHealth then
                        self:SetHealContent(self:GetHealContent() - healAmount)
                        if self:GetHealContent() <= 0 then
                            self:Remove()
                        end
                        activator:SetArmor(newHealth)
                        self:EmitSound(self:ConfigValue("Sound") )
                    end
                end
            end
        end
    end



end


--addons/sse_101/lua/entities/sse_console_weapons.lua:
AddCSLuaFile()



ENT.Base = "sse_base"
ENT.PrintName		= "Turbolaser Console"
ENT.Spawnable       = true
ENT.ConfigName = "TurbolaserConsole"
ENT.ClientInteraction = true
ENT.Category        = "SSE"






if SERVER then
     
    util.AddNetworkString( "SSE_WEAPONCONSOLE_SELECT" )
   
    
    
    net.Receive( "SSE_WEAPONCONSOLE_SELECT", function( len, ply )

        if SSE:AntiSpam(ply) then return end
        local ent = net.ReadEntity()
        local terminal = net.ReadEntity()

        if !IsValid(ent) or !IsValid(terminal) then return end
        if !terminal:ConfirmUse(ply) then return end

        if !terminal:ConfigValue("TurbolaserClass")[ent:GetClass()] then return end



        ply.SSE_returnPos = ply:GetPos()
        ent:Use(ply)

    end)

    hook.Add( "PlayerLeaveVehicle", "SSE_RETURN_PLAYER", function( ply, veh )
        
        if ply.SSE_returnPos != nil then 
        
            timer.Simple(0, function() ply:SetPos(ply.SSE_returnPos) ply.SSE_returnPos = nil end)
    
        end
    end )

    
end
        
    
    if CLIENT then
    
        local function SSE_WEAPON_CONSOLE_PANEL(terminal) 
            if ValidPanel(TLCFrame) then TLCFrame:Remove() end
            TLCFrame = SSE:DefaultFrame()
            TLCFrame:SetSize(SSEW(500),SSEH(600))
            TLCFrame:Center()
            TLCFrame:SetNewTitle(terminal:ConfigValue("TurbolaserName"))
            TLCFrame:SetSizable(false)
            TLCFrame:SetDraggable(false)
    
            local content = SSE:ScrollBar(TLCFrame) 
            content:Dock(FILL)
            local newTable = {}
            for k, v in ipairs(ents.GetAll()) do
                if !terminal:ConfigValue("TurbolaserClass")[v:GetClass()] then
                    continue
                end

                local btn = SSE:Button(content, terminal:ConfigValue("TurbolaserName").." #"..v:EntIndex(), function() 
                    if ValidPanel(TLCFrame) then TLCFrame:Remove() end
                    if !IsValid(v:GetDriver()) then
                        net.Start("SSE_WEAPONCONSOLE_SELECT")
                        net.WriteEntity(v)
                        net.WriteEntity(terminal)
                        net.SendToServer()
                    end
                end, "lc")

                btn:Dock(TOP)
                btn:DockMargin(5,10,5,0)


    
    
            end        
        end


        function ENT:ClientUse()
            SSE_WEAPON_CONSOLE_PANEL(self)
         end
    end

    
--addons/sse_101/lua/entities/sse_scanner.lua:
AddCSLuaFile()


ENT.Base = "sse_base"

ENT.PrintName		= "Scanner"
ENT.Author			= "Lt. Sammy"
ENT.Spawnable       = true
ENT.ConfigName = "Scanner"
ENT.NoHudName = true
ENT.Category        = "SSE"



if CLIENT then

    ENT.ScanTable = {}
    function ENT:DoScan(scantype) 
        self.ScanTable = {}
        if scantype == 1 then
            for k, v in ipairs(ents.GetAll()) do
                if v.LVS then
                    table.insert(self.ScanTable, v:GetPos())
                end
            end
        end
        if scantype == 2 then
            for k, v in ipairs(player.GetAll()) do
                if v:Alive() then
                    table.insert(self.ScanTable, v:GetPos())
                end
            end
        end
        if scantype == 3 then
            for k, v in ipairs(ents.GetAll()) do
                if v:IsNPC() or v:IsNextBot() then
                    table.insert(self.ScanTable, v:GetPos())
                end
            end
        end

        self:EmitSound(self:ConfigValue("Sound"))
   
    end


    ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

    
    function ENT:DrawTranslucent()

        local imgui = SSE.Imgui

        local radarSize = self:ConfigValue("Size") -- Half of the radar size (since the radar is square)
        
        -- Fetch map bounds
        local world = game.GetWorld()
        local mapMinBound, mapMaxBound = world:GetModelBounds()
        
        -- Function to map world coordinates to radar coordinates
        local function WorldToRadar(worldPos)
            -- Calculate scale based on the map bounds
            local scaleX = radarSize * 2 / (mapMaxBound.x - mapMinBound.x)
            local scaleY = radarSize * 2 / (mapMaxBound.y - mapMinBound.y)
    
            -- Convert world position to radar position
            local radarX = (worldPos.x - mapMinBound.x) * scaleX - radarSize
            local radarY = (worldPos.y - mapMinBound.y) * scaleY - radarSize
    
            -- Clamp to ensure the position stays within the radar square
            radarX = math.Clamp(radarX, -radarSize, radarSize)
            radarY = math.Clamp(radarY, -radarSize, radarSize)
    
            return radarX, radarY
        end
    
        if imgui.Entity3D2D(self, Vector(0, 0, 0), Angle(0, 90, 0), 0.1, 1000, 500) then
            -- Draw filled radar square
            draw.RoundedBox(0, -radarSize, -radarSize, radarSize * 2, radarSize * 2, self:ConfigValue("BackgroundColor"))
    
            -- Draw radar center
            --draw.RoundedBox(50, -5, -5, 10, 10, Color(0, 255, 0, 200))
    

            -- Draw radar border
            surface.SetDrawColor(255, 255, 255, 255)
            surface.DrawOutlinedRect(-radarSize, -radarSize, radarSize * 2, radarSize * 2)
            
            if imgui.xTextButton(self:ConfigValue("Vehicles"), SSE.xFont("!Agency FB@25#1000"), -radarSize + 25, radarSize - 75, 100, 50, 1, Color(145,145,145), Color(255,255,255), Color(255,205,205)) then
                self:DoScan(1) 
            end

            if imgui.xTextButton(self:ConfigValue("Lifeforms"), SSE.xFont("!Agency FB@25#1000"), -radarSize + 25, radarSize - 135, 100, 50, 1, Color(145,145,145), Color(255,255,255), Color(255,205,205)) then
                self:DoScan(2) 
            end

            if imgui.xTextButton(self:ConfigValue("Droids"), SSE.xFont("!Agency FB@25#1000"), -radarSize + 25, radarSize - 195, 100, 50, 1, Color(145,145,145), Color(255,255,255), Color(255,205,205)) then
                self:DoScan(3) 
            end


            local rX, rY = WorldToRadar(self:GetPos())
            draw.RoundedBox(50, rX-5,rY-5, 10, 10, self:ConfigValue("SelfColor"))

            -- Draw players on the radar
            for k, v in ipairs(self.ScanTable) do

          
                local pX, pY = WorldToRadar(v)
    
                -- Ensure the player dot is drawn within radar boundaries
                if math.abs(pX) <= radarSize and math.abs(pY) <= radarSize then
                    draw.RoundedBox(50, pX - 5, pY - 5, 10, 10, self:ConfigValue("Target"))
                end
            end
    
            imgui.End3D2D()
        end
    end
    
    

    
end
--addons/sse_101/lua/entities/sse_vehreq.lua:
AddCSLuaFile()

ENT.Base = "sse_base"

ENT.PrintName		= "Requistion Terminal"
ENT.Spawnable       = true
ENT.ConfigName = "VehicleRequisition"
ENT.ClientInteraction = true
ENT.Category        = "SSE"

local function SpawnBlocked(spawn)
    local entsTbl = ents.FindInBox(spawn:GetPos() + Vector(-200, -200, -200), spawn:GetPos() + Vector(200, 200, 200))
    for k, v in ipairs(entsTbl) do
        if v:IsPlayer() or v.LFS or v.LVS then
            return true
        end
    end
    return false
end

if SERVER then
    function ENT:Use( activator, caller )
        if activator.SSE_CurrentVeh then
            if activator.SSE_CurrentVeh:IsValid() then
                activator.SSE_CurrentVeh:Remove()
                activator:ChatPrint("*** "..self:ConfigValue("VehStored"))
                activator.SSE_CurrentVeh = nil
            else
                activator.SSE_CurrentVeh = nil
                activator:ChatPrint("*** "..self:ConfigValue("VehDestroyed"))
            end
        else
            if self.ClientInteraction then 
                activator.SSE_CurrentEntity = self
                net.Start("SSE_ClientInteraction")
                    net.WriteEntity(self)
                net.Send(activator)
            end
        end
    end

    util.AddNetworkString("SSE_VehicleSpawn")
    util.AddNetworkString("SSE_VehicleSpawn_Spawn")

    net.Receive("SSE_VehicleSpawn_Spawn", function(len, ply)

        if SSE:AntiSpam(ply) then return end
        local class = net.ReadString()
        local spawn = net.ReadEntity()
        local terminal = net.ReadEntity()

        if !IsValid(terminal) then return end
        if terminal:GetClass() != "sse_vehreq" then return end
        if ply:GetPos():DistToSqr(terminal:GetPos()) > 10000 then return end
        if !terminal:ConfirmUse(ply) then return end

        local getVehicleFunc = terminal:ConfigValue("GetVehicles")
        local vehicles = getVehicleFunc(ply)
        
        if !IsValid(spawn) then return end

        if ply.SSE_CurrentVeh then
            if ply.SSE_CurrentVeh:IsValid() then
                --ply:Kick("Exploit attempt")
                return
            end
            return
        end

        local pos = spawn:GetPos()
        local ang = spawn:GetAngles()
        local name = spawn:GetPlatformName()

        if !table.HasValue(vehicles,class) then 
            ply:ChatPrint("*** "..terminal:ConfigValue("NoAccessVeh")) 
            return 
        end

        if SpawnBlocked(spawn) then
            ply:ChatPrint("*** "..terminal:ConfigValue("SpawnBlocked"))
            return
        end

        local vehicle = ents.Create(class)
        vehicle:SetPos(pos)
        vehicle:SetAngles(ang)
        vehicle:SetOwner(ply)
        vehicle:Spawn()

        ply.SSE_CurrentVeh = vehicle
    end)
end

if CLIENT then
    function ENT:Draw()
        self.BaseClass.Draw(self)
    end



    function SSE_VehicleSpawnSelectSpawn(class, terminal)
        if ValidPanel(SSE_VehicleSpawnGUI) then SSE_VehicleSpawnGUI:Remove() end
        SSE_VehicleSpawnGUI = SSE:DefaultFrame(terminal:ConfigValue("ChooseSpawn"))
        SSE_VehicleSpawnGUI:SetSize(SSEW(500), SSEH(800))
        SSE_VehicleSpawnGUI:Center()

        function SSE_VehicleSpawnGUI:OnRemove()
            terminal:InvalidateUseConfirm(LocalPlayer())
        end

        local fahrzeugeList = SSE:ScrollBar(SSE_VehicleSpawnGUI)
        fahrzeugeList:Dock(FILL)

        for k, v in SortedPairs(ents.FindByClass("sse_vehspawn")) do
            local text = v:GetPlatformName()
            local btn = SSE:Button(fahrzeugeList, text, function()
                net.Start("SSE_VehicleSpawn_Spawn")
                    net.WriteString(class)
                    net.WriteEntity(v)
                    net.WriteEntity(terminal)
                net.SendToServer()

                if ValidPanel(SSE_VehicleSpawnGUI) then SSE_VehicleSpawnGUI:Remove() end
            end, "bc")
            btn:Dock(TOP)
            btn:DockMargin(0, 0, 0, SSEH(5))

            function btn:PaintOver(w, h)
                if SpawnBlocked(v) then
                    self:SetEnabled(false)
                    self.akzent = Color(200, 0, 0, 255)
                    self.akzenthover = Color(255, 0, 0, 255)
                else
                    self:SetEnabled(true)
                    self.akzent = Color(0, 200, 0, 255)
                    self.akzenthover = Color(0, 255, 0, 255)
                end
            end
        end
    end

    function SSE_VehicleSpawnFrame(fahrzeuge, terminal)
        if !IsValid(terminal) then return end
        if !fahrzeuge then LocalPlayer():ChatPrint("*** "..terminal:ConfigValue("NoAccess")) return end
        if !istable(fahrzeuge) then LocalPlayer():ChatPrint("*** "..terminal:ConfigValue("NoAccess")) return end
        if table.IsEmpty(fahrzeuge) then LocalPlayer():ChatPrint("*** "..terminal:ConfigValue("NoAccess")) return end

        if ValidPanel(SSE_VehicleSpawnGUI) then SSE_VehicleSpawnGUI:Remove() end
        SSE_VehicleSpawnGUI = SSE:DefaultFrame(terminal:ConfigValue("Title"))
        SSE_VehicleSpawnGUI:SetSize(SSEW(500), SSEH(800))
        SSE_VehicleSpawnGUI:Center()

        local fahrzeugeList = SSE:ScrollBar(SSE_VehicleSpawnGUI)
        fahrzeugeList:Dock(FILL)

        for k, v in pairs(fahrzeuge) do
            local entTbl = scripted_ents.Get(v)
            local text = v
            if entTbl then
                text = entTbl.PrintName
            end
            local btn = SSE:Button(fahrzeugeList, text, function() SSE_VehicleSpawnSelectSpawn(v, terminal) end, "lc")
            btn:Dock(TOP)
            btn:DockMargin(0, 0, 0, SSEH(5))
        end
    end

    function ENT:ClientUse()
        local getVehiclesFunc = self:ConfigValue("GetVehicles")
        SSE_VehicleSpawnFrame(getVehiclesFunc(LocalPlayer()), self)
    end
end

--addons/sse_101/lua/entities/sse_vehspawn.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Vehiclespawnpoint"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "SSE"
ENT.Spawnable       = true
ENT.Editable        = true
if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/maxofs2d/cube_tool.mdl" )
        self:DrawShadow( false )

        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end

function ENT:SetupDataTables()

	self:NetworkVar( "String", 0, "PlatformName", { KeyName = "platformname",	Edit = { type = "Generic",	order = 1} } ) 

	if SERVER then
		self:SetPlatformName("Unbekannt")
	end
end

if CLIENT then
    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 

            if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 1000*1000 then
                render.DrawWireframeBox( self:GetPos(), self:GetAngles(), Vector( -200, -200, -200 ), Vector( 200, 200, 200 ), Color(200,0,0,200) ) -- draws the box 
            end
        end
    end

end
--addons/aoc_nextbots/lua/entities/summe_boarding_pod_flying/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Boarding Pod (flying)"
ENT.Category = "Summe"
ENT.Spawnable = false
ENT.Editable = true

function ENT:SetupDataTables()
    self:NetworkVar("Bool", 0, "Landed", { KeyName = "Landed", Edit = { type = "Boolean", order = 1, category = "Settings"}})
end
--addons/arccw_weapons/lua/entities/tfa_ammo_base.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "AmmoBase"
ENT.Category = "TFA Ammunition"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Class = ""
ENT.MyModel = "models/props_junk/popcan01a.mdl"
ENT.ImpactSound = "Default.ImpactSoft"
ENT.AmmoCount = 100
ENT.AmmoType = "357"
ENT.TextPosition = Vector(-2.5, -3.3, 4)
ENT.TextAngles = Vector(48, -90, 0)
ENT.TextColor = Color(240, 35, 35, 255)
ENT.DrawText = false
ENT.ShouldDrawShadow = true
ENT.ImpactSound = "Default.ImpactSoft"
ENT.DamageThreshold = 80
ENT.ExplosionOffset = Vector(0, 0, 10)
ENT.Damage = 30
ENT.TextOffX = 30
ENT.TextOffY = -20
ENT.TextScale = 1

if SERVER then
	AddCSLuaFile()

	function ENT:SpawnFunction(ply, tr, classname)
		if (not tr.Hit) then return end
		local pos = tr.HitPos + tr.HitNormal * 4
		local ent = ents.Create(classname)
		ent:SetPos(pos)
		ent:Spawn()
		ent:Activate()
		ent.Class = classname
		ent.Spawner = ply

		return ent
	end

	function ENT:Initialize()
		local model = self.MyModel
		self.Class = self:GetClass()
		self:SetModel(model)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:DrawShadow(self.ShouldDrawShadow)
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		self:SetUseType(SIMPLE_USE)
		self:SetHealth(self.DamageThreshold)
		self:SetNW2Bool("ShouldRemove", false)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
		end
	end

	function ENT:PhysicsCollide(data, physobj)
		if (data.Speed > 60 and data.DeltaTime > 0.2) then
			self:EmitSound(self.ImpactSound)
		end
	end

	function ENT:Use(activator, caller)
		if IsValid(activator) and activator:IsPlayer() then
			activator:GiveAmmo(self.AmmoCount, self.AmmoType)
			self:SetNW2Bool("ShouldRemove", true)
		end
	end

	local bul = {}
	local randvec = Vector(0, 0, 0)
	bul.Tracer = 3
	bul.Num = 1
	bul.TracerName = "Tracer"
	bul.Spread = Vector(0, 0, 0)

	local cv_dc = GetConVar("sv_tfa_ammo_detonation_chain")
	local cv_dm = GetConVar("sv_tfa_ammo_detonation_mode")
	function ENT:OnTakeDamage(dmginfo)
		if not IsValid(self) then return end
		local at = dmginfo:GetInflictor()
		local shouldtakedamage = true

		if IsValid(at) then
			local base = at.Base

			if (base and string.find(base, "tfa_ammo_base")) or string.find(at:GetClass(), "tfa_ammo_") and not cv_dc:GetBool() then
				shouldtakedamage = false
			end
		end

		if dmginfo:GetDamage() < 1 then
			shouldtakedamage = false
		end

		self.Attacker = at

		if shouldtakedamage then
			self:SetHealth(self:Health() - dmginfo:GetDamage())
		end

		self:EmitSound(self.ImpactSound)
		local phy = self:GetPhysicsObject()

		if IsValid(phy) then
			local f = dmginfo:GetDamageForce()
			local p = dmginfo:GetDamagePosition()

			if f and p then
				phy:ApplyForceOffset(f / 4, p)
			end
		end
	end

	function ENT:Think()
		if self:GetNW2Bool("ShouldRemove", false) then
			self:Remove()

			return false
		end

		if not cv_dc:GetBool() then return true end

		if self:Health() <= 0 then
			self:EmitSound(self.ImpactSound)
			local adm = cv_dm:GetInt()
			bul.AmmoType = self.AmmoType
			bul.Damage = self.Damage
			bul.Force = math.Max(self.Damage / 25, 0.1)
			bul.Attacker = self

			if IsValid(self.Attacker) then
				bul.Attacker = self.Attacker
			end

			local upang = self:GetAngles():Up()
			bul.Dir = upang + randvec * 0.75
			local numbuls = math.random(math.Round(self.AmmoCount * 0.25), math.Round(self.AmmoCount * 0.75))
			local i = 1

			if adm == 2 then
				bul.Damage = bul.Damage / 2
			end

			bul.Dir = (upang + randvec * 0.75):GetNormalized()
			bul.Src = self:GetPos()
			self:FireBullets(bul)

			if adm ~= 1 then
				while i <= math.Clamp(numbuls, 1, 35) do
					randvec.x = math.Rand(-1, 1)
					randvec.y = math.Rand(-1, 1)
					randvec.z = math.Rand(-1, 1)
					bul.Dir = (upang + randvec * 0.75):GetNormalized()
					bul.Src = self:GetPos()
					self:FireBullets(bul)
					i = i + 1
				end
			end

			local effectdata = EffectData()
			effectdata:SetOrigin(self:GetPos())
			effectdata:SetMagnitude(0.1)
			effectdata:SetScale(0.5)

			if adm == 1 then
				bul.Damage = bul.Damage * 3 / 4
			end

			if adm > 0 then
				util.BlastDamage(bul.Attacker, bul.Attacker, bul.Src, (bul.Damage * 6 + 128) / 2, bul.Damage * 2)
				util.Effect("Explosion", effectdata)
			end

			if adm ~= 1 then
				util.Effect("cball_explode", effectdata)
			end

			self:SetNW2Bool("ShouldRemove", true)
		end
	end
end

if CLIENT then
	function ENT:Initialize()
		self.Class = self:GetClass()
	end

	function ENT:Draw()
		self:DrawModel()

		if self.TextPosition and self.TextAngles and self.DrawText then
			local pos = self:GetPos() + (self:GetUp() * self.TextPosition.z) + (self:GetRight() * self.TextPosition.x) + (self:GetForward() * self.TextPosition.y)
			local ang = self:GetAngles()
			ang:RotateAroundAxis(ang:Right(), self.TextAngles.x)
			ang:RotateAroundAxis(ang:Up(), self.TextAngles.y)
			ang:RotateAroundAxis(ang:Forward(), self.TextAngles.z)

			if not self.Text then
				self.Text = string.upper(self.AmmoType)
			end

			cam.Start3D2D(pos, ang, .07 * self.TextScale)
			draw.SimpleText(self.Text, "DermaLarge", self.TextOffX, self.TextOffY, self.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			cam.End3D2D()
		end
	end
end

--addons/arccw_weapons/lua/entities/tfa_csgo_fire_1/shared.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Damage = 1

function ENT:Draw()
end

function ENT:Initialize()
	self.Damage = 1
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
		for i = 1, 20 do
			local fire = ents.Create("info_particle_system")
			if (i < 2) then
				fire:SetKeyValue("effect_name","molotov_fire_main_gm")
			else
				fire:SetKeyValue("effect_name","molotov_fire_child_gm")
			end
			local pos = self:GetPos()
			//fire:SetPos( Vector( pos.x + 100 * math.sin( math.rad( i * 20 ) ), pos.y + 100 * math.cos( math.rad( i * 20 ) ), pos.z ) )
			fire:SetPos( Vector( pos.x + math.Rand(0, 144) * math.sin( math.rad( i * math.Rand( 0, 180 ) ) ), pos.y + math.Rand(0, 144) * math.cos( math.rad( i * math.Rand( 0, 180 ) ) ), pos.z ) )
			fire:SetAngles( self:GetAngles() )
			fire:SetParent( self )
			fire:Spawn()
			fire:Activate()
			fire:Fire("Start","",0)
			fire:Fire("Kill","",8)
		end
	end
	self:NextThink( CurTime() )
end

function ENT:Think()
	if SERVER then
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 150 ) ) do
			if v:IsPlayer() or v:IsNPC() then
				if v:GetPos():Distance( self:GetPos() ) < 150 then
					damage = DamageInfo()
					damage:SetDamage( math.random( 3, 7 ) )
					damage:SetAttacker( self:GetOwner() )
					damage:SetInflictor( self:GetCreator() )
					damage:SetDamageType( DMG_BURN )
					v:TakeDamageInfo( damage )
				end
			end
		end
	end
	if self:GetNWBool("extinguished",true) then
		if not self.PlayedSound then
			self:EmitSound("TFA_CSGO_Molotov.Extinguish")
			self.PlayedSound = true
		end
		if SERVER then
			SafeRemoveEntity( self )
		end
	end
	self:NextThink( CurTime() + math.Rand( 0.2, 0.7 ) )
end
--addons/arccw_weapons/lua/entities/tfa_thrown_blade/cl_init.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--lua/entities/turret_eweb/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetShootPos()--GetDTEntity(1)
	
end
--[[
ENT.HiddenShooter=false
function ENT:Think()
	if not self.HiddenShooter and IsValid(self.shootPos) then
		self.shootPos:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self.shootPos:SetColor(Color(255,255,255,1))
		self.HiddenShooter=true
	end
	
end]]

local color_lightwhite = Color(250,250,250)
local color_outline = Color(25,25,25,100)
local color_green = Color(39, 174, 96)

function ENT:Draw()
	
	self:DrawModel()

	if (self:GetTurretBase()) and (IsValid(self:GetTurretBase())) then

		local Ang = self:GetTurretBase():GetAngles()
		local Pos = self:GetTurretBase():GetPos()

		local ammo = self:GetTAmmo()
		local perc = math.ceil((ammo*100)/500)

		-- Ang:RotateAroundAxis(self:GetAngles():Forward(), 90)
		Ang:RotateAroundAxis(self:GetTurretBase():GetAngles():Up(), 180)
		
		
		cam.Start3D2D(Pos + Ang:Up() * 20.8 + Ang:Forward()*-15.51 + Ang:Right()*77.8, Ang, 0.07 )

			surface.SetDrawColor(color_black)
			surface.DrawRect(0,0, -95, -95)

			surface.SetDrawColor(color_green)
			surface.DrawRect(0,0, -95, -95 * (perc / 100))

			draw.SimpleTextOutlined(perc.."%", "DermaLarge", -47.5, -47.5,  color_lightwhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, color_outline )

		cam.End3D2D()

	end
	
end
--lua/entities/turret_eweb_ammo/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "E-Web Ammo"
ENT.Category		= "[SWRP] Emplacements"

ENT.Spawnable = true

--addons/tools/lua/entities/vanilla_hyperspace2_ship/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    local sound1 = "vanilla/hyperspace/vanilla_hyperspace_01.wav"
    local sound2 = "vanilla/hyperspace/vanilla_hyperspace_02.wav"

    if self:GetPlaySound() == "1" then
        local choose = math.random(0,1)
    	if choose == 0 then
    		surface.PlaySound(sound1)
    	else
    		surface.PlaySound(sound2)
    	end
    end
end

function ENT:Draw()
    self:DrawModel()
end

--addons/arccw_weapons/lua/entities/wrist_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Wrist Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp02.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_cis_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 10 )
        smoke:SetEndSize( 35 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_wristrocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_med0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 150, 225)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(255, 100, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--lua/effects/arccw_uc_shelleffect.lua:

EFFECT.Sounds = {}
EFFECT.Pitch = 90
EFFECT.Scale = 1.5
EFFECT.PhysScale = 1
EFFECT.Model = "models/shells/shell_57.mdl"
EFFECT.Material = nil
EFFECT.JustOnce = true
EFFECT.AlreadyPlayedSound = false
EFFECT.ShellTime = 1

EFFECT.SpawnTime = 0

EFFECT.UC_ShellColor = color_white

function EFFECT:Init(data)

    local att = data:GetAttachment()
    local ent = data:GetEntity()
    local mag = data:GetMagnitude()

    local mdl = LocalPlayer():GetViewModel()

    if LocalPlayer():ShouldDrawLocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if !IsValid(ent) then self:Remove() return end

    local owner = ent:GetOwner()
    if owner != LocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if owner != LocalPlayer() and !GetConVar("arccw_shelleffects"):GetBool() then self:Remove() return end
    if !IsValid(mdl) then self:Remove() return end
    if !mdl:GetAttachment(att) then self:Remove() return end

    local origin, ang = mdl:GetAttachment(att).Pos, mdl:GetAttachment(att).Ang

    ang:RotateAroundAxis(ang:Right(), -90 + ent.ShellRotate)

    ang:RotateAroundAxis(ang:Right(), (ent.ShellRotateAngle or Angle(0, 0, 0))[1])
    ang:RotateAroundAxis(ang:Up(), (ent.ShellRotateAngle or Angle(0, 0, 0))[2])
    ang:RotateAroundAxis(ang:Forward(), (ent.ShellRotateAngle or Angle(0, 0, 0))[3])

    local dir = ang:Up()

    local st = GetConVar("arccw_shelltime"):GetFloat()

    if ent then
        self.Model = ent:GetBuff_Override("Override_ShellModel") or ent.ShellModel
        self.Material = ent:GetBuff_Override("Override_ShellMaterial") or ent.ShellMaterial
        self.Scale = ent:GetBuff("ShellScale") or 1--ent:GetBuff_Override("Override_ShellScale") or ent.ShellScale or 1
        self.PhysScale = ent:GetBuff_Override("Override_ShellPhysScale") or ent.ShellPhysScale or 1
        self.Pitch = ent:GetBuff_Override("Override_ShellPitch") or ent.ShellPitch or 100
        self.Sounds = ent:GetBuff_Override("Override_ShellSounds") or ent.ShellSounds
        self.ShellTime = (ent.ShellTime or 0) + st

        if self.Sounds == "autocheck" and ent:GetPrimaryAmmoType() then
            local t = ent:GetPrimaryAmmoType()
            if t == game.GetAmmoID("buckshot") then
                self.Sounds = ArcCW.ShotgunShellSoundsTable
            elseif ent.Trivia_Calibre and string.find(ent.Trivia_Calibre, ".22") then
                self.Sounds = ArcCW.TinyShellSoundsTable
            elseif t == game.GetAmmoID("pistol") or t == game.GetAmmoID("357") or t == game.GetAmmoID("AlyxGun") then
                self.Sounds = ArcCW.PistolShellSoundsTable
            elseif t == game.GetAmmoID("ar2") then
                self.Sounds = ArcCW.MediumShellSoundsTable
            else
                self.Sounds = ArcCW.ShellSoundsTable
            end
        end

        self.UC_ShellColor = ent:GetBuff_Override("Override_UC_ShellColor") or ent.UC_ShellColor or self.UC_ShellColor
    end

    self:SetPos(origin)
    self:SetModel(self.Model)
    self:SetModelScale(self.Scale)
    self:DrawShadow(true)
    self:SetAngles(ang)

    if self.Material then
        self:SetMaterial(self.Material)
    end

    local pb_vert = 2 * self.Scale * self.PhysScale
    local pb_hor = 0.5 * self.Scale * self.PhysScale

    self:PhysicsInitBox(Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor))

    self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE_DEBRIS)

    local phys = self:GetPhysicsObject()

    local plyvel = Vector(0, 0, 0)

    if IsValid(owner) then
        plyvel = owner:GetAbsVelocity()
    end


    phys:Wake()
    phys:SetDamping(0, 0)
    phys:SetMass(1)
    phys:SetMaterial("gmod_silent")

    phys:SetVelocity((dir * mag * math.Rand(1, 2)) + plyvel)

    phys:AddAngleVelocity(VectorRand() * 100)
    phys:AddAngleVelocity(ang:Up() * 2500 * math.Rand(0.75, 1.25))

    self.HitPitch = self.Pitch + math.Rand(-5,5)

    local emitter = ParticleEmitter(origin)

    for i = 1, 3 do
        local particle = emitter:Add("particles/smokey", origin + (dir * 2))

        if (particle) then
            particle:SetVelocity(VectorRand() * 10 + (dir * i * math.Rand(48, 64)) + plyvel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.05, 0.15))
            particle:SetStartAlpha(math.Rand(40, 60))
            particle:SetEndAlpha(0)
            particle:SetStartSize(0)
            particle:SetEndSize(math.Rand(18, 24))
            particle:SetRoll(math.rad(math.Rand(0, 360)))
            particle:SetRollDelta(math.Rand(-1, 1))
            particle:SetLighting(true)
            particle:SetAirResistance(96)
            particle:SetGravity(Vector(-7, 3, 20))
            particle:SetColor(150, 150, 150)
        end
    end

    self.SpawnTime = CurTime()
end

function EFFECT:PhysicsCollide()
    if self.AlreadyPlayedSound and self.JustOnce then return end

    sound.Play(self.Sounds[math.random(#self.Sounds)], self:GetPos(), 65, self.HitPitch, 1)

    self.AlreadyPlayedSound = true
end

function EFFECT:Think()
    if (self.SpawnTime + self.ShellTime) <= CurTime() then
        if !IsValid(self) then return end
        self:SetRenderFX( kRenderFxFadeFast )
        if (self.SpawnTime + self.ShellTime + 1) <= CurTime() then
            if !IsValid(self:GetPhysicsObject()) then return end
            self:GetPhysicsObject():EnableMotion(false)
            if (self.SpawnTime + self.ShellTime + 1.5) <= CurTime() then
                self:Remove()
                return
            end
        end
    end
    return true
end

function EFFECT:Render()
    if !IsValid(self) then return end
    self:DrawModel()
end
--lua/effects/blue_tracer_fx.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_blue_main" );
local MaterialFront			= Material( "effects/sw_laser_blue_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * (endDistance*1.2);
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 32, 24, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 20, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact_beamrifle/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swbf/sparks", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 25, 30 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/swbf/thicksmoke"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(2, 5));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(20, 40));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_laser/init.lua:

local Tracer = Material( "effects/halo3/spartanlaser" )
local Width = 16

function EFFECT:Init( data )

	self.Entity=data:GetEntity()
	if !IsValid(self.Entity) then return end
	self.Position = self.Entity:GetAttachment(1).Pos
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.DieTime = CurTime() + self.LifeTime

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()


	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	

	render.SetMaterial( Tracer )
	for i=1, 8 do
	render.DrawBeam( self.StartPos, self.EndPos, ( Width / i)* v, 0, (self.Dist/10)*math.Rand(-2,2), Color( 225, 200, 200, v * 100 ) )
	end
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_plasmarifle_brute/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 48;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_reach/trail_red" );
local MaterialFront			= Material( "effects/halo_reach/plasma_bolt_red" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - 2* self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 10, 10, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 15, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_impact_ne/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 48;

local MaterialGlow		= Material( "effects/halo_ce/flare_generic" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flare1", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 200, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flare1", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.15 ) );
			particle:SetStartAlpha( 155 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(155, 85, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end

		
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_ce/flare_generic", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 35 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(215, 85, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, 205, 230, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_plasma_orange_burn/init.lua:

local Tracer = Material( "effects/halo2/c_gun_turret_contrail" )
local Tracer2  = Material( "effects/halo3/spartanlaser" )
local Width = 10
local Width2 = 5

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 205, 255, v * 200 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 220, 255, 185, (v2 * 155)*1 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_spv3_tracer_brute_plasma_rifle/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 1500;
EFFECT.Length				= 75;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/muzzle_flash_01" );
local MaterialFront			= Material( "effects/halo_spv3/flash/smg_new" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 7, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_haloreach_tracer_needler_rifle/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 8000;
EFFECT.Length				= 512;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/trail_beamrifle" );
local MaterialFront			= Material( "effects/halo3/muzzle_needler" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 3, 7, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 4, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_crimson_sniper/init.lua:

local Tracer = Material( "effects/laser1" )
local Tracer2  = Material( "effects/swbf/red_beam" )
local Width = 15
local Width2 = 10

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 0, 0, v * 100 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 200, 200, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_orange/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swbf/orangelaser_bolt" );
local MaterialFront			= Material( "effects/swbf/orangelaser" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_teal_sniper/init.lua:

local Tracer = Material( "effects/laser1" )
local Tracer2  = Material( "effects/swbf/blue_beam" )
local Width = 25
local Width2 = 15

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 90, 255, 200, v * 100 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 10, 255, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_laser/init.lua:

EFFECT.Mat = Material( "cable/redlaser" )


function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	

	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 255
	self.FlashA = 255
	
end


function EFFECT:Think( )

	self.FlashA = self.FlashA - 2050 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1650 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end


function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 8,													// Width
					 texcoord,														// Start tex coord
					 texcoord + self.Length / 256,									// End tex coord
					 Color( 255, 255, 255, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
					 
end

--addons/weapon_jedi/lua/effects/force_effects.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

EFFECT.mat2 = Material( "sprites/heatwave" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime
	self.mat = Material( "particle/smokesprites_000"..math.random(1,9) )
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	render.SetMaterial( self.mat )
	render.DrawSprite( self.Ent:LocalToWorld( self.Ent:OBBCenter() ), 150 * Scale, 150 * Scale, Color( 150,200,255,50 * Scale ) )
	render.SetMaterial( self.mat2 )
	render.DrawSprite( self.Ent:LocalToWorld( self.Ent:OBBCenter() ), 100 * Scale, 100 * Scale, Color( 255,255,255,255 ) )
end
	

--addons/weapon_jedi/lua/effects/force_lightning_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 150, 150, 255, 255) )
	end
end

--addons/lvs_addons/lua/effects/lfs_fb_laser_blue.lua:
EFFECT.Mat = Material( "effects/spark" )
EFFECT.Mat2 = Material( "sprites/light_glow02_add" )

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}
local color_white = Color(255, 255, 255, 255)
local color_blue = Color(55, 169, 237, 255)

function EFFECT:Init( data )
	self.StartPos = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 15000 ) * 0.5
	self.Length = math.Rand( 0.4, 0.45 )
	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime
	
	local Dir = self.Dir:GetNormalized()
	local emitter = ParticleEmitter( self.StartPos, false )
	
	for i = 0, 12 do
		local Pos = self.StartPos + Dir * i * 0.7 * math.random(1,2) * 0.5
		local particle = emitter:Add( "effects/muzzleflash2", Pos )
		local Size = 2
		
		if particle then
			particle:SetVelocity( Dir * 800 )
			particle:SetDieTime( 0.05 )
			particle:SetStartAlpha( 255 * Size )
			particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( color_blue )
			particle:SetCollide( false )
		end
	end
	
	for i = 0,20 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))],self.StartPos )
		local rCol = 255
		
		if particle then
			particle:SetVelocity( Dir * math.Rand(1000,3000) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) ) 
			particle:SetStartAlpha( 20 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( color_white )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0,200) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50, 80, 255) ) 
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "lfs_laser_hit", effectdata )
		
		return false
	end

	return true
end

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2 -- lasers are faster than bullets...

	local sinWave = math.sin( fDelta * math.pi )
	
	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1, self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ), 45, 1, 0, color_blue )
		
	render.DrawBeam( Pos1, self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ), 15, 1, 0, color_white )
end
--addons/lvs_addons/lua/effects/lvs_concussion_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 40, 100 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 255, 40, 100, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_exhaust.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local Vel = Ent:GetVelocity()

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

	if not particle then return end

	local Col = 100 - 60 * Scale

	particle:SetVelocity( Vel + Dir * (100 + 50 * Scale) )
	particle:SetDieTime( 0.4 - 0.3 * Scale )
	particle:SetAirResistance( 400 ) 
	particle:SetStartAlpha( 80 )
	particle:SetStartSize( 2 )
	particle:SetEndSize( 10 + 20 * Scale )
	particle:SetRoll( math.Rand( -1, 1 ) )
	particle:SetRollDelta( math.Rand( -1, 1 ) * 2 )
	particle:SetColor( Col, Col, Col )
	particle:SetGravity( Vector( 0, 0, 10 ) )
	particle:SetCollide( false )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_physics_impact.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	if not LVS.ShowPhysicsEffects then return end

	local pos  = data:GetOrigin()

	local emitter = ParticleEmitter( pos, false )

	for i = 0,4 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		
		local vel = VectorRand() * 200
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(2.5,5) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( 200 )
			particle:SetRoll( math.Rand(-5,5) )
			particle:SetColor( 30,30,20 )
			particle:SetGravity( Vector(0,0,20) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_physics_water.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	self.LifeTime = math.Rand(1.5,3)
	self.DieTime = CurTime() + self.LifeTime

	self.Splash = {
		Pos = Pos,
		Mat = Material("effects/splashwake1"),
		RandomAng = math.random(0,360),
	}

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	if emitter and emitter.Add then
		local particle = emitter:Add( "effects/splash4", Pos + VectorRand(-10,10) - Vector(0,0,20) )
		if particle then
			particle:SetVelocity( Vector(0,0,250) )
			particle:SetDieTime( 0.8 )
			particle:SetAirResistance( 60 ) 
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( 100 )
			particle:SetRoll( math.Rand(-1,1) * 100 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end
end


function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	end
	return true
end

function EFFECT:Render()
	if self.Splash and self.LifeTime then
		local Scale = (self.DieTime - self.LifeTime - CurTime()) / self.LifeTime
		local S = 200 - Scale * 600
		local Alpha = 100 + 100 * Scale

		cam.Start3D2D( self.Splash.Pos + Vector(0,0,1), Angle(0,0,0), 1 )
			surface.SetMaterial( self.Splash.Mat )
			surface.SetDrawColor( 255, 255, 255 , Alpha )
			surface.DrawTexturedRectRotated( 0, 0, S , S, self.Splash.RandomAng )
		cam.End3D2D()
	end
end
--addons/laat_g/lua/effects/lvs_proton_explosion_large.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add(  Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(50,80) )
			particle:SetEndSize( math.Rand(400,500) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(400,450) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 0,127,255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 100 )
			particle:SetEndSize( math.Rand(300,350) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 1000000
		if delay <= 0.9 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 1000 * Scale, 1000 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 800 * Scale, 800 * Scale, Color( 255, 255, 255, 255) )
end

--addons/joes_stuff/lua/effects/riffle.lua:
-- edited version of the normal gmod selection ring
EFFECT.Mat = Material( "effects/select_ring" )

function EFFECT:Init( data )

	local size = 8
	self:SetCollisionBounds( Vector( -size, -size, -size ), Vector( size, size, size ) )

	local Pos = data:GetOrigin() + data:GetNormal() * 2

	self:SetPos( Pos )

	-- This 0.01 is a hack.. to prevent the angle being weird and messing up when we change it back to a normal
	self:SetAngles( data:GetNormal():Angle() + Angle( 0.01, 0.01, 0.01 ) )

	self:SetParentPhysNum( data:GetAttachment() )

	if ( IsValid( data:GetEntity() ) ) then
		self:SetParent( data:GetEntity() )
	end

	self.Pos = data:GetOrigin()
	self.Normal = data:GetNormal()

	self.MaxSize = data:GetScale()
	self.Size = 0
	self.Alpha = 255
	self.Speed = math.Rand(0.5, 1.5)
end

function EFFECT:Think()

	self.Alpha = self.Alpha * ( 1 - self.Size / self.MaxSize )
	self.Size = self.Size + FrameTime() * 256 * self.Speed

	if self.Size >= self.MaxSize then return false end
	return true

end

function EFFECT:Render()

	if ( self.Alpha < 1 ) then return end

	render.SetMaterial( self.Mat )

	render.DrawQuadEasy( self.Pos, self:GetAngles():Forward(), self.Size, self.Size, Color( math.Rand( 10, 150 ), math.Rand( 170, 220 ), math.Rand( 240, 255 ), self.Alpha ) )

end

--addons/weapon_jedi/lua/effects/saber_hitwall_cheap.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)
	
	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()

	--[[
	local trace = util.TraceLine( {
		start = Pos + Dir * 5,
		endpos = Pos - Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), 0.3, 0.3 )
	end
	]]

	local emitter = ParticleEmitter( Pos, false )

	for i = 0,2 do
		local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( 0.5 )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( 6 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Dir * 10 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.25 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 150, 0 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		return false
	end

	return true
end

local mat = Material( "sprites/light_glow02_add" )
function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 12, 12, Color( 255 * Scale, 100 * Scale, 0, 255) ) 
end


--addons/arccw_weapons/lua/effects/tfa_tracer_purple/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(148, 0, 211)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(148, 0, 211)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 148
        dlight.g = 0
        dlight.b = 211
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end