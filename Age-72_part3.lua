--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 3/12 - 06/04/2025


--PATH addons/arccw_base_modified/lua/arccw/shared/sh_0_ttt.lua:
ArcCW.TTTAmmoToEntity = {
    ["pistol"] = "item_ammo_pistol_ttt",
    ["smg1"] = "item_ammo_smg1_ttt",
    ["AlyxGun"] = "item_ammo_revolver_ttt",
    ["357"] = "item_ammo_357_ttt",
    ["buckshot"] = "item_box_buckshot_ttt"
}
--[[
WEAPON_TYPE_RANDOM = 1
WEAPON_TYPE_MELEE = 2
WEAPON_TYPE_NADE = 3
WEAPON_TYPE_SHOTGUN = 4
WEAPON_TYPE_HEAVY = 5
WEAPON_TYPE_SNIPER = 6
WEAPON_TYPE_PISTOL = 7
WEAPON_TYPE_SPECIAL = 8
]]

ArcCW.AmmoToTTT = {
    ["357"] = "AlyxGun",
    ["SniperPenetratedRound"] = "357",
    ["ar2"] = "smg1",
}
ArcCW.TTTAmmoToClipMax = {
    ["357"] = 20,
    ["smg1"] = 60,
    ["pistol"] = 60,
    ["alyxgun"] = 36,
    ["buckshot"] = 24
}
-- translate TTT weapons to HL2 weapons, in order to recognize NPC weapon replacements.
ArcCW.TTTReplaceTable = {
    ["weapon_ttt_glock"] = "weapon_pistol",
    ["weapon_zm_mac10"] = "weapon_ar2",
    ["weapon_ttt_m16"] = "weapon_smg1",
    ["weapon_zm_pistol"] = "weapon_pistol",
    ["weapon_zm_revolver"] = "weapon_357",
    ["weapon_zm_rifle"] = "weapon_crossbow",
    ["weapon_zm_shotgun"] = "weapon_shotgun",
    ["weapon_zm_sledge"] = "weapon_ar2",
    ["weapon_ttt_smokegrenade"] = "weapon_grenade",
    ["weapon_ttt_confgrenade"] = "weapon_grenade",
    ["weapon_tttbasegrenade"] = "weapon_grenade",
    ["weapon_zm_molotov"] = "weapon_grenade",
}

if engine.ActiveGamemode() != "terrortown" then return end

hook.Add("OnGamemodeLoaded", "ArcCW_TTT", function()
    for i, wep in pairs(weapons.GetList()) do
        local weap = weapons.Get(wep.ClassName)
        if weap then
            if !weap.ArcCW then
                continue
            end
            if weap.ArcCW and !weap.Spawnable then
                continue
            end
        end

        if ArcCW.AmmoToTTT[wep.Primary.Ammo] then
            wep.Primary.Ammo = ArcCW.AmmoToTTT[wep.Primary.Ammo]
        end

        wep.AmmoEnt = ArcCW.TTTAmmoToEntity[wep.Primary.Ammo] or ""
        -- You can tell how desperate I am in blocking the base from spawning
        wep.AutoSpawnable = (wep.AutoSpawnable == nil and true) or wep.AutoSpawnable
        wep.AllowDrop = wep.AllowDrop or true

        -- We have to do this here because TTT2 does a check for .Kind in WeaponEquip,
        -- earlier than Initialize() which assigns .Kind
        if !wep.Kind and !wep.CanBuy then
            if wep.Throwing or weap.Throwing then
                wep.Slot = 3
                wep.Kind = WEAPON_NADE
                wep.spawnType = wep.spawnType or WEAPON_TYPE_NADE
            elseif wep.Slot == 0 then
                -- melee weapons
                wep.Slot = 6
                wep.Kind = WEAPON_MELEE or WEAPON_EQUIP1
                wep.spawnType = wep.spawnType or WEAPON_TYPE_MELEE
            elseif wep.Slot == 1 then
                -- sidearms
                wep.Kind = WEAPON_PISTOL
                wep.spawnType = wep.spawnType or WEAPON_TYPE_PISTOL
            else
                -- other weapons are considered primary
                -- try to determine spawntype if none exists
                if !wep.spawnType then
                    if wep.Primary.Ammo == "357" or (wep.Slot == 3 and (wep.Num or 1) == 1) then
                        wep.spawnType = WEAPON_TYPE_SNIPER
                    elseif wep.Primary.Ammo == "buckshot" or (wep.Num or 1) > 1 then
                        wep.spawnType = WEAPON_TYPE_SHOTGUN
                    else
                        wep.spawnType = WEAPON_TYPE_HEAVY
                    end
                end

                wep.Slot = 2
                wep.Kind = WEAPON_HEAVY
            end
        end

        local class = wep.ClassName
        local path = "arccw/weaponicons/" .. class
        local path2 = "arccw/ttticons/" .. class .. ".png"
        local path3 = "vgui/ttt/" .. class
        local path4 = "entities/" .. class .. ".png"

        if !Material(path2):IsError() then
            -- TTT icon (png)
            wep.Icon = path2
        elseif !Material(path3):IsError() then
            -- TTT icon (vtf)
            wep.Icon = path3
        elseif !Material(path4):IsError() then
            -- Entity spawn icon
            wep.Icon = path4
        elseif !Material(path):IsError() then
            -- Kill icon
            wep.Icon = path
        else
            -- fallback: display _something_
            wep.Icon = "arccw/hud/arccw_bird.png"
        end

    end

    --[[]
    local pistol_ammo = (scripted_ents.GetStored("arccw_ammo_pistol") or {}).t
    if pistol_ammo then
        pistol_ammo.AmmoCount = 30
    end
    ]]

    -- Language string(s)
    if CLIENT then
        local lang = TTT2 and "en" or "english"
        LANG.AddToLanguage(lang, "search_dmg_buckshot", "This person was blasted to pieces by buckshot.")
        LANG.AddToLanguage(lang, "search_dmg_nervegas", "Their face looks pale. It must have been some sort of nerve gas.")
        LANG.AddToLanguage(lang, "ammo_smg1_grenade", "Rifle Grenades")
    end
end)

hook.Add("DoPlayerDeath", "ArcCW_DetectiveSeeAtts", function(ply, attacker, dmginfo)
    local wep = util.WeaponFromDamage(dmginfo)
    timer.Simple(0, function()
        if ArcCW.ConVars["ttt_bodyattinfo"]:GetInt() > 0 and ply.server_ragdoll and IsValid(wep) and wep:IsWeapon() and wep.ArcCW and wep.Attachments then
            net.Start("arccw_ttt_bodyattinfo")
                net.WriteEntity(ply.server_ragdoll)
                net.WriteUInt(table.Count(wep.Attachments), 8)
                for i, info in pairs(wep.Attachments) do
                    if info.Installed then
                        net.WriteUInt(ArcCW.AttachmentTable[info.Installed].ID, ArcCW.GetBitNecessity())
                    else
                        net.WriteUInt(0, ArcCW.GetBitNecessity())
                    end
                end
            net.Broadcast()
        end
    end)
end)

hook.Add("ArcCW_OnAttLoad", "ArcCW_TTT", function(att)
    if att.Override_Ammo and ArcCW.AmmoToTTT[att.Override_Ammo] then
        att.Override_Ammo = ArcCW.AmmoToTTT[att.Override_Ammo]
    end
end)

--addons/arccw_base_modified/lua/arccw/shared/sh_ammo.lua:
ArcCW.AmmoEntToArcCW = {
    -- TTT
    ["item_ammo_pistol_ttt"] = "arccw_ammo_pistol",
    ["item_ammo_smg1_ttt"] = "arccw_ammo_smg1",
    ["item_ammo_revolver_ttt"] = "arccw_ammo_357",
    ["item_ammo_357_ttt"] = "arccw_ammo_sniper",
    ["item_box_buckshot_ttt"] = "arccw_ammo_buckshot",

    -- HL2
    ["item_ammo_357"] = "arccw_ammo_357",
    ["item_ammo_357_large"] = "arccw_ammo_357_large",
    ["item_ammo_ar2"] = "arccw_ammo_ar2",
    ["item_ammo_ar2_large"] = "arccw_ammo_ar2_large",
    ["item_ammo_pistol"] = "arccw_ammo_pistol",
    ["item_ammo_pistol_large"] = "arccw_ammo_pistol_large",
    ["item_ammo_smg1"] = "arccw_ammo_smg1",
    ["item_ammo_smg1_large"] = "arccw_ammo_smg1_large",
    ["item_ammo_smg1_grenade"] = "arccw_ammo_smg1_grenade",
    ["item_ammo_crossbow"] = "arccw_ammo_sniper",
    ["item_box_buckshot"] = "arccw_ammo_buckshot",
    ["item_ammo_ar2_altfire"] = "arccw_ammo_smg1_grenade",

    -- HL:S
    ["ammo_357"] = "arccw_ammo_357",
    ["ammo_crossbow"] = "arccw_ammo_sniper",
    ["ammo_glockclip"] = "arccw_ammo_pistol",
    ["ammo_9mmbox"] = "arccw_ammo_ar2",
    ["ammo_mp5clip"] = "arccw_ammo_smg1",
    ["ammo_mp5grenades"] = "arccw_ammo_smg1_grenade",
    ["ammo_rpgclip"] = "arccw_ammo_smg1_grenade_large",
    ["ammo_buckshot"] = "arccw_ammo_buckshot",
    ["ammo_gaussclip"] = "arccw_ammo_ar2_large"
}

function ArcCW:AddGrenadeAmmo()
    if ArcCW.ConVars["equipmentammo"]:GetBool() and !ArcCW.ConVars["equipmentsingleton"]:GetBool() then
        for i, k in pairs(weapons.GetList()) do
            local class = k.ClassName
            local wpntbl = weapons.Get(class)
            if !wpntbl.ArcCW then continue end

            if (wpntbl.Throwing or wpntbl.Disposable) and !wpntbl.Singleton and !wpntbl.DoNotEquipmentAmmo then
                -- ammoid check will cause inconsistency between SV/CL on map change
                -- Initialize is only run once anyways, so it should be fine
                --local ammoid = game.GetAmmoID(class)
                --if ammoid == -1 then
                    -- if ammo type does not exist, build it
                    game.AddAmmoType({
                        name = class,
                    })
                    print("ArcCW adding ammo type " .. class)
                    if CLIENT then
                        language.Add(class .. "_ammo", wpntbl.PrintName)
                    end
                    ArcCW.LangTable["en"]["ammo." .. class] = wpntbl.PrintName
                --end

                k.Primary.Ammo = class
                k.OldAmmo = class
            end
        end
    end
end

hook.Add("Initialize", "ArcCW_AddGrenadeAmmo", ArcCW.AddGrenadeAmmo)

if SERVER then
    -- hook.Add( "OnEntityCreated", "ArcCW_AmmoReplacement", function(ent)
    --     if ((engine.ActiveGamemode() == "terrortown" and ArcCW.ConVars["ttt_ammo"]:GetBool()) or
    --         (engine.ActiveGamemode() != "terrortown" and ArcCW.ConVars["ammo_replace"]:GetBool()))
    --             and ArcCW.AmmoEntToArcCW[ent:GetClass()] then
    --         timer.Simple(0, function()
    --             if !IsValid(ent) then return end
    --             local ammoent = ents.Create(ArcCW.AmmoEntToArcCW[ent:GetClass()])
    --             ammoent:SetPos(ent:GetPos())
    --             ammoent:SetAngles(ent:GetAngles())
    --             ammoent:Spawn()
    --             SafeRemoveEntityDelayed(ent, 0) -- remove next tick
    --             if engine.ActiveGamemode() == "terrortown" then
    --                 -- Setting owner prevents pickup
    --                 if IsValid(ent:GetOwner()) then
    --                     ammoent:SetOwner(ent:GetOwner())
    --                     timer.Simple(2, function()
    --                         if IsValid(ammoent) then ammoent:SetOwner(nil) end
    --                     end)
    --                     ammoent.AmmoCount = ent.AmmoAmount
    --                 end
    --                 --[[]
    --                 if ent:GetClass() == "item_ammo_pistol_ttt" and ent.AmmoCount == 20 then
    --                     -- Extremely ugly hack: TTT pistol ammo only gives 20 rounds but we want it to be 30
    --                     -- Because most SMGs use pistol ammo (unlike vanilla TTT) and it runs out quickly
    --                     ammoent.AmmoCount = 30
    --                 end
    --                 ]]
    --                 ammoent:SetNWInt("truecount", ammoent.AmmoCount)
    --             end
    --         end)
    --     end
    -- end)
end
--addons/arccw_weapons/lua/arccw/shared/sh_grenade.lua:
ArcCW.Grenade = {}

hook.Add("StartCommand", "ArcCW_Grenade_ArcSlow", function(ply, ucmd)
    if (ply.ArcSlowEnd or 0) > CurTime() then
        ucmd:SetButtons(bit.band(ucmd:GetButtons(), bit.bnot(IN_SPEED)))
    end
end)

hook.Add("SetupMove", "ArcCW_Grenade_ArcSlow", function(ply, mv, ucmd)
    if (ply.ArcSlowEnd or 0) > CurTime() then
        mv:SetMaxSpeed(mv:GetMaxSpeed() * 0.5)
        mv:SetMaxClientSpeed(mv:GetMaxClientSpeed() * 0.5)
    end
end)

if SERVER then
    util.AddNetworkString("arccw_grenade_autoreload")
    util.AddNetworkString("arccw_grenade_hit")
    util.AddNetworkString("arccw_grenade_arcslow")
    util.AddNetworkString("arccw_grenade_loader")

    -- Since all move hooks are run client and server, we need to network it
    function ArcCW.Grenade.ArcSlow(ply, dur)
        net.Start("arccw_grenade_arcslow")
            net.WriteFloat(dur + CurTime())
        net.Send(ply)
        ply.ArcSlowEnd = dur + CurTime()
    end

    net.Receive("arccw_grenade_arcslow", function()
        LocalPlayer().ArcSlowEnd = net.ReadFloat()
    end)

    hook.Add("RenderScreenspaceEffects", "ArcCW_Grenade_ArcSlow", function()
        if (LocalPlayer().ArcSlowEnd or 0) > CurTime() then
            local delta = math.Clamp((LocalPlayer().ArcSlowEnd - CurTime()) / 2, 0, 1) ^ 0.75

            DrawMaterialOverlay("effects/water_warp01", delta * 0.5)
            DrawMotionBlur(0.5 * delta, 0.75, 0.01)
            DrawColorModify({
                [ "$pp_colour_addr" ] = 0,
                [ "$pp_colour_addg" ] = 0,
                [ "$pp_colour_addb" ] = 0,
                [ "$pp_colour_brightness" ] = 0.35 * delta,
                [ "$pp_colour_contrast" ] = 1 - delta * 0.5,
                [ "$pp_colour_colour" ] = 1 - delta,
                [ "$pp_colour_mulr" ] = 0,
                [ "$pp_colour_mulg" ] = 0,
                [ "$pp_colour_mulb" ] = 0,
            })
        end
    end )

    hook.Add("HUDShouldDraw", "ArcCW_Grenade_ArcSlow", function(ele)
        if (LocalPlayer().ArcSlowEnd or 0) > CurTime() and ele ~= "CHudWeaponSelection" then
            return false
        end
    end)

end
--addons/arccw_weapons/lua/arccw/shared/attachments/15a_top_closecombat.lua:
att.PrintName = "15a Close-combat top"
att.Description = "Short length customized top. Improves handling, though offers much worse range and accuracy."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_a280c_barrel.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_top"
att.ActivateElements = {"15a_top_closecombat"}

att.Mult_Range = 0.79
att.Mult_Recoil = 1.10
att.Mult_RPM = 1.12 
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2
att.Mult_ShootPitch = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/a280cfe_stock_assault.lua:
att.PrintName = "Assault Stock"
att.Description = "Lightweight stock. Improves ADS speed at the cost of recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_stock"
att.ActivateElements = {"a280cfe_stock_assault"}

att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.75
att.Free = true
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_gl_stun.lua:
att.PrintName = "Stun Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_stungrenade.png")
att.Description = "Throwable grenade with stun capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_stun"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_low.lua:
att.PrintName = "Low Tibanna Density"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Cycle the potency of the platform to allow for its chambering in Low Density Tibanna."
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"

att.Reload = 1
att.Mult_DamageMin = 0.76
att.Mult_Recoil = 1.1
att.Mult_SightTime = 1
att.Mult_RPM = 1.35
att.NotForNPCs = true
att.Mult_Damage = 0.75
att.Mult_MuzzleVelocity = 0.5
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_masita_overpressure.lua:
att.PrintName = "Overpressure"

att.SortOrder = 20
att.Icon = Material("interfaz/armas/sw_powercore.png", "smooth mips")
att.Description = "Higher pressure compression allows for higher muzzle velocity at the cost of stronger knockback. Such immense pressure increases the likelihood of extraction failures."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ammo_masita"

att.AutoStats = true

att.Mult_RecoilSide = 1.25
att.Mult_Recoil = 1.2
att.Mult_RangeMin = 1.25
att.Mult_Range = 1.3

att.Mult_RPM = 1.08
att.Mult_ShootVol = 1.25
--att.Mult_ShootPitch = 0.9 please don't

att.Mult_MalfunctionMean = 0.7
att.Mult_PhysBulletMuzzleVelocity = 1.25
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_masita_stealth.lua:
att.PrintName = "Stealth Rounds"

att.SortOrder = 17
att.Icon = Material("interfaz/armas/sw_blastersilencer.png", "smooth mips")
att.Description = [[Stealth load low enough to make the plasma travel slower than the normal speed. This reduces range significantly, but makes gunfire very comfortable and quiet.
The sonic boom typical of the round is eliminated, rendering it even more silent than usual with a suppressed firearm.]]
att.Desc_Pros = {
    "Invisible tracers",
    -- "uc.subsonic"
}
att.Desc_Cons = {
    "Lower plasma speed"
}
att.Desc_Neutrals = {
}
att.Slot = "ammo_masita"

att.AutoStats = true

att.Mult_RecoilSide = 0.75
att.Mult_Recoil = 0.8
att.Mult_RangeMin = 0.75
att.Mult_Range = 0.7

att.Mult_RPM = 0.89
att.Mult_ShootVol = 0.8
--att.Mult_ShootPitch = 1.1 please don't

att.Override_PhysTracerProfile = 7
att.Override_TracerNum = 0

att.Mult_MalfunctionMean = 1.3
att.Override_PhysBulletMuzzleVelocity = 339
att.Override_PhysBulletMuzzleVelocity_Priority = 2
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_piercing.lua:
att.PrintName = "Armorpiercing Module"
att.Icon = Material("interfaz/armas/sw_piercingshot.png")
att.Description = "Higher damage and armor piercing at the cost of higher recoil and lower fire-ratio."
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_purple"
att.Override_Tracer = "tracer_purple"
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Mult_ShootPitch = 0.8
att.Reload = 1.1
att.Mult_Penetration = 1.2
att.Mult_DamageMin = 1.18
att.Mult_Recoil = 1.47
att.Mult_SightTime = 1.1
att.Mult_RPM = 0.57
att.Mult_Damage = 1.10
att.Mult_MuzzleVelocity = 1.36
--addons/arccw_weapons/lua/arccw/shared/attachments/gl_smoke.lua:
att.PrintName = "Grenade Launcher (Smoke)"
att.Icon = Material("interfaz/armas/sw_smokegrenade.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Smoke)"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_smoke", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_mag_dc15a_75mag.lua:
att.PrintName = "SW-Half Drum Magazine"
att.AbbrevName = "75-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Half Drum magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc15a_magazine_75"

att.Model = "models/weapons/arccw/atts/magazine/rt97c_mag_half.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, -90)
att.ModelOffset = Vector(4.2, 0, -0.33)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 75

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_mag_dc17m_85mag.lua:
att.PrintName = "SW-Extended Magazine"
att.AbbrevName = "85-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc17m_ext"

att.Model = "models/arccw/cs574/dc17m/dc17m_drummag.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, -90)
att.ModelOffset = Vector(-0.5, -6.9, -2.3)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 85

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--lua/arccw/shared/attachments/uc_40mm_dummy.lua:
att.PrintName = "40mm Dummy Grenades"
att.AbbrevName = "Dummy"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Non-lethal grenades with an empty ceramic shell.\nUsed for target practice, the grenade has a noticable trail and paints its impact point with blue chalk."
att.Desc_Pros = {
    "uc.infiniteammo"
}
att.Desc_Cons = {
    "uc.40mm.nodmg",
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.SortOrder = -9001

att.AutoStats = true

att.Override_ShootEntity = "arccw_uc_40mm_dummy"

att.ActivateElements = {"40mm_dummy"}

att.Mult_VisualRecoil = 0.5
att.Mult_Recoil = 0.5
att.Mult_ReloadTime = 0.8
att.Override_InfiniteAmmo = true
--lua/arccw/shared/attachments/uc_ammo_sg_bird.lua:
att.PrintName = "\"BIRD\" #9 Birdshot"

att.SortOrder = 4
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Hunting rounds with a wide spread and a very large number of pellets, designed to shoot birds out of the sky.
While not as lethal as buckshot, the loose clump spread makes it easier to hit small or multiple targets.]]
att.Desc_Pros = {
    "uc.pellet.2x"
}
att.Desc_Cons = {
    "uc.accuracy.20"
}
att.Desc_Neutrals = {
}
att.Slot = {"ud_ammo_shotgun", "uc_ammo"}

att.AutoStats = true

att.Mult_Num = 2
att.Mult_Damage = 0.85
att.Mult_DamageMin = 0.85
att.Mult_Recoil = 0.8

att.Add_AccuracyMOA = 20

att.Mult_HullSize = 0.1

att.Override_UC_ShellColor = Color(0.4 * 255, 0.6 * 255, 0.8 * 255)

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then
        return false
    end
end
--lua/arccw/shared/attachments/uc_ammo_sg_bird2.lua:
att.PrintName = "\"BIRD\" #9 Birdshot"

att.SortOrder = 4
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Hunting rounds with a wide spread and a very large number of pellets, designed to shoot birds out of the sky.
While not as lethal as buckshot, the loose clump spread makes it easier to hit small or multiple targets.]]
att.Desc_Pros = {
    "uc.pellet.8"
}
att.Desc_Cons = {
    "uc.accuracy.10"
}
att.Desc_Neutrals = {
}
att.Slot = {"ud_ammo_shotgun", "uc_ammo"}

att.InvAtt = "uc_ammo_sg_bird"

att.AutoStats = true

att.Add_Num = 8
att.Mult_Damage = 0.9
att.Mult_DamageMin = 0.9
att.Mult_Recoil = 0.8

att.Add_AccuracyMOA = 10

att.Override_UC_ShellColor = Color(0.4 * 255, 0.6 * 255, 0.8 * 255)

att.Hook_Compatible = function(wep)
    if !wep:GetBuff_Override("UC_Shotshell") then
        return false
    end
end
--lua/arccw/shared/attachments/uc_ammo_sg_slug.lua:
att.PrintName = "\"SLUG\" Full-Bore Slug"

att.SortOrder = 1
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[A single heavy projectile, comparable in performance to a high-caliber rifle cartridge at close to medium range.
Applicable in situations that require marksmanship and minimal collateral damage.]]
att.Desc_Pros = {
    "uc.penetration.8"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "uc.oneprojectile"
}
att.Slot = {"ud_ammo_shotgun","uc_ammo"}

att.AutoStats = true

att.Override_Num = 1
att.Override_Num_Priority = 2
att.Mult_Damage = .75
att.Mult_DamageMin = .5
att.Mult_AccuracyMOA = .3
att.Add_Penetration = 8
att.Mult_RangeMin = 2
att.Mult_Range = 2.5
att.Mult_HipDispersion = 2

att.Override_HullSize = 0
att.Override_DamageType = DMG_BULLET

att.Override_UC_ShellColor = Color(0.2 * 255, 0.45 * 255, 0.2 * 255)

att.GivesFlags = {"uc_slug"}

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell")  then
        return false
    end
end
--lua/arccw/shared/attachments/uc_fg_loosesprings.lua:
att.PrintName = "Loose Springs"

att.Icon = Material("entities/att/arccw_uc_loosesprings.png", "mpis smooth")
att.Description = "With help from some loose magazine springs, it is possible to stuff more ammo in a magazine than is usually recommended."
att.Desc_Pros = {
    "uc.loosesprings"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true

function att.Hook_GetCapacity(wep,cap)
    return math.max(cap + 1, math.floor(cap * 1.08))
end

att.Hook_Compatible = function(wep)
    if wep.RejectMagSizeChange or wep:GetCapacity() == 1 then return false end
end

att.Mult_RPM = .85
att.Mult_MalfunctionMean = 0.9
att.GivesFlags = {"ud_loosesprings"}
att.ExcludeFlags = {"ud_underload"}

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_muzzle_supp_ga9.lua:
att.PrintName = "GA9 Revolution 9 Suppressor"
att.AbbrevName = "GA9 Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_ga9.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nCompact and lightweight, with little impact on handling, but still lengthens profile more than other muzzle attachments."
att.Desc_Neutrals = {"uc.exclusive.pistol", "uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/uc_ga_revolution9.mdl"
att.ModelOffset = Vector(2.6, 0, 0)
att.ModelScale = Vector(1.15, 1.15, 1.15)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Range = 0.9

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.07
att.Mult_Sway = 1.1

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep,data)
    if !ArcCW.UC.PistolAmmoTypes[wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo)] then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_eotech553.lua:
att.PrintName = "EOTech 553 (HOLO)"
att.Icon = Material("entities/att/acwatt_uc_optic_eotech553.png", "mips smooth")
att.Description = "Tried-and-true sighting solution for close to medium ranges. Improves target acquisition with a highly precise circle-dot holographic reticle while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/atts/uc_gso_eotech.mdl"
att.ModelOffset = Vector(-0.5, 0, 0.05)
att.ModelScale = Vector(1.3, 1.3, 1.3)

att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.53),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/ud_holo.png", "smooth")
att.HolosightSize = 1.1
att.HolosightBone = "holosight"
att.HolosightNoFlare = true

att.Colorable = true

att.Mult_SightedSpeedMult = 0.9
--lua/arccw/shared/attachments/uc_tp_fastreload.lua:
att.PrintName = "Loading Drills"

att.Icon = Material("entities/att/arccw_uc_tp_loading_drills.png", "smooth mips")
att.Description = "Every second counts in the heat of battle. Repeated training drills allow you to reload your weapon more quickly."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 13

att.Mult_ReloadTime = 0.9

-- CS/GSO rapid reload OP

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_tp_fullstroke.lua:
att.PrintName = "Full Stroke"

att.Icon = Material("entities/att/arccw_uc_tp_full_stroke.png", "smooth mips")
att.Description = "Specialist training and a little extra gun oil allow you to cycle the action more quickly after a shot, improving your rate of fire."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 15

att.Mult_CycleTime = .9

att.Hook_Compatible = function(wep)
    if wep:GetBuff_Override("Override_ManualAction", wep.ManualAction) then return end
    for i, v in pairs(wep.Firemodes) do
        if !v then continue end
        if v.Mode and v.Override_ManualAction then
            return
        end
    end
    return false
end

att.NotForNPCs = true
--addons/arccw_base_modified/lua/arccw/shared/sh_vehicle.lua:
-- returns a table of entities to ignore (the player's vehicle)
function ArcCW:GetVehicleFilter(ply)
    if !ArcCW.ConVars["driveby"]:GetBool() or !IsValid(ply) or !ply:IsPlayer() then return {} end

    local tbl = {}
    local veh = ply:GetVehicle()

    if simfphys then
        -- gredwitch, why do you think it's a good idea to create the simfphys table yourself???
        -- people might need to do dependency checks, you know
        local car = ply.GetSimfphys and ply:GetSimfphys()
        if IsValid(car) then
            table.insert(tbl, car)
            if SERVER then
                table.insert(tbl, car.DriverSeat)
                for _, seat in ipairs(car.pSeat) do
                    table.insert(tbl, seat)
                    if IsValid(seat:GetDriver()) then
                        table.insert(tbl, seat:GetDriver())
                    end
                end
                table.Add(tbl, car.Wheels or {})
            else
                table.insert(tbl, veh) -- should be the pod
                -- client doesn't know what the wheels/passenger seats are
                -- iterate over all wheels and seats. inefficient, but its client so whatever
                for _, w in ipairs(ents.FindByClass("gmod_sent_vehicle_fphysics_wheel")) do
                    if w:GetBaseEnt() == car then
                        table.insert(tbl, w)
                    end
                end
                for _, s in ipairs(ents.FindByClass("prop_vehicle_prisoner_pod")) do
                    if s:GetParent() == car then
                        table.insert(tbl, s)
                        if IsValid(s:GetDriver()) then
                            table.insert(tbl, s:GetDriver())
                        end
                    end
                end
            end
        elseif IsValid(veh) then
            table.insert(tbl, veh)
        end
    elseif IsValid(veh) then
        table.insert(tbl, veh)
    end

    return tbl
end

-- returns a new source to fire from, this should be moved right outside the vehicle
-- since we can't ignore multiple entities in FireBullets, this is the only solution
function ArcCW:GetVehicleFireTrace(ply, src, dir)
    if !ArcCW.ConVars["driveby"]:GetBool() then return src end
    local tbl = ArcCW:GetVehicleFilter(ply)
    if table.IsEmpty(tbl) then return src end

    -- Make some traces from the outside to find a good spot
    local trace_dist = {256, 128, 64}
    for i = 1, #trace_dist do
        local tr = util.TraceLine({
            start = src + dir * trace_dist[i],
            endpos = src,
            ignoreworld = true,
            mask = MASK_SHOT
        })
        if IsValid(tr.Entity) and table.HasValue(tbl, tr.Entity) then
            return tr.HitPos + tr.HitNormal * 4
        end
    end
    return src
end
--addons/arccw_base_modified/lua/arccw/client/cl_convars.lua:
--[[
    ClientConVars table doc:
    name = data:
    def  - default value
    desc - description of var
    min  - minimum value
    max  - maximum value
    usri - userinfo
    save - whether to save (default true)
]]

ArcCW.ClientConVars = {
    ["arccw_bullet_imaginary"]        = { def = 1 },

    ["arccw_crosshair"]               = { def = 1 },
    ["arccw_crosshair_clr_r"]         = { def = 255 },
    ["arccw_crosshair_clr_g"]         = { def = 255 },
    ["arccw_crosshair_clr_b"]         = { def = 255 },
    ["arccw_crosshair_clr_a"]         = { def = 255 },
    ["arccw_crosshair_length"]        = { def = 4 },
    ["arccw_crosshair_thickness"]     = { def = 1 },
    ["arccw_crosshair_gap"]           = { def = 1 },
    ["arccw_crosshair_static"]        = { def = 0 },
    ["arccw_crosshair_clump"]         = { def = 0 },
    ["arccw_crosshair_clump_outline"] = { def = 0 },
    ["arccw_crosshair_clump_always"]  = { def = 0 },
    ["arccw_crosshair_outline"]       = { def = 2 },
    ["arccw_crosshair_outline_r"]     = { def = 0 },
    ["arccw_crosshair_outline_g"]     = { def = 0 },
    ["arccw_crosshair_outline_b"]     = { def = 0 },
    ["arccw_crosshair_outline_a"]     = { def = 255 },
    ["arccw_crosshair_dot"]           = { def =  1 },
    ["arccw_crosshair_shotgun"]       = { def =  1 },
    ["arccw_crosshair_equip"]         = { def =  1 },
    ["arccw_crosshair_aa"]            = { def =  1 },
    ["arccw_crosshair_trueaim"]       = { def =  0 },
    ["arccw_crosshair_prong_top"]     = { def =  1 },
    ["arccw_crosshair_prong_left"]    = { def =  1 },
    ["arccw_crosshair_prong_right"]   = { def =  1 },
    ["arccw_crosshair_prong_bottom"]  = { def =  1 },
    ["arccw_crosshair_tilt"]    = { def =  0 },

    ["arccw_attinv_simpleproscons"]   = { def =  0 },
    ["arccw_attinv_onlyinspect"]      = { def =  0 },
    ["arccw_attinv_hideunowned"]      = { def =  0 },
    ["arccw_attinv_darkunowned"]      = { def =  0 },
    ["arccw_attinv_closeonhurt"]      = { def =  0, usri = true },
    ["arccw_attinv_gamemodebuttons"]  = { def =  1 },

    ["arccw_language"]                = { def =  "", usri = true },
    ["arccw_font"]                    = { def =  "", usri = true },
    ["arccw_ammonames"]               = { def =  0 },

    ["arccw_cheapscopes"]             = { def =  1 },
    ["arccw_cheapscopesv2_ratio"]     = { def =  0.05 },
    ["arccw_scopepp"]                 = { def =  1 },
    ["arccw_thermalpp"]               = { def =  1 },
    ["arccw_scopepp_refract"]         = { def =  0 },
    ["arccw_scopepp_refract_ratio"]   = { def =  0.75 },

    ["arccw_cheapscopesautoconfig"]   = { def =  0 }, -- what this for

    --["arccw_flatscopes"]              = { def = 0 },

    ["arccw_shake"]                   = { def =  1 },
    ["arccw_shakevm"]                 = { def =  1 },
    ["arccw_muzzleeffects"]           = { def =  1 },
    ["arccw_shelleffects"]            = { def =  1 },
    ["arccw_shelltime"]               = { def =  0 },
    ["arccw_att_showothers"]          = { def =  1 },
    ["arccw_att_showground"]          = { def =  1 },
    ["arccw_visibility"]              = { def =  8000 },
    ["arccw_fastmuzzles"]             = { def =  0 },
    ["arccw_fasttracers"]             = { def =  0 },

    ["arccw_2d3d"]                    = { def =  1, min = 0, max = 2},

    ["arccw_hud_3dfun"]               = { def =  0, usri = true },
    ["arccw_hud_3dfun_lite"]          = { def =  0 },
    ["arccw_hud_3dfun_ammotype"]      = { def =  0 },
    ["arccw_hud_forceshow"]           = { def =  0 },
    ["arccw_hud_fcgbars"]             = { def =  1, desc = "Draw firemode bars on ammo HUD." },
    ["arccw_hud_fcgabbrev"]           = { def =  0, desc = "Use shortened firemode names."},
    ["arccw_hud_minimal"]             = { def =  1, desc = "Backup HUD if we cannot draw the ammo HUD." },
    ["arccw_hud_embracetradition"]    = { def =  0, desc = "Use the classic customization HUD." },
    ["arccw_hud_deadzone_x"]          = { def =  0 },
    ["arccw_hud_deadzone_y"]          = { def =  0 },
    ["arccw_hud_3dfun_decaytime"]     = { def =  3 },
    ["arccw_hud_3dfun_right"]         = { def =  2 },
    ["arccw_hud_3dfun_up"]            = { def =  1 },
    ["arccw_hud_3dfun_forward"]       = { def =  0 },
    ["arccw_hud_size"]                = { def =  1 },

    ["arccw_cust_sounds"]             = { def =  1, desc = "Play sounds when opening and closing the customization menu." },

    ["arccw_scope_r"]                 = { def =  255 },
    ["arccw_scope_g"]                 = { def =  0 },
    ["arccw_scope_b"]                 = { def =  0 },

    ["arccw_blur"]                    = { def =  0 },
    ["arccw_blur_toytown"]            = { def =  1 },

    ["arccw_adjustsensthreshold"]     = { def =  0 },

    ["arccw_drawbarrel"]              = { def =  0 },

    ["arccw_glare"]                   = { def =  1 },
    ["arccw_autosave"]                = { def =  1 },

    ["arccw_vm_right"]                = { def =  0 },
    ["arccw_vm_up"]                   = { def =  0 },
    ["arccw_vm_forward"]              = { def =  0 },
    ["arccw_vm_pitch"]                = { def =  0 },
    ["arccw_vm_yaw"]                  = { def =  0 },
    ["arccw_vm_roll"]                 = { def =  0 },
    ["arccw_vm_fov"]                  = { def =  0, usri = true },
    ["arccw_vm_add_ads"]              = { def =  0},
    ["arccw_vm_coolsway"]             = { def =  1 },
    ["arccw_vm_coolview"]             = { def =  1 },
    ["arccw_vm_coolview_mult"]        = { def =  1 },
    ["arccw_vm_look_xmult"]           = { def =  1 },
    ["arccw_vm_look_ymult"]           = { def =  1 },
    ["arccw_vm_sway_xmult"]           = { def =  1 },
    ["arccw_vm_sway_ymult"]           = { def =  1 },
    ["arccw_vm_sway_zmult"]           = { def =  1 },

    ["arccw_vm_sway_speedmult"]       = { def =  1 },
    ["arccw_vm_nearwall"]             = { def =  1 },

    ["arccw_toggleads"]               = { def = 0, usri = true },
    ["arccw_altbindsonly"]            = { def = 0, usri = true },
    ["arccw_altsafety"]               = { def = 0, usri = true },
    ["arccw_automaticreload"]         = { def = 0, usri = true },

    ["arccw_nohl2flash"]              = { def = 0, usri = true },

    ["arccw_aimassist_cl"]            = { def = 0, usri = true },

    ["arccw_dev_benchgun"]            = { def = 0, save = false },
    ["arccw_dev_benchgun_custom"]     = { def = "", save = false },

    ["arccw_dev_removeonclose"]       = { def = 0, desc = "Remove the hud when closing instead of fading out, allowing easy reloading of the hud.", save = false },
    ["arccw_noinspect"]               = { def = 0, usri = true },

    ["arccw_dev_crosshair"]           = { def = 0, save = false },
}

for name, data in pairs(ArcCW.ClientConVars) do
    ArcCW.ConVars[string.sub(name, 7)] = CreateClientConVar(name, data.def, data.save == nil and true or data.save, data.usri or false, data.desc, data.min, data.max)
end

-- CreateClientConVar("arccw_quicknade", KEY_G)

--addons/arccw_base_modified/lua/arccw/client/cl_warnings.lua:
ArcCW.IncompatibleAddons = {
    -- My Hands 8.1
    ["847269692"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",

    -- My Hands 8
    ["1890577397"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",

    -- Quick Weapon Menu
    ["306149085"] = "Makes the customize menu mouse unable to appear.",

    -- Neurotec
    ["541434990"] = "Neurotec is ancient, half the base is missing, and it flat-out doesn't work. Causes all sorts of problems. For the love of god, let go.",

    -- Improved Combine NPCs
    ["476997621"] = "Causes issues with arms.",

    -- Realistic Bullet Overhaul
    ["1588705429"] = "Causes damage calculation to not work properly.",

    -- Quake/Half Life View bobbing
    ["378401390"] = "Causes most animations to not play properly.",

    -- Thirteen's Physgun Glow
    ["111249028"] = "Causes LHIK animations to flicker and not work properly.",

    -- Viewmodel Lagger
    ["1146104662"] = "Misaligns viewmodel in sights.",

    -- Viewmodel Lagger (fixed)
    ["2566560460"] = "Misaligns viewmodel in sights.",

    -- VTools
    ["DisplayDistancePlane"] = "Tool contains faulty hook, which has been removed to keep ArcCW functional.",
}

local t = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

function ArcCW.MakeIncompatibleWindow(tbl)
    local startTime = CurTime()

    local window = vgui.Create( "DFrame" )
    window:SetSize( ScrW() * 0.6, ScrH() * 0.6)
    window:Center()
    window:SetTitle("")
    window:SetDraggable(false)
    window:SetVisible(true)
    window:ShowCloseButton(false)
    window:MakePopup()
    window.Paint = function(self, w, h)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, w, h)
    end

    local title = vgui.Create("DLabel", window)
    title:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    title:Dock(TOP)
    title:SetFont("ArcCW_24")
    title:SetText(t("incompatible.title"))
    title:DockMargin(ScreenScaleMulti(16), 0, ScreenScaleMulti(16), ScreenScaleMulti(8))

    local desc = vgui.Create("DLabel", window)
    desc:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc:Dock(TOP)
    desc:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), 0)
    desc:SetFont("ArcCW_12")
    desc:SetText(t("incompatible.line1"))
    desc:SetContentAlignment(5)

    local desc2 = vgui.Create("DLabel", window)
    desc2:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc2:Dock(TOP)
    desc2:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), ScreenScaleMulti(4))
    desc2:SetFont("ArcCW_12")
    desc2:SetText(t("incompatible.line2"))
    desc2:SetContentAlignment(5)

    local neverAgain = vgui.Create("DButton", window)
    neverAgain:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    neverAgain:SetText("")
    neverAgain:Dock(BOTTOM)
    neverAgain:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    neverAgain.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 10 then
            local simpleTbl = {}
            for _, v in pairs(tbl) do simpleTbl[tostring(v.wsid)] = true end
            file.Write("arccw_incompatible.txt", util.TableToJSON(simpleTbl))
            window:Close()
            window:Remove()
            chat.AddText(Color(255,0,0),t("incompatible.never.confirm"))
        end
    end
    neverAgain.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 10 and spaa:IsHovered() then
            Bbg_col = Color(255, 100, 100, 100)
            Bfg_col = Color(255, 255, 255, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (CurTime() > startTime + 10) and (spaa:IsHovered() and t("incompatible.never.hover") or t("incompatible.never")) or t("incompatible.wait", {time = math.ceil(startTime + 10 - CurTime())})
        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local addonList = vgui.Create("DScrollPanel", window)
    addonList:SetText("")
    addonList:Dock(FILL)
    addonList.Paint = function(span, w, h) end
    local sbar = addonList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end
    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, w, h)
    end


    local accept = vgui.Create("DButton", window)
    accept:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    accept:SetText("")
    accept:Dock(BOTTOM)
    accept:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    accept.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 5 then
            window:Close()
            window:Remove()
        end
    end
    accept.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 5 and spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = t("incompatible.confirm") .. ((CurTime() > startTime + 5) and "" or (" - " .. t("incompatible.wait", {time = math.ceil(startTime + 5 - CurTime())})))
        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    for _, addon in pairs(tbl) do
        local addonBtn = vgui.Create("DButton", window)
        addonBtn:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(28))
        addonBtn:Dock(TOP)
        addonBtn:DockMargin(ScreenScaleMulti(36), ScreenScaleMulti(2), ScreenScaleMulti(36), ScreenScaleMulti(2))
        addonBtn:SetFont("ArcCW_12")
        addonBtn:SetText("")
        addonBtn:SetContentAlignment(5)
        addonBtn.Paint = function(spaa, w, h)
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 200)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = addon.title
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(2))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)

            local txt2 = ArcCW.IncompatibleAddons[tostring(addon.wsid)]
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(16))
            surface.SetFont("ArcCW_8")
            surface.DrawText(txt2)
        end
        addonBtn.OnMousePressed = function(spaa, kc)
            if addon.nourl then return end
            gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. tostring(addon.wsid))
        end
    end
end

hook.Add("InitPostEntity", "ArcCW_CheckContent", function()
    for _, k in pairs(weapons.GetList()) do
        if weapons.IsBasedOn(k.ClassName, "arccw_base") and k.ClassName != "arccw_base" then
            return
        end
    end
    chat.AddText(Color(255,255,255), "You have installed the ArcCW base but have no weapons installed. Search the workshop for some!") -- Perhaps you want to install the CS+ pack?")
    --chat.AddText(Color(255,255,255), "https://steamcommunity.com/sharedfiles/filedetails/?id=2131058270")
end)
--addons/sh_lounge_chatbox/lua/chatbox/cl_colors.lua:
LOUNGE_CHAT.Colors = {
	aliceblue = "F0F8FF",
	antiquewhite = "FAEBD7",
	aqua = "00FFFF",
	aquamarine = "7FFFD4",
	azure = "F0FFFF",
	beige = "F5F5DC",
	bisque = "FFE4C4",
	black = "000000",
	blanchedalmond = "FFEBCD",
	blue = "0000FF",
	blueviolet = "8A2BE2",
	brown = "A52A2A",
	burlywood = "DEB887",
	cadetblue = "5F9EA0",
	chartreuse = "7FFF00",
	chocolate = "D2691E",
	coral = "FF7F50",
	cornflowerblue = "6495ED",
	cornsilk = "FFF8DC",
	crimson = "DC143C",
	cyan = "00FFFF",
	darkblue = "00008B",
	darkcyan = "008B8B",
	darkgoldenrod = "B8860B",
	darkgray = "A9A9A9",
	darkgreen = "006400",
	darkgrey = "A9A9A9",
	darkkhaki = "BDB76B",
	darkmagenta = "8B008B",
	darkolivegreen = "556B2F",
	darkorange = "FF8C00",
	darkorchid = "9932CC",
	darkred = "8B0000",
	darksalmon = "E9967A",
	darkseagreen = "8FBC8F",
	darkslateblue = "483D8B",
	darkslategray = "2F4F4F",
	darkslategrey = "2F4F4F",
	darkturquoise = "00CED1",
	darkviolet = "9400D3",
	deeppink = "FF1493",
	deepskyblue = "00BFFF",
	dimgray = "696969",
	dimgrey = "696969",
	dodgerblue = "1E90FF",
	firebrick = "B22222",
	floralwhite = "FFFAF0",
	forestgreen = "228B22",
	fuchsia = "FF00FF",
	gainsboro = "DCDCDC",
	ghostwhite = "F8F8FF",
	gold = "FFD700",
	goldenrod = "DAA520",
	gray = "808080",
	green = "008000",
	greenyellow = "ADFF2F",
	grey = "808080",
	honeydew = "F0FFF0",
	hotpink = "FF69B4",
	indianred = "CD5C5C",
	indigo = "4B0082",
	ivory = "FFFFF0",
	khaki = "F0E68C",
	lavender = "E6E6FA",
	lavenderblush = "FFF0F5",
	lawngreen = "7CFC00",
	lemonchiffon = "FFFACD",
	lightblue = "ADD8E6",
	lightcoral = "F08080",
	lightcyan = "E0FFFF",
	lightgoldenrodyellow = "FAFAD2",
	lightgray = "D3D3D3",
	lightgreen = "90EE90",
	lightgrey = "D3D3D3",
	lightpink = "FFB6C1",
	lightsalmon = "FFA07A",
	lightseagreen = "20B2AA",
	lightskyblue = "87CEFA",
	lightslategray = "778899",
	lightslategrey = "778899",
	lightsteelblue = "B0C4DE",
	lightyellow = "FFFFE0",
	lime = "00FF00",
	limegreen = "32CD32",
	linen = "FAF0E6",
	magenta = "FF00FF",
	maroon = "800000",
	mediumaquamarine = "66CDAA",
	mediumblue = "0000CD",
	mediumorchid = "BA55D3",
	mediumpurple = "9370DB",
	mediumseagreen = "3CB371",
	mediumslateblue = "7B68EE",
	mediumspringgreen = "00FA9A",
	mediumturquoise = "48D1CC",
	mediumvioletred = "C71585",
	midnightblue = "191970",
	mintcream = "F5FFFA",
	mistyrose = "FFE4E1",
	moccasin = "FFE4B5",
	navajowhite = "FFDEAD",
	navy = "000080",
	oldlace = "FDF5E6",
	olive = "808000",
	olivedrab = "6B8E23",
	orange = "FFA500",
	orangered = "FF4500",
	orchid = "DA70D6",
	palegoldenrod = "EEE8AA",
	palegreen = "98FB98",
	paleturquoise = "AFEEEE",
	palevioletred = "DB7093",
	papayawhip = "FFEFD5",
	peachpuff = "FFDAB9",
	peru = "CD853F",
	pink = "FFC0CB",
	plum = "DDA0DD",
	powderblue = "B0E0E6",
	purple = "800080",
	rebeccapurple = "663399",
	red = "FF0000",
	rosybrown = "BC8F8F",
	royalblue = "4169E1",
	saddlebrown = "8B4513",
	salmon = "FA8072",
	sandybrown = "F4A460",
	seagreen = "2E8B57",
	seashell = "FFF5EE",
	sienna = "A0522D",
	silver = "C0C0C0",
	skyblue = "87CEEB",
	slateblue = "6A5ACD",
	slategray = "708090",
	slategrey = "708090",
	snow = "FFFAFA",
	springgreen = "00FF7F",
	steelblue = "4682B4",
	tan = "D2B48C",
	teal = "008080",
	thistle = "D8BFD8",
	tomato = "FF6347",
	turquoise = "40E0D0",
	violet = "EE82EE",
	wheat = "F5DEB3",
	white = "FFFFFF",
	whitesmoke = "F5F5F5",
	yellow = "FFFF00",
	yellowgreen = "9ACD32",
}
--addons/gm_express/lua/includes/modules/sfs.lua:
-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil and ((tbl_len == 1 and next(tbl) == 1) or (tbl_len > 1 and next(tbl, tbl_len - 1) == tbl_len)) then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

_G.sfs = {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.3"
}

--addons/aocrp_map/lua/gmaps/cl_zslider.lua:

local PNL = {}
function PNL:Init()
	self:SetLockX(.5)
	self:SetLockY(nil)
	self:SetSize(21,100)
	
	self.Knob.Paint = function() end
end

function PNL:OnMouseWheeled(d)

	local h = self:GetTall()
	local ih = self.Knob:GetTall()
	h = h - ih
	
	local y = math.Clamp(self:GetSlideY()*h-d*4, ih/2, h-ih/2)/h
	self:SetSlideY(y)
	
	self:OnUpdate(y)
end

function PNL:OnCursorMoved( x, y )

	if ( !self.Dragging && !self.Knob.Depressed ) then return end
	
	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()
	
	if ( self.m_bTrappedInside ) then
	
		w = w - iw
		h = h - ih
		
		x = x - iw * 0.5
		y = y - ih * 0.5
	
	end
	
	x = math.Clamp( x, 0, w ) / w
	y = math.Clamp( y, 0, h ) / h
	
	if ( self.m_iLockX ) then x = self.m_iLockX end
	if ( self.m_iLockY ) then y = self.m_iLockY end
	
	x, y = self:TranslateValues( x, y )
	
	self:SetSlideX( x )
	self:SetSlideY( y )
	
	self:InvalidateLayout()
	
	self:OnUpdate(y)
	
end

function PNL:SetSlideY(new)
	local h, ih = self:GetTall(), self.Knob:GetTall()
	new = math.Clamp(new*h, ih/2+2, h-ih/2-2)/h
	self.m_fSlideY = new
	self:InvalidateLayout()
end

function PNL:OnUpdate(y)
	
end

function PNL:TranslateValues(x,y)
	local h = self:GetTall()
	local ih = self.Knob:GetTall()/2
	return x, math.Clamp(y*h,ih,h-ih)/h
end

local blur = Material("pp/blurscreen");
local bc = color_black;
local lev = 6;
function PNL:Paint(w,h)
	
	//Draw blur
	local x, y = self:LocalToScreen(0, 0);
	surface.SetDrawColor(color_white);
	surface.SetMaterial(blur);

	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * lev);
		blur:Recompute();

		render.UpdateScreenEffectTexture();
		surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH());
	end

	surface.SetDrawColor(bc);
	surface.DrawOutlinedRect(0, 0, w, h);
	
	
	//Draw ticks
	surface.SetDrawColor(gmaps.Teal)
	-- surface.DrawRect(w/2-1,0,1,h-2)
	surface.DrawLine(w/2,1,w/2,h-1)
	
	for i=10, h-2, 10 do
		surface.DrawRect(4,i,w-8,1)
	end
	
	//Manual Paint Knob
	local panel = self.Knob
	local x1,y1 = panel:GetPos()
	local w1,h1 = panel:GetSize()
	
	draw.NoTexture()
	if ( panel:GetDisabled() ) then	
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2), Color(0,0,0), 2)
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2)-1, Color(40,40,40), 2)
	elseif ( panel.Depressed ) then
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2), Color(0,0,0), 2)
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2)-1, Color(100,210,255), 2)
	elseif ( panel.Hovered ) then
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2), Color(0,0,0), 2)
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2)-1, Color(255,255,255), 2)
	else //normal:
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2), Color(0,0,0), 2)
		gmaps.Circle(x1+w1/2, y1+h1/2, math.Round(w1/2)-1, Color(230,230,230), 2)
	end
	
	
	
end

vgui.Register("ZSlider",PNL,"DSlider")
--addons/billy_gas/lua/gmodadminsuite/thirdparty/spon.lua:
--           -- COPYRIGHT HEADER --
-- spon2.lua 1.0.0 by thelastpenguin
-- Copyright 2016 Gareth George
--                aka thelastpenguin
--
-- GitHub release: https://github.com/thelastpenguin/spon
--
-- You may use this in any purpose / include it in any project so long as the
-- following conditions are met:
--    - You do not remove this copyright notice
--    - You don't claim this to be your own
--    - You properly credit the author (thelastpenguin aka gareth george) if you publish your work
--      based on (and/or using) this.
--
-- If you modify this code in any way this copyright still applies to the modifications or any
-- derived pieces of code
--
-- The author may not be held responsibile for any damages or losses directly or indirectly caused
-- by the use of spon
-- If you disagree with any of these limitations you're free not to use the code!
--
--
--
--           -- COMPATABILITY MODE --
-- compatability with alternative encoders:
--    - util.TableFromJSON
--    - von by Vericas https://github.com/vercas/vON/blob/master/von.lua
--    - pon1 by thelastpenguin https://github.com/thelastpenguin/gLUA-Library/blob/master/pON/pON-recommended.lua
--
--           -- DATA TYPES --
-- All of the following data types are supported as both keys and values
-- References are preserved i.e. if the same object appears twice it will be encoded as the same object
-- Cycles will not result in infinite recursion
--
-- Data Types:
--    - boolean
--    - numbers (integers, floats)
--    - strings
--    - table
--    - nil

if SERVER then AddCSLuaFile() end

-- localized variable optimization
local select = select
local format_string = string.format
local concat = table.concat
local len = string.len
local string_find = string.find
local string_sub = string.sub
local tonumber = tonumber
local tostring = tostring
local math_log = math.log
local math_ceil = math.ceil
local next = next
local ipairs = ipairs
local pairs = pairs
local Angle = Angle
local Vector = Vector

-- the global table for the encoder
local spon = {}
--if _G then _G.spon = spon end

--
-- caches
--

local hex_cache = {} for i = 0, 15 do hex_cache[format_string('%x', i)] = i end

local cache = {}
local cache_size = 0
local output_buffer = setmetatable({}, {__mode = 'v'})

local function empty_cache(hashy, a)
	cache_size = 0
	for k,v in pairs(hashy) do hashy[k] = nil end
	return a
end

local function empty_output_buffer(buffer, a)
	for k,v in ipairs(buffer) do buffer[k] = nil end
	return a
end

--
-- COMPATABILITY MODES
--

local compatability = {}
if true then -- you can re-enable this in your version if you so desire.
	do
		local function safeload(lib) local _, a = pcall(require, lib) if not _ then return nil else return a end end

		-- von compatability
		--_G.von = _G.von or safeload('von')
		--if von and von.serialize then compatability.vonDeserialize = von.deserialize end

		-- pon compatability
		_G.pon = spon.pon or _G.pon or safeload('pon')
		if pon and pon.decode then compatability.ponDecode = pon.decode end

		-- json compatability
		if util and util.JSONToTable then compatability.JSONToTable = util.JSONToTable end
	end
end 
--
-- ENCODER FUNCTIONS
--

local encoder = {}

local log16 = math_log(16)

local function encoder_write_pointer(index)
	return format_string('@%x%x', math_ceil(math_log(index + 1) / log16), index)
end

encoder['number'] = function(value, output, index)
	if value % 1 == 0 then
		if value == 0 then
			output[index] = 'I0'
		elseif value < 0 then
			output[index] = format_string('i%x%x', math_ceil(math_log(-value+1) / (log16)), -value)
		else
			output[index] = format_string('I%x%x', math_ceil(math_log(value+1) / (log16)), value)
		end
	else
		output[index] = 'd' .. tostring(value) .. 'd' -- use a base10 tostring representation if it has decimals
	end

	return index + 1
end
local encode_number = encoder['number']

encoder['string'] = function(value, output, index)
	if cache[value] then
		output[index] = encoder_write_pointer(cache[value])
	end
	cache_size = cache_size + 1
	cache[value] = cache_size

	local len = len(value)
	if len >= 16 * 16 then
		output[index] = format_string('T%06X%s', len, value)
	else
		output[index] = format_string('S%02X%s', len, value)
	end
	return index + 1
end

encoder['boolean'] = function(value, output, index)
	output[index] = value and 't' or 'f'
	return index + 1
end

encoder['table'] = function(value, output, index)
	if cache[value] then
		output[index] = encoder_write_pointer(cache[value])
		return index + 1
	end

	-- update the cache
	cache_size = cache_size + 1
	cache[value] = cache_size

	local table_size = #value
	local has_kv_component = next(value, table_size ~= 0 and table_size or nil)

	if table_size > 0 then
		if has_kv_component then
			output[index] = '('
		else
			output[index] = '<'
		end

		index = index + 1

		for k,v in ipairs(value) do
			index = encoder[type(v)](v, output, index)
		end

		if has_kv_component then
			output[index] = '~'
			index = index + 1
		else
			output[index] = '>'
			return index + 1
		end
	else
		output[index] = '['
		index = index + 1
	end

	for k,v in next, value, (table_size ~= 0 and table_size or nil) do
		index = encoder[type(k)](k, output, index)
		index = encoder[type(v)](v, output, index)
	end

	output[index] = ')'

	return index + 1 --fast_concat_stack(fast_concat_stack('{', encode_sequential(1, value, 0)))
end

encoder['nil'] = function(value, output, index)
	output[index] = '-'
	return index + 1
end

-- gmod specific
if IsValid and FindMetaTable then
	local IsValid = IsValid
	local FindMetaTable = FindMetaTable
	local EntIndex = FindMetaTable('Entity').EntIndex

	encoder['Vector'] = function(value, output, index)
		output[index] = 'V'
		index = encode_number(value.x, output, index + 1)
		index = encode_number(value.y, output, index)
		return encode_number(value.z, output, index)
	end

	encoder['Angle'] = function(value, output, index)
		output[index] = 'A'
		index = encode_number(value.p, output, index + 1)
		index = encode_number(value.y, output, index)
		return encode_number(value.r, output, index)
	end

	encoder['Entity'] = function(value, output, index)
		if IsValid(value) then
			output[index] = 'E'
			return encode_number(EntIndex(value), output, index + 1)
		else
			return '#'
		end
	end

	encoder['Player']  = encoder['Entity']
	encoder['Vehicle'] = encoder['Entity']
	encoder['Weapon']  = encoder['Entity']
	encoder['NPC']     = encoder['Entity']
	encoder['NextBot'] = encoder['Entity']

end

local decoder = {}
-- a short string with a 2-digit length component
decoder['S'] = function(str, index, cache)
	local strlen = tonumber(string_sub(str, index + 1, index + 2), 16)
	local str = string_sub(str, index + 3, index + (3 - 1) + strlen)
	cache_size = cache_size + 1
	cache[cache_size] = str
	return str, index + (3) + strlen
end
-- a long string with a 6-digit length component
decoder['T'] = function(str, index, cache)
	local strlen = tonumber(string_sub(str, index + 1, index + 6), 16)
	return string_sub(str, index + 7, index + (7 - 1) + strlen), index + (7) + strlen -- figure out if alignment is off i think its right
end
-- decoder for an integer value
decoder['I'] = function(str, index, cache)
	local digitCount = hex_cache[string_sub(str, index+1, index+1)]
	if digitCount == 0 then return 0, index + 2 end
	return tonumber(string_sub(str, index + 2, index + 1 + digitCount), 16), index + (2 + digitCount)
end
decoder['i'] = function(str, index, cache)
	local digitCount = hex_cache[string_sub(str, index+1, index+1)]
	if digitCount == 0 then return 0, index + 2 end
	return -tonumber(string_sub(str, index + 2, index + 1 + digitCount), 16), index + (2 + digitCount)
end

decoder['d'] = function(str, index, cache)
	local build_base_10 = ""
	for i=index+1,#str do
		if (str[i] == 'd') then break end
		build_base_10 = build_base_10 .. str[i]
	end
	return tonumber(build_base_10), index + #build_base_10 + 2
end

-- decoder for a boolean
decoder['t'] = function(str, index) return true, index + 1 end
decoder['f'] = function(str, index) return false, index + 1 end
decoder['@'] = function(str, index)
	local digitCount = hex_cache[string_sub(str, index+1, index+1)]
	return cache[tonumber(string_sub(str, index + 2, index + 1 + digitCount), 16)], index + (2 + digitCount)
end

decoder['A'] = function(str, index)
	local p, y, r, char

	-- Skip prefix 'A', go to first property
	char = string_sub(str, index + 1, index + 1)
	p, index = decoder[char](str, index + 1)

	char = string_sub(str, index, index)
	y, index = decoder[char](str, index)

	char = string_sub(str, index, index)
	r, index = decoder[char](str, index)

	return Angle(p, y, r), index
end

decoder['V'] = function(str, index)
	local x, y, z, char

	-- Skip prefix 'V', go to first property
	char = string_sub(str, index + 1, index + 1)
	x, index = decoder[char](str, index + 1)

	char = string_sub(str, index, index)
	y, index = decoder[char](str, index)

	char = string_sub(str, index, index)
	z, index = decoder[char](str, index)

	return Vector(x, y, z), index
end

decoder['E'] = function(str, index)
	local entid, char

	-- Skip prefix 'E', go to entity index
	char = string_sub(str, index + 1, index + 1)
	entid, index = decoder[char](str, index + 1)

	return Entity(entid), index
end

decoder['('] = function(str, index)
	local table = {}
	cache_size = cache_size + 1
	cache[cache_size] = table

	index = index + 1

	-- decode the array portion of the table
	local i = 1
	while true do
		local c = string_sub(str, index, index)
		if c == '~' or c == ')' or c == nil then break end
		table[i], index = decoder[c](str, index, cache)
		i = i + 1
	end

	if string_sub(str, index, index) == '~' then
		-- decode the key-value poriton of the table
		index = index + 1
		local k
		while true do
			local c = string_sub(str, index, index)
			if c == ')' or c == nil then break end
			k, index = decoder[c](str, index, cache)
			c = string_sub(str, index, index)
			table[k], index = decoder[c](str, index, cache)
		end
	end

	return table, index + 1
end

decoder['['] = function(str, index)
	local table = {}
	cache_size = cache_size + 1
	cache[cache_size] = table

	-- decode the key-value poriton of the table
	index = index + 1
	local k
	while true do
		local c = string_sub(str, index, index)
		if c == ')' or c == nil then break end
		k, index = decoder[c](str, index, cache)
		c = string_sub(str, index, index)
		table[k], index = decoder[c](str, index, cache)
	end

	return table, index + 1
end

decoder['<'] = function(str, index)
	local table = {}
	cache_size = cache_size + 1
	cache[cache_size] = table

	index = index + 1

	-- decode the array portion of the table
	local i = 1
	while true do
		local c = string_sub(str, index, index)
		if c == '>' or c == nil then break end
		table[i], index = decoder[c](str, index, cache)
		i = i + 1
	end

	return table, index + 1
end

decoder['-'] = function(str, index)
	return nil, index + 1
end


spon.encode = function(table)
	-- encoding its simple
	empty_output_buffer(output_buffer)
	empty_cache(cache)
	encoder.table(table, output_buffer, 1)
	return concat(output_buffer)
end

spon.decode = function(str)
	empty_cache(cache)

	local firstChar = string_sub(str, 1, 1)
	local decoderFunc = decoder[firstChar]

	if spon.noCompat then
		return  decoderFunc(str, 1)
	end

	if not decoderFunc then
		return spon._decodeInCompatabilityMode(str, 'did not find a decoder function to handle the string beginning with \''..tostring(firstChar)..'\'')
	end

	local succ, val = pcall(decoderFunc, str, 1)
	if succ then return val end

	return spon._decodeInCompatabilityMode(str, 'spon encountered error: ' .. tostring(val))
end

spon._decodeInCompatabilityMode = function(str, message)
	local firstChar = string_sub(str, 1, 1)
	if firstChar == '{' then
		message = message .. '\nthis looks like it may be a pon1 encoded object, please make sure you have pon1 installed for compatability mode to work with it'
	end
	for k, decoder in pairs(compatability) do
		local succ, val = pcall(decoder, str)
		if succ then return val end
		message = message .. '\ntrying decoder: ' .. k .. '\n\terror: ' .. tostring(val)
	end
	error('[spon] failed to decode string and was unable to resolve the problem in compatability mode!\n' .. message .. '\n\nthe encoded object: ' .. tostring(str:sub(1, 100)))
end

spon.printtable = function(tbl, indent, cache) -- debug utility
	if indent == nil then
		return spon.printtable(tbl, 0, {})
	end
	if cache[tbl] then return end
	cache[tbl] = true
	local lpad = string.format('%'..indent..'s', '')

	for k,v in pairs(tbl) do
		print(lpad .. '- ' .. string_sub(type(k), 1, 1) .. ':' .. tostring(k) .. ' = ' .. string_sub(type(v), 1, 1) .. ':' .. tostring(v))
		if type(v) == 'table' then
			spon.printtable(v, indent + 4, cache)
		end
	end
end

-- todo: finish writing entity, angle, vector decoders

return spon
--addons/billy_gas/lua/gmodadminsuite/sh_language.lua:
local function GmodLanguage(module_name)
	if (SERVER) then return "english" end
	local lang = GetConVar("gmod_language"):GetString()
	if (lang == "en") then return "english" end
	local module_name = module_name or "GAS"
	for lang_name, data in pairs(GAS.Languages.LanguageData[module_name]) do
		if (data.Flag == "flags16/" .. lang .. ".png") then
			return lang_name
		end
	end
	return "english"
end

GAS.Languages = {}

GAS.Languages.DefaultConfig = {
	SelectedLanguages = {},
	ShortDateFormat = false,
	LongDateFormat = false,
}

if (CLIENT) then
	GAS.Languages.Config = GAS:GetLocalConfig("languages", GAS.Languages.DefaultConfig)
else
	GAS.Languages.Config = table.Copy(GAS.Languages.DefaultConfig)
end

--######## LOAD LANGUAGE DATA ########--

GAS.Languages.LanguageData = {GAS = {}}

function GAS.Languages:LoadLanguageData()
	local languages = file.Find("gmodadminsuite/lang/*.lua", "LUA")
	for _,f in ipairs(languages) do
		local filename = (f:gsub("%.lua$",""))
		GAS.Languages.LanguageData["GAS"][filename] = include("gmodadminsuite/lang/" .. f)
		if (filename == "english" or GAS.Languages.Config.SelectedLanguages.GAS == filename) then
			GAS.Languages.LanguageData["GAS"][filename].Phrases = GAS.Languages.LanguageData["GAS"][filename].Phrases()
		end
	end

	local _,modules = file.Find("gmodadminsuite/modules/*", "LUA")
	for _,module in ipairs(modules) do
		local languages = file.Find("gmodadminsuite/modules/" .. module .. "/lang/*.lua", "LUA")
		if (#languages > 0) then
			GAS.Languages.LanguageData[module] = {}
			for _,f in ipairs(languages) do
				local filename = (f:gsub("%.lua$",""))
				GAS.Languages.LanguageData[module][filename] = include("gmodadminsuite/modules/" .. module .. "/lang/" .. f)
				if (filename == "english" or GAS.Languages.Config.SelectedLanguages[module] == filename) then
					GAS.Languages.LanguageData[module][filename].Phrases = GAS.Languages.LanguageData[module][filename].Phrases()
				end
			end
		end
	end
end
GAS.Languages:LoadLanguageData()

if (GAS.Languages.Config.SelectedLanguages.GAS == nil) then
	GAS.Languages.Config.SelectedLanguages.GAS = GmodLanguage()
end

--######## LANGUAGE FUNCTIONS ########--

function GAS.Languages:LanguageExists(language_name, module_name)
	return GAS.Languages.LanguageData[module_name or "GAS"][language_name] ~= nil
end

function GAS.Languages:GetSelectedLanguage(module_name)
	if (SERVER) then return "english" end
	if (not module_name) then
		if (GAS.Languages:LanguageExists(GAS.Languages.Config.SelectedLanguages.GAS)) then
			return GAS.Languages.Config.SelectedLanguages.GAS
		else
			return GmodLanguage()
		end
	else
		if (GAS.Languages.Config.SelectedLanguages[module_name] and GAS.Languages:LanguageExists(GAS.Languages.Config.SelectedLanguages[module_name], module_name)) then
			return GAS.Languages.Config.SelectedLanguages[module_name]
		elseif (GAS.Languages:LanguageExists(GAS.Languages.Config.SelectedLanguages.GAS, module_name)) then
			return GAS.Languages.Config.SelectedLanguages.GAS
		else
			return GmodLanguage(module_name)
		end
	end
end

function GAS.Languages:RawPhrase(str, module_name, discriminator)
	local selected_language = GAS.Languages:GetSelectedLanguage(module_name)
	local phrase_str
	if (isfunction(GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases)) then
		GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases = GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases()
	end
	if (discriminator) then
		phrase_str = GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases[discriminator][str]
	else
		phrase_str = GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases[str]
	end
	if (phrase_str) then
		return phrase_str
	elseif (selected_language ~= "english") then
		if (discriminator) then
			if (GAS.Languages.LanguageData[module_name or "GAS"]["english"].Phrases[discriminator] ~= nil) then
				return GAS.Languages.LanguageData[module_name or "GAS"]["english"].Phrases[discriminator][str] or str
			else
				return str
			end
		else
			return GAS.Languages.LanguageData[module_name or "GAS"]["english"].Phrases[str] or str
		end
	else
		return str
	end
end
function GAS:Phrase(str, module_name, discriminator)
	if (str == "module_name") then
		local friendly_name = GAS.Languages:RawPhrase(str, module_name)
		if (friendly_name == str) then
			return nil
		else
			return friendly_name
		end
	else
		return (GAS.Languages:RawPhrase(str, module_name, discriminator):gsub("\t",""))
	end
end
function GAS:PhraseFormat(str, module_name, ...)
	return GAS:Phrase(str, module_name):format(...)
end

--######## TIMESTAMP LOCALIZATION ########--

function GAS:FormatTimestamp(timestamp)
	if (GAS.Languages.Config.ShortDateFormat ~= false) then
		return os.date(GAS.Languages.Config.ShortDateFormat, timestamp)
	else
		if (CLIENT and (system.GetCountry() == "US" or system.GetCountry() == "CA")) then
			return os.date("%m/%d/%Y %I:%M:%S %p", timestamp)
		else
			return os.date("%d/%m/%Y %I:%M:%S %p", timestamp)
		end
	end
end
function GAS:FormatFullTimestamp(timestamp)
	if (GAS.Languages.Config.LongDateFormat ~= false) then
		return os.date(GAS.Languages.Config.LongDateFormat, timestamp)
	else
		if (CLIENT and (system.GetCountry() == "US" or system.GetCountry() == "CA")) then
			return os.date("%a %m/%d/%Y %I:%M:%S %p", timestamp)
		else
			return os.date("%a %d/%m/%Y %I:%M:%S %p", timestamp)
		end
	end
end
function GAS:SimplifySeconds(seconds)
	if (seconds < 60) then
		local sec = seconds
		local lang_str = "s_seconds"
		if (sec == 1) then lang_str = "s_second" end
		return GAS:PhraseFormat(lang_str, nil, sec)
	elseif (seconds < 3600) then
		local min = math.Round(seconds / 60)
		local lang_str = "s_minutes"
		if (min == 1) then lang_str = "s_minute" end
		return GAS:PhraseFormat(lang_str, nil, min)
	else
		local hour = math.Round(seconds / 60 / 60)
		local lang_str = "s_hours"
		if (hour == 1) then lang_str = "s_hour" end
		return GAS:PhraseFormat(lang_str, nil, hour)
	end
end
function GAS:SimplifyTimestamp(timestamp)
	local difference = os.time() - timestamp
	if (difference == 0) then
		return GAS:Phrase("just_now")
	elseif (difference < 60) then

		local sec = difference
		local lang_str = "seconds_ago"
		if (sec == 1) then lang_str = "second_ago" end
		return GAS:PhraseFormat(lang_str, nil, sec)

	elseif (difference < 3600) then

		local min = math.Round(difference / 60)
		local lang_str = "minutes_ago"
		if (min == 1) then lang_str = "minute_ago" end
		return GAS:PhraseFormat(lang_str, nil, min)

	elseif (difference < 86400) then

		local hour = math.Round(difference / 60 / 60)
		local lang_str = "hours_ago"
		if (hour == 1) then lang_str = "hour_ago" end
		return GAS:PhraseFormat(lang_str, nil, hour)

	else
		return GAS:FormatTimestamp(timestamp)
	end
end

if (SERVER) then
	local languages = file.Find("gmodadminsuite/lang/*.lua", "LUA")
	for _,f in ipairs(languages) do
		AddCSLuaFile("gmodadminsuite/lang/" .. f)
	end

	local _,modules = file.Find("gmodadminsuite/modules/*", "LUA")
	for _,module in ipairs(modules) do
		local languages = file.Find("gmodadminsuite/modules/" .. module .. "/lang/*.lua", "LUA")
		for _,f in ipairs(languages) do
			AddCSLuaFile("gmodadminsuite/modules/" .. module .. "/lang/" .. f)
		end
	end
end
--lua/autorun/kaminoan.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Kaminoan",		"models/player/tiki/kaminoan.mdl" )

--addons/weapon_jedi/lua/lscs/autorun/lscs_inventory.lua:
local meta = FindMetaTable( "Player" )

if SERVER then
	util.AddNetworkString( "lscs_inventory" )
	util.AddNetworkString( "lscs_inventory_refresh" )
	util.AddNetworkString( "lscs_sync" )
	util.AddNetworkString( "lscs_equip" )

	function meta:lscsAddInventory( class_or_entity, equip )
		local item = class_or_entity

		if IsEntity( class_or_entity ) then
			item = class_or_entity:GetClass()
		end

		local index = 1 -- start at 1
		for _,_ in ipairs( self:lscsGetInventory() ) do
			index = index + 1 -- lets find an empty slot. Thanks to ipairs nature it will automatically stop at an empty slot
		end

		if hook.Run( "LSCS:PlayerInventory", self, item, index ) then return end

		if self._lscsNetworkingReady then
			net.Start( "lscs_inventory" )
				net.WriteBool( true )
				net.WriteInt( index, 8 )
				net.WriteString( item )
			net.Send( self )
		end

		self:lscsGetInventory()[ index ] = item

		if isbool( equip ) then -- this makes sure we can not equip two hilts or blades in one hand
			local object = LSCS:ClassToItem( item )

			if object then
				local type = object.type

				if type == "hilt" or type == "crystal" then
					self:lscsClearEquipped( type, equip )
				end
			end
		end

		self:lscsEquipItem( index, equip )

		if IsEntity( class_or_entity ) then
			class_or_entity:Remove()
		end
	end

	function meta:lscsEquipItem( index, hand )
		local class = self:lscsGetInventory()[ index ]
		if not class then return end

		local WasEquipped = self:lscsGetEquipped()[ index ]
		self:lscsGetEquipped()[ index ] = hand

		if self._lscsNetworkingReady then
			net.Start( "lscs_equip" )
				net.WriteInt( index, 8 )
				if hand == true then
					net.WriteInt( 1, 3 )
				elseif hand == false then
					net.WriteInt( 0, 3 )
				else
					net.WriteInt( -1, 3 )
				end
			net.Send( self )
		end

		self:lscsBuildPlayerInfo()

		if isbool( hand ) then
			hook.Run( "LSCS:OnPlayerEquippedItem", self, LSCS:ClassToItem( class ) )
		else
			if isbool( WasEquipped ) then
				hook.Run( "LSCS:OnPlayerUnEquippedItem", self, LSCS:ClassToItem( class ) )
			end
		end
	end

	net.Receive( "lscs_equip", function( len, ply )
		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()

		local index = net.ReadInt( 8 )
		local equip = net.ReadInt( 3 )

		if inventory[ index ] then
			if equip == 1 then
				ply:EmitSound( "lscs/equip.mp3" )
				equipped[ index ] = true

			elseif equip == 0 then
				ply:EmitSound( "lscs/equip.mp3" )
				equipped[ index ] = false

			else
				if isbool( equipped[ index ] ) then
					equipped[ index ] = nil
					ply:EmitSound( "weapons/sniper/sniper_zoomout.wav" )
				end
			end
		else
			equipped[ index ] = nil
		end

		ply:lscsBuildPlayerInfo()

		if equip == 0 or equip == 1 then
			hook.Run( "LSCS:OnPlayerEquippedItem", ply, LSCS:ClassToItem( inventory[ index ] ) )
		else
			hook.Run( "LSCS:OnPlayerUnEquippedItem", ply, LSCS:ClassToItem( inventory[ index ] ) )
		end
	end )

	function meta:lscsSyncInventory()
		if not self._lscsNetworkingReady then return end

		local inv = self:lscsGetInventory()
		local eq = self:lscsGetEquipped()

		local num = table.Count( inv )

		net.Start( "lscs_sync" )
			net.WriteInt( num, 8 )
			for index, item in pairs( inv ) do
				net.WriteInt( index, 8 )

				local IsEquipped = eq[ index ]
				if IsEquipped == true then
					net.WriteInt( 1, 3 )
				elseif IsEquipped == false then
					net.WriteInt( 0, 3 )
				else
					net.WriteInt( -1, 3 )
				end

				net.WriteString( item )
			end
		net.Send( self )
	end

	function meta:lscsWipeInventory( wipe_unequipped )
		if wipe_unequipped then
			local inv = self:lscsGetInventory()
			local eq = self:lscsGetEquipped()

			for id, item in pairs( inv ) do
				if eq[ id ] == nil then
					inv[ id ] = nil
				end
			end
		else
			local inv = self:lscsGetInventory()
			local eq = self:lscsGetEquipped()

			self:StripWeapon( "weapon_lscs" )

			for id, class in pairs( self:lscsGetInventory() ) do
				if isbool( eq[ id ] ) then
					hook.Run( "LSCS:OnPlayerUnEquippedItem", self, LSCS:ClassToItem( class ) )
				end
			end

			table.Empty( inv )
			table.Empty( eq )
		end

		self:lscsSyncInventory()
		self:lscsBuildPlayerInfo()
	end

	function meta:lscsDropItem( id )
		local item = self:lscsGetInventory()[ id ]

		if not item then return end

		local tr = util.TraceLine( {
			start = self:GetShootPos(),
			endpos = self:GetShootPos() + self:GetAimVector() * 50,
			filter = self,
		} )

		local ent = ents.Create( item )

		if not IsValid( ent ) then self:lscsRemoveItem( id ) return end

		ent:SetPos( tr.HitPos )
		ent:SetAngles( Angle(90,self:EyeAngles().y,0) )

		ent.PreventTouch = true
		ent.DieTime = CurTime() + 240

		ent:Spawn()
		ent:Activate()
		ent:PhysWake()

		net.Start( "lscs_inventory" )
			net.WriteBool( false )
			net.WriteInt( id, 8 )
		net.Send( self )

		if self:lscsGetEquipped()[ id ] then -- we dropped a equipped item
			local _item = LSCS:ClassToItem( item ) -- convert item from inventory which is a class to actual item data
			if _item.type =="hilt" or _item.type == "crystal" then -- the item is a crystal or hilt which means we have to craft a lightsaber so it actually takes these parts out

				-- this garbage has to be called before crafting because it pulls stuff out of the inventory
				self:lscsRemoveItem( id )
				self:lscsBuildPlayerInfo()

				-- craft the saber
				self:lscsCraftSaber()
			end

			if _item.type == "stance" then -- dropped a equipped stance
				self:lscsRemoveItem( id )
				self:lscsBuildPlayerInfo() -- sync stances
			end

			hook.Run( "LSCS:OnPlayerUnEquippedItem", self, _item )
		end

		self:lscsRemoveItem( id )

		hook.Run( "LSCS:OnPlayerDroppedItem", self, ent )
	end

	function meta:lscsRemoveItem( id )
		local item = self:lscsGetInventory()[ id ]

		if not item then return end

		net.Start( "lscs_inventory" )
			net.WriteBool( false )
			net.WriteInt( id, 8 )
		net.Send( self )

		self:lscsGetInventory()[ id ] = nil
		self:lscsGetEquipped()[ id ] = nil
	end

	net.Receive( "lscs_inventory", function( len, ply )
		local id = net.ReadInt( 8 )
		ply:lscsDropItem( id )
	end)

	net.Receive( "lscs_sync", function( len, ply )
		if ply._lscsNetworkingReady then return end -- only allow this to be called once. This will prevent them from doing malicious bullshit.

		-- in case someone was spamming ply:Give while the player wasnt ready for networking
		-- this will make sure the client's inventory is 100% in sync with the server
		ply._lscsNetworkingReady = true
		ply:lscsSyncInventory()
		ply:lscsBuildPlayerInfo()

		hook.Run( "LSCS:OnPlayerFullySpawned", ply )
	end )

	net.Receive( "lscs_inventory_refresh", function( len, ply )
		local Wipe = net.ReadBool()

		if Wipe then
			ply:lscsWipeInventory( net.ReadBool() )
		else
			ply._lscsInvRefNext = ply._lscsInvRefNext or 0

			local Time = CurTime()

			if ply._lscsInvRefNext > Time then
				ply._lscsInvRefNext = ply._lscsInvRefNext + 1 -- add 1 second penality
				ply:ChatPrint("[LSCS] - Please wait ".. math.Round(ply._lscsInvRefNext-Time,0) .." seconds before refreshing your Inventory again")
				return
			end

			ply._lscsInvRefNext = Time + 10

			ply:lscsSyncInventory()
			ply:lscsBuildPlayerInfo()

			ply:ChatPrint("[LSCS] - Inventory Refreshed")
		end
	end)
else
	hook.Add( "InitPostEntity", "!!!lscsPlayerReady", function()
		net.Start( "lscs_sync" )
		net.SendToServer()
	end )

	net.Receive( "lscs_inventory", function( len )
		local ply = LocalPlayer()

		local Add = net.ReadBool()
		local id = net.ReadInt( 8 )

		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()
	
		if Add then
			local item = net.ReadString()
			inventory[ id ] = item
		else
			inventory[ id ] = nil
		end
		equipped[ id ] = nil

		LSCS:RefreshMenu()
	end)

	net.Receive( "lscs_sync", function( len )
		local ply = LocalPlayer()

		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()

		table.Empty( inventory )
		table.Empty( equipped )

		local num = net.ReadInt( 8 )
		for i = 1, num do
			local index = net.ReadInt( 8 )
			local IsEquipped = net.ReadInt( 3 )
			local item = net.ReadString( item )

			inventory[ index ] = item

			if IsEquipped == 1 then
				equipped[ index ] = true
			elseif IsEquipped == 0 then
				equipped[ index ] = false
			else
				equipped[ index ] = nil
			end
		end

		LSCS:RefreshMenu()
	end)

	function meta:lscsDropItem( id )
		net.Start( "lscs_inventory" )
			net.WriteInt( id, 8 )
		net.SendToServer()

		self:lscsGetInventory()[ id ] = nil
		self:lscsGetEquipped()[ id ] = nil

		self:lscsBuildPlayerInfo()
	end

	function meta:lscsEquipItem( index, hand )
		if not self:lscsGetInventory()[ index ] then return end

		self:lscsGetEquipped()[ index ] = hand

		net.Start( "lscs_equip" )
			net.WriteInt( index, 8 )
			if hand == true then
				net.WriteInt( 1, 3 )
			elseif hand == false then
				net.WriteInt( 0, 3 )
			else
				net.WriteInt( -1, 3 )
			end
		net.SendToServer()

		self:lscsBuildPlayerInfo()
	end

	net.Receive( "lscs_equip", function( len )
		local ply = LocalPlayer()

		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()

		local index = net.ReadInt( 8 )
		local equip = net.ReadInt( 3 )

		if inventory[ index ] then
			if equip == 1 then
				equipped[ index ] = true

			elseif equip == 0 then
				equipped[ index ] = false

			else
				equipped[ index ] = nil
			end
		else
			equipped[ index ] = nil
		end

		ply:lscsBuildPlayerInfo()
	end )
end

--addons/weapon_jedi/lua/lscs/combos/bx_shiicho.lua:
COMBO.id = "bx"
COMBO.PrintName = "Form I | Shii-Cho"
COMBO.Author = "Deltaa"
COMBO.Description = "Der Weg des Sarlacc"

COMBO.DeflectBullets = false
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_shiicho"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.1,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.1,
		Duration = .9,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
	["____"] = {
		AttackAnim = "judge_b_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "judge_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.8, Vector(100, 0, 0))
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.1,
		Duration = 1,
	},
	["W_S_"] = {
		AttackAnim = "vanguard_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

            ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(50, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["__S_"] = {
		AttackAnim = "judge_b_s2_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "vanguard_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "vanguard_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_r_s2_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
}
--addons/weapon_jedi/lua/lscs/combos/shiicho.lua:
COMBO.id = "shiicho"
COMBO.PrintName = "Form I | Shii-Cho"
COMBO.Author = "Deltaa"
COMBO.Description = "Der Weg des Sarlacc"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_shiicho"
COMBO.MaxBlockPoints = 125

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.1,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.1,
		Duration = .9,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
	["____"] = {
		AttackAnim = "judge_b_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "judge_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.8, Vector(100, 0, 0))
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.1,
		Duration = 1,
	},
	["W_S_"] = {
		AttackAnim = "vanguard_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

            ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(50, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["__S_"] = {
		AttackAnim = "judge_b_s2_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "vanguard_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "vanguard_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_r_s2_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
}
--addons/weapon_jedi/lua/lscs/content/lscs_hilts.lua:

-- Hilt: Katarn
--
local hilt = {}
hilt.PrintName = "Katarn"
hilt.Author = "Blu-x92 / Luna"
hilt.id = "katarn"
hilt.mdl = "models/lscs/weapons/katarn.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(4.25, -1.5, -1),
			ang = Angle(172, 0, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(4.25, -1.5, 1),
			ang = Angle(8, 0, -10),
		},
	},
	GetBladePos = function( ent )
		if not ent.BladeID then
			ent.BladeID = ent:LookupAttachment( "primary_blade" )
		end

		local att = ent:GetAttachment( ent.BladeID )

		if att then
			local blades = {
				[1] = {
					pos = att.Pos,
					dir = att.Ang:Up(),
				}
			}
			return blades
		end
	end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Nano Sword
hilt.PrintName = "Nano Sword"
hilt.Author = "Salza"
hilt.id = "nanosword"
hilt.Spawnable = false  
hilt.mdl = "models/lscs/weapons/nanosword.mdl"
LSCS:RegisterHilt( hilt )


-- Hilt: Staff
--
local hilt = {}
hilt.PrintName = "Staff"
hilt.Author = "Blu-x92 / Luna"
hilt.id = "guard"
hilt.mdl = "models/lscs/weapons/staff.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(4.25, -1.5, -1),
			ang = Angle(172, 0, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(4.25, -1.5, 1),
			ang = Angle(8, 0, -10),
		},
	},
	GetBladePos = function( ent )
		if not ent.BladeID1 then
			ent.BladeID1 = ent:LookupAttachment( "primary_blade" )
		end
		if not ent.BladeID2 then
			ent.BladeID2 = ent:LookupAttachment( "secondary_blade" )
		end

		local att1 = ent:GetAttachment( ent.BladeID1 )
		local att2 = ent:GetAttachment( ent.BladeID2 )

		if att1 and att2 then
			local blades = {
				[1] = {
					pos = att1.Pos,
					dir = att1.Ang:Up(),
				},
				[2] = {
					pos = att2.Pos,
					dir = att2.Ang:Up(),
				}
			}
			return blades
		end
	end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Anakin
--
local hilt = {}
hilt.PrintName = "Anakin"
hilt.Author = "Rubat"
hilt.id = "Anakin"
hilt.Spawnable = false
hilt.mdl = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Kenobi
--
local hilt = {}
hilt.PrintName = "Kenobi"
hilt.Author = "Blu-x92 / Luna"
hilt.id = "Kenobi"
hilt.Spawnable = false
hilt.mdl = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Jedi Common
--
local hilt = {}
hilt.PrintName = "Jedicommon"
hilt.Author = "Blu-x92 / Luna"
hilt.id = "jedicommon"
hilt.mdl = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Qui-Gon
--
local hilt = {}
hilt.PrintName = "Qui-Gon Jinn"
hilt.Author = "Deltaa"
hilt.id = "quigon"
hilt.mdl = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Ahsoka 1
local hilt = {}
hilt.PrintName = "Ahsoka | Rechts | Hilt"
hilt.Author = "ArsenicBeast"
hilt.id = "ahsokaright"
hilt.Spawnable = false
hilt.mdl = "models/starwars/cwa/lightsabers/ahsoka.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Ahsoka 2
--
local hilt = {}
hilt.PrintName = "Ahsoka | Links | Hilt"
hilt.Author = "ArsenicBeast"
hilt.id = "ahsokaleft"
hilt.Spawnable = false
hilt.mdl = "models/starwars/cwa/lightsabers/reverseahsoka.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(1.7, -1.5, -7.2),
            ang = Angle(260, 200, 200),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Dooku
--
local hilt = {}
hilt.PrintName = "Dooku"
hilt.Author = "Rino"
hilt.id = "dooku"
hilt.Spawnable = false
hilt.mdl = "models/weapons/starwars/w_dooku_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.3) ),
                dir = ent:LocalToWorldAngles( Angle(50,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: BX
--
local hilt = {}
hilt.PrintName = "BX"
hilt.Author = "Rino"
hilt.id = "bx1"
hilt.Spawnable = false  
hilt.mdl = "models/vibrolame/w_models/w_bxdroid_vibrosword.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(05.5, -1, -012.5),
            ang = Angle(180, 70, 10),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(05.5, -1, -012.5),
            ang = Angle(-180, -70, -10),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-1,-0.2,-7.9) ),
                dir = ent:LocalToWorldAngles( Angle(-3,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Electrostaff
--
local hilt = {}
hilt.PrintName = "Electrostaff"
hilt.Author = "Miller"
hilt.id = "staffel"
hilt.Spawnable = false  
hilt.mdl = "models/tfa/comm/gg/prp_magna_guard_weapon_season4.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -5),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-30,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(30,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: ARC Knife
--
local hilt = {}
hilt.PrintName = "ARC Knife"
hilt.Author = "Miller"
hilt.id = "arcknife"
hilt.Spawnable = false  
hilt.mdl = "models/lauch/weapons/knife/w_knife.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.25, -1.5, 0),
            ang = Angle(20,80,-85),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4.25, -1.5, 0),
            ang = Angle(186,180,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(0,0,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

-- Hilt: Zatt
--
local hilt = {}
hilt.PrintName = "Zatt"
hilt.Author = "Deltaa"
hilt.id = "zatt"
hilt.Spawnable = false
hilt.mdl = "models/starwars/cwa/lightsabers/zatt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Jocasta
--
local hilt = {}
hilt.PrintName = "Jocasta"
hilt.Author = "Deltaa"
hilt.id = "jocasta"
hilt.mdl = "models/starwars/cwa/lightsabers/jocastanu.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Saesee Tiin
--
local hilt = {}
hilt.PrintName = "Saesee Tiin"
hilt.Author = "Deltaa"
hilt.id = "tiin"
hilt.mdl = "models/starwars/cwa/lightsabers/saeseetiin.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Fisto
--
local hilt = {}
hilt.PrintName = "Kit Fisto"
hilt.Author = "Deltaa"
hilt.id = "fisto"
hilt.mdl = "models/starwars/cwa/lightsabers/kitfisto.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Ventress
--
local hilt = {}
hilt.PrintName = "Ventress"
hilt.Author = "Deltaa"
hilt.id = "ventress"
hilt.Spawnable = false  
hilt.mdl = "models/starwars/cwa/lightsabers/ventress.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Lightside
--
local hilt = {}
hilt.PrintName = "Lightside"
hilt.Author = "Deltaa"
hilt.id = "lightside"
hilt.mdl = "models/starwars/cwa/lightsabers/lightsideaffiliation.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Kashyyyk
--
local hilt = {}
hilt.PrintName = "Kashyyyk Hilt"
hilt.Author = "Deltaa"
hilt.id = "kashyyk"
hilt.mdl = "models/starwars/cwa/lightsabers/kashyyyk.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)

-- Hilt: Talz
--
local hilt = {}
hilt.PrintName = "Talz"
hilt.Author = "Deltaa"
hilt.id = "talz"
hilt.mdl = "models/starwars/cwa/lightsabers/talz.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.4,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt(hilt)
--addons/lvs_base/lua/lvs_framework/autorun/lvs_entitytracker.lua:
LVS.VehiclesStored = LVS.VehiclesStored or {}
LVS.NPCsStored = LVS.NPCsStored or {}

function LVS:GetNPCs()
	for index, ent in pairs( LVS.NPCsStored ) do
		if not IsValid( ent ) then
			LVS.NPCsStored[ index ] = nil
		end
	end

	return LVS.NPCsStored
end

function LVS:GetVehicles()
	for index, ent in pairs( LVS.VehiclesStored ) do
		if not IsValid( ent ) then
			LVS.VehiclesStored[ index ] = nil
		end
	end

	return LVS.VehiclesStored
end

local Teams = {
	["npc_breen"] = 1,
	["npc_combine_s"] = 1,
	["npc_combinedropship"] = 1,
	["npc_combinegunship"] = 1,
	["npc_crabsynth"] = 1,
	["npc_cscanner"] = 1,
	["npc_helicopter"] = 1,
	["npc_manhack"] = 1,
	["npc_metropolice"] = 1,
	["npc_mortarsynth"] = 1,
	["npc_sniper"] = 1,
	["npc_stalker"] = 1,
	["npc_strider"] = 1,
	["npc_hunter"] = 1,

	["monster_human_grunt"] = 1,
	["monster_human_assassin"] = 1,
	["monster_sentry"] = 1,

	["npc_kleiner"] = 2,
	["npc_monk"] = 2,
	["npc_mossman"] = 2,
	["npc_vortigaunt"] = 2,
	["npc_alyx"] = 2,
	["npc_barney"] = 2,
	["npc_citizen"] = 2,
	["npc_dog"] = 2,
	["npc_eli"] = 2,
	["monster_scientist"] = 2,
	["monster_barney"] = 2,

	["npc_zombine"] = 3,
	["npc_fastzombie"] = 3,
	["npc_headcrab"] = 3,
	["npc_headcrab_black"] = 3,
	["npc_headcrab_fast"] = 3,
	["npc_antlion"] = 3,
	["npc_antlionguard"] = 3,
	["npc_zombie"] = 3,
	["npc_zombie_torso"] = 3,
	["npc_poisonzombie"] = 3,
	["monster_alien_grunt"] = 3,
	["monster_alien_slave"] = 3,
	["monster_gargantua"] = 3,
	["monster_bullchicken"] = 3,
	["monster_headcrab"] = 3,
	["monster_babycrab"] = 3,
	["monster_zombie"] = 3,
	["monster_houndeye"] = 3,
	["monster_nihilanth"] = 3,
	["monster_bigmomma"] = 3,
	["monster_babycrab"] = 3,
}
function LVS:GetNPCRelationship( npc_class )
	return Teams[ npc_class ] or 0
end

hook.Add( "OnEntityCreated", "!!!!lvsEntitySorter", function( ent )
	timer.Simple( 2, function() 
		if not IsValid( ent ) then return end

		if isfunction( ent.IsNPC ) and ent:IsNPC() then
			table.insert( LVS.NPCsStored, ent )

			if SERVER then
				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end

		if ent.LVS then 
			if CLIENT and ent.PrintName then
				language.Add( ent:GetClass(), ent.PrintName)
			end

			table.insert( LVS.VehiclesStored, ent )

			if SERVER then
				LVS:FixVelocity()

				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end
	end )
end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_force_directinput.lua:

local cVar_forcedirect = CreateConVar( "lvs_force_directinput", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Force Direct Input Steering Method?" )
local cVar_forceindicator = CreateConVar( "lvs_force_forceindicator", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Force Direct Input Steering Method?" )

function LVS:IsDirectInputForced()
	return LVS.ForceDirectInput == true
end

function LVS:IsIndicatorForced()
	return LVS.ForceIndicator == true
end

if SERVER then
	util.AddNetworkString( "lvs_forced_input_getter" )

	local function UpdateForcedSettings( ply )
		net.Start( "lvs_forced_input_getter" )

		net.WriteBool( LVS:IsDirectInputForced() )
		net.WriteBool( LVS:IsIndicatorForced() )

		if IsValid( ply ) then
			net.Send( ply )
		else
			net.Broadcast()
		end
	end

	LVS.ForceDirectInput = cVar_forcedirect and cVar_forcedirect:GetBool() or false
	cvars.AddChangeCallback( "lvs_force_directinput", function( convar, oldValue, newValue ) 
		LVS.ForceDirectInput = tonumber( newValue ) ~=0

		UpdateForcedSettings()
	end)

	LVS.ForceIndicator = cVar_forceindicator and cVar_forceindicator:GetBool() or false
	cvars.AddChangeCallback( "lvs_force_forceindicator", function( convar, oldValue, newValue ) 
		LVS.ForceIndicator = tonumber( newValue ) ~=0

		UpdateForcedSettings()
	end)

	net.Receive( "lvs_forced_input_getter", function( length, ply )
		UpdateForcedSettings( ply )
	end)
else
	net.Receive( "lvs_forced_input_getter", function( length )
		LVS.ForceDirectInput = net.ReadBool()
		LVS.ForceIndicator = net.ReadBool()
	end )

	hook.Add( "InitPostEntity", "!11!!!lvsIsPlayerReady", function()
		net.Start( "lvs_forced_input_getter" )
		net.SendToServer()
	end )
end
--addons/weapons_other/lua/autorun/recondroiddeploy_net.lua:
if SERVER then 
	
	hook.Add("PlayerSwitchWeapon","TurnoffController",function( ply, oldWeapon, newWeapon )
		
	end)

	
	
end

if !CLIENT then return end

local modelexample = ClientsideModel( "models/lt_c/holograms/eletc_paths.mdl" )
//modelexample:SetNoDraw( true )

local offsetvec = Vector( 4, -5.5, 0 ) //3
local offsetang = Angle( 180, 0, 0 )



/*
hook.Add( "PostPlayerDraw" , "controller_show" , function( ply )
	if ply == LocalPlayer() then timer.Simple(.5,function() LocalPlayer().shutoff = false end)LocalPlayer().shutoff = true end
	
	for index, ply in pairs(player.GetAll()) do
		if ply == LocalPlayer() then continue end
		if !ply:GetNWBool("HasController") then continue end
		if ply:GetNWBool( "Show_Controller" ) then 
			local boneid = ply:LookupBone( "ValveBiped.Bip01_R_Hand" )
			if not boneid then
				return
			end
		
			local matrix = ply:GetBoneMatrix( boneid )
		
			if not matrix then
				return
			end
		
			local newpos, newang = LocalToWorld( offsetvec, offsetang, matrix:GetTranslation(), matrix:GetAngles() )
		
			modelexample:SetPos( newpos )
			modelexample:SetAngles( newang )
			modelexample:SetupBones()
			modelexample:DrawModel()
		end

	end
end)


	
hook.Add("HUDPaint", "Controllerrmodel", function()
    local ply = LocalPlayer()
	local ang = LocalPlayer():GetAimVector()
	if LocalPlayer().shutoff then return end
   if !LocalPlayer():Alive() then return end
   if !LocalPlayer():GetNWBool("HasController") then return end
        cam.Start3D()
			if LocalPlayer():GetNWBool( "Show_Controller" ) then
					modelexample:SetModel("models/lt_c/holograms/eletc_paths.mdl")
					local ang = LocalPlayer():EyeAngles() 
					ang.z = ang.z + 180
					//ang.y = ang.y + 180
					modelexample:SetPos( LocalPlayer():GetShootPos() + ang:Right() * -10 - ang:Up() * -5 + ang:Forward()* 30 )
					modelexample:SetAngles(ang + Angle(180,0,0))
					modelexample:SetupBones()
					modelexample:DrawModel()
			end
        cam.End3D()
end)
*/
--addons/admin_sam/lua/sam/command/arguments/dropdown.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("dropdown")
    :OnExecute(function(arg, input, ply, _, result)
        if not arg.options or table.Empty(arg.options) then
            ply:sam_send_message("no data", {S = "dropdown", S_2 = input})
            return
        end

        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value)
            set_result(value)
            default = value
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            if not arg.options then
                LocalPlayer():sam_send_message("dropdown has no options data")
                return
            end

            for k, v in pairs(arg.options) do
                self:AddChoice(v)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()
--addons/admin_sam_sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--addons/admin_sam/lua/sam/menu/tabs/players.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_players", nil, "superadmin")

local get_pages_count = function(count)
	count = count / 35
	local i2 = math.floor(count)
	return count ~= i2 and i2 + 1 or count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_players") and ply:sam_check_cooldown("MenuViewPlayers", 0.1)
	end

	local limit = 35

	local get_page_count = function(callback, res, page, column, order_by, sort_by, keyword)
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_players`]]
		if keyword then
			if column == "steamid" and sam.is_steamid64(keyword) then
				keyword = util.SteamIDFrom64(keyword)
			end

			query = string.format("%s WHERE `%s` LIKE %s", query, column, SQL.Escape("%" .. keyword .. "%"))
		end
		SQL.Query(query, callback, true, {res, page, column, order_by, sort_by, keyword})
	end

	local valid_columns = {
		steamid = true,
		name = true,
		rank = true
	}

	local valid_sorts = {
		id = true,
		name = true,
		rank = true,
		play_time = true,
		last_join = true
	}

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_players = function(count_data, arguments)
		local res, page, column, order_by, sort_by, keyword = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`steamid`,
				`name`,
				`rank`,
				`expiry_date`,
				`first_join`,
				`last_join`,
				`play_time`
			FROM
				`sam_players`
		]]

		local args = {}

		if keyword then
			args[1] = column
			args[2] = "%" .. keyword .. "%"

			query = query .. [[
				WHERE
					`{1f}` LIKE {2}
			]]
		end

		args[3] = sort_by
		if order_by == "DESC" then
			query = query .. [[
				ORDER BY `{3f}` DESC
			]]
		else
			query = query .. [[
				ORDER BY `{3f}` ASC
			]]
		end

		args[4] = limit
		args[5] = math.abs(limit * (page - 1))

		query = query .. [[
			LIMIT {4} OFFSET {5}
		]]

		SQL.FQuery(query, args, resolve_promise, false, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetPlayers", function(res, ply, page, column, order_by, sort_by, keyword)
		if not isnumber(page) then return end
		if not valid_columns[column] then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if not valid_sorts[sort_by] then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(get_players, res, page, column, order_by, sort_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

local button_click = function(s)
	local v = s.v

	local dmenu = vgui.Create("SAM.Menu")
	dmenu:SetInternal(s)
	if v.name and v.name ~= "" then
		dmenu:AddOption("Copy Name", function()
			SetClipboardText(v.name)
		end)
	end

	dmenu:AddOption("Copy SteamID", function()
		SetClipboardText(v.steamid)
	end)

	dmenu:AddOption("Copy Rank", function()
		SetClipboardText(v.rank)
	end)

	dmenu:AddOption("Copy Play Time", function()
		SetClipboardText(sam.reverse_parse_length(tonumber(v.play_time) / 60))
	end)

	dmenu:AddSpacer()

	dmenu:AddOption("Change Rank", function()
		local querybox = vgui.Create("SAM.QueryBox")
		querybox:SetTitle(string.format("Change rank for '%s'", v.name or v.steamid))
		querybox:SetWide(360)

		local ranks = querybox:Add("SAM.ComboBox")
		ranks:SetTall(28)

		for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if v.rank ~= rank_name then
				ranks:AddChoice(rank_name, nil, true)
			end
		end

		querybox:Done()
		querybox.save:SetEnabled(true)

		querybox:SetCallback(function()
			RunConsoleCommand("sam", "setrankid", v.steamid, ranks:GetValue())
		end)
	end)

	dmenu:Open()
end

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_column, current_order, current_sort, keyword = nil, "steamid", "DESC", "id", nil

	local players_body = column_sheet:Add("Panel")
	players_body:Dock(FILL)
	players_body:DockMargin(0, 1, 0, 0)
	players_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(players_body)

	local title = players_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Players")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = players_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total players")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	local search_entry
	do
		local container = players_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_by = container:Add("SAM.ComboBox")
		sort_by:Dock(RIGHT)
		sort_by:DockMargin(4, 0, 0, 0)
		sort_by:SetWide(106)
		sort_by:SetValue("Sort By (ID)")
		sort_by:AddChoice("ID")
		sort_by:AddChoice("Name")
		sort_by:AddChoice("Rank")
		sort_by:AddChoice("Play Time")

		function sort_by:OnSelect(_, value)
			value = value:lower():gsub(" ", "_")
			if current_sort ~= value then
				current_sort = value
				refresh()
			end
		end

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local column = container:Add("SAM.ComboBox")
		column:Dock(RIGHT)
		column:DockMargin(0, 0, 4, 0)
		column:SetWide(140)

		column:SetValue("Search (SteamID)")
		column:AddChoice("SteamID")
		column:AddChoice("Name")
		column:AddChoice("Rank")

		function column:OnSelect(_, value)
			value = value:lower()
			if current_column ~= value then
				current_column = value
				refresh()
			end
		end

		search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter(no_refresh)
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				if not no_refresh then
					refresh()
				end
			end
		end
	end

	Line(players_body, nil, -5, SUI.Scale(15), -5, 0)

	do
		local columns = players_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local play_time = columns:Add("SAM.Label")
		play_time:Dock(LEFT)
		play_time:DockMargin(-4, 0, 0, 0)
		play_time:SetFont(COLUMN_FONT)
		play_time:SetText("Play Time")
		play_time:SetTextColor(GetColor("player_list_titles"))
		play_time:SetWide(SUI.Scale(180))
		play_time:SizeToContentsY(3)

		local rank_expiry = columns:Add("SAM.Label")
		rank_expiry:Dock(LEFT)
		rank_expiry:DockMargin(-4, 0, 0, 0)
		rank_expiry:SetFont(COLUMN_FONT)
		rank_expiry:SetText("Rank Expiry")
		rank_expiry:SetTextColor(GetColor("player_list_titles"))
		rank_expiry:SetWide(SUI.Scale(280))
		rank_expiry:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = players_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local players, players_count, current_page_2 = unpack(data)
		total:SetText(players_count .. " total players")

		pages = get_pages_count(players_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(players) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = v.rank
			})

			local play_time = line:Add("SAM.Label")
			play_time:Dock(LEFT)
			play_time:DockMargin(4, 0, 0, 0)
			play_time:SetFont(LINE_FONT)
			play_time:SetText(sam.reverse_parse_length(tonumber(v.play_time) / 60))
			play_time:SetTextColor(GetColor("player_list_data"))
			play_time:SetContentAlignment(4)
			play_time:SetWide(SUI.Scale(180))

			local expiry_date = tonumber(v.expiry_date)
			local rank_expiry = line:Add("SAM.Label")
			rank_expiry:Dock(LEFT)
			rank_expiry:DockMargin(-3, 0, 0, 0)
			rank_expiry:SetFont(LINE_FONT)
			rank_expiry:SetText(expiry_date == 0 and "Never" or sam.reverse_parse_length((expiry_date - os.time()) / 60))
			rank_expiry:SetTextColor(GetColor("player_list_data"))
			rank_expiry:SetContentAlignment(4)
			rank_expiry:SizeToContents()

			local but = line:Actions()
			but.v = v
			but:On("DoClick", button_click)

			body:Line()
		end
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_players") then
			search_entry:OnEnter(true)
			local refresh_query = netstream.async.Start("SAM.GetPlayers", toggle_loading, current_page.i, current_column, current_order, current_sort, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = players_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	do
		local refresh_2 = function()
			timer.Simple(1, refresh)
		end

		for k, v in ipairs({"SAM.AuthedPlayer", "SAM.ChangedPlayerRank", "SAM.ChangedSteamIDRank"}) do
			hook.Add(v, "SAM.MenuPlayers", refresh_2)
		end
	end

	refresh()

	return players_body
end, function()
	return LocalPlayer():HasPermission("manage_players")
end, 2)
--addons/reconnect_crash_screen/lua/autorun/sh_crashmenu_load.lua:
hook.Add("Initialize", "crashmenu", function()
    if game.SinglePlayer() then return end

    crashmenu = {}
    crashmenu.Host = "https://reconnect.bell.moe"

    include("crashmenu/sh_config.lua")

    if SERVER then
        AddCSLuaFile("crashmenu/sh_config.lua")
        AddCSLuaFile("crashmenu/vgui/ReconnectPanel.lua")
        AddCSLuaFile("crashmenu/cl_init.lua")
        include("crashmenu/sv_init.lua")
    end

    if CLIENT then
        include("crashmenu/cl_init.lua")

        RunConsoleCommand("cl_timeout", "7200")
    end
end)

--addons/arccw_weapons/lua/autorun/sh_grenade_sounds.lua:
sound.Add({
    name = "ArcCW_ThermalDet.holster1",
    channel = CHAN_ITEM,
    volume = 1.0,
    sound = "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
})  
sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
})
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"    
})
        
sound.Add({
    name =          "ArcCW_ThermalDet.explosion1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/thermaldet.mp3"    
})

sound.Add({
    name =          "ArcCW_primer.button",
    channel =       16,
    volume =        1.0,
    sound =             "w/buttonpress.wav"    
})

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"    
})
--addons/aocrp_pixelui/lua/autorun/sh_pixelui_loader.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

PIXEL = PIXEL or {}
PIXEL.UI = PIXEL.UI or {}
PIXEL.UI.Version = "1.2.3"

function PIXEL.LoadDirectory(path)
	local files, folders = file.Find(path .. "/*", "LUA")

	for _, fileName in ipairs(files) do
		local filePath = path .. "/" .. fileName

		if CLIENT then
			include(filePath)
		else
			if fileName:StartWith("cl_") then
				AddCSLuaFile(filePath)
			elseif fileName:StartWith("sh_") then
				AddCSLuaFile(filePath)
				include(filePath)
			else
				include(filePath)
			end
		end
	end

	return files, folders
end

function PIXEL.LoadDirectoryRecursive(basePath)
	local _, folders = PIXEL.LoadDirectory(basePath)
	for _, folderName in ipairs(folders) do
		PIXEL.LoadDirectoryRecursive(basePath .. "/" .. folderName)
	end
end

PIXEL.LoadDirectoryRecursive("pixelui")

hook.Run("PIXEL.UI.FullyLoaded")

if CLIENT then return end

--resource.AddWorkshop("2468112758")


--addons/aocrp_pixelui/lua/pixelui/drawing/cl_imgur.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local progressMat

local drawProgressWheel
local setMaterial = surface.SetMaterial
local setDrawColor = surface.SetDrawColor

do
    local min = math.min
    local curTime = CurTime
    local drawTexturedRectRotated = surface.DrawTexturedRectRotated

    function PIXEL.DrawProgressWheel(x, y, w, h, col)
        local progSize = min(w, h)
        setMaterial(progressMat)
        setDrawColor(col.r, col.g, col.b, col.a)
        drawTexturedRectRotated(x + w * .5, y + h * .5, progSize, progSize, -curTime() * 100)
    end
    drawProgressWheel = PIXEL.DrawProgressWheel
end

local materials = {}
local grabbingMaterials = {}

local getImgur = PIXEL.GetImgur
getImgur(PIXEL.ProgressImageID, function(mat)
    progressMat = mat
end)

local drawTexturedRect = surface.DrawTexturedRect
function PIXEL.DrawImgur(x, y, w, h, imgurId, col)
    if not materials[imgurId] then
        drawProgressWheel(x, y, w, h, col)

        if grabbingMaterials[imgurId] then return end
        grabbingMaterials[imgurId] = true

        getImgur(imgurId, function(mat)
            materials[imgurId] = mat
            grabbingMaterials[imgurId] = nil
        end)

        return
    end

    setMaterial(materials[imgurId])
    setDrawColor(col.r, col.g, col.b, col.a)
    drawTexturedRect(x, y, w, h)
end

local drawTexturedRectRotated = surface.DrawTexturedRectRotated
function PIXEL.DrawImgurRotated(x, y, w, h, rot, imgurId, col)
    if not materials[imgurId] then
        drawProgressWheel(x - w * .5, y - h * .5, w, h, col)

        if grabbingMaterials[imgurId] then return end
        grabbingMaterials[imgurId] = true

        getImgur(imgurId, function(mat)
            materials[imgurId] = mat
            grabbingMaterials[imgurId] = nil
        end)

        return
    end

    setMaterial(materials[imgurId])
    setDrawColor(col.r, col.g, col.b, col.a)
    drawTexturedRectRotated(x, y, w, h, rot)
end
--addons/aocrp_pixelui/lua/pixelui/drawing/cl_rounded_box.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local cornerTex8 = surface.GetTextureID("gui/corner8")
local cornerTex16 = surface.GetTextureID("gui/corner16")
local cornerTex32 = surface.GetTextureID("gui/corner32")
local cornerTex64 = surface.GetTextureID("gui/corner64")
local cornerTex512 = surface.GetTextureID("gui/corner512")

local round = math.Round
local min = math.min
local floor = math.floor

local setDrawColor = surface.SetDrawColor
local drawRect = surface.DrawRect
local drawTexturedRectUV = surface.DrawTexturedRectUV
local setTexture = surface.SetTexture

function PIXEL.DrawRoundedBoxEx(borderSize, x, y, w, h, col, topLeft, topRight, bottomLeft, bottomRight)
	setDrawColor(col.r, col.g, col.b, col.a)

	if borderSize <= 0 then
		drawRect(x, y, w, h)
		return
	end

	x = round(x)
	y = round(y)
	w = round(w)
	h = round(h)
	borderSize = min(round(borderSize), floor(w / 2))

	drawRect(x + borderSize, y, w - borderSize * 2, h)
	drawRect(x, y + borderSize, borderSize, h - borderSize * 2)
	drawRect(x + w - borderSize, y + borderSize, borderSize, h - borderSize * 2)

	local tex = cornerTex8
	if borderSize > 8 then tex = cornerTex16 end
	if borderSize > 16 then tex = cornerTex32 end
	if borderSize > 32 then tex = cornerTex64 end
	if borderSize > 64 then tex = cornerTex512 end

	setTexture(tex)

	if topLeft then
		drawTexturedRectUV(x, y, borderSize, borderSize, 0, 0, 1, 1)
	else
		drawRect(x, y, borderSize, borderSize)
	end

	if topRight then
		drawTexturedRectUV(x + w - borderSize, y, borderSize, borderSize, 1, 0, 0, 1)
	else
		drawRect(x + w - borderSize, y, borderSize, borderSize)
	end

	if bottomLeft then
		drawTexturedRectUV(x, y + h -borderSize, borderSize, borderSize, 0, 1, 1, 0)
	else
		drawRect(x, y + h - borderSize, borderSize, borderSize)
	end

	if bottomRight then
		drawTexturedRectUV(x + w - borderSize, y + h - borderSize, borderSize, borderSize, 1, 1, 0, 0)
	else
		drawRect(x + w - borderSize, y + h - borderSize, borderSize, borderSize)
	end
end

local drawRoundedBoxEx = PIXEL.DrawRoundedBoxEx
function PIXEL.DrawRoundedBox(borderSize, x, y, w, h, col)
	return drawRoundedBoxEx(borderSize, x, y, w, h, col, true, true, true, true)
end

local roundedBoxCache = {}
local whiteTexture = surface.GetTextureID("vgui/white")

local drawPoly = surface.DrawPoly

function PIXEL.DrawFullRoundedBoxEx(borderSize, x, y, w, h, col, tl, tr, bl, br)
	setDrawColor(col.r, col.g, col.b, col.a)

	if borderSize <= 0 then
		drawRect(x, y, w, h)
		return
	end

	local fullRight = x + w
	local fullBottom = y + h

	local left, right = x + borderSize, fullRight - borderSize
	local top, bottom = y + borderSize, fullBottom - borderSize

	local halfBorder = borderSize * .7

	local cacheName = borderSize .. x .. y .. w .. h
	local cache = roundedBoxCache[cacheName]
	if not cache then
		cache = {
			{x = right, y = y}, --Top Right
			{x = right + halfBorder, y = top - halfBorder},
			{x = fullRight, y = top},

			{x = fullRight, y = bottom}, --Bottom Right
			{x = right + halfBorder, y = bottom + halfBorder},
			{x = right, y = fullBottom},

			{x = left, y = fullBottom}, --Bottom Left
			{x = left - halfBorder, y = bottom + halfBorder},
			{x = x, y = bottom},

			{x = x, y = top}, --Top Left
			{x = left - halfBorder, y = top - halfBorder},
			{x = left, y = y}
		}

		roundedBoxCache[cacheName] = cache
	end

	setTexture(whiteTexture)
	drawPoly(cache)

	if not tl then drawRect(x, y, borderSize, borderSize) end
	if not tr then drawRect(x + w - borderSize, y, borderSize, borderSize) end
	if not bl then drawRect(x, y + h - borderSize, borderSize, borderSize) end
	if not br then drawRect(x + w - borderSize, y + h - borderSize, borderSize, borderSize) end
end

function PIXEL.DrawFullRoundedBox(borderSize, x, y, w, h, col)
	return PIXEL.DrawFullRoundedBoxEx(borderSize, x, y, w, h, col, true, true, true, true)
end
--addons/aocrp_pixelui/lua/pixelui/elements/cl_slider.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

function PANEL:Init()
    self.Fraction = 0

    self.Grip = vgui.Create("PIXEL.ImgurButton", self)
    self.Grip:NoClipping(true)

    self.Grip:SetImgurID("E8QbV5i")
    self.Grip:SetNormalColor(PIXEL.CopyColor(PIXEL.Colors.Primary))
    self.Grip:SetHoverColor(PIXEL.OffsetColor(PIXEL.Colors.Primary, -15))
    self.Grip:SetClickColor(PIXEL.OffsetColor(PIXEL.Colors.Primary, 15))

    self.Grip.OnCursorMoved = function(pnl, x, y)
        if not pnl.Depressed then return end

        x, y = pnl:LocalToScreen(x, y)
        x = self:ScreenToLocal(x, y)

        self.Fraction = math.Clamp(x / self:GetWide(), 0, 1)

        self:OnValueChanged(self.Fraction)
        self:InvalidateLayout()
    end

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 20)
    self.FillCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 10)
end

function PANEL:OnMousePressed()
    local w = self:GetWide()

    self.Fraction = math.Clamp(self:CursorPos() / w, 0, 1)
    self:OnValueChanged(self.Fraction)
    self:InvalidateLayout()
end

function PANEL:OnValueChanged(fraction) end

function PANEL:Paint(w, h)
    local rounding = h * .5
    PIXEL.DrawRoundedBox(rounding, 0, 0, w, h, self.BackgroundCol)
    PIXEL.DrawRoundedBox(rounding, 0, 0, self.Fraction * w, h, self.FillCol)
end

function PANEL:PerformLayout(w, h)
    local gripSize = h + PIXEL.Scale(6)
    local offset = PIXEL.Scale(3)
    self.Grip:SetSize(gripSize, gripSize)
    self.Grip:SetPos((self.Fraction * w) - (gripSize * .5), -offset)
end

vgui.Register("PIXEL.Slider", PANEL, "PIXEL.Button")
--lua/autorun/sw_imperial_seats.lua:

-- Don't try to edit this file if you're trying to add new vehicles
-- Just make a new file and copy the format below.

local function AddVehicle( t, class )
	list.Set( "Vehicles", class, t )
end

local Category = "Star Wars Seats"

AddVehicle( {
	-- Required information
	Name = "Emperors Throne",
	Model = "models/KingPommes/starwars/misc/seats/palp_chair_full.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Emperors Throne",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "emperors_throne" )

AddVehicle( {
	-- Required information
	Name = "Imperial Conferencechair",
	Model = "models/KingPommes/starwars/misc/seats/imp_chaira.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Imperial Covfefe-chair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "imperial_conference_chair" )

AddVehicle( {
	-- Required information
	Name = "Tarkins Conferencechair",
	Model = "models/KingPommes/starwars/misc/seats/imp_chairb.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Tarkins Covfefe-chair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "tarkins_conference_chair" )


AddVehicle( {
	-- Required information
	Name = "Senat Armchair",
	Model = "models/KingPommes/starwars/misc/seats/imp_armchair.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Senat Armchair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "senat_armchair" )

AddVehicle( {
	-- Required information
	Name = "Bridgecrew Seat",
	Model = "models/lordtrilobite/starwars/props/imp_chair01.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "Lord Trilobite",
	Information = "Bridgecrew Seat",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "bridgecrew_seat" )

--addons/vyhub-gmod/lua/vyhub/lib/date.lua:
VyHub.Lib.date = VyHub.Lib.date or {}

---------------------------------------------------------------------------------------
-- Module for date and time calculations
--
-- Version 2.2
-- Copyright (C) 2005-2006, by Jas Latrix (jastejada@yahoo.com)
-- Copyright (C) 2013-2021, by Thijs Schreijer
-- Licensed under MIT, http://opensource.org/licenses/MIT

-- https://github.com/Tieske/date

-- Changes by Matbyte: New function setbias

--[[ CONSTANTS ]]--
local HOURPERDAY  = 24
local MINPERHOUR  = 60
local MINPERDAY    = 1440  -- 24*60
local SECPERMIN   = 60
local SECPERHOUR  = 3600  -- 60*60
local SECPERDAY   = 86400 -- 24*60*60
local TICKSPERSEC = 1000000
local TICKSPERDAY = 86400000000
local TICKSPERHOUR = 3600000000
local TICKSPERMIN = 60000000
local DAYNUM_MAX =  365242500 -- Sat Jan 01 1000000 00:00:00
local DAYNUM_MIN = -365242500 -- Mon Jan 01 1000000 BCE 00:00:00
local DAYNUM_DEF =  0 -- Mon Jan 01 0001 00:00:00
local _;
--[[ GLOBAL SETTINGS ]]--
local centuryflip = 0 -- year >= centuryflip == 1900, < centuryflip == 2000
--[[ LOCAL ARE FASTER ]]--
local type     = type
local pairs    = pairs
local error    = error
local assert   = assert
local tonumber = tonumber
local tostring = tostring
local string   = string
local math     = math
local os       = os
local unpack   = unpack or table.unpack
local setmetatable = setmetatable
local getmetatable = getmetatable
--[[ EXTRA FUNCTIONS ]]--
local fmt  = string.format
local lwr  = string.lower
local rep  = string.rep
local len  = string.len  -- luacheck: ignore
local sub  = string.sub
local gsub = string.gsub
local gmatch = string.gmatch or string.gfind
local find = string.find
local ostime = os.time
local osdate = os.date
local floor = math.floor
local ceil  = math.ceil
local abs   = math.abs
-- removes the decimal part of a number
local function fix(n) n = tonumber(n) return n and ((n > 0 and floor or ceil)(n)) end
-- returns the modulo n % d;
local function mod(n,d) return n - d*floor(n/d) end
-- is `str` in string list `tbl`, `ml` is the minimun len
local function inlist(str, tbl, ml, tn)
  local sl = len(str)
  if sl < (ml or 0) then return nil end
  str = lwr(str)
  for k, v in pairs(tbl) do
    if str == lwr(sub(v, 1, sl)) then
      if tn then tn[0] = k end
      return k
    end
  end
end
local function fnil() end
--[[ DATE FUNCTIONS ]]--
local DATE_EPOCH -- to be set later
local sl_weekdays = {
  [0]="Sunday",[1]="Monday",[2]="Tuesday",[3]="Wednesday",[4]="Thursday",[5]="Friday",[6]="Saturday",
  [7]="Sun",[8]="Mon",[9]="Tue",[10]="Wed",[11]="Thu",[12]="Fri",[13]="Sat",
}
local sl_meridian = {[-1]="AM", [1]="PM"}
local sl_months = {
  [00]="January", [01]="February", [02]="March",
  [03]="April",   [04]="May",      [05]="June",
  [06]="July",    [07]="August",   [08]="September",
  [09]="October", [10]="November", [11]="December",
  [12]="Jan", [13]="Feb", [14]="Mar",
  [15]="Apr", [16]="May", [17]="Jun",
  [18]="Jul", [19]="Aug", [20]="Sep",
  [21]="Oct", [22]="Nov", [23]="Dec",
}
-- added the '.2'  to avoid collision, use `fix` to remove
local sl_timezone = {
  [000]="utc",    [0.2]="gmt",
  [300]="est",    [240]="edt",
  [360]="cst",  [300.2]="cdt",
  [420]="mst",  [360.2]="mdt",
  [480]="pst",  [420.2]="pdt",
}
-- set the day fraction resolution
local function setticks(t)
  TICKSPERSEC = t;
  TICKSPERDAY = SECPERDAY*TICKSPERSEC
  TICKSPERHOUR= SECPERHOUR*TICKSPERSEC
  TICKSPERMIN = SECPERMIN*TICKSPERSEC
end
-- is year y leap year?
local function isleapyear(y) -- y must be int!
  return (mod(y, 4) == 0 and (mod(y, 100) ~= 0 or mod(y, 400) == 0))
end
-- day since year 0
local function dayfromyear(y) -- y must be int!
  return 365*y + floor(y/4) - floor(y/100) + floor(y/400)
end
-- day number from date, month is zero base
local function makedaynum(y, m, d)
  local mm = mod(mod(m,12) + 10, 12)
  return dayfromyear(y + floor(m/12) - floor(mm/10)) + floor((mm*306 + 5)/10) + d - 307
  --local yy = y + floor(m/12) - floor(mm/10)
  --return dayfromyear(yy) + floor((mm*306 + 5)/10) + (d - 1)
end
-- date from day number, month is zero base
local function breakdaynum(g)
  local g = g + 306
  local y = floor((10000*g + 14780)/3652425)
  local d = g - dayfromyear(y)
  if d < 0 then y = y - 1; d = g - dayfromyear(y) end
  local mi = floor((100*d + 52)/3060)
  return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)
end
--[[ for floats or int32 Lua Number data type
local function breakdaynum2(g)
  local g, n = g + 306;
  local n400 = floor(g/DI400Y);n = mod(g,DI400Y);
  local n100 = floor(n/DI100Y);n = mod(n,DI100Y);
  local n004 = floor(n/DI4Y);   n = mod(n,DI4Y);
  local n001 = floor(n/365);   n = mod(n,365);
  local y = (n400*400) + (n100*100) + (n004*4) + n001  - ((n001 == 4 or n100 == 4) and 1 or 0)
  local d = g - dayfromyear(y)
  local mi = floor((100*d + 52)/3060)
  return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)
end
]]
-- day fraction from time
local function makedayfrc(h,r,s,t)
  return ((h*60 + r)*60 + s)*TICKSPERSEC + t
end
-- time from day fraction
local function breakdayfrc(df)
  return
    mod(floor(df/TICKSPERHOUR),HOURPERDAY),
    mod(floor(df/TICKSPERMIN ),MINPERHOUR),
    mod(floor(df/TICKSPERSEC ),SECPERMIN),
    mod(df,TICKSPERSEC)
end
-- weekday sunday = 0, monday = 1 ...
local function weekday(dn) return mod(dn + 1, 7) end
-- yearday 0 based ...
local function yearday(dn)
   return dn - dayfromyear((breakdaynum(dn))-1)
end
-- parse v as a month
local function getmontharg(v)
  local m = tonumber(v);
  return (m and fix(m - 1)) or inlist(tostring(v) or "", sl_months, 2)
end
-- get daynum of isoweek one of year y
local function isow1(y)
  local f = makedaynum(y, 0, 4) -- get the date for the 4-Jan of year `y`
  local d = weekday(f)
  d = d == 0 and 7 or d -- get the ISO day number, 1 == Monday, 7 == Sunday
  return f + (1 - d)
end
local function isowy(dn)
  local w1;
  local y = (breakdaynum(dn))
  if dn >= makedaynum(y, 11, 29) then
    w1 = isow1(y + 1);
    if dn < w1 then
      w1 = isow1(y);
    else
        y = y + 1;
    end
  else
    w1 = isow1(y);
    if dn < w1 then
      w1 = isow1(y-1)
      y = y - 1
    end
  end
  return floor((dn-w1)/7)+1, y
end
local function isoy(dn)
  local y = (breakdaynum(dn))
  return y + (((dn >= makedaynum(y, 11, 29)) and (dn >= isow1(y + 1))) and 1 or (dn < isow1(y) and -1 or 0))
end
local function makedaynum_isoywd(y,w,d)
  return isow1(y) + 7*w + d - 8 -- simplified: isow1(y) + ((w-1)*7) + (d-1)
end
--[[ THE DATE MODULE ]]--
local fmtstr  = "%x %X";
--#if not DATE_OBJECT_AFX then
local date = {}
setmetatable(date, date)
-- Version:  VMMMRRRR; V-Major, M-Minor, R-Revision;  e.g. 5.45.321 == 50450321
do
  local major = 2
  local minor = 2
  local revision = 0
  date.version = major * 10000000 + minor * 10000 + revision
end
--#end -- not DATE_OBJECT_AFX
--[[ THE DATE OBJECT ]]--
local dobj = {}
dobj.__index = dobj
dobj.__metatable = dobj
-- shout invalid arg
local function date_error_arg() return error("invalid argument(s)",0) end
-- create new date object
local function date_new(dn, df)
  return setmetatable({daynum=dn, dayfrc=df}, dobj)
end

--#if not NO_LOCAL_TIME_SUPPORT then
-- magic year table
local date_epoch, yt;
local function getequivyear(y)
  assert(not yt)
  yt = {}
  local de = date_epoch:copy()
  local dw, dy
  for _ = 0, 3000 do
    de:setyear(de:getyear() + 1, 1, 1)
    dy = de:getyear()
    dw = de:getweekday() * (isleapyear(dy) and  -1 or 1)
    if not yt[dw] then yt[dw] = dy end  --print(de)
    if yt[1] and yt[2] and yt[3] and yt[4] and yt[5] and yt[6] and yt[7] and yt[-1] and yt[-2] and yt[-3] and yt[-4] and yt[-5] and yt[-6] and yt[-7] then
      getequivyear = function(y)  return yt[ (weekday(makedaynum(y, 0, 1)) + 1) * (isleapyear(y) and  -1 or 1) ]  end
      return getequivyear(y)
    end
  end
end
-- TimeValue from date and time
local function totv(y,m,d,h,r,s)
  return (makedaynum(y, m, d) - DATE_EPOCH) * SECPERDAY  + ((h*60 + r)*60 + s)
end
-- TimeValue from TimeTable
local function tmtotv(tm)
  return tm and totv(tm.year, tm.month - 1, tm.day, tm.hour, tm.min, tm.sec)
end
-- Returns the bias in seconds of utc time daynum and dayfrc
local function getbiasutc2(self)
  local y,m,d = breakdaynum(self.daynum)
  local h,r,s = breakdayfrc(self.dayfrc)
  local tvu = totv(y,m,d,h,r,s) -- get the utc TimeValue of date and time
  local tml = osdate("*t", tvu) -- get the local TimeTable of tvu
  if (not tml) or (tml.year > (y+1) or tml.year < (y-1)) then -- failed try the magic
    y = getequivyear(y)
    tvu = totv(y,m,d,h,r,s)
    tml = osdate("*t", tvu)
  end
  local tvl = tmtotv(tml)
  if tvu and tvl then
    return tvu - tvl, tvu, tvl
  else
    return error("failed to get bias from utc time")
  end
end
-- Returns the bias in seconds of local time daynum and dayfrc
local function getbiasloc2(daynum, dayfrc)
  local tvu
  -- extract date and time
  local y,m,d = breakdaynum(daynum)
  local h,r,s = breakdayfrc(dayfrc)
  -- get equivalent TimeTable
  local tml = {year=y, month=m+1, day=d, hour=h, min=r, sec=s}
  -- get equivalent TimeValue
  local tvl = tmtotv(tml)

  local function chkutc()
    tml.isdst =  nil; local tvug = ostime(tml) if tvug and (tvl == tmtotv(osdate("*t", tvug))) then tvu = tvug return end
    tml.isdst = true; local tvud = ostime(tml) if tvud and (tvl == tmtotv(osdate("*t", tvud))) then tvu = tvud return end
    tvu = tvud or tvug
  end
  chkutc()
  if not tvu then
    tml.year = getequivyear(y)
    tvl = tmtotv(tml)
    chkutc()
  end
  return ((tvu and tvl) and (tvu - tvl)) or error("failed to get bias from local time"), tvu, tvl
end
--#end -- not NO_LOCAL_TIME_SUPPORT

--#if not DATE_OBJECT_AFX then
-- the date parser
local strwalker = {} -- ^Lua regular expression is not as powerful as Perl$
strwalker.__index = strwalker
local function newstrwalker(s)return setmetatable({s=s, i=1, e=1, c=len(s)}, strwalker) end
function strwalker:aimchr() return "\n" .. self.s .. "\n" .. rep(".",self.e-1) .. "^" end
function strwalker:finish() return self.i > self.c  end
function strwalker:back()  self.i = self.e return self  end
function strwalker:restart() self.i, self.e = 1, 1 return self end
function strwalker:match(s)  return (find(self.s, s, self.i)) end
function strwalker:__call(s, f)-- print("strwalker:__call "..s..self:aimchr())
  local is, ie; is, ie, self[1], self[2], self[3], self[4], self[5] = find(self.s, s, self.i)
  if is then self.e, self.i = self.i, 1+ie; if f then f(unpack(self)) end return self end
end
 local function date_parse(str)
  local y,m,d, h,r,s,  z,  w,u, j,  e,  x,c,  dn,df
  local sw = newstrwalker(gsub(gsub(str, "(%b())", ""),"^(%s*)","")) -- remove comment, trim leading space
  --local function error_out() print(y,m,d,h,r,s) end
  local function error_dup(q) --[[error_out()]] error("duplicate value: " .. (q or "") .. sw:aimchr()) end
  local function error_syn(q) --[[error_out()]] error("syntax error: " .. (q or "") .. sw:aimchr()) end
  local function error_inv(q) --[[error_out()]] error("invalid date: " .. (q or "") .. sw:aimchr()) end
  local function sety(q) y = y and error_dup() or tonumber(q); end
  local function setm(q) m = (m or w or j) and error_dup(m or w or j) or tonumber(q) end
  local function setd(q) d = d and error_dup() or tonumber(q) end
  local function seth(q) h = h and error_dup() or tonumber(q) end
  local function setr(q) r = r and error_dup() or tonumber(q) end
  local function sets(q) s = s and error_dup() or tonumber(q) end
  local function adds(q) s = s + tonumber(q) end
  local function setj(q) j = (m or w or j) and error_dup() or tonumber(q); end
  local function setz(q) z = (z ~= 0 and z) and error_dup() or q end
  local function setzn(zs,zn) zn = tonumber(zn); setz( ((zn<24) and (zn*60) or (mod(zn,100) + floor(zn/100) * 60))*( zs=='+' and -1 or 1) ) end
  local function setzc(zs,zh,zm) setz( ((tonumber(zh)*60) + tonumber(zm))*( zs=='+' and -1 or 1) ) end

  if not (sw("^(%d%d%d%d)",sety) and (sw("^(%-?)(%d%d)%1(%d%d)",function(_,a,b) setm(tonumber(a)); setd(tonumber(b)) end) or sw("^(%-?)[Ww](%d%d)%1(%d?)",function(_,a,b) w, u = tonumber(a), tonumber(b or 1) end) or sw("^%-?(%d%d%d)",setj) or sw("^%-?(%d%d)",function(a) setm(a);setd(1) end))
  and ((sw("^%s*[Tt]?(%d%d):?",seth) and sw("^(%d%d):?",setr) and sw("^(%d%d)",sets) and sw("^(%.%d+)",adds))
    or sw:finish() or (sw"^%s*$" or sw"^%s*[Zz]%s*$" or sw("^%s-([%+%-])(%d%d):?(%d%d)%s*$",setzc) or sw("^%s*([%+%-])(%d%d)%s*$",setzn))
    )  )
  then --print(y,m,d,h,r,s,z,w,u,j)
  sw:restart(); y,m,d,h,r,s,z,w,u,j = nil,nil,nil,nil,nil,nil,nil,nil,nil,nil
    repeat -- print(sw:aimchr())
      if sw("^[tT:]?%s*(%d%d?):",seth) then --print("$Time")
        _ = sw("^%s*(%d%d?)",setr) and sw("^%s*:%s*(%d%d?)",sets) and sw("^(%.%d+)",adds)
      elseif sw("^(%d+)[/\\%s,-]?%s*") then --print("$Digits")
        x, c = tonumber(sw[1]), len(sw[1])
        if (x >= 70) or (m and d and (not y)) or (c > 3) then
          sety( x + ((x >= 100 or c>3) and 0 or x<centuryflip and 2000 or 1900) )
        else
          if m then setd(x) else m = x end
        end
      elseif sw("^(%a+)[/\\%s,-]?%s*") then --print("$Words")
        x = sw[1]
        if inlist(x, sl_months,   2, sw) then
          if m and (not d) and (not y) then d, m = m, false end
          setm(mod(sw[0],12)+1)
        elseif inlist(x, sl_timezone, 2, sw) then
          c = fix(sw[0]) -- ignore gmt and utc
          if c ~= 0 then setz(c, x) end
        elseif not inlist(x, sl_weekdays, 2, sw) then
          sw:back()
          -- am pm bce ad ce bc
          if sw("^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*[Ee]%s*(%2)%s*") or sw("^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*") then
            e = e and error_dup() or -1
          elseif sw("^([aA])%s*(%.?)%s*[Dd]%s*(%2)%s*") or sw("^([cC])%s*(%.?)%s*[Ee]%s*(%2)%s*") then
            e = e and error_dup() or 1
          elseif sw("^([PApa])%s*(%.?)%s*[Mm]?%s*(%2)%s*") then
            x = lwr(sw[1]) -- there should be hour and it must be correct
            if (not h) or (h > 12) or (h < 0) then return error_inv() end
            if x == 'a' and h == 12 then h = 0 end -- am
            if x == 'p' and h ~= 12 then h = h + 12 end -- pm
          else error_syn() end
        end
      elseif not(sw("^([+-])(%d%d?):(%d%d)",setzc) or sw("^([+-])(%d+)",setzn) or sw("^[Zz]%s*$")) then -- sw{"([+-])",{"(%d%d?):(%d%d)","(%d+)"}}
        error_syn("?")
      end
    sw("^%s*")  until sw:finish()
  --else print("$Iso(Date|Time|Zone)")
  end
  -- if date is given, it must be complete year, month & day
  if (not y and not h) or ((m and not d) or (d and not m)) or ((m and w) or (m and j) or (j and w)) then return error_inv("!") end
  -- fix month
  if m then m = m - 1 end
  -- fix year if we are on BCE
  if e and e < 0 and y > 0 then y = 1 - y end
  --  create date object
  dn = (y and ((w and makedaynum_isoywd(y,w,u)) or (j and makedaynum(y, 0, j)) or makedaynum(y, m, d))) or DAYNUM_DEF
  df = makedayfrc(h or 0, r or 0, s or 0, 0) + ((z or 0)*TICKSPERMIN)
  --print("Zone",h,r,s,z,m,d,y,df)
  return date_new(dn, df) -- no need to :normalize();
 end
local function date_fromtable(v)
  local y, m, d = fix(v.year), getmontharg(v.month), fix(v.day)
  local h, r, s, t = tonumber(v.hour), tonumber(v.min), tonumber(v.sec), tonumber(v.ticks)
  -- atleast there is time or complete date
  if (y or m or d) and (not(y and m and d)) then return error("incomplete table")  end
  return (y or h or r or s or t) and date_new(y and makedaynum(y, m, d) or DAYNUM_DEF, makedayfrc(h or 0, r or 0, s or 0, t or 0))
end
local tmap = {
  ['number'] = function(v) return date_epoch:copy():addseconds(v) end,
  ['string'] = function(v) return date_parse(v) end,
  ['boolean']= function(v) return date_fromtable(osdate(v and "!*t" or "*t")) end,
  ['table']  = function(v) local ref = getmetatable(v) == dobj; return ref and v or date_fromtable(v), ref end
}
local function date_getdobj(v)
  local o, r = (tmap[type(v)] or fnil)(v);
  return (o and o:normalize() or error"invalid date time value"), r -- if r is true then o is a reference to a date obj
end
--#end -- not DATE_OBJECT_AFX
local function date_from(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
  local y, m, d = fix(arg1), getmontharg(arg2), fix(arg3)
  local h, r, s, t = tonumber(arg4 or 0), tonumber(arg5 or 0), tonumber(arg6 or 0), tonumber(arg7 or 0)
  if y and m and d and h and r and s and t then
    return date_new(makedaynum(y, m, d), makedayfrc(h, r, s, t)):normalize()
  else
    return date_error_arg()
  end
end

--[[ THE DATE OBJECT METHODS ]]--
function dobj:normalize()
  local dn, df = fix(self.daynum), self.dayfrc
  self.daynum, self.dayfrc = dn + floor(df/TICKSPERDAY), mod(df, TICKSPERDAY)
  return (dn >= DAYNUM_MIN and dn <= DAYNUM_MAX) and self or error("date beyond imposed limits:"..self)
end

function dobj:getdate()  local y, m, d = breakdaynum(self.daynum) return y, m+1, d end
function dobj:gettime()  return breakdayfrc(self.dayfrc) end

function dobj:getclockhour() local h = self:gethours() return h>12 and mod(h,12) or (h==0 and 12 or h) end

function dobj:getyearday() return yearday(self.daynum) + 1 end
function dobj:getweekday() return weekday(self.daynum) + 1 end   -- in lua weekday is sunday = 1, monday = 2 ...

function dobj:getyear()   local r,_,_ = breakdaynum(self.daynum)  return r end
function dobj:getmonth() local _,r,_ = breakdaynum(self.daynum)  return r+1 end-- in lua month is 1 base
function dobj:getday()   local _,_,r = breakdaynum(self.daynum)  return r end
function dobj:gethours()  return mod(floor(self.dayfrc/TICKSPERHOUR),HOURPERDAY) end
function dobj:getminutes()  return mod(floor(self.dayfrc/TICKSPERMIN), MINPERHOUR) end
function dobj:getseconds()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)  end
function dobj:getfracsec()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)+(mod(self.dayfrc,TICKSPERSEC)/TICKSPERSEC) end
function dobj:getticks(u)  local x = mod(self.dayfrc,TICKSPERSEC) return u and ((x*u)/TICKSPERSEC) or x  end

function dobj:getweeknumber(wdb)
  local wd, yd = weekday(self.daynum), yearday(self.daynum)
  if wdb then
    wdb = tonumber(wdb)
    if wdb then
      wd = mod(wd-(wdb-1),7)-- shift the week day base
    else
      return date_error_arg()
    end
  end
  return (yd < wd and 0) or (floor(yd/7) + ((mod(yd, 7)>=wd) and 1 or 0))
end

function dobj:getisoweekday() return mod(weekday(self.daynum)-1,7)+1 end   -- sunday = 7, monday = 1 ...
function dobj:getisoweeknumber() return (isowy(self.daynum)) end
function dobj:getisoyear() return isoy(self.daynum)  end
function dobj:getisodate()
  local w, y = isowy(self.daynum)
  return y, w, self:getisoweekday()
end
function dobj:setisoyear(y, w, d)
  local cy, cw, cd = self:getisodate()
  if y then cy = fix(tonumber(y))end
  if w then cw = fix(tonumber(w))end
  if d then cd = fix(tonumber(d))end
  if cy and cw and cd then
    self.daynum = makedaynum_isoywd(cy, cw, cd)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:setisoweekday(d)    return self:setisoyear(nil, nil, d) end
function dobj:setisoweeknumber(w,d)  return self:setisoyear(nil, w, d)  end

function dobj:setyear(y, m, d)
  local cy, cm, cd = breakdaynum(self.daynum)
  if y then cy = fix(tonumber(y))end
  if m then cm = getmontharg(m)  end
  if d then cd = fix(tonumber(d))end
  if cy and cm and cd then
    self.daynum  = makedaynum(cy, cm, cd)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:setmonth(m, d)return self:setyear(nil, m, d) end
function dobj:setday(d)    return self:setyear(nil, nil, d) end

function dobj:sethours(h, m, s, t)
  local ch,cm,cs,ck = breakdayfrc(self.dayfrc)
  ch, cm, cs, ck = tonumber(h or ch), tonumber(m or cm), tonumber(s or cs), tonumber(t or ck)
  if ch and cm and cs and ck then
    self.dayfrc = makedayfrc(ch, cm, cs, ck)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:setminutes(m,s,t)  return self:sethours(nil,   m,   s, t) end
function dobj:setseconds(s, t)  return self:sethours(nil, nil,   s, t) end
function dobj:setticks(t)    return self:sethours(nil, nil, nil, t) end

function dobj:spanticks()  return (self.daynum*TICKSPERDAY + self.dayfrc) end
function dobj:spanseconds()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERSEC  end
function dobj:spanminutes()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERMIN  end
function dobj:spanhours()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERHOUR end
function dobj:spandays()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERDAY  end

function dobj:addyears(y, m, d)
  local cy, cm, cd = breakdaynum(self.daynum)
  if y then y = fix(tonumber(y))else y = 0 end
  if m then m = fix(tonumber(m))else m = 0 end
  if d then d = fix(tonumber(d))else d = 0 end
  if y and m and d then
    self.daynum  = makedaynum(cy+y, cm+m, cd+d)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:addmonths(m, d)
  return self:addyears(nil, m, d)
end

local function dobj_adddayfrc(self,n,pt,pd)
  n = tonumber(n)
  if n then
    local x = floor(n/pd);
    self.daynum = self.daynum + x;
    self.dayfrc = self.dayfrc + (n-x*pd)*pt;
    return self:normalize()
  else
    return date_error_arg()
  end
end
function dobj:adddays(n)  return dobj_adddayfrc(self,n,TICKSPERDAY,1) end
function dobj:addhours(n)  return dobj_adddayfrc(self,n,TICKSPERHOUR,HOURPERDAY) end
function dobj:addminutes(n)  return dobj_adddayfrc(self,n,TICKSPERMIN,MINPERDAY)  end
function dobj:addseconds(n)  return dobj_adddayfrc(self,n,TICKSPERSEC,SECPERDAY)  end
function dobj:addticks(n)  return dobj_adddayfrc(self,n,1,TICKSPERDAY) end
local tvspec = {
  -- Abbreviated weekday name (Sun)
  ['%a']=function(self) return sl_weekdays[weekday(self.daynum) + 7] end,
  -- Full weekday name (Sunday)
  ['%A']=function(self) return sl_weekdays[weekday(self.daynum)] end,
  -- Abbreviated month name (Dec)
  ['%b']=function(self) return sl_months[self:getmonth() - 1 + 12] end,
  -- Full month name (December)
  ['%B']=function(self) return sl_months[self:getmonth() - 1] end,
  -- Year/100 (19, 20, 30)
  ['%C']=function(self) return fmt("%.2d", fix(self:getyear()/100)) end,
  -- The day of the month as a number (range 1 - 31)
  ['%d']=function(self) return fmt("%.2d", self:getday())  end,
  -- year for ISO 8601 week, from 00 (79)
  ['%g']=function(self) return fmt("%.2d", mod(self:getisoyear() ,100)) end,
  -- year for ISO 8601 week, from 0000 (1979)
  ['%G']=function(self) return fmt("%.4d", self:getisoyear()) end,
  -- same as %b
  ['%h']=function(self) return self:fmt0("%b") end,
  -- hour of the 24-hour day, from 00 (06)
  ['%H']=function(self) return fmt("%.2d", self:gethours()) end,
  -- The  hour as a number using a 12-hour clock (01 - 12)
  ['%I']=function(self) return fmt("%.2d", self:getclockhour()) end,
  -- The day of the year as a number (001 - 366)
  ['%j']=function(self) return fmt("%.3d", self:getyearday())  end,
  -- Month of the year, from 01 to 12
  ['%m']=function(self) return fmt("%.2d", self:getmonth())  end,
  -- Minutes after the hour 55
  ['%M']=function(self) return fmt("%.2d", self:getminutes())end,
  -- AM/PM indicator (AM)
  ['%p']=function(self) return sl_meridian[self:gethours() > 11 and 1 or -1] end, --AM/PM indicator (AM)
  -- The second as a number (59, 20 , 01)
  ['%S']=function(self) return fmt("%.2d", self:getseconds())  end,
  -- ISO 8601 day of the week, to 7 for Sunday (7, 1)
  ['%u']=function(self) return self:getisoweekday() end,
  -- Sunday week of the year, from 00 (48)
  ['%U']=function(self) return fmt("%.2d", self:getweeknumber()) end,
  -- ISO 8601 week of the year, from 01 (48)
  ['%V']=function(self) return fmt("%.2d", self:getisoweeknumber()) end,
  -- The day of the week as a decimal, Sunday being 0
  ['%w']=function(self) return self:getweekday() - 1 end,
  -- Monday week of the year, from 00 (48)
  ['%W']=function(self) return fmt("%.2d", self:getweeknumber(2)) end,
  -- The year as a number without a century (range 00 to 99)
  ['%y']=function(self) return fmt("%.2d", mod(self:getyear() ,100)) end,
  -- Year with century (2000, 1914, 0325, 0001)
  ['%Y']=function(self) return fmt("%.4d", self:getyear()) end,
  -- Time zone offset, the date object is assumed local time (+1000, -0230)
  ['%z']=function(self) local b = -self:getbias(); local x = abs(b); return fmt("%s%.4d", b < 0 and "-" or "+", fix(x/60)*100 + floor(mod(x,60))) end,
  -- Time zone name, the date object is assumed local time
  ['%Z']=function(self) return self:gettzname() end,
  -- Misc --
  -- Year, if year is in BCE, prints the BCE Year representation, otherwise result is similar to "%Y" (1 BCE, 40 BCE)
  ['%\b']=function(self) local x = self:getyear() return fmt("%.4d%s", x>0 and x or (-x+1), x>0 and "" or " BCE") end,
  -- Seconds including fraction (59.998, 01.123)
  ['%\f']=function(self) local x = self:getfracsec() return fmt("%s%.9f",x >= 10 and "" or "0", x) end,
  -- percent character %
  ['%%']=function(self) return "%" end,
  -- Group Spec --
  -- 12-hour time, from 01:00:00 AM (06:55:15 AM); same as "%I:%M:%S %p"
  ['%r']=function(self) return self:fmt0("%I:%M:%S %p") end,
  -- hour:minute, from 01:00 (06:55); same as "%I:%M"
  ['%R']=function(self) return self:fmt0("%I:%M")  end,
  -- 24-hour time, from 00:00:00 (06:55:15); same as "%H:%M:%S"
  ['%T']=function(self) return self:fmt0("%H:%M:%S") end,
  -- month/day/year from 01/01/00 (12/02/79); same as "%m/%d/%y"
  ['%D']=function(self) return self:fmt0("%m/%d/%y") end,
  -- year-month-day (1979-12-02); same as "%Y-%m-%d"
  ['%F']=function(self) return self:fmt0("%Y-%m-%d") end,
  -- The preferred date and time representation;  same as "%x %X"
  ['%c']=function(self) return self:fmt0("%x %X") end,
  -- The preferred date representation, same as "%a %b %d %\b"
  ['%x']=function(self) return self:fmt0("%a %b %d %\b") end,
  -- The preferred time representation, same as "%H:%M:%\f"
  ['%X']=function(self) return self:fmt0("%H:%M:%\f") end,
  -- GroupSpec --
  -- Iso format, same as "%Y-%m-%dT%T"
  ['${iso}'] = function(self) return self:fmt0("%Y-%m-%dT%T") end,
  -- http format, same as "%a, %d %b %Y %T GMT"
  ['${http}'] = function(self) return self:fmt0("%a, %d %b %Y %T GMT") end,
  -- ctime format, same as "%a %b %d %T GMT %Y"
  ['${ctime}'] = function(self) return self:fmt0("%a %b %d %T GMT %Y") end,
  -- RFC850 format, same as "%A, %d-%b-%y %T GMT"
  ['${rfc850}'] = function(self) return self:fmt0("%A, %d-%b-%y %T GMT") end,
  -- RFC1123 format, same as "%a, %d %b %Y %T GMT"
  ['${rfc1123}'] = function(self) return self:fmt0("%a, %d %b %Y %T GMT") end,
  -- asctime format, same as "%a %b %d %T %Y"
  ['${asctime}'] = function(self) return self:fmt0("%a %b %d %T %Y") end,
}
function dobj:fmt0(str) return (gsub(str, "%%[%a%%\b\f]", function(x) local f = tvspec[x];return (f and f(self)) or x end)) end
function dobj:fmt(str)
  str = str or self.fmtstr or fmtstr
  return self:fmt0((gmatch(str, "${%w+}")) and (gsub(str, "${%w+}", function(x)local f=tvspec[x];return (f and f(self)) or x end)) or str)
end

function dobj.__lt(a, b) if (a.daynum == b.daynum) then return (a.dayfrc < b.dayfrc) else return (a.daynum < b.daynum) end end
function dobj.__le(a, b) if (a.daynum == b.daynum) then return (a.dayfrc <= b.dayfrc) else return (a.daynum <= b.daynum) end end
function dobj.__eq(a, b)return (a.daynum == b.daynum) and (a.dayfrc == b.dayfrc) end
function dobj.__sub(a,b)
  local d1, d2 = date_getdobj(a), date_getdobj(b)
  local d0 = d1 and d2 and date_new(d1.daynum - d2.daynum, d1.dayfrc - d2.dayfrc)
  return d0 and d0:normalize()
end
function dobj.__add(a,b)
  local d1, d2 = date_getdobj(a), date_getdobj(b)
  local d0 = d1 and d2 and date_new(d1.daynum + d2.daynum, d1.dayfrc + d2.dayfrc)
  return d0 and d0:normalize()
end
function dobj.__concat(a, b) return tostring(a) .. tostring(b) end
function dobj:__tostring() return self:fmt() end

function dobj:copy() return date_new(self.daynum, self.dayfrc) end


function dobj:setbias(bias)
  self.bias = bias
  return self
end

--[[ THE LOCAL DATE OBJECT METHODS ]]--
function dobj:tolocal()
  local dn,df = self.daynum, self.dayfrc
  bias = self.bias or getbiasutc2(self)
  if bias != nil then
    -- utc = local + bias; local = utc - bias
    self.daynum = dn
    self.dayfrc = df - bias*TICKSPERSEC
    return self:normalize()
  else
    return nil
  end
end

function dobj:toutc()
  local dn,df = self.daynum, self.dayfrc
  local bias  = self.bias or getbiasloc2(dn, df)
  if bias then
    -- utc = local + bias;
    self.daynum = dn
    self.dayfrc = df + bias*TICKSPERSEC
    return self:normalize()
  else
    return nil
  end
end

function dobj:getbias()  return self.bias != nil and self.bias/SECPERMIN or (getbiasloc2(self.daynum, self.dayfrc))/SECPERMIN end

function dobj:gettzname()
  if self.bias != nil then return "" end

  local _, tvu, _ = getbiasloc2(self.daynum, self.dayfrc)
  return tvu and osdate("%Z",tvu) or ""
end

--#if not DATE_OBJECT_AFX then
function date.time(h, r, s, t)
  h, r, s, t = tonumber(h or 0), tonumber(r or 0), tonumber(s or 0), tonumber(t or 0)
  if h and r and s and t then
     return date_new(DAYNUM_DEF, makedayfrc(h, r, s, t))
  else
    return date_error_arg()
  end
end

function date:__call(arg1, ...)
  local arg_count = select("#", ...) + (arg1 == nil and 0 or 1)
  if arg_count  > 1 then return (date_from(arg1, ...))
  elseif arg_count == 0 then return (date_getdobj(false))
  else local o, r = date_getdobj(arg1);  return r and o:copy() or o end
end

date.diff = dobj.__sub

function date.isleapyear(v)
  local y = fix(v);
  if not y then
    y = date_getdobj(v)
    y = y and y:getyear()
  end
  return isleapyear(y+0)
end

function date.epoch() return date_epoch:copy()  end

function date.isodate(y,w,d) return date_new(makedaynum_isoywd(y + 0, w and (w+0) or 1, d and (d+0) or 1), 0)  end
function date.setcenturyflip(y)
  if y ~= floor(y) or y < 0 or y > 100 then date_error_arg() end
  centuryflip = y
end
function date.getcenturyflip() return centuryflip end

-- Internal functions
function date.fmt(str) if str then fmtstr = str end; return fmtstr end
function date.daynummin(n)  DAYNUM_MIN = (n and n < DAYNUM_MAX) and n or DAYNUM_MIN  return n and DAYNUM_MIN or date_new(DAYNUM_MIN, 0):normalize()end
function date.daynummax(n)  DAYNUM_MAX = (n and n > DAYNUM_MIN) and n or DAYNUM_MAX return n and DAYNUM_MAX or date_new(DAYNUM_MAX, 0):normalize()end
function date.ticks(t) if t then setticks(t) end return TICKSPERSEC  end
--#end -- not DATE_OBJECT_AFX

local tm = osdate("!*t", 0);
if tm then
  date_epoch = date_new(makedaynum(tm.year, tm.month - 1, tm.day), makedayfrc(tm.hour, tm.min, tm.sec, 0))
  -- the distance from our epoch to os epoch in daynum
  DATE_EPOCH = date_epoch and date_epoch:spandays()
else -- error will be raise only if called!
  date_epoch = setmetatable({},{__index = function() error("failed to get the epoch date") end})
end

--#if not DATE_OBJECT_AFX then
VyHub.Lib.date = date
--#else
--$return date_from
--#end


--lua/autorun/wg_hc.lua:
list.Set( "anakin_skywalker", "models/anakin_skywalker.mdl" )
player_manager.AddValidModel( "anakin_skywalker", "models/anakin_skywalker.mdl" )
player_manager.AddValidHands( "anakin_skywalker", "models/hands/anakin_hands.mdl", 1, "00000000" )

list.Set( "obiwan_kenobi", "models/obiwan_kenobi.mdl" )
player_manager.AddValidModel( "obiwan_kenobi", "models/obiwan_kenobi.mdl" )
player_manager.AddValidHands( "obiwan_kenobi", "models/hands/obiwan_hands.mdl", 1, "00000000" )

list.Set( "mace_windu", "models/mace_windu.mdl" )
player_manager.AddValidModel( "mace_windu", "models/mace_windu.mdl" )
player_manager.AddValidHands( "mace_windu", "models/hands/mace_hands.mdl", 1, "00000000" )

list.Set( "plo_koon", "models/plo_koon.mdl" )
player_manager.AddValidModel( "plo_koon", "models/plo_koon.mdl" )
player_manager.AddValidHands( "plo_koon", "models/hands/plo_hands.mdl", 1, "00000000" )

list.Set( "yoda", "models/yoda.mdl" )
player_manager.AddValidModel( "yoda", "models/yoda.mdl" )
player_manager.AddValidHands( "yoda", "models/hands/yoda_hands.mdl", 1, "00000000" )
--lua/wos/anim_extension/loader/loader.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Register:
		A simple register to keep track of all wiltOS extensions installed
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension = wOS.AnimExtension or {}
wOS.AnimExtension.Mounted = wOS.AnimExtension.Mounted or {}

local string = string
local file = file

local function _AddCSLuaFile( lua )

	if SERVER then
		AddCSLuaFile( lua )
	end
	
end

local function _include( load_type, lua )

	if load_type then
		include( lua )
	end
	
end

function wOS.AnimExtension:Autoloader()
	
	for _,source in pairs( file.Find( "wos/anim_extension/extensions/*", "LUA"), true ) do
		local lua = "wos/anim_extension/extensions/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
	_AddCSLuaFile( "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	_include( CLIENT, "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_metatable.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_metatable.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_metatable.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_holdtypes.lua" )

	_AddCSLuaFile( "wos/anim_extension/core/sh_prone_support.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_prone_support.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_prone_support.lua" )
	
	for _,source in pairs( file.Find( "wos/anim_extension/holdtypes/*", "LUA"), true ) do
		local lua = "wos/anim_extension/holdtypes/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
end

wOS.AnimExtension:Autoloader()
--addons/weapon_jedi/lua/wos/anim_extension/holdtypes/lscs_holdtypes.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Butterfly"
DATA.HoldType = "lscs_butterfly"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "vanguard_f_idle"
DATA.Translations[ACT_MP_WALK] = "walk_melee2"
DATA.Translations[ACT_MP_RUN] = "run_knife"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Shii-Cho"
DATA.HoldType = "lscs_shiicho"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "h_idle"
DATA.Translations[ACT_MP_WALK] = "walk_melee2"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Makashi"
DATA.HoldType = "lscs_makashi"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "phalanx_r_idle"
DATA.Translations[ACT_MP_WALK] = "walk_melee2"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Soresu"
DATA.HoldType = "lscs_soresu"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "judge_h_idle"
DATA.Translations[ACT_MP_WALK] = "walk_melee2"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Ataru"
DATA.HoldType = "lscs_ataru"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "vanguard_h_idle"
DATA.Translations[ACT_MP_WALK] = "walk_melee2"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Djem So"
DATA.HoldType = "lscs_djemso"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "judge_b_idle"
DATA.Translations[ACT_MP_WALK] = "walk_melee2"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Niman"
DATA.HoldType = "lscs_niman"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "b_idle"
DATA.Translations[ACT_MP_WALK] = "walk_lower"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Vaapad"
DATA.HoldType = "lscs_vaapad"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "phalanx_b_idle"
DATA.Translations[ACT_MP_WALK] = "walk_lower"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

local DATA = {}
DATA.Name = "[LSCS] HoldType Jarkai"
DATA.HoldType = "lscs_jarkai"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "b_idle"
DATA.Translations[ACT_MP_WALK] = "walk_lower"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype(DATA)

local DATA = {}
DATA.Name = "[LSCS] HoldType Ze'phra"
DATA.HoldType = "lscs_zephra"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ACT_MP_STAND_IDLE] = "b_idle"
DATA.Translations[ACT_MP_WALK] = "walk_lower"
DATA.Translations[ACT_MP_RUN] = "b_run"
wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/melee_combo.lua:
local DATA = {}

DATA.Name = "Melee Combination"
DATA.HoldType = "melee-combo"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

--DATA.Translations[ ACT_MP_STAND_IDLE ]					= 2680
--DATA.Translations[ ACT_MP_WALK ]						= 2683
--DATA.Translations[ ACT_MP_RUN ]							= 2685
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= ACT_HL2MP_IDLE_CROUCH_KNIFE 
DATA.Translations[ ACT_MP_CROUCHWALK ]					= ACT_HL2MP_WALK_CROUCH_KNIFE
--DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= 2688
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_JUMP ]						= 3160
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
--DATA.Translations[ ACT_LAND ]							= ACT_LAND

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/ee.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local ee = {
	
	-- Stats
	lag = "LAG",
	collisions = "KOKKUPÕRKED",
	props = "REKVISIIDID",
	propsFrozen = "KÜLMUNUD REKVISIIDID",
	npcs = "NPCS",
	vehicles = "MASINAD",
	players = "MÄNGIJAD",
	uptime = "UPTIME",
	entities = "ÜKSUSED",
	spawned = "SPAWNED",
	fps = "FPS",
	tickrate = "TICKRATE",
	runAntiLagMeasures = "ALUSTA ANTI-LAG MEETMEID",
	
	-- Users
	search = "Otsi",
	constraints = "PIIRANGUD",
	showEntities = "Näita üksuseid",
	hideEntities = "Peida üksused",
	resetMap = "Lähtesta maailm",
	freezeEntities = "Külmuta üksused",
	removeEntities = "Eemalda üksused",
	
	-- Global
	noCollideEntities = "No-Collide üksused",
	
	-- Lag
	heavyLag = "Raske lag tuvastatud!",
	lagIsStuck = "Hoiatus: lag on kinni!",
	crashPrevented = "Serveri krahh ära hoitud!",
	cleaningMap = "+ Koristan maailma...",
	removingEnts = "+ Eemaldan %s üksust",
	revertChanges = "+ Eemaldan %s üksust loodud viimase %s minuti jooksul",
	freezeingEnts = "+ Külmutan %s üksust",
	noCollidingEnts = "+ No Colliding %s üksust",
	offenderWarning = "%s sisaldab kahtlase arvuga üksuseid (%s), mis võivad viia lagini!",
	freezingAllEntities = "Külmuta kõik üksused (%s)",
	
	-- Dupes
	dupesNotEnabled = "Dupes ei ole selles serveris lubatud!",
	advDupesNotEnabled = "Advanced Dupes ei ole selles serveris lubatud!",
	dupeExceedsSize = "See dupe ületab maksimaalse suuruse piirangut! (suurus:%s, max:%s)",
	dupeInformation = "%s spawning dupe, mis sisaldab %s üksust ja %s piirangut",
	
	-- Notifications
	triggeredAntiLagMeasures = "triggered anti-lag mõõtmeid!",
	ranAntilagMeasures = "alustas anti-lag mõõtmeid!",
	hasNoEntities = "üksuseid pole!",
	youRemovedFrom = "Eemaldasid %s üksust %s'st!",
	removedYourObjects = "eemaldas sinu spawnitud objektid!",
	youFrozeFrom = "Külmutasid %s üksust %s poolt!",
	frozeYourObjects = "külmutas sinu spawnitud objektid!",
	enabledSpawnAbility = "lubas sul objekte spawnida!",
	disabledSpawnAbility = "keelas sul objekte spawnida!",
	youEnabledSpawnAbility = "Lubasid %s'l objekte spawninda!",
	youDisabledSpawnAbility = "Keelasid %s'l objekte spawnida!",
	
	resetTheMap = "lähtesta maailm!",
	noEntNameFound = "%s ei leitud!",
	noEntitiesFound = "Ühtegi üksust ei leitud!",
	noUnfrozenEntsFound = "Ühtegi külmunud üksust ei leitud!",
	noUnCollidedEntsFound = "Ühtegi un-collided üksust ei leitud!",
	freezeAllEnts = "%s külmutas kõik %s! (%s)",
	noCollideAllEnts = "%s no-collided kõik %s! (%s)",
	removedAllEntName = "%s eemaldas kõik %s! (%s)",
	entitiesLowCase = "üksused",
	
	-- Console Log
	removedEntitiesFrom = "%s eemaldas %s üksust %s'st!",
	frozeEntitiesFrom = "%s külmutas %s üksust %s'st!",
	enabledSpawningCapabilities = "%s lubas spawni võimekuse %s'le!",
	disabledSpawningCapabilities = "%s keelas spawni võimekuse %s'le!",
	removingHighCollision = "Eemaldan %s'st kõrge kokkupõrke %s (%s)!",
	
}

return ee
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_gprotect.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

/*
	Compatibility with gProtect
*/

function SH_ANTICRASH.HasGProtect()
	return gProtect ~= nil
end

function SH_ANTICRASH.HasGProtectGhosting()
	if !SH_ANTICRASH.HasGProtect() then
		return false
	end

	local ghostingConf = gProtect.GetConfig(nil,"ghosting")

	return ghostingConf and ghostingConf.enabled
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_access.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

SH_ANTICRASH.VARS.convertedPermissions = SH_ANTICRASH.VARS.convertedPermissions or {}

for k, v in pairs(SH_ANTICRASH.SETTINGS.ADMINS) do

	SH_ANTICRASH.VARS.convertedPermissions[k] = {}
	
	if istable(v) then
		
		-- new format (["rank"] = { permissions })
		for i=1, #v do
			
			local perm = v[i]
			SH_ANTICRASH.VARS.convertedPermissions[k][perm] = true
			
		end
		
	else
	
		-- backwards compatibility (["rank"] = true)
		SH_ANTICRASH.VARS.convertedPermissions[k]["stats"] = true
		SH_ANTICRASH.VARS.convertedPermissions[k]["users"] = true
		SH_ANTICRASH.VARS.convertedPermissions[k]["global"] = true
	
	end
	
end

function SH_ANTICRASH.HasAccess(ply,permission)
	
	if CLIENT and isstring(ply) or ply == nil then
		permission = ply
		ply = LocalPlayer()
	end

	if ply:IsSuperAdmin() then
		return true
	end
	
	local userGroup = ply:GetUserGroup():lower()
	local permissions = SH_ANTICRASH.VARS.convertedPermissions[userGroup]
	
	-- Check if user has any permissions
	if !permission then
		return permissions ~= nil
	end
	
	-- Check for specific user permission
	return permissions ~=nil and permissions[permission]
	
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_entityvision.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

CL_ANTICRASH.ENTVISION = {}

local wireframeMat = Material( "models/wireframe" )
local chamsColor = SH_ANTICRASH.VARS.COLOR.FUCHSIA
local chamsColVector = Vector(chamsColor.r/1, chamsColor.g/1, chamsColor.b/1)

local viewingPlayers = {}
local globalVision = false

function CL_ANTICRASH.ENTVISION.AddPlayer(ply)

	if SH_ANTICRASH.HasAccess("users") then
		viewingPlayers[ply] = true
	end
	
end

function CL_ANTICRASH.ENTVISION.RemovePlayer(ply)

	if SH_ANTICRASH.HasAccess("users") then
		viewingPlayers[ply] = nil
	end

end 

function CL_ANTICRASH.ENTVISION.HasPlayer(ply)
	return viewingPlayers[ply] ~= nil
end


function CL_ANTICRASH.ENTVISION.SetGlobalVision(bool)

	if SH_ANTICRASH.HasAccess("global") then
		globalVision = bool
	end

end

function CL_ANTICRASH.ENTVISION.GetGlobalVision()
	return globalVision
end

local function EntityVision()

	if table.Count(viewingPlayers) == 0 and !globalVision then return end

	cam.Start3D()
	
		render.SuppressEngineLighting(true)
		render.MaterialOverride(wireframeMat)
		render.SetColorModulation (chamsColVector.x, chamsColVector.y, chamsColVector.z)

		local entTbl = ents.GetAll()
		
		for i=1, #entTbl do
		
			local ent = entTbl[i]
			local creator = ent:z_anticrashGetCreator()
			
			if creator ~= NULL and (viewingPlayers[creator] or globalVision) then
				ent:DrawModel()
			end
			
		end
	
		render.MaterialOverride()
		render.SuppressEngineLighting(false)
		
	cam.End3D()	
	
end
hook.Add("HUDPaint", "cl_anticrash_EntityVision", EntityVision)

--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_stats_overlay.lua:

local overlay = nil

function CL_ANTICRASH.OverlayIsOpen()
	return overlay ~= nil and overlay:IsVisible()
end

local function OpenOverlayByConCommand( ply, cmd, args )
	if !SH_ANTICRASH.HasAccess() then return end

	if overlay ~= nil then
	
		overlay:Remove()
		overlay = nil
		
	else
		overlay = vgui.Create( "p_anticrash_overlay" )
	end
end
concommand.Add( "anticrash_overlay_open", OpenOverlayByConCommand) 
--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_node.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local PANEL = {}

function PANEL:DrawTriangleUp( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy + h/2 },
        { x = cx, y = cy - h/2 },
        { x = cx + w/2, y = cy + h/2 }
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleDown( cx, cy, w, h, color )

    local triangle = {
        { x = cx, y = cy + h/2 },
        { x = cx - w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy - h/2 }
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleRight( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy },
        { x = cx - w/2, y = cy + h/2 },
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleLeft( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy },
        { x = cx + w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy + h/2 },
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawRotatedBox( x, y, w, h, ang, color )
	draw.NoTexture()
	surface.SetDrawColor( color or color_white )
	surface.DrawTexturedRectRotated( x, y, w, h, ang )
end

PANEL.TriggerColorHierarchy = {
    Color( 0, 205, 0 ),
    Color( 50, 83, 205 ),   
    Color( 205, 0, 0 ),
    Color( 205, 205, 0 ),
    Color( 205, 0, 205 ),
    Color( 50, 205, 205 ),
}

// Applies to everything, including the current panel after INIT
local function ChildRecursive( self, child )
    child:NoClipping( false )
    child:SetPaintedManually( true )
    child.TestHover = self.TestHover
    child.GetBackground = function() return self:GetBackground() end
    child.GetCursorPos = self.GetCursorPos

    // If we start seeing issues with sub menus, fix this.
    if not child.DropButton then
        child.OnChildAdded = function( s, kid )
            ChildRecursive( s, kid )
        end
    end

    child.RecursiveManualPaint = function( pan )
        if not pan:IsVisible() then return end
        pan:PaintManual( true )
        for _, child in ipairs( pan:GetChildren() ) do
            if not child.RecursiveManualPaint then continue end
            if not child:IsVisible() then continue end
            child:RecursiveManualPaint()
        end        
    end

    for _, cpan in ipairs( child:GetChildren() ) do
        ChildRecursive( child, cpan )
    end

end

function PANEL:RecursiveManualPaint()
    if not self:IsVisible() then return end
    if not IsValid( self.vars ) then 
        self:PaintManual( true ) 
        for _, child in ipairs( self:GetChildren() ) do
            child:PaintManual( true )
        end
        return 
    end

    local dx, dy = self:GetPos()
    local px, py = self:GetParent():LocalToScreen( dx, dy )
    self.Matrix:SetTranslation( Vector( dx, dy, 0 ) )
    cam.PushModelMatrix(self.Matrix, true)
    self:Paint( self:GetWide(), self:GetTall() )
    cam.PopModelMatrix()

    for _, child in ipairs( self:GetChildren() ) do
        if child == self.vars then continue end
        if not child.Paint then continue end
        self.Matrix:SetTranslation( Vector( dx + child:GetX(), dy + child:GetY(), 0 ) )
        cam.PushModelMatrix(self.Matrix, true)
        child:Paint( child:GetWide(), child:GetTall() )
        cam.PopModelMatrix()
    end

    render.ClearStencil()
    render.SetStencilTestMask( 255 )
    render.SetStencilWriteMask( 255 )
    render.SetStencilPassOperation( STENCILOPERATION_KEEP )
    render.SetStencilZFailOperation( STENCILOPERATION_KEEP )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )

    // Now we render self.vars

    render.SetStencilEnable( true )
        render.SetStencilReferenceValue( 9 )
        render.SetStencilFailOperation( STENCILOPERATION_REPLACE )

        // Masked Draw
        dx, dy = self:LocalToScreen( self.vars:GetPos() )
        px, py = self:GetParent():ScreenToLocal( dx, dy )
        draw.RoundedBox(0, px, py, self.vars:GetWide(), self.vars:GetTall(), Color( 255, 0, 0 ) )
        /////////////////////////////////
        render.SetStencilFailOperation( STENCILOPERATION_KEEP )
        render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )

        // Main draw
        self.vars:RecursiveManualPaint( true )
        /////////////////////////////////
    render.SetStencilEnable( false )

end

function PANEL:OnChildAdded( child )
    ChildRecursive( self, child )
end

function PANEL:TestHover( mx, my )
    local bg = self:GetBackground()
    if IsValid( bg ) and bg:GetZoomScale() < 1 then
        mx, my = self:GetBackground():GetZoomedCursorPos(mx, my)
    end
    
    mx, my = self:ScreenToLocal( mx, my )
    local bx, by = self:GetSize()
    return ( mx >= 0 ) && ( my >= 0 ) && ( mx <= bx ) && ( my <= by )
end

function PANEL:Init()
    self.NextClick = 0
    self.MainLink = true
    self._vars = {}
    self._disablevars = {}
    self._checkboxes = {}
    self.Matrix = Matrix()


    self.wOSNode = true
    self:NodeClose(true)
    self:SetZPos( -5 )
    self:SetPaintedManually(true)

    self.DeleteButton = vgui.Create("DButton", self)
    self.DeleteButton:SetSize( self:GetTall()*0.15, self:GetTall()*0.15 )
    self.DeleteButton:SetPos( self:GetWide()*0.9 - self:GetTall()*0.0, self:GetTall()*0.925 )
    self.DeleteButton:SetText("")
    self.DeleteButton.DoClick = function(pan)
        self:GetBackground():NodeRemove(self)
        hook.Call( "wOS.PES.OnNodeDelete", nil, self )
    end
    self.DeleteButton.Paint = function(pan, ww, hh)
        //draw.RoundedBox(hh*0.3, 0, 0, ww, hh, Color( 200, 200, 200 ) )
        //draw.SimpleText("X", "DermaDefaultBold", ww/2, hh/2, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        self:DrawRotatedBox( ww*0.5, hh*0.5, ww*2, hh*0.2, -45, color_white )
        self:DrawRotatedBox( ww*0.5, hh*0.5, ww*2, hh*0.2, 45, color_white )
    end

    self.ExpandButton = vgui.Create("DButton", self)
    self.ExpandButton:SetSize( self:GetTall()*0.15, self:GetTall()*0.15 )
    self.ExpandButton:SetPos( self:GetWide()*0.8 - self:GetTall()*0.075, self:GetTall()*0.925 )
    self.ExpandButton:SetText("")
    self.ExpandButton.DoClick = function(pan)
        if self.IsOpen then
            self:NodeClose()
        else
            self:Open()
        end
        self.NodeDirty = false
    end
    self.ExpandButton.Paint = function(pan, ww, hh)
        if self.IsOpen then
            self:DrawTriangleUp( ww*0.5, hh*0.3875, ww*0.75, hh*0.75, color_white )
            draw.RoundedBox(0, 0, hh*0.88, ww, hh*0.12, color_white )
        else
            draw.RoundedBox(0, 0, 0, ww, hh*0.12, color_white )
            self:DrawTriangleDown( ww*0.5, hh*0.6, ww*0.8, hh*0.8, color_white )
        end
    end
    self:SetText("")
    self:CreateLinks()

    // Legacy
    self:OnChildAdded( self.ExpandButton )
    self:OnChildAdded( self.DeleteButton )
end

function PANEL:OnSizeChanged( newWidth, newHeight )
	self:CreateLinks( true )
end

function PANEL:CreateLinks( recalc )
    if self.Links then
        for index, link in ipairs(self.Links) do
            if IsValid(link) then link:Remove() end
        end
    end

    self.Links = {}
    self.OtherLinks = {}

    local function makeOtherLink(name, oNode)
        if self.OtherLinks[oNode] and IsValid(self.OtherLinks[oNode][name]) then return end
        local link = vgui.Create("DButton", oNode)
        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( link:GetWide()*-0.5, self:GetTall()*0.5 - link:GetTall()*0.5 )
        link:SetText( "" )
        link.Name = name or "Output"
        link.TriggerColor = Color( 255, 255, 255 )
        
        link.OldThink = link.Think
        link.Think = function( s )
            s:OldThink()
            s:SetPos( s:GetPos(), s:GetParent():GetTall()*0.5 - s:GetTall()*0.5 )
        end

        link.DoClick = function()
            self:GetBackground():RemoveLink(self, name, oNode)
            surface.PlaySound( "buttons/button15.wav" )
            link:Remove()
        end

        link.Paint = function(s, w, h)
            local wasEnabled = DisableClipping( true )            
            local col = s.TriggerColor
            if s.Hovered then col = Color(150,150,150) end
            draw.RoundedBox( h*0.3, 0, 0, w, h, col )
            DisableClipping( wasEnabled )
        end

        if IsValid(oNode) then
            self.OtherLinks[oNode] = self.OtherLinks[oNode] || {}
            self.OtherLinks[oNode][name] = link
        else
            self:GetBackground():RemoveLink(self, name, oNode)
        end
    end

    local function makeLink( name, label, desc )
        local link = vgui.Create("DButton", self)

        local t_pos, id, trigcol = self:GetTriggerPos( name )
        id = id or 1
        link.TriggerColor = trigcol or self.TriggerColorHierarchy[id]

        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( self:GetWide() - link:GetWide()*0.5, t_pos - link:GetTall()*0.5 )
        link:SetText( "" )
        link.NLabel = label or name
        link.NDescription = desc or ""
        link.Name = name or "Output"

        link:SetToolTip( link.NDescription )

        link.OnDepressed = function( s )
            surface.PlaySound( "weapons/airboat/airboat_gun_lastshot2.wav" )
            s.Linking = true
        end

        link.OnReleased = function( s )
            s.Linking = false
            local x, y = self:GetCursorPos()

            timer.Simple(0, function()
                local a = vgui.GetHoveredPanel()

                local hoveredPanel = vgui.GetHoveredPanel()
                if not hoveredPanel then return end
                if not IsValid(hoveredPanel) then return end
                if not hoveredPanel.wOSNode then return end
                if hoveredPanel:IsStart() then return end
                self:GetBackground():MakeLink(self, hoveredPanel, link.Name)
                makeOtherLink(link.Name, hoveredPanel)
                surface.PlaySound( "weapons/airboat/airboat_gun_lastshot1.wav" )
            end)

            s.mousepos = {x = x, y= y}
            self.Links[#self.Links + 1] = link
        end

        link.Paint = function(s, w, h)

            local col = s.TriggerColor
            local wasEnabled = DisableClipping( true )
            if s.Hovered then col = Color(150,150,150) end

            self:DrawTriangleRight( w*0.5, h*0.5, w, h, col )
            draw.SimpleText( s.NLabel, "DermaDefaultBold", w*-0.2, h/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

            DisableClipping( wasEnabled )

            if not s.Linking then return end
            DisableClipping( true )

            local x,y = s:ScreenToLocal( self:GetCursorPos() )

            surface.DrawLine( w, h/2, x, y )

            DisableClipping( wasEnabled )
        end
        self.Links[#self.Links + 1] = link
    end

    local nodeLinks = self:GetBackground():GetLinks(self)

    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData and nodeData.Triggers then
            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                local trigger_label = name
                local trigger_description = "This will fire when this condition is met"
                if istable( tdata ) then
                    name = tdata.Type or name
                    trigger_label = tdata.Name or trigger_label
                    trigger_description = tdata.Description or trigger_description
                end

                makeLink(name, trigger_label, trigger_description )
                if recalc then return end
                if not nodeLinks[name] then continue end
                for index, node in pairs(nodeLinks[name]) do
                    makeOtherLink(name, node)
                end
            end
            return
        end
    end

    makeLink("Instant")
    if not nodeLinks["Instant"] then return end
    for index, node in pairs(nodeLinks["Instant"]) do
        makeOtherLink("Instant", node)
    end
end

function PANEL:ApproveVar( name, data, dirty )
    if not name then return true end
    if not data then return true end
    if data.Internal then return true end

    if ( self:GetVarDisabled( name ) ) then return true end

    //Dirty validation
    if dirty then
        local varType = wOS.PES.Vars:Get(data.Type)
        if varType then
            if varType.DirtyValidate then
                self._vars[name] = data.Default or nil
                return false 
            end
        end
    end

    if !data.Required then return true end
    if ( self._vars[name] != nil ) then return true end
    return false
end

function PANEL:GetCursorPos()
    local bg = self:GetBackground()
    if not IsValid( bg ) then return input.GetCursorPos() end
    return bg:GetZoomedCursorPos( input.GetCursorPos() )
end

function PANEL:RecalculateDirty( dirty )
    local final = false
    
    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData then
            if nodeData.Vars then
                for _, name in pairs(nodeData.SortedVars) do
                    local data = nodeData.Vars[ name ]
                    if not data then continue end
                    if self:ApproveVar( name, data, dirty ) then continue end
                    final = true 
                end
            end

            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                if istable( tdata ) then
                    name = tdata.Type or name
                end
                
                local triggerTable = wOS.PES.Triggers:Get(name)
                if not triggerTable then continue end
                if not triggerTable.Vars then continue end
                for name, data in pairs(triggerTable.Vars) do
                    if self:ApproveVar( name, data, dirty ) then continue end
                    final = true 
                end
            end
        end
    end

    self.NodeDirty = final
end

function PANEL:SetVars(tbl, dirty)
    tbl = tbl or {}
    self._vars = tbl
    self:RecalculateName()
    self:RecalculateDirty( dirty )
end

-- function PANEL:UpdateCheckbox( name )
--     if not self._checkboxes[ name ] then return end
--     self._checkboxes[ name ]( !self:GetVarDisabled( name ) )
-- end

function PANEL:SetDisableVars( tbl, dirty )
    tbl = tbl or {}
    self._disablevars = tbl
    self:RecalculateDirty( dirty )
    //self:RefreshCheckBoxes()
end

function PANEL:GetVars()
    return self._vars
end

function PANEL:GetCopy()
    local data = {}
    data.Vars = table.Copy( self._vars )
    data.Toggles = table.Copy( self._disablevars )
    data.Type = self.Type
    return data
end

function PANEL:GetVar(name)
    return self._vars[name]
end

function PANEL:GetVarDisabled(name)
    if self._disablevars[name] != nil then
        return self._disablevars[name]
    end
    return false
end

function PANEL:SetVarDisabled(name, bool)
    self._disablevars[name] = bool
end

function PANEL:SetVar(name, value)
    self._vars[name] = value
    self:RecalculateName()
end

function PANEL:SetMainLink(bool)
    self.MainLink = bool
end

function PANEL:GetMainLink()
    return self.MainLink
end

function PANEL:GetBackground()
    if self.TempBack then return self.TempBack:GetParent() end
    return self:GetParent():GetParent()
end

function PANEL:GetMaster()
    local pan = self:GetBackground()
    if not pan then return end
    return pan:GetParent()
end

function PANEL:OnDepressed()
    local x, y = self:GetCursorPos()
    self.mousepos = {x = x, y= y}

    if !input.IsMouseDown( MOUSE_LEFT ) then return end
    self.Dragging = true
    local back = self:GetBackground()
    if back.SelectedPanel == self then return end
    back:SelectNode( self )
end

function PANEL:OnReleased()
    self.Dragging = false
end

function PANEL:GetTriggerPos(triggerName)
    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        -- if check
		if nodeData then
			local maxTriggers = #nodeData.Triggers
            for index, tdata in ipairs(nodeData.Triggers) do
                local trigger = tdata
                if istable( tdata ) then
                    trigger = tdata.Type or trigger
                end

				if trigger == triggerName then
					return self:GetTall()*0.5 + self:GetTall()*0.13 * ( index - ( maxTriggers + 1 )*0.5 ), index, self.TriggerColorHierarchy[index]
				end
			end
		end
	end

    return self:GetTall() * 0.5, 1, self.TriggerColorHierarchy[1]
end

function PANEL:Think()

    if not self.Dragging then return end
    if not input.IsMouseDown(MOUSE_LEFT) then self.Dragging = false return end

    local cX, cY = self:ScreenToLocal( self.mousepos.x, self.mousepos.y )
    local mX, mY = self:GetCursorPos()
    self.mousepos = {x = mX, y = mY}
    mX, mY = self:ScreenToLocal( mX, mY )

    local x, y = self:GetPos()
    local dX, dY = mX - cX, mY - cY
    self:SetPos(x + dX, y + dY)

end

function PANEL:DoClick()
    if self.NextClick >= CurTime() then
        self.NextClick = CurTime() + 1
        return
    end

    local back = self:GetBackground()
    back:SelectNode( self )
end

function PANEL:SaveVars()
    if not self.Type then return end

    local nodeData = wOS.PES.Nodes:Get(self.Type)
    -- if no data then return
    local maxTriggers = #nodeData.Triggers

    if !self.varDerma then return end

    if nodeData.Vars then
        for name, varTable in pairs(nodeData.Vars) do
            if varTable.Internal then continue end
            local varType = wOS.PES.Vars:Get(varTable.Type)
            if not varType then continue end
            local element = self.varDerma[name]
            local value = varType.GetValue(element)
            if value == nil then continue end
            self:SetVar(name, value)
        end
    end

    for index, tdata in ipairs(nodeData.Triggers) do
        local name = tdata
        if istable( tdata ) then
            name = tdata.Type or name
        end
        local triggerTable = wOS.PES.Triggers:Get(name)
        if not triggerTable then continue end
        if not triggerTable.Vars then continue end
        for name, varTable in pairs(triggerTable.Vars) do
            if varTable.Internal then continue end
            local varType = wOS.PES.Vars:Get(varTable.Type)
            if not varType then continue end
            local element = self.varDerma[ name ]
            local value = varType.GetValue(element)
            if value == nil then continue end
            self:SetVar( name, value)
        end
    end
end

function PANEL:NodeClose(bool)
    -- remove extra elements
    self:SetZPos(20)
    self.IsOpen = false
    if !bool then
        self:SaveVars()
    end

    self:SetSize(self:GetWide(), self:GetWide()*0.8 )

    if IsValid(self.TypeComboBox) then
        self.TypeComboBox:Remove()
    end

    if IsValid(self.vars) then
        self.vars:Remove()
    end
end

function PANEL:Open()
    self:SetSize( self:GetWide(), self:GetWide() )
    self.IsOpen = true
    self:Populate()
    self:SetZPos(9999)
end

function PANEL:Populate()

    // Replace this with a label that makes sense
    local a = vgui.Create("DLabel", self)
    a:SetSize(190, 15)
    a:SetTextColor( Color( 0, 0, 0 ) )
    a:SetText( self:GetText() )
    a:SetPos(10, 10)
    self.TypeComboBox = a

    if self.Type then
        local scroll = vgui.Create("DCategoryList", self)
        scroll:SetPos( self:GetWide()*0.025, self.BoxTopSize + self:GetTall()*0.05 )
        scroll:SetSize( self:GetWide()*0.95, self:GetTall()*0.9 - self.BoxTopSize - self.BoxBottomSize )

        self.vars = scroll
        self.varDerma = {}
    end

    local makeVars = function(varTable, varData)
        local varType = wOS.PES.Vars:Get(varTable.Type)
        if varTable.Internal then return end

        local cat = self.vars:Add( varTable.Name )

        if !varType then
            cat:Add("This variable errored!")
            self.vars:InvalidateLayout( true )
            return
        end

        -- send in varData or the Default value
        local element = varType.DermaElement(varTable, varData)

        local back = vgui.Create("DPanel")

        if !IsValid(element) then
            element = vgui.Create("DPanel")
        end

        if element:GetClassName() == "TextEntry" then
            local old_func = element.OnGetFocus
            element.OnGetFocus = function( pan )
                self:GetBackground().SelectedPanel = nil
                old_func( pan )
            end
        end

        element:SetParent(back)
        element:Dock(TOP)
        element:DockMargin(2,2,2,2)
        element._catderma = cat
        element.varTable = varTable

        back.element = element

        self.varDerma[varTable.Name] = element

        if varType.UseTool then
            local useTool = vgui.Create("DButton", back)
            useTool:Dock(TOP)
            useTool:DockMargin(8,2,8,2)
            useTool:SetTall(30)
            useTool:SetText("Use Tool")
            useTool.DoClick = function( pan )
                wOS.PES:SetEditingVar(self, varTable)
                local bg = self:GetBackground()
                if not bg then return end
                bg:SetupTool()
            end
        end

        cat:SetContents(back)
        self.vars:InvalidateLayout( true )

        if varTable.ToggleVar then
            local header = cat.Header

            local checkbox = vgui.Create( "DCheckBox", header )
            local hew, heh = header:GetSize()
            local cw, ch = self.vars:GetSize()

            checkbox:DockMargin(heh*0.1, heh*0.10, heh*0.1, heh*0.1)
            checkbox:Dock( RIGHT )
            checkbox:SetSize( heh*0.7, heh*0.7 )
            checkbox.Variable = varTable.Name

            //checkbox:SetPos( cw - 40, heh*0.15 )

            //self:SetVarDisabled( varTable.Name, false )
            
            header.OriginalColor = header:GetTextColor()
            checkbox.OnChange = function( pan, chk )
                local color = Color( 0, 0, 0, 155 )
                if chk then
                    color = pan:GetParent().OriginalColor
                end
                header:SetTextColor( color )
                if pan.RecursivePrevention then return end
                self:SetVarDisabled( pan.Variable, !chk )
            end

            local state = !self:GetVarDisabled( checkbox.Variable )
            checkbox.RecursivePrevention = true
            checkbox:SetChecked( state )
            checkbox:OnChange( state )
            checkbox.RecursivePrevention = false
            
            -- self._checkboxes[ checkbox.Variable ]  = function( bool )
            --     checkbox.RecursivePrevention = true
            --     checkbox:SetChecked( bool )
            --     checkbox.RecursivePrevention = false
            -- end
        end


    end

    if self.vars then
        self:OnChildAdded( self.vars )
    end

    local nodeData = wOS.PES.Nodes:Get(self.Type)

    if nodeData then
        if nodeData.Vars then
            for _, name in pairs(nodeData.SortedVars) do
                local data = nodeData.Vars[ name ]
                if not data then continue end
                if self._vars[name] == nil then self._vars[name] = data.Default end
                makeVars(data, self._vars[name])
            end
        end

        for index, tdata in ipairs(nodeData.Triggers) do
            local name = tdata
            if istable( tdata ) then
                name = tdata.Type or name
            end
            local triggerTable = wOS.PES.Triggers:Get(name)
            if not triggerTable then continue end
            if not triggerTable.Vars then continue end
            for name, data in pairs(triggerTable.Vars) do
                if self._vars[name] == nil then self._vars[name] = data.Default end
                makeVars(data, self._vars[name])
            end
        end
    end
    
end

function PANEL:RecalculateName()
    if self:IsStart() then return end

    if self:GetVar("Event Label") and self:GetVar("Event Label") != "" then
        self.TextName = self:GetVar("Event Label")
        return
    end

    if self.Type then
        self.TextName = self.Type .. " " .. tostring(self.ID-1) 
    else
        self.TextName = "Node " .. tostring(self.ID-1) 
    end
end

function PANEL:Paint(w, h)


    local color = Color(0, 0, 0, 255)

    if self.EventViewerNode then
    
        if self.Active then
            color = Color(0, 255, 0, 255)
        end

    else

        // Regular usage ( CSS / PES CREATION )
        local back = self:GetBackground()
        if self.NodeDirty then 
            color = Color( 176, 66, 33 )
        elseif back.SelectedPanel == self then
            color = Color( 66, 117, 176 ) 
        end

    end
    draw.RoundedBox(w*0.1, 0, 0, w, h, color)
    draw.RoundedBox(w*0.1, w*0.015, w*0.015, w*0.97, h - w*0.03, Color(155, 155, 155, 88))

    if not self.TextName then return end
    local txt = wOS.PES.WrapText( self.TextName, "wOS.PES.NodeText", w*0.95 )
    surface.SetFont( "wOS.PES.NodeText" )
    local _, dH = surface.GetTextSize( txt )


    self.BoxTopSize = h*0.18
    self.BoxBottomSize = h*0.18
    self.BoxBottomPos = h - self.BoxBottomSize
    
    if dH > self.BoxTopSize*0.95 then
        self.BoxTopSize = self.BoxTopSize + dH*0.5
    end

	if IsValid(self.ExpandButton) then
        self.ExpandButton:SetSize( self.BoxBottomSize*0.6, self.BoxBottomSize*0.6 )
        self.ExpandButton:SetPos( self:GetWide()*0.75 - self.BoxBottomSize*0.3, self.BoxBottomPos + self.BoxBottomSize*0.2 )
	end

	if IsValid(self.DeleteButton) then
        self.DeleteButton:SetSize( self.BoxBottomSize*0.6, self.BoxBottomSize*0.6 )
        self.DeleteButton:SetPos( self:GetWide()*0.9 - self.BoxBottomSize*0.3, self.BoxBottomPos + self.BoxBottomSize*0.2 )
	end

    // Bottom Bar
    draw.RoundedBoxEx( w*0.1, 0, self.BoxBottomPos, w, self.BoxBottomSize, Color( 66, 0, 0 ), false, false, true, true )
    draw.RoundedBoxEx( w*0.1, w*0.015, self.BoxBottomPos + w*0.015, w*0.97, self.BoxBottomSize - w*0.03, Color( 125, 0, 0 ), false, false, true, true )

    // Top Bar
    draw.RoundedBoxEx( w*0.1, 0, 0, w, self.BoxTopSize, Color( 66, 0, 0 ), true, true, false, false )
    draw.RoundedBoxEx( w*0.1, w*0.015, w*0.015, w*0.97, self.BoxTopSize - w*0.03, Color( 125, 0, 0 ), true, true, false, false )

    draw.DrawText(txt, "wOS.PES.NodeText", w/2, self.BoxTopSize/2 - dH/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

function PANEL:SetAsStart( isstarter )
    self.IsStartNode = isstarter
end

function PANEL:IsStart()
    return self.IsStartNode
end

vgui.Register( "WOS_PES_NODE", PANEL, "DButton" )

--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_calendar.lua:

local PANEL = {}

local time = {
	Second = 1,
	Minute = 60,
	Hour = 60*60,
	Day = 60*60*24
}

function PANEL:Init()

	local dash = vgui.Create("DPanel", self)
	dash:Dock(TOP)
	dash:SetTall(60)

	timer.Simple(0, function()
		local size = math.floor(dash:GetWide() / (table.Count(time) *2))
		self:GetParent():SetWide(size*(table.Count(time) *2))
		self:GetParent():Center()
		for index, time in SortedPairsByValue(time, true) do
			local timebutton = vgui.Create("DButton", dash)
			timebutton:Dock(LEFT)
			timebutton:SetWide(size)
			timebutton:DockMargin(0,0,0,0)
			timebutton:SetText("-1 " .. index)
			timebutton.DoClick = function()
				self.time = math.max(self.time - time, 0)
			end
		end

		for index, time in SortedPairsByValue(time) do
			local timebutton = vgui.Create("DButton", dash)
			timebutton:SetWide(size)
			timebutton:Dock(LEFT)
			timebutton:DockMargin(0,0,0,0)
			
			timebutton:SetText("+1 " .. index)
			timebutton.DoClick = function()
				self.time = math.max(self.time + time, 0)
			end
		end
	end)

	self.time = 0
end

function PANEL:GetTime()
	return os.time() + self.time
end

function PANEL:Paint(w, h)
	surface.SetDrawColor(0,0,0)
	surface.DrawRect(0,0, w ,h)
	local date = os.date( "%Y/%m/%d  %H:%M:%S", self.time + os.time())

	draw.SimpleText(date, "DermaDefault", w/2, 60 + (h - 60)/2, color_white, 1, 1 )
end

vgui.Register( "wOSCalendar", PANEL, "Panel" )
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/io_logic/sh_logic_tables.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local addon = {}


/*
Thank you Jazztronauts for this table of entclass to io inputs
https://github.com/Foohy/jazztronauts/blob/master/gamemodes/jazztronauts/gamemode/lib/sh_hacking.lua#L163-L394
*/

local io_functions = {
	logic_auto = {
		inputs = {},
		outputs = {
			"OnMapSpawn"
		},
	},
	logic_relay = {
		inputs = {
			"Enable",
			"Disable",
			"Trigger",
			"Toggle",
			"CancelPending",
			"EnableRefire",
			"Kill",
			"Use",
		},
		outputs = {
			"OnSpawn",
			"OnTrigger",
		},
	},
	logic_branch = {
		inputs = {
			"SetValue",
			"SetValueTest",
			"Toggle",
			"ToggleTest",
			"Test",
		},
		outputs = {
			"OnTrue",
			"OnFalse",
		},
	},
	logic_timer = {
		inputs = {
			"RefireTime",
			"ResetTimer",
			"FireTimer",
			"Enable",
			"Disable",
			"Toggle",
			"LowerRandomBound",
			"UpperRandomBound",
			"AddToTimer",
			"SubtractFromTimer",
		},
		outputs = {
			"OnTimer",
			"OnTimerHigh",
			"OnTimerLow",
		},
	},
	func_button = {
		inputs = {
			"Kill",
			"Use",
			"Lock",
			"Unlock",
			"Press",
			"PressIn",
			"PressOut",
		},
		outputs = {
			"OnDamaged",
			"OnPressed",
			"OnUseLocked",
			"OnIn",
			"OnOut",
		},
	},
	func_rot_button = {
		inputs = {
			"Kill",
			"Use",
			"Lock",
			"Unlock",
			"Press",
			"PressIn",
			"PressOut",
		},
		outputs = {
			"OnDamaged",
			"OnPressed",
			"OnUseLocked",
			"OnIn",
			"OnOut",
		},
	},
	func_door = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	func_door_rotating = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	prop_door_rotating = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	func_rotating = {
		inputs = {
			"SetSpeed",
			"Start",
			"Stop",
			"StopAtStartPos",
			"StartForward",
			"StartBackward",
			"Toggle",
			"Reverse",
		},
		outputs = {
		},
	},
	prop_dynamic = {
		inputs = {
			"SetAnimation",
			"SetDefaultAnimation",
			"SetPlaybackRate",
			"SetBodyGroup",
			"TurnOn",
			"TurnOff",
			"EnableCollision",
			"DisableCollision",
			"BecomeRagdoll",
		},
		outputs = {
			"OnAnimationBegun",
			"OnAnimationDone",
		},
	},
	env_sprite = {
		inputs = {
			"SetScale",
			"HideSprite",
			"ShowSprite",
			"ToggleSprite",
			"ColorRedValue",
			"ColorGreenValue",
			"ColorBlueValue",
			"Alpha",
			"Color",
		},
		outputs = {

		},
	},
	env_spark = {
		inputs = {
			"StartSpark",
			"StopSpark",
			"ToggleSpark",
			"SparkOnce"
		},
		outputs = {

		},
	},
	trigger_once = {
		inputs = {
			"Toggle",
			"Enable",
			"Disable",
		},
		outputs = {
			"OnStartTouch",
			"OnTrigger",
		},
	},
	trigger_multiple = {
		inputs = {
			"TouchTest",
			"Toggle",
			"Enable",
			"Disable",
		},
		outputs = {
			"OnStartTouchAll",
			"OnEndTouch",
			"OnEndTouchAll",
			"OnStartTouch",
			"OnTrigger",
		},
	},
	ambient_generic = {
		inputs = {
			"Pitch",
			"PlaySound",
			"StopSound",
			"ToggleSound",
			"Volume",
			"FadeIn",
			"FadeOut"
		},
		outputs = {

		},
	},
}

function addon:GetIOTable(class, ent)
	local actions = {}

	if io_functions[ class ] then
		table.Add(actions, io_functions[ class ].inputs or {})
	end

	// Add any custom actions
	if ent and ent._pesIOLogic then
		table.Add(actions, ent._pesIOLogic)
	end

	return actions
end

wOS.PES.Modules:RegisterAddon( "io_logic", addon )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/string.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "String"

VAR.IsValid = function(varData, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local textentry = vgui.Create("DTextEntry")

    if varTable.AllowMultiLine then
        textentry:SetMultiline(true)
        textentry:SetHeight(40)
    end

    textentry:SetText(value or varTable.Default or "")

    return textentry
end

VAR.GetValue = function(dermaElement)
    return dermaElement:GetValue()
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/vector.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Vector"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Save the position you are AIMING AT", key = "gui/lmb.png", },
    { text = "Save your current EYE position", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Save your current STANDING position", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
}

VAR.IsValid = function(varTable, value)
    if not isvector(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isvector(self.Value) then
            draw.SimpleText("Vector set at: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(125, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Vector needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Value
end

VAR.PrimaryAttack = function(wep, ply, panel)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    panel.Value = pos
end

VAR.OnStart = function(node, value, var)
    if !isvector(value) then

        local vec = Vector(value)
        if vec then
            node:SetVar(var.Name, vec)
        end
    end
end

VAR.Draw3D = function(wep, ply, element)
    local vec = element.Value
    if not isvector(vec) then return end

    local top = Vector(vec.x, vec.y, vec.z + 200)
    render.DrawLine(vec, top, Color(255, 255, 255), false)
end


return VAR

--addons/wos-passiveevent-ageo/lua/wos/css/vgui/wos_css_scrollpanel.lua:
--[[-------------------------------------------------------------------
	Shooting Range Scroll Panel
		VGUI Element for use in the menus.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David, Oninoni
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--

local DSRScrollPanel = {}

-- Initializes the DSRScrollPanel.
function DSRScrollPanel:Init()
	self.Panels = {}

	self.XScroll = true
	self.AlignCenter = true

	self.Overflow = 0
end

function DSRScrollPanel:OnSizeChanged(width, height)
	if self.XScroll then
		self.ScrollSize = width
	else
		self.ScrollSize = height
	end
end

function DSRScrollPanel:SetPanelSize(x, y)
	self.XPanelSize = x
	self.YPanelSize = y
end

function DSRScrollPanel:SetPanelSpacing(s)
	self.PanelSpacing = s
end

function DSRScrollPanel:GetScrollPanelSize()
	if self.XScroll then
		return self.XPanelSize
	else
		return self.YPanelSize
	end
end

function DSRScrollPanel:SetPanelScroll(panel, offset)
	offset = offset or 0

	if self.XScroll then
		panel:SetPos(panel.OriginalValue + offset, self.PanelSpacing)
	else
		panel:SetPos(self.PanelSpacing, panel.OriginalValue + offset)
	end
end

function DSRScrollPanel:SetScroll(offset)
	for _, panel in pairs(self.Panels or {}) do
		self:SetPanelScroll(panel, offset)
	end
end

function DSRScrollPanel:Clear()
	for _, panel in pairs(self.Panels or {}) do
		panel:Remove()
	end

	self.Panels = {}
end

function DSRScrollPanel:Think()
	local offset = 0

	if self.AlignCenter then
		offset = self.Overflow / 2
	end

	if self.Overflow < 0 then
		local xMouse, yMouse = gui.MousePos()
		local xLocal, yLocal = self:ScreenToLocal(xMouse, yMouse)

		local xSize, ySize = self:GetSize()

		local scrollLocal = yLocal
		if self.XScroll then
			scrollLocal = xLocal
		end
		
		local panelSize = self:GetScrollPanelSize()

		local targetOffset = math.min(0, math.max(self.Overflow, (scrollLocal - self.PanelSpacing) / (self.ScrollSize - self.PanelSpacing * 2) * self.Overflow))

		offset = Lerp(0.03, self.LastOffset, targetOffset)
		self.LastOffset = offset
	end

	self:SetScroll(offset)
end

function DSRScrollPanel:CreatePanel(class)
	local panel = vgui.Create(class, self)
	panel:SetSize(self.XPanelSize, self.YPanelSize)

	local panelSpacing = self.PanelSpacing
	local panelSize = self:GetScrollPanelSize()
	
	panel.OriginalValue = panelSpacing + (panelSpacing + panelSize) * #self.Panels
	
	self:SetPanelScroll(panel)
	self.LastOffset = 0
	table.insert(self.Panels, panel)

	local totalWidth = panel.OriginalValue + panelSize + panelSpacing

	self.Overflow = self.ScrollSize - totalWidth

	return panel
end

vgui.Register("WOS_CSS_ScrollPanel", DSRScrollPanel, "DPanel")
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local ENT = {}

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Spawnable = false

-- Sets up the NetworkVars for the entity.
function ENT:SetupDataTables()
end

function ENT:ApplyCustomCollisions(vertices)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_NONE)

	self:EnableCustomCollisions(true)

	self:PhysicsInitMultiConvex(vertices)
end

hook.Add("PhysgunPickup", "wOS.CombatSim.PreventWallPickup", function(ply, ent)
	if IsValid(ent) and ent:GetClass() == "wos_simulation_wall" then
		return false
	end
end)

hook.Add("CanTool", "wOS.CombatSim.PreventWallToolgun", function(ply, tr)
	local ent = tr.Entity
	if IsValid(ent) and ent:GetClass() == "wos_simulation_wall" then
		return false
	end
end)

-- Clientside Initialize
function ENT:Initialize()
	net.Start("wOS.CombatSim.UpdateWallCollisions")
		net.WriteEntity(self)
	net.SendToServer()
end

-- Clientside Think
function ENT:Think()
end

-- Clientside OnRemove
function ENT:OnRemove()
end

-- Main Draw function.
function ENT:Draw()
end

scripted_ents.Register(ENT, "wos_simulation_wall")
--addons/xeon-drm-dll/lua/autorun/client/xeon-drm-auth.lua:
local domain = CreateConVar("xeon_dev", 0, bit.bor(FCVAR_REPLICATED, FCVAR_UNREGISTERED, FCVAR_UNLOGGED, FCVAR_DONTRECORD), nil, 0, 1):GetInt() == 1 and "http://gmod.local" or "https://xeon.network"

local XEON_AUTH
local XEON_IP
net.Receive("XEON.Auth", function(len)
	if net.ReadBool() then
		if not IsValid(XEON_AUTH) then return end

		local path = net.ReadString()

		XEON_AUTH:Remove()
		XEON_AUTH = Derma_Query(
			"You will now be prompted to open a URL in the Steam Overlay. Please click \"Yes\" when prompted.\n\nThe URL will redirect you to a Sign in through Steam page for https://xeon.network.\nYou won't need to enter a username or password, the Steam Overlay should already have you logged in.",
			"XEON DRM",
			"Continue", function()
				gui.OpenURL(domain .. path)
			end,
			"Cancel"
		)
	end

	net.Start("XEON.Auth")
	net.SendToServer()

	if IsValid(XEON_AUTH) then return end

	if not LocalPlayer():IsSuperAdmin() then
		XEON_AUTH = Derma_Message("Thanks for installing one of Billy's scripts!\nTo activate your license and use your new scripts, you need to be a superadmin. Please promote yourself to superadmin, then respawn or rejoin to try again.", "XEON DRM", "Dismiss")
		return
	end

	XEON_AUTH = Derma_Query(
		"Thanks for installing one of Billy's scripts!\nTo activate your license and use your new scripts, I'll need you to log in to Steam via the Steam Overlay to authenticate that this server belongs to you.\nWould you like to do this now?",
		"XEON DRM",
		"Link Server", function()
			XEON_AUTH = Derma_Message("Connecting to XEON... please wait. If nothing happens, please check your server's console.", "XEON DRM", "Cancel")

			if not IsValid(XEON_IP) then
				XEON_IP = vgui.Create("DHTML")

				if not IsValid(XEON_IP) or not XEON_IP.OpenURL then
					XEON_IP = { GetIPAddress = function(_, callback) callback(nil) end }
				else
					XEON_IP:SetSize(0, 0)
					XEON_IP:AddFunction("XEON", "IP", function(IP)
						timer.Remove("XEON_IP")
						XEON_IP.IP = IP
						for _, c in ipairs(XEON_IP.IP_Callbacks) do c(IP) end
						XEON_IP.IP_Callbacks = {}
					end)

					XEON_IP.IP_Callbacks = {}
					function XEON_IP:GetIPAddress(callback)
						if os.time() - self.StartedLoading > 5 then
							callback(nil)
						elseif self.IP then
							callback(self.IP)
						else
							table.insert(self.IP_Callbacks, callback)
						end
					end

					function XEON_IP:OnFinishLoadingDocument(IP)
						self:QueueJavascript("XEON.IP(document.body.textContent.trim())")
					end

					XEON_IP.StartedLoading = os.time()
					XEON_IP:OpenURL("https://icanhazip.com/")

					timer.Create("XEON_IP", 1, 0, function()
						if not IsValid(XEON_IP) then
							timer.Remove("XEON_IP")
							return
						end

						if os.time() - XEON_IP.StartedLoading <= 5 then return end

						timer.Remove("XEON_IP")

						for _, c in ipairs(XEON_IP.IP_Callbacks) do c(nil) end
						XEON_IP.IP_Callbacks = {}
					end)
				end
			end

			XEON_IP:GetIPAddress(function(IP)
				net.Start("XEON.Auth")
					net.WriteBool(true)
					net.WriteString(tostring(IP or ""))
				net.SendToServer()
			end)
		end,
		"Dismiss"
	)
end)

local function openErrors(errors)
	if IsValid(XEON_ERRORS) then
		XEON_ERRORS:Update(errors)
		return
	end

	XEON_ERRORS = vgui.Create("DFrame")
	XEON_ERRORS:SetSize(ScrW() * .8, ScrH() * .8)
	XEON_ERRORS:SetTitle("XEON DRM by Billy - Error!")
	XEON_ERRORS:Center()
	XEON_ERRORS:MakePopup()

	local html = vgui.Create("DHTML", XEON_ERRORS)
	html:Dock(FILL)
	html:OpenURL(domain .. "/errors")
	html:AddFunction("XEON", "ScriptSupport", function()
		gui.OpenURL("https://support.billy.enterprises")
	end)

	function XEON_ERRORS:Update(errors)
		print("XEON Errors: " .. #errors)
		PrintTable(errors)

		html:QueueJavascript("ShowNetworkedErrors(" .. util.TableToJSON(errors) .. ")")
	end
	function html:OnDocumentReady()
		XEON_ERRORS:Update(errors)
		self.OnDocumentReady = nil
	end
	XEON_ERRORS:Update(errors)

	sound.PlayURL("https://xeon.network/static/media/oof.mp3", "", function() end)
end

net.Receive("XEON.Error", function()
	local errors = {}
	for i = 1, net.ReadUInt(16) do
		errors[i] = net.ReadString()
	end
	openErrors(errors)
end)

hook.Add("InitPostEntity", "XEON.Error", function()
	timer.Simple(2, function()
		net.Start("XEON.Error")
		net.SendToServer()
	end)
end)
--addons/billy_gas/lua/vgui/bvgui/renderscene.lua:
local IsInspecting = false

local LockView
local ViewOrigin, ViewAngle
local Velocity = Vector(0,0,0)
local CalcView_tbl = {}
hook.Add("CalcView", "bvgui_renderscene_CalcView", function(ply, origin, angles, fov)
	if (IsInspecting) then
		if (not ViewOrigin or not ViewAngle) then
			ViewOrigin, ViewAngle = origin, angles
		end
		CalcView_tbl.origin = ViewOrigin
		CalcView_tbl.angles = ViewAngle
	end

	if (GAS and GAS.Logging and GAS.Logging.Scenes) then
		if (IsInspecting) then
			GAS.Logging.Scenes.ViewOrigin = ViewOrigin
		else
			GAS.Logging.Scenes.ViewOrigin = nil
		end
	end

	if (IsInspecting) then return CalcView_tbl end
end)

local tr = { collisiongroup = COLLISION_GROUP_WORLD }
local function IsInWorld( pos )
	tr.start = pos
	tr.endpos = pos
	return util.TraceLine( tr ).HitWorld
end

hook.Add("CreateMove", "bvgui_renderscene_CreateMove", function(cmd)
	if (not IsInspecting) then
		LockView = nil
		Velocity.x, Velocity.y, Velocity.z = 0,0,0
		return
	end

	if (not LockView) then
		LockView = cmd:GetViewAngles()
	else
		cmd:SetViewAngles(LockView)
	end
	
	cmd:ClearMovement()

	local time = FrameTime()
   
	local sensitivity = 0.022
	ViewAngle:Normalize()
	ViewAngle.p = math.Clamp(ViewAngle.p + (cmd:GetMouseY() * sensitivity), -89, 89)
	ViewAngle.y = ViewAngle.y + (cmd:GetMouseX() * -1 * sensitivity)

	local NewViewOrigin = ViewOrigin + (Velocity * time)
   
	local add = Vector(0,0,0)
	local ang = ViewAngle
	if (cmd:KeyDown(IN_FORWARD)) then add = add + ang:Forward() end
	if (cmd:KeyDown(IN_BACK)) then add = add - ang:Forward() end
	if (cmd:KeyDown(IN_MOVERIGHT)) then add = add + ang:Right() end
	if (cmd:KeyDown(IN_MOVELEFT)) then add = add - ang:Right() end
	if (cmd:KeyDown(IN_JUMP)) then add = add + ang:Up() end
	if (cmd:KeyDown(IN_DUCK)) then add = add - ang:Up() end
   
	add = add:GetNormal() * time * 1000
	if (cmd:KeyDown(IN_SPEED)) then add = add * 2 end

	Velocity = Velocity * 0.95
	ViewOrigin = NewViewOrigin
   
	Velocity = Velocity + add

	cmd:ClearButtons()
end)

local function ResetNoDraw()
	for _,ent in ipairs(ents.GetAll()) do
		if (ent.bVGUI_RenderScene_SetNoDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = nil
			ent:SetNoDraw(false)
		end
	end
end
local function SetNoDraw()
	for _,ent in ipairs(ents.GetAll()) do
		if (ent:GetNoDraw() == false and not ent.bVGUI_RenderScene_ForceDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = true
			ent:SetNoDraw(true)
		end
	end
end
local function CheckNoDraw(ent)
	if (not IsValid(ent)) then return end
	if (IsInspecting) then
		if (ent:GetNoDraw() == false and not ent.bVGUI_RenderScene_ForceDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = true
			ent:SetNoDraw(true)
		end
	else
		if (ent.bVGUI_RenderScene_SetNoDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = nil
			ent:SetNoDraw(false)
		end
	end
end
local function KeepNoDraw(ent)
	CheckNoDraw(ent)
	CheckNoDraw(ent:GetParent())
end
hook.Add("NotifyShouldTransmit", "bvgui_renderscene_KeepNoDraw", KeepNoDraw)

local static = Material("vgui/bvgui/static.vtf")

local PANEL = {}

function PANEL:Init()
	local this = self

	local function find_dframe(pnl)
		if (IsValid(pnl.bVGUI_PinButton)) then
			return pnl
		elseif (IsValid(pnl:GetParent())) then
			return find_dframe(pnl:GetParent())
		end
	end
	self.PvPEventFrame = find_dframe(self:GetParent())

	self.Inspecting = false
	self.Rendering = false
	self.CanRender = true
	self.Origin = Vector(0,0,0)
	self.Angle = Angle(0,0,0)

	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.RenderView = {
		origin = self.Origin,
		angles = self.Angle,
		drawviewmodel = false,
		fov = 120,
		bloomtone = false,
		aspectratio = 0
	}

	self.Toolbar = vgui.Create("bVGUI.BlankPanel", self)
	self.Toolbar:DockPadding(2,2,2,2)
	self.Toolbar:SetPos(5,5)
	function self.Toolbar:Paint(w,h)
		surface.SetDrawColor(47,79,115,255)
		surface.DrawRect(0,0,w,h)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
		surface.DrawTexturedRect(0,0,w,h)
	end

	self.InspectBtn = vgui.Create("DImageButton", self.Toolbar)
	self.InspectBtn:Dock(LEFT)
	self.InspectBtn:DockMargin(0,0,5,0)
	self.InspectBtn:SetSize(16,16)
	self.InspectBtn:SetImage("icon16/world.png")
	function self.InspectBtn:DoClick()
		if (IsInspecting and not this.Inspecting) then return end
		if (IsInspecting) then
			IsInspecting = false
			this.Inspecting = false
			if (ViewOrigin and ViewAngle) then
				this:SetOrigin(ViewOrigin)
				this:SetAngle(ViewAngle)
			end
			ResetNoDraw()

			this.PvPEventFrame:SetPos(this.PvPEventFrame.GAS_RenderScene_FramePosX, this.PvPEventFrame.GAS_RenderScene_FramePosY)
			for _,dframe in ipairs(bVGUI.Frames) do
				if (IsValid(dframe) and dframe.GAS_RenderScene_Hidden) then
					dframe:SetVisible(true)
				end
			end
		else
			ViewOrigin, ViewAngle = this.Origin, this.Angle

			SetNoDraw()

			this.PvPEventFrame.bVGUI_PinButton:TogglePin()
			this.PvPEventFrame.GAS_RenderScene_FramePosX, this.PvPEventFrame.GAS_RenderScene_FramePosY = this.PvPEventFrame:GetPos()
			this.PvPEventFrame:SetPos(ScrW() - this.PvPEventFrame:GetWide() - 20, ScrH() - this.PvPEventFrame:GetTall() - 20)
			for _,dframe in ipairs(bVGUI.Frames) do
				if (IsValid(dframe) and dframe ~= this.PvPEventFrame and dframe:IsVisible()) then
					dframe:SetVisible(false)
					dframe.GAS_RenderScene_Hidden = true
				end
			end

			IsInspecting = true
			this.Inspecting = true
		end
		GAS:PlaySound("jump")
	end
	bVGUI.AttachTooltip(self.InspectBtn, {Text = bVGUI.L("inspect")})

	local screenshot = vgui.Create("DImageButton", self.Toolbar)
	screenshot:Dock(LEFT)
	screenshot:SetSize(16,16)
	screenshot:DockMargin(0,0,5,0)
	screenshot:SetImage("icon16/camera.png")
	function screenshot:Capture()
		gui.HideGameUI()
		bVGUI.DestroyTooltip()

		timer.Simple(0, function()
			hook.Add("PostRender", "GAS_RenderScene_Screenshot", function()
				local img = render.Capture({
					format = "png",
					x = 0,
					y = 0,
					w = ScrW(),
					h = ScrH(),
					alpha = false
				})

				local name = "gas_scene_screenshot_" .. os.date("%d_%m_%Y_%H_%M_%S")
				local function screenshot_name(i)
					if (i == nil) then
						if (file.Exists(name, "DATA")) then
							return screenshot_name(2)
						else
							return name
						end
					else
						if (file.Exists(name .. "_" .. i, "DATA")) then
							return screenshot_name(i + 1)
						else
							return name .. "_" .. i
						end
					end
				end
				local screenshot_name = screenshot_name() .. ".png"
				file.Write(screenshot_name, img)

				hook.Remove("PostRender", "GAS_RenderScene_Screenshot")

				bVGUI.RichMessage({
					title = bVGUI.L("screenshot_saved"),
					button = bVGUI.L("ok"),
					textCallback = function(text)
						local full_path = "garrysmod/data/" .. screenshot_name

						text:InsertColorChange(255,255,255,255)
						local t = bVGUI.L("screenshot_saved_to")
						local s,e = t:find("%%s")
						text:AppendText(t:sub(1,s-1))

						text:InsertColorChange(0,255,255,255)
						text:InsertClickableTextStart("CopyFilePath")
						text:AppendText(full_path)
						text:InsertClickableTextEnd()

						text:InsertColorChange(255,255,255,255)
						text:AppendText(t:sub(e+1))

						function text:ActionSignal(signalName, signalValue)
							if (signalName == "TextClicked" and signalValue == "CopyFilePath") then
								GAS:SetClipboardText(full_path)
							end
						end
					end
				})

				if (IsValid(self) and IsValid(this) and this.Inspecting) then
					this.InspectBtn:DoClick()
				end

				GAS:PlaySound("success")
			end)
		end)
	end
	function screenshot:DoClick()
		if (this.Inspecting) then
			self:Capture()
		elseif (not IsInspecting) then
			this.InspectBtn:DoClick()
			self:Capture()
		end
	end
	bVGUI.AttachTooltip(screenshot, {Text = bVGUI.L("screenshot")})

	local reset = vgui.Create("DImageButton", self.Toolbar)
	reset:Dock(LEFT)
	reset:SetSize(16,16)
	reset:SetImage("icon16/arrow_refresh.png")
	function reset:DoClick()
		if (this.OriginalOrigin) then
			this:SetOrigin(Vector(this.OriginalOrigin.x, this.OriginalOrigin.y, this.OriginalOrigin.z))
		end
		if (this.OriginalAngles) then
			this:SetAngle(Angle(this.OriginalAngles.p, this.OriginalAngles.y, this.OriginalAngles.r))
		end
		GAS:PlaySound("delete")
	end
	bVGUI.AttachTooltip(reset, {Text = bVGUI.L("reset")})
end

function PANEL:OnRemove()
	if (self.Inspecting) then
		self.InspectBtn:DoClick()
	end
end

function PANEL:PerformLayout(w,h)
	self.Toolbar:SetSize(w - 10,20)
end

local click_to_render_font = bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 18)
function PANEL:Paint(w,h)
	if (not self.Rendering or IsInspecting) then
		surface.SetDrawColor(255,255,255)
		surface.SetMaterial(static)
		local d = math.max(w,h)
		surface.DrawTexturedRect((w - d) / 2,(h - d) / 2,d,d)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT)
		surface.DrawTexturedRect(0,(((SysTime() % 5) / 5) * (h + 30)) - 30,w,30)

		if (self.CanRender and not IsInspecting) then
			draw.SimpleTextOutlined(bVGUI.L("click_to_render"), click_to_render_font, w / 2, (h - 20) / 2, bVGUI.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, bVGUI.COLOR_BLACK)
		end
		if (self.Inspecting) then
			draw.SimpleTextOutlined(bVGUI.L("inspecting"), click_to_render_font, w / 2, (h - 20) / 2, bVGUI.COLOR_RED, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, bVGUI.COLOR_BLACK)
		elseif (not self.CanRender) then
			draw.SimpleTextOutlined(bVGUI.L("no_data"), click_to_render_font, w / 2, (h - 20) / 2, bVGUI.COLOR_RED, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, bVGUI.COLOR_BLACK)
		end
	else
		local x,y = self:LocalToScreen(0,0)
		self.RenderView.x, self.RenderView.y, self.RenderView.w, self.RenderView.h = x,y,w,h
		render.RenderView(self.RenderView)
	end

	surface.SetDrawColor(0,0,0)
	surface.DrawRect(0,0,5,h)
	surface.DrawRect(0,0,w,5)
	surface.DrawRect(w - 5,0,5,h)
	surface.DrawRect(0,h - 30,w,30)

	self.Toolbar:SetVisible(self.Rendering)
end

function PANEL:SetLabel(txt)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(txt)
	self.Label:Dock(FILL)
	self.Label:DockMargin(0,0,0,7.5)
	self.Label:SetContentAlignment(2)
end

function PANEL:SetOrigin(origin)
	self.Origin = origin
	self.RenderView.origin = self.Origin
	if (not self.OriginalOrigin) then
		self.OriginalOrigin = Vector(origin.x,origin.y,origin.z)
	end
end

function PANEL:SetAngle(ang)
	self.Angle = ang
	self.RenderView.angles = self.Angle
	if (not self.OriginalAngles) then
		self.OriginalAngles = Angle(ang.p,ang.y,ang.r)
	end
end

function PANEL:SetRendering(rendering)
	self.Rendering = rendering
	if (self.Rendering and self.OnStartRender) then
		self:OnStartRender()
	elseif (not self.Rendering and self.OnEndRender) then
		self:OnEndRender()
	end

	if (not self.Rendering and self.Inspecting) then
		self.Inspecting = false
		IsInspecting = false
	end
end

function PANEL:SetCanRender(can_render)
	self.CanRender = can_render
	if (not self.CanRender) then
		self:SetCursor("none")
	else
		self:SetCursor("hand")
	end
	if (self.Rendering) then
		self:SetRendering(false)
	end
end

function PANEL:DoClick()
	if (not self.Rendering) then
		if (not self.CanRender) then
			GAS:PlaySound("error")
		else
			self:SetRendering(true)
			GAS:PlaySound("btn_on")
			notification.AddLegacy(bVGUI.L("right_click_to_stop_rendering"), NOTIFY_HINT, 2)
		end
	else
		self.InspectBtn:DoClick()
	end
end

function PANEL:DoRightClick()
	if (self.Rendering) then
		if (self.Inspecting) then
			self.InspectBtn:DoClick()
		end
		self:SetRendering(false)
		GAS:PlaySound("btn_off")
	end
end

function PANEL:OnMousePressed(m)
	self.m_pressing = m
end
function PANEL:OnMouseReleased(m)
	if (self.m_pressing == m) then
		if (m == MOUSE_LEFT) then
			self:DoClick()
		elseif (m == MOUSE_RIGHT) then
			self:DoRightClick()
		end
	end
	self.m_pressing = nil
end

derma.DefineControl("bVGUI.RenderScene", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/bvgui/switch.lua:
local PANEL = {}

local on_color  = Color(76,218,100)
local off_color = Color(216,75,75)
local switch_width = 40
local switch_height = 20
local label_margin = 7

local function Circle( x, y, radius, seg )
	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
	for i = 0, seg do
		local a = math.rad( ( i / seg ) * -360 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
	end

	local a = math.rad( 0 )
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

	return cir 
end

function PANEL:Init()
	self.LeftCircle = false
	self.RightCircle = false

	self.Active = false
	self.ColorInterpolation = bVGUI.LerpColor(off_color, off_color, .25)
	self.SwitchInterpolation = bVGUI.Lerp(switch_height / 2, switch_height / 2, .25)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self:SetText("Switch")

	self.ClickableArea = vgui.Create("bVGUI.BlankPanel", self)
	self.ClickableArea:SetMouseInputEnabled(true)
	self.ClickableArea:SetCursor("hand")
	function self.ClickableArea:OnMouseReleased(m)
		if (m ~= MOUSE_LEFT) then return end
		local checked = not self:GetParent().Active
		self:GetParent():SetChecked(checked, true)
		if (GAS) then
			if (checked) then
				GAS:PlaySound("btn_on")
			else
				GAS:PlaySound("btn_off")
			end
		end
		if (self:GetParent().OnChange) then
			self:GetParent():OnChange()
		end
	end
end

function PANEL:PerformLayout()
	self.ClickableArea:SetSize(switch_width + label_margin + self.Label:GetWide() + label_margin, switch_height)
end

function PANEL:SetText(text)
	self.Text = text

	self.Label:SetText(text)
	self.Label:SizeToContents()
	self.Label:AlignLeft(switch_width + label_margin)
	self.Label:SizeToContents()

	self:SetSize(switch_width + label_margin + self.Label:GetWide(), switch_height)

	self.Label:CenterVertical()
end
function PANEL:GetText(text)
	return self.Text
end

function PANEL:Paint(w)
	if !self.LeftCircle or !self.RightCircle then
		self.LeftCircle = Circle(switch_height / 2, switch_height / 2, switch_height / 2,20)
		self.RightCircle = Circle(switch_width - switch_height / 2, switch_height / 2, switch_height / 2,20)
	end

	self.ColorInterpolation:DoLerp()
	self.SwitchInterpolation:DoLerp()

	surface.SetDrawColor(self.ColorInterpolation:GetColor())
	draw.NoTexture()
	surface.DrawPoly(self.LeftCircle)
	surface.DrawPoly(self.RightCircle)
	
	surface.DrawRect(switch_height / 2, 0, switch_width - switch_height, switch_height)

	surface.SetDrawColor(255, 255, 255)
	surface.DrawPoly(Circle(self.SwitchInterpolation:GetValue(), switch_height / 2, switch_height / 2 - 2,20))
end

function PANEL:SetChecked(active, animate)
	if (self.Disabled) then return end
	self.Active = active
	local from
	local to
	if (active) then
		from = switch_height / 2
		to = switch_width - (switch_height / 2)
	else
		from = switch_width - (switch_height / 2)
		to = switch_height / 2
	end
	if (animate) then
		self.SwitchInterpolation:SetTo(to)
		self.ColorInterpolation:SetTo(active and on_color or off_color)
	else
		self.SwitchInterpolation = bVGUI.Lerp(to, to, .25)
		if (active) then
			self.ColorInterpolation = bVGUI.LerpColor(on_color, on_color, .25)
		else
			self.ColorInterpolation = bVGUI.LerpColor(off_color, off_color, .25)
		end
	end
end
function PANEL:GetChecked()
	return self.Active
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.HelpLabel:AlignTop(switch_height + 10)
	self.HelpLabel:SetText(text)
	function self.HelpLabel:PerformLayout()
		local w = math.min(500, self:GetParent():GetWide())
		if (self:GetWide() ~= w) then
			self:SetWide(w)
		end
		self:GetParent():SetSize(switch_width + label_margin + self:GetParent().Label:GetWide(), switch_height + 10 + self:GetTall())
	end
end

function PANEL:SetDisabled(disabled)
	self.Disabled = disabled
	if (self.Disabled) then
		self.ColorInterpolation:SetColor(Color(165,165,165))
		self.Label:SetTextColor(Color(180,180,180))
		self.ClickableArea:SetCursor("no")
	else
		self.ClickableArea:SetCursor("hand")
		self.Label:SetTextColor(bVGUI.COLOR_WHITE)
		if (self:GetChecked()) then
			self.ColorInterpolation:SetColor(on_color)
		else
			self.ColorInterpolation:SetColor(off_color)
		end
	end
end
function PANEL:GetDisabled()
	return self.Disabled
end

derma.DefineControl("bVGUI.Switch", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/openpermissions_listview.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset + self:GetParent():GetHeaderHeight()))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayout()

	-- Do Scrollbar
	local Wide = self:GetWide()
	local YPos = 0

	if ( IsValid( self.VBar ) ) then

		self.VBar:SetPos( self:GetWide() - 5 - 3, 3 )
		self.VBar:SetSize( 5, self:GetTall() - 6 )
		self.VBar:SetUp( self.VBar:GetTall() - self:GetHeaderHeight(), self.pnlCanvas:GetTall() )
		YPos = self.VBar:GetOffset()

		if ( self.VBar.Enabled ) then Wide = Wide - 5 end

	end

	if ( self.m_bHideHeaders ) then
		self.pnlCanvas:SetPos( 0, YPos )
	else
		self.pnlCanvas:SetPos( 0, YPos + self:GetHeaderHeight() )
	end

	self.pnlCanvas:SetSize( Wide + self.VBar:GetWide(), self.pnlCanvas:GetTall() )

	self:FixColumnsLayout()

	--
	-- If the data is dirty, re-layout
	--
	if ( self:GetDirty() ) then

		self:SetDirty( false )
		local y = self:DataLayout()
		self.pnlCanvas:SetTall( y )

		-- Layout again, since stuff has changed..
		self:InvalidateLayout( true )

	end

end

derma.DefineControl("OpenPermissions.ListView", nil, PANEL, "DListView")
--addons/tools/lua/vgui/stackerdnumslider.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local math = math
local vgui = vgui
local tonumber = tonumber

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:SetValue( string, boolean )
--
--]]--
function PANEL:SetValue( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )

	if ( val == nil ) then return end
	if ( self:GetValue() == val ) then return end

	self.Scratch:SetFloatValue( val )
	self:ValueChanged( self:GetValue(), bSuppress )
end

--[[--------------------------------------------------------------------------
--
--	PANEL:ValueChanged( string, value)
--
--]]--
function PANEL:ValueChanged( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )
	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )	
	if ( self.TextArea ~= vgui.GetKeyboardFocus() ) then
		self.TextArea:SetValue( self.Scratch:GetTextValue() )
	end
	if ( not bSuppress ) then
		self:OnValueChanged( val )
	end
end

vgui.Register( "StackerDNumSlider", PANEL, "DNumSlider" )
--gamemodes/starwarsrp/gamemode/config.lua:
AOCRP.Config = {}


AOCRP.Config.Version = "0.0.2"

AOCRP.Config.Logo = "4qCpQT8" -- ImgurID of Logo
AOCRP.Config.LogoCropped = "YW14edM" -- ImgurID of cropped Logo

AOCRP.Config.DefaultRank = 1
AOCRP.Config.DefaultGear = 1

AOCRP.Config.BackupModel = "models/starwars/grady/501st/501st_bodybuilder.mdl"

AOCRP.Config.APIUrl = "https://api.ageofclones.de/"

-- Dateiendungen die dazu führen das Content aus Workshop-Addons zum Client geschickt wird. (BSP nicht erforderlich)
AOCRP.Config.WorkshopExt = {"vtf", "vmt", "mp3", "ogg", "wav", "mdl", "phy", "jpg", "jpeg", "png"}


AOCRP.Config.NPCLimit = 50

AOCRP.Config.HauptServerIP = "94.199.215.95:27015"
AOCRP.Config.EventServerIP = "94.199.215.95:27016"
AOCRP.Config.EventCheckForOpenDelay = 60
-- Wartezeit bis Anruf automatisch abgelehnt wird
AOCRP.Config.CallTimeOut = 20

AOCRP.Config.SocketIP = "94.199.215.95:25507"

AOCRP.Config.ManualAddWorkshop = {
  2906844561, -- AOCRP Content 1
  1598105059, -- Fire System
  104607228, -- Fire Extunisher
  2299543771, -- BKeypads
  673961243, -- GMaps
  2468112758, -- PixelUI
  1603635147, -- OpenPermissions
  1596971443, -- GmodAdminSuite
  1100368137, -- Prone
  2003539477, -- AT-RT Content
  893244794, -- Lounge Chat
  2837856621, -- LSCS
  2441211404, -- Police Shield Content
  2328817193, -- Passive Event System
  2159259261, -- Anti Crash
  111412589, -- Rubat Lightsaber
  2003539477, -- SW Shared King Pommes
  617610563, -- Rakghoul
  2502753281, -- Mortar
  3147222013, -- Brandgranate
  3263065765, -- IS1 debug?
  3264695556, -- IS2 Debug?
}


AOCRP.Config.DropBlacklist = { 
  "aoc_animationswep",
  "weapon_fists",
  "astromech_swep",
  "weapon_handcuffed",
  "wookie_swep",
  "gas_log_scanner",
  "weapon_fists",
  "jet_astromech",
  "rw_sw_b2rp_blaster",
  "rw_sw_b2rp_rocket",
  "rw_sw_droideka",
  "rw_sw_droideka_sniper"

}




AOCRP.Config.Fortbildungen = {}

AOCRP.Config.Fortbildungen["laat"] = {name = "LAAT/i - Flugschein", unit = {9}, rank = 5}
AOCRP.Config.Fortbildungen["stfunker"] = {name = "ST - Funker Fortbildung", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["bereichsschutz"] = {name = "Bereichsschutz Fortbildung", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["personenschutz"] = {name = "Personenschutz Fortbildung", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["gesetzestestintern"] = {name = "SG u. RG Theorietest (Intern)", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["schockstab"] = {name = "Schockstab-Einweisung", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["lcpleignung"] = {name = "Lance Corporal Eignungstest", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["gesetzestestextern"] = {name = "SG u. RG Theorietest (Extern)", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["ladungssicherung"] = {name = "Ladungssicherung/kontrolle", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["erstehilfe"] = {name = "Erste-Hilfe Fortbildung", unit = {4}, rank = 7}
AOCRP.Config.Fortbildungen["tcschildtraeger"] = {name = "Schildträger Fortbildung", unit = {3}, rank = 7}
AOCRP.Config.Fortbildungen["barcspeeder"] = {name = "BARC-Speeder Fortbildung", unit = {9}, rank = 7}
AOCRP.Config.Fortbildungen["stgranaten"] = {name = "Schocktruppen Granaten Fortbildung", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["enetz"] = {name = "E-Netz Fortbildung", unit = {6}, rank = 7}
AOCRP.Config.Fortbildungen["grundkpsycho"] = {name = "Grundkurs Psychologie", unit = {4}, rank = 7}
AOCRP.Config.Fortbildungen["stpsychologe"] = {name = "Schocktruppen Psychologe (freiwillig)", unit = {4}, rank = 7}
AOCRP.Config.Fortbildungen["spurensuche"] = {name = "Spurensuche Fortbildung (freiwillig)", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["fortbilderone"] = {name = "Fortbilder Schein I.", unit = {8}, rank = 7}
AOCRP.Config.Fortbildungen["laatle"] = {name = "LAAT/le Fortbildung", unit = {9}, rank = 7}
AOCRP.Config.Fortbildungen["fortbildertwo"] = {name = "Fortbilder Schein II.", unit = {8}, rank = 8}
AOCRP.Config.Fortbildungen["sttryoutschein"] = {name = "Schocktruppen TO Schein", unit = {8}, rank = 8}

AOCRP.Config.TextFunkEveryone = {"Truppen", "Alle","Penis"}

AOCRP.Config.PaydayAmount = 50
AOCRP.Config.PayDayTimer = 900
AOCRP.Config.PayDayPercent = {
		["user"] = 1.0, 
		["Donator_T1"] = 1.5,
		["Donator_T2"] = 2.0,
		["Donator_T3"] = 2.5,
		["Junior-Moderator"] = 2.5,
		["Moderator"] = 2.5,
		["Senior-Moderator"] = 2.5,
		["admin"] = 2.5,
		["superadmin"] = 5,
}

AOCRP.Config.CharSlots = {
  ["user"] = 1, 
  ["Donator_T1"] = 2,
  ["Donator_T2"] = 3,
  ["Donator_T3"] = 4,
  ["Junior-Moderator"] = 4,
  ["Moderator"] = 4,
  ["Senior-Moderator"] = 4,
  ["admin"] = 4,
  ["superadmin"] = 5,
}

AOCRP.Config.CloneID = {"Donator_T1", "Donator_T2", "Donator_T3", "Junior-Moderator", "Moderator", "Senior-Moderator", "admin", "superadmin"}
AOCRP.Config.Team = {"Junior-Moderator", "Moderator", "Senior-Moderator", "admin", "superadmin"}

AOCRP.Config.NPCKillMoney = 5 -- Wv credits bei NPC kill


AOCRP.Config.DefaultWeapons = {
  "aoc_animationswep",
  "weapon_fists",
  "aocrp_datapad"
}

AOCRP.Config.NoStripWeapons = {
    "weapon_handcuffed"
}


AOCRP.Config.FireImmuneModels = {
  "models/starwars/grady/aoc/212th/ec/212th_flametrooper.mdl"
}

-- Einfach nicht anfassen
AOCRP.Config.NetOverrideDebug = false


AOCRP.Config.ActsToGTM = {}
--AOCRP.Config.ActsToGTM[1642] = "act_dance"
AOCRP.Config.ActsToGTM[53] = "act_forward"
AOCRP.Config.ActsToGTM[54] = "act_group"
AOCRP.Config.ActsToGTM[55] = "act_halt"
AOCRP.Config.ActsToGTM[1611] = "act_becon"
AOCRP.Config.ActsToGTM[1612] = "act_bow"
AOCRP.Config.ActsToGTM[1613] = "act_disagree"
AOCRP.Config.ActsToGTM[1614] = "act_salute"
AOCRP.Config.ActsToGTM[1615] = "act_wave"
AOCRP.Config.ActsToGTM[1616] = "act_pers"
--AOCRP.Config.ActsToGTM[1618] = "act_laugh"
AOCRP.Config.ActsToGTM[1620] = "act_cheer"
AOCRP.Config.ActsToGTM[1641] = "act_zombie"
AOCRP.Config.ActsToGTM[1643] = "act_robot"
AOCRP.Config.ActsToGTM[1610] = "act_agree"
AOCRP.Config.Distances = {}
AOCRP.Config.Distances[4] = { distance = 1200, color = Color(255,0,234), msg = "Du schreist nun um dein Leben" } -- Schreien
AOCRP.Config.Distances[3] = { distance = 750, color = Color(255,0,0), msg = "Du schreist nun" } -- Schreien
AOCRP.Config.Distances[2] = { distance = 500, color = Color(0,255,0), msg = "Du redest nun" }  -- Reden
AOCRP.Config.Distances[1] = { distance = 100, color = Color(255,174,0), msg = "Du flüsterst nun" }  -- Flüstern
AOCRP.Config.DefaultDistance = 2
AOCRP.Config.ChangeSound = "everfall/miscellaneous/ux/navigation/navigation_carousel_01.mp3"

-- Danger do not touch!
--seconds
AOCRP.Config.StatsSaveLoop = 60
-- Danger over

AOCRP.Config.SpawnDelay = 120
AOCRP.Config.InstantRespawnPrice = 1000

AOCRP.Config.HideHUD = {
	["CHudCrosshair"] = true,
	["CHudDeathNotice"] = true,
  ["VoiceNotify"] = false,
  ["CHudAmmo"] = true,
  ["CHudBattery"] = true,
  ["CHudHealth"] = true,
  ["CHudDeathNotice"] = true,
  ["CHudWeaponSelection"] = true,
}

AOCRP.Config.HUDEntTraceDistance = 200

AOCRP.Config.Rakghoul = {}
-- Time of infection, before transforming to rakghoul
AOCRP.Config.Rakghoul.InfectionTime = 120

-- Percent of a infection with the rakghoul virus (30 = 30%)
AOCRP.Config.Rakghoul.InfectionRate = 30

-- Whats the immunity time after serum injection
AOCRP.Config.Rakghoul.ImmunityTime = 900

-- The model, which will set the rakghoul
AOCRP.Config.Rakghoul.Model = "models/grealms/characters/rakghoul/rakghoul.mdl"

-- The health of a rakghoul
AOCRP.Config.Rakghoul.Health = 1000

-- These models cannot be infected by rakghoul
AOCRP.Config.Rakghoul.ProtectedModels = {
    ["models/deltaa/nuru_kungurama.mdl"] = true,
    ["models/xozz/bf2/anakin.mdl"] = true,
    ["models/xozz/bf2/obiwankenobi.mdl"] = true,
    ["models/plo/ahsoka/ahsoka_s7.mdl"] = true,
    ["models/starwars/grady/212th/commander_cody/commander_cody_ph2.mdl"] = true,
    ["models/starwars/grady/501st/captain_rex/captain_rex_ph2.mdl"] = true,
    ["models/starwars/grady/aoc/st/st_lore/commander_fox.mdl"] = true,
    ["models/starwars/grady/aoc/st/st_lore/jek.mdl"] = true,
    ["models/starwars/grady/aoc/st/st_lore/sergeant_hound.mdl"] = true,
    ["models/starwars/grady/arc/aoc/501st_arc_fives.mdl"] = true,
	-- ["Some Modelpath"] = Percent,
}


AOCRP.Config.Defcon = {}
AOCRP.Config.Defcon[0] = {
  title = "Normalbetrieb",
  text = "Normalbetrieb\nsämtliche Freizeitaktivitäten gestattet!",
  color = Color(255,255,255)
}
AOCRP.Config.Defcon[5] = {
  title = "BEREITSCHAFTALARM",
  text = "BEREITSCHAFTALARM\nKampfbereitschaft herstellen!",
  soundurl = "https://ageofclones.de/aoc_content/sounds/defcon/Defcon_5.wav",
  color = Color(0,163,22)
}
AOCRP.Config.Defcon[4] = {
  title = "ANÄHERUNGSALARM",
  text = "ANÄHERUNGSALARM\nBedrohung in unmittelbarer Nähe! Auf Verteidigungsposition!",
  soundurl = "https://ageofclones.de/aoc_content/sounds/defcon/Defcon_4.wav",
  color = Color(255,136,0)
}
AOCRP.Config.Defcon[3] = {
  title = "ANGRIFFSALARM",
  text = "ANGRIFFSALARM\nFeinde greifen uns an! Auf Verteidigungsposition!",
  soundurl = "https://ageofclones.de/aoc_content/sounds/defcon/Defcon_3.wav",
  color = Color(255,0,0)
}
AOCRP.Config.Defcon[2] = {
  title = "INFILTRATIONSALARM",
  text = "INFILTRATIONSALARM\nFeinde aufspüren und vernichten!",
  soundurl = "https://ageofclones.de/aoc_content/sounds/defcon/Defcon_2.wav",
  color = Color(255,0,0)
}
AOCRP.Config.Defcon[1] = {
  title = "EVAKUIERUNG",
  text = "EVAKUIERUNG!\nBasis/Schiff sofort verlassen!",
  soundurl = "https://ageofclones.de/aoc_content/sounds/defcon/Defcon_1.wav",
  color = Color(255,0,0)
}
AOCRP.Config.Defcon[420] = {
  text = "LAUSCHER AUF",
  title = "LAUSCHER AUF",
  soundurl = "https://github.com/Rinocarlos/testteil/blob/main/fickdichnytek.m4a?raw=true",
  color = Color(255,0,0)
}
AOCRP.Config.Defcon[69] = {
  text = "Auf 69 Kurs!",
  title = "69 Kurs",
  soundurl = "https://github.com/peterkuzik/randomfiles/raw/master/AOC/join.mp3",
  color = Color(255,0,0)
}



AOCRP.Config.UnitToHandModel = {}

AOCRP.Config.UnitToHandModel[3] = "models/starwars/grady/501st_hands/501st_trooper_hands.mdl"
--AOCRP.Config.UnitToHandModel[8] = "models/starwars/grady/aoc/st/st_lore/commander_fox_viewhands.mdl"



AOCRP.Config.PlayerSettings = {}

AOCRP.Config.PlayerSettings[1] = { name = "Tastenbelegungen", cmd = "aocrp_binds"}
AOCRP.Config.PlayerSettings[2] = { name = "Fahrzeugeinstellungen", cmd = "lvs_openmenu"}


AOCRP.Config.PlayerSettings[3] = { name = "HUD an/aus", cmd = "say /hud"}
AOCRP.Config.PlayerSettings[4] = { name = "Squadliste an/aus", cmd = "say /sl"}
AOCRP.Config.PlayerSettings[5] = { name = "Knochen richten", cmd = "say /knochen"}
AOCRP.Config.PlayerSettings[6] = { name = "Skin zurücksetzen", cmd = "say /sr"}
AOCRP.Config.PlayerSettings[7] = { name = "GTM Autoausrüsten zurücksetzen", cmd = "say /rds"}



--AOCRP.Config.PlayerSettings[99] = { name = "Alte Spielerdaten importieren", cmd = "say /import"}




AOCRP.Config.RanksToRibbons = {
  ["Donator_T1"] = "newcomer",
  ["Donator_T2"] = "hero",
  ["Donator_T3"] = "legend",
  ["Junior-Moderator"] = "legend",
  ["Moderator"] = "legend",
  ["Senior-Moderator"] = "legend",
  ["admin"] = "legend",
  ["superadmin"] = "legend",
}



AOCRP.Config.Crosshair = {}

AOCRP.Config.Crosshair["crosshair_rc"] = { img = "aoc/crosshairs/rc.png", cl = Color(255,255,255), name = "Republic Commando", price = 50000}
AOCRP.Config.Crosshair["crosshair_complex"] = { img = "aoc/crosshairs/complex.png", cl = Color(255,255,255), name = "Complex", price = 50000}
AOCRP.Config.Crosshair["crosshair_heavy"] = { img = "aoc/crosshairs/heavy.png", cl = Color(255,255,255), name = "Heavy", price = 50000}
AOCRP.Config.Crosshair["crosshair_square"] = { img = "aoc/crosshairs/square.png", cl = Color(255,255,255), name = "Square", price = 50000}
AOCRP.Config.Crosshair["crosshair_point"] = { img = "aoc/crosshairs/point.png", cl = Color(255,255,255), name = "Punkt", price = 45000}
AOCRP.Config.Crosshair["crosshair_point_red"] = { img = "aoc/crosshairs/point.png", cl = Color(143,0,0), name = "Roter Punkt", price = 50000}


AOCRP.Config.LocalPrintDistance = 500


AOCRP.Config.Sicherheitslevel = {}
AOCRP.Config.Sicherheitslevel[0] = { name = "Echo", color = Color(0,255,0), text = "E", rank = 2, units = {}, gears = {}}
AOCRP.Config.Sicherheitslevel[1] = { name = "Delta", color = Color(255,255,0), text = "D", rank = 14, units = {6,4,8,9}} 
AOCRP.Config.Sicherheitslevel[2] = { name = "Charlie", color = Color(255,100,0), text = "C", rank = 10, units = {6,4,8,9}}
AOCRP.Config.Sicherheitslevel[3] = { name = "Bravo", color = Color(255,0,0), text = "B", rank = 14, units = {6,4,8,9}}
AOCRP.Config.Sicherheitslevel[4] = { name = "Alpha", color = Color(255,0,255), text = "A", rank = 16, units = {6,4,8,9}}
AOCRP.Config.Sicherheitslevel[5] = { name = "Gefängnis", color = Color(255,0,255), text = "G", rank = 14, units = {6,4,8,9}}
AOCRP.Config.Sicherheitslevel[6] = { name = "SEB", color = Color(195,0,255), text = "S", rank = 16, units = {6,4,8,9, 16}, gears = {182}}




AOCRP.Config.TerminalCombinations = {

  { {"Red", false}, {"Blue", 1}, {"Blue", 2}, {"Blue", 3}, {"Blue", 4} },
  { {"Red", false}, {"Red", false}, {"Blue", 1}, {"Blue", 2}, {"Blue", 3} },
  { {"Red", 1}, {"Red", 2}, {"Red", 3}, {"Blue", false}, {"Blue", false} },
  { {"Red", 1}, {"Red", 2}, {"Red", 3}, {"Red", 4}, {"Blue", false} },
  { {"Red", 5}, {"Red", 4}, {"Red", 3}, {"Red", 2}, {"Red", 1} },

  { {"Orange", 3}, {"Orange", 2}, {"Orange", 1}, {"Orange", 4}, {"Orange", 5} },
  { {"Orange", false}, {"Red", 4}, {"Red", 2}, {"Red", 1}, {"Red", 3} },
  { {"Orange", false}, {"Orange", false}, {"Red", 2}, {"Red", 1}, {"Red", 3} },
  { {"Orange", 1}, {"Orange", 3}, {"Orange", 2}, {"Red", false}, {"Red", false} },
  { {"Orange", 1}, {"Orange", 3}, {"Orange", 2}, {"Orange", 4}, {"Red", false} },

  { {"Black", 1}, {"Black", 2}, {"Black", 3}, {"Black", 4}, {"Black", 5} },
  { {"Black", false}, {"White", 4}, {"White", 3}, {"White", 2}, {"White", 1} },
  { {"Black", false}, {"Black", false}, {"White", 3}, {"White", 2}, {"White", 1} },
  { {"Black", 1}, {"Black", 2}, {"Black", 3}, {"White", false}, {"White", false} },
  { {"Black", 1}, {"Black", 2}, {"Black", 3}, {"Black", 4}, {"White", false} },

  { {"White", 5}, {"White", 4}, {"White", 1}, {"White", 2}, {"White", 3} },
  
}





AOCRP.Config.FreeAttachments = {"uc_optic_sureshot","uc_grip_kacvfg","uc_optic_micro_t1"}


AOCRP.Config.DefaultMedicSupply = 5000




AOCRP.Config.BlockedCharNames = {
  "Rex",
  "Cody",
  "Gree",
  "Bly",
  "Ponds",
  "Wolffe",
  "Fox",
  "Thorn",
  "Stone",
  "Thire",
  "Appo",
  "Fil",
  "Neyo",
  "Bacara",
  "Jet",
  "Faie",
  "Baccara",
  "Neyo",
  "Vill",
  "Tano",
  "Fives",
  "Hitler",
  "Adolf",
  "Sammy",
  "Rino"
}

AOCRP.Config.ComlinkDialTime = 15 -- Zeit wie lange das Telefon wählt.
AOCRP.Config.ComlinkSound = "everfall/miscellaneous/ux/navigation/navigation_carousel_01.mp3"



AOCRP.Config.Binds = {}

--[[ AOCRP.Config.Binds["abseilen"] = {
  name = "Abseilen",
  desc = "Aus Fahrzeug abseilen",
  defaultkey = KEY_F,
  downFunc = function() LocalPlayer():ConCommand("rappel_helirappel ") end,
  upFunc = function() end
} ]]

AOCRP.Config.Binds["timer"] = {
  category = "Kurzbefehle",
  name = "Stoppuhr",
  desc = "Stoppuhr in Sekunden",
  defaultkey = KEY_NONE,
  downFunc = function() LocalPlayer():ConCommand("aocrp_timer") end,
  upFunc = function() end
}

AOCRP.Config.Binds["comlink"] = {
  category = "Comlink",
  name = "Comlink",
  desc = "Öffne deinen Comlink",
  defaultkey = KEY_H,
  downFunc = function() AOCRP.Comlink:OpenMenu() end,
  upFunc = function() end
}

AOCRP.Config.Binds["map"] = {
  category = "Menüs",
  name = "Übersichtskarte",
  desc = "Öffne die Übersichtskarte",
  defaultkey = KEY_M,
  downFunc = function() end,
  upFunc = function() if !AOCRP_BlockM then AOCRP.TacMap:OpenTacMap() else AOCRP_BlockM = false end end
}


AOCRP.Config.Binds["comlinkf1"] = {
  category = "Comlink",
  name = "Comlink-Schnelltaste 1",
  desc = "Nutze definierte Schnellfunktion",
  defaultkey = KEY_F1,
  downFunc = function() LocalPlayer():ComlinkSetQuickBind("f1") end,
  upFunc = function() end
}

AOCRP.Config.Binds["comlinkf2"] = {
  category = "Comlink",
  name = "Comlink-Schnelltaste 2",
  desc = "Nutze definierte Schnellfunktion",
  defaultkey = KEY_F2,
  downFunc = function() LocalPlayer():ComlinkSetQuickBind("f2") end,
  upFunc = function() end
}

AOCRP.Config.Binds["comlinkf3"] = {
  category = "Comlink",
  name = "Comlink-Schnelltaste 3",
  desc = "Nutze definierte Schnellfunktion",
  defaultkey = KEY_F3,
  downFunc = function() LocalPlayer():ComlinkSetQuickBind("f3") end,
  upFunc = function() end
}

AOCRP.Config.Binds["comlinkfullmute"] = {
  category = "Comlink",
  name = "Comlink stummschalten",
  desc = "Schaltet dein gesamten Comlink stumm. (Noch nicht fertig)",
  defaultkey = KEY_NONE,
  downFunc = function() end,
  upFunc = function() end
}

AOCRP.Config.Binds["quickclose"] = {
  category = "Menüs",
  name = "QuickClose",
  desc = "Schließt mit einem Tastendruck die AOC-Fenster",
  defaultkey = KEY_NONE,
  downFunc = function() end,
  upFunc = function() end
}

AOCRP.Config.Binds["thirdperson"] = {
  category = "Allgemeines",
  name = "Thirdperson",
  desc = "Wechsle zwischen der Ego- oder Aussen-Perspektive.",
  defaultkey = KEY_T,
  downFunc = function() ThirdPersonUmsg() end,
  upFunc = function() end
}

AOCRP.Config.Binds["quicksalute"] = {
  category = "Kurzbefehle",
  name = "Schnell-Salutieren",
  desc = "Wechsle mit einem Knopfdruck auf das Animationswep und Salutiere.",
  defaultkey = KEY_NONE,
  downFunc = function() AOCRP.Animation:QuickSalute() end,
  upFunc = function() end
}




AOCRP.Config.Binds["quickanimation"] = {
  category = "Kurzbefehle",
  name = "Schnellanimationswechsel",
  desc = "Wechsel schnell zur Animations Waffe",
  defaultkey = KEY_NONE,
  downFunc = function() RunConsoleCommand("say","/animation") end,
  upFunc = function() end
}

AOCRP.Config.Binds["id"] = {
  category = "Kurzbefehle",
  name = "ID vorzeigen",
  desc = "Zeige deine ID vor",
  defaultkey = KEY_NONE,
  downFunc = function() RunConsoleCommand("say","/id") end,
  upFunc = function() end
}

AOCRP.Config.Binds["voicedistance"] = {
  category = "Allgemeines",
  name = "Sprachdistanz ändern",
  desc = "Ändern der Sprachdistanz",
  defaultkey = KEY_O,
  downFunc = function() AOCRP.VoiceDistance:Change() end,
  upFunc = function() end
}

AOCRP.Config.Binds["mouse"] = {
  category = "Menüs",
  name = "Mauszeiger aktivieren",
  desc = "Aktiviere den Mauszeiger",
  defaultkey = KEY_NONE,
  downFunc = function() gui.EnableScreenClicker(true) end,
  upFunc = function() gui.EnableScreenClicker(false) end
}

AOCRP.Config.Binds["prone"] = {
  category = "Allgemeines",
  name = "Kriechen",
  desc = "Krieche auf allen vieren..",
  defaultkey = KEY_G,
  downFunc = function() LocalPlayer():ConCommand("prone") end,
  upFunc = function() end
}


AOCRP.Config.Binds["gtm"] = {
  category = "Menüs",
  name = "Galactic Trade Market",
  desc = "Öffnet den GTM",
  defaultkey = KEY_NONE,
  downFunc = function() AOCRP.GTM:OpenMenu() end,
  upFunc = function() end
}

AOCRP.Config.Binds["squadpos"] = {
  category = "Squad",
  name = "Squadpositionen",
  desc = "Öffnet ein Menü indem du deine Squadposition wählen kannst.",
  defaultkey = KEY_NONE,
  downFunc = function() AOCRP.Squad:SquadPosMenu() end,
  upFunc = function() end
}


AOCRP.Config.Binds["squadlist"] = {
  category = "Squad",
  name = "Squadliste",
  desc = "Zeigt die Squadliste links an.",
  defaultkey = KEY_NONE,
  downFunc = function() LocalPlayer().SquadList = true end,
  upFunc = function() LocalPlayer().SquadList = false end
}

AOCRP.Config.Binds["squadlistumsch"] = {
  category = "Squad",
  name = "Squadliste (umschalt)",
  desc = "Zeige die Squadliste links an.",
  defaultkey = KEY_NONE,
  downFunc = function() LocalPlayer().SquadList = !LocalPlayer().SquadList end,
  upFunc = function() end
}


AOCRP.Config.Binds["callaccept"] = {
  category = "Comlink",
  name = "Anruf annehmen",
  desc = "Nehme einen eingehenden Anruf an",
  defaultkey = KEY_Q,
  downFunc = function() end,
  upFunc = function() end
}
AOCRP.Config.Binds["calldeny"] = {
  category = "Comlink",
  name = "Anruf ablehnen",
  desc = "Lehne einen eingehenden Anruf ab.",
  defaultkey = KEY_E,
  downFunc = function() end,
  upFunc = function() end
}
 
AOCRP.Config.Binds["rpbinds"] = {
  category = "Menüs",
  name = "Roleplay Binds",
  desc = "Öffnet ein Menü indem du Binds fürs PassivRP abspeichern kannst. Spart mies Knöpfe.",
  defaultkey = KEY_NONE,
  downFunc = function() AOCRP.RPBinds:RPBindsMenu() end,
  upFunc = function() end
}
 


 
 
AOCRP.Config.Binds["arccw_firemode"] = {
  category = "Waffen",
  name = "Feuermodus ändern",
  desc = "Schalte deinen Feuermodus um",
  defaultkey = KEY_B,
  downFunc = function() RunConsoleCommand("arccw_firemode") end,
  upFunc = function() end
}
AOCRP.Config.Binds["arccw_zoom_in"] = {
  category = "Waffen",
  name = "Visier hereinzoomen",
  desc = "Zomme in deinem Visier mehr herein",
  defaultkey = KEY_NONE,
  downFunc = function() RunConsoleCommand("arccw_zoom_in") end,
  upFunc = function() end
}
AOCRP.Config.Binds["arccw_zoom_out"] = {
  category = "Waffen",
  name = "Visier herauszoomen",
  desc = "Zoome in deinem Visier mehr heraus",
  defaultkey = KEY_NONE,
  downFunc = function() RunConsoleCommand("arccw_zoom_out") end,
  upFunc = function() end
}
AOCRP.Config.Binds["arccw_toggle_inv"] = {
  category = "Waffen",
  name = "Anpassungsmenü",
  desc = "Öffnet das Menü zum Einstellen der Attachments",
  defaultkey = KEY_C,
  downFunc = function() RunConsoleCommand("arccw_toggle_inv") end,
  upFunc = function() end
}
AOCRP.Config.Binds["arccw_switch_scope"] = {
  category = "Waffen",
  name = "Visier umschalten",
  desc = "Schalte Sonderfunktionen deines Visiers um",
  defaultkey = KEY_E,
  downFunc = function() RunConsoleCommand("arccw_switch_scope") end,
  upFunc = function() end
}
AOCRP.Config.Binds["arccw_toggle_ubgl"] = {
  category = "Waffen",
  name = "Granatwerfer umschalten",
  desc = "Schalte auf den Granatwerfer um",
  defaultkey = KEY_NONE,
  downFunc = function() RunConsoleCommand("arccw_toggle_ubgl") end,
  upFunc = function() end
}
AOCRP.Config.Binds["arccw_melee"] = {
  category = "Waffen",
  name = "Nahkampf",
  desc = "Führt einen Schlag mit der Waffe aus.",
  defaultkey = KEY_NONE,
  downFunc = function() RunConsoleCommand("arccw_melee") end,
  upFunc = function() end
}
AOCRP.Config.Binds["arccw_toggle_att"] = {
  category = "Waffen",
  name = "Attachmentaktion",
  desc = "Schalte Sonderfunktionen deiner Attachments um",
  defaultkey = KEY_NONE,
  downFunc = function() RunConsoleCommand("arccw_toggle_att") end,
  upFunc = function() end
}


AOCRP.Config.SquadHalo = true 
AOCRP.Config.SquadHaloColor = Color(255,255,255,10)


AOCRP.Config.SquadTeams = {}


AOCRP.Config.SquadTeams[1] = {name = "Standard", color = Color(0,0,0)}
AOCRP.Config.SquadTeams[2] = {name = "Rot", color = Color(255,0,0)}
AOCRP.Config.SquadTeams[3] = {name = "Grün", color = Color(0,255,0)}
AOCRP.Config.SquadTeams[4] = {name = "Blau", color = Color(0,0,200)}
AOCRP.Config.SquadTeams[5] = {name = "Orange", color = Color(255,150,0)}
AOCRP.Config.SquadTeams[6] = {name = "Hellblau", color = Color(0,255,255)}
AOCRP.Config.SquadTeams[7] = {name = "Pink", color = Color(255,0,255)}


--[[ AOCRP.Config.SquadTeams["Weiß"] = Color(255,255,255)
AOCRP.Config.SquadTeams["Blau"] = Color(0,0,200)
AOCRP.Config.SquadTeams["Rot"] = Color(255,0,0)
AOCRP.Config.SquadTeams["Türkis"] = Color(0,200,200)
AOCRP.Config.SquadTeams["Pink"] = Color(200,0,200)
AOCRP.Config.SquadTeams["Orange"] = Color(200,113,0)
AOCRP.Config.SquadTeams["Grün"] = Color(0,200,0) ]]

AOCRP.Config.SquadPos = {}
AOCRP.Config.SquadPos[""] = "Mitglied"
AOCRP.Config.SquadPos["!!"] = "Squadleader"
AOCRP.Config.SquadPos["!"] = "Stellvertreter"
AOCRP.Config.SquadPos["#"] = "Sanitäter"
AOCRP.Config.SquadPos["t"] = "Techniker"
AOCRP.Config.SquadPos["&"] = "VIP"
AOCRP.Config.SquadPos["f"] = "Funker"


AOCRP.Config.SquadBefehleRadial = {
  {
      name = "Abbrechen",
      func = function() end,
  },
  {
      name = "Sammeln",
      func = function() AOCRP.Squad:SquadBefehl(LocalPlayer(), "Beim Squadleader sammeln!") end,
  },
  {
      name = "Feuer frei",
      func = function() AOCRP.Squad:SquadBefehl(LocalPlayer(), "Feuer Frei") end,
  },
  {
      name = "Rundumsicherung",
      func = function() AOCRP.Squad:SquadBefehl(LocalPlayer(), "Rundumsicherung aufbauen!") end,
  },
  {
      name = "Deckung",
      func = function() AOCRP.Squad:SquadBefehl(LocalPlayer(), "Deckung suchen und bereithalten!") end,
  },
  {
      name = "Rückzug",
      func = function() AOCRP.Squad:SquadBefehl(LocalPlayer(), "Taktischer Rückzug!") end,
  },
  {
      name = "Ruhe",
      func = function() AOCRP.Squad:SquadBefehl(LocalPlayer(), "Leise sein! Funkstille!") end,
  },
  {
      name = "Vorrücken",
      func = function() AOCRP.Squad:SquadBefehl(LocalPlayer(), "Auf gehts, Vorrücken!") end,
  },
}

--[[ AOCRP.Config.SquadMarkersRadial = {
  {
      name = "Abbrechen",
      func = function() end,
  },
  {
      name = "FEIND",
      func = function() AOCRP.HUD:RequestSquadMarker(LocalPlayer():GetEyeTrace().HitPos, "F", Color(255,0,0), 10, LocalPlayer():Nick(), "everfall/miscellaneous/ux/rankup/eor_levelupbig_02.mp3") end,
  },
  {
      name = "PANZER",
      func = function() AOCRP.HUD:RequestSquadMarker(LocalPlayer():GetEyeTrace().HitPos, "P", Color(255,0,0), 10, LocalPlayer():Nick(), "everfall/miscellaneous/ux/rankup/eor_levelupbig_02.mp3") end,
  },
  {
      name = "FREUND",
      func = function() AOCRP.HUD:RequestSquadMarker(LocalPlayer():GetEyeTrace().HitPos, "*", Color(0,255,0), 10, LocalPlayer():Nick(), "everfall/miscellaneous/ux/rankup/eor_levelupbig_02.mp3") end,
  },
  {
      name = "MEDIC",
      func = function() AOCRP.HUD:RequestSquadMarker(LocalPlayer():GetEyeTrace().HitPos, "+", Color(0,255,0), 10, LocalPlayer():Nick(), "everfall/miscellaneous/ux/rankup/eor_levelupbig_02.mp3") end,
  },
  {
      name = "HIER",
      func = function() AOCRP.HUD:RequestSquadMarker(LocalPlayer():GetEyeTrace().HitPos, "#", Color(255,255,0), 10, LocalPlayer():Nick(), "everfall/miscellaneous/ux/rankup/eor_levelupbig_02.mp3") end,
  },
}
 ]]

AOCRP.Config.SquadMarker = {}
AOCRP.Config.SquadMarker[1] = {title = "HIER", symbol = "T", cl = Color(255,255,255)}
AOCRP.Config.SquadMarker[2] = {title = "Feind", symbol = "*", cl = Color(255,0,0)}
AOCRP.Config.SquadMarker[3] = {title = "Neutral", symbol = "*", cl = Color(255,255,0)}
AOCRP.Config.SquadMarker[4] = {title = "Freund", symbol = "*", cl = Color(0,255,0)}
AOCRP.Config.SquadMarker[5] = {title = "MEDIC", symbol = "+", cl = Color(255,72,0)}




AOCRP.Config.Binds["squadquick"] = {
  category = "Squad",
  name = "Squadbefehle",
  desc = "Öffnet ein Radialmenü wo alle Schnellbefehle ausgewählt werden können",
  defaultkey = KEY_NONE,
  downFunc = function() AOCDerma:RadialMenu(AOCRP.Config.SquadBefehleRadial) end,
  upFunc = function() if ValidPanel(AOCDerma.RMenu) then AOCDerma.RMenu:Remove() end end
}
--[[ AOCRP.Config.Binds["squadquickmarkers"] = {
  name = "Squadmarkierungen",
  desc = "Öffnet ein Radialmenü wo alle Squadmarkierung ausgewählt werden können",
  defaultkey = KEY_NONE,
  downFunc = function() AOCDerma:RadialMenu(AOCRP.Config.SquadMarkersRadial) end,
  upFunc = function() if ValidPanel(AOCDerma.RMenu) then AOCDerma.RMenu:Remove() end end
}
 ]]

AOCRP.Config.Binds["qim"] = {
  category = "Allgemeines",
  name = "Quick Interaction Menu",
  desc = "",
  defaultkey = 61,
  downFunc = function() AOCRP.QIM:OpenMenu() end,
  upFunc = function()  if ValidPanel(AOCRP.QIM.FRAME) then AOCRP.QIM.FRAME:Remove() end  end
}


AOCRP.Config.Binds["ability"] = {
  category = "Allgemeines",
  name = "Fähigkeit einsetzen",
  desc = "",
  defaultkey = KEY_Q,
  downFunc = function() LocalPlayer():ConCommand("say /ability") end,
  upFunc = function() end
}


AOCRP.Config.SubUnits = {}
AOCRP.Config.SubUnits[1] = {name = "Kein Platoon", prefix = "", unitid = 0}

AOCRP.Config.SubUnits[2] = {name = "Heavy Platoon", prefix = "Heavy", unitid = 3}
AOCRP.Config.SubUnits[3] = {name = "Jaig Platoon", prefix = "Jaig",  unitid = 3}
AOCRP.Config.SubUnits[4] = {name = "Rex Platoon", prefix = "Rex",  unitid = 3}
AOCRP.Config.SubUnits[5] = {name = "Triton Squad", prefix = "Triton",  unitid = 3}


AOCRP.Config.SubUnits[6] = {name = "Rancor  Platoon", prefix = "Rancor",  unitid = 5}
AOCRP.Config.SubUnits[7] = {name = "Zillo Platoon", prefix = "Zillo",  unitid = 5}
AOCRP.Config.SubUnits[8] = {name = "Nexu Platoon", prefix = "Nexu",  unitid = 5}
AOCRP.Config.SubUnits[9] = {name = "Parjai Squad", prefix = "Parjai",  unitid = 5}

AOCRP.Config.SubUnits[10] = {name = "Fleet Crew", prefix = "FC",  unitid = 9}
AOCRP.Config.SubUnits[11] = {name = "Galactic Marines", prefix = "GM", unitid = 9}
AOCRP.Config.SubUnits[12] = {name = "Armored Vehicle Platoon", prefix = "AVP", unitid = 9} 


AOCRP.Config.SubUnits[13] = {name = "K9", prefix = "K9", unitid = 8}
AOCRP.Config.SubUnits[14] = {name = "Jumptrooper", prefix = "JT",  unitid = 4}
AOCRP.Config.SubUnits[15] = {name = "Flametrooper", prefix = "FT",  unitid = 6}


--- talk/hear syntax 
--[[ 

talk/hear syntax 
{u=0,r=11,g={},su=0}

u = unitid, 0=none
r = minrang
g = tbl mit gears
su = subunitid, 0=none
all = true, alle

 ]]

AOCRP.Config.Funks = {}
AOCRP.Config.Funks[1] = { short = "ANK", name = "Ankündigung", canMute = false, defMute = false, talk = {r=11}, hear = {r=1} }
AOCRP.Config.Funks[2] = { short = "ELT", name = "Einsatzleitung", canMute = true, defMute = true, talk = {r=2}, hear = {r=2} }
AOCRP.Config.Funks[3] = { short = "ATC", name = "Air Traffic Control", canMute = true, defMute = true, talk = {all=true}, hear = {all=true} }

AOCRP.Config.Funks[100] = { short = "TC", name = "Torrent Company", canMute = true, defMute = false, talk = {u=3}, hear = {u=3} }
AOCRP.Config.Funks[101] = { short = "TCA", name = "TC Ankündigung", canMute = false, defMute = false, talk = {u=3,r=8}, hear = {u=3} }
AOCRP.Config.Funks[102] = { short = "GC", name = "Ghost Company", canMute = true, defMute = false, talk = {u=5}, hear = {u=5} }
AOCRP.Config.Funks[103] = { short = "GCA", name = "GC Ankündigung", canMute = false, defMute = false, talk = {u=5,r=8}, hear = {u=5} }
AOCRP.Config.Funks[104] = { short = "EC", name = "Engineering Company", canMute = true, defMute = false, talk = {u=6}, hear = {u=6} }
AOCRP.Config.Funks[105] = { short = "ECA", name = "EC Ankündigung", canMute = false, defMute = false, talk = {u=6,r=8}, hear = {u=6} }
AOCRP.Config.Funks[106] = { short = "ST", name = "Schocktruppen", canMute = true, defMute = false, talk = {u=8}, hear = {u=8} }
AOCRP.Config.Funks[107] = { short = "STA", name = "ST Ankündigung", canMute = false, defMute = false, talk = {u=8,r=8}, hear = {u=8} }
AOCRP.Config.Funks[108] = { short = "RN", name = "Republic Navy", canMute = true, defMute = false, talk = {u={9,15}}, hear = {u={9,15}} }
AOCRP.Config.Funks[109] = { short = "FT", name = "Flugtaktik", canMute = true, defMute = true, talk = {r=2}, hear = {r=2} }
AOCRP.Config.Funks[110] = { short = "RNA", name = "RN Ankündigung", canMute = false, defMute = false, talk = {u=9,r=8}, hear = {u=9} }
AOCRP.Config.Funks[111] = { short = "MP", name = "Medical Platoon", canMute = true, defMute = false, talk = {u=4}, hear = {u=4} }
AOCRP.Config.Funks[112] = { short = "MPA", name = "MP Ankündigung", canMute = false, defMute = false, talk = {u=4,r=8}, hear = {u=4} }
AOCRP.Config.Funks[113] = { short = "CR", name = "Clone Regiment", canMute = true, defMute = false, talk = {u=2}, hear = {u=2} }
AOCRP.Config.Funks[114] = { short = "CRA", name = "CR Ankündigung", canMute = false, defMute = false, talk = {u=2,r=8}, hear = {u=2} }
AOCRP.Config.Funks[115] = { short = "AC", name = "Airborne Company", canMute = true, defMute = false, talk = {u=7}, hear = {u=7} }
AOCRP.Config.Funks[116] = { short = "ACA", name = "AC Ankündigung", canMute = false, defMute = false, talk = {u=7,r=8}, hear = {u=7} }
AOCRP.Config.Funks[117] = { short = "AB", name = "Ausbildung", canMute = true, defMute = true, talk = {u=1}, hear = {u=1} }
AOCRP.Config.Funks[118] = { short = "ARC", name = "Advanced Recon Commando", canMute = true, defMute = true, talk = {g={182,257,258}}, hear = {g={182,257,258}} }
AOCRP.Config.Funks[119] = { short = "GM", name = "Galactic Marines", canMute = true, defMute = false, talk = {g={292,293,294,295}}, hear = {g={292,293,294,295}} }
AOCRP.Config.Funks[120] = { short = "GMA", name = "GM Ankündigung", canMute = false, defMute = false, talk = {g={292,293,294,295},r=8}, hear = {g={292,293,294,295}} }
AOCRP.Config.Funks[121] = { short = "SEB", name = "Sondereinsatzbrigade", canMute = true, defMute = false, talk = {u=16, g={182}}, hear = {u=16, g={182}} }
AOCRP.Config.Funks[122] = { short = "SEA", name = "SEB Ankündigung", canMute = false, defMute = false, talk = {u=16, r=14}, hear = {u=16, g={182}}}

AOCRP.Config.Funks[130] = { short = "212", name = "212th Attack Battalion", canMute = true, defMute = true, talk = {r=1}, hear = {r=1}}
AOCRP.Config.Funks[131] = { short = "501", name = "501st Legion", canMute = true, defMute = true, talk = {r=1}, hear = {r=1}}

AOCRP.Config.Funks[150] = { short = "ANF", name = "RN Anfrage", canMute = true, defMute = true, talk = {all=true}, hear = {all=true} }
AOCRP.Config.Funks[151] = { short = "STK", name = "Straftatenkanal", canMute = true, defMute = true, talk = {all=true}, hear = {all=true} }
AOCRP.Config.Funks[152] = { short = "MN", name = "Medizinischer Notfall", canMute = true, defMute = true, talk = {all=true}, hear = {all=true} }
AOCRP.Config.Funks[153] = { short = "TN", name = "Technischer Notfall", canMute = true, defMute = true, talk = {all=true}, hear = {all=true} }
AOCRP.Config.Funks[154] = { short = "LS", name = "Republikanische Langstrecke", canMute = true, defMute = true, talk = {r=1}, hear = {r=1} }
AOCRP.Config.Funks[155] = { short = "OF", name = "Öffentliche Frequenz", canMute = true, defMute = true, talk = {all=true}, hear = {all=true} }

for i=1,5 do 
  AOCRP.Config.Funks[200+i] = { short = "F"..i, name = "Feind "..i, canMute = true, defMute = true, talk = {u=12}, hear = {u=12} }
end

for i=1,5 do 
  AOCRP.Config.Funks[300+i] = { short = "Z"..i, name = "Zivil "..i, canMute = true, defMute = true, talk = {u=10}, hear = {u=10} }
end

for i=1,5 do 
  AOCRP.Config.Funks[400+i] = { short = "S"..i, name = "Sonstiges "..i, canMute = true, defMute = true, talk = {u=13}, hear = {u=13} }
end

for i=1,20 do 
  AOCRP.Config.Funks[500+i] = { short = "E"..i, name = "Einheit "..i, canMute = true, defMute = true, talk = {r=2}, hear = {r=2} }
end


-- Wie viel XP für ein Skillpunkt?
AOCRP.Config.XPForPoint = 2000


AOCRP.Config.DisconnectNachricht = [[

  Danke für dein Besuch!
  Deine Daten wurden gespeichert.
  Bis zum nächsten mal!
  
]]




AOCRP.Config.Fonts = {}
AOCRP.Config.Fonts["l"] = "Bebas Neue Pro Exp Rg"
AOCRP.Config.Fonts["m"] = "Bebas Neue Pro SmE Rg"
AOCRP.Config.Fonts["s"] = "Bebas Neue Pro Exp Md"

AOCRP.Config.Fonts["droid"] = "Droid"
AOCRP.Config.Fonts["nalhutt"] = "Nal-Huttese"
AOCRP.Config.Fonts["hutt"] = "SW Huttese"
AOCRP.Config.Fonts["aurehand"] = "Aurek-Besh Hand"
AOCRP.Config.Fonts["aurebesh"] = "Aurebesh"
AOCRP.Config.Fonts["icon"] = "Galaxy Far Far Away"
AOCRP.Config.Fonts["jedi"] = "Jedi Symbol"
AOCRP.Config.Fonts["ewok"] = "Ewok"
AOCRP.Config.Fonts["yavin"] = "SWyavin4"



AOCRP.Config.LVSATCAllowed = {"lvs_space_laat_arc","lvs_space_laat","lvs_starfighter_soulless", "lvs_gunship_hmp", "lvs_starfighter_hyenabomber", "lvs_starfighter_geo", "lvs_starfighter_vulture","lvs_arc", "lvs_starfighter_repz95", "lvs_starfighter_eta2", "lvs_repulsorlift_gunship_space", "lvs_laatle_patrolgunship_rep", "lvs_starfighter_nbt630", "lvs_nuclass_attack_shuttle", "lvs_starfighter_consulradiance", "lvs_starfighter_consulcharger", "lvs_starfighter_peltaclass", "lvs_starfighter_wwing", "lvs_v19", "lvs_starfighter_ywing","lvs_neutralstarfighter_swtor", "lvs_repdestroyer_swtor", "lvs_repfighter_swtor", "lvs_repshuttle_swtor"}
--gamemodes/starwarsrp/gamemode/modules/ribbons/cl_ribbons.lua:
AOCRP.Ribbons = AOCRP.Ribbons or {}

--[[ 
AOCDerma:RegisterFont("AOCRP.Ribbon.Title", "Agency FB", 45, 1000)

AOCDerma:RegisterFont("AOCRP.Ribbon.Description", "Agency FB", 20, 10)


function AOCRP.Ribbons:RibbonMenu(data)

    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
    
    self.FRAME = AOCDerma:DefaultFrame("Meine Ribbons")
    self.FRAME:SetSize(AOCW(800),AOCH(800))
    self.FRAME:Center()

    if data then self.FRAME.DATA = data end

    local seEntry = AOCDerma:TextEntry(self.FRAME," Ribbon suchen...")
    seEntry:SetTall(AOCH(50))
    seEntry:Dock(TOP)
    seEntry:SetUpdateOnType(true)
    function seEntry:OnValueChange(val)

        AOCRP.Ribbons:DisplayRibbons(val)
    end   

    self.FRAME.ButtonList = AOCDerma:ScrollBar(self.FRAME) 
    self.FRAME.ButtonList:Dock(FILL)


    AOCRP.Ribbons:DisplayRibbons("")

    local saveBtn = AOCDerma:Button(self.FRAME, "Speichern", function() 
        net.Start("AOCRP.Ribbons.Save")
        net.SendToServer()

        if ValidPanel(self.FRAME) then self.FRAME:Remove() end
    
    end, "b")
    saveBtn:Dock(BOTTOM)
    saveBtn.akzent = Color(0,200,0,255)
    saveBtn.akzenthover = Color(0,255,0,255)
end

 ]]


--[[ function AOCRP.Ribbons:RequestPlayerRibbons()
    net.Start("AOCRP.Ribbons.RequestData")
    net.SendToServer()
end ]]
--[[ 
net.Receive( "AOCRP.Ribbons.SendData", function( len, ply )
    
    local data = net.ReadTable()
    AOCRP.Ribbons:RibbonMenu(data)
end )


local function SendActiveRequest(ribbon, slot)
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(ribbon, 14)
    net.WriteString(slot)
    net.SendToServer()
end
local function ClearSlots()
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(0, 14)
    net.WriteString("1")
    net.SendToServer()
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(0, 14)
    net.WriteString("2")
    net.SendToServer()
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(0, 14)
    net.WriteString("3")
    net.SendToServer()
end

function AOCRP.Ribbons:AddRibbonToPnl(ribbonid) 
    if ValidPanel(self.FRAME) then
        if AOCRP.Ribbons:Exists(ribbonid) then
            local ribbonData = AOCRP.Ribbons:GetRibbon(ribbonid)
            local ribbonPnl = vgui.Create("DButton", self.FRAME.ButtonList)
            ribbonPnl:Dock(TOP)
            ribbonPnl:SetTall(AOCH(80))
            ribbonPnl.ribbonData = ribbonData
            ribbonPnl:SetText("")
            ribbonPnl:DockMargin(0,AOCH(5),0,0)

            function ribbonPnl:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
                PIXEL.DrawImgur(AOCW(5), AOCH(5), AOCW(200), AOCH(70), self.ribbonData.url, Color(255,255,255))
                AOCDerma:DrawTextShadow(self.ribbonData.name, AOCDerma:Font("AOCRP.Ribbon.Title"), AOCW(220), AOCH(5), Color(255,255,255), TEXT_ALIGN_LEFT)
                AOCDerma:DrawTextShadow(self.ribbonData.description,  AOCDerma:Font("AOCRP.Ribbon.Description"), AOCW(220), AOCH(50), Color(255,255,255), TEXT_ALIGN_LEFT)


                if AOCRP.Ribbons:RibbonActive(LocalPlayer(), ribbonid) then
                    surface.SetDrawColor(0,255,0)
                    surface.DrawOutlinedRect(0, 0, w, h,1)
                end
            end

            function ribbonPnl:DoClick()
                local menu = DermaMenu() 
                menu:AddOption( "Ribbon-Slot 1", function() SendActiveRequest(ribbonid, "1") end )
                menu:AddOption( "Ribbon-Slot 2", function() SendActiveRequest(ribbonid, "2") end )
                menu:AddOption( "Ribbon-Slot 3", function() SendActiveRequest(ribbonid, "3") end )
                menu:AddOption( "Alle Slots leeren", function() ClearSlots() end )
                menu:Open()
            end
        end
    end
end


function AOCRP.Ribbons:DisplayRibbons(searchtext)
    self.FRAME.ButtonList:Clear()
    if istable(self.FRAME.DATA) then
        if #self.FRAME.DATA > 0 then
            for k, v in pairs(self.FRAME.DATA) do
                if AOCRP.Ribbons.Data[v] then
                    if string.find( AOCRP.Ribbons.Data[v].name, searchtext ) then
                        AOCRP.Ribbons:AddRibbonToPnl(v) 
                    end
                end
            end
        end
    end
end

concommand.Add( "aocrp_ribbons", function( ply, cmd, args )
    AOCRP.Ribbons:RequestPlayerRibbons()
end ) ]]



AOCDerma:RegisterFont("AOCRP.Ribbon.DisplayTitle", "Agency FB", 80, 1000)

AOCDerma:RegisterFont("AOCRP.Ribbon.DisplayDescription", "Agency FB", 35, 10)


function AOCRP.Ribbons:DisplayRibbon(ribbonid)

    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
    
    local ribbonData =  AOCRP.Ribbons:GetRibbon(ribbonid)
    self.FRAME = AOCDerma:DefaultFrame("Ribbon")
    self.FRAME:SetSize(AOCW(1050),AOCH(700))
    self.FRAME:Center()

    local ribbon = vgui.Create("DPanel", self.FRAME)
    ribbon:Dock(TOP)
    ribbon:SetTall(AOCH(500))

    function ribbon:Paint(w,h)
        --draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
        PIXEL.DrawImgur(0,0, AOCW(1000), AOCH(350), ribbonData.url, Color(255,255,255))

        AOCDerma:DrawTextShadow(ribbonData.name,  AOCDerma:Font("AOCRP.Ribbon.DisplayTitle"), w/2, AOCH(370), Color(255,255,255), TEXT_ALIGN_CENTER)

        AOCDerma:DrawTextShadow(ribbonData.description,  AOCDerma:Font("AOCRP.Ribbon.DisplayDescription"), w/2, AOCH(450), Color(255,255,255), TEXT_ALIGN_CENTER)

    end
end



--[[ 


function AOCRP.Ribbons:AddRibbonToPnlList(ribbonid) 
    if ValidPanel(self.FRAME) then
        if AOCRP.Ribbons:Exists(ribbonid) then
            local ribbonData = AOCRP.Ribbons:GetRibbon(ribbonid)
            local ribbonPnl = vgui.Create("DButton", self.FRAME.ButtonList)
            ribbonPnl:Dock(TOP)
            ribbonPnl:SetTall(AOCH(80))
            ribbonPnl.ribbonData = ribbonData
            ribbonPnl:SetText("")
            ribbonPnl:DockMargin(0,AOCH(5),0,0)

            function ribbonPnl:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
                PIXEL.DrawImgur(AOCW(5), AOCH(5), AOCW(200), AOCH(70), self.ribbonData.url, Color(255,255,255))
                AOCDerma:DrawTextShadow(self.ribbonData.name, AOCDerma:Font("AOCRP.Ribbon.Title"), AOCW(220), AOCH(5), Color(255,255,255), TEXT_ALIGN_LEFT)
                AOCDerma:DrawTextShadow(self.ribbonData.description,  AOCDerma:Font("AOCRP.Ribbon.Description"), AOCW(220), AOCH(50), Color(255,255,255), TEXT_ALIGN_LEFT)
            end


        end
    end
end
 ]]
--[[ 
function AOCRP.Ribbons:DisplayRibbonsList(searchtext)
    self.FRAME.ButtonList:Clear()
    if istable(AOCRP.Ribbons.Data) then

            for k, v in pairs(AOCRP.Ribbons.Data) do
                if string.find( v.name, searchtext ) then
                    AOCRP.Ribbons:AddRibbonToPnlList(v.ribbonid) 
                end
            end

    end
end


function AOCRP.Ribbons:RibbonList()

    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
    
    self.FRAME = AOCDerma:DefaultFrame("Alle Ribbons")
    self.FRAME:SetSize(AOCW(800),AOCH(800))
    self.FRAME:Center()



    local seEntry = AOCDerma:TextEntry(self.FRAME," Ribbon suchen...")
    seEntry:SetTall(AOCH(50))
    seEntry:Dock(TOP)
    seEntry:SetUpdateOnType(true)
    function seEntry:OnValueChange(val)

        AOCRP.Ribbons:DisplayRibbonsList(val)
    end   

    self.FRAME.ButtonList = AOCDerma:ScrollBar(self.FRAME) 
    self.FRAME.ButtonList:Dock(FILL)


    AOCRP.Ribbons:DisplayRibbonsList("")


end
concommand.Add( "aocrp_allribbons", function( ply, cmd, args )
    AOCRP.Ribbons:RibbonList()
end ) ]]
--gamemodes/starwarsrp/gamemode/modules/gamemec/sh_voicedistance.lua:
AOCRP.VoiceDistance = AOCRP.VoiceDistance or {}

--[[ 


AOCRP.Config.Distances = {}
AOCRP.Config.Distances[1] = 750 -- Schreien
AOCRP.Config.Distances[2] = 500 -- Reden
AOCRP.Config.Distances[3] =  100 -- Flüstern


ply.AOCRP_VoiceDistance -- Serverside Var 


 ]]


local meta = FindMetaTable("Player")


if SERVER then

    util.AddNetworkString("AOCRP.VoiceDistance.Change")
    
    util.AddNetworkString("AOCRP.VoiceDistance.ChangeAnswer")

    net.Receive( "AOCRP.VoiceDistance.Change", function( len, ply )
        if ply.AOCRP_VoiceDistance >= #AOCRP.Config.Distances then 
            ply.AOCRP_VoiceDistance = 1
        else
            ply.AOCRP_VoiceDistance = ply.AOCRP_VoiceDistance + 1 
        end  

        net.Start("AOCRP.VoiceDistance.ChangeAnswer")
        net.WriteInt(ply.AOCRP_VoiceDistance, 4)
        net.Send(ply)
    end)
end

if CLIENT then
    AOCRP_VoiceDistance = AOCRP_VoiceDistance or AOCRP.Config.DefaultDistance
    AOCRP_VoiceDistanceChangeMsg = ""

    net.Receive( "AOCRP.VoiceDistance.ChangeAnswer", function( len, ply )
        local distance = net.ReadInt(4)
        AOCRP_VoiceDistance = distance

        AOCRP_VoiceDistanceChangeMsg = AOCRP.Config.Distances[distance].msg 

        surface.PlaySound(AOCRP.Config.ChangeSound)

        if timer.Exists("AOCRP_VoiceDistanceChangeMsgDelay") then timer.Remove("AOCRP_VoiceDistanceChangeMsgDelay") end
        timer.Create( "AOCRP_VoiceDistanceChangeMsgDelay", 3, 1, function()  AOCRP_VoiceDistanceChangeMsg = "" end ) 

    end)

    local cooldown = CurTime()
    local counter = 0

    function AOCRP.VoiceDistance:Change()
            if CurTime()-cooldown > 1.5 then
                net.Start("AOCRP.VoiceDistance.Change")
                net.SendToServer()
                counter = counter + 1
                if counter > #AOCRP.Config.Distances then
                    cooldown = CurTime()
                    counter = 0
                end
             else
                 LocalPlayer():ChatPrint("*** Bitte warte einen Moment, bevor du deine Sprachreichweite erneut änderst")
            end
    end
end




--gamemodes/starwarsrp/gamemode/modules/ctf/cl_ctf.lua:
local w,h=ScrW(),ScrH()

function ctf_flags_setupmenu(flag)


	local bg = AOCDerma:DefaultFrame("Flaggen-Team erstellen")
	bg:SetSize( AOCW(600), AOCH(600) )
	bg:Center()
	local scroll_for_small_screen_retards=AOCDerma:ScrollBar(bg) 
	scroll_for_small_screen_retards:Dock(FILL)


	local name_lbl=vgui.Create("DLabel", scroll_for_small_screen_retards)
	name_lbl:SetTextColor(Color(255,255,255))
	name_lbl:SetFont("ChatFont")
	name_lbl:SetText("Teamnamen wählen")
	name_lbl:Dock(TOP)
	name_lbl:SetContentAlignment(5)

	local enter_name=vgui.Create("DTextEntry", scroll_for_small_screen_retards)
	enter_name:Dock(TOP)
	enter_name:SetPlaceholderText("Teamname")
	enter_name:DockMargin(0,0,0,h*.01)

	local team_col_lbl=vgui.Create("DLabel", scroll_for_small_screen_retards)
	team_col_lbl:SetTextColor(Color(255,255,255))
	team_col_lbl:SetFont("ChatFont")
	team_col_lbl:SetText("Teamfarbe wählen")
	team_col_lbl:Dock(TOP)
	team_col_lbl:SetContentAlignment(5)

	local enter_col=vgui.Create("DColorMixer", scroll_for_small_screen_retards)
	enter_col:Dock(TOP)
	enter_col:SetPalette(false)
	enter_col:SetAlphaBar(false)
	enter_col:DockMargin(0,0,0,h*.01)


	local btn = AOCDerma:Button(scroll_for_small_screen_retards, "Team erstellen", function() 
	
		if IsValid(flag) then
			net.Start("ctf_flags_setupteam")
				net.WriteEntity(flag)
				net.WriteString(enter_name:GetValue())
				net.WriteVector(enter_col:GetVector())
			net.SendToServer()
		end
		bg:Remove()

	end, "b")

	btn:Dock(TOP)


end

net.Receive("ctf_flags_setupteam", function()
	local flag=net.ReadEntity()
	ctf_flags_setupmenu(flag)
end)

net.Receive("ctf_flags_jointeam", function()
	local ply=net.ReadEntity()
	local flag=net.ReadEntity()

	ply.ctf_team=flag
end)

net.Receive("ctf_flags_leaveteam", function()
	local ply=net.ReadEntity()

	ply.ctf_team=nil
end)

net.Receive("ctf_flags_capturedflag", function()
	local capturer=net.ReadEntity()
	local captured_flag=net.ReadEntity()
	--local flagparts=net.ReadTable()

	capturer.ctf_captured=captured_flag

end)

net.Receive("ctf_flags_droppedflag", function()
	local capturer=net.ReadEntity()

	capturer.ctf_captured=nil
end)

net.Receive("ctf_flags_chatmsg", function()
	local msg=net.ReadTable()

	chat.AddText(unpack(msg))
	chat.PlaySound()
end)

local ctf_global_msgs={}

net.Receive("ctf_flags_globalmsg", function()
	local col=net.ReadColor()
	local msg=net.ReadString()


	local ind=math.random(1,9999)
	ctf_global_msgs[ind]={col=col,msg=msg}
	surface.PlaySound("Friends/message.wav")

	timer.Simple(5, function()
		if ctf_global_msgs[ind]~=nil then
			ctf_global_msgs[ind]=nil
		end
	end)
end)

local w2=w/2
hook.Add("HUDPaint", "global_msgs_ctf", function()

	local ctf_global_msg_spacer=100
	surface.SetFont("CloseCaption_Bold")
	for k,v in pairs(ctf_global_msgs) do
		local tw=surface.GetTextSize(v.msg)
		draw.SimpleText(v.msg, "CloseCaption_Bold", w2-tw/2, h*.04+ctf_global_msg_spacer, v.col)
		ctf_global_msg_spacer=ctf_global_msg_spacer+h*.025
	end

end)
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/io_logic/sh_logic_tables.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local addon = {}


/*
Thank you Jazztronauts for this table of entclass to io inputs
https://github.com/Foohy/jazztronauts/blob/master/gamemodes/jazztronauts/gamemode/lib/sh_hacking.lua#L163-L394
*/

local io_functions = {
	logic_auto = {
		inputs = {},
		outputs = {
			"OnMapSpawn"
		},
	},
	logic_relay = {
		inputs = {
			"Enable",
			"Disable",
			"Trigger",
			"Toggle",
			"CancelPending",
			"EnableRefire",
			"Kill",
			"Use",
		},
		outputs = {
			"OnSpawn",
			"OnTrigger",
		},
	},
	logic_branch = {
		inputs = {
			"SetValue",
			"SetValueTest",
			"Toggle",
			"ToggleTest",
			"Test",
		},
		outputs = {
			"OnTrue",
			"OnFalse",
		},
	},
	logic_timer = {
		inputs = {
			"RefireTime",
			"ResetTimer",
			"FireTimer",
			"Enable",
			"Disable",
			"Toggle",
			"LowerRandomBound",
			"UpperRandomBound",
			"AddToTimer",
			"SubtractFromTimer",
		},
		outputs = {
			"OnTimer",
			"OnTimerHigh",
			"OnTimerLow",
		},
	},
	func_button = {
		inputs = {
			"Kill",
			"Use",
			"Lock",
			"Unlock",
			"Press",
			"PressIn",
			"PressOut",
		},
		outputs = {
			"OnDamaged",
			"OnPressed",
			"OnUseLocked",
			"OnIn",
			"OnOut",
		},
	},
	func_rot_button = {
		inputs = {
			"Kill",
			"Use",
			"Lock",
			"Unlock",
			"Press",
			"PressIn",
			"PressOut",
		},
		outputs = {
			"OnDamaged",
			"OnPressed",
			"OnUseLocked",
			"OnIn",
			"OnOut",
		},
	},
	func_door = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	func_door_rotating = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	prop_door_rotating = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	func_rotating = {
		inputs = {
			"SetSpeed",
			"Start",
			"Stop",
			"StopAtStartPos",
			"StartForward",
			"StartBackward",
			"Toggle",
			"Reverse",
		},
		outputs = {
		},
	},
	prop_dynamic = {
		inputs = {
			"SetAnimation",
			"SetDefaultAnimation",
			"SetPlaybackRate",
			"SetBodyGroup",
			"TurnOn",
			"TurnOff",
			"EnableCollision",
			"DisableCollision",
			"BecomeRagdoll",
		},
		outputs = {
			"OnAnimationBegun",
			"OnAnimationDone",
		},
	},
	env_sprite = {
		inputs = {
			"SetScale",
			"HideSprite",
			"ShowSprite",
			"ToggleSprite",
			"ColorRedValue",
			"ColorGreenValue",
			"ColorBlueValue",
			"Alpha",
			"Color",
		},
		outputs = {

		},
	},
	env_spark = {
		inputs = {
			"StartSpark",
			"StopSpark",
			"ToggleSpark",
			"SparkOnce"
		},
		outputs = {

		},
	},
	trigger_once = {
		inputs = {
			"Toggle",
			"Enable",
			"Disable",
		},
		outputs = {
			"OnStartTouch",
			"OnTrigger",
		},
	},
	trigger_multiple = {
		inputs = {
			"TouchTest",
			"Toggle",
			"Enable",
			"Disable",
		},
		outputs = {
			"OnStartTouchAll",
			"OnEndTouch",
			"OnEndTouchAll",
			"OnStartTouch",
			"OnTrigger",
		},
	},
	ambient_generic = {
		inputs = {
			"Pitch",
			"PlaySound",
			"StopSound",
			"ToggleSound",
			"Volume",
			"FadeIn",
			"FadeOut"
		},
		outputs = {

		},
	},
}

function addon:GetIOTable(class, ent)
	local actions = {}

	if io_functions[ class ] then
		table.Add(actions, io_functions[ class ].inputs or {})
	end

	// Add any custom actions
	if ent and ent._pesIOLogic then
		table.Add(actions, ent._pesIOLogic)
	end

	return actions
end

wOS.PES.Modules:RegisterAddon( "io_logic", addon )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/bounds.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}
VAR.Name = "Bounds"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Add the position you are AIMING AT as a boundary point", key = "gui/lmb.png", },
    { text = "Add your current EYE position as a boundary point", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position as a boundary point", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position from the boundary points", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)
    if table.Count(value) < 1 then return false end

    for index, vec in ipairs(value) do
        if not isvector( vec ) then
            return false
        end
    end

    return true
end



VAR.DermaElement = function(varTable, value)
    if not istable(value) then value = {} end
    local dermaElement = vgui.Create("DPanel")
    dermaElement.Corners = value.Corners or {}

    local heightSelector = vgui.Create("DNumberWang", dermaElement)
    heightSelector:DockMargin(6,2,6,2)
    heightSelector:SetTall(30)
    heightSelector:Dock(LEFT)
    heightSelector:SetDecimals(0)
    heightSelector:SetMin( minCount or 1 )
    heightSelector:SetMax( maxCount or math.huge )
    heightSelector:SetValue(value.Height or 200)
    dermaElement.HeightSelector = heightSelector

    function dermaElement:PerformLayout(ww, hh)
        heightSelector:SetWide(ww * 0.25)
    end
    function dermaElement:Paint(ww, hh)
        draw.SimpleText("Height", nil, ww * 0.45, hh * 0.5, Color(0,0,0), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

        draw.SimpleText("|", nil, ww * 0.5, hh * 0.5, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        draw.SimpleText("Corners: " .. #(dermaElement.Corners), nil, ww * 0.55, hh * 0.5, Color(0,0,0), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    return dermaElement
end

VAR.GetValue = function(dermaElement)
    -- Return Debug Format Template
    local value = {
        Corners = dermaElement.Corners or {},
        Height = math.floor(dermaElement.HeightSelector:GetValue()),
    }

    -- Prepare values for more effiecient use.
    value.PreparedBorderValues = {}
    for i, borderPoint in pairs(value.Corners) do
        value.PreparedBorderValues[i] = {
            v = borderPoint
        }
    end

    local j = table.Count(value.Corners)
    for i=1, table.Count(value.Corners) do
        local borderI = value.PreparedBorderValues[i].v
        local borderJ = value.PreparedBorderValues[j].v

        if borderJ.y == borderI.y then
            value.PreparedBorderValues[i].c = borderI.x
            value.PreparedBorderValues[i].m = 0
        else
            value.PreparedBorderValues[i].c = borderI.x - (borderI.y * borderJ.x) / (borderJ.y - borderI.y) + (borderI.y * borderI.x) / (borderJ.y - borderI.y)
            value.PreparedBorderValues[i].m = (borderJ.x - borderI.x) / (borderJ.y - borderI.y);
        end

        j = i
    end

    return value
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    table.insert(dermaElement.Corners, pos )
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Corners[#(dermaElement.Corners)] = nil
end

VAR.OnStart = function(node, varData, var)

end

VAR.OnEnd = function(node, varData, var)

end

local function DrawBorders(points, height, color)
	local prev = nil
	local prevtop = nil
	local first = nil
	local firsttop = nil

	for _, vec in pairs(points) do
		if not first then first = vec end

		local top = Vector(vec.x, vec.y, first.z + height)
		vec.z = first.z
		if not firsttop then firsttop = top end

		render.DrawLine(vec, top, color, false)

		if prev then
			render.DrawLine(vec, prev, color, false)
		end

		if prevtop then
			render.DrawLine(top, prevtop, color, false)
		end

		prevtop = top
		prev = vec
	end

	if prev and first then
		render.DrawLine(prev, first, color, false)
	end
	if prevtop and firsttop then
		render.DrawLine(prevtop, firsttop, color, false)
	end
end

VAR.Draw3D = function(wep, ply, element)
    DrawBorders(element.Corners, element.HeightSelector:GetValue(), Color(255, 255, 255))
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/model.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "Model"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to save the model properties from", key = "gui/lmb.png", },
}

VAR.IsValid = function(varData, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isstring(self.Value) then
            draw.SimpleText("Model set to: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(125, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Model needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data

    local ent = ply:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    dermaElement.Value = ent:GetModel()
end

VAR.GetValue = function(panel)
    return panel.Value
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/pathvar.lua:

local VAR = {}

VAR.Name = "Path"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Add the position and angle you are AIMING AT to the path", key = "gui/lmb.png", },
    { text = "Add your current EYE position and angle to the path", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position and angle to the path", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position and angle from the path", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

	if (value == nil) then return false end
	if type(value) != "table" then return false end


	if #value != table.Count(value) then return false end

	if #value  < 1 then return false end

	return true
end

VAR.GetValue = function(element)
    if element.Path then
        return element.Path
    end
end

VAR.PrimaryAttack = function(wep, ply, element)
	element.Path = element.Path or {}

    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end

    local ang = ply:EyeAngles()
    
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end

	table.insert(element.Path, {
		Vector = pos,
		Angle = ang,
	})
    panel:RefreshList()
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    panel.Path = value

    function panel:Paint(ww, hh) end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Vector")
    listView:AddColumn("Angle")    
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Path or #panel.Path < 1 then
            pan:AddLine( "Path needs to be set!" )
            return
        end

        for id, vdata in pairs( panel.Path or {} ) do
            local line = pan:AddLine( vdata.Vector, vdata.Angle )
            line.ID = id
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
        table.remove( panel.Path, line.ID )
        pan:RefreshList()
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel
end

VAR.SecondaryAttack = function(wep, ply, element)
	element.Path = element.Path or {}
	if #element.Path > 0 then
		table.remove(element.Path, #element.Path)
	end
end

VAR.Draw3D = function(wep, ply, element)
	local path = element.Path or {}

	for _, v in pairs(path) do
		local pos = v.Vector
		local ang = v.Angle

		local pos2 = pos + ang:Forward() * 10

		render.DrawLine(pos, pos2, Color(0, 0, 0), true)
		render.DrawWireframeSphere(pos, 5, 10, 10, Color(255, 255, 255, 255))
	end
end

return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_sfs_extern.lua:
if wOS and wOS.SFS_EXTERN then return end

-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

wOS.SFS_EXTERN = {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.1"
}

function wOS.SFS_EXTERN:Compress( data_table )
    if not data_table then return nil, "NO DATA PRESENT" end
    local encoded, err = self.encode( data_table )
    if err then return encoded, err end
    return util.Compress( encoded )
end

function wOS.SFS_EXTERN:RawCompress( data_table )
    if not data_table then return nil, "NO DATA PRESENT" end
    local encoded, err = self.encode( data_table )
    if err then return encoded, err end
    return encoded
end

function wOS.SFS_EXTERN:Decompress( data )
    if not data then return nil, "NO DATA PRESENT" end
    local decomp = util.Decompress( data )
    return self.decode( decomp )
end

function wOS.SFS_EXTERN:RawDecompress( data )
    if not data then return nil, "NO DATA PRESENT" end
    return self.decode( data )
end
--addons/wos-passiveevent-ageo/lua/wos/css/vgui/wos_css_scrollpanel.lua:
--[[-------------------------------------------------------------------
	Shooting Range Scroll Panel
		VGUI Element for use in the menus.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David, Oninoni
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--

local DSRScrollPanel = {}

-- Initializes the DSRScrollPanel.
function DSRScrollPanel:Init()
	self.Panels = {}

	self.XScroll = true
	self.AlignCenter = true

	self.Overflow = 0
end

function DSRScrollPanel:OnSizeChanged(width, height)
	if self.XScroll then
		self.ScrollSize = width
	else
		self.ScrollSize = height
	end
end

function DSRScrollPanel:SetPanelSize(x, y)
	self.XPanelSize = x
	self.YPanelSize = y
end

function DSRScrollPanel:SetPanelSpacing(s)
	self.PanelSpacing = s
end

function DSRScrollPanel:GetScrollPanelSize()
	if self.XScroll then
		return self.XPanelSize
	else
		return self.YPanelSize
	end
end

function DSRScrollPanel:SetPanelScroll(panel, offset)
	offset = offset or 0

	if self.XScroll then
		panel:SetPos(panel.OriginalValue + offset, self.PanelSpacing)
	else
		panel:SetPos(self.PanelSpacing, panel.OriginalValue + offset)
	end
end

function DSRScrollPanel:SetScroll(offset)
	for _, panel in pairs(self.Panels or {}) do
		self:SetPanelScroll(panel, offset)
	end
end

function DSRScrollPanel:Clear()
	for _, panel in pairs(self.Panels or {}) do
		panel:Remove()
	end

	self.Panels = {}
end

function DSRScrollPanel:Think()
	local offset = 0

	if self.AlignCenter then
		offset = self.Overflow / 2
	end

	if self.Overflow < 0 then
		local xMouse, yMouse = gui.MousePos()
		local xLocal, yLocal = self:ScreenToLocal(xMouse, yMouse)

		local xSize, ySize = self:GetSize()

		local scrollLocal = yLocal
		if self.XScroll then
			scrollLocal = xLocal
		end
		
		local panelSize = self:GetScrollPanelSize()

		local targetOffset = math.min(0, math.max(self.Overflow, (scrollLocal - self.PanelSpacing) / (self.ScrollSize - self.PanelSpacing * 2) * self.Overflow))

		offset = Lerp(0.03, self.LastOffset, targetOffset)
		self.LastOffset = offset
	end

	self:SetScroll(offset)
end

function DSRScrollPanel:CreatePanel(class)
	local panel = vgui.Create(class, self)
	panel:SetSize(self.XPanelSize, self.YPanelSize)

	local panelSpacing = self.PanelSpacing
	local panelSize = self:GetScrollPanelSize()
	
	panel.OriginalValue = panelSpacing + (panelSpacing + panelSize) * #self.Panels
	
	self:SetPanelScroll(panel)
	self.LastOffset = 0
	table.insert(self.Panels, panel)

	local totalWidth = panel.OriginalValue + panelSize + panelSpacing

	self.Overflow = self.ScrollSize - totalWidth

	return panel
end

vgui.Register("WOS_CSS_ScrollPanel", DSRScrollPanel, "DPanel")
--addons/arccw_weapons/lua/weapons/aocrp_dc15se.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "REP"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "ZP-1"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Damage = 30
SWEP.RangeMin = 500
SWEP.DamageMin = 20
SWEP.Range = 1344
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 325

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "weapons/bf3/dc15a.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.8, -2, 1),
    Ang = Angle(0, .1, 1.2),
     Magnification = 1.3,
     SwitchToSound = "armasclasicas/wpn_cis_medequip.wav",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.17, -1.06, 0.1),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}


--addons/arccw_base_modified/lua/weapons/arccw_base/sh_firemodes.lua:
function SWEP:ChangeFiremode(pred)
    pred = pred or true
    local fmt = self:GetBuff_Override("Override_Firemodes", self.Firemodes)
    fmt["BaseClass"] = nil

    local check = self:GetBuff_Hook("Hook_ChangeFiremode")
    if check then return end
    local count = table.Count(fmt)
    if count == 1 then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetGrenadePrimed() then return end

    local fmi = self:GetFireMode()
    local lastfmi = fmi

    fmi = fmi + 1

    if fmi > count then
       fmi = 1
    end

    local altsafety = SERVER and (self:GetOwner():GetInfo("arccw_altsafety") == "1") or CLIENT and (ArcCW.ConVars["altsafety"]:GetBool())
    if altsafety and !self:GetOwner():KeyDown(IN_WALK) and fmt[fmi] and fmt[fmi].Mode == 0 then
        -- Skip safety when walk key is not down
        fmi = (fmi + 1 > count) and 1 or (fmi + 1)
    elseif altsafety and self:GetOwner():KeyDown(IN_WALK) then
        if fmt[lastfmi] and fmt[lastfmi].Mode == 0 then
            -- Find the first non-safety firemode
            local nonsafe_fmi = nil
            for i, fm in pairs(fmt) do
                if fm.Mode != 0 then nonsafe_fmi = i break end
            end
            fmi = nonsafe_fmi or fmi
        else
            -- Find the safety firemode
            local safety_fmi = nil
            for i, fm in pairs(fmt) do
                if fm.Mode == 0 then safety_fmi = i break end
            end
            fmi = safety_fmi or fmi
        end
    end

    if !fmt[fmi] then fmi = 1 end

    local a = tostring(lastfmi) .. "_to_" .. tostring(fmi)

    if !self.Animations[a] then a = "changefiremode" end

    if self.Animations[a] then
        self:PlayAnimationEZ(a, 1, true)
        local t = CurTime() + self:GetAnimKeyTime(a, true)
        self:SetPriorityAnim(t)
        self:SetNextPrimaryFire(t)
    end

    local old_inf = self:HasInfiniteAmmo()

    self:SetFireMode(fmi)
    --timer.Simple(0, function() self:RecalcAllBuffs() end)
    -- Absolutely, totally, completely ENSURE client has changed the value before attempting recalculation
    -- Waiting one tick will not work on dedicated servers
    local id = "ArcCW_RecalcWait_" .. self:EntIndex()
    timer.Create(id, 0.01, 0, function()
        if !IsValid(self) then timer.Remove(id) return end
        if self:GetFireMode() == fmi then
            self:RecalcAllBuffs()
            self:GetActiveElements(true)

            -- Timers solve everything!
            timer.Simple(0.01, function()
                if !IsValid(self) then return end
                self:AdjustAmmo(old_inf)
                if self:GetCurrentFiremode().RestoreAmmo then
                    -- No seriously, they really do
                    timer.Simple(0.01, function()
                        if !IsValid(self) then return end
                        self:RestoreAmmo()
                    end)
                end
            end)
            timer.Remove(id)
        end
    end)

    if lastfmi != fmi then
        local snd = self:GetBuff_Override("Override_FiremodeSound", self.FiremodeSound)
        if SERVER then
            if pred then
                SuppressHostEvents(self:GetOwner())
            end
            self:MyEmitSound(snd, 75, 100, 1, CHAN_ITEM + 2)
            if pred then
                SuppressHostEvents(NULL)
            end
        else
           self:MyEmitSound(snd, 75, 100, 1, CHAN_ITEM + 2)
        end
    end

    self:SetShouldHoldType()

    if self:GetCurrentFiremode().Mode == 0 or self:GetBuff_Hook("Hook_ShouldNotSight") then
        self:ExitSights()
    end
end

function SWEP:GetCurrentFiremode()
    local fmt = self:GetBuff_Override("Override_Firemodes", self.Firemodes)
    fmt.BaseClass = nil

    if self:GetFireMode() > table.Count(fmt) or self:GetFireMode() < 1 then
        self:SetFireMode(1)
    end

    fmt[self:GetFireMode()].BaseClass = nil
    return fmt[self:GetFireMode()]
end

function SWEP:GetFiremodeName()
    if self:GetBuff_Hook("Hook_FiremodeName") then return self:GetBuff_Hook("Hook_FiremodeName") end

    local abbrev = ArcCW.ConVars["hud_fcgabbrev"]:GetBool() and ".abbrev" or ""

    if self:GetInUBGL() then
        return self:GetBuff_Override("UBGL_PrintName") and self:GetBuff_Override("UBGL_PrintName") or ArcCW.GetTranslation("fcg.ubgl" .. abbrev)
    end

    local fm = self:GetCurrentFiremode()

    if fm.PrintName then
        local phrase = ArcCW.GetPhraseFromString(fm.PrintName)
        return phrase and ArcCW.GetTranslation(phrase .. abbrev) or ArcCW.TryTranslation(fm.PrintName)
    end

    local mode = fm.Mode
    if mode == 0 then return ArcCW.GetTranslation("fcg.safe" .. abbrev) end
    if mode == 1 then return ArcCW.GetTranslation("fcg.semi" .. abbrev) end
    if mode >= 2 then return ArcCW.GetTranslation("fcg.auto" .. abbrev) end
    if mode < 0 then return string.format(ArcCW.GetTranslation("fcg.burst" .. abbrev), tostring(-mode)) end
end

function SWEP:GetFiremodeBars()
    if self:GetBuff_Hook("Hook_FiremodeBars") then return self:GetBuff_Hook("Hook_FiremodeBars") end

    if self:GetInUBGL() then
        return "____-"
    end

    local fm = self:GetCurrentFiremode()

    if fm.CustomBars then return fm.CustomBars end

    local mode = fm.Mode

    if mode == 0 then return "_____" end
    if mode == 1 then return "-____" end
    if mode >= 2 then return "-----" end
    if mode == -2 then return "--___" end
    if mode == -3 then return "---__" end
    if mode == -4 then return "----_" end

    return "-----"
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_heat.lua:
SWEP.NextHeatDissipateTime = 0
SWEP.Heat = 0

function SWEP:GetMaxHeat()
    return self:GetBuff("HeatCapacity")
end

function SWEP:AddHeat(a)
    local single = game.SinglePlayer()
    a = tonumber(a)

    if !(self.Jamming or self:GetBuff_Override("Override_Jamming")) then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("AddHeat", a) end
    -- if !single and !IsFirstTimePredicted() then return end

    local max = self:GetBuff("HeatCapacity")
    local mult = 1 * self:GetBuff_Mult("Mult_FixTime")
    local heat = self:GetHeat()
    local anim = self:SelectAnimation("fix")
    anim = self:GetBuff_Hook("Hook_SelectFixAnim", anim) or anim
    local amount = a or 1
    local t = CurTime() + self:GetAnimKeyTime(anim) * mult
    self.Heat = math.max(0, heat + amount * ArcCW.ConVars["mult_heat"]:GetFloat())

    self.NextHeatDissipateTime = CurTime() + (self:GetBuff("HeatDelayTime"))
    local overheat = self.Heat >= max
    if overheat then
        local h = self:GetBuff_Hook("Hook_Overheat", self.Heat)
        if h == true then overheat = false end
    end
    if overheat then
        self.Heat = math.min(self.Heat, max)
        if self:GetBuff_Override("Override_HeatFix", self.HeatFix) then
            self.NextHeatDissipateTime = t
        elseif self:GetBuff_Override("Override_HeatLockout", self.HeatLockout) then
            self.NextHeatDissipateTime = t
        end
    elseif !self:GetBuff_Override("Override_HeatOverflow", self.HeatOverflow) then
        self.Heat = math.min(self.Heat, max)
    end

    if single and CLIENT then return end

    self:SetHeat(self.Heat)

    if overheat then

        local ret = self:GetBuff_Hook("Hook_OnOverheat")
        if ret then return end

        if anim then
            self:PlayAnimation(anim, mult, true, 0, true)
            self:SetPriorityAnim(t)
            self:SetNextPrimaryFire(t)

            if self:GetBuff_Override("Override_HeatFix", self.HeatFix) then
                self:SetTimer(t - CurTime(),
                function()
                    self:SetHeat(0)
                end)
            end
        end

        if self.HeatLockout or self:GetBuff_Override("Override_HeatLockout") then
            self:SetHeatLocked(true)
        end

        self:GetBuff_Hook("Hook_PostOverheat")
    end
end

function SWEP:DoHeat()
    if self.NextHeatDissipateTime > CurTime() then return end

    --local diss = self.HeatDissipation or 2
    --diss = diss * self:GetBuff_Mult("Mult_HeatDissipation")
    local diss = self:GetBuff("HeatDissipation") or 2
    local ft = FrameTime()
    self.Heat = self:GetHeat() - (ft * diss)

    self.Heat = math.max(self.Heat, 0)

    self:SetHeat(self.Heat)

    if self.Heat <= 0 and self:GetHeatLocked() then
        self:SetHeatLocked(false)
    end
end

function SWEP:HeatEnabled()
    return self.Jamming or self:GetBuff_Override("Override_Jamming")
end

function SWEP:MalfunctionEnabled()
    local cvar = ArcCW.ConVars["malfunction"]:GetInt()
    return cvar == 2 or (cvar == 1 and self:GetBuff_Override("Override_Malfunction", self.Malfunction))
end

function SWEP:GetMalfunctionAnimation()
    local anim = self:SelectAnimation("unjam")
    if !self.Animations[anim] then
        anim = self:SelectAnimation("fix")
        anim = self:GetBuff_Hook("Hook_SelectFixAnim", anim) or anim
    end
    if !self.Animations[anim] then anim = self:SelectAnimation("cycle") end
    if !self.Animations[anim] then anim = nil end
    return anim
end

function SWEP:DoMalfunction(post)

    if !IsFirstTimePredicted() then return end
    if !self:MalfunctionEnabled() then return false end
    local shouldpost = self:GetBuff_Override("Override_MalfunctionPostFire", self.MalfunctionPostFire)
    if post != shouldpost then return false end

    -- Auto calculated malfunction mean
    if self.MalfunctionMean == nil then
        local mm
        if self.Jamming then mm = self.HeatCapacity * 4
        else mm = self.Primary.ClipSize * 8 end

        if self.ManualAction then
            -- Manual guns are less likely to jam
            mm = mm * 2
        else
            -- Burst and semi only guns are less likely to jam
            local a, b = false, false
            for k, v in pairs(self.Firemodes) do
                if !v.Mode then continue end
                if v.Mode == 2 then a = true
                elseif v.Mode < 0 then b = true end
            end
            if !a and b then
                mm = mm * 1.25
            elseif !a and !b then
                mm = mm * 1.5
            end
        end
        self.MalfunctionMean = mm
    end

    local cvar = math.max(ArcCW.ConVars["mult_malfunction"]:GetFloat(), 0.00000001)
    local mean = self:GetBuff("MalfunctionMean") / cvar
    local var = mean * math.Clamp(self:GetBuff("MalfunctionVariance") * math.max(1, math.sqrt(cvar)), 0, 1)
    local count = (self.ShotsSinceMalfunction or 0)

    if !self.NextMalfunction then
        math.randomseed(math.Round(util.SharedRandom(count, -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)))
        self.NextMalfunction = math.ceil(math.sqrt(-2 * var * math.log(math.random())) * math.cos(2 * math.pi * math.random()))
    end

    local ret = self:GetBuff_Hook("Hook_Malfunction", count, true)
    if ret != nil then return ret end

    -- if self:Clip1() <= 1 then return false end -- Don't fucking

    --print(mean, var, count, self.NextMalfunction)
    if count >= self.NextMalfunction + mean then
        local ret2 = self:GetBuff_Hook("Hook_OnMalfunction", count, true)
        if ret2 then return false end

        self:MyEmitSound(self:GetBuff_Override("Override_MalfunctionSound") or self.MalfunctionSound, 75, 100, 1, CHAN_ITEM)

        local wait = self:GetBuff("MalfunctionWait")
        self:SetNextPrimaryFire(CurTime() + wait)

        local anim = self:GetMalfunctionAnimation()
        if !anim or self:GetBuff_Override("Override_MalfunctionJam", self.MalfunctionJam) then
            self:SetMalfunctionJam(true)
        else
            self:SetTimer(wait,
            function()
                self:MalfunctionClear()
            end)
        end

        self:GetBuff_Hook("Hook_PostMalfunction")
        self.ShotsSinceMalfunction = 0
        self.NextMalfunction = nil

        self:SetBurstCount(0)

        return true
    else
        self.ShotsSinceMalfunction = (self.ShotsSinceMalfunction or 0) + 1
        return false
    end
end

function SWEP:MalfunctionClear()

    if self:GetBuff_Override("Override_MalfunctionTakeRound", self.MalfunctionTakeRound) then
        self:TakePrimaryAmmo(self:GetBuff("AmmoPerShot"))
    end

    local anim = self:GetMalfunctionAnimation()
    if anim then
        self:PlayAnimation(anim, self:GetBuff_Mult("Mult_MalfunctionFixTime"), true, 0, true)
        local wait = self:GetAnimKeyTime(anim) - 0.01
        self:SetTimer(wait,
        function()
            self:SetMalfunctionJam(false)
            self:PlayIdleAnimation(true)
        end)
        return true
    else
        self:SetMalfunctionJam(false)
        return false
    end
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_ubgl.lua:

function SWEP:SelectUBGL()
    if !self:GetBuff_Override("UBGL") then return end
    if self:GetReloading() then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetUBGLDebounce() then return end
    self:SetUBGLDebounce( true )

    self:SetInUBGL(true)

    self:SetFireMode(1)

    if CLIENT and (game.SinglePlayer() or (!game.SinglePlayer() and IsFirstTimePredicted())) then
        -- if !ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        --     self:GetOwner():ChatPrint("Selected " .. self:GetBuff_Override("UBGL_PrintName") or "UBGL")
        -- end
        if !self:GetLHIKAnim() then
            self:DoLHIKAnimation("enter")
        end
        self:MyEmitSound( self:GetBuff_Override("SelectUBGLSound") or self.SelectUBGLSound )
    end

    if self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.enter_ubgl_empty and self:Clip2() == 0 then
        self:PlayAnimation("enter_ubgl_empty", 1, true)
        self:SetNextSecondaryFire(CurTime() + self:GetAnimKeyTime("enter_ubgl_empty"))
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.enter_ubgl then
        self:PlayAnimation("enter_ubgl", 1, true)
        self:SetNextSecondaryFire(CurTime() + self:GetAnimKeyTime("enter_ubgl"))
    else
        self:PlayAnimationEZ("idle", 1, false)
        self:SetNextSecondaryFire(CurTime() + 0.1)
    end

    self:GetBuff_Hook("Hook_OnSelectUBGL")
end

function SWEP:DeselectUBGL()
    if !self:GetInUBGL() then return end
    if self:GetReloading() then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetUBGLDebounce() then return end
    self:SetUBGLDebounce( true )

    self:SetInUBGL(false)

    if CLIENT and (game.SinglePlayer() or (!game.SinglePlayer() and IsFirstTimePredicted())) then
        -- if !ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        --     self:GetOwner():ChatPrint("Deselected " .. self:GetBuff_Override("UBGL_PrintName") or "UBGL")
        -- end
        if !self:GetLHIKAnim() and bong then
            self:DoLHIKAnimation("exit")
        end
        self:MyEmitSound( self:GetBuff_Override("ExitUBGLSound") or self.ExitUBGLSound )
    end

    if self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.exit_ubgl_empty and self:Clip2() == 0 then
        self:PlayAnimation("exit_ubgl_empty", 1, true)
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.exit_ubgl then
        self:PlayAnimation("exit_ubgl", 1, true)
    else
        self:PlayAnimationEZ("idle", 1, false)
        self:SetNextSecondaryFire(CurTime() + 0.1)
    end

    self:GetBuff_Hook("Hook_OnDeselectUBGL")
end

function SWEP:RecoilUBGL()
    local single = game.SinglePlayer()

    if !single and !IsFirstTimePredicted() then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("RecoilUBGL") end

    local amt = self:GetBuff_Override("UBGL_Recoil")
    local amtside = self:GetBuff_Override("UBGL_RecoilSide") or (self:GetBuff_Override("UBGL_Recoil") * 0.5)
    local amtrise = self:GetBuff_Override("UBGL_RecoilRise") or 1

    local r = math.Rand(-1, 1)
    local ru = math.Rand(0.75, 1.25)

    local m = 1 * amt
    local rs = 1 * amtside
    local vsm = 1

    local vpa = Angle(0, 0, 0)

    vpa = vpa + (Angle(1, 0, 0) * amt * m * vsm)

    vpa = vpa + (Angle(0, 1, 0) * r * amtside * m * vsm)

    if CLIENT then
        self:OurViewPunch(vpa)
    end

    if CLIENT or game.SinglePlayer() then

        self.RecoilAmount = self.RecoilAmount + (amt * m)
        self.RecoilAmountSide = self.RecoilAmountSide + (r * amtside * m * rs)

        self.RecoilPunchBack = amt * 2.5 * m

        if self.MaxRecoilBlowback > 0 then
            self.RecoilPunchBack = math.Clamp(self.RecoilPunchBack, 0, self.MaxRecoilBlowback)
        end

        self.RecoilPunchSide = r * rs * m * 0.1 * vsm
        self.RecoilPunchUp = math.Clamp(ru * amt * m * 0.6 * vsm * amtrise, 0, 0.1)
    end
end

function SWEP:ShootUBGL()
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return false end

    self.Primary.Automatic = self:GetBuff_Override("UBGL_Automatic")

    local ubglammo = self:GetBuff_Override("UBGL_Ammo")

    if self:Clip2() <= 0 and self:GetOwner():GetAmmoCount(ubglammo) <= 0 then
        self:DeselectUBGL()
        return
    end

    if self:Clip2() <= 0 then
        return
    end

    self:RecoilUBGL()

    local func, slot = self:GetBuff_Override("UBGL_Fire")

    if func then
        func(self, self.Attachments[slot].VElement)
    end

    self:SetNextSecondaryFire(CurTime() + (60 / self:GetBuff_Override("UBGL_RPM")))
end

function SWEP:ReloadUBGL()
    if self:GetNextSecondaryFire() > CurTime() then return end

    local reloadfunc, slot = self:GetBuff_Override("UBGL_Reload")

    if reloadfunc then
        reloadfunc(self, self.Attachments[slot].VElement)
    end
end

if SERVER then

function SWEP:DoLHIKAnimation(key, time)
    if game.SinglePlayer() then
        net.Start("arccw_sp_lhikanim")
        net.WriteString(key)
        net.WriteFloat(time or -1)
        net.Send(self:GetOwner())
    end
end

end
--addons/arccw_weapons/lua/weapons/arccw_blaster_westarm5.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Westar-M5"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/arccw/ser/starwars/c_westarm5.mdl"
SWEP.WorldModel = "models/arccw/ser/starwars/w_westarm5.mdl"
SWEP.IconOverride = "materials/entities/tfa_sw_westarm5.png"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 24
SWEP.DamageMin = 18 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 100 -- how far bullets will retain their maximum damage for
SWEP.Range = 300 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_blue" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 1.5 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 45 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0
SWEP.MaxRecoilBlowback = 1
SWEP.VisualRecoilMult = 1

SWEP.RecoilDirection = Angle(0.2, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 540 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 150 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "w/westar.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -0, 2.1),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(6, -4, 0)
SWEP.SprintAng = Angle(-16.524, 60, -11.046)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["ironsight"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/props/e11r_scope/e11r_scope.mdl",
                Bone = "weapon",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.05, -2.85, 0.8),
                    ang = Angle(-0.3, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(17, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
        DefaultEles = {"ironsight"},
		Bone = "weapon", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0.02, -2.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1, -7),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "weapon", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, -0.8, 4),
            vang = Angle(90, 0, -0),
            wpos = Vector(9, 2, -6),
            wang = Angle(-10, 5, -90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "weapon", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, -1, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        Bone = "weapon", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(0, 2.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, -1.5),
            wang = Angle(0, 0, 180)            
        },
        NoWM = true,
        NoVM = true, -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "weapon", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, 4),
            vang = Angle(0, 0, 0),
        },
    },
    [8] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "weapon", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.2, 1.6, 17.4),
            vang = Angle(90, 0, -90),
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "fire",
    },
	["idle_sights"] = {
        Source = "idle",
        Mult = 10000,
    },
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {
				s = "w/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 75, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "w/overheat_overheated_var_01.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 75, -- volume
				t = 1.3, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_cr2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "CR-2"
SWEP.Trivia_Class = "Naboo Security Blaster Rifle"
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020
SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_cr2.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 25
SWEP.RangeMin = 80
SWEP.DamageMin = 11
SWEP.Range = 330
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_green"
SWEP.TracerCol = Color(0, 255, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.13

SWEP.Delay = 60 / 510
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/cr2.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(0, 250, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-3.13, -11, 1.85),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -4, .5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(0.2, -1, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -13, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"cr2"}

SWEP.AttachmentElements = {
    ["cr2"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/CR2_Base.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1.3, 1.3, 1.3),
                Offset = {
                    pos = Vector(-1.2, -1.5, 0.5),
                    ang = Angle(0, -90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/CR2_Base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(300, 120, -200),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}

WMOverride = "models/arccw/sw_battlefront/weapons/CR2_Base.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0.8, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(500, 110, -710),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 12),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0.2, 2.5, 8),
            vmax = Vector(-0.2, 2.5, 11),
            wmin = Vector(1200, 120, -480), 
            wmax = Vector(1200, 120, -480)  -- how far this attachment can slide in both directions.
        },                 
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1.5, 11),
            vang = Angle(90, 0, 0),
            wpos = Vector(1150, 230, -550),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(111, 111, 111),
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.1, 2.2, 16.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(1820, 120, -750),
            wang = Angle(-15, 0, -90)
        },
    },             
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        WMScale = true,
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, 4),
            vang = Angle(0, 0, 0),
            wpos = Vector(650, 10, -300),
            wang = Angle(-15, 90, -90)
        },
    },   
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 1.5, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(400, 200, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_dl44.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Dual DL-44"
SWEP.Trivia_Class = "Dual Blaster Pistol"
SWEP.Trivia_Desc = "Dual Blaster pistols for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_dl44.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 330
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dl44.wav"

SWEP.MuzzleFlashColor = Color(255, 165, 18, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dl44", "dl44+"}

SWEP.AttachmentElements = {
    ["dl44"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3, 2, -0.7),
                    ang = Angle(85, -2, 90)
                }
            }
        },
    },
    ["dl44+"] = {
         VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-3.5, -2.2, 1.2),
                    ang = Angle(90, -2, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -90, 2)
                }
            },
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -90, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_ib94.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Dual IB-94"
SWEP.Trivia_Class = "Heavy Dual Blaster Pistol"
SWEP.Trivia_Desc = "Heavy Dual Blaster pistols for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_ib94.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 130
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 290
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/ib94.wav"

SWEP.MuzzleFlashColor = Color(250, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"ib94", "ib94+"}

SWEP.AttachmentElements = {
    ["ib94"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/dc92.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(7, 1, -1),
                    ang = Angle(-5, -2, 90)
                }
            }
        },
    },
    ["ib94+"] = {
         VMElements = {
            {
                Model = "models/arccw/cs574/weapons/dc92.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-7.5, -1, 1.2),
                    ang = Angle(-180, -2, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/dc92.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/cs574/weapons/dc92.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/cs574/weapons/dc92.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_masita_base.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = false -- this obviously has to be set to true

// names and stuff
SWEP.PrintName = "Masita ArcCW Weapon Base"
SWEP.Category = "[MASITA] ArcCW Weapon Base"

SWEP.Description = ""

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.ViewModelFOV = 56
SWEP.MirrorVMWM = nil --Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM

--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible
SWEP.HullSize = 1.5 -- HullSize used by FireBullets

function SWEP:DoImpactEffect(tr, dmgtype)
    if tr.HitSky then return true end

    util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal);
    if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then
        local soundToPlay = "impacts/sw752_hit_1.wav"
        local randomSound = math.random(1,14)
        if randomSound == 1 then
            soundToPlay = "impacts/sw752_hit_4.wav"
        elseif randomSound == 2 then
            soundToPlay = "impacts/sw752_hit_5.wav"
        elseif randomSound == 3 then
            soundToPlay = "impacts/sw752_hit_9.wav"
        elseif randomSound == 4 then
            soundToPlay = "impacts/sw752_hit_10.wav"
        elseif randomSound == 5 then
            soundToPlay = "impacts/sw752_hit_12.wav"
        elseif randomSound == 6 then
            soundToPlay = "impacts/sw752_hit_13.wav"
        elseif randomSound == 7 then
            soundToPlay = "impacts/sw752_hit_14.wav"
        elseif randomSound == 8 then
            soundToPlay = "impacts/sw752_hit_19.wav"
        elseif randomSound == 9 then
            soundToPlay = "impacts/sw752_hit_27.wav"
        elseif randomSound == 10 then
            soundToPlay = "impacts/sw752_hit_28.wav"
        elseif randomSound == 11 then
            soundToPlay = "impacts/sw752_hit_30.wav"
        elseif randomSound == 12 then
            soundToPlay = "impacts/sw752_hit_31.wav"
        elseif randomSound == 13 then
            soundToPlay = "impacts/sw752_hit_17.wav"
        end

    
        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetNormal(tr.HitNormal)

        sound.Play( soundToPlay, tr.HitPos, 75, 100, 1 );

        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetStart(tr.StartPos)
        effect:SetDamageType(dmgtype)

        util.Effect("RagdollImpact", effect)
    end

    return true;
end

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_!",
    -- }
}

--[[
	Custom bar setup
	Colored variants        Classic
	'a' Filled              '-' Filled
	'b' Outline             '_' Outline
	'd' CLR w Outline       '!' Red w Outline
	'#' Empty
]]
--     PrintName = "PUMP",
--     RunAwayBurst = false,
--     AutoBurst = false, -- hold fire to continue firing bursts
--     PostBurstDelay = 0,
--     ActivateElements = {}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 100 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 100 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(0, 110, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.AttachmentOverrides = {
    -- ["optic_docter"] = {} -- allows you to overwrite atttbl values
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnimation to change the bash animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    -- }
}

--[[
for k, v in ipairs(ents.FindByClass("sb*")) do
	if v.Droid then
		v:Give("arccw_ef_blaster_dc15s")
	end
end
]]

DEFINE_BASECLASS( SWEP.Base )
--addons/arccw_weapons/lua/weapons/arccw_sops_emprifle.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "EMP Anti-Vehicle"
SWEP.Trivia_Desc = "The electromagnetic pulse (EMP) launcher was a devastating weapon when used against the battle droid forces of the Confederacy of Independent Systems as they were able to both deactivate droids by shorting out electronics and destroy their interior circuitry with powerful EMP waves. Clone jet troopers used these as their primary weapon."
SWEP.IconOverride = "entities/sopsmisc/emprifle.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.ShootEntity = "ion_throwed"
SWEP.MuzzleVelocity = 3400

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 2.5
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = true -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 1.7
SWEP.HeatFix = true -- when the "fix" animation is played, all heat is restored.

SWEP.ChamberSize = 0 
SWEP.Primary.ClipSize = 6
SWEP.ExtendedClipSize = 8
SWEP.ReducedClipSize = 2

SWEP.Recoil = 1.87
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 102

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 200

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "RPG_Round"
SWEP.MagID = "rpg7"

SWEP.ShootVol = 50
SWEP.ShootPitch = 70
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/emp/emp.mp3"
SWEP.ShootSound = "sops-v2/weapons/emp/emp.mp3"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 142, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -3, -1),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/emp_rifle.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "0000000",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0.1, 2, -9),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 20, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/emp_rifle.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                ModelBodygroups = "0000000",
                Offset = {
                    pos = Vector(140, 10, 40),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(430, 15, -150),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/emp_rifle.mdl"

SWEP.Attachments = {     
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.2, -0.5, 3),
            vang = Angle(0, -90, 0),
            wpos = Vector(80, 11.5, -78),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0)
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(1.1, 18, 1.5),
            vang = Angle(0, -90, 90),
            wpos = Vector(220, 23, -105),
            wang = Angle(-15, 0, -90)
        },
    },  
    {
        PrintName = "Rocket", 
        DefaultAttName = "None",
        Slot = {"ammo_rocket"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "None"
    },         
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(1.8, -8.3, 1.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(60, 30, -54),
            wang = Angle(-15, 0, 180)
        },
    },    
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_m5d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "M5-D"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Heavy-Powered blaster produced by BlastTech Industries for the galactic citizens."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/m5d.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/blasterpistol_template.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 27
SWEP.RangeMin = 127
SWEP.DamageMin = 31
SWEP.Range = 302
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 302

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/m5d.wav"
SWEP.ShootSound = "sops-v2/weapons/m5d.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-5.3, -10, 1.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/m5d.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1.5, 1.1, 1.1),
                Offset = {
                    pos = Vector(-1.65, 4, -4.7),
                    ang = Angle(0, 0, -90)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC-15SA",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 5, 12),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/m5d.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.6, 1.3, 1.3),
                Offset = {
                    pos = Vector(50, 0, 25),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(100, 20, -40),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/m5d.mdl"

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.24, -1.8, -4),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 17.5, -45),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-0.24, 0, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(110, 17.5, -45),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.24, -1.15, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(125, 17.5, -65),
            wang = Angle(-15, 0, 180)

        },
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(0.2, -0.7, -1.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(65, 20, -45),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.75, 1.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(110, 25, -58),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false
    },
    ["fire"] = {
        Source = {"Fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_pistolpuncher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Imperial Firepuncher Pistol"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Heavy-Powered blaster produced by BlastTech Industries for the galactic citizens."
SWEP.IconOverride = "entities/sopsmisc/pistolpuncher.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/blasterpistol_template.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 32
SWEP.RangeMin = 120
SWEP.DamageMin = 24
SWEP.Range = 199
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 29

SWEP.Recoil = 1.20
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 200

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = -3
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/firepuncher/firepuncher.wav"
SWEP.ShootSound = "sops-v2/weapons/firepuncher/firepuncher.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-5.7, -10, 1.1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/pistolpuncher.mdl",
                Bone = "DC-15SA",
                Scale = Vector(0.6, 0.6, 0.6),
                Offset = {
                    pos = Vector(-0.7, -1, -8.3),
                    ang = Angle(90, 0, -90)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC-15SA",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-5, 5, 10),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/pistolpuncher.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.6, 0.6, 0.6),
                Offset = {
                    pos = Vector(0, 10, -15),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(130, 20, -55),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/pistolpuncher.mdl"

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.64, -2.1, -3.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(40, 11, -39),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0)
    },    
    {
        PrintName = "Integrated Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.1, 0.1, 0.1),
        WMScale = Vector(1, 1, 1),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-0.5, 1, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(110, 11, -25),
            wang = Angle(-15, 0, -180)
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.64 , -1.4, 5),
            vang = Angle(90, 0, -90),
            wpos = Vector(140, 11, -57),
            wang = Angle(-15, 0, 180)

        },
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(7, 7, 7),
        Offset = {
            vpos = Vector(0.1, -1, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(86, 19, -20),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.1, -1.2, -4),
            vang = Angle(90, 0, -90),
            wpos = Vector(70, 18, -36),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false
    },
    ["fire"] = {
        Source = {"Fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_wookieslug.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Wookie Slug-Blaster"
SWEP.Trivia_Class = "Slugthrower rifle"
SWEP.Trivia_Desc = "The Wookiee Slug-Thrower was a slugthrower rifle that was mass-produced by Wookiee workshops across the planet Kashyyyk around the time of the Clone Wars. Slugthrowers were primitive weapons that used an explosive force (from chemicals or compressed gas) to launch a solid projectile, called a slug, at high velocity."
SWEP.IconOverride = "entities/sopsmisc/wookieslug.png"
-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 60
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 62
SWEP.RangeMin = 309
SWEP.DamageMin = 31
SWEP.Range = 602
SWEP.Penetration = 10
SWEP.DamageType = DMG_AIRBOAT
SWEP.PhysBulletMuzzleVelocity = 800
SWEP.AlwaysPhysBullet = true 
SWEP.PhysTracerProfile = 4

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.98
SWEP.RecoilSide = 0.22
SWEP.RecoilRise = 0.76
SWEP.Delay = 60 / 176

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/wookieslug.wav"
SWEP.ShootSound = "sops-v2/weapons/wookieslug.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 250, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.95, 0, 0),
    Ang = Angle(1, -0.9, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 8, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/wookie_slug.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.5, 0, -1.5),
                    ang = Angle(0, -180, -10)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 15, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/wookie_slug.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(100, 0, -30),
                    ang = Angle(-15, 90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(200, 15, -100),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/wookie_slug.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.4, -6.5, 2.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(15, 9, -35),
            wang = Angle(-25, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(1.6, 9, 0),
            vang = Angle(0, -90, 90),
            wpos = Vector(170, 25, -80),
            wang = Angle(-25, 0, -70)
        },
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},   
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(1, -5.2, -0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(43, 17, -13),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1, -5.2, 1),
            vang = Angle(0, -90, 0),
            wpos = Vector(70, 17, -30),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sw_rocket_smartlauncher.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Rocket Launcher"
SWEP.TrueName = "Rocket Launcher"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "A rocket launcher with 4 different payload options; HE, HEAT, Tandem, and Smoke. HE rockets have high splash but low immediate damage. HEAT rounds have good damage and splash. Tandem rounds have very little splash, but massive damage. Smoke rounds do no damage, but create an obscuring smokescreen."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Mechanism = "Single-Action"
SWEP.Trivia_Country = "Russia"
SWEP.Trivia_Year = 1961

SWEP.Slot = 4
SWEP.UseHands = true

SWEP.IconOverride = "materials/entities/rocket_launcher_meeks.png"

SWEP.ViewModel = "models/holdtypes/c_rpg7.mdl"
SWEP.WorldModel = "models/holdtypes/w_rpg7.mdl"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true

SWEP.ShootEntity = "arccw_rocket_heat" -- entity to fire, if any
SWEP.MuzzleVelocity = 100000 -- projectile or phys bullet muzzle velocity
-- IN M/S

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 1 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 1
SWEP.ReducedClipSize = 1

SWEP.Recoil = 2
SWEP.RecoilSide = 0.175
SWEP.RecoilRise = 2

SWEP.Delay = 60 / 600 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = "weapon_rpg"
SWEP.NPCWeight = 150

SWEP.AccuracyMOA = 10 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 500

SWEP.Primary.Ammo = "RPG_Round" -- what ammo type the gun uses
SWEP.MagID = "rpg7" -- the magazine pool this gun draws from

SWEP.ShootVol = 130 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound = "weapons/rocket launcher/explosive_rocketlauncher_corebass_close_var_03.mp3"
SWEP.DistantShootSound = "weapons/arccw/rpg7/rpg7_dist.wav"

SWEP.MuzzleEffect = "muzzleflash_m79"

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on

SWEP.SightTime = 0.35

SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.75

SWEP.BarrelLength = 24

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.CaseBones = {}

SWEP.IronSightStruct = {
    Pos = Vector(-2, -12, 2),
    Ang = Angle(1.5, 0, 0),
    Magnification = 1.5,
    SwitchToSound = "", -- sound that plays when switching to this sight
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 2, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 5)
SWEP.SprintAng = Angle(-30, 0, 0)

SWEP.HolsterPos = Vector(1, 4, -14)
SWEP.HolsterAng = Angle(40, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(13.824, 2, 0.897)
SWEP.CustomizeAng = Angle(12.149, 40.547, 45)

SWEP.ExtraSightDist = 15

SWEP.DefaultElements = {"rocketlauncher"}

SWEP.AttachmentElements = {
    ["rocketlauncher"] = {
        VMElements = {
            {
                Model = "models/weapons/rocket_launcher.mdl",
                Bone = "Weapon_Main",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(0.3, 0, 1),
                    ang = Angle(90, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/weapons/rocket_launcher.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(50, 10, -40),
                    ang = Angle(0, 0, 180)
                }
            }
        },
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights",
        Slot = {"optic", "optic_lp"},
        WMScale = Vector(11, 11, 11), -- what kind of attachments can fit here, can be string or table
        Bone = "Weapon_Main", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, -2.6, 5), -- offset that the attachment will be relative to the bone
            vang = Angle(90, 0, -90),
            wpos = Vector(110, 8, -75.301),
            wang = Angle(0, 0, 180)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "bipod"},
        WMScale = Vector(11, 11, 11),
        Bone = "Weapon_Main",
        Offset = {
            vpos = Vector(0, -0.3, 6),
            vang = Angle(90, 0, -90),
            wpos = Vector(150.329, 9, -40.453),
            wang = Angle(-0, 0, 180)
        },
        InstalledEles = {"nogrip"},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "Weapon_Main",
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(1.6, -1.4, 5.8),
            vang = Angle(90, 0, 0),
            wpos = Vector(125.625, 29.253, -60.298),
            wang = Angle(-0, -0, -90)
        },
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "Default",
        Slot = "ammo_rocket"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        NoWM = true,
        Bone = "Weapon_Main",
        Offset = {
            vpos = Vector(1.3, -1.4, 4), -- offset that the attachment will be relative to the bone
            vang = Angle(90, 0, -90),
            wpos = Vector(11, 25, -4.5),
            wang = Angle(0, -4.211, 180)
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1,
    },
    ["idle_empty"] = {
        Source = "idle_empty",
        Time = 1,
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 1.5,
    },
    ["draw"] = {
        Source = "draw",
        Time = 1.5,
    },
    ["fire"] = {
        Source = "fire",
        Time = 0.5,
    },
    ["reload"] = {
        Source = "reload",
        Time = 4,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Checkpoints = {20, 26, 40},
        FrameRate = 30,
        LHIK = false,
        SoundTable = {
            {
                s = "insertrocket", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 74 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
            {
                s = "insertrocket2", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 115 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
            {
                s = "rocketclick", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 174 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}

local path = "weapons/rocket launcher/"

sound.Add({
	name = "insertrocket",
	channel = CHAN_ITEM,
	volume = 1,
	soundlevel = 100,
	pitch = 100,
	sound = path .. "insert.wav"
	})

sound.Add({
	name = "insertrocket2",
	channel = CHAN_ITEM,
	volume = 1,
	soundlevel = 100,
	pitch = 100,
	sound = path .. "insert2.wav"
	})


sound.Add({
	name = 			"rocketclick",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = path ..	"click.wav"
})

--addons/arccw_weapons/lua/weapons/arccw_umb1.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "UMB-1"
SWEP.Trivia_Class = "Galactic Blaster Rifle"
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020
SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_umb1.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 28
SWEP.RangeMin = 150
SWEP.DamageMin = 15
SWEP.Range = 450
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1


SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_green"
SWEP.TracerCol = Color(0, 255, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.13

SWEP.Delay = 60 / 510
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 255, 21)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/umb1.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(0, 250, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-2.8, -11, -0.8),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterrifle_08.mp3",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -6, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(2, -5, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -15, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"umb1"}

SWEP.AttachmentElements = {
    ["umb1"] = {
        VMElements = {
            {
                Model = "models/arccw/jay/unbaran_gun.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.9, 05.55, 4.25),
                    ang = Angle(0, 0, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/jay/unbaran_gun.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(600, 4.5, -200),
                    ang = Angle(-15, -90, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}

WMOverride = "models/arccw/jay/unbaran_gun.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.3, -3, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(500, 0, -550),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        NoWM = true,
        Bone = "e11_sight", -- releva-nt bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 12),
            vang = Angle(90, 0, -90),
        },
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, -1.5, 11),
            vang = Angle(90, 0, 0),
            wpos = Vector(1150, 120, -550),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(111, 111, 111),
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, -1.65, 22),
            vang = Angle(90, 0, -90),
            wpos = Vector(2480, 10, -915),
            wang = Angle(-15, 0, -90)
        },
    },             
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, -1, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 100, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--lua/weapons/blood_mace/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Blood mace"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Blood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, Special +vampirism"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/potato", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/potato", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 23.377), angle = Angle(0, 90, 0), size = Vector(0.4, 0.4, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(103, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/cigar", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(103, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/camera", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 0.8, 0), size = Vector(0.07, 0.07, 0.507), color = Color(255, 0, 0, 95), surpresslightning = false, material = "phoenix_storms/plastic", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/potato", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/potato", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 0.8, 0), size = Vector(0.07, 0.07, 0.507), color = Color(255, 0, 0, 95), surpresslightning = false, material = "phoenix_storms/plastic", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(103, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/cigar", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -38.571, 8), size = Vector(0.05, 0.039, 0.108), color = Color(103, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/camera", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 23.377), angle = Angle(0, 90, 0), size = Vector(0.4, 0.4, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Glass"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		self.Owner:SetHealth(math.Clamp(self.Owner:Health()+3,0,100))
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/gm_climbswep/lua/weapons/climb_swep2/shared.lua:
SWEP.Author              = "Jonascone"
SWEP.Contact             = ""
SWEP.Purpose             = "A reiteration of the Climb SWEP."
SWEP.Instructions        = "Refer to the Workshop page!"

SWEP.Spawnable                  = true
SWEP.AdminSpawnable             = false

SWEP.ViewModel                  = "models/weapons/v_pistol.mdl"
SWEP.HoldType                   = "normal"

SWEP.Primary.ClipSize           = -1
SWEP.Primary.DefaultClip        = -1
SWEP.Primary.Automatic          = false
SWEP.Primary.Ammo               = "none"

SWEP.Secondary.ClipSize         = -1
SWEP.Secondary.DefaultClip      = -1
SWEP.Secondary.Automatic        = true
SWEP.Secondary.Ammo             = "none"


local HitPlayer = { Sound("npc/vort/foot_hit.wav"), Sound("npc/zombie/zombie_hit.wav") }
local MatList = { }
MatList[67] = "concrete"
MatList[68] = "dirt"
MatList[71] = "chainlink"
MatList[76] = "tile"
MatList[77] = "metal"
MatList[78] = "dirt"
MatList[84] = "tile"
MatList[86] = "duct"
MatList[87] = "wood"

function SWEP:DrawWorldModel() return false; end

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
    self.Weapon:DrawShadow(false)
	self.nextThink = 0
	self.Jumps = 0
    self.JumpSequence = 0
	self.EasterEgg = false
	self.Released = false
	self.MFC = "male"
	self.WallJumpTrace = nil
	self.CanWallRun = true
	self.WallRunAnim = 0
    return true
end
function SWEP:Deploy()
    self.Owner:DrawViewModel(false)
    if string.find(self.Owner:GetModel(), "female") or string.find(self.Owner:GetModel(), "alyx") or string.find(self.Owner:GetModel(), "mossman") then self.MFC = "female"
    elseif string.find(self.Owner:GetModel(), "combine") or string.find(self.Owner:GetModel(), "metro") then self.MFC = "combine"
    else self.MFC = "male" end

    self.Owner:SetNWBool("ClimbWallJump", false)
    self.Owner:SetNWBool("ClimbFalling", false)
    self.Owner:SetNWBool("ClimbWallRun", false)
    self.Released = false
    self.CanWallRun = true;		
    self.Parent = NULL;
end
function SWEP:Forget()

    if self.Grab then
        if self.Owner:GetMoveType() == MOVETYPE_NONE then self.Owner:SetMoveType(MOVETYPE_WALK) end
        self.Grab = false
        self.Parent = NULL;
    end
    return true

end
function SWEP:Think()

    if CLIENT or !IsValid(self.Owner) or !self.Owner:Alive() then return false end

    if self.Jumps != self.Owner:GetNWInt("ClimbJumps") then self.Owner:SetNWInt("ClimbJumps", self.Jumps) end
    if !self.Released and !self.Owner:KeyDown(IN_ATTACK2) then
        self.Released = true
    elseif self.Owner:OnGround() and (self.Jumps > 0 or !self.CanWallRun) or self.Owner:GetNWBool("ClimbFalling") then

        self.Jumps, self.JumpSequence = 0, 0
        self.EasterEgg = false
		self.CanWallRun = true
		self.Owner:SetNWBool("ClimbWallJump", false)
        self.Owner:SetNWBool("ClimbFalling", false)

	elseif self.Owner:GetNWBool("ClimbWallRun") and !self.Grab then
	
		local traceData = {};
		traceData.start = self.Owner:GetPos() + Vector(0, 0, 20);
		traceData.endpos = traceData.start + self.Owner:GetForward() * 70;
		traceData.filter = self.Owner;
		local trace = util.TraceLine(traceData);
		
		local vel = self.Owner:GetVelocity();
		if !self.Owner:OnGround() and trace.Hit and self.Owner:KeyDown(IN_FORWARD) and math.abs(vel:Length()) > 100 then
		
			local vel = self.Owner:GetVelocity() + self.Owner:GetForward();
			vel.z = 0;			
			if CurTime() > self.WallRunAnim then
			
				self.WallRunAnim = CurTime() + (0.2 - vel:Length() / 10000);
				self.Owner:ViewPunch(Angle(10, 0, 0));
				if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
				elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end
				vel.z = -(100 + vel:Length());
				
			end
			self.Owner:SetLocalVelocity(vel);
			
		else 
			
			self.Owner:SetNWBool("ClimbWallRun", false); 
			self.CanWallRun = false;
			
		end
    elseif self.Owner:KeyDown(IN_FORWARD) then
		if self.Owner:KeyDown(IN_USE) and !self.Owner:OnGround() and self.CanWallRun and self.Jumps < GetConVarNumber("climbswep2_maxjumps") and !self.Grab then
	
			local traceData = {};
			traceData.start = self.Owner:GetPos();
			traceData.endpos = traceData.start - Vector(0, 0, GetConVarNumber("climbswep2_wallrun_minheight"));
			if !util.TraceLine(traceData).Hit then
			
				self.Owner:SetNWBool("ClimbWallRun", true);
				self.Jumps = self.Jumps + 1
				local vel = self.Owner:GetVelocity() + self.Owner:GetForward() * 100;
				vel.z = 0;
				self.Owner:SetLocalVelocity(vel);
			
			end
		end
	end

    if CurTime() < self.nextThink then return false end

    // For the lulz.
    if self.Owner:GetVelocity().z <= -900 and self.Owner:GetMoveType() == MOVETYPE_WALK then

        if !self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", true); self.Owner:SetNWBool("ClimbWallJump", false)
        elseif self.Owner:KeyDown(IN_JUMP) then

            self.nextThink = CurTime() + 2.5
            if self.MFC == "combine" then

                self.Owner:EmitSound("npc/metropolice/vo/help.wav", 125, math.random(90, 110))
                return true

            end
            self.Owner:EmitSound("vo/npc/"..self.MFC.."01/help01.wav", 125, math.random(90, 110))
            return true

        elseif !self.EasterEgg and math.random(1, 128) == 1 then

            self.EasterEgg = true
            if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/vo/shit.wav", 100)
            else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/gordead_ans19.wav", 100) end
            return true

        end

        return true

    elseif self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", false)
    end

    // Are we grabbing a ledge?
    if self.Grab then

        // Is it a prop?
		local physObj = NULL;
        if IsValid(self.Parent) then
			
			physObj = self.Parent:GetPhysicsObject();
            if physObj:IsMoveable() then 
				if math.abs(self.OldVelocity - self.Parent:GetVelocity():Length()) >= 500 then 
					return false;
				end
			end

        end
        if !self.Owner:KeyDown(IN_FORWARD) and !self.Owner:KeyDown(IN_MOVELEFT) and !self.Owner:KeyDown(IN_MOVERIGHT) then return false
        elseif self.Owner:KeyDown(IN_FORWARD) then

            if self.Owner:KeyDown(IN_JUMP) then

                self:Forget()
                self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
                self.Owner:ViewPunch(Angle(-7.5, 0, 0))
                self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 400)
                return true

            end
            return true

        end

        local Predict
        local Shift = 0
        if self.Owner:KeyDown(IN_SPEED) then Shift = 0.15 end
        self.nextThink = CurTime() + (0.35 - Shift)

        if self.Owner:KeyDown(IN_MOVELEFT) then Predict = -self.Owner:GetRight() * 10
        elseif self.Owner:KeyDown(IN_MOVERIGHT) then Predict = self.Owner:GetRight() * 10 end

        local tracedata = {}
        tracedata.start = self.Owner:GetShootPos() + Predict
        tracedata.endpos = tracedata.start + self.Owner:GetForward() * 40
        tracedata.filter = self.Owner
        local trLo =  util.TraceLine(tracedata)

        local tracedata = {}
        tracedata.start = self.Owner:GetShootPos() + Vector(0, 0, 15) + Predict
        tracedata.endpos = tracedata.start + self.Owner:GetForward() * self.Owner:GetShootPos():Distance(trLo.HitPos)
        tracedata.filter = self.Owner
        local trHi =  util.TraceLine(tracedata)

        if !trHi.Hit and trLo.Hit then

            self.Owner:SetPos(self.Owner:GetPos() + Predict)
			if physObj != NULL then
				self.LocalPos = self.Parent:WorldToLocal(self.Owner:GetPos());
			end
            if trLo.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
			elseif trLo.MatType and MatList[trLo.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trLo.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end

            if self.Owner:KeyDown(IN_MOVELEFT) then self.Owner:ViewPunch(Angle(0, 0, -2.5))
            else self.Owner:ViewPunch(Angle(0, 0, 2.5)) end
            return true

        end

    end

    // Wall Jumping. (In Think due to HUD Implementation)
    if self.Jumps > 0 then

        // Are we actually against a wall?
        local tracedata = { }
        local ShootPos = self.Owner:GetShootPos()
        local AimVector = self.Owner:GetAimVector()
        tracedata.start = ShootPos
        tracedata.endpos = ShootPos - AimVector*45
        tracedata.filter = self.Owner

        local trace = util.TraceLine(tracedata)

        if trace.Hit and !trace.HitSky and !self.Owner:GetNWBool("ClimbWallJump") then

            self.Owner:SetNWBool("ClimbWallJump", true)

        end

    elseif self.Owner:GetNWBool("ClimbWallJump") then self.Owner:SetNWBool("ClimbWallJump", false)
    end

    return true

end
function SWEP:ShakeEffect()
    if self.JumpSequence == 0 then
        self.Owner:ViewPunch(Angle(0, 5, 0))
    elseif self.JumpSequence == 1 then
        self.Owner:ViewPunch(Angle(0, -5, 0))
    elseif self.JumpSequence == 2 then
        self.Owner:ViewPunch(Angle(-5, 0, 0))
    end
    self.JumpSequence = self.JumpSequence < 3 and self.JumpSequence + 1 or 0
end
function SWEP:PrimaryAttack()

    if CLIENT or self.Owner:GetNWBool("ClimbWallRun") then return true end

    // We'll use this trace for determining whether we're looking at a Wall!
    local tracedata = { }
    local ShootPos = self.Owner:GetShootPos()
    local AimVector = self.Owner:GetAimVector()
    tracedata.start = ShootPos
    tracedata.endpos = ShootPos + AimVector*45
    tracedata.filter = self.Owner
    local trace = util.TraceLine(tracedata)

    // We'll have to be off the ground to start climbing!
    if self.Owner:OnGround() then

        // General Melee Functionality

        self:SetNextPrimaryFire(CurTime() + 0.4)

        if !trace.Hit or trace.HitWorld or trace.HitSky then

            self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75)
            return false

        end

        if IsValid(trace.Entity) then

            if !trace.Entity:IsWorld() then

                if GetConVarNumber("climbswep2_necksnaps") == 1 and (trace.Entity:IsPlayer() or trace.Entity:IsNPC()) and trace.Entity:GetAimVector():DotProduct(self.Owner:GetAimVector()) > 0.6 then

                    if trace.Entity:IsPlayer() then

                        if GetConVarNumber("sbox_playershurtplayers") <= 0 then return false end
                        trace.Entity:Kill()
                        self.Owner:AddFrags(1)
                        self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    else

                        trace.Entity:TakeDamage(trace.Entity:Health(), self.Owner, self)
                        self.Owner:AddFrags(1)
                        self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    end

                    return true

                elseif trace.Entity:IsPlayer() then

                    trace.Entity:ViewPunch(Angle(-25, 20, 0))
					if trace.Entity:GetActiveWeapon().Grab then trace.Entity:GetActiveWeapon().Grab = false end
					
                elseif trace.Entity:IsNPC() then
                    trace.Entity:TakeDamage(10, self.Owner, self)
                end
                if (IsValid(trace.Entity:GetPhysicsObject())) then
                    trace.Entity:GetPhysicsObject():ApplyForceOffset((trace.HitPos-self.Owner:EyePos())*128, trace.HitPos)
                end
                self.Owner:EmitSound(table.Random(HitPlayer), 80, math.random(95, 105))
                return true

            end

        end

        return false

    end

    // Are we grabbing?
    if self.Grab then

        // If so, we'll want to reset our variables!
        self:Forget()

        // Now, run up that wall!
        self.Owner:ViewPunch(Angle(-15, self.Owner:EyeAngles().yaw/32, 0))
        self.Owner:EmitSound(Sound("player/suit_sprint.wav"), 80, math.random(95, 105))
        self.Owner:SetVelocity(-self.Owner:GetVelocity() + Vector(0, 0, 250))
        self:SetNextPrimaryFire(CurTime() + 0.15)
        return true

    end

    // Wall Jumping. (Code in Think due to HUD Implementation)
    if self.Owner:GetNWBool("ClimbWallJump") then

        // We can Wall Jump!
        self.CanWallRun = true;
		self.Jumps = 0
        self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 300)
        self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
        self.Owner:ViewPunch(Angle(-7.5, 0, 0))
        return true

    end

    // Are we close enough to start climbing?
    if ( (self.Jumps == 0 and trace.HitPos:Distance(ShootPos) > 40) or self.Jumps > (GetConVarNumber("climbswep2_maxjumps") - 1) or trace.HitSky) then return false end

    // If we've mysteriously lost the wall we'll want to stop climbing!
    if !trace.Hit then return false end

    if self.Owner:GetVelocity().z <= -750 then

        self:SetNextPrimaryFire(CurTime() + 1)
        self.Owner:EmitSound("ambient/levels/canals/toxic_slime_sizzle4.wav", 50, 200)

        if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/knockout2.wav", 125)
        else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/ow0"..math.random(1, 2)..".wav", 125) end

        return true

    end

    // Add some effects.
    if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
	elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105))
    else self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75, math.random(95, 105)) end

    // Climb the wall and modify our jump count.

    local Vel = self.Owner:GetVelocity()
    self.Owner:SetVelocity(Vector(0, 0, 240 - 15 * 1 + self.JumpSequence - Vel.z))
    self:SetNextPrimaryFire(CurTime() + 0.15)
    self.Jumps = self.Jumps + 1
    self:ShakeEffect()
    return true

end
function SWEP:CanGrab() -- This too, but modified it somewhat.

    // We'll detect whether we can grab onto the ledge.
    local trace = {}
    trace.start = self.Owner:GetShootPos() + Vector( 0, 0, 15 )
    trace.endpos = trace.start + self.Owner:GetAimVector() * 30
    trace.filter = self.Owner

    local trHi = util.TraceLine(trace)

    local trace = {}
    trace.start = self.Owner:GetShootPos()
    trace.endpos = trace.start + self.Owner:GetAimVector() * 30
    trace.filter = self.Owner

    local trLo = util.TraceLine(trace)

    // Is the ledge actually grabbable?
    if trLo and trHi and trLo.Hit and !trHi.Hit then
        return {true, trLo}
    else
        return {false, trLo}
    end

end
function SWEP:SecondaryAttack()

    if CLIENT then return true end

    if !self.Released then return end

    if self.Owner:OnGround() then return false end // We don't want to grab onto a ledge if we're on the ground!

    // If we're already grabbing something, we want to let go!
    if self.Grab then
        self:Forget()
        self.Released = false
        return false
    end

    // Returns whether we can grab(boolean) and a traceres.
    local Grab = self:CanGrab()

    // If we can't grab we're done here.
    if !Grab[1] then 
        return false 
    end

    // Otherwise reset our jumps and enter ledge holding mode!
    self.Jumps = 0
    self.Grab  = true
    self.Released = false
    local VelZ = self.Owner:GetVelocity().z;
	self.Owner:ViewPunch(Angle(math.max(15, math.min(30, VelZ)) * (VelZ > 0 and 1 or -1), 0, 0));
    self.Owner:SetLocalVelocity(Vector(0, 0, 0))
    self.Owner:SetMoveType(MOVETYPE_NONE)
    self.Owner:EmitSound(Sound("physics/flesh/flesh_impact_hard"..math.random(1, 3)..".wav"), 75)
	
    // Are we looking at a valid entity?
    if IsValid(Grab[2].Entity) then

        // Does the prop/entity use valid prop-like behaviour?
        if Grab[2].Entity:GetMoveType() == MOVETYPE_VPHYSICS then

            // Then we can grab onto it!
            self.OldVelocity      = Grab[2].Entity:GetVelocity():Length()
            self.Parent           = Grab[2].Entity
            self.LocalPos      	= Grab[2].Entity:WorldToLocal(self.Owner:GetPos())
        end

    end

    local ClimbSwep = self
	local Ply = self.Owner;
    local Forget = function()
        self:Forget();
		hook.Remove("Think", "ClimbGrab"..Ply:UniqueID())
    end
    local IsOneHanded = function()

        if !IsValid(Ply:GetActiveWeapon()) then return false end

        local Weps = {climb_swep2 = true, weapon_pistol = true, weapon_357 = true, weapon_crowbar = true, weapon_frag = true}
        local HoldTypes = {pistol = true, grenade = true, knife = true}
        local Wep = Ply:GetActiveWeapon()
        if Weps[Wep:GetClass()] then return true
        elseif HoldTypes[Wep.HoldType] then return true end
        return false

    end


    local ThinkFunction = function()

		if !Ply:Alive() then hook.Remove("Think", "ClimbGrab"..Ply:UniqueID());
	    elseif !ClimbSwep.Grab or Ply:GetMoveType() != MOVETYPE_NONE then Forget(); return
        elseif !IsOneHanded() then Forget(); 
            return
        elseif IsValid(ClimbSwep.Parent) then

            if ClimbSwep.Parent:GetPhysicsObject():IsMoveable() then
            
                if math.abs(ClimbSwep.OldVelocity - ClimbSwep.Parent:GetVelocity():Length()) >= 500 then Forget()
                else

                    ClimbSwep.OldVelocity = ClimbSwep.Parent:GetVelocity():Length()
                    Ply:SetLocalVelocity(Vector(0, 0, 0))
                    Ply:SetPos(ClimbSwep.Parent:LocalToWorld(ClimbSwep.LocalPos))
                    return

                end

            end

        end

    end
    hook.Add("Think", "ClimbGrab"..Ply:UniqueID(), ThinkFunction)
    return true

end
function SWEP:DrawHUD()

    if SERVER or true then return false end

    /*
        We can't make use of the variables the SERVER has indexed.
        Instead we'll make use of Networked Variables, available to both
        the CLIENT and the SERVER.
    */

    local Jumps, MaxJumps = LocalPlayer():GetNWInt("ClimbJumps"), GetConVarNumber("climbswep2_maxjumps")
    local Width, Height = 256, 18


    // Draw Jump-Monitor
    draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 2, Width, Height, Color(51, 181, 229, 122))
    if (MaxJumps - Jumps) > 0 then draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 2, Width * (MaxJumps - Jumps) / MaxJumps, Height, Color(51, 181, 229, 255)) end
    draw.DrawText("Jumps: "..(MaxJumps - Jumps).." of "..GetConVarNumber("climbswep2_maxjumps"), "Default", ScrW() / 2, ScrH() - 33, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)

    // Draw Custom HUD Icons
    if LocalPlayer():GetNWBool("ClimbWallJump") then

        surface.SetDrawColor(Color(51, 181, 229, 255))
        surface.DrawRect(ScrW() / 2 - 8, ScrH() - Height * 2 - 36, 8, 32)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() / 2 + 9, ScrH() - Height * 2 - 22, 30, 30, -60)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    elseif LocalPlayer():GetNWBool("ClimbFalling") then

        surface.SetDrawColor(Color(51, 181, 229, 255))
        surface.DrawRect(ScrW() / 2 - 16, ScrH() - Height * 2 - 12, 32, 8)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() / 2, ScrH() - Height * 2 - 28, 30, 30, 180)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    end

end
--addons/weapon_joe_fort/lua/weapons/fort_datapad/shared.lua:
SWEP.PrintName = "Strukturenplaner"
SWEP.Author =	"Joe"
SWEP.Contact = "Workshop"
SWEP.Slot = 5
SWEP.SlotPos = -1
SWEP.Instructions = [[
R - Opens up the Menu
E - rotates prop
LMB - spawns prop
RMB - rotates through structures in selected category
]]
SWEP.Spawnable =	true
SWEP.Adminspawnable =	false
SWEP.Category = "AOCRP - Tools"
SWEP.ShowWorldModel = false

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	false
SWEP.Primary.Ammo =	"none"

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"
SWEP.UseHands = true

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 55
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/joes/c_datapad.mdl"
SWEP.WorldModel = "models/joes/w_datapad.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.DrawCrosshair = false

SWEP.selectcat = ""
SWEP.selectnum = 1
SWEP.selectmdl = ""
SWEP.rotation = 0

SWEP.secondarycooldown = 0
SWEP.cld = 0

SWEP.Range = 300

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
end

function SWEP:GetViewModelPosition(pos, ang)
	pos = pos - Vector(0,0,3.5)
	return pos,ang
end

function SWEP:PrimaryAttack()
	if not SERVER then return end
	if not self.selectmdl or self.selectmdl == "" then return end
	local ply = self.Owner
	local trace = ply:GetEyeTrace()
	if trace.HitPos:DistToSqr(self.Owner:GetPos()) > self.Range ^ 2 then return end

	local ent = ents.Create("prop_physics")
	ent:SetModel(self.selectmdl)
	local min = ent:OBBMins()
	ent:SetPos(trace.HitPos - trace.HitNormal * min.z)
	ent:SetAngles(Angle(0,ply:GetAngles().y - 180 + self.rotation,0))
	local tr = util.TraceLine( {
		start =  ent:LocalToWorld(min),
		endpos = ent:LocalToWorld(ent:OBBMaxs()),
		filter = {},
	} )
	ent:Remove()
	if tr.Hit then return end
	
	if JoeFort.Ressources - JoeFort.structs[self.selectcat][self.selectnum].neededresources < 0 then return end

	if JoeFort.structs[self.selectcat][self.selectnum].CanSpawn != nil then
		if JoeFort.structs[self.selectcat][self.selectnum].CanSpawn(self.Owner, self) == false then return end
	end
	
	JoeFort:SpawnEnt(self.Owner, self)
	self.Owner:EmitSound("physics/concrete/rock_impact_hard6.wav")
	self:SetNextPrimaryFire(CurTime() + 2)
end

function SWEP:SecondaryAttack()
	if self.secondarycooldown > CurTime() then return end
	if not self.selectcat or self.selectcat == "" then return end

	local tbl = JoeFort.structs[self.selectcat]

	if self.selectnum + 1 <= table.Count(tbl) then 
		self.selectnum = self.selectnum + 1
	else
		self.selectnum = 1
	end

	self.selectmdl = tbl[self.selectnum].model
	if CLIENT then self:MakeGhostEntity() surface.PlaySound("buttons/combine_button7.wav") end

	self.secondarycooldown = CurTime() + 1
end


function SWEP:Reload()
	self.selectcat = ""
	self.selectnum = 1
	self.selectmdl = ""
	if not CLIENT then return end
	JoeFort:OpenFortMenu(self)
end

local green = Color(0,255,0)
local red = Color(255,0,0)
function SWEP:UpdateGhostent( ent, ply )
	if not IsValid( ent ) then return end

	local trace = ply:GetEyeTrace()
	local ang = Angle(0,ply:GetAngles().y - 180,0) + Angle(0,self.rotation,0)
	local min = ent:OBBMins()
	local pos = trace.HitPos - trace.HitNormal * min.z
	ent:SetPos( pos )
	ent:SetAngles( ang )

	ent:SetNoDraw( false )
end

function SWEP:MakeGhostEntity()
	if not self.selectmdl or self.selectmdl == "" then return end

	if IsValid(self.GhostEntity) then self.GhostEntity:Remove() end

	self.GhostEntity = ents.CreateClientProp( "prop_physics" )
	self.GhostEntity:SetModel(self.selectmdl)
	self.GhostEntity:SetMaterial("ace/sw/hologram")
	self.GhostEntity:SetPos(Vector( 0, 0, 0 ))
	self.GhostEntity:SetAngles(Angle( 0, 0, 0 ))
	self.GhostEntity:SetNoDraw(true)
end

function SWEP:Think()
	if not self.selectmdl or self.selectmdl == "" then if IsValid(self.GhostEntity) then self.GhostEntity:Remove() end return end
	if not IsValid( self.GhostEntity ) or self.GhostEntity:GetModel() != string.lower(self.selectmdl) then
		if CLIENT then self:MakeGhostEntity( ) end
	end

	if CLIENT then self:UpdateGhostent( self.GhostEntity, self.Owner ) end

	if self.cld < CurTime() and self.Owner:KeyPressed(IN_USE) then
		self.rotation = self.rotation + 90 <= 360 and self.rotation + 90 or 0
		self.cld = CurTime() + 1
	end

	if CLIENT then
		local tr = util.TraceLine( {
			start =  self.GhostEntity:LocalToWorld(self.GhostEntity:OBBMins()),
			endpos = self.GhostEntity:LocalToWorld(self.GhostEntity:OBBMaxs()),
			filter = {},
		} )

		if tr.Hit or self.GhostEntity:GetPos():DistToSqr(self.Owner:GetPos()) > self.Range ^ 2 then
			self.GhostEntity:SetColor(red)
		else
			self.GhostEntity:SetColor(green)
		end
	end
end

function SWEP:Holster()
	if IsValid( self.GhostEntity ) then
		self.GhostEntity:Remove()
	end
	return true
end

local col1 = Color(134, 235, 255,255)
local col2 = Color(9, 125, 168, 100)
local mat = Material("ace/sw/hologram")

function SWEP:PostDrawViewModel(vm, wep, ply)
	if not CLIENT then return end
	if not IsValid(self.GhostEntity) then return end
	local ply = self.Owner
	if not self.selectcat or self.selectcat == "" then return end
	if not JoeFort.structs[self.selectcat] then return end
	local data = JoeFort.structs[self.selectcat][self.selectnum]
	if not data then return end
	local obb = self.GhostEntity:OBBCenter()
	local pos = self.GhostEntity:LocalToWorld(Vector(obb.x,0,obb.z))
	local ang = self.Owner:GetAngles()
	ang.r = 0
	ang.p = 0
	ang:RotateAroundAxis(ang:Right(), 90)
	ang:RotateAroundAxis(ang:Up(), -90)

	cam.Start3D2D(pos, ang, 0.1)
		surface.SetFont("JoeFort50")
		local sizex = surface.GetTextSize("Name: " .. data.name) + 30
		surface.SetDrawColor(col2)
		surface.DrawRect(sizex * -0.5, -20, sizex, 220)
		surface.DrawTexturedRect(sizex * -0.5, -20, sizex, 220)
		surface.SetDrawColor(col1)
		surface.DrawOutlinedRect(sizex * -0.5, -20, sizex, 220, 3)
		draw.SimpleText("Name: " .. data.name, "JoeFort50", 0, 10, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		draw.SimpleText("Health: " .. data.health, "JoeFort50", 0, 60, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		draw.SimpleText("Buildtime: " .. data.buildtime .. "s", "JoeFort50", 0, 110, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		draw.SimpleText("Cost: " .. data.neededresources, "JoeFort50", 0, 160, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()

end
--addons/aoc_nextbots/lua/weapons/gmod_tool/stools/droid_dispenser_spawner.lua:
TOOL.Category = "Age of Clones"
TOOL.Name = "Droid Dispenser"
TOOL.Command = nil
TOOL.ConfigName = nil
 
if CLIENT then
    language.Add("Tool.droid_dispenser_spawner.name", "Create Droid Dispenser")
    language.Add("Tool.droid_dispenser_spawner.desc", "Spawns a droid container with droids inside, which are spawned one by one.")
    language.Add("Tool.droid_dispenser_spawner.0", "Left click: Spawns the dispenser")
else
    util.AddNetworkString("AOCRPNextbots.SpawnDispenser")
    net.Receive("AOCRPNextbots.SpawnDispenser", function(len, ply)
        if not ply:HasPermission("NPC") then return end

        local pos = net.ReadVector()
        local data = net.ReadTable()
        local model = net.ReadString()
        local hp = net.ReadUInt(15)
        local shouldFall = net.ReadBool()
        local data_ = {}

        for k, v in pairs(data) do
            for i = 1, v do
                table.insert(data_, k)
            end
        end

        if shouldFall then
            local pod = ents.Create("summe_dispenser_flying")
            pod:SetPos(pos + Vector(0, 0, 600))
            pod:SetOwner(ply)
            pod.TargetPos = pos
            pod.NPCList = data_
            pod:Spawn()
            pod:SetModel(model)
            pod:SetMaxHealth(hp)
            pod:SetHealth(hp)

            local phys = pod:GetPhysicsObject()
            if IsValid(phys) then
                phys:Wake()
            end

            undo.Create("Droid Dispenser Pod")
                undo.AddEntity(pod)
                undo.SetPlayer(ply)
            undo.Finish()
        else
            local pod = ents.Create("summe_dispenser_landed")
            pod:SetPos(pos)
            pod.TargetPos = pos
            pod.NPCList = data_
            pod:Spawn()
            pod:SetModel(model)
            pod:SetMaxHealth(hp)
            pod:SetHealth(hp)

            undo.Create("Droid Dispenser Pod")
                undo.AddEntity(pod)
                undo.SetPlayer(ply)
            undo.Finish()
        end
    end)
end

function TOOL:LeftClick(trace)
    if not IsFirstTimePredicted() then return false end

    if CLIENT then

        local data = {}
        for k, v in SortedPairs(AOCRPNextbots.Config.Tool) do
            data[v.class] = cookie.GetNumber("AOCRPNextbots.Type."..tostring(k)) or 0
        end

        local pos = trace.HitPos
        if not pos then return end

        local model = GetConVarString("droid_dispenser_spawner_model")
        if model == nil then
            model = "models/dav0r/thruster.mdl"
        end

        net.Start("AOCRPNextbots.SpawnDispenser")
            net.WriteVector(pos)
            net.WriteTable(data)
            net.WriteString(model)
            net.WriteUInt(cookie.GetNumber("AOCRPNextbots.DispenserHealth") or 1000, 15)
            net.WriteBool(tobool(cookie.GetString("AOCRPNextbots.DropDispenser") or "false"))
        net.SendToServer()
    end

    return true
end
 
function TOOL:RightClick(trace)
    if not IsFirstTimePredicted() then return false end

    return true
end


local ConVarsDefault = TOOL:BuildConVarList()
 
function TOOL:BuildCPanel()
    if SERVER then return end

    self:AddControl("Header", {
        Text = "Droid Boarding Pod",
        Description = "With this tool you spawn a boarding pod from which droids come out."
    })

    self:AddControl("Label", {
        Text = "The number of droids in the container:",
    })

    for k, v in SortedPairs(AOCRPNextbots.Config.Tool) do
        if not v.dispenser then continue end

        local panel = vgui.Create("DPanel")
        panel:SetTall(ScrH() * .05)

        local spawnIcon = vgui.Create("SpawnIcon", panel)
        spawnIcon:SetModel(v.previewModel or "models/Gibs/HGIBS.mdl")
        spawnIcon:Dock(LEFT)

        local slider = vgui.Create("DNumSlider", panel)
        slider:SetText(v.name)
        slider:SetMinMax(0, 10)
        slider:SetDecimals(0)
        slider:SetValue(cookie.GetNumber("AOCRPNextbots.Type."..tostring(k)) or 0)
        slider:Dock(LEFT)
        slider:SetWide(240)
        slider:SetDark(true)
        function slider:OnValueChanged(value)
            value = math.Round(value, 0)
            cookie.Set("AOCRPNextbots.Type."..tostring(k), value)
        end
        
        self:AddItem(panel)
    end

    self:AddControl("Label", {
        Text = "Settings:",
    })

    self:AddControl("PropSelect", { Label = "Select model", ConVar = "droid_dispenser_spawner_model", Height = 0, Models = list.Get("AOCRPNextbots.DispenserModels")})

    local HPSlider = vgui.Create("DNumSlider")
    HPSlider:SetText("Dispenser Health")
    HPSlider:SetMinMax(0, 10000)
    HPSlider:SetDecimals(0)
    HPSlider:SetValue(cookie.GetNumber("AOCRPNextbots.DispenserHealth", 1000))
    HPSlider:SetDark(true)
    function HPSlider:OnValueChanged(value)
        value = math.Round(value, 0)
        cookie.Set("AOCRPNextbots.DispenserHealth", value)
    end

    self:AddItem(HPSlider)

    local checkbox = vgui.Create("DCheckBoxLabel")
    checkbox:SetText("Fall from sky")
    checkbox:SetValue(tobool(cookie.GetString("AOCRPNextbots.DropDispenser", "false")))
    function checkbox:OnChange(value)
        cookie.Set("AOCRPNextbots.DropDispenser", tostring(value))
    end

    self:AddItem(checkbox)
end

if not CLIENT then return end

CreateClientConVar("droid_dispenser_spawner_model", "models/props/starwars/vehicles/sbd_dispenser.mdl", true, false)

list.Set("AOCRPNextbots.DispenserModels", "models/props/starwars/vehicles/sbd_dispenser.mdl", {})
list.Set("AOCRPNextbots.DispenserModels", "models/props/starwars/vehicles/droideka_dispenser.mdl", {})
list.Set("AOCRPNextbots.DispenserModels", "models/props/starwars/vehicles/bd_dispenser.mdl", {})

local mat = Material("models/wireframe")
local circleMat = Material("particle/particle_ring_wave_addnofog")

-- Renders the marker. 
hook.Add("HUDPaint", "NextBotSpawner.DispenserRender", function()
    local ply = LocalPlayer()
    local tool = ply:GetActiveWeapon()

    if IsValid(tool) and tool:GetClass() == "gmod_tool" and ply:GetTool() and ply:GetTool().Mode == "droid_dispenser_spawner" then
        local targetPos = ply:GetEyeTrace().HitPos
        if isvector(targetPos) then
            cam.Start3D()

            render.SetMaterial(circleMat)
            render.DrawQuadEasy(targetPos + Vector(0, 0, 0), Vector(0, 0, 1), 250, 250, Color(201, 201, 201, 19), 0)

            render.DrawQuadEasy(targetPos + Vector(0, 0, 0), Vector(0, 0, 1), 600, 600, Color(201, 201, 201, 19), 0)

                render.ModelMaterialOverride(mat)
                render.SetColorModulation(0.902,0.416,1)
                render.Model({
                    model = GetConVarString("droid_dispenser_spawner_model"),
                    pos = targetPos,
                    angle = Angle(0),
                    size = 3,
                })
            cam.End3D()
        end
    end
end)
--addons/aoc_nextbots/lua/weapons/gmod_tool/stools/droid_pod_spawner.lua:
TOOL.Category = "Age of Clones"
TOOL.Name = "Droid Boarding Ship"
TOOL.Command = nil
TOOL.ConfigName = nil
 
cleanup.Register("droid_boaring_pods")

if CLIENT then
    language.Add("Tool.droid_pod_spawner.name", "Create Boarding Ship")
    language.Add("Tool.droid_pod_spawner.desc", "Spawns a boarding ship that drills through to the position and then spawns droids.")
    language.Add("Tool.droid_pod_spawner.0", "Left click: Spawns the ship")
else
    util.AddNetworkString("AOCRPNextbots.Spawn")
    net.Receive("AOCRPNextbots.Spawn", function(len, ply)
        if not ply:HasPermission("NPC") then return end

        local pos = net.ReadVector()
        local data = net.ReadTable()
        local data_ = {}

        for k, v in pairs(data) do
            for i = 1, v do
                table.insert(data_, k)
            end
        end

        local pod = ents.Create("summe_boarding_pod_flying")
        pod:SetPos(pos)
        pod:SetOwner(ply)
        pod.TargetPos = pos
        pod.NPCList = data_
        pod:Spawn()

        undo.Create("Droid Boarding Pod")
            undo.AddEntity(pod)
            undo.SetPlayer(ply)
        undo.Finish()
    end)
end

function TOOL:LeftClick(trace)
    if not IsFirstTimePredicted() then return false end

    if CLIENT then

        local data = {}
        for k, v in SortedPairs(AOCRPNextbots.Config.Tool) do
            data[v.class] = cookie.GetNumber("AOCRPNextbots.TypePod."..tostring(k)) or 0
        end

        local pos = trace.HitPos
        if not pos then return end

        net.Start("AOCRPNextbots.Spawn")
        net.WriteVector(pos)
        net.WriteTable(data)
        net.SendToServer()
    end

    return true
end

function TOOL:BuildCPanel()
    if SERVER then return end

    self:AddControl("Header", {
        Text = "Droid Boarding Pod",
        Description = "With this tool you spawn a boarding pod from which droids come out."
    })

    self:AddControl("Label", {
        Text = "The number of droids in the container:",
    })

    for k, v in SortedPairs(AOCRPNextbots.Config.Tool) do
        if not v.pod then continue end

        local panel = vgui.Create("DPanel")
        panel:SetTall(ScrH() * .05)

        local spawnIcon = vgui.Create("SpawnIcon", panel)
        spawnIcon:SetModel(v.previewModel or "models/Gibs/HGIBS.mdl")
        spawnIcon:Dock(LEFT)

        local slider = vgui.Create("DNumSlider", panel)
        slider:SetText(v.name)
        slider:SetMinMax(0, 10)
        slider:SetDecimals(0)
        slider:SetValue(cookie.GetNumber("AOCRPNextbots.TypePod."..tostring(k)) or 0)
        slider:Dock(LEFT)
        slider:SetWide(240)
        slider:SetDark(true)
        function slider:OnValueChanged(value)
            value = math.Round(value, 0)
            cookie.Set("AOCRPNextbots.TypePod."..tostring(k), value)
        end
        
        self:AddItem(panel)
    end
end

if not CLIENT then return end

local mat = Material("models/wireframe")
local circleMat = Material("particle/particle_ring_wave_addnofog")

-- Renders the marker. 
hook.Add("HUDPaint", "NextBotSpawner.Render", function()
    local ply = LocalPlayer()
    local tool = ply:GetActiveWeapon()

    if IsValid(tool) and tool:GetClass() == "gmod_tool" and ply:GetTool() and ply:GetTool().Mode == "droid_pod_spawner" then
        local targetPos = ply:GetEyeTrace().HitPos
        if isvector(targetPos) then
            cam.Start3D()

                render.SetMaterial(circleMat)
                local intPol = (math.sin( CurTime() ) * 300 * 2)
                render.DrawQuadEasy(targetPos + Vector(0, 0, 0), Vector(0, 0, 1), 0 + intPol, 0 + intPol, Color(201, 201, 201, 19), 0)

                render.ModelMaterialOverride(mat)
                render.SetColorModulation(0.416,0.69,1)
                render.Model({
                    model = "models/summe/drochclass/pod.mdl",
                    pos = targetPos + Vector(0, 0, 600),
                    angle = Angle(0),
                })
            cam.End3D()
        end
    end
end)
--lua/weapons/gold_dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Gold dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Gold"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -45.584, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 10
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 30
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapons_other/lua/weapons/jet_mk2.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Jump Pack"
SWEP.Category	= "Star Wars Jetpacks"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		--if (ply.LastJetExecuted or 0)+20 >= CurTime() then return end
		local jp = ents.Create('mk2')
		jp:SetSlotName('mk2')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--addons/arccw_weapons/lua/weapons/masita_iqa11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "[S] IQA-11"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The IQA-11 Blaster Rifle was a model of sniper rifle with a sleek and inexpensive design that made it a weapon of choice for mercenaries and bounty hunters who sought reliability over longer ranges. The rifle could receive modifications, such as an extended barrel and a dual zoom scope. During the Clone Wars, the bounty hunter Rumi Paramita used an IQA-11 while defending Felucian farmers from the Ohnaka Gang. A Mon Calamari also utilized the weapon during the Imperial Era."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/iqa11.png"

SWEP.UseHands = true

SWEP.ViewModel = "models/servius/weapons/viewmodels/c_iqa11.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_iqa-11.mdl"
SWEP.ViewModelFOV = 70
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.DefaultBodygroups = "000000000000"
-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 200
SWEP.RangeMin = 200
SWEP.DamageMin = 100
SWEP.Range = 950
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10

SWEP.Recoil = 1.2
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.18

SWEP.Delay = 60 / 210
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(255, 0, 0)


-- Properties
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0.05
SWEP.ShootPitch = 70

SWEP.ShootSound = "armas/disparos/iqa11.mp3"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

SWEP.IronSightStruct = {
    Pos = Vector(-3.49, -3.547, 2.612),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN
SWEP.ManualAction = true

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)


SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

--SWEP.Attachments 
SWEP.DefaultElements = {"iqa11"}
SWEP.AttachmentElements = {
    ["iqa11"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/viewmodels/c_iqa11.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 1, bg = 1}},
                Offset = {
                    pos = Vector(-800, 500, -500),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4700, 80, -1500),
                    ang = Angle(0, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/viewmodels/c_iqa11.mdl"
SWEP.Attachments = {
    {
        PrintName = "Sight", -- print name
        DefaultAttName = "Standard", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.032, -1.043, 1.723),
            vang = Angle(0, -90, 0),
            wpos = Vector(650, 85, -510),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh",
        Offset = {
            vpos = Vector(0.059, 33.666, 0.86),
            vang = Angle(0, -90, 0),
            wpos = Vector(4700, 80, -1500),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 9.63, 1.113),
            vang = Angle(0, -90, 90),
            wpos = Vector(2000, 150, -750),
            wang = Angle(-15, 0, -90)
        },
    },    
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"foregrip", "bipod"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.222, 9.911, 0),
            vang = Angle(0, -90, 0),
            wang = Angle(165, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 9.9, 0),
            vmax = Vector(-0, 3.5, 0),
            wmin = Vector(1600, 80, -550), 
            wmax = Vector(1600, 80, -550)   -- how far this attachment can slide in both directions.
        },  
    }, 
    {
        PrintName = "Charm", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.546, -0.829, 0.085),
            vang = Angle(0, -90, 0),
            wpos = Vector(900, 145, -420),
            wang = Angle(-10 , 0, -180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["cycle"] = {
        Source = "Pump",
        SoundTable = {
                {s = "everfall/weapons/handling/reload_gentle/locknload/023d-00000922.mp3", t = 1 / 60},
        },
    },
    ["fire"] = {
        Source = "Shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_dc17m_draw_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_blaster_sheathe_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "ArcCW_dp24.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dp24.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_republic_medreload.wav"
    }),
}
--lua/weapons/neon_katana/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Stylish neon..."
SWEP.Instructions = "You know what to do..."

SWEP.PrintName = "Neon katana"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 70
SWEP.ViewModel = "models/weapons/c_stunstick.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "melee"

SWEP.ShowWorldModel = false

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.HoldType = "melee"
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 65
SWEP.Primary.DelayMiss = 0.25
SWEP.Primary.DelayHit = 0.4
SWEP.Primary.Force = 500

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {}

SWEP.VElements = {
	["handle"] = { type = "Model", model = "models/maxofs2d/hover_plate.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -11.5, 0), angle = Angle(90, 0, 90), size = Vector(0.5, 0.3, 0.5), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["rack"] = { type = "Model", model = "models/props_phx/gears/rack18.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 1.5, -1.4), angle = Angle(180, 0, 0), size = Vector(0.2, 0.27, 0.2), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["combineball"] = { type = "Model", model = "models/effects/combineball.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -3.5), angle = Angle(90, 0, 0), size = Vector(0.119, 0.119, 0.119), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade_decor+"] = { type = "Model", model = "models/hunter/blocks/cube1x6x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 20, -3), angle = Angle(0, 0, 7), size = Vector(0.039, 0.079, 0.039), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["train+"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 0, 1.2), angle = Angle(0, 0, 0), size = Vector(0.009, 0.039, 0.029), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["handle+"] = { type = "Model", model = "models/dav0r/tnt/tnt.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0.3, -17, -1), angle = Angle(90, 0, 90), size = Vector(0.2, 0.2, 0.2), color = Color(100, 100, 100, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["combineball+"] = { type = "Model", model = "models/effects/combineball.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -3.5), angle = Angle(90, 0, 0), size = Vector(0.119, 0.119, 0.119), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["train"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1.899, -14), angle = Angle(0, 90, 90), size = Vector(0.014, 0.039, 0.014), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["train2"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 20, -1.201), angle = Angle(0, 0, 7), size = Vector(0.019, 0.039, 0.019), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade_decor"] = { type = "Model", model = "models/hunter/blocks/cube1x6x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 0, -2), angle = Angle(0, 0, 0), size = Vector(0.039, 0.079, 0.039), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["prop+"] = { type = "Model", model = "models/maxofs2d/hover_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(-0.201, 5, 0), angle = Angle(90, 0, 0), size = Vector(0.2, 0.2, 0.05), color = Color(160, 0, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["gear"] = { type = "Model", model = "models/props_phx/gears/bevel90_24.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -2.651), angle = Angle(180, 0, 0), size = Vector(0.079, 0.079, 0.079), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/hover_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(-0.201, 1, 0), angle = Angle(90, 0, 0), size = Vector(0.2, 0.2, 0.05), color = Color(160, 0, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["tri"] = { type = "Model", model = "models/hunter/triangles/1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -1.25), angle = Angle(0, 0, 90), size = Vector(0.064, 0.079, 0.064), color = Color(80, 80, 80, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade_decor2"] = { type = "Model", model = "models/props_combine/CombineThumper002.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0.699, -12, -1), angle = Angle(180, 0, 90), size = Vector(0.059, 0.059, 0.059), color = Color(200, 200, 200, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["train2+"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 20, 0), angle = Angle(0, 0, 7), size = Vector(0.009, 0.039, 0.029), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} }
}




SWEP.WElements = {
	["handle+"] = { type = "Model", model = "models/dav0r/tnt/tnt.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(-0.201, -16, 0), angle = Angle(90, 0, 90), size = Vector(0.2, 0.2, 0.2), color = Color(100, 100, 100, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["train2+"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 20, 0), angle = Angle(0, 0, 7), size = Vector(0.009, 0.039, 0.029), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["combineball+"] = { type = "Model", model = "models/effects/combineball.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -3.5), angle = Angle(90, 0, 0), size = Vector(0.119, 0.119, 0.119), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["handle"] = { type = "Model", model = "models/maxofs2d/hover_plate.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -11.5, 0), angle = Angle(90, 0, 90), size = Vector(0.5, 0.3, 0.5), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["train"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1, -14), angle = Angle(0, 90, 90), size = Vector(0.014, 0.039, 0.014), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade_decor2"] = { type = "Model", model = "models/props_combine/CombineThumper002.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0.699, -12, -1), angle = Angle(180, 0, 90), size = Vector(0.059, 0.059, 0.059), color = Color(200, 200, 200, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["rack"] = { type = "Model", model = "models/props_phx/gears/rack18.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 1.5, -1.4), angle = Angle(180, 0, 0), size = Vector(0.2, 0.27, 0.2), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["combineball"] = { type = "Model", model = "models/effects/combineball.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -3.5), angle = Angle(90, 0, 0), size = Vector(0.119, 0.119, 0.119), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["prop+"] = { type = "Model", model = "models/maxofs2d/hover_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(-0.201, 5, 0), angle = Angle(90, 0, 0), size = Vector(0.2, 0.2, 0.05), color = Color(160, 0, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade_decor+"] = { type = "Model", model = "models/hunter/blocks/cube1x6x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 20, -3), angle = Angle(0, 0, 7), size = Vector(0.039, 0.079, 0.039), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["gear"] = { type = "Model", model = "models/props_phx/gears/bevel90_24.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -2.651), angle = Angle(180, 0, 0), size = Vector(0.079, 0.079, 0.079), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["train+"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 0, 1.2), angle = Angle(0, 0, 0), size = Vector(0.009, 0.039, 0.029), color = Color(160, 100, 255, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/hover_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(-0.201, 1, 0), angle = Angle(90, 0, 0), size = Vector(0.2, 0.2, 0.05), color = Color(160, 0, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["tri"] = { type = "Model", model = "models/hunter/triangles/1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, -9.301, -1.25), angle = Angle(0, 0, 90), size = Vector(0.064, 0.079, 0.064), color = Color(80, 80, 80, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["blade_decor"] = { type = "Model", model = "models/hunter/blocks/cube1x6x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 0, -2), angle = Angle(0, 0, 0), size = Vector(0.039, 0.079, 0.039), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["train2"] = { type = "Model", model = "models/props_combine/combine_train02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "train", pos = Vector(0, 20, -1.201), angle = Angle(0, 0, 7), size = Vector(0.019, 0.039, 0.019), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} }
}



function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 98,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 98,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "weapons/iceaxe/iceaxe_swing1.wav" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 200
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 200
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "weapons/crossbow/bolt_fly4.wav" )
else
self.Owner:EmitSound( "weapons/crossbow/bolt_fly4.wav" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--lua/weapons/neon_knucle/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "What did you do with him?"
SWEP.Instructions = "Kick their ass!"

SWEP.ShowWorldModel = false
SWEP.PrintName = "Neon knuckle"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 60
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "knife"

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 41
SWEP.Primary.DelayMiss = 0.7
SWEP.Primary.DelayHit = 0.9
SWEP.Primary.Force = 3000

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}


SWEP.VElements = {
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0.05, 0.2, 1.5), angle = Angle(180, 90, -90), size = Vector(0.3, 0.3, 0.3), color = Color(40, 40, 40, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part4+"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.799, 0.8), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.2, 2), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(60, 60, 60, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["neon"] = { type = "Model", model = "models/squad/sf_bars/sf_bar1.mdl", bone = "v_weapon.Knife_Handle", rel = "part1", pos = Vector(0.129, 0, -0.051), angle = Angle(0, 90, 0), size = Vector(0.159, 0.159, 0.159), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2, -0.301), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(20, 20, 20, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["what"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "v_weapon.Knife_Handle", rel = "part1", pos = Vector(0, -0.9, 0.059), angle = Angle(-90, 90, 0), size = Vector(0.059, 0.059, 0.059), color = Color(255, 255, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 1.299, 3), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(80, 80, 80, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part5+"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.2, -0.401), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part3+"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.4, 1.899), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part2+"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 1.5, 2.9), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.599, 0.899), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(40, 40, 40, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} }
}




SWEP.WElements = {
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, 0), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, -1.5), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 1.2), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} },
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 0), angle = Angle(0, 0, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, -2.3), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 0, 255), surpresslightning = true, material = "phoenix_storms/white", skin = 0, bodygroup = {} }
}



function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "Weapon_HL_Crowbar.Miss" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 64
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 0
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "Flesh.ImpactHard" )
else
self.Owner:EmitSound( "Weapon_HL_Crowbar.Hit" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--addons/weapons_other/lua/weapons/weapon_armorkit.lua:

AddCSLuaFile()

SWEP.PrintName = "Armor-Kit"
SWEP.Author = "Age of Clones"
SWEP.Purpose = "Linksklick zum Rüstung geben"
SWEP.DrawCrosshair = false

SWEP.Slot = 5
SWEP.SlotPos = 3

SWEP.Spawnable = true

SWEP.ViewModel = Model( "models/weapons/v_toolgun.mdl" )
SWEP.WorldModel = Model( "models/weapons/w_toolgun.mdl" )
SWEP.ViewModelFOV = 54
SWEP.UseHands = true

SWEP.Primary.ClipSize = 100
SWEP.Primary.DefaultClip = 100
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.HealAmount = 25
SWEP.MaxAmmo = 100

local HealSound = Sound( "items/battery_pickup.wav" )

function SWEP:Initialize()

	self:SetHoldType( "slam" )

	if ( CLIENT ) then return end

	timer.Create( "medkit_ammo" .. self:EntIndex(), 1, 0, function()
		if ( self:Clip1() < self.MaxAmmo ) then self:SetClip1( math.min( self:Clip1() + 5, self.MaxAmmo ) ) end
	end )

end

function SWEP:PrimaryAttack()

	if ( CLIENT ) then return end

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
		filter = self.Owner
	} )

	local ent = tr.Entity

	local need = self.HealAmount
	if ( IsValid( ent ) ) then need = math.min( ent:GetMaxArmor() - ent:Armor(), self.HealAmount ) end

	if ( IsValid( ent ) && self:Clip1() >= need && ( ent:IsPlayer() or ent:IsNPC() ) && ent:Armor() < ent:GetMaxArmor()  ) then

		self:TakePrimaryAmmo( need )

		ent:SetArmor( math.min( ent:GetMaxArmor(), ent:Armor() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0.5 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		self:SetNextPrimaryFire( CurTime() + 1 )

	end

end

function SWEP:SecondaryAttack()

	if ( CLIENT ) then return end
	self:SetNextSecondaryFire( CurTime() + 1 )
 	local ent = self.Owner

	local need = self.HealAmount
	if ( IsValid( ent ) ) then need = math.min( ent:GetMaxArmor() - ent:Armor(), self.HealAmount ) end

	if ( IsValid( ent ) && self:Clip1() >= need && ent:Armor() < ent:GetMaxArmor() ) then

		self:TakePrimaryAmmo( need )

		ent:SetArmor( math.min( ent:GetMaxArmor(), ent:Armor() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() + 0.5 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		self:SetNextSecondaryFire( CurTime() + 1 )

	end

end

function SWEP:OnRemove()

	timer.Stop( "medkit_ammo" .. self:EntIndex() )
	timer.Stop( "weapon_idle" .. self:EntIndex() )

end

function SWEP:Holster()

	timer.Stop( "weapon_idle" .. self:EntIndex() )

	return true

end

function SWEP:CustomAmmoDisplay()

	self.AmmoDisplay = self.AmmoDisplay or {}
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()

	return self.AmmoDisplay

end

--addons/arccw_weapons/lua/weapons/weapon_imperial_flamethrower.lua:
AddCSLuaFile()

SWEP.Base = "arccw_base"

SWEP.PrintName				= "Imperial D-72w Oppressor"
SWEP.Category 				= "AOCRP - Nicht eingestelle Waffen"
SWEP.Trivia_Class 			= "Flamethrower"
SWEP.Trivia_Desc 			= "The D-72w Oppressor flame projector was a flamethrower used by Incinerator troopers part of Moff Gideon's Imperial remnant."
SWEP.Author				= "Meeks & Venator"
SWEP.Purpose				= ""

SWEP.Spawnable				= true
SWEP.UseHands				= true
SWEP.DrawAmmo				= true

SWEP.ViewModel				= "models/ven/sw_battlefront/weapons/bf2017/v_e11_flame.mdl"
SWEP.WorldModel				= "models/models/weapon/ven/custom/smg/ggn/flame/imperial_incinerator_world.mdl"
SWEP.HideViewmodel = true

SWEP.IconOverride = "materials/entities/imperial_incinerator.png"


SWEP.ViewModelFOV			= 75
SWEP.Slot				= 4
SWEP.SlotPos				= 5

SWEP.ChamberSize 			= 0
SWEP.Primary.ClipSize			= 200
SWEP.Primary.DefaultClip		= 200
SWEP.ExtendedClipSize			= 400
SWEP.Primary.Automatic			= true
SWEP.Primary.Ammo			= "ar2"
SWEP.Secondary.ClipSize			= -1
SWEP.Secondary.DefaultClip		= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo			= "none"
SWEP.FireLoopSound			= "nil"
SWEP.LastShoot				= nil
SWEP.IsShooting				= false
SWEP.Reloading				= false


SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.ActivePos = Vector(3, -5, 0)
SWEP.ActiveAng = Angle(-5, -4, 5)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 10.547, 0)


SWEP.DefaultElements = {"flamethrower"}

SWEP.AttachmentElements = {
    ["flamethrower"] = {
        VMElements = {
            {
                Model = "models/models/weapon/ven/custom/smg/ggn/flame/imperial_incinerator.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.05, 1.05, 1.05),
                Offset = {
                    pos = Vector(7.791, 3.635, -1.558),
                    ang = Angle(-5.844, -113.377, -176.495)
                }
            }
        }
	},
}

WMOverride = "models/models/weapon/ven/custom/smg/ggn/flame/imperial_incinerator_world.mdl"

SWEP.Attachments = {
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "ValveBiped.Bip01_R_Hand",
        Offset = {
            vpos = Vector(12, 5.25, -4.8),
            vang = Angle(0, -22, 0),
            wpos = Vector(22, 3.25, -8.55),
            wang = Angle(-10, -0.556, 175)
        },
		CorrectiveAng = Angle(180, 0, 0),			
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        Slot = {"speedboost", "perk"}, --nothing else is compatible
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "ValveBiped.Bip01_R_Hand",
        Offset = {
            vpos = Vector(10, 6, -3.55),
            vang = Angle(-1, -20, 190),
            wpos = Vector(14.5, 2.5, -7.55),
            wang = Angle(-10, -0.556, 175)
        },
		CorrectiveAng = Angle(180, 0, 0),			
    },
}

SWEP.Firemodes = {
    {
        PrintName = "FIRE",
        Mode = 1,
    },
    {
        Mode = 0
    }
}


if CLIENT then
	game.AddParticles( 'particles/alien_isolation.pcf' )
end

if SERVER then
	util.AddNetworkString( 'AI_FLAMETHROWER_SHOOT' )
else
	net.Receive( 'AI_FLAMETHROWER_SHOOT', function()
		local self = net.ReadEntity()
		self.LastShoot = CurTime() + 0.15
	end )
end


function SWEP:Initialize()
	self.FireLoopSound = CreateSound( self, 'weapons/flamethrower_loop.wav' )
	timer.Simple( 0, function() if !IsValid( self ) then return end self:SetMoveType( MOVETYPE_NONE ) end )
end

function SWEP:Reload( i )
	if self.Owner:GetAmmoCount( 'ar2' ) <= 0 then return end -- no ammo to reload!
	if self:Clip1() >= self.Primary.ClipSize then return end -- we're already full!
	if self.Reloading then return end
	if self.FireLoopSound then self.FireLoopSound:FadeOut( 0.5 ) timer.Simple( 0.5, function() self.FireLoopSound:Stop() end ) end
	self:SendWeaponAnim( ACT_VM_RELOAD )
	self.Reloading = true
	self:DefaultReload( self.Primary.ClipSize )
	-- timer.Simple( 0.4, function() if !IsValid( self ) then return end self:EmitSound( 'weapons/flamethrower_reload_01.wav' ) end )
	-- timer.Simple( 0.6, function() if !IsValid( self ) then return end self:EmitSound( 'weapons/flamethrower_reload_02.wav' ) end )
	-- timer.Simple( 1.8, function() if !IsValid( self ) then return end self:EmitSound( 'weapons/flamethrower_reload_04.wav' ) end )
	-- timer.Simple( 2.5, function() if !IsValid( self ) then return end self:EmitSound( 'weapons/flamethrower_reload_05.wav' ) end )
	-- timer.Simple( 3.4, function() if !IsValid( self ) then return end self:EmitSound( 'weapons/flamethrower_reload_01.wav' ) end )
	timer.Simple( 3.5, function() if !IsValid( self ) then return end self.Reloading = false end )
end

function SWEP:Think()
	if self.LastShoot and self.LastShoot > CurTime() and CLIENT then
		local dlight = DynamicLight( LocalPlayer():EntIndex() )
		if ( dlight ) then
			dlight.pos = self.Owner:GetShootPos() + self.Owner:EyeAngles():Forward() * 40 + self.Owner:EyeAngles():Right() * 4 - self.Owner:EyeAngles():Up() * 5
			dlight.r = 255
			dlight.g = 200
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 2000
			dlight.Size = 800
			dlight.DieTime = CurTime() + 0.6
		end
	end
	
	if self.LastShoot and self.LastShoot > CurTime() and self.IsShooting then
		if SERVER then net.Start( 'AI_FLAMETHROWER_SHOOT' ) net.WriteEntity( self ) net.Send( self.Owner ) end
		if SERVER then
			local tr = {}
			tr.start = self.Owner:GetShootPos()
			tr.endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * 335 )
			tr.filter = self.Owner
			tr.mins = Vector( -10, -10, -10 )
			tr.maxs = Vector( 10, 10, 10 )
			tr.mask = MASK_SHOT_HULL
			local _tr = util.TraceHull( tr )
			local v = _tr.Entity
			if IsValid( v ) then 
				if v:IsPlayer() and v != self.Owner or v:IsNPC() or v:GetClass() == 'prop_physics' or v:GetClass() == 'prop_ragdoll' then
					if v:GetClass() == 'npc_' and self.NextAllowedXenoScare < CurTime() then
						self.NextAllowedXenoScare = CurTime() + 1
						v:ReactToFire( self:GetPos() )
					elseif v:GetClass() != 'npc_' then
						v:Ignite( 3 )
						v:TakeDamage( math.random( 0.6, 1.3 ), self.Owner, self )
					end
				end
			end
		end
	end
	
	if self.LastShoot and self.LastShoot < CurTime() and self.IsShooting then
		if self.FireLoopSound then self.FireLoopSound:FadeOut( 0.5 ) timer.Simple( 0.5, function() self.FireLoopSound:Stop() end ) end
		self.IsShooting = false
		self:EmitSound( 'weapons/flamethrower_end.wav' )
	end
end

function SWEP:PrimaryAttack()
		if self:Clip1() <= 0 then return end -- we're already full!
		if self.Owner:WaterLevel() >= 3 then return end
		ParticleEffect( 'alien_flamethrower_fire_start', self.Owner:GetShootPos() + self.Owner:EyeAngles():Forward() * 69 + self.Owner:EyeAngles():Right() * 7 - self.Owner:EyeAngles():Up() * 10, self.Owner:EyeAngles(), self )
		if !self.IsShooting then
			self:EmitSound( 'weapons/flamethrower_start.wav' )
			self.FireLoopSound:Play()
		end
		self.IsShooting = true
		self.LastShoot = CurTime() + 0.15
		self:TakePrimaryAmmo( 1 )
		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		self:SetNextPrimaryFire( CurTime() + 0.05 )
	end

--addons/weapon_jedi/lua/weapons/weapon_lightsaber_plokoon.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Plo Koon"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("jocasta")
		self:SetBladeR("blue")
	end
end

if CLIENT then return end 

function SWEP:ForcePowersGive(ply)
	ply:lscsAddInventory("item_force_leap", true)
	ply:lscsAddInventory("item_force_push", true)
    ply:lscsAddInventory("item_force_pull", true)
    ply:lscsAddInventory("item_force_rockthrow", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)

	ply:lscsAddInventory("item_stance_djemso", true)
	ply:lscsAddInventory("item_stance_shiicho", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/weapon_jedi/lua/weapons/weapon_lscs/sh_combo.lua:

if SERVER then
	util.AddNetworkString( "lscs_cancelattack" )

	function SWEP:CancelCombo( delay )
		self:SetNextPrimaryAttack( math.max(self:GetNextPrimaryAttack(),CurTime()) + (delay or 0) )

		self:FinishCombo()
		self:StopAnimation()

		net.Start( "lscs_cancelattack" )
			net.WriteEntity( self )
		net.Broadcast()
	end
else
	function SWEP:CancelCombo()
		self:FinishCombo()
		self:StopAnimation()
	end

	net.Receive( "lscs_cancelattack", function( len )
		local ent = net.ReadEntity()
		if not IsValid( ent ) or not ent.LSCS then return end

		ent:CancelCombo()
	end )
end

function SWEP:CurComboUnblockable()
	return self:GetAnimHasCancelAnim()
end

function SWEP:GetCombo()
	local CurStance = self:GetNWStance()

	if CurStance == -1 then
		return LSCS:GetStance( self:GetLockedCombo() )
	end

	local ply = self:GetOwner()

	if IsValid( ply ) then
		local combo = ply:lscsGetCombo()

		if CurStance > #combo then
			self:SetNWStance( 1 )
		end

		return LSCS:GetStance( combo[ self:GetNWStance() ] )
	else
		return LSCS:GetStance( "default" )
	end
end

function SWEP:GetComboObject( id )
	return self:GetCombo().Attacks[ id ]
end

function SWEP:StartCombo( ComboObj )
	self.AttackActive = true

	local Time = CurTime()
	self.ComboStatus = 1
	self.CurCombo = {
		BeginTime = Time + ComboObj.Delay,
		BeginFunc = ComboObj.BeginAttack,
		SwingTime = ComboObj.Duration,
		FinishFunc = ComboObj.FinishAttack,
		FinishTime = (Time + ComboObj.Duration + ComboObj.Delay),
	}
end

function SWEP:FinishCombo()
	self.AttackActive = nil
	self.CurCombo = nil
	self.ComboStatus = nil
	self:FinishAttack()
end

function SWEP:HandleCombo()
	local Time = CurTime()
	local ply = self:GetOwner()

	if not IsValid( ply ) then
		self:FinishCombo()
		return
	end

	if self.ComboStatus == 1 then
		if self.CurCombo.BeginTime <= Time then
			self:BeginAttack()

			ProtectedCall( function() self.CurCombo.BeginFunc( self, ply ) end )

			self.ComboStatus = 2
		end
	end

	if self.ComboStatus == 2 then
		if (self.CurCombo.BeginTime + self.CurCombo.SwingTime) * 0.7 <= Time then
			self.ComboStatus = 3
		end
	end

	if self.ComboStatus == 3 then
		if self.CurCombo.FinishTime <= Time then

			ProtectedCall( function() self.CurCombo.FinishFunc( self, ply ) end )
			
			self:FinishCombo()
		end
	end
end

function SWEP:ComboThink()
	if self.CurCombo and self.ComboStatus then
		self:HandleCombo()
		
		local ply = self:GetOwner()

		if IsValid( ply ) then
			local ID = ply:LookupAttachment( "anim_attachment_RH" )
			local att = ply:GetAttachment( ID )

			if att then
				self:SetBlockPos( att.Pos )
			end
		end
	else
		self:SetBlockPos( Vector(0,0,0) )
	end

	local ply = self:GetOwner()

	if IsValid( ply ) then
		if ply:lscsKeyDown( IN_ATTACK ) then
			self:DoCombo()
		end
	end
end

function SWEP:DoCombo()
	if not self:CanPrimaryAttack() then return end

	self:FinishCombo()

	local ply = self:GetOwner()

	local W = ply:lscsKeyDown( IN_FORWARD ) and "W" or "_"
	local A = ply:lscsKeyDown( IN_MOVELEFT ) and "A" or "_"
	local S = ply:lscsKeyDown( IN_BACK ) and "S" or "_"
	local D = ply:lscsKeyDown( IN_MOVERIGHT ) and "D" or "_"

	local ATTACK_DIR = W..A..S..D
	local Hack45Deg = false -- hack45Deg  is used so +45+ and -45- is counted as ___ so you can not switch between those to get a quickswing

	if not ply:lscsKeyDown( IN_SPEED ) and not ply:lscsKeyDown( IN_JUMP ) then
		if ATTACK_DIR == "____" or ATTACK_DIR == "W___" then
			if ply:EyeAngles().p > 15 then
				if self:GetComboObject( "+45+" ) then
					ATTACK_DIR = "+45+"
					Hack45Deg = true
				end

			elseif ply:EyeAngles().p < -15 then
				if self:GetComboObject( "-45-" ) then
					ATTACK_DIR = "-45-"
					Hack45Deg = true
				end
			else
				if ATTACK_DIR == "W___" then
					if self:GetComboObject(  "-45-" ) then
						ATTACK_DIR =  "-45-"
						Hack45Deg = true
					end
				end
			end
		end
	end

	if not ply:OnGround() then
		if self.LastAttack == "BACKFLIP" and (self:GetNextPrimaryAttack() + 0.5) > CurTime() then
			ATTACK_DIR = "SLAM"
		else
			if ply:lscsKeyDown( IN_JUMP ) then
				if ATTACK_DIR == "W___" then
					ATTACK_DIR = "FRONT_DASH"
				end

				if ATTACK_DIR == "__S_" then
					ATTACK_DIR = "BACKFLIP"
				end

				if ATTACK_DIR == "_A__" then
					ATTACK_DIR = "ROLL_LEFT"
				end

				if ATTACK_DIR == "___D" then
					ATTACK_DIR = "ROLL_RIGHT"
				end
			end
		end
	end

	self:SetActive( true )

	local ComboObj = self:GetComboObject( ATTACK_DIR )

	if not ComboObj then
		ComboObj = self:GetComboObject( "____" )
		ATTACK_DIR = "____"
	end

	if Hack45Deg then
		ATTACK_DIR = "____"
	end

	if self.LastAttack then
		local A = string.Explode( "", ATTACK_DIR )
		local B = string.Explode( "", self.LastAttack )

		if self.LastAttack == ATTACK_DIR or A[2] == B[2] or A[4] == B[4] or self.LastAttack == "____" then
			if (self:GetNextPrimaryAttack() + 0.5) > CurTime() then
				return
			end
		end
	end

	self:PlayAnimation(ComboObj.AttackAnim, ComboObj.AttackAnimSpeed, ComboObj.AttackAnimStart)

	local Time = CurTime() + ComboObj.Delay + ComboObj.Duration + 0.1
	self:SetNextPrimaryAttack( Time )
	self:SetGestureTime( Time )

	self.LastAttack = ATTACK_DIR

	if isstring( LSCS.ComboInterupt[ ATTACK_DIR ] ) then
		self:SetAnimHasCancelAnim( false )
	else
		self:SetAnimHasCancelAnim( true )
		self:DrainBP( 15 )
	end

	self:StartCombo( ComboObj )
end

function SWEP:IsComboActive()
	return self.ComboStatus ~= nil
end
--addons/weapon_jedi/lua/weapons/weapon_lscs/cl_effects.lua:
SWEP.BladeData = {
	[SWEP.HAND_RIGHT] = {
	},
	[SWEP.HAND_LEFT] = {
	},
}

function SWEP:CalcTrail( HandID, BladeID, PosData, bladeObject, Mul )
	local DMGActive = self:GetDMGActive()
	local LifeTime = self:GetBladeLifeTime()
	local CurTime = CurTime()

	local length = bladeObject.length * (PosData.length_multiplier or 1)

	local cur_pos = PosData.pos + PosData.dir * length
	local cur_dir = -PosData.dir

	if self:CanDoTrail( HandID, BladeID, 0.02 ) then
		for id, data in pairs( self.BladeData[HandID][BladeID].BladePositions ) do
			if CurTime - data.time > LifeTime then
				self.BladeData[HandID][BladeID].BladePositions[id] = nil
			end
		end

		if DMGActive then
			local data = {
				time = CurTime,
				pos = cur_pos,
				dir = cur_dir,
			}

			table.insert(self.BladeData[HandID][BladeID].BladePositions, data)
			table.sort(self.BladeData[HandID][BladeID].BladePositions, function( a, b ) return a.time > b.time end )
		end

		if Mul == 1 and bladeObject.dynamic_light and LSCS.DynamicLight then
			local dlight = DynamicLight( self:EntIndex() * 1000 + HandID * 10 + BladeID )
			if dlight then
				dlight.pos = cur_pos + cur_dir * length * 0.5
				dlight.r = bladeObject.color_blur.r
				dlight.g = bladeObject.color_blur.g
				dlight.b = bladeObject.color_blur.b
				dlight.brightness = 2
				dlight.Decay = 100
				dlight.Size = 125
				dlight.DieTime = CurTime + 0.2
			end
		end
	end

	render.SetMaterial( bladeObject.material_trail )

	self:DrawTrail( cur_pos, cur_dir, CurTime, LifeTime, length, self.BladeData[HandID][BladeID].BladePositions,  bladeObject.color_core, bladeObject.color_blur, DMGActive )
end

local function OverClocked() -- if someone has host_timescale lower than default 1, chances are he wants to make a screenshot. Lets increase detail to maximum in this case for best looks.
	return LSCS.TimeScale < 0.9
end

function SWEP:DrawTrail( MyPos, MyDir, CurTime, LifeTime, Length, Positions, ColorStart, ColorEnd, DMGActive )
	local prev

	if DMGActive then
		prev = {
			pos = MyPos,
			dir = MyDir,
			time = CurTime
		}
	end

	local LoopStep = OverClocked() and 1 or 2

	local idx = 0
	for _, cur in ipairs( Positions ) do
		if prev then
			local startpos = prev.pos
			local startdir = prev.dir

			local endpos = cur.pos
			local enddir = cur.dir

			local subtract = endpos - startpos

			local direction = subtract:GetNormalized()
			local distance = subtract:Length()

			for i = LoopStep, distance,LoopStep do
				idx = idx + 1

				if idx > self:GetMaxBeamElements() then
					break
				end

				local _pos = startpos + direction * i
				local _dir = startdir + (enddir - startdir) / distance * i
				local _time = prev.time + (cur.time - prev.time) / distance * i
				local _alpha = math.max( (_time + LifeTime - CurTime) / LifeTime, 0)

				local _alpha2 = (math.max(_alpha - 0.8,0) / 0.2) ^ 2
				local inv_alpha2 = math.max(1 - _alpha2,0)

				local R = ColorStart.r * _alpha2 + ColorEnd.r * inv_alpha2
				local G = ColorStart.g * _alpha2 + ColorEnd.g * inv_alpha2
				local B = ColorStart.b * _alpha2 + ColorEnd.b * inv_alpha2
				local A = (ColorStart.a * _alpha2 + ColorEnd.a * inv_alpha2) * _alpha

				render.DrawBeam( _pos, _pos + _dir * Length, 12, 1, 1, Color(R, G, B, A ) )
			end
		end

		prev = {
			pos = cur.pos,
			dir = cur.dir,
			time = cur.time
		}
	end
end

function SWEP:CanDoTrail( HandID, BladeID, Next )
	local Time = CurTime()
	if self.BladeData[HandID][BladeID].BladeNext < Time then
		self.BladeData[HandID][BladeID].BladeNext = Time + Next

		return true
	else
		return false
	end
end

function SWEP:CanDoEffect( HandID, BladeID, Next )
	local Time = CurTime()
	if self.BladeData[HandID][BladeID].NextImpactFX < Time then
		self.BladeData[HandID][BladeID].NextImpactFX = Time + Next

		return true
	else
		return false
	end
end

function SWEP:ObjectImpactEffects( pos, dir )
	local effectdata = EffectData()
		effectdata:SetOrigin( pos )
	util.Effect( "saber_hit_generic", effectdata, true, true )
end

function SWEP:IsMe()
	if not self._IsMe and IsValid( self:GetOwner() ) then
		self._IsMe = self:GetOwner() == LocalPlayer()
	end

	return self._IsMe
end

function SWEP:WallImpactEffects( pos, dir, playsound )
	if playsound then
		local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			effectdata:SetNormal( dir )
		util.Effect( "saber_hitwall_cheap", effectdata, true, true )

		sound.Play(Sound( "saber_hitwall_spark" ), pos, 75)
	else
		local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			effectdata:SetNormal( dir )
		util.Effect( "saber_hitwall", effectdata, true, true )
	end
end

function SWEP:GetMaxBeamElements()
	if OverClocked() then
		return 400
	end
	if self:IsMe() then
		return 200 * LSCS.SaberTrailDetail
	else
		return 25 * LSCS.SaberTrailDetail
	end
end

function SWEP:GetBladeLifeTime()
	if OverClocked() then
		return 0.15
	end
	if self:IsMe() then
		return 0.15 * LSCS.SaberTrailDetail
	else
		return 0.1 * LSCS.SaberTrailDetail
	end
end

function SWEP:DrawBlade( HandID, BladeID, PosData, bladeObject, Mul, HiltAngles )
	local length = bladeObject.length * (PosData.length_multiplier or 1)

	local width = bladeObject.width * (PosData.width_multiplier or 1)
	local actual_width = width + math.Rand(0,bladeObject.widthWiggle)

	local pos = PosData.pos
	local dir = PosData.dir

	local w12 = width * 12
	local w32 = width * 32

	local color_blur = bladeObject.color_blur
	local color_core = bladeObject.color_core

	local Frac = self:DoBladeTrace( HandID, BladeID, pos, dir, length * Mul, width ).Fraction

	local MulxFrac = Mul * Frac

	if bladeObject.mdl then
		self:DrawBladeModel( HandID, BladeID, PosData, bladeObject, MulxFrac, HiltAngles )

		return
	end

	render.SetMaterial( bladeObject.material_glow )
	render.DrawSprite( pos, w32, w32, color_blur )

	-- inefficient pls replace
	for i = 0, math.Round( (length - 1) * MulxFrac, 0 ) do
		render.DrawSprite( pos + dir * i, w12, w12, color_blur ) 
	end

	local EndPos = pos + dir * math.max(length - 0.9,0) * MulxFrac

	render.SetMaterial( bladeObject.material_core )
	render.DrawBeam( pos, EndPos, actual_width , 1, 1, color_core )

	render.SetMaterial( bladeObject.material_core_tip )
	render.DrawBeam( EndPos, EndPos + dir, actual_width , 0.9, 0.1, color_core )
end

function SWEP:DoImpactEffects( HandID, BladeID, bHit, vPos, vDir, hitEnt, ply, min, max )
	local start_pos = ply:GetShootPos()

	if self:IsThrown() then
		start_pos = self:GetProjectile():GetPos()
	end

	local aimDir = ply:GetAimVector()
	local dmgActive = self:GetDMGActive()

	local bHitWall = bHit and not IsValid( hitEnt )
	if self.BladeData[HandID][BladeID].HitWall ~= bHitWall then
		self.BladeData[HandID][BladeID].HitWall = bHitWall

		if bHitWall then
			if dmgActive then
				sound.Play( "saber_lighthit", vPos )
			end
		else
			sound.Play( "saber_hitwall", vPos )
		end
	end

	-- ?option performance setting?
	--[[
	if ply ~= LocalPlayer() then
		if not IsValid( hitEnt ) and bHitWall then
			if self:CanDoEffect( HandID, BladeID, 0.05 ) then
				self:WallImpactEffects(vPos, vDir, true )
			end
		end

		return
	end
	]]

	if self.BladeData[HandID][BladeID].prev_hitpos and self.BladeData[HandID][BladeID].prev_hitnormal then
		local _pos = self.BladeData[HandID][BladeID].prev_hitpos
		local _dir = self.BladeData[HandID][BladeID].prev_hitnormal
		local dir = (vPos - _pos):GetNormalized()

		local dist = math.Round( (vPos - _pos):Length() , 0 )

		if dist > 0 then
			local idx = 0
			for i = 2, dist,2 do
				local trace = util.TraceHull( {
					start = start_pos,
					endpos = _pos + dir * i + aimDir * 5,
					mins = min,
					maxs = max,
					mask = MASK_SHOT_HULL,
					filter = { self, ply }
				} )

				debugoverlay.SweptBox( start_pos, _pos + dir * i + aimDir * 5, min, max, (start_pos -  (_pos + dir * i + aimDir * 5)):Angle(), 10, Color( 0, 100, 255 ) )

				if trace.Hit and not IsValid( trace.Entity ) then
					self:WallImpactEffects( trace.HitPos, trace.HitNormal, false )
				end

				if dmgActive then
					self:RegisterHitCL( trace.Entity, trace.HitPos, trace.HitNormal )
				end
			end
		else
			if dmgActive then
				self:RegisterHitCL( hitEnt, vPos, vDir )
			else
				if not IsValid( hitEnt ) then
					self:WallImpactEffects(vPos, vDir, true )
				end
			end
		end
	-- else
	-- 	if not IsValid( hitEnt ) and bHitWallthen
	-- 		if self:CanDoEffect( HandID, BladeID, self:IsMe() and 0.01 or 0.05 ) then
	-- 			self:WallImpactEffects(vPos, vDir, true )
	-- 		end
	-- 	end
	end

	self.BladeData[HandID][BladeID].prev_hitpos = vPos
	self.BladeData[HandID][BladeID].prev_hitnormal = vDir
end

function SWEP:DoBladeTrace( HandID, BladeID, pos, dir, length, width )
	if not self.BladeData[HandID][BladeID] then
		self.BladeData[HandID][BladeID] = {
			NextImpactFX = 0,
			BladePositions  = {},
			BladeNext = 0,
			HitWall = false,
		}
	end

	local ply = self:GetOwner()

	local max = Vector( width, width, width )
	local min = -max

	local trace = util.TraceHull( {
		start = pos,
		endpos = pos + dir * length,
		mins = min,
		maxs = max,
		mask = MASK_SHOT_HULL,
		filter =  {self, ply}
	} )

	if trace.Hit and trace.Fraction == 1 then
		trace.Fraction = 0
		trace.HitPos = pos
	end

	if IsValid( trace.Entity ) and not self:GetDMGActive() then
		if self:CanDoEffect( HandID, BladeID, 0.05 ) then
			self:ObjectImpactEffects( trace.HitPos, trace.HitNormal )
		end
	end

	if self:GetDMGActive() then
		debugoverlay.SweptBox( pos, pos + dir * length, min, max, dir:Angle(), 10, Color( 255, 0, 0 ) )
	else
		self.BladeData[HandID][BladeID].prev_hitpos = nil
		self.BladeData[HandID][BladeID].prev_hitnormal = nil
	end

	self:DoImpactEffects( HandID, BladeID, trace.Hit, trace.HitPos, trace.HitNormal, trace.Entity, ply, min, max )

	return trace
end

function SWEP:RegisterHitCL( target, Pos, Dir )
	if not IsValid( target ) then return end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	if ply ~= LocalPlayer() then return end

	local CurTime = CurTime()

	if (target.HitTime or 0) < CurTime then
		target.HitTime = CurTime + 0.15

		net.Start( "lscs_saberdamage" ) 
			net.WriteEntity( target )
			net.WriteVector( Pos )
			net.WriteVector( Dir )
		net.SendToServer()
	end
end
--addons/weapons_other/lua/weapons/weapon_policeshield/shared.lua:
AddCSLuaFile()


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Downloading content from workshop
---------------------------------------------------------------------------------------------------------------------------------------------
*/	

--if SERVER then resource.AddWorkshop("2441211404"); end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.shieldDamage = 10;
SWEP.bashReloadTime = 2;
SWEP.stunTime = 1;

SWEP.canBeDestroyedByDamage = false;
SWEP.onlyExplosionDamage = true;
SWEP.defaultHealth = 1000;

local deleteShieldsAfterDeath = true;

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Default SWEP config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Author = "Drover | Edit by Mickerd"
SWEP.Contact = "Discord: Mickerd#1593"
SWEP.Purpose = ""
SWEP.IconLetter = ""
SWEP.PrintName = "Einsatzschild"
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "physgun"
SWEP.HoldType ="physgun"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "AOCRP - Tools"

SWEP.ViewModel = Model("models/drover/shield.mdl");
SWEP.WorldModel = Model("models/drover/w_shield.mdl");



SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Initialize
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:Initialize()
    self:SetHoldType("physgun");
end



function SWEP:SetupShield()
	--if true then return end
	if CLIENT then return end;
	self.shieldProp = ents.Create("prop_physics");
	self.shieldProp:SetModel("models/hunter/blocks/cube075x2x025.mdl");
	
	self.shieldProp:Spawn(); 
	--self.shieldProp:SetModelScale(0,0);
	local phys = self.shieldProp:GetPhysicsObject();
	if not IsValid(phys) then
		self.Owner:ChatPrint("not valid physics object!");
		return;
	end
	phys:SetMass(5000);
	
	local nothand = false;
	local attach = self.Owner:LookupAttachment("anim_attachment_RH");
	if attach == nil or attach == 0 then
		--self.Owner:ChatPrint("Attachment 'anim_attachment_RH' not found for this player model!");
		attach = self.Owner:LookupAttachment("forward");
		nothand = true;
		if attach == nil or attach == 0 then
			self.Owner:ChatPrint("Attachment 'anim_attachment_RH' and 'forward' not found for this player model!");
			return;
		end
	end
	
	local up = -15;
	local forward = 15;
	local right = -8;
	
	local aforward = 20;
	local aup = 70;
	
	if nothand then
	    up = -20;
		forward = 17;
		aforward = 0;
		aup = 90;
	end
	local attachTable = self.Owner:GetAttachment(attach);
	self.shieldProp:SetPos(attachTable.Pos + attachTable.Ang:Up()*up + attachTable.Ang:Forward()*forward + attachTable.Ang:Right()*right);
	
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Forward(),110);
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Up(),0);
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Right(),105);
	self.shieldProp:SetAngles(attachTable.Ang);
	self.shieldProp:SetCollisionGroup( COLLISION_GROUP_WORLD );
	self.shieldProp:SetParent(self.Owner,attach);
	self.shieldProp:SetRenderMode( RENDERMODE_TRANSCOLOR )
	self.shieldProp:SetColor(Color(0,0,0,0))
	--self.shieldProp:SetModelScale(1,0);
	--self.shieldProp:SetNoDraw( true )
--[[ 	timer.Simple(0.2,function()
		if IsValid(self) and IsValid(self.shieldProp) then
			self.shieldProp:SetModelScale(1,0);
			net.Start("disable_shielddraw") net.WriteEntity(self) net.WriteEntity(self.shieldProp) net.Send(self.Owner);
		end
	end) ]]
	
	--self:SetupCollisionHelp()
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				CheckPlace
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:CheckPlace(pos)

	local mins = Vector( -10, -20, -3);
	local maxs = Vector( 20, 20, 40);
	local tr = {
		start = pos, 
		endpos = pos + Vector(0,0,5), 
		mins = mins, 
		maxs = maxs,
		filter = {self.Owner,self.shieldProp}
	}
	local hullTrace = util.TraceHull( tr );
	if ( hullTrace.Hit ) then
		return false;
	end	
	return true;	
end



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Shield bash
---------------------------------------------------------------------------------------------------------------------------------------------
*/


function SWEP:FreezeEnemy(ply)
	ply:Freeze(true);
	timer.Create('unfreezemeswep'..tostring(ply:EntIndex()),self.stunTime,1,function()
		if IsValid(ply) then ply:Freeze(false); end
	end)
end

function SWEP:FindEnemy()
	local mins = Vector( -10, -10, -3);
	local maxs = Vector( 10, 10, 40);
	local pos = self.Owner:GetPos() + self.Owner:GetForward()*35 + Vector(0,0,40);
	local tr = {
		start = pos, 
		endpos = pos + Vector(0,0,5), 
		mins = mins, 
		maxs = maxs,
		filter = {self.Owner,self.shieldProp,Entity(0)}
	}
	local hullTrace = util.TraceHull( tr );
	if ( hullTrace.Hit ) then
		if hullTrace.Entity:IsPlayer() then
			return hullTrace.Entity;
		end
		return false;
	end
	return false;
end


function SWEP:ShieldBash()
	local enemy = self:FindEnemy();
	if enemy == false then return end;
	enemy:TakeDamage(self.shieldDamage,self.Owner,self);
	self:FreezeEnemy(enemy);
	self.Owner:EmitSound(Sound("Flesh.ImpactHard"));
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Primary attack
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + self.bashReloadTime);
	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK );
	if CLIENT then return end;
	net.Start("shieldbash") net.WriteEntity(self.Owner) net.Broadcast();
	self:ShieldBash();
	
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Secondary attack / Deploy static shield
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:SecondaryAttack()
	if CLIENT then return end;

	for k, v in pairs(ents.GetAll()) do
		if v:GetClass() == "police_shield" then
			if v.Owner == self.Owner then
				v:Remove()
			end
		end
	end

	local ang = self.Owner:GetAngles()
	ang.p = 0;
	ang.r = 0;
	local pos = self.Owner:GetPos() + ang:Forward()*45 + Vector(0,0,10);
	local checkingPlace = self:CheckPlace(pos);
	if not checkingPlace then return end;
	local shieldEnt = ents.Create("police_shield");
	shieldEnt:SetPos(pos);
	local tempAngle = self.Owner:GetAngles();
	shieldEnt:SetAngles(Angle(0,tempAngle.y,0));
	
	shieldEnt.canBeDestroyedByDamage = self.canBeDestroyedByDamage;
	shieldEnt.onlyExplosionDamage = self.onlyExplosionDamage;
	shieldEnt.currentHealth = self.defaultHealth;
	
	shieldEnt:Spawn();
	shieldEnt.Owner = self.Owner;
--[[ 	self.Owner:Freeze(true);
	local ply = self.Owner;
	timer.Simple(0.2,function()
		if IsValid(ply) then
			ply:Freeze(false);			
		end
	end) ]]
	self:Remove();
end



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Network initialize && Client Receive
---------------------------------------------------------------------------------------------------------------------------------------------
*/

if SERVER then
	util.AddNetworkString("disable_shielddraw");
	util.AddNetworkString("shieldbash");
end

if CLIENT then
	net.Receive("disable_shielddraw",function()
		local weaponEntity = net.ReadEntity();
		local shieldProp = net.ReadEntity();
		if IsValid(shieldProp) then
			shieldProp:SetNoDraw(true);
		if IsValid(weaponEntity) then
			weaponEntity.shieldProp = shieldProp;
		end	
		end
	end)
	
	
net.Receive('shieldbash',function()
	local ply = net.ReadEntity();
	if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end;
	ply:AnimRestartGesture( GESTURE_SLOT_GRENADE,ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND, true );
end)
	
	
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Weapon dropped / replace world model
---------------------------------------------------------------------------------------------------------------------------------------------
*/
/*
 hook.Add("onDarkRPWeaponDropped","Police Shield",function(d2, ent, weapon)
	if weapon:GetClass() == "weapon_policeshield" then
		ent:SetModel("models/drover/w_shield.mdl");
	end
 end)
*/

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Player Death / delete our shields
---------------------------------------------------------------------------------------------------------------------------------------------
*/

-- Nicht mehr da

-- hook.Add("PlayerDeath","PlayerDeathDeleteShields",function(ply)
-- 	if deleteShieldsAfterDeath then
-- 		for k,v in pairs(ents.FindByClass("police_shield")) do
-- 			if v.Owner != nil and IsValid(v.Owner) and v.Owner == ply then
-- 				v:Remove();
-- 			end
-- 		end
-- 	end	
-- end)

hook.Add("OnPlayerChangedTeam","PlayerChangeTeamDeleteShields",function(ply)
    if deleteShieldsAfterDeath then
        for k,v in pairs(ents.FindByClass("police_shield")) do
            if v.Owner != nil and IsValid(v.Owner) and v.Owner == ply then
                v:Remove();
            end
        end
    end
end)

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Reload && Deploy && Holster && Drop && Remove
---------------------------------------------------------------------------------------------------------------------------------------------
*/


function SWEP:ViewModelDrawn(viewmodel)
	if IsValid(self.shieldProp) and !self.shieldProp:GetNoDraw() then
		self.shieldProp:SetNoDraw(true);
	end
end

if CLIENT then
	local WorldModel = ClientsideModel(SWEP.WorldModel)

	-- Settings...
	WorldModel:SetSkin(1)
	WorldModel:SetNoDraw(true)


	function SWEP:DrawWorldModel()
		local _Owner = self:GetOwner()

		if (IsValid(_Owner)) then
			-- Specify a good position
			local offsetVec = Vector(13,-2,-3)
			local offsetAng = Angle(161,110,7)
			
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end

			local matrix = _Owner:GetBoneMatrix(boneid)
			if !matrix then return end

			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)

			WorldModel:SetupBones()
		else
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
		end

		WorldModel:DrawModel()
	end
end

function SWEP:Reload()

end

function SWEP:Deploy()
	self:SetHoldType("physgun"); 
	self:SetupShield();
	return true
end

function SWEP:Holster()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end


function SWEP:OnDrop()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end

function SWEP:OnRemove()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end


--addons/aoc_nextbots/lua/weapons/weapon_summes_npcbase.lua:
AddCSLuaFile()

SWEP.PrintName = "#HL2_357"
SWEP.Spawnable = true
SWEP.Author = "Summe"
SWEP.Purpose = "Should only be used internally by advanced nextbots!"

SWEP.ViewModel = "models/weapons/v_357.mdl"
--SWEP.WorldModel = "models/kuro/sw_battlefront/weapons/e5c_blaster.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 3

SWEP.Delay_ = 0

SWEP.Primary = {
	Ammo = "SMG1",
	ClipSize = SWEP.ClipSize or 40,
	DefaultClip = 20,
	Automatic = true
}

SWEP.Secondary = {
	Ammo = "None",
	ClipSize = -1,
	DefaultClip = -1,
}

function SWEP:Initialize()
	self:SetHoldType("smg")
    self:SetClip1(self.ClipSize or 40)
end

function SWEP:CanPrimaryAttack()
	return CurTime() >= self:GetNextPrimaryFire() and self:Clip1() > 0
end

function SWEP:CanSecondaryAttack()
	return false
end

local MAX_TRACE_LENGTH = 56756

function SWEP:PrimaryAttack()
	if !self:CanPrimaryAttack() then return end

	local owner = self:GetOwner()

	local enemy = owner:GetEnemy()
    if not IsValid(enemy) then return end

	local headBone = enemy:LookupBone("ValveBiped.Bip01_Spine") or 0

	local weaponPos = owner:GetPos() + Vector(0, 0, 55)
	local enemyPos = enemy:GetBonePosition(headBone) or enemy:GetPos()

	local prof = (owner.Proficiency or 1) * 100

	enemyPos = Vector(math.random(enemyPos.x - prof, enemyPos.x + prof), math.random(enemyPos.y - prof, enemyPos.y + prof), enemyPos.z)

	math.randomseed(CurTime() * 1000)

	local direction = enemyPos - weaponPos

	local spread = self.Spread or 0

	self:FireBullets({
		Num = self.Bullets or 1,
		Src = weaponPos,
		Dir = direction:GetNormalized(),
		Spread = Vector(spread, spread, 0),
		Distance = MAX_TRACE_LENGTH,
		AmmoType = self:GetPrimaryAmmoType(),
		Damage = self.Damage or 10,
        DamageType = DMG_AIRBOAT,
		Attacker = owner,
		TracerName = self.Tracer or "rw_sw_laser_red",
		Callback = self.BulletCallback,
	})

	self:EmitSound(self.Sound or "w/e5.wav", 85, 100, 0.5, CHAN_WEAPON)

    self:TakePrimaryAmmo(1)
	self:SetNextPrimaryFire(CurTime() + self.NextShoot)
end

function SWEP:BulletCallback(tr, dmgInfo)
	local effect = EffectData()
	effect:SetEntity(self)
	effect:SetStart(tr.HitPos)
	effect:SetOrigin(tr.HitPos)
	effect:SetNormal(tr.HitNormal)
	effect:SetAngles(tr.HitNormal:Angle())
	effect:SetScale(1)
	effect:SetRadius(4)
	effect:SetMagnitude(1)
	effect:SetAttachment(1)
	util.Effect(self.ImpactEffect or "rw_sw_impact_red", effect)
end

function SWEP:SecondaryAttack()
	if !self:CanSecondaryAttack() then return end
end

function SWEP:Reload()
    self:GetOwner():PlayAnimation("shoot", true)
    self:EmitSound("weapons/357/357_reload1.wav", 85, 100, 0.5, CHAN_WEAPON)

    timer.Simple(2, function()
        self:SetClip1(self.Primary.ClipSize)
    end)
end

function SWEP:OnDrop()
    self:Remove()
end

function SWEP:Equip()
    if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
        self:Remove()
    end
end

if CLIENT then
	function SWEP:DrawWorldModel()

		if not self.WorldModel then return end

		if not IsValid(self.Model) then
			self.Model = ClientsideModel(self.WorldModel)
		end

		local _Owner = self:GetOwner()

		if (IsValid(_Owner)) then
            -- Specify a good position
			local offsetVec = Vector(5, -2.7, 0)
			local offsetAng = Angle(180, 180, 0)
			
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end

			local matrix = _Owner:GetBoneMatrix(boneid)
			if !matrix then return end

			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

			self.Model:SetPos(newPos)
			self.Model:SetAngles(newAng)

            self.Model:SetupBones()
		else
			self.Model:SetPos(self:GetPos())
			self.Model:SetAngles(self:GetAngles())
		end

		self.Model:DrawModel()
	end

	function SWEP:OnRemove()
		if not IsValid(self.Model) then return end
		self.Model:Remove()
	end
end
--lua/weapons/wood_baton/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Wood Baton"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Wood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(97, 69, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(97, 69, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(97, 69, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -36.235, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(97, 69, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 2
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Sand"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--gamemodes/starwarsrp/entities/entities/aoc_gtm_b1.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "GTM Droidenspawn"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP - Spawns"
ENT.Spawnable       = true


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate1x1.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(204,0,255))
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end
-- test

if CLIENT then

    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end
--gamemodes/starwarsrp/entities/entities/aoc_hackterminal.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Terminal"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true
ENT.Editable = true

function ENT:SetupDataTables()


	self:NetworkVar( "String", 0, "AnzeigeName", { KeyName = "AnzeigeName",	Edit = { type = "Text"  } } ) 
	self:NetworkVar( "Int", 0, "WaitTime", { KeyName = "WaitTime",	Edit = { type = "Int", mix = 1, max = 500  } } ) 

	if SERVER then
		self:SetAnzeigeName("Unbekanntes Terminal")
        self:SetWaitTime(10)
	end

end


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/starwars/syphadias/props/hoth_barrack/console_1.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


        self.CableTable = {
            [1] = {
                pos = Vector(2.032251, 6.022954, 26.184006),
                ang = Angle(58.160, 22.754, 72.184),
            },
            [2] = {
                pos = Vector(-2.647063, 7.137735, 12.956272),
                ang = Angle(24.138, 85.227, -90.413),
            },
            [3] = {
                pos = Vector(-8.424945, -3.761531, 29.757538),
                ang = Angle(75.625, 89.618, 88.550),
            },
            [4] = {
                pos = Vector(1.253638, -9.945827, 29.554203),
                ang = Angle(79.388, -84.360, -87.514),
            },
            [5] = {
                pos = Vector(10.601143, -0.763375, 31.281775),
                ang = Angle(87.242, -2.380, 101.274),
            },
        }


        local combination = AOCRP.Config.TerminalCombinations[math.random(#AOCRP.Config.TerminalCombinations)]
        for k, v in pairs(self.CableTable) do
            self.CableTable[k].col = combination[k][1]
            self.CableTable[k].cut = combination[k][2]
        end
    
        self.cables = {}

        self.CurrentDelay = 0


    end
    


 
 
    function ENT:Use( activator, caller )


        if self.Hacked then 
            AOCRP.HUD:Notify(activator, "Dieses Terminal wurde bereits gehackt!", 2)
            return 
        end 

        if self.CurrentDelay > CurTime() then
            local waitTime = math.Round(self.CurrentDelay - CurTime())
            AOCRP.HUD:Notify(activator, "Du musst noch " .. waitTime .. "s warten, bevor du dieses Terminal erneut hacken kannst!", 2)
            return
        end

        if !self.HackingActive then

            self.HackingActive = true 

            activator:ConCommand("say /me öffnet die Panele des Terminals und zieht die Kabel hervor.")

            self.Hacker = activator

            for number,data in pairs(self.CableTable) do
                local ent = ents.Create("joe_cable")
                ent:SetPos(self:LocalToWorld(data.pos))
                ent:SetAngles(self:GetAngles() - data.ang)
                ent:SetColor(BombSystem.colors[data.col])
                ent.data = {pos = data.pos, ang = data.ang}
                ent.cut = data.cut
                ent.bomb = self
                ent:Spawn()
                ent:Activate()
                ent:SetUnPresetColor(data.col)
                self.cables[ent] = true
                constraint.NoCollide(self, ent, 0, 0)
            end
            
        else

            self:RemoveCables()
            activator:ConCommand("say /me packt die Kabel wieder rein und schließt die Panele.")
        end


    end

    function ENT:RemoveCables()
        for v,_ in pairs(self.cables) do
            if not IsValid(v) then continue end
            v:Remove()
        end
        self.cables = {}

        self.HackingActive = false 

        self.curexpected = nil
    end


    function ENT:OnRemove()
        self:RemoveCables()
    end

    function ENT:Think()
        if self.HackingActive then
            for v,_ in pairs(self.cables) do
                if not IsValid(v) then continue end
                v:SetPos(self:LocalToWorld(v.data.pos))
                v:SetAngles(self:GetAngles() - v.data.ang)
            end
        end
    end



    function ENT:NotCorrect()
        self:RemoveCables()
        self:EmitSound("everfall/equipment/squad_shield/break/gadgets_burstshieldundeploysparks_var_01_0"..math.random(9)..".mp3")

        self.CurrentDelay = CurTime() + self:GetWaitTime()
    end

    function ENT:Correct()
        self.Hacked = true
        self:EmitSound("weapons/slam/mine_mode.wav")

        if IsValid(self.Hacker) then

            self.Hacker:addMoney(5, "Hacken eines Terminals")
        end

        AOCRP.Chat:TeamPrint( self:GetAnzeigeName() .. " wurde erfolgreich gehackt. ")
        AOCRP.Chat:GlobalPrint("*** " .. self:GetAnzeigeName() .. " wurde erfolgreich gehackt.")

        hook.Run("AOCRP_TerminalHacked", self, self.Hacker)
    end

    function ENT:CableCut(cable)
		if cable.cut == false then
			self:NotCorrect()
		else
			if isnumber(cable.cut) then
				self.curexpected = self.curexpected or 1
				if cable.cut == self.curexpected then
					for v,_ in pairs(self.cables) do
						if not v.cut or not isnumber(v.cut) then continue end
						if v.cut > self.curexpected then
							self.curexpected = self.curexpected + 1
							return
						end
					end
					self:Correct()
				else
					self:NotCorrect()
				end
			else
				self:Correct()
			end
		end
    end

end


--addons/arccw_base_modified/lua/entities/arccw_ammo.lua:
AddCSLuaFile()

ENT.Type                     = "anim"
ENT.Base                     = "base_entity"
ENT.RenderGroup              = RENDERGROUP_TRANSLUCENT

ENT.PrintName                = "Base Ammo"
ENT.Category                 = "ArcCW - Ammo"
ENT.ArcCW_Ammo = true

ENT.Spawnable                = false
ENT.Model                    = "models/items/sniper_round_box.mdl"
ENT.MaxHealth = 40
ENT.Scale = 1

ENT.AmmoType = "SniperPenetratedRound"
ENT.AmmoCount = 5
ENT.DetonationDamage = 10 -- Per-round damage
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/arccw/glock18/glock18-1.wav" -- string or table

ENT.ShellModel = "models/shells/shell_9mm.mdl"
ENT.ShellScale = 1.5

ENT.ResistanceMult = {
    [DMG_BURN] = 3,
    [DMG_DIRECT] = 3, -- This is also fire
    [DMG_BLAST] = 2,
    [DMG_BULLET] = 0.5,
    [DMG_BUCKSHOT] = 0.5,
    [DMG_CLUB] = 0.25,
    [DMG_SLASH] = 0.25,
    [DMG_CRUSH] = 0.25,
    [DMG_NERVEGAS] = 0,
    [DMG_POISON] = 0
}

function ENT:Initialize()
    self:SetModel(self.Model)
    self:SetHealth(math.max(math.ceil(self.MaxHealth * ArcCW.ConVars["mult_ammohealth"]:GetFloat()), 1))
    self.AmmoCount = math.max(math.ceil(self.AmmoCount * ArcCW.ConVars["mult_ammoamount"]:GetFloat(), 1))
    self.MaxAmmoCount = self.AmmoCount

    if engine.ActiveGamemode() == "terrortown" and ArcCW.TTTReplaceTable then
        self.AmmoType = ArcCW.TTTReplaceTable[self.AmmoType] or self.AmmoType
    end

    if self.Scale != 1 then
        self:SetModelScale(self.Scale)
    end

    if self:SkinCount() > 1 and math.random() <= ArcCW.ConVars["ammo_rareskin"]:GetFloat() then
        self:SetSkin(math.random(1, self:SkinCount() - 1))
    end

    if SERVER then

        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
        self:SetUseType(SIMPLE_USE)
        self:PhysWake()

        self:SetTrigger(true) -- Enables Touch() to be called even when not colliding
        if ArcCW.ConVars["ammo_largetrigger"]:GetBool() then
            self:UseTriggerBounds(true, 24)
        end
    end
end

-- Adapted from TTT's ammo - we don't use it otherwise
function ENT:TTT_PlayerCanPickup(ply)
    if ply == self:GetOwner() then return false end

    local result = hook.Call("TTTCanPickupAmmo", nil, ply, self)
    if result then
        return result
    end

    local ent = self
    local phys = ent:GetPhysicsObject()
    local spos = phys:IsValid() and phys:GetPos() or ent:OBBCenter()
    local epos = ply:GetShootPos()

    local tr = util.TraceLine({start = spos, endpos = epos, filter = {ply, ent}, mask = MASK_SOLID})

    -- can pickup if trace was not stopped
    return tr.Fraction == 1.0
end

-- Ditto - unused outside of TTT
function ENT:TTT_CheckForWeapon(ply)
    --[[]
    if !self.CachedWeapons then
        local tbl = {}
        for k,v in pairs(weapons.GetList()) do
            if v and v.Primary.Ammo == self.AmmoType then
                tbl[v.ClassName] = true -- WEPS.GetClass(v)
            end
        end
        self.CachedWeapons = tbl
    end
    ]]

    -- Why does TTT not iterate over the player's weapons? This is obviously faster
    for _, wep in ipairs(ply:GetWeapons()) do
        --if self.CachedWeapons[wep:GetClass()] then return true end
        -- Perform check for overwritten ammo types (attachments) and UBGLs
        if wep.ArcCW and
                (wep:GetBuff_Override("UBGL_Ammo") == self.AmmoType
                or wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo) == self.AmmoType
                or wep:GetBuff_Override("Akimbo_Ammo") == self.AmmoType) then
            return true
        end
    end
    return false
end

function ENT:ApplyAmmo(ply)
    if self.USED then return end
    if engine.ActiveGamemode() == "terrortown" then
        -- Stupid checks mate... but we'll play along unless an override exists
        if !self.IgnoreTTTChecks and !self:TTT_PlayerCanPickup(ply) or !self:TTT_CheckForWeapon(ply) then return end

        local giveCount = math.min(self.AmmoCount, ArcCW.TTTAmmoToClipMax[string.lower(self.AmmoType)] - ply:GetAmmoCount(self.AmmoType))
        if giveCount <= 0 then return end

        self.AmmoCount = self.AmmoCount - giveCount
        ply:GiveAmmo(giveCount, self.AmmoType)

        -- Ugly hack to let client update ammo count
        -- Why not just use NWInts or NetworkVars to begin with? Good question!
        self:SetNWInt("truecount", self.AmmoCount)

        if self.AmmoCount <= 0 then
            self.USED = true
            self:Remove()
        end
    else
        self.USED = true -- Prevent multiple uses
        ply:GiveAmmo(self.AmmoCount, self.AmmoType)
        self:Remove()
    end
end

function ENT:DetonateRound()
    local count = math.Clamp(math.random(1, self.MaxAmmoCount / 5), 1, self.AmmoCount)
    -- Default function
    self:FireBullets({
        Attacker = self.Burner,
        Damage = self.DetonationDamage,
        Force = self.DetonationDamage / 5,
        Num = count,
        AmmoType = self.AmmoType,
        Src = self:WorldSpaceCenter(),
        Dir = self:GetUp(),
        Spread = Vector(math.pi * 2, math.pi * 2, 0),
        IgnoreEntity = self
    })
    self.AmmoCount = self.AmmoCount - count

    self:GetPhysicsObject():AddVelocity(VectorRand() * math.random(30, 50) * self:GetPhysicsObject():GetMass())
    self:GetPhysicsObject():AddAngleVelocity(VectorRand() * math.random(60, 300))

    if self.DetonationSound then
        self:EmitSound(istable(self.DetonationSound) and table.Random(self.DetonationSound) or self.DetonationSound)
    end
end

function ENT:Detonate(wet, attacker)
    if wet then
        self:FireBullets({
            Attacker = attacker,
            Damage = self.DetonationDamage,
            Force = self.DetonationDamage / 5,
            Num = math.max(self.AmmoCount, 50),
            AmmoType = self.AmmoType,
            Src = self:WorldSpaceCenter(),
            Dir = self:GetUp(),
            Spread = Vector(math.pi * 2, math.pi * 2, 0),
            IgnoreEntity = self
        })
    end

    local e = EffectData()
    e:SetOrigin(self:GetPos())
    util.Effect("Explosion", e)

    util.BlastDamage(self, attacker, self:GetPos(), self.DetonationRadius, self.DetonationDamage * (wet and 0.5 or 1))
    self:Remove()
end

if SERVER then

    function ENT:Use(ply)
        if !ply:IsPlayer() then return end
        self:ApplyAmmo(ply)
    end


    function ENT:Touch(ply)
        if !ply:IsPlayer() or !ArcCW.ConVars["ammo_autopickup"]:GetBool() then return end
        self:ApplyAmmo(ply)
    end

    function ENT:Burn(attacker)
        self.Burning = true
        self.Burner = attacker
        self:Ignite(30)
        self:SetHealth(-1)
    end

    function ENT:OnTakeDamage(dmginfo)

        if self:Health() <= 0 or self.USED then return end

        --self:TakePhysicsDamage(dmginfo)
        self:SetHealth(self:Health() - dmginfo:GetDamage())

        if self:Health() <= 0 then

            self.USED = true

            local cvar = ArcCW.ConVars["ammo_detonationmode"]:GetInt()

            if cvar == -1 or (!ArcCW.ConVars["ammo_chaindet"]:GetBool() and dmginfo:GetInflictor().ArcCW_Ammo) or self.DetonationDamage <= 0 then
                -- Go quietly
                local e = EffectData()
                e:SetOrigin(self:GetPos())
                e:SetMagnitude(8)
                e:SetScale(2)
                util.Effect("Sparks", e)
                self:EmitSound("physics/cardboard/cardboard_box_break2.wav", 80, 120)
                self:Remove()
            elseif cvar == 2 and (math.random() <= 0.25 or dmginfo:IsDamageType(DMG_BURN)) then
                -- Fancy ammobox burning
                self:Burn(dmginfo:GetAttacker())
            else
                -- Plain old explosion
                self:Detonate(cvar >= 1, dmginfo:GetAttacker())
            end
        end

    end

    function ENT:Think()
        if self.Burning then

            if self.AmmoCount <= 0 then
                self:Detonate(false, IsValid(self.Burner) and self.Burner or self)
            else
                self:DetonateRound()
            end

            self:NextThink(CurTime() + math.random() * 0.3 + 0.2)
            return true
        end
    end

    -- Do it during the hook so that hit damage numbers show up properly (yes, I am _that_ pedantic)
    hook.Add("EntityTakeDamage", "ArcCW_Ammo", function(ent, dmginfo)
        if ent.ArcCW_Ammo then
            if ArcCW.ConVars["mult_ammohealth"]:GetFloat() < 0 then
                dmginfo:ScaleDamage(0)
            elseif ent.ResistanceMult then
                -- Only apply one multiplier, and prioritize larger ones
                for k, v in SortedPairsByValue(ent.ResistanceMult, true) do if dmginfo:IsDamageType(k) then dmginfo:ScaleDamage(v) break end end
            end
        end
    end)

elseif CLIENT then

    function ENT:DrawTranslucent()
        self:Draw()
    end

    function ENT:Draw()
        self:DrawModel()

        local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
        if cvar2d3d == 0 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity != self) then return end

        if (EyePos() - self:GetPos()):LengthSqr() <= 262144 then -- 512^2
            local ang = LocalPlayer():EyeAngles()

            ang:RotateAroundAxis(ang:Forward(), 180)
            ang:RotateAroundAxis(ang:Right(), 90)
            ang:RotateAroundAxis(ang:Up(), 90)

            cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, (self:OBBMaxs().z - self:OBBMins().z) * 0.5 + 8) , ang, 0.1)
                surface.SetFont("ArcCW_32_Unscaled")

                local w = surface.GetTextSize(self.PrintName)

                surface.SetTextPos(-w / 2 + 2, 2)
                surface.SetTextColor(0, 0, 0, 150)
                surface.DrawText(self.PrintName)

                surface.SetTextPos(-w / 2, 0)
                surface.SetTextColor(255, 255, 255, 255)
                surface.DrawText(self.PrintName)

                local ammo = self:GetNWInt("truecount", -1) != -1 and self:GetNWInt("truecount", -1) or self.AmmoCount
                if ammo then
                    w = surface.GetTextSize("×" .. ammo)

                    surface.SetTextColor(0, 0, 0, 150)
                    surface.SetTextPos(-w / 2 + 2, 27)
                    surface.DrawText("×" .. ammo)

                    surface.SetTextColor(255, 255, 255, 255)
                    surface.SetTextPos(-w / 2, 25)
                    surface.DrawText("×" .. ammo)
                end
            cam.End3D2D()
        end
    end

end
--addons/arccw_weapons/lua/entities/arccw_new_projectile.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "Base Projectile"

ENT.Spawnable 			= false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/weapons/w_missile_launch.mdl"
ENT.Ticks = 0
ENT.FuseTime = 0.1
ENT.Defused = false
ENT.BoxSize = Vector(2, 2, 2)
ENT.SmokeTrail = true

ENT.Drag = true
ENT.Gravity = true
ENT.DragCoefficient = 0.25
ENT.Boost = 0
ENT.Lift = 0
ENT.GunshipWorkaround = true
ENT.HelicopterWorkaround = true

ENT.Damage = 100
ENT.Radius = 300
ENT.ImpactDamage = 400

if SERVER then
    local gunship = {["npc_combinegunship"] = true, ["npc_combinedropship"] = true}

    function ENT:Initialize()
        local pb_vert = self.BoxSize[1]
        local pb_hor = self.BoxSize[2]
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableDrag(self.Drag)
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:EnableGravity(self.Gravity)
            phys:SetMass(5)
            phys:SetBuoyancyRatio(0.4)
        end

        self.SpawnTime = CurTime()

        if self.SmokeTrail then
            util.SpriteTrail(self, 0, Color( 255 , 255 , 255 ), false, 6, 6, 0.5, 1 / (6 + 6) * 0.5, "particle/particle_smokegrenade")
        end
    end

    function ENT:Think()
        if self.Defused or self:WaterLevel() > 0 then return end

        self:GetPhysicsObject():AddVelocity(Vector(0, 0, self.Lift) + self:GetForward() * self.Boost)

        -- Gunships have no physics collection, periodically trace to try and blow up in their face
        if self.GunshipWorkaround and (self.GunshipCheck or 0 < CurTime()) then
            self.GunshipCheck = CurTime() + 0.33
            local tr = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() + self:GetVelocity(),
                filter = self,
                mask = MASK_SHOT
            })
            if IsValid(tr.Entity) and gunship[tr.Entity:GetClass()] then
                self:SetPos(tr.HitPos)
                self:Detonate()
            end
        end
    end

    function ENT:Detonate()
        if !self:IsValid() then return end
        if self.Defused then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() > 0 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
            --self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            util.Effect( "Explosion", effectdata)
            --self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
        end

        util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), self.Radius, self.DamageOverride or self.Damage)

        if SERVER then
            self:FireBullets({
                Attacker = self,
                Damage = 0,
                Tracer = 0,
                Distance = 256,
                Dir = self.HitVelocity or self:GetVelocity(),
                Src = self:GetPos(),
                Callback = function(att, tr, dmg)
                    util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
                end
            })
        end
        self.Defused = true
        self:Remove()
    end

    function ENT:PhysicsCollide(colData, physobj)
        if !self:IsValid() then return end

        if self.FuseTime > 0 and CurTime() - self.SpawnTime < self.FuseTime then
            if IsValid(colData.HitEntity) then
                local v = colData.OurOldVelocity:Length() ^ 0.5
                local dmg = DamageInfo()
                dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
                dmg:SetInflictor(self)
                dmg:SetDamageType(DMG_CRUSH)
                dmg:SetDamage(v)
                dmg:SetDamagePosition(colData.HitPos)
                dmg:SetDamageForce(colData.OurOldVelocity)
                colData.HitEntity:TakeDamageInfo(dmg)
                self:EmitSound("weapons/rpg/shotdown.wav", 80, math.random(90, 110))
            end
            self:Defuse()
            return
        end

        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        -- simulate AP damage on vehicles, mainly simfphys
        local tgt = colData.HitEntity
        while IsValid(tgt) do
            if tgt.GetParent and IsValid(tgt:GetParent()) then
                tgt = tgt:GetParent()
            elseif tgt.GetBaseEnt and IsValid(tgt:GetBaseEnt()) then
                tgt = tgt:GetBaseEnt()
            else
                break
            end
        end

        if self.ImpactDamage and IsValid(tgt) then
            local dmg = DamageInfo()
            dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
            dmg:SetInflictor(self)
            dmg:SetDamageType(DMG_BLAST) -- helicopters
            dmg:SetDamage(self.ImpactDamage)
            dmg:SetDamagePosition(colData.HitPos)
            dmg:SetDamageForce(self:GetForward() * self.ImpactDamage)

            if IsValid(tgt:GetOwner()) and tgt:GetOwner():GetClass() == "npc_helicopter" then
                tgt = tgt:GetOwner()
                dmg:ScaleDamage(0.1)
                dmg:SetDamageType(DMG_BLAST + DMG_AIRBOAT)
                dmg:SetDamageForce(self:GetForward() * 100)
            end

            tgt:TakeDamageInfo(dmg)
        end

        self.HitPos = colData.HitPos
        self.HitVelocity = colData.OurOldVelocity
        self:Detonate()
    end

    -- Combine Helicopters are hard-coded to only take DMG_AIRBOAT damage
    hook.Add("EntityTakeDamage", "ArcCW_HelicopterWorkaround", function(ent, dmginfo)
        if IsValid(ent:GetOwner()) and ent:GetOwner():GetClass() == "npc_helicopter" then ent = ent:GetOwner() end
        if ent:GetClass() == "npc_helicopter" and dmginfo:GetInflictor().HelicopterWorkaround then
            dmginfo:SetDamageType(bit.bor(dmginfo:GetDamageType(), DMG_AIRBOAT))
        end
    end)
end

function ENT:Defuse()
    self.Defused = true
    SafeRemoveEntityDelayed(self, 5)
end

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/arccw_rocket_nofuze.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "arccw_new_projectile"
ENT.PrintName 			= "No Fuze"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/w_missile_launch.mdl"
ENT.BoxSize = Vector(8, 4, 1)

ENT.Damage = 300
ENT.Radius = 300
ENT.ImpactDamage = 3000

ENT.FuseTime = 0
ENT.Boost = 1500
ENT.Lift = 80
ENT.DragCoefficient = 0.1
--addons/arccw_weapons/lua/entities/arccw_thr_smoke.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Fragnade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/weapons/tfa_starwars/w_smoke.mdl"
ENT.FuseTime = 3.5
ENT.ArmTime = 0
ENT.Armed = true
ENT.ImpactFuse = false
ENT.TrailColor = Color(48, 48, 48)
ENT.TrailTexture = "sprites/bluelaser1" -- this is exactly the one hl2 frag uses. Why blue? idk blame gaben

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()

        self.Trail = util.SpriteTrail(self, 0, self.TrailColor, false, 4, 0, 0.5, 4, self.TrailTexture or "sprites/bluelaser1")
        if IsValid(self.Trail) then
            self.Trail:SetRenderMode(RENDERMODE_TRANSADD)
            self.Trail:SetRenderFX(kRenderFxNone)
        end

        timer.Simple(0, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end
    util.PrecacheSound("misc/BEEPTimer_Anticipation Beeps_02.wav")

    -- Play the sound when the entity is spawned
    self:EmitSound("misc/BEEPTimer_Anticipation Beeps_02.wav")
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/grenades/wpn_fraggrenade_1p_hardsurface_bounce_01_lr_v" .. math.random(1,2) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/grenades/grenade_bounce_2ch_v2_0" .. math.random(1,3) .. ".wav"))
        end

        if (CurTime() - self.SpawnTime >= self.ArmTime) and self.ImpactFuse then
            self:Detonate()
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if !self:IsValid() or self:WaterLevel() > 2 then return end
    self:EmitSound("arccw_go/smokegrenade/smoke_emit.wav", 90, 100, 1, CHAN_AUTO)

    local cloud = ents.Create( "arccw_smoke" )

    if !IsValid(cloud) then return end

    cloud:SetPos(self:GetPos())
    cloud:Spawn()

    self:Remove()
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--lua/entities/arccw_uc_napalm.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Fire Particle"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/Items/AR2_Grenade.mdl"

ENT.FireTime = 30
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE
ENT.Armed = false

ENT.NextDamageTick = 0
ENT.NextStickTick = 0

ENT.Ticks = 0

ENT.ArcCW_Killable = false

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        local maxs = Vector(1, 1, 1)
        local mins = -maxs
        self:PhysicsInitBox(mins, maxs)
        self:DrawShadow( false )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:Detonate()

        self.FireTime = math.Rand(self.FireTime - 1, self.FireTime + 1)
    end
end

local fired = {
    "sprites/flamelet1",
    "sprites/flamelet2",
    "sprites/flamelet3",
    "sprites/flamelet4",
    "sprites/flamelet5",
}
local function GetFireParticle()
    return fired[math.random(#fired)]
end

function ENT:Think()
    if !self.SpawnTime then self.SpawnTime = CurTime() end

    if CLIENT then
        local emitter = ParticleEmitter(self:GetPos())

        if !self:IsValid() or self:WaterLevel() > 2 then return end
        if !IsValid(emitter) then return end

        if math.random(1, 100) < 10 then
            local fire = emitter:Add(GetFireParticle(), self:GetPos() + (VectorRand() * 16))
            fire:SetVelocity( VectorRand() * 500 * VectorRand() )
            fire:SetGravity( Vector(0, 0, 100) )
            fire:SetDieTime( math.Rand(0.5, 0.75) )
            fire:SetStartAlpha( 255 )
            fire:SetEndAlpha( 0 )
            fire:SetStartSize( 15 )
            fire:SetEndSize( 100 )
            fire:SetRoll( math.Rand(-180, 180) )
            fire:SetRollDelta( math.Rand(-0.2,0.2) )
            fire:SetColor( 255, 255, 255 )
            fire:SetAirResistance( 150 )
            fire:SetPos( self:GetPos() )
            fire:SetLighting( false )
            fire:SetCollide(true)
            fire:SetBounce(0.75)
            fire:SetNextThink( CurTime() + FrameTime() )
            fire:SetThinkFunction( function(pa)
                if !pa then return end
                local col1 = Color(255, 255, 175)
                local col2 = Color(0, 0, 0)

                local col3 = col1
                local d = pa:GetLifeTime() / pa:GetDieTime()
                col3.r = Lerp(d, col1.r, col2.r)
                col3.g = Lerp(d, col1.g, col2.g)
                col3.b = Lerp(d, col1.b, col2.b)

                pa:SetColor(col3.r, col3.g, col3.b)
                pa:SetNextThink( CurTime() + FrameTime() )
            end )
        end

        if math.random(1, 100) < 15 then
            local fire = emitter:Add("particles/smokey", self:GetPos())
                fire:SetVelocity( VectorRand() * 100 )
                fire:SetGravity( Vector(0, 0, 1000) )
                fire:SetDieTime( math.Rand(0.5, 2) )
                fire:SetStartAlpha( 200 )
                fire:SetEndAlpha( 0 )
                fire:SetStartSize( 10 )
                fire:SetEndSize( 128 )
                fire:SetRoll( math.Rand(-180, 180) )
                fire:SetRollDelta( math.Rand(-0.2,0.2) )
                fire:SetColor( 255, 255, 255 )
                fire:SetAirResistance( 150 )
                fire:SetPos( self:GetPos() )
                fire:SetLighting( false )
                fire:SetCollide(true)
                fire:SetBounce(0.75)
                fire:SetNextThink( CurTime() + FrameTime() )
                fire:SetThinkFunction( function(pa)
                    if !pa then return end
                    local col1 = Color(150, 75, 0)
                    local col2 = Color(50, 50, 50)

                    local col3 = col1
                    local d = pa:GetLifeTime() / pa:GetDieTime()
                    col3.r = Lerp(d, col1.r, col2.r)
                    col3.g = Lerp(d, col1.g, col2.g)
                    col3.b = Lerp(d, col1.b, col2.b)

                    pa:SetColor(col3.r, col3.g, col3.b)
                    pa:SetNextThink( CurTime() + FrameTime() )
                end )
        end

        emitter:Finish()

        self.Ticks = self.Ticks + 1
    else

        if self.NextDamageTick > CurTime() then return end

        if self.Stuck and (!IsValid(self:GetParent()) or (self:GetParent():IsPlayer() and !self:GetParent():Alive())) then
            self:SetParent(NULL)
            self:SetMoveType( MOVETYPE_VPHYSICS )
            self:SetSolid( SOLID_VPHYSICS )
            self.Stuck = false
            local maxs = Vector(1, 1, 1)
            local mins = -maxs
            self:PhysicsInitBox(mins, maxs)
            local phys = self:GetPhysicsObject()
            if phys:IsValid() then
                phys:Wake()
            end
            return
        end

        local dmg = DamageInfo()
        dmg:SetDamageType(DMG_BURN)
        dmg:SetDamage(math.random() * 2 + 1)
        dmg:SetInflictor(self)
        dmg:SetAttacker(self:GetOwner())

        if self:WaterLevel() > 2 then
            if math.random() <= 0.075 then self:Remove() return end
            dmg:SetDamage(1)
        end

        util.BlastDamageInfo(dmg, self:GetPos(), 150)

        self.NextDamageTick = CurTime() + 0.15
        if !self.Stuck and self.NextStickTick < CurTime() then
            self.NextStickTick = CurTime() + 0.5
            if math.random() <= 0.25 then
                for _, e in pairs(ents.FindInSphere(self:GetPos(), 96)) do
                    if e:IsNPC() or e:IsNextBot() or e:IsVehicle() or (e:IsPlayer() and e:Alive()) or (simfphys and simfphys.IsCar(e)) then
                        self.Stuck = true
                        timer.Simple(0, function()
                            -- we commit a mild amount of war crimes
                            self:SetSolid(SOLID_NONE)
                            self:SetMoveType(MOVETYPE_NONE)
                            self:SetParent(e)
                            local min, max = e:WorldSpaceAABB()
                            self:SetPos(min + (max - min) * math.random())
                        end)
                        break
                    end
                end
            end
        end


        if self.SpawnTime + self.FireTime <= CurTime() then self:Remove() return end
    end
end

function ENT:OnRemove()
    if !self.FireSound then return end
    self.FireSound:Stop()
end

function ENT:Detonate()
    if !self:IsValid() then return end

    self.Armed = true

    if self.Order and self.Order != 1 then return end

    self.FireSound = CreateSound(self, "arccw_go/molotov/fire_loop_1.wav")
    self.FireSound:Play()

    self.FireSound:ChangePitch(80, self.FireTime)

    timer.Simple(self.FireTime - 1, function()
        if !IsValid(self) then return end

        self.FireSound:ChangeVolume(0, 1)
    end)

    timer.Simple(self.FireTime, function()
        if !IsValid(self) then return end

        self:Remove()
    end)
end


function ENT:PhysicsCollide(data, physobj)
    if self.Stuck then return end

    local tgt = data.HitEntity
    if !tgt:IsWorld() then
        timer.Simple(0, function()
            -- we commit a mild amount of war crimes
            self:SetSolid(SOLID_NONE)
            self:SetMoveType(MOVETYPE_NONE)
            self:SetParent(tgt)
        end)
        self.Stuck = true
    else
        timer.Simple(0, function()
            -- we commit a mild amount of war crimes
            self:SetSolid(SOLID_NONE)
            self:SetMoveType(MOVETYPE_NONE)
        end)
    end
end

function ENT:Draw()
    -- cam.Start3D() -- Start the 3D function so we can draw onto the screen.
    --     render.SetMaterial( GetFireParticle() ) -- Tell render what material we want, in this case the flash from the gravgun
    --     render.DrawSprite( self:GetPos(), math.random(200, 250), math.random(200, 250), Color(255, 255, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    -- cam.End3D()
end
--lua/entities/arccw_uc_riflegrenade.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Base Rifle Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false

ENT.Ticks = 0
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE


-- Intentionally not ENT.Damage since ArcCW base overwrites it with weapon damage (for some reason)
ENT.GrenadeDamage = false
ENT.GrenadeRadius = 0
ENT.FuseTime = 10
ENT.DragCoefficient = 1
ENT.DetonateOnImpact = true

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.ExplosionEffect = true
ENT.Scorch = "Scorch"
ENT.SmokeTrail = true

local path = "arccw_uc/common/"
local path1 = "arccw_uc/common/"
ENT.ExplosionSounds = {path .. "explosion-close-01.ogg", path .. "explosion-close-02.ogg"}
ENT.DebrisSounds = {path1 .. "debris-01.ogg", path1 .. "debris-02.ogg", path1 .. "debris-03.ogg", path1 .. "debris-04.ogg", path1 .. "debris-05.ogg"}


if SERVER then
    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox(Vector(-pb_vert, -pb_hor, -pb_hor), Vector(pb_vert, pb_hor, pb_hor))
        local phys = self:GetPhysicsObject()

        if phys:IsValid() then
            phys:Wake()
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:SetBuoyancyRatio(0.1)
        end

        self.SpawnTime = CurTime()
    end

    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end
else
    function ENT:Think()
        if self.SmokeTrail then
            if self.Ticks % 5 == 0 then
                local emitter = ParticleEmitter(self:GetPos())
                if not self:IsValid() or self:WaterLevel() > 2 then return end
                if not IsValid(emitter) then return end
                local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
                smoke:SetVelocity(VectorRand() * 25)
                smoke:SetGravity(Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)))
                smoke:SetDieTime(math.Rand(1.5, 2.0))
                smoke:SetStartAlpha(255)
                smoke:SetEndAlpha(0)
                smoke:SetStartSize(0)
                smoke:SetEndSize(100)
                smoke:SetRoll(math.Rand(-180, 180))
                smoke:SetRollDelta(math.Rand(-0.2, 0.2))
                smoke:SetColor(20, 20, 20)
                smoke:SetAirResistance(5)
                smoke:SetPos(self:GetPos())
                smoke:SetLighting(false)
                emitter:Finish()
            end
            self.Ticks = self.Ticks + 1
        end
    end
end

-- overwrite to do special explosion things
function ENT:DoDetonation()
    local attacker = IsValid(self:GetOwner()) and self:GetOwner() or self
    util.BlastDamage(self, attacker, self:GetPos(), self.GrenadeRadius, self.GrenadeDamage or self.Damage or 0)
end

function ENT:DoImpact(ent)
    local attacker = IsValid(self:GetOwner()) and self:GetOwner() or self
    local dmg = DamageInfo()
    dmg:SetAttacker(attacker)
    dmg:SetInflictor(self)
    dmg:SetDamage(100)
    dmg:SetDamageType(DMG_CRUSH)
    dmg:SetDamageForce(self.GrenadeDir * 5000)
    dmg:SetDamagePosition(self:GetPos())
    ent:TakeDamageInfo(dmg)
end

function ENT:Detonate()
    if not self:IsValid() or self.BOOM then return end
    self.BOOM = true

    if self.ExplosionEffect then
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            -- util.Effect("Explosion", effectdata)

            -- explosion_HE_m79_fas2
            -- explosion_he_grenade_fas2
            -- explosion_HE_claymore_fas2
            -- explosion_grenade_fas2

            self:EmitSound(self.ExplosionSounds[math.random(1,#self.ExplosionSounds)], 125, 100, 1, CHAN_AUTO)
            ParticleEffect("explosion_HE_m79_fas2", self:GetPos(), Angle(-90, 0, 0))

            --self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)

            -- Where is the sound zenith ? ???
        end

        util.ScreenShake(self:GetPos(), 25, 4, 0.75, self.GrenadeRadius * 4)

        if self.GrenadePos == nil then
            self.GrenadePos = self:GetPos()
        end
        if self.GrenadeDir == nil then
            self.GrenadeDir = self:GetVelocity():GetNormalized()
        end

        local trace = util.TraceLine({
            start = self.GrenadePos,
            endpos = self.GrenadePos + self.GrenadeDir * 4,
            mask = MASK_SOLID_BRUSHONLY
        })
        if trace.Hit then
            self:EmitSound(self.DebrisSounds[math.random(1,#self.DebrisSounds)], 85, 100, 1, CHAN_AUTO)
        end
    end

    self:DoDetonation()

    if self.Scorch then
        util.Decal(self.Scorch, self.GrenadePos, self.GrenadePos + self.GrenadeDir * 4, self)
    end

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self.GrenadeDir = colData.OurOldVelocity:GetNormalized()
    self.GrenadePos = colData.HitPos

    self:DoImpact(colData.HitEntity)

    if self.DetonateOnImpact then
        self:Detonate()
    else
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())
        effectdata:SetMagnitude(2)
        effectdata:SetScale(1)
        effectdata:SetRadius(2)
        effectdata:SetNormal(self.GrenadeDir)
        util.Effect("Sparks", effectdata)
        self:EmitSound("weapons/rpg/shotdown.wav", 100, 150)
        self:Remove()
    end
end


function ENT:Draw()
    self:DrawModel()
end
--addons/auralvsradar/lua/entities/aura_lfs_fight_display_panel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "LVS Fight Display Panel"
ENT.Category = "Aura's Custom Entities"

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

function ENT:SetupDataTables()


	self:NetworkVar("Int",0, "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 2,min = 0, max = 2, category = "AI"} } )
	self:NetworkVar("Int",1, "OffsetY", { KeyName = "offsetY", Edit = { type = "Int", order = 2,min = -50, max = 150, category = "General"} } )


	self:NetworkVar("Bool",1, "Powered", { KeyName = "Powered", Edit = { type = "Boolean", order = 0, category = "Controls"} } )

	self:NetworkVar("Bool",2, "ShowPlayers", { KeyName = "ShowPlayers", Edit = { type = "Boolean", order = 1, category = "Controls"} } )
	self:NetworkVar("Bool",3, "ShowNPCs", { KeyName = "ShowNPCs", Edit = { type = "Boolean", order = 2, category = "Controls"} } )
	self:NetworkVar("Bool",4, "ShowShips", { KeyName = "ShowShips", Edit = { type = "Boolean", order = 3, category = "Controls"} } )

	self:NetworkVar("String",0,"HologramMaterial",{ KeyName = "HologramMaterial", Edit = { type = "String", category = "General"} })

	if SERVER then
		self:NetworkVarNotify( "AITEAM", self.SetNewAITeam )
		self:NetworkVarNotify( "OffsetY", self.SetNewOffsetY )
		self:NetworkVarNotify( "ShowPlayers", self.SetNewShowPlayers )
		self:NetworkVarNotify( "ShowNPCs", self.SetNewShowNPCs )
		self:NetworkVarNotify( "ShowShips", self.SetNewShowShips )
		self:NetworkVarNotify( "Powered", self.SetNewEnabled )

	end

	if CLIENT then
		self:NetworkVarNotify("HologramMaterial", self.SetNewHologramMaterial )
	end

	self:SetAITEAM(2)
	self:SetOffsetY(70)
	self:SetNWBool("SelfShowPlayers",true)
	self:SetNWBool("SelfShowShips",true)
	self:SetNWBool("Powered",true)
	self:SetPowered(true)
	self:SetShowPlayers(true)
	self:SetShowNPCs(true)
	self:SetShowShips(true)
	self:SetHologramMaterial("ace/sw/hologram")
end

function ENT:SetNewAITeam(name, old, new)
	self:SetNWInt("SelfAITeam",new)
end

function ENT:SetNewOffsetY(name, old, new)
	self:SetNWInt("SelfOffsetY",new)
end

function ENT:SetNewShowPlayers(name, old, new)
	self:SetNWBool("SelfShowPlayers",new)
end

function ENT:SetNewShowNPCs(name, old, new)
	self:SetNWBool("SelfShowNPCs",new)
end

function ENT:SetNewShowShips(name, old, new)
	self:SetNWBool("SelfShowShips",new)
end

function ENT:SetNewEnabled(name, old, new)
	self:SetNWBool("Powered",new)
end

function ENT:SetNewHologramMaterial(name, old, new)
	if (self.shipModels != nil) then
		for i=1,#self.shipModels do
			if (self.shipModels[i]) then
				self.shipModels[i]:SetMaterial(new or "ace/sw/hologram")
			end
		end
	end
end
--gamemodes/starwarsrp/entities/entities/bodyman_closet.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Kleiderschrank"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true
ENT.Editable = true


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/armory_02_1/armory_02_1.mdl" )
        self:DrawShadow( false )
        --self:SetColor(Color(225,0,255))
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )
        --self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

    function ENT:Use(ply)
        
        ply:ConCommand("aocrp_mychar")
        self:EmitSound("doors/door1_move.wav", 100, math.random(75,100))
    end

        



end

--addons/lvs_addons/lua/entities/hyena_bomb/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--lua/entities/laat_detonator/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--addons/lvs_addons/lua/entities/lfs_tx-427_main.lua:
AddCSLuaFile()

ENT.Type = "anim"

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
		self:PhysWake()

		local pObj = self:GetPhysicsObject()
		if IsValid( pObj ) then
			pObj:EnableGravity( false ) 
			pObj:SetMass( 1 ) 
		end

		self.SpawnTime = CurTime()
	end
	
	function ENT:Think()
		if self.SpawnTime + 12 < CurTime() then
			self:Detonate()
		end
		
		local pObj = self:GetPhysicsObject()
		if IsValid( pObj ) then
			pObj:SetVelocityInstantaneous( self:GetForward() * 4000 )
		end
	end

	function ENT:Detonate()
		util.BlastDamage( IsValid( self.inflictor ) and self.inflictor or self, IsValid( self.attacker ) and self.attacker or self, self:GetPos(), 100, 200 )

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
		util.Effect( "lfs_tx-427_main_explosion", effectdata )

		self:Remove()
	end

	function ENT:PhysicsCollide( data )
		if data.HitEntity == self.inflictor then return end
		
		self:Detonate()
	end
else
	local mat = Material( "sprites/light_glow02_add" )
	local mat_laser = Material( "effects/spark" )
	local blue = Color(0,0,255,255)
	local white = Color(255,255,255,255)
	function ENT:Draw()
		local pos = self:GetPos()
		local dir = self:GetForward()
		local length = 100

		render.SetMaterial( mat_laser )
		render.DrawBeam( pos + dir * length, pos, 40, 1, 0, blue )
		render.DrawBeam( pos + dir * length, pos, 15, 1, 0, white )

		render.SetMaterial( mat )
		render.DrawSprite( pos + dir * length * 0.3, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.45, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.6, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.75, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.9, 100, 100, blue )
	end
end
--addons/weapon_jedi/lua/entities/lscs_pickupable.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.DoNotDuplicate = true

ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()
end

function ENT:PlayAnimation( animation, playbackrate )
	playbackrate = playbackrate or 1

	local sequence = self:LookupSequence( animation )

	self:ResetSequence( sequence )
	self:SetPlaybackRate( playbackrate )
	self:SetSequence( sequence )
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )

		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 15 )
		ent:SetAngles( Angle(90,ply:EyeAngles().y,0) )
		ent.PreventTouch = true
		ent:Spawn()
		ent:Activate()
		ent:PhysWake()

		return ent
	end

	function ENT:Initialize()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		self:SetTrigger( true )

		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	function ENT:DoPickup( ply )
		ply:EmitSound( self.PickupSound )
		ply:lscsAddInventory( self )
	end

	function ENT:OnRemove()
	end

	function ENT:Use( ply )
		self:DoPickup( ply )
	end

	function ENT:Think()
		if self.DieTime and self.DieTime < CurTime() then
			self:Remove()
		end
		
		self:NextThink( CurTime() )
		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		self:TakePhysicsDamage( dmginfo )
	end

	function ENT:PhysicsCollide( data, physobj )
		if data.Speed > 60 and data.DeltaTime > 0.2 then
			if data.Speed > 200 then
				self:EmitSound( self.ImpactHardSound )
			else
				self:EmitSound(  self.ImpactSoftSound )
			end
		end
	end

	function ENT:StartTouch( touch_ent )
		if self.PreventTouch then return end

		if not IsValid( touch_ent ) or not touch_ent:IsPlayer() then return end

		self:DoPickup( touch_ent )
	end

	function ENT:EndTouch( touch_ent )
	end

	function ENT:Touch( touch_ent )
	end
else
	function ENT:Initialize()
	end

	function ENT:Think()
	end

	function ENT:OnRemove()
	end

	function ENT:DrawTranslucent()
	end

	function ENT:Draw()
		self:DrawModel()
	end
end
--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427_imperial/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterTurret( pod:lvsGetWeapon() )

	self:InvalidateBoneCache()
end
--addons/lvs_base/lua/entities/lvs_base/cl_boneposeparemeter.lua:

function ENT:CreateBonePoseParameter( name, bone, ang_min, ang_max, pos_min, pos_max )
	if not istable( self._BonePoseParameters ) then self._BonePoseParameters = {} end

	self._BonePoseParameters[ name ] = {
		bone = (bone or -1),
		ang_min = ang_min or angle_zero,
		ang_max = ang_max or angle_zero,
		pos_min = pos_min or vector_origin,
		pos_max = pos_max or vector_origin,
	}
end

function ENT:SetBonePoseParameter( name, value )
	if name and string.StartsWith( name, "!" ) then
		name = string.Replace( name, "!", "" )
	end

	local EntTable = self:GetTable()

	if not istable( EntTable._BonePoseParameters ) or not EntTable._BonePoseParameters[ name ] then return end

	local data = EntTable._BonePoseParameters[ name ]

	local ang = LerpAngle( value, data.ang_min, data.ang_max )
	local pos = LerpVector( value, data.pos_min, data.pos_max )

	self:ManipulateBoneAngles( data.bone, ang )
	self:ManipulateBonePosition( data.bone, pos )
end
--addons/lvs_addons/lua/entities/lvs_base_starfighter/cl_hud.lua:
ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local Throttle = self:GetThrottle()
	local Col = Throttle <= 1 and color_white or Color(0,0,0,255)
	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )

	if Throttle > 1 then
		draw.SimpleText( "+"..math.Round((Throttle - 1) * 100,0).."%" , "LVS_FONT",  hX, hY, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	if ply ~= self:GetDriver() then return end

	local HitPlane = self:GetEyeTrace( true ).HitPos:ToScreen()
	local HitPilot = self:GetEyeTrace().HitPos:ToScreen()

	self:PaintCrosshairCenter( HitPlane )
	self:PaintCrosshairOuter( HitPilot )

	if ply:lvsMouseAim() and not ply:lvsKeyDown( "FREELOOK" ) then
		self:LVSHudPaintMouseAim( HitPlane, HitPilot )
	end

	self:LVSPaintHitMarker( HitPilot )
end

function ENT:LVSHudPaintDirectInput( Pos2D )
	self:PaintCrosshairCenter( Pos2D )
	self:PaintCrosshairOuter( Pos2D )
end

function ENT:LVSHudPaintMouseAim( HitPlane, HitPilot )
	local Sub = Vector(HitPilot.x,HitPilot.y,0) - Vector(HitPlane.x,HitPlane.y,0)
	local Len = Sub:Length()
	local Dir = Sub:GetNormalized()

	surface.SetDrawColor( 255, 255, 255, 100 )
	if Len > 20 then
		surface.DrawLine( HitPlane.x + Dir.x * 5, HitPlane.y + Dir.y * 5, HitPilot.x - Dir.x * 20, HitPilot.y- Dir.y * 20 )

		-- shadow
		surface.SetDrawColor( 0, 0, 0, 50 )
		surface.DrawLine( HitPlane.x + Dir.x * 5 + 1, HitPlane.y + Dir.y * 5 + 1, HitPilot.x - Dir.x * 20+ 1, HitPilot.y- Dir.y * 20 + 1 )
	end
end

--addons/lvs_addons/lua/entities/lvs_base_starfighter/cl_deathsound.lua:

function ENT:OnDestroyed()
	if not self.DeathSound then return end

	if self:GetVelocity():Length() <= self.MaxVelocity * 0.5 then return end

	self._sndDeath = CreateSound( self, self.DeathSound )
	self._sndDeath:SetSoundLevel( 125 )
	self._sndDeath:PlayEx( 1, 50 + 50 * self:CalcDoppler( LocalPlayer() ) )
end

function ENT:StopDeathSound()
	if not self._sndDeath then return end

	self._sndDeath:Stop()
end


--addons/laat_g/lua/entities/lvs_custommissile.lua:
AddCSLuaFile()

ENT.Base = "lvs_missile"

ENT.Type            = "anim"

ENT.PrintName = "Custom Missile"
ENT.Author = "Tic"
ENT.Information = "Big Boom"
ENT.Category = "[LVS]"

ENT.Spawnable		= false
ENT.AdminOnly		= false

ENT.ExplosionEffect = "lvs_proton_explosion_large"
ENT.GlowColor = Color( 0, 127, 255, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 4000)
	end

	function ENT:GetRadius() 
		return (self._radius or 1000)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true
	 self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 95 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_proton_trail_large", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((60 - i) / 20) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/lvs_base/lua/entities/lvs_destruction.lua:
AddCSLuaFile()

ENT.Type            = "anim"

local gibs = {
	"models/gibs/manhack_gib01.mdl",
	"models/gibs/manhack_gib02.mdl",
	"models/gibs/manhack_gib03.mdl",
	"models/gibs/manhack_gib04.mdl",
	"models/props_c17/canisterchunk01a.mdl",
	"models/props_c17/canisterchunk01d.mdl",
	"models/props_c17/oildrumchunk01a.mdl",
	"models/props_c17/oildrumchunk01b.mdl",
	"models/props_c17/oildrumchunk01c.mdl",
	"models/props_c17/oildrumchunk01d.mdl",
	"models/props_c17/oildrumchunk01e.mdl",
}

for _, modelName in ipairs( gibs ) do
	util.PrecacheModel( modelName )
end

if SERVER then
	function ENT:Initialize()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false ) 

		self.Vel = isvector( self.Vel ) and self.Vel or Vector(0,0,0)

		local fxPos = self:LocalToWorld( self:OBBCenter() )
	
		local effectdata = EffectData()
			effectdata:SetOrigin( fxPos )
		util.Effect( "lvs_explosion", effectdata )

		self.GibModels = istable( self.GibModels ) and self.GibModels or gibs

		self.Gibs = {}
		self.DieTime = CurTime() + 5

		local Speed = self.Vel:Length()

		for _, v in pairs( self.GibModels ) do
			local ent = ents.Create( "prop_physics" )

			if not IsValid( ent ) then continue end

			table.insert( self.Gibs, ent ) 

			ent:SetPos( self:GetPos() )
			ent:SetAngles( self:GetAngles() )
			ent:SetModel( v )
			ent:Spawn()
			ent:Activate()
			ent:SetRenderMode( RENDERMODE_TRANSALPHA )
			ent:SetCollisionGroup( COLLISION_GROUP_WORLD )

			local PhysObj = ent:GetPhysicsObject()
			if IsValid( PhysObj ) then
				if Speed <= 250 then
					local GibDir = Vector( math.Rand(-1,1), math.Rand(-1,1), 1.5 ):GetNormalized()
					PhysObj:SetVelocityInstantaneous( GibDir * math.random(800,1300)  )
				else
					PhysObj:SetVelocityInstantaneous( VectorRand() * math.max(300,self.Vel:Length() / 3) + self.Vel  )
				end

				PhysObj:AddAngleVelocity( VectorRand() * 500 ) 
				PhysObj:EnableDrag( false ) 

				local effectdata = EffectData()
					effectdata:SetOrigin( fxPos )
					effectdata:SetStart( PhysObj:GetMassCenter() )
					effectdata:SetEntity( ent )
					effectdata:SetScale( math.Rand(0.3,0.7) )
					effectdata:SetMagnitude( math.Rand(0.5,2.5) )
				util.Effect( "lvs_firetrail", effectdata )
			end

			timer.Simple( 4.5 + math.Rand(0,0.5), function()
				if not IsValid( ent ) then return end

				ent:SetRenderMode( RENDERMODE_TRANSCOLOR )
				ent:SetRenderFX( kRenderFxFadeFast  )
			end )
		end
	end

	function ENT:Think()
		if self.DieTime < CurTime() then
			self:Remove()
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnRemove()
		if istable( self.Gibs ) then
			for _, v in pairs( self.Gibs ) do
				if IsValid( v ) then
					v:Remove()
				end
			end
		end
	end
else
	function ENT:Draw()
	end
end
--addons/lvs_addons/lua/entities/lvs_fakehover_barc/shared.lua:
ENT.Type = "anim"
DEFINE_BASECLASS( "lunasflightschool_basescript_gunship" )
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Barc-speeder"
ENT.Author = "Codexx"
ENT.Information = "Biker Advanced Recon Commando "
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/barc/barc.mdl"

ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 1400

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 600
ENT.MaxVelocityY = 600

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 480
ENT.BoostAddVelocityY = 480

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,-51,43) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,51,43) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 10 and AimAnglesL.p >= 10) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 30)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(120.24,18.04 * i,26.96) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

end

ENT.EngineSounds = {
	{
		sound = "heracles421/galactica_vehicles/barc_engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 205,
	},
	{
		sound = "heracles421/galactica_vehicles/barc_engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "heracles421/galactica_vehicles/barc_engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "BARC_SHOOT",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "barc/canon.wav"
} )

--addons/lvs_addons/lua/entities/lvs_nuclass_attack_shuttle/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "NU-Class Attack Shuttle"
ENT.Author = "Durian"
ENT.Information = "The Nu-class attack shuttle, also known as the Republic attack shuttle, was a vessel used by the Grand Army of the Republic during the Clone Wars."
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/swbf3/vehicles/nu_attackship.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 2000
ENT.MaxThrust = 1750

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 1

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 0.9
ENT.TurnRateRoll = 1

ENT.MaxPitch = 60
ENT.MaxRoll = 0

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 3500
ENT.MaxShield = 1000

function ENT:OnSpawn()
	
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingsDown" )
	self:AddDT( "Bool", "HatchOpen" )

	if SERVER or CLIENT then
		self:NetworkVarNotify( "WingsDown", self.OnWingsChanged )
	end

	if SERVER or CLIENT then
		self:NetworkVarNotify( "HatchOpen", self.OnHatchChanged )
	end
end

function ENT:InitWeapons()
	local weapon = {}
		weapon.Icon = Material("lvs/weapons/dual_hmg.png")
		weapon.Ammo = 1250
		weapon.Delay = 0.5
		weapon.HeatRateUp = 0.3
		weapon.HeatRateDown = 0.5
		weapon.Attack = function( ent )
			if not self:GetWingsDown(true) then 
				ent:SetHeat( ent:GetHeat() * 0 )
				return
			end
			local pod = ent:GetDriverSeat()

			if not IsValid( pod ) then return end

			local startpos = pod:LocalToWorld( pod:OBBCenter() )
			local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
			} )

			local bullet = {}
			bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 40
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
				for i = -1,1,2 do
					bullet.Src 	= ent:LocalToWorld( Vector(210,220 * i, 120) )
					bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()

					local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) )
					effectdata:SetOrigin( bullet.Src )
					effectdata:SetNormal( ent:GetForward() )
					effectdata:SetEntity( ent )
					util.Effect( "lvs_muzzle_colorable", effectdata )

					ent:LVSFireBullet( bullet )
				end

				for i = -1,1,2 do
					bullet.Src 	= ent:LocalToWorld( Vector(230,220 * i, 140) )
					bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()

					local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) )
					effectdata:SetOrigin( bullet.Src )
					effectdata:SetNormal( ent:GetForward() )
					effectdata:SetEntity( ent )
					util.Effect( "lvs_muzzle_colorable", effectdata )

					ent:LVSFireBullet( bullet )
				end

			ent:TakeAmmo()

			ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/shuttle/overheat.wav") end
	self:AddWeapon( weapon )

		local weapon = {}
			weapon.Icon = Material("lvs/weapons/dual_mg.png")
			weapon.Ammo = 1250
			weapon.Delay = 0.5
			weapon.HeatRateUp = 0.4
			weapon.HeatRateDown = 0.5
			weapon.Attack = function( ent )
				if not self:GetWingsDown(true) then 
					ent:SetHeat( ent:GetHeat() * 0 )
					return
				end
				local pod = ent:GetDriverSeat()
	
				if not IsValid( pod ) then return end
	
				local startpos = pod:LocalToWorld( pod:OBBCenter() )
				local trace = util.TraceHull( {
				start = startpos,
				endpos = (startpos + ent:GetForward() * 50000),
				mins = Vector( -10, -10, -10 ),
				maxs = Vector( 10, 10, 10 ),
				filter = ent:GetCrosshairFilterEnts()
				} )
	
				local bullet = {}
				bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
				bullet.TracerName = "lvs_laser_blue"
				bullet.Force	= 10
				bullet.HullSize 	= 25
				bullet.Damage	= 80
				bullet.Velocity = 60000
				bullet.Attacker 	= ent:GetDriver()
				bullet.Callback = function(att, tr, dmginfo)
					local effectdata = EffectData()
						effectdata:SetStart( Vector(50,50,255) ) 
						effectdata:SetOrigin( tr.HitPos )
						effectdata:SetNormal( tr.HitNormal )
					util.Effect( "lvs_laser_impact", effectdata )
				end
					for i = -1,1,2 do
						bullet.Src 	= ent:LocalToWorld( Vector(470,120 * i, 150) )
						bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
	
						local effectdata = EffectData()
						effectdata:SetStart( Vector(50,50,255) )
						effectdata:SetOrigin( bullet.Src )
						effectdata:SetNormal( ent:GetForward() )
						effectdata:SetEntity( ent )
						util.Effect( "lvs_muzzle_colorable", effectdata )
	
						ent:LVSFireBullet( bullet )
					end
	
					for i = -1,1,2 do
						bullet.Src 	= ent:LocalToWorld( Vector(470,120 * i, 175)) 
						bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
	
						local effectdata = EffectData()
						effectdata:SetStart( Vector(50,50,255) )
						effectdata:SetOrigin( bullet.Src )
						effectdata:SetNormal( ent:GetForward() )
						effectdata:SetEntity( ent )
						util.Effect( "lvs_muzzle_colorable", effectdata )
	
						ent:LVSFireBullet( bullet )
					end
	
				ent:TakeAmmo()
	
				ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
			end
			weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
			weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/shuttle/overheat.wav") end
		self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if not self:GetHatchOpen(false) then
			self:EmitSound("lvs/vehicles/vwing/sfoils.wav")
			self:SetHatchOpen(true)
			self:ManipulateBoneAngles(1, Angle(0,0,-90))
			self:ManipulateBoneAngles(2, Angle(0,0,180))
			
		else
			self:EmitSound("lvs/vehicles/vwing/sfoils.wav")
			self:SetHatchOpen(false)
			self:ManipulateBoneAngles(1, Angle(0,0,0))
			self:ManipulateBoneAngles(2, Angle(0,0,0))
		end
	end
	self:AddWeapon( weapon )

end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/shuttle/flyby.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/nuclass/engine.wav",
		sound_int = "lvs/vehicles/nuclass/engineint.wav",
		Pitch = 100,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/shuttle/distance.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}
--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/cl_init.lua:
include("shared.lua")
include( "sh_mainweapons.lua" )
include( "sh_ballturret_left.lua" )
include( "sh_wingturret.lua" )
include( "cl_drawing.lua" )
include( "sh_gunner2.lua" )
include( "sh_gunner3.lua" )
include( "cl_prediction.lua" )
include( "cl_lights.lua" )

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:AnimLights()
	self:WingTurretProjector()
	self:BTLProjector()
	self:PredictPoseParamaters()
end
	
function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_left_projector", effectdata )
	end
end

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_wing_projector", effectdata )
	end
end


function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end

--addons/lvs_addons/lua/entities/lvs_sithfighter_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Sith fighter"
ENT.Author = "Ophra"
ENT.Information = "Fighter of the Sith Empire"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/mag_spacecombatplayershipsith_sith_ship.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(411.63,27.28,-20.96),
		Vector(411.63,-27.28,-20.96),
	}


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
 		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(411.63,-27.28,-20.96))
			

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(411.63,27.28,-20.96)	)

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 25
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 411.63, (ent._swapMissile and 20.96 or -20.96), 58.12 ) 




		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

end


	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/lvs_base/lua/entities/lvs_soundemitter.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )
	self:NetworkVar( "Bool",1, "ActiveVisible" )
	self:NetworkVar( "Bool",2, "Doppler" )

	self:NetworkVar( "String",1, "Sound")
	self:NetworkVar( "String",2, "SoundInterior")

	self:NetworkVar( "Int",0, "SoundLevel" )

	if SERVER then
		self:SetSoundLevel( 110 )
		self:SetActiveVisible( true )
	end
end

if SERVER then
	util.AddNetworkString( "lvs_soundemitter_playonce" )

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 150, 150, 150 ) )
	end

	function ENT:Think()
		return false
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	function ENT:PlayOnce( pitch, volume )
		net.Start( "lvs_soundemitter_playonce", true )
			net.WriteEntity( self )
			net.WriteInt( pitch or 100, 9 )
			net.WriteFloat( volume or 1 )
		net.SendPVS( self:GetPos() )
	end

	function ENT:Play()
		self:SetActive( true )
	end

	function ENT:Stop()
		self:SetActive( false )
	end

	return
end

net.Receive( "lvs_soundemitter_playonce", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not ent.PlayOnce then return end

	ent:PlayOnce( net.ReadInt( 9 ), net.ReadFloat() )
end )

function ENT:PlayOnce( pitch, volume )
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()

	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd == snd_int then self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON ) return end

	if IsValid( veh ) and veh == self:GetBase() and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			else
				self:EmitSound( snd_int, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			end
		else
			self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
		end
	else
		self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
	end
end

function ENT:Initialize()
end

function ENT:RemoveSounds()
	if self.snd then
		self.snd:Stop()
		self.snd = nil
	end

	if self.snd_int then
		self.snd_int:Stop()
		self.snd_int = nil
	end
end

function ENT:HandleSounds()
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()
	local base = self:GetBase()

	if self:GetDoppler() and IsValid( base ) then
		local Doppler = base:CalcDoppler( ply )

		if self.snd then self.snd:ChangePitch( 100 * Doppler, 0.5 ) end
		if self.snd_int then self.snd_int:ChangePitch( 100 * Doppler, 0.5 ) end
	end

	if not self.snd_int then return end

	if IsValid( veh ) and veh == base and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				if self.snd then self.snd:ChangeVolume( 1 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
			else
				if self.snd then self.snd:ChangeVolume( 0 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 1 ) end
			end
		else
			if self.snd then self.snd:ChangeVolume( 1 ) end
			if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
		end
	else
		if self.snd then self.snd:ChangeVolume( 1 ) end
		if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
	end
end

function ENT:StartSounds()
	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd ~= "" then
		self.snd = CreateSound( self, snd )
		self.snd:SetSoundLevel( self:GetSoundLevel() )
		self.snd:PlayEx(0,100)
	end

	if snd == snd_int or snd_int == "" or LocalPlayer():lvsGetVehicle() ~= self:GetBase() then
		if self.snd then self.snd:ChangeVolume( 1, 0 ) end

		return
	end

	self.snd_int = CreateSound( self, snd_int )
	self.snd_int:SetSoundLevel( self:GetSoundLevel() )
	self.snd_int:PlayEx(0,100)
end

function ENT:StopSounds()
	self.NextActive = CurTime() + 0.12

	if self.snd then
		self.snd:ChangeVolume( 0, 0.1 )
	end

	if self.snd_int then
		self.snd_int:ChangeVolume( 0, 0.1 )
	end

	timer.Simple(0.11, function()
		if not IsValid( self ) then return end
		self:RemoveSounds()
	end)
end

function ENT:OnActiveChanged( Active )
	if Active then
		self:StartSounds()
	else
		self:StopSounds()
	end
end

ENT._oldActive = false
function ENT:Think()
	local Active = self:GetActive() and (self.NextActive or 0) < CurTime()

	if self._oldActive ~= Active then
		self._oldActive = Active
		self:OnActiveChanged( Active )
	end

	if Active then
		self:HandleSounds()
	end
end

function ENT:OnRemove()
	self:RemoveSounds()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--addons/lvs_addons/lua/entities/lvs_starfighter_arc170/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "ARC-170 fighter"
ENT.Author = "Luna"
ENT.Information = "Heavy-Duty Starfighter of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/arc170.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(207.65,-303.52,-48.35),
		Vector(207.65,303.52,-48.35),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.5 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 40
		bullet.SplashDamage = 60
		bullet.SplashDamageRadius = 250
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 90, (ent._swapMissile and -304 or 304), -32 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )




	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 60 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-175.81,0,50.26) or Vector(-171.69,0,5.81) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 45
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_gauntlet/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

ENT.RED = Color(255,0,0,255)
ENT.WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	local Pod = self:GetGunnerSeat()

	if Pod ~= ply:GetVehicle() then return true end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return true end
	
	local Col = (self:AngleBetweenNormal( weapon:GetAimVector(), weapon:GetForward() ) > 60) and self.RED or self.WHITE

	local Pos2D = weapon:GetEyeTrace().HitPos:ToScreen() 

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	return true
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-320,190,100), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-320,-190,100), 0, 20, 2, 1000, 150 )
	
	self:RegisterTrail( Vector(-240,0,60), 0, 20, 2, 700, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 280 + self:GetThrottle() * 120 + self:GetBoost()
	local Mirror = false

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-480,270,175) ), Size, Size, Color( 255, 200, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-480,-270,175) ), Size, Size, Color( 255, 200, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-480,210,175) ), Size, Size, Color( 255, 200, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-480,-210,175) ), Size, Size, Color( 255, 200, 0, 255) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end
	
	self.nextEFX = self.nextEFX or 0
	
	if self.nextEFX < CurTime() then
		self.nextEFX = CurTime() + 0.01
		
		local emitter = ParticleEmitter( self:GetPos(), false )
		local Pos = {
			Vector(-495,210,175),
			Vector(-495,-210,175),
			Vector(-495,270,175),
			Vector(-495,-270,175),
			}

		if emitter then
			for _, v in pairs( Pos ) do
				local Sub = Mirror and 1 or -1
				local vOffset = self:LocalToWorld( v )
				local vNormal = -self:GetForward()

				vOffset = vOffset + vNormal * 5

				local particle = emitter:Add( "effects/muzzleflash2", vOffset )
				if not particle then return end

				particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(35,55) )
				particle:SetEndSize( math.Rand(1,20) )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				
				particle:SetColor( 200, 250, 200 )
			
				Mirror = true
			end
			
			emitter:Finish()
		end
	end
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "w_wing_by_1.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "w_wing_by_2.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_nbt630/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "NBT-630 Heavy Bomber"
ENT.Author = "Luna"
ENT.Information = "Rare, Heavy-Duty Bomber of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/nbt630/rep_ntb630_servius.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2100
ENT.MaxThrust = 2100

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 1600
ENT.MaxShield = 2100

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 5 or AimAngles.p <= -80)
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(425,45,20),
		Vector(425,-45,20),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 800
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.3
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 150
		bullet.HullSize 	= 30
		bullet.Damage	= 100
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent )ent:EmitSound("physics/metal/weapon_impact_soft3.wav")	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile
		
		local Pos = Vector( 250, (ent._swapMissile and -120 or 120), 55 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and .5 or -.5,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetDamage( 800 )
		projectile:SetRadius( 350 )
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )




	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(200,8,150) or Vector(200,-8,150) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_blue_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 45
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local AimAngles = self:GetAimAngles( ent )

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_skipray/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()	
	self:RegisterTrail( Vector(-5,73,37), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-5,-73,37), 0, 20, 2, 1000, 150 )
	
	self:RegisterTrail( Vector(-140,90,70), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-140,-90,70), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()
	local Mirror = false

	render.SetMaterial( self.EngineGlow )

	for i = -1,1,2 do
		local pos = self:LocalToWorld( Vector(-236,0,70) )
		render.DrawSprite( pos, Size, Size, Color( 255, 49, 0, 255) )
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(-240,0,70) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
			
		particle:SetColor( 255, 50, 200 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_soulless/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-75,115,35), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-75,-115,35), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-145,35,45), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-145,-35,45), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EnginePos = {
	[1] = Vector(-70,115,35),
	[2] = Vector(-70,-115,35),
	[3] = Vector(-140,35,45),
	[4] = Vector(-140,-35,45),
}

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(25,45) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 200, 50 )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 60 + self:GetThrottle() * 60 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_turret_aa/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--addons/lvs_addons/lua/entities/lvs_turret_av/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Vehicle Turret"
ENT.Author = "Luna"
ENT.Information = "Hard-hitting, but very limited firing arc. Good for dealing with pesky tanks."
ENT.Category = "[LVS] - Turrets (Republic)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antivehicleturret/Anti-VehicleTurret.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 7500


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 8 or AimAngles.p <= -10)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.67
	weapon.HeatRateDown = 0.2
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID = self:LookupAttachment( "muzzle" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end	

		local Pos = Muzzle.Pos
		local Dir = Muzzle.Ang:Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01)
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 450
		bullet.Velocity = 20000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.5
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_L = self:LookupAttachment( "muzzle_left" )
		local ID_R = self:LookupAttachment( "muzzle_right" )
		local MuzzleLeft = self:GetAttachment( ID_L )
		local MuzzleRight = self:GetAttachment( ID_R )

		if not MuzzleLeft or not MuzzleRight then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleLeft.Pos or MuzzleRight.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleLeft.Ang or MuzzleRight.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.015,  0.015, 0.015 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--addons/lvs_base/lua/entities/lvs_vehicle_air_refil.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo Refil Balloon"
ENT.Author = "Luna"
ENT.Information = "Refils Ammo on Vehicles"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.RenderGroup = RENDERGROUP_BOTH 

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/balloons/hot_airballoon.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Balloon terminated.")

			return
		end

		pObj:SetMass( 1000 ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:StartMotionController()

		self:PhysWake()
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local StartPos = self:LocalToWorld( self:OBBCenter() )
		local traceUp = util.TraceLine( {
			start = StartPos,
			endpos = StartPos + Vector(0,0,50000),
			filter = self,
			mask = MASK_SOLID
		} )
		local traceDown = util.TraceLine( {
			start = StartPos,
			endpos = StartPos - Vector(0,0,50000),
			filter = self,
			mask = MASK_SOLID
		} )

		local Force = (traceUp.HitPos + traceDown.HitPos) * 0.5 - StartPos

		local ForceLinear, ForceAngle = phys:CalculateForceOffset( Force, phys:LocalToWorld( phys:GetMassCenter() + Vector(0,0,1) ) )

		ForceLinear = ForceLinear - phys:GetVelocity()
		ForceAngle = ForceAngle - phys:GetAngleVelocity()

		return ForceAngle, ForceLinear, SIM_GLOBAL_ACCELERATION
	end

	function ENT:Refil( entity )
		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")
		end

		entity:OnMaintenance()
	end

	function ENT:StartTouch( entity )
		self:Refil( entity )
	end

	function ENT:EndTouch( entity )
		self:Refil( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:Think()
		return false
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local SpriteColor = Color( 255, 150, 0, 255 )
	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local RepairMat = Material( "lvs/3d2dmats/refil.png" )

	function ENT:Draw()
	end

	function ENT:DrawTranslucent()
		local ply = LocalPlayer()
		local Small = false

		if IsValid( ply ) and not IsValid( ply:lvsGetVehicle() ) then
			self:DrawModel()

			Small = true

			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local ply = LocalPlayer()
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		end

		local Pos = self:LocalToWorld( self:OBBCenter() )

		if Small then
			for i = 0, 180, 180 do
				cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(0,i,90) ), 1 )
					surface.SetDrawColor( 255, 150, 0, 255 )

					surface.SetMaterial( FrameMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )

					surface.SetMaterial( RepairMat )
					surface.DrawTexturedRect( -256, 0, 512, 512 )
				cam.End3D2D()
			end
		else
			for i = 0, 180, 180 do
				cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(0,i,90) ), 0.75 )
					surface.SetDrawColor( 255, 150, 0, 255 )

					surface.SetMaterial( FrameMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )

					surface.SetMaterial( RepairMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				cam.End3D2D()
			end
		end
	end

	function ENT:OnRemove()
		if IsValid( self._RepairMDL ) then
			self._RepairMDL:Remove()
		end
	end
end
--addons/lvs_addons/lua/entities/lvs_walker_atte/cl_init.lua:
include("shared.lua")
include( "cl_ikfunctions.lua" )
include( "cl_camera.lua" )
include( "cl_legs.lua" )
include( "cl_prediction.lua" )
include("sh_turret.lua")
include("sh_gunner.lua")

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,70) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,160) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,20,180) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-20,180) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:PreDraw()
	self:DrawTurretDriver()

	return true
end

function ENT:DrawTurretDriver()
	local pod = self:GetTurretSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	local ID = self:LookupAttachment( "driver_turret" )
	local Att = self:GetAttachment( ID )

	if not Att then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-110,-90,0), Att.Pos, Att.Ang )

	ply:SetSequence( "drive_jeep" )
	ply:SetRenderAngles( Ang )
	ply:DrawModel()
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if self:GetIsCarried() then return end

	if ply ~= self:GetDriver() then
		local pod = ply:GetVehicle()

		if pod == self:GetTurretSeat() or pod == self:GetGunnerSeat() then
			self:PaintZoom( X, Y, ply )
		end

		return
	end

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen()

	local _,_, InRange = self:GetAimAngles()

	local Col = InRange and white or red

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	self:PaintZoom( X, Y, ply )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if self:GetIsCarried() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end

--addons/lvs_addons/lua/entities/lvs_walker_atte/sh_gunner.lua:

function ENT:GetGunnerAimAng( ent, base, RearEnt )
	local trace = ent:GetEyeTrace()

	local Pos = RearEnt:LocalToWorld( Vector(-208,0,170) )
	local wAng = (trace.HitPos - Pos):GetNormalized():Angle()

	local _, Ang = WorldToLocal( Pos, wAng, Pos, RearEnt:LocalToWorldAngles( Angle(0,180,0) ) )

	return Ang, trace.HitPos, (Ang.p < 30 and Ang.p > -10 and math.abs( Ang.y ) < 60)
end

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:InitGunner()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.2
	weapon.OnOverheat = function( ent ) end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then base:SetHeat( 0 ) return true end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end

		local _, AimPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		if not InRange then return true end
	
		local ID1 = RearEnt:LookupAttachment( "muzzle_right" )
		local ID2 = RearEnt:LookupAttachment( "muzzle_left" )

		local Muzzle1 = RearEnt:GetAttachment( ID1 )
		local Muzzle2 = RearEnt:GetAttachment( ID2 )

		if not Muzzle1 or not Muzzle2 then return end

		local FirePos = { 
			[1] = Muzzle1,
			[2] = Muzzle2
		}

		ent.FireIndex = ent.FireIndex and ent.FireIndex + 1 or 1
	
		if ent.FireIndex > #FirePos then
			ent.FireIndex = 1
		end

		local Pos = FirePos[ent.FireIndex].Pos
		local Dir = (AimPos - Pos):GetNormalized()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 15000
		bullet.HullSize 	= 30
		bullet.Damage	= 100
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 8000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		base.SNDRear:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end
	
		local Ang, HitPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		RearEnt:SetPoseParameter("gun_pitch", math.Clamp(Ang.p,-10,30) )
		RearEnt:SetPoseParameter("gun_yaw", Ang.y )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( Vector(-150,0,150) ) + clamped_angles:Up() * 150
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos
		view.drawviewer = true

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end
	
		local _,AimPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		local Pos2D = AimPos:ToScreen()

		local Col = InRange and white or red

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end

	self:AddWeapon( weapon, 3 )
end
--addons/lvs_addons/lua/entities/lvs_walker_atte/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--addons/lvs_addons/lua/entities/lvs_walker_hsd/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetDriverSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:AimTurretPrimary()
	self:AimTurretSecondary()
end
--addons/lvs_addons/lua/entities/lvs_walker_hsd/sh_weapons.lua:

function ENT:AimTurretSecondary()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,100)) ):GetNormalized():Angle() )

	self:SetPoseParameter("turret_secondary_pitch", -AimAngles.p )
	self:SetPoseParameter("turret_secondary_yaw", AimAngles.y )
end

function ENT:AimTurretPrimary()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,342)) ):GetNormalized():Angle() )

	self:SetPoseParameter("turret_primary_pitch", -AimAngles.p )
	self:SetPoseParameter("turret_primary_yaw", AimAngles.y )
end

function ENT:WeaponsInRange()
	local Forward = self:GetForward()
	local AimForward = self:GetAimVector()

	return self:AngleBetweenNormal( Forward, AimForward ) < 45
end

function ENT:TraceProjectorBeam()
	local ID = self:LookupAttachment( "muzzle_primary" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = -Muzzle.Ang:Right()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:StopProjector()
	if not self:GetProjectorBeam() then return end

	self:SetProjectorBeam( false )

	self.SNDProjector:Stop()
end

function ENT:StartProjector()
	if not IsValid( self.SNDProjector ) then return end

	if self:GetProjectorBeam() then return end

	self:SetProjectorBeam( true )

	self.SNDProjector:Play()
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 2
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.5
	weapon.OnThink = function( ent, active )
		ent:AimTurretPrimary()

		if not ent:GetProjectorBeam() then return end

		local trace = ent:TraceProjectorBeam()

		ent:ProjectorBeamDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )

		if not active then return end

		ent:SetHeat( ent:GetHeat() + FrameTime() * 10 )
	end
	weapon.Attack = function( ent )
		if ent:GetProjectorBeam() then return true end

		if not ent:WeaponsInRange() then return true end

		ent:StartProjector()

		timer.Simple( 1.25, function()
			if not IsValid( ent ) then return end

			ent:StopProjector()
		end )
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 100
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.4
	weapon.OnOverheat = function( ent )
		timer.Simple( 0.4, function()
			if not IsValid( ent ) then return end

			ent:EmitSound("lvs/overheat.wav")
		end )
	end
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local effectdata = EffectData()
		effectdata:SetOrigin( ent:LocalToWorld( Vector(0,0,200) ) )
		effectdata:SetEntity( ent )
		effectdata:SetAttachment( ent:LookupAttachment( "muzzle_secondary" ) )
		util.Effect( "lvs_laser_charge", effectdata )

		timer.Simple( 0.4, function()
			if not IsValid( ent ) then return end

			local ID = ent:LookupAttachment( "muzzle_secondary" )
			local Muzzle = ent:GetAttachment( ID )

			if not Muzzle then return end

			local bullet = {}
			bullet.Src 	= Muzzle.Pos
			bullet.Dir 	= ent:WeaponsInRange() and (ent:GetEyeTrace().HitPos - Muzzle.Pos):GetNormalized() or -Muzzle.Ang:Right()
			bullet.Spread 	= Vector(0,0,0)
			bullet.TracerName = "lvs_laser_red_aat"
			bullet.Force	= 20000
			bullet.HullSize 	= 1
			bullet.Damage	= 200
			bullet.SplashDamage = 300
			bullet.SplashDamageRadius = 250
			bullet.Velocity = 10000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetOrigin( tr.HitPos )
				util.Effect( "lvs_laser_explosion_aat", effectdata )
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( Muzzle.Ang:Up() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:TakeAmmo()

			if not IsValid( ent.SNDTurret ) then return end

			ent.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end )
	end
	weapon.OnThink = function( ent, active )
		ent:AimTurretSecondary()
	end
	self:AddWeapon( weapon )
end
--lua/entities/mace_windu_council_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Mace Windu Council Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/mace_windu_council_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("mace_windu_council_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*10+self:GetForward()*4,self:GetAngles()+Angle(0,-90,15)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:Exit(kill)
	self.BaseClass.Exit(self,kill);
	if(IsValid(p)) then
		p:SetEyeAngles(self:GetAngles() + Angle(0,180,0));
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*50)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--addons/weapons_other/lua/entities/mk2.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jump Pack"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 9 , -6 , -0.2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:SetMaterial ( "Models/effects/vol_light001" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( false )
		self:SetMaxFuel(100)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(3)	--drain in seconds
		self:SetFuelRecharge(6)	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 3000 )
		self:SetJetpackStrafeSpeed( 600 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 2 , 80 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--addons/weapons_other/lua/entities/mk6.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jetpack Infinite Fuel"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 9 , -6 , -0.2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:SetMaterial ( "Models/effects/vol_light001" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( true )
		self:SetMaxFuel(150)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(0)	--drain in seconds
		self:SetFuelRecharge( 0 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2000 )
		self:SetJetpackStrafeSpeed( 500 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 1 , 60 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--addons/arccw_weapons/lua/entities/nade_emp/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "EMP Projectile"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/Items/combine_rifle_ammo01.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		-- ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )

        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_rep_emp_rocket", self:GetPos(), self:GetAngles() )
					sound.Play( "weapons/star_wars_battlefront/jd_oc/glasslcar.wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        	 -- util.BlastDamage(self, self.Owner, self:GetPos(), 65, 100)
	 local ent = self.Owner
	if !IsValid(ent) then ent = self end
	 local t = DamageInfo()
			t:SetDamage(60)
			t:SetDamageType(DMG_SHOCK)
			t:SetAttacker(ent)
			t:SetInflictor(self)
	util.BlastDamageInfo(t, self:GetPos(), 300)
	  -- local targets = ents.FindInSphere(self:GetPos(), 256)
        -- for _, k in pairs(targets) do
            -- if k:IsPlayer() or k:IsNPC() or scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" ) then
                -- local regen = FrameTime() * 900
                -- k:SetHealth( math.Clamp( k:Health() - regen, 0, k:GetMaxHealth()+k:GetMaxHealth() ) )
				-- if(SERVER) then
				-- k:Ignite( 10 )
				-- end
			-- if !k:IsPlayer() or !k:IsNPC() then
				-- end
            -- end
        -- end
        self:Remove()
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),4096,100,0.6,1024)
    end
end

function ENT:Draw()
    if CLIENT then
        -- self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(16, 32), math.random(16, 32), Color(175, 100, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            ParticleEffectAttach( "astw2_swbf_muzzle_cis_bulldog", PATTACH_POINT_FOLLOW, self, 0 )
			cam.End3D()
        end
    end
end
--addons/tools/lua/entities/prop_animatable.lua:

AddCSLuaFile()

ENT.Base = "base_entity"
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()

	self:NetworkVar( "Bool", 0, "IsRagdoll" )
	self:NetworkVar( "Bool", 1, "AnimateBodyXY" )
	self:NetworkVar( "Bool", 2, "BecomeRagdoll" )
	self:NetworkVar( "Bool", 3, "HideBBox" )

	if ( CLIENT ) then return end

	self:SetIsRagdoll( false )
	self:SetAnimateBodyXY( false )
	self:SetBecomeRagdoll( false )

end

if ( SERVER ) then

	function ENT:Initialize()

		-- This is a silly way to check if the model has a physics mesh or not
		self:PhysicsInit( SOLID_VPHYSICS )

		-- We got no physics? Do some fake shit
		if ( !IsValid( self:GetPhysicsObject() ) ) then
			local mins, maxs = self:OBBMins(), self:OBBMaxs()
			self:SetCollisionBounds( mins, maxs )
			self:SetSolid( SOLID_BBOX )
		end

		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )

	end

	function ENT:FixRagdoll()

		local mins, maxs = self:OBBMins(), self:OBBMaxs()

		-- Just in case
		self.OriginalCollisions = mins
		self.OriginalCollisionsMax = maxs

		-- Fix some NPC ragdolls flying above ground
		mins.z = 0

		self:SetCollisionBounds( mins, maxs )
		self:SetSolid( SOLID_BBOX )

		-- Used to determine if this animatable prop should have the "Turn into Ragdoll" option.
		self:SetIsRagdoll( true )

	end

	function ENT:PreEntityCopy()

		self.DuplicatorSavedSequence = self:GetSequence()
		self.DuplicatorSavedSequenceName = self:GetSequenceName( self:GetSequence() )
		self.DuplicatorSavedCycle = self:GetCycle()
		self.DuplicatorSavedPlaybackRate = self:GetPlaybackRate()

		self.PoseParameters = {}
		for k = 0, self:GetNumPoseParameters() - 1 do
			local name = self:GetPoseParameterName( k )
			self.PoseParameters[ name ] = self:GetPoseParameter( name )
		end

	end

	function ENT:PostEntityPaste()

		if ( self:GetIsRagdoll() ) then self:FixRagdoll() end

		if ( !self.DuplicatorSavedSequence ) then return end

		if ( self.DuplicatorSavedSequence != self:LookupSequence( self.DuplicatorSavedSequenceName ) ) then
			print( "Something went wrong with restoring sequence for animatable prop!" )
			self.DuplicatorSavedSequence = self:LookupSequence( self.DuplicatorSavedSequenceName )
		end

		self:ResetSequence( self.DuplicatorSavedSequence )
		self:SetCycle( self.DuplicatorSavedCycle )
		self:SetPlaybackRate( self.DuplicatorSavedPlaybackRate )

		if ( self.PoseParameters ) then
			for name, value in pairs( self.PoseParameters ) do
				self:SetPoseParameter( name, value )
			end
		end

	end

	function ENT:OnTakeDamage( dmg )

		if ( !self:GetBecomeRagdoll() ) then return end

		if ( util.IsValidRagdoll( self:GetModel() ) ) then
			self:BecomeRagdollLua( dmg:GetDamageForce(), dmg:GetDamagePosition() )
		else
			self:GibBreakClient( dmg:GetDamageForce() )
			self:Remove()
		end

	end

end

function ENT:BecomeRagdollLua( force, forcePos )
	local ent = self

	local ragdoll = ents.Create( "prop_ragdoll" )
	ragdoll:SetModel( ent:GetModel() )
	ragdoll:SetPos( ent:GetPos() )
	ragdoll:SetAngles( ent:GetAngles() )

	ragdoll:SetSkin( ent:GetSkin() )
	ragdoll:SetFlexScale( ent:GetFlexScale() )
	for i = 0, ent:GetNumBodyGroups() - 1 do ragdoll:SetBodygroup( i, ent:GetBodygroup( i ) ) end
	for i = 0, ent:GetFlexNum() - 1 do ragdoll:SetFlexWeight( i, ent:GetFlexWeight( i ) ) end
	for i = 0, ent:GetBoneCount() do
		ragdoll:ManipulateBoneScale( i, ent:GetManipulateBoneScale( i ) )
		ragdoll:ManipulateBoneAngles( i, ent:GetManipulateBoneAngles( i ) )
		ragdoll:ManipulateBonePosition( i, ent:GetManipulateBonePosition( i ) )
		ragdoll:ManipulateBoneJiggle( i, ent:GetManipulateBoneJiggle( i ) ) -- Even though we don't know what this does, I am still putting this here.
	end

	ragdoll:Spawn()
	ragdoll:Activate()

	ragdoll.EntityMods = ent.EntityMods
	ragdoll.BoneMods = ent.BoneMods
	duplicator.ApplyEntityModifiers( nil, ragdoll )
	duplicator.ApplyBoneModifiers( nil, ragdoll )

	for i = 0, ragdoll:GetPhysicsObjectCount() - 1 do
		local bone = ragdoll:GetPhysicsObjectNum( i )
		if ( IsValid( bone ) ) then
			local pos, ang = ent:GetBonePosition( ragdoll:TranslatePhysBoneToBone( i ) )
			if ( pos ) then bone:SetPos( pos ) end
			if ( ang ) then bone:SetAngles( ang ) end

			if ( !force ) then
				bone:EnableMotion( false )
			else
				bone:ApplyForceOffset( force / ragdoll:GetPhysicsObjectCount(), forcePos )
			end
		end
	end

	undo.ReplaceEntity( ent, ragdoll )
	cleanup.ReplaceEntity( ent, ragdoll )

	constraint.RemoveAll( ent ) -- Remove all constraints ( this stops ropes from hanging around )
	ent:Remove()
end

function ENT:Think()

	-- Clientside only because Velocity is 0 on server
	if ( self:GetAnimateBodyXY() && CLIENT ) then

		local velocity = self:GetVelocity()
		velocity.z = 0

		local vecCurrentMoveYaw = Vector( velocity:GetNormalized():Dot( self:GetForward() ), velocity:GetNormalized():Dot( self:GetRight() ) )
		local flInvScale = math.max( math.abs( vecCurrentMoveYaw.x ), math.abs( vecCurrentMoveYaw.y ) );
		if ( flInvScale != 0.0 ) then
			vecCurrentMoveYaw.x = vecCurrentMoveYaw.x / flInvScale;
			vecCurrentMoveYaw.y =  vecCurrentMoveYaw.y / flInvScale;
		end

		self:SetPoseParameter( "move_x", vecCurrentMoveYaw.x )
		self:SetPoseParameter( "move_y", vecCurrentMoveYaw.y )

		local maxSpeed = self:GetSequenceGroundSpeed( self:GetSequence() )

		if ( maxSpeed > velocity:Length() ) then
			vecCurrentMoveYaw.x = vecCurrentMoveYaw.x * ( velocity:Length() / maxSpeed )
			vecCurrentMoveYaw.y = vecCurrentMoveYaw.y * ( velocity:Length() / maxSpeed )
		end
		self:SetPoseParameter( "move_x", vecCurrentMoveYaw.x )
		self:SetPoseParameter( "move_y", vecCurrentMoveYaw.y )

		-- This has to be on server to function :(
		--[[local scale = velocity:Length() / maxSpeed
		if ( maxSpeed != 0 ) then
			self:SetPlaybackRate( scale )
		end]]

	end

	if ( SERVER ) then
		-- Ugly hack because no replicated cvars for Lua :(
		self:SetHideBBox( GetConVarNumber( "rb655_easy_animation_nobbox_sv" ) > 0 )
	end

	-- Ensure the animation plays smoothly
	self:NextThink( CurTime() )
	return true

end

if ( SERVER ) then return end

function ENT:DrawBBox()

	if ( GetConVarNumber( "rb655_easy_animation_noglow" ) != 0 || self:GetHideBBox() ) then return end

	local wep = LocalPlayer():GetActiveWeapon()
	if ( !IsValid( wep ) || wep:GetClass() != "gmod_tool" && wep:GetClass() != "weapon_physgun" ) then
		return
	end

	local mins = self:OBBMins()
	local maxs = self:OBBMaxs()

	if ( self:GetSolid() == SOLID_BBOX ) then
		render.DrawWireframeBox( self:GetPos(), angle_zero, mins, maxs )
	else
		render.DrawWireframeBox( self:GetPos(), self:GetAngles(), mins, maxs )
	end

end

function ENT:Draw()

	self:DrawBBox()

	-- This probably shouldn't run every frame..
	self:SetRenderBounds( self:GetModelBounds() )

	self:DrawModel()

end

function ENT:DrawTranslucent()

	self:Draw()

end

--addons/arccw_weapons/lua/entities/rocket_emp/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "EMP Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 30
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 50 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 5 )
        smoke:SetEndSize( 20 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 155, 155, 255 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_rep_emp_rocket", self:GetPos(), self:GetAngles() )
					sound.Play( "weapons/star_wars_battlefront/common/exp_ord_haywireGrenade.wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        	 -- util.BlastDamage(self, self.Owner, self:GetPos(), 65, 100)
	 local ent = self.Owner
	if !IsValid(ent) then ent = self end
	 local t = DamageInfo()
			t:SetDamage(185)
			t:SetDamageType(DMG_SHOCK)
			t:SetAttacker(ent)
			t:SetInflictor(self)
	util.BlastDamageInfo(t, self:GetPos(), 400)
	util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
	  -- local targets = ents.FindInSphere(self:GetPos(), 256)
        -- for _, k in pairs(targets) do
            -- if k:IsPlayer() or k:IsNPC() or scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" ) then
                -- local regen = FrameTime() * 900
                -- k:SetHealth( math.Clamp( k:Health() - regen, 0, k:GetMaxHealth()+k:GetMaxHealth() ) )
				-- if(SERVER) then
				-- k:Ignite( 10 )
				-- end
			-- if !k:IsPlayer() or !k:IsNPC() then
				-- end
            -- end
        -- end
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(45, 85), math.random(45, 85), Color(175, 100, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/weapons_other/lua/entities/sent_breachingcharge/shared.lua:
////////////////////////////////////////////////////////////////
//  Breaching Charge, Entity
//  Programmed by Sevan Buechele
//  @   Copyright 2018 © Sevan Buechele
//  @   All Rights Reserved.
/////////////////////////////////////////////////////////////

/*|Entity Configuration|*/
ENT.Type		= "anim"
ENT.Base		= "base_anim"
ENT.Category	= "Sevan's Entities"
ENT.PrintName	= "Detpack"
ENT.Author		= "Sevan Buechele - Edit by Rino"
--ENT.Contact		= "STEAM_0:1:65313765"
ENT.Spawnable	= false
ENT.AdminOnly	= true
AddCSLuaFile()

/*|Entity Initialization|*/
function ENT:Initialize()
	self:SetModel("models/props/starwars/weapons/detpack.mdl")
	self:SetModelScale(1,0)
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self.physicsobj = self:GetPhysicsObject()
	if IsValid(self.physicsobj) then
		self.physicsobj:Wake()
		self.physicsobj:EnableMotion(false)
	end
	self:Activate()
	self:DrawShadow(true)
end

/*|Explode Function|*/
function ENT:Explode()
	local doortime = false
	local cvar1 = GetConVar("sv_breachingcharge_enabledoorbust")
	local cvar2 = GetConVar("sv_breachingcharge_enablepropunfreeze")
	cvar1 = cvar1:GetInt()
	cvar2 = cvar2:GetInt()
	if cvar1 == 1 then
		for k,v in pairs(ents.FindInSphere(self:GetPos(),40)) do
			if v:GetClass() == "func_door" || v:GetClass() == "prop_door_rotating" || v:GetClass() == "func_door_rotating" then
				v:Fire("lock","",0)
				v:Fire("Open","",0)
				v:SetNoDraw(true)
				v:SetCollisionGroup(COLLISION_GROUP_WORLD)
				v:CollisionRulesChanged()
				if !v.ent then
					v.ent = ents.Create("prop_physics")
					v.ent:SetModel(v:GetModel())
					if v:GetSkin() then
						v.ent:SetSkin(v:GetSkin())
					end
					v.ent:SetPos(v:GetPos()+self:GetUp()*-40)
					v.ent:SetAngles(v:GetAngles())
					v.ent:Spawn()
					v.ent:GetPhysicsObject():SetVelocityInstantaneous(self:GetUp()*-500)
				end
				timer.Simple(10,function()
					if v:IsValid() then
						v:SetCollisionGroup(COLLISION_GROUP_NONE)
						v:CollisionRulesChanged()
						v:Fire("unlock","",0)
						v:SetNoDraw(false)
						if v.ent:IsValid() then
							v.ent:Remove()
						end
					end
				end)
				doortime = true
			end
		end
	else
		for k,v in pairs(ents.FindInSphere(self:GetPos(),40)) do
			if v:GetClass() == "func_door" || v:GetClass() == "prop_door_rotating" || v:GetClass() == "func_door_rotating" then
				v:Fire("unlock","",0)
				v:Fire("Open","",0)
				doortime = true
			end
		end
	end
	for k,v in pairs(ents.FindInSphere(self:GetPos(),40)) do
		if v:GetClass() == "prop_physics" and v.isFadingDoor then
			v:fadeActivate()
			timer.Simple(4,function()
				if v:IsValid() then
					v:fadeDeactivate()
				end
			end)
			doortime = true
		elseif v:GetClass() == "prop_physics" and cvar2 == 1 then
			if v.isFadingDoor then return end
			v:GetPhysicsObject():EnableMotion(true)
		end
	end
	if doortime then
		util.BlastDamage(self,self,self:GetPos(),100,10)
	else
		util.BlastDamage(self,self,self:GetPos(),400,350)
	end
	self:Remove()
end

/*|Disarm Function|*/
function ENT:Disarm()
	self.disarm = true
	self:Remove()
end

/*|Spawn Function|*/
function ENT:SpawnFunction(ply,tr,cname)
	if (!tr.Hit) then return end
	local pos = tr.HitPos + tr.HitNormal
	local ang = ply:EyeAngles()
	ang.p = 0
	local ent = ents.Create(cname)
	ent.Owner = ply
	ent:SetPos(pos)
	ent:SetAngles(ang)
	ent:Spawn()
	return ent
end

/*|Think|*/
function ENT:Think()
	if self:GetParent() then
		local ent = self:GetParent()
		if ent:IsPlayer() then
			if !ent:Alive() then
				self:Explode()
			end
		end
	end
	self:NextThink(CurTime()+0.2)
end

/*|Entity VFX|*/
if CLIENT then
	function ENT:Initialize()
	end
	function ENT:Draw()
		self:DrawModel()
	end
	function ENT:OnRemove()
		local effectdata = EffectData()
		effectdata:SetOrigin(self:GetPos())
		util.Effect("Explosion",effectdata)
		util.Effect("HelicopterMegaBomb",effectdata)
		self:EmitSound("weapons/explode5.wav")
	end
end
--addons/weapons_other/lua/entities/sent_breachingchargeammo/shared.lua:
////////////////////////////////////////////////////////////////
//  Breaching Charge, Ammo Entity
//  Programmed by Sevan Buechele
//  @   Copyright 2018 © Sevan Buechele
//  @   All Rights Reserved.
/////////////////////////////////////////////////////////////

/*|Entity Configuration|*/
ENT.Type		= "anim"
ENT.Base		= "base_anim"
ENT.Category	= "Sevan's Ammo"
ENT.PrintName	= "Breaching Charges"
ENT.Author		= "Sevan Buechele"
ENT.Contact		= "STEAM_0:1:65313765"
ENT.Spawnable	= true
ENT.AdminOnly	= true
AddCSLuaFile()

/*|Entity Initialization|*/
function ENT:Initialize()
	self:SetModel("models/Items/item_item_crate.mdl")
	self:SetModelScale(1,0)
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self.physicsobj = self:GetPhysicsObject()
	if IsValid(self.physicsobj) then
		self.physicsobj:Wake()
	end
	self:Activate()
	self:DrawShadow(true)
	self:SetUseType(SIMPLE_USE)
end

/*|Use Function|*/
function ENT:Use(activator,caller,usetype)
	if caller:IsPlayer() then
		if caller:GetAmmoCount("ammo_breachingcharge") < 12 then
			caller:GiveAmmo(3,"ammo_breachingcharge")
			local ammocount = caller:GetAmmoCount("ammo_breachingcharge")
			caller:SetAmmo(math.Clamp(ammocount,0,12),"ammo_breachingcharge")
			self:Remove()
		end
	end
end

/*|Spawn Function|*/
function ENT:SpawnFunction(ply,tr,cname)
	if (!tr.Hit) then return end
	local pos = tr.HitPos + tr.HitNormal
	local ang = ply:EyeAngles()
	ang.p = 0
	local ent = ents.Create(cname)
	ent.Owner = ply
	ent:SetPos(pos)
	ent:SetAngles(ang)
	ent:Spawn()
	return ent
end

/*|Entity VFX|*/
if CLIENT then
	function ENT:Initialize()
	end
	function ENT:Think()
	end
	function ENT:Draw()
		self:DrawModel()
	end
	function ENT:OnRemove()
	end
end
--addons/joes_stuff/lua/entities/shield_5/shared.lua:
ENT.Type = "anim"
ENT.Base = "shield_base"
 
ENT.PrintName= "Shield Level 5"
ENT.Author= "Joe + JackJack"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true
ENT.shieldmodel = "models/jackjack/props/circle5.mdl"
ENT.health = 500
ENT.laserlength = 3240
ENT.radius = 3667
ENT.size = 1
--addons/sse_101/lua/entities/sse_datapad.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.PrintName		= "Datapad"
ENT.Spawnable       = true
ENT.ConfigName = "Datapad"
ENT.ClientInteraction = true
ENT.NoHudName = true
ENT.Category        = "SSE"
if SERVER then
        

    
    util.AddNetworkString("SSE_DataPad")

    function ENT:Use( activator, caller )

         self.DataPadData = self.DataPadData or "Nothing..."
        if self.ClientInteraction then 
            activator.SSE_CurrentEntity = self
            net.Start("SSE_DataPad")
                net.WriteEntity(self)
                net.WriteString(self.DataPadData)
            net.Send(activator)
        end
    end

    util.AddNetworkString("SSE_RecieveDatapad_Data")
    net.Receive("SSE_RecieveDatapad_Data", function(len, ply)

        if SSE:AntiSpam(ply) then return end
        local ent = net.ReadEntity()
        local data = net.ReadString()

        if !IsValid(ent) then return end
        if ent:GetClass() != "sse_datapad" then return end

        if !ent:ConfirmUse(ply) then return end
        
        ent.DataPadData = data

        ent:InvalidateUseConfirm(ply)
    end)


end



if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self)
    end




    net.Receive("SSE_DataPad", function()

        local ent = net.ReadEntity()
        local text = net.ReadString()
        
        if ValidPanel(SSE_DataPadFrame) then SSE_DataPadFrame:Remove() end
        SSE_DataPadFrame = SSE:DefaultFrame(ent:ConfigValue("FrameTitle"))
        SSE_DataPadFrame:SetSize(SSEW(600), SSEH(900))
        SSE_DataPadFrame:Center()

        local MultiLine = vgui.Create("DTextEntry", SSE_DataPadFrame)
        MultiLine:Dock(FILL)
        MultiLine:SetMultiline(true)
        MultiLine:SetEditable(true)
        MultiLine:SetFont(SSE.xFont(ent:ConfigValue("Font")))
        MultiLine:SetTextColor(Color(255, 255, 255))
        MultiLine:SetDrawBackground(false)
        MultiLine:SetDrawBorder(false)
        MultiLine:SetCursorColor(Color(255, 255, 255))
        MultiLine:SetVerticalScrollbarEnabled(true)
        MultiLine:SetValue(text)
        

        local bottomPanel = vgui.Create("DPanel", SSE_DataPadFrame)
        bottomPanel:Dock(BOTTOM)
        bottomPanel:SetTall(SSEH(50))
        bottomPanel:DockMargin(0, 0, 0, 0)
        bottomPanel.Paint = nil 

        local btnSave = SSE:Button(bottomPanel, ent:ConfigValue("Save"), function() 
            net.Start("SSE_RecieveDatapad_Data")
            net.WriteEntity(ent)
            net.WriteString(MultiLine:GetValue())
            net.SendToServer()

            SSE_DataPadFrame:Remove()
        
        end, "bc")
        btnSave:Dock(FILL)
        btnSave:DockMargin(0, 0, 0, 0)



    end)


end


--addons/sse_101/lua/entities/sse_lightswitch.lua:
AddCSLuaFile()



ENT.Base = "sse_base"

ENT.PrintName		= "Lightswitch"
ENT.Spawnable       = true
ENT.ConfigName = "Lightswitch"
ENT.Category        = "SSE"

if CLIENT then
    net.Receive("SSE_RedownloadLightmaps", function()
        render.RedownloadAllLightmaps(false, false)
    end)
    
end


if SERVER then

    util.AddNetworkString("SSE_RedownloadLightmaps")

    SSE_LIGHTS_STATUS = true
    function ENT:ToggleAllLights(state)

        -- list of light entity class names
        local lightClasses = {
            "light",
            "light_spot",
            "gmod_light",
            "env_projectedtexture",
            "point_tesla",
            "prop_dynamic_light",
            "spotlight_end",
            "point_spotlight",
            "light_dynamic",
        }

        if self:ConfigValue("EngineLightstyle")[game.GetMap()] then
           
            if state then
                engine.LightStyle(0, "m")
            else
                engine.LightStyle(0, "a")
            end
            net.Start("SSE_RedownloadLightmaps")
            net.Broadcast()

        end

        for _, ent in pairs(ents.GetAll()) do
            if lightClasses[ent:GetClass()] then
                if state then
                    ent:Fire("TurnOn")
                else
                    ent:Fire("TurnOff")
                end
       
            end
        end
    end




    function ENT:Use( activator, caller )

        if CurTime() - (self.LastUseTime or 0) >= self:ConfigValue("Delay") then
            self:ToggleAllLights(not SSE_LIGHTS_STATUS)
            SSE_LIGHTS_STATUS = not SSE_LIGHTS_STATUS
            self.LastUseTime = CurTime()

            -- Emit Electric Shutdown Sound 
            activator:EmitSound("ambient/levels/labs/electric_explosion1.wav")

        else
            -- Emit Error Sound
            activator:EmitSound("buttons/button10.wav")
        end

    end


end


--addons/aoc_nextbots/lua/entities/summe_bombadement.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.PrintName = "AOCRPNextbots Bombadement Marker"
ENT.Category = "Other"

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel("models/props_borealis/bluebarrel001.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)

        self.flightvector = self:GetForward() * ((110 * 52.5) / 66)

        self.Glow = ents.Create("env_sprite")
        self.Glow:SetKeyValue("model", "orangecore2.vmt")
        self.Glow:SetKeyValue("rendercolor", "235 52 222")
        self.Glow:SetKeyValue("scale", "0.3")
        self.Glow:SetPos(self:GetPos())
        self.Glow:SetParent(self)
        self.Glow:Spawn()
        self.Glow:Activate()

        self:DrawShadow(true)
        self:SpawnMissles()
    else
        self.Emitter = ParticleEmitter(self:GetPos())
    end

    self.Delay = CurTime() + 3
    self.Damage = 40
end

if SERVER then
    function ENT:SpawnMissles()
        for i = 1, 15 do
            local missle = ents.Create("summe_b2missle")
            missle:SetPos(self:GetPos() + Vector(math.random(-700, 700), math.random(-700, 700), math.random(2000, 4500)))
            missle:SetAngles(Angle(90, 0, 0))
            missle:SetOwner(self)
            missle.Speed = 80
            missle:Spawn()
        end
    end
end
--addons/arccw_weapons/lua/entities/tfa_thrown_blade/shared.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

ENT.Type = "anim"
ENT.PrintName = "Thrown Blade"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true

ENT.HitSounds = {
	[MAT_DIRT] = {Sound("physics/metal/metal_grenade_impact_hard1.wav"), Sound("physics/metal/metal_grenade_impact_hard2.wav"), Sound("physics/metal/metal_grenade_impact_hard3.wav")},
	[MAT_FLESH] = {Sound("physics/flesh/flesh_impact_bullet1.wav"), Sound("physics/flesh/flesh_impact_bullet2.wav"), Sound("physics/flesh/flesh_impact_bullet3.wav")}
}

ENT.ImpactSound = Sound("weapons/blades/impact.mp3")
--addons/aocrp_emplacements/lua/entities/turret_bullets2/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "Emplacements"
ENT.PrintName 		= "14mm Turret"
ENT.Author			= "Wolly/BOT_09"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.TurretFloatHeight=3
ENT.TurretModelOffset=Vector(0,0,44)
ENT.TurretTurnMax=0.7

ENT.LastShot=0
ENT.ShotInterval=0.4


function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:DTVar("Entity",1,"ShootPos")
end

function ENT:SetShooter(plr)
	self.Shooter=plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self.Shooter then
			self:SetShooter(nil)
			self:FinishShooting()
			
		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self.Shooter
	elseif CLIENT then
		shooter=self:GetDTEntity(0)
	end
	
	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=90)
end



function ENT:DoShot()
	
	
	if self.LastShot+self.ShotInterval<CurTime() then
		if SERVER then
			
			local effectPosAng=self:GetAttachment(self.MuzzleAttachment)
			local vPoint = effectPosAng.Pos
			local effectdata = EffectData()
			effectdata:SetStart( vPoint )
			effectdata:SetOrigin( vPoint )
			effectdata:SetAngles(effectPosAng.Ang + Angle(0,-90,0))
			effectdata:SetEntity(self)
			effectdata:SetScale( 1 )
			util.Effect( "MuzzleEffect", effectdata )
			
		--elseif SERVER then
			self:EmitSound(self.ShotSound,50,100)
			
			
		end
		
		if IsValid(self.shootPos) and SERVER then
			
			self.shootPos:FireBullets({
				Num=1,
				Src=self.shootPos:GetPos()+self.shootPos:GetAngles():Up()*10,
				Dir=self.shootPos:GetAngles():Up()*1,
				Spread=Vector(0.005,0.005,0),
				Tracer=0,
				Force=50,
				Damage=55,
				Attacker=self.Shooter,
				Callback=function(attacker,trace,dmginfo) 
					--if CLIENT then
						
						local tracerEffect=EffectData()
						tracerEffect:SetStart(self.shootPos:GetPos())
						tracerEffect:SetOrigin(trace.HitPos)
						tracerEffect:SetScale(6000)
						util.Effect("Tracer",tracerEffect)
						if(!trace.HitSky)then
						local effectdata = EffectData()
						effectdata:SetOrigin(trace.HitPos)
						effectdata:SetScale(1.2)
						effectdata:SetRadius(trace.MatType)
						effectdata:SetNormal(trace.HitNormal)
						util.Effect("gdcw_universal_impact_t",effectdata)
						end
					--end
					
				end
			})
			self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*-10000 )
			
			
			
		end
		
		self.LastShot=CurTime()
	end
	
end



function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		--[[if IsValid(self.shootPos) or self.shootPos==NULL then
			if CLIENT then
				
				self.shootPos=self:GetDTEntity(1)
			elseif SERVER then
				
				self:SetDTEntity(1,self.shootPos)
			end
		end]]
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=(self.turretBase:GetAngles():Right()*-1):DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),-90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end
	end
end	
--lua/entities/turret_eweb/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "[SWRP] Emplacements"
ENT.PrintName 		= "Clone Wars E-Web"
ENT.Author			= "JohnyReaper & Macieg"
ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.TurretFloatHeight=0
ENT.TurretModelOffset=Vector(0,-50,50)
ENT.TurretTurnMax=0.7

ENT.LastShot=0
ENT.ShotInterval=0.15

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetupDataTables()
	self:NetworkVar("Entity",0,"Shooter")
	self:NetworkVar("Entity",1,"ShootPos")
	self:NetworkVar("Entity",2,"TurretBase")
	self:NetworkVar( "Int", 0, "TAmmo" )
end

-- function ENT:SetShooter(plr)
-- 	self.Shooter=plr
-- 	self:SetDTEntity(0,plr)
-- end

function ENT:GetShooter(plr)
	if SERVER then
		return self:GetShooter()
	elseif CLIENT then
		return self:GetShooter()
	end
end


function ENT:Use(plr)
	
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self:GetShooter() then
			self:SetShooter(nil)
			self:FinishShooting()
			
		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self:GetShooter()
	elseif CLIENT then
		shooter=self:GetShooter()
	end
--self.shootPos:GetPos():DistToSqr(shooter:GetPos()) >= 20000 )
	return IsValid(shooter) and shooter:Alive() and (self:GetPos():DistToSqr(shooter:GetPos()) <= 7000)-- ((self:GetPos()+self.TurretModelOffset):DistToSqr(shooter:GetShootPos())<=600)
end

function ENT:GetCrosshairFilterEnts()
	return {self, self.turretBase, self.shootPos}
end

function ENT:LVSFireBullet( data )
	data.Entity = self
	data.Velocity = data.Velocity + self:GetVelocity():Length()
	-- data.Filter = self:GetCrosshairFilterEnts()
	data.SrcEntity = self:WorldToLocal( data.Src )

	LVS:FireBullet( data )
end

function ENT:DoShot()
	
	
	if self.LastShot+self.ShotInterval<CurTime() then

		if (SERVER) then

			if (self:GetTAmmo() > 0) then

				-- if SERVER then
					
					local effectPosAng=self:GetAttachment(self.MuzzleAttachment)

					-- local BonePos, BoneAng = self:GetBonePosition(1)
					-- if BonePos == self:GetPos() then
					-- 	BonePos, BoneAng = self:GetBoneMatrix(1):GetTranslation()
					-- end

					local vPoint = effectPosAng.Pos
					-- local effectdata = EffectData()
					-- effectdata:SetStart( vPoint )
					-- effectdata:SetOrigin( vPoint )
					-- effectdata:SetAngles(effectPosAng.Ang)
					-- effectdata:SetEntity(self)
					-- effectdata:SetScale( 1 )
					-- util.Effect( "MuzzleEffect", effectdata )

					local effectdata = EffectData()
					-- effectdata:SetStart( vPoint )
					effectdata:SetStart( Vector(50,50,255) )
					effectdata:SetOrigin( vPoint )
					effectdata:SetNormal( self.shootPos:GetAngles():Forward()*100 )
					effectdata:SetAngles(effectPosAng.Ang)
					effectdata:SetEntity( self )
					effectdata:SetScale( 100 )
					util.Effect( "lvs_muzzle_colorable", effectdata )
					
				--elseif SERVER then
					self:EmitSound(self.ShotSound,50,100)
					
					
				-- end
				
				if IsValid(self.shootPos) and SERVER then

					local dir = (self:GetDesiredShootPos() - self.shootPos:GetPos()):GetNormalized()
					
					-- if (LVS) then

					-- 	local bullet = {}
					-- 	bullet.Src 	= self.shootPos:GetPos() + self.shootPos:GetAngles():Forward()*10
					-- 	bullet.Dir 	= self.shootPos:GetAngles():Forward()*1
					-- 	bullet.Spread 	= Vector( 0.02,  0.02, 0 )
					-- 	bullet.Tracer = 1
					-- 	bullet.TracerName = "lvs_laser_blue_short"
					-- 	bullet.Force	= 2
					-- 	bullet.HullSize 	= 30
					-- 	bullet.Damage	= 50
					-- 	bullet.SplashDamage = 200
					-- 	bullet.SplashDamageRadius = 200
					-- 	bullet.Velocity = 8000
					-- 	bullet.Attacker 	= self.Shooter
					-- 	bullet.Callback = function(att, tr, dmginfo)
					-- 		local effectdata = EffectData()
					-- 			effectdata:SetStart( Vector(50,50,255) ) 
					-- 			effectdata:SetOrigin( tr.HitPos )
					-- 		util.Effect( "lvs_laser_explosion", effectdata )
					-- 	end
					-- 	self:LVSFireBullet( bullet )


					-- else

						self.shootPos:FireBullets({
							Num=1,
							Src=self.shootPos:GetPos()+self.shootPos:GetAngles():Forward()*40,
							Dir=self.shootPos:GetAngles():Forward()*1,
							Spread=Vector(0.02,0.02,0),
							-- Tracer=1,
							-- TracerName = "lvs_laser_blue_short",
							HullSize 	= 30,
							Force=2,
							Damage=50,
							Attacker=self.Shooter,
							Callback=function(attacker,trace,dmginfo) 
								--if CLIENT then
										
									local effectdata = EffectData()
										effectdata:SetStart( Vector(50,50,255) ) 
										effectdata:SetOrigin( trace.HitPos )
									util.Effect( "lvs_laser_explosion", effectdata )

									local tracerEffect=EffectData()
									tracerEffect:SetStart(self.shootPos:GetPos())
									tracerEffect:SetOrigin(trace.HitPos)
									-- tracerEffect:SetScale(6000)
									util.Effect("blue_tracer_fx",tracerEffect)
								--end
								
							end
						})
					-- end

					self:TakeAmmo()

					self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*-500 )
					
					
				end
			else
				self:EmitSound(self.EmptySound,50,100)
			end
		end

		self.LastShot=CurTime()
	end
	
end



function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		--[[if IsValid(self.shootPos) or self.shootPos==NULL then
			if CLIENT then
				
				self.shootPos=self:GetDTEntity(1)
			elseif SERVER then
				
				self:SetDTEntity(1,self.shootPos)
			end
		end]]
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1


				if self.MagazineCollider then
					self.MagazineCollider:SetPos(self.turretBase:GetPos() + self.turretBase:GetUp() * 5 + self.turretBase:GetForward()*10 + self.turretBase:GetRight()*-80)
					self.MagazineCollider:SetAngles(self.turretBase:GetAngles() + Angle(0,90,0))
				end

			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=self.turretBase:GetAngles():Right():DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					-- if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),-90)
						
						
						self.OffsetAng=offsetAngNew
						-- self.OffsetAng = LerpAngle( 0.025, self.OffsetAng, offsetAngNew )
						local Vertical = math.Clamp(self.OffsetAng.z, -31, 30)
						self:ManipulateBoneAngles(1, Angle(0,Vertical,0))
						
					-- end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					-- self.OffsetAng=self.turretBase:GetAngles()
					-- self:ManipulateBoneAngles(1, Angle(0,0,0))
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end
	end
end	
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_energy_hmg/init.lua:
EFFECT.TracerName = "tfa_apex_energy_tracer_mach"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_energy_smg/init.lua:
EFFECT.TracerName = "tfa_apex_energy_tracer_smg"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_base_modified/lua/effects/arccw_incendiaryround.lua:
local images_muzzle = {"effects/muzzleflash1", "effects/muzzleflash2", "effects/muzzleflash3", "effects/muzzleflash4"}
local images_smoke = {"particle/smokesprites_0001", "particle/smokesprites_0002", "particle/smokesprites_0003", "particle/smokesprites_0004", "particle/smokesprites_0005", "particle/smokesprites_0006", "particle/smokesprites_0007", "particle/smokesprites_0008", "particle/smokesprites_0009", "particle/smokesprites_0010", "particle/smokesprites_0011", "particle/smokesprites_0012", "particle/smokesprites_0013", "particle/smokesprites_0014", "particle/smokesprites_0015", "particle/smokesprites_0016"}

local function TableRandomChoice(tbl)
    return tbl[math.random(#tbl)]
end

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()

    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )

    for i = 0,3 do
        local particle = emitter:Add( TableRandomChoice(images_smoke) , self.Origin )
        local scol = math.Rand( 200, 225 )

        particle:SetVelocity( 50 * VectorRand() )
        particle:SetDieTime( math.Rand(0.2, 0.5) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,30) )
        particle:SetEndSize( math.Rand(50,75) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( scol,scol,scol )
        particle:SetAirResistance( 100 )
        particle:SetGravity( Vector( math.Rand(-30,30) ,math.Rand(-30,30),math.Rand(10,40)) )
        particle:SetLighting( true )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    local particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 0.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 100 )
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    for i = 0, 2 do
        local fire = emitter:Add( TableRandomChoice(images_muzzle), self.Origin )
        fire:SetVelocity(VectorRand() * 100)
        fire:SetAirResistance( 0 )
        fire:SetDieTime( 0.25 )
        fire:SetStartAlpha( 255 )
        fire:SetEndAlpha( 0 )
        fire:SetEndSize( 0 )
        fire:SetStartSize( 50 )
        fire:SetRoll( math.Rand(180,480) )
        fire:SetRollDelta( math.Rand(-1,1) )
        fire:SetColor( 255, 255, 255 )
    end

    local light = DynamicLight(self:EntIndex())
    if (light) then
        light.Pos = self.Origin
        light.r = 255
        light.g = 206
        light.b = 122
        light.Brightness = 5
        light.Decay = 2500
        light.Size = 256
        light.DieTime = CurTime() + 0.1
    end

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_base_modified/lua/effects/arccw_muzzleeffect.lua:
function EFFECT:Init(data)
    local pos = data:GetOrigin()
    local wpn = data:GetEntity()

    if !IsValid(wpn) then return end

    local muzzle = wpn.MuzzleEffect
    local overridemuzzle = wpn:GetBuff_Override("Override_MuzzleEffect")

    local gmmuzzle = wpn:GetBuff_Override("Override_GMMuzzleEffect") or wpn.GMMuzzleEffect

    muzzle = overridemuzzle or muzzle

    if wpn.GetInUBGL and wpn:GetInUBGL() then
        muzzle = wpn:GetBuff_Override("UBGL_MuzzleEffect") or muzzle
    end

    if ArcCW.ConVars["fastmuzzles"]:GetBool() then
        muzzle = wpn.FastMuzzleEffect or "CS_MuzzleFlash"

        gmmuzzle = true

        if overridemuzzle then
            muzzle = nil
        end

        muzzle = wpn:GetBuff_Override("Override_FastMuzzleEffect") or muzzle
    end

    local att = data:GetAttachment() or 1

    local wm = false

    local Owner = wpn:GetOwner()
    if (LocalPlayer():ShouldDrawLocalPlayer() or Owner != LocalPlayer()) and !wpn.AlwaysWM then
        wm = true
        att = 1
    end

    if Owner != LocalPlayer() and !ArcCW.ConVars["muzzleeffects"]:GetBool() then
        return
    end

    local mdl = wpn:GetMuzzleDevice(wm)
    local parent = mdl

    if !wm then
        parent = LocalPlayer():GetViewModel()
    end

    if !IsValid(mdl) then return end

    pos = (mdl:GetAttachment(att) or {}).Pos
    ang = (mdl:GetAttachment(att) or {}).Ang

    if gmmuzzle then
        if muzzle then
            if !pos then return end

            local fx = EffectData()

            fx:SetOrigin(pos)
            fx:SetEntity(parent)
            fx:SetAttachment(att)
            fx:SetNormal((ang or Angle(0, 0, 0)):Forward())
            fx:SetStart(pos)
            fx:SetScale(1)

            util.Effect(muzzle, fx)
        end
    else
        if muzzle then
            ParticleEffectAttach(muzzle, PATTACH_POINT_FOLLOW, mdl, att)
        end
    end

    if !pos then return end

    if !ArcCW.ConVars["fastmuzzles"]:GetBool() and !wpn.NoFlash
            and !wpn:GetBuff_Override("Silencer")
            and !wpn:GetBuff_Override("FlashHider") then
        local light = DynamicLight(self:EntIndex())
        local clr = wpn:GetBuff_Override("Override_MuzzleFlashColor", wpn.MuzzleFlashColor) or Color(244, 209, 66)
        if (light) then
            light.Pos = pos
            light.r = clr.r
            light.g = clr.g
            light.b = clr.b
            light.Brightness = 2
            light.Decay = 2500
            light.Size = Owner == LocalPlayer() and 256 or 128
            light.DieTime = CurTime() + 0.1
        end
    end
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    return false
end
--addons/arccw_base_modified/lua/effects/arccw_tracer.lua:
EFFECT.StartPos = Vector(0, 0, 0)
EFFECT.EndPos = Vector(0, 0, 0)
EFFECT.StartTime = 0
EFFECT.LifeTime = 0.2
EFFECT.LifeTime2 = 0.2
EFFECT.DieTime = 0
EFFECT.Color = Color(255, 255, 255)
EFFECT.Speed = 15000

local head = Material("effects/whiteflare")
local tracer = Material("arccw/tracer")
local smoke = Material("trails/smoke")
local smoker, smoked = Color(155, 155, 155, 155), Color(155, 155, 155, 0)

function EFFECT:Init(data)

    local hit = data:GetOrigin()
    local wep = data:GetEntity()

    if !IsValid(wep) then return end

    local speed = data:GetScale()
    local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()

    if ArcCW.ConVars["fasttracers"]:GetBool() then
            local fx = EffectData()
            fx:SetOrigin(hit)
            fx:SetEntity(wep)
            fx:SetStart(start)
            fx:SetScale(4000)
            util.Effect("tracer", fx)
            self:Remove()
        return -- was it ever really necessary? yes, to not use the dog-shit tracers that used to ship with this
    end

    local diff = hit - start

    if speed > 0 then
        self.Speed = speed
    end

    local profile = 0
    if wep.GetBuff_Override then
        profile = wep:GetBuff_Override("Override_PhysTracerProfile", wep.PhysTracerProfile) or 0
        if isnumber(profile) then profile = ArcCW.BulletProfileDict[ArcCW.BulletProfiles[profile]] end
    end

    self.LifeTime = (hit - start):Length() / self.Speed

    self.StartTime = UnPredictedCurTime()
    self.DieTime = UnPredictedCurTime() + math.max(self.LifeTime, self.LifeTime2)
    self.Dir = diff:GetNormalized()

    self.StartPos = start
    self.EndPos = hit
    self.Color = (ArcCW.BulletProfileDict[profile] or ArcCW.BulletProfileDict["default0"]).color
end

function EFFECT:Think()
    return self.DieTime > UnPredictedCurTime()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

function EFFECT:Render()
    local d = (UnPredictedCurTime() - self.StartTime) / self.LifeTime
    local d2 = (UnPredictedCurTime() - self.StartTime) / self.LifeTime2
    local startpos = self.StartPos + (d * 0.1 * (self.EndPos - self.StartPos))
    local endpos = self.StartPos + (d * (self.EndPos - self.StartPos))
    local size = math.Clamp(math.log(EyePos():DistToSqr(endpos) - math.pow(256, 2)), 0, math.huge)

    local col = self.Color --LerpColor(d, self.Color, Color(0, 0, 0, 0))
    local col2 = LerpColor(d2, smoker, smoked)

    local vel = self.Dir * self.Speed - LocalPlayer():GetVelocity()
    local dot = math.abs(EyeAngles():Forward():Dot(vel:GetNormalized()))
    --dot = math.Clamp(((dot * dot) - 0.25) * 5, 0, 1)
    local headsize = size * dot * 2
    render.SetMaterial(head)
    render.DrawSprite(endpos, headsize, headsize, col)

    local tail = (self.Dir * math.min(self.Speed / 25, 512, (endpos - startpos):Length() - 64))
    render.SetMaterial(tracer)
    render.DrawBeam(endpos, endpos - tail, size * 0.75, 0, 1, col)

    render.SetMaterial(smoke)
    render.DrawBeam( endpos - tail, startpos, size * d2, 0, 1, col2)
end

--lua/effects/arccw_uc_confetti.lua:

function EFFECT:Init( data )

	local vOffset = data:GetOrigin()

	sound.Play( "garrysmod/balloon_pop_cute.wav", vOffset, 90, math.random( 90, 120 ) )

	local NumParticles = 48

	local emitter = ParticleEmitter( vOffset, true )

	for i = 0, NumParticles do
		local Color = Color(math.random(255), math.random(255), math.random(255))
		local Pos = Vector( math.Rand( -0.5, 0.5 ), math.Rand( -0.5, 0.5 ), math.Rand( -0.5, 0.5 ) ) + data:GetStart()

		local particle = emitter:Add( "particles/balloon_bit", vOffset + Pos * 8 )
		if ( particle ) then

			particle:SetVelocity( Pos * 600 )

			particle:SetLifeTime( 0 )
			particle:SetDieTime( 10 )

			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 255 )

			local Size = math.Rand( 1, 2 )
			particle:SetStartSize( Size )
			particle:SetEndSize( 0 )

			particle:SetRoll( math.Rand( 0, 360 ) )
			particle:SetRollDelta( math.Rand( -2, 2 ) )

			particle:SetAirResistance( 80 )
			particle:SetGravity( Vector( 0, 0, -300 ) )

			local RandDarkness = math.Rand( 0.8, 1.0 )
			particle:SetColor( Color.r * RandDarkness, Color.g * RandDarkness, Color.b * RandDarkness )

			particle:SetCollide( true )

			particle:SetAngleVelocity( Angle( math.Rand( -160, 160 ), math.Rand( -160, 160 ), math.Rand( -160, 160 ) ) )

			particle:SetBounce( 0 )
			particle:SetLighting( true )

		end

	end

	emitter:Finish()

end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/arccw_uc_tracer.lua:
EFFECT.StartPos = Vector(0, 0, 0)
EFFECT.EndPos = Vector(0, 0, 0)
EFFECT.StartTime = 0
EFFECT.LifeTime = 0.2
EFFECT.LifeTime2 = 0.15
EFFECT.DieTime = 0
EFFECT.Color = Color(255, 255, 255)
EFFECT.Speed = 6000

local head = Material("effects/whiteflare")
local tracer = Material("effects/smoke_trail")
local smoke = Material("trails/smoke")

function EFFECT:Init(data)

    local hit = data:GetOrigin()
    local wep = data:GetEntity()

    if !IsValid(wep) then return end

    local speed = data:GetScale()
    local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()

    --[[]
    if GetConVar("arccw_fasttracers"):GetBool() then
            local fx = EffectData()
            fx:SetOrigin(hit)
            fx:SetEntity(wep)
            fx:SetStart(start)
            fx:SetScale(4000)
            util.Effect("tracer", fx)
            self:Remove()
        return
    end
    ]]

    if speed > 0 then
        self.Speed = speed
    end

    local profile = 0
    if wep.GetBuff_Override then
        profile = wep:GetBuff_Override("Override_PhysTracerProfile", wep.PhysTracerProfile) or 0
        if isnumber(profile) then profile = ArcCW.BulletProfileDict[ArcCW.BulletProfiles[profile]] end
    end

    self.LifeTime = (hit - start):Length() / self.Speed

    self.StartTime = UnPredictedCurTime()
    self.DieTime = UnPredictedCurTime() + math.max(self.LifeTime, self.LifeTime2)

    self.StartPos = start
    self.EndPos = hit
    self.Color = (ArcCW.BulletProfileDict[profile] or ArcCW.BulletProfileDict["default0"]).color

    -- print(profile)
end

function EFFECT:Think()
    return self.DieTime > UnPredictedCurTime()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

function EFFECT:Render()
    local d = (UnPredictedCurTime() - self.StartTime) / self.LifeTime
    local d2 = (UnPredictedCurTime() - self.StartTime) / self.LifeTime2
    local startpos = self.StartPos + (d * 0.15 * (self.EndPos - self.StartPos))
    local endpos = self.StartPos + (d * (self.EndPos - self.StartPos))
    local size = 2

    local col = LerpColor(d, self.Color, Color(0, 0, 0, 255))
    local col2 = LerpColor(d2, Color(255, 255, 255, 127), Color(0, 0, 0, 0))

    render.SetMaterial(head)
    render.DrawSprite(endpos, size * 3, size * 3, col)

    render.SetMaterial(tracer)
    render.DrawBeam(endpos, startpos, size * 2, 0, 1, col)

    render.SetMaterial(smoke)
    render.DrawBeam(self.EndPos, self.StartPos, size * 0.5 * d2, 0, 1, col2)
end

--addons/arccw_weapons/lua/effects/astw2_halo3_explosion_bruteshot/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 225
            light.g = 155
            light.b = 200
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/explosive_burst", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 225, 215, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	



    for i = 0,5 do
        particle = emitter:Add( "effects/halo3/flare1" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.15, 0.25) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(10,15) )
        particle:SetEndSize( math.Rand(175,200) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo3/electric_arcs", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(150,175) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,200,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_halo3_explosion_rocket/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 135
            light.b = 100
            light.Brightness = 3
            light.Decay = 10
            light.Size = 724
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/8pt_ringed_star_flare", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	

    for i= 0,5 do
   local particle = emitter:Add("effects/halo3/smoke_dark", self.Origin)

    particle:SetVelocity( Vector(math.Rand(-100, 100),math.Rand(-100, 100),math.Rand(250, 400)) )
    particle:SetDieTime( math.Rand(2,3) )
    particle:SetStartAlpha( 25 )
    particle:SetEndAlpha( 100 )
    particle:SetStartSize( math.Rand(95,100) )
    particle:SetEndSize( math.Rand(125,135) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 155, 155 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-325,-425) ) )
    particle:SetLighting( true )
    particle:SetCollide( false )
	end

		for i= 0,5 do
        particle = emitter:Add( "effects/halo3/explosion" .. math.random(2,4) , self.Origin )
        particle:SetVelocity( 7 * Vector(math.Rand(-50, 50),math.Rand(-50, 50),math.Rand(20, 50)) )
        particle:SetDieTime( math.Rand(0.5, 0.7) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(50,75) )
        particle:SetEndSize( math.Rand(125,150) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,math.Rand( 200, 225 ),math.Rand( 175, 200 ) )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,25) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	end

    for i = 0,5 do
        particle = emitter:Add( "effects/halo3/explosion1" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.2, 0.3) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(175,225) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo3/explosive_burst", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(225,550) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,200,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_halo_ce_explosion_frag/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 225
            light.g = 155
            light.b = 200
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo_ce/flare_generic2", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	

		for i= 0,5 do
	  local particle = emitter:Add("effects/halo3/smoke_dark", self.Origin)

    particle:SetVelocity( Vector(math.Rand(75, 100),math.Rand(75, 100),math.Rand(300, 750)) )
    particle:SetDieTime( math.Rand(2,3) )
    particle:SetStartAlpha( 55 )
    particle:SetEndAlpha( 255 )
    particle:SetStartSize( math.Rand(95,100) )
    particle:SetEndSize( math.Rand(125,135) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 255, 225, 225 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-325,-425) ) )
    particle:SetLighting( true )
    particle:SetCollide( false )
	end

    for i = 0,5 do
        particle = emitter:Add( "effects/halo_ce/flare_generic" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.15, 0.2) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(175,225) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo_ce/flare_generic2a", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.15, 0.2) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,200,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end 
--addons/arccw_weapons/lua/effects/astw2_halo_ce_explosion_rocket/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 225
            light.g = 155
            light.b = 200
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo_ce/flare_generic2", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	

		for i= 0,5 do
	  local particle = emitter:Add("effects/halo3/smoke_dark", self.Origin)

    particle:SetVelocity( Vector(math.Rand(75, 100),math.Rand(75, 100),math.Rand(300, 750)) )
    particle:SetDieTime( math.Rand(2,3) )
    particle:SetStartAlpha( 55 )
    particle:SetEndAlpha( 255 )
    particle:SetStartSize( math.Rand(95,100) )
    particle:SetEndSize( math.Rand(125,135) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 255, 225, 225 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-325,-425) ) )
    particle:SetLighting( true )
    particle:SetCollide( false )
	end

    for i = 0,5 do
        particle = emitter:Add( "effects/halo_ce/flare_generic" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.15, 0.2) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(175,225) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo_ce/flare_generic2a", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.15, 0.2) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,200,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_haloreach_explosion_stickylauncher/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 155
            light.g = 155
            light.b = 255
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
		
		
		
    local particle = emitter:Add("effects/halo3/muzzle_flash_round_fiery", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.35 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 215, 215, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	
    local particle = emitter:Add("effects/halo3/explosive_burst", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 215, 215, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	


	
		for i= 0,3 do
	  local particle = emitter:Add("effects/halo3/smoke_directional_large", self.Origin)

    particle:SetVelocity( Vector(0,math.Rand(75, 100),math.Rand(65, 125)) )
    particle:SetDieTime( math.Rand(1,1.5) )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(25,75) )
    particle:SetEndSize( math.Rand(300,350) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 55, 55, 255 )
    particle:SetAirResistance( 755 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-10,50) ) )
    particle:SetLighting( false )
    particle:SetCollide( false )
	end

    particle = emitter:Add( "effects/halo_reach/emp_mask", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 155,155,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
		
	    particle = emitter:Add( "effects/halo_reach/plasma_bolt", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 155,155,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	
    particle = emitter:Add( "effects/halo3/electric_arcs", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.5, 0.7) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(300,325) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 185,185,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_br/init.lua:

local Tracer = Material( "effects/halo2/contrail_human" )
local Tracer2  = Material( "effects/halo2/condensation_contrail" )
local Width = 3
local Width2 = 16

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.15
	self.LifeTime2 = 0.25 * 1/2
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 225
	local b = 200
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 225, 155, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( r, b, g, (v2 * 50)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_sniperrifle/init.lua:

local Tracer = Material( "effects/halo3/trails/trail_sniper_ce" )
local Width = 18

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.85
	self.DieTime = CurTime() + self.LifeTime

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*1/2, 0, (self.Dist/12)*math.Rand(-2,2), Color( 225, 255, 255, v * 100 ) )
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_bruteplasmarifle/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_reach/trail_red" );
local MaterialFront			= Material( "effects/swbf/redlaser" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_yellow/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swbf/yellowlaser_bolt" );
local MaterialFront			= Material( "effects/swbf/yellowlaser" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/aoc_nextbots/lua/effects/effect_npc_laser_green.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6

EFFECT.Speed = 6500
EFFECT.Length = 64
EFFECT.WhizDistance = 72

local MaterialMain = Material("effects/sw_laser_green_main")
local MaterialFront = Material("effects/sw_laser_green_front")
local MaterialGlow = Material("sprites/light_glow02_add")
local ColorRed = Color(0, 255, 34)

function EFFECT:GetTracerOrigin(data)
    local start = data:GetStart()

    if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
        local entity = data:GetEntity()

        if (not IsValid(entity)) then
            return start
        end
        if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then
            return start
        end

        if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
            local pl = entity:GetOwner()
            if (IsValid(pl)) then
                local vm = pl:GetViewModel()
                if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
                    entity = vm
                else
                    if (entity.WorldModel) then
                        entity:SetModel(entity.WorldModel)
                    end
                end
            end
        end

        local attachment = entity:GetAttachment(data:GetAttachment())
        if (attachment) then
            start = attachment.Pos
        end
    end

    return start
end

function EFFECT:Init(data)
    self.StartPos = self:GetTracerOrigin(data)
    self.EndPos = data:GetOrigin()

    self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)

    local diff = (self.EndPos - self.StartPos)

    self.Normal = diff:GetNormal()
    self.StartTime = 0
    self.LifeTime = (diff:Length() + self.Length) / self.Speed

    local weapon = data:GetEntity()
    if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
        local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
    end
end

function EFFECT:Think()
    self.LifeTime = self.LifeTime - FrameTime()
    self.StartTime = self.StartTime + FrameTime()

    return self.LifeTime > 0
end

function EFFECT:Render()
    local endDistance = self.Speed * self.StartTime
    local startDistance = endDistance - self.Length

    startDistance = math.max(0, startDistance)
    endDistance = math.max(0, endDistance)

    local startPos = self.StartPos + self.Normal * startDistance
    local endPos = self.StartPos + self.Normal * endDistance

    render.SetMaterial(MaterialFront)
    render.DrawSprite(endPos, 8, 8, color_white)

    render.SetMaterial(MaterialMain)
    render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)

    render.SetMaterial(MaterialGlow)
    render.DrawSprite(startPos, 50, 50, ColorRed)
end

--addons/aocrp_emplacements/lua/effects/gdca_cinematicboom_t/init.lua:

					//Sound,Impact

					// 1        2       3      4      5
					//Dirt, Concrete, Metal, Glass, Flesh

					// 1     2     3      4      5      6      7      8         9
					//Dust, Dirt, Sand, Metal, Smoke, Wood,  Glass, Blood, YellowBlood
local mats={				
	[MAT_ALIENFLESH]		={5,9},
	[MAT_ANTLION]			={5,9},
	[MAT_BLOODYFLESH]		={5,8},
	[45]				={5,8},	// Metrocop heads are a source glitch, they have no enumeration
	[MAT_CLIP]			={3,5},
	[MAT_COMPUTER]			={4,5},
	[MAT_FLESH]			={5,8},
	[MAT_GRATE]			={3,4},
	[MAT_METAL]			={3,4},
	[MAT_PLASTIC]			={2,5},
	[MAT_SLOSH]			={5,5},
	[MAT_VENT]			={3,4},
	[MAT_FOLIAGE]			={1,5},
	[MAT_TILE]			={2,5},
	[MAT_CONCRETE]			={2,1},
	[MAT_DIRT]			={1,2},
	[MAT_SAND]			={1,3},
	[MAT_WOOD]			={2,6},
	[MAT_GLASS]			={4,7},
}


function EFFECT:Init(data)
self.Entity 		= data:GetEntity()		// Entity determines what is creating the dynamic light			//
self.Pos 		= data:GetOrigin()		// Origin determines the global position of the effect			//
self.Scale 		= data:GetScale()*0.8		// Scale determines how large the effect is				//
self.Radius 		= data:GetRadius() or 1		// Radius determines what type of effect to create, default is Concrete	//
self.DirVec 		= data:GetNormal()		// Normal determines the direction of impact for the effect		//
self.PenVec 		= data:GetStart()		// PenVec determines the direction of the round for penetrations	//
self.Particles 		= data:GetMagnitude()		// Particles determines how many puffs to make, primarily for "trails"	//
self.Angle 		= self.DirVec:Angle()		// Angle is the angle of impact from Normal				//
self.DebrizzlemyNizzle 	= 10+data:GetScale()		// Debrizzle my Nizzle is how many "trails" to make			//
self.Size 		= 5*self.Scale			// Size is exclusively for the explosion "trails" size			//
self.Emitter 		= ParticleEmitter( self.Pos )	// Emitter must be there so you don't get an error			//
	

			if self.Scale<2.1 then
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			else
			sound.Play( "Explosion.Boom", self.Pos)
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			end


	self.Mat=math.ceil(self.Radius)


 
	if     mats[self.Mat][2]==1 then	self:Dust()	
	elseif mats[self.Mat][2]==2 then	self:Dirt()
	elseif mats[self.Mat][2]==3 then	self:Sand()
	elseif mats[self.Mat][2]==4 then	self:Metal()
	elseif mats[self.Mat][2]==5 then	self:Smoke()
	elseif mats[self.Mat][2]==6 then	self:Wood()
	elseif mats[self.Mat][2]==7 then	self:Glass()
	elseif mats[self.Mat][2]==8 then	self:Blood()
	elseif mats[self.Mat][2]==9 then	self:YellowBlood()
	else 					self:Smoke()
	end

end
 
 function EFFECT:Dust()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end


		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 80,80,80 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,85,75 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,500)*self.Scale + VectorRand():GetNormalized() * math.random(0,400)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 60,60,60 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 5) + (DustRing*math.Rand(2, 5))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,87+Rcolor,80+Rcolor )
			end
		end
 end
 
function EFFECT:Dirt()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,500)*self.Scale + VectorRand():GetNormalized() * math.random(0,400)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 50,53,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(2, 6) + (DustRing*math.Rand(1, 4))	

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,83+Rcolor,68+Rcolor )
			end
		end
 end

 function EFFECT:Sand()

		for i=0, 45*self.Scale do		// This is the main plume
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 50,1000*self.Scale) + VectorRand():GetNormalized()*300*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 100, 120 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 50*self.Scale )
		Smoke:SetEndSize( 120*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-1, 1) )			
		Smoke:SetAirResistance( 200 ) 			 
		Smoke:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do		// This is the dirt kickup
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,700)*self.Scale + VectorRand():GetNormalized()*250*self.Scale )
		Dust:SetDieTime( math.Rand( 0.5 , 1,5 ) )
		Dust:SetStartAlpha( 200 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( 60*self.Scale )
		Dust:SetEndSize( 90*self.Scale )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 200 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=0, 25*self.Scale do		// Chunkage
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(50,700)*self.Scale + VectorRand():GetNormalized() * math.random(0,500)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,8)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 53,50,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end

		for i=0, 25*self.Scale do		// Shrapnel
		local Shrapnel = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos+self.DirVec )
		if (Shrapnel) then
		Shrapnel:SetVelocity ( (self.DirVec*700*self.Scale) + (VectorRand():GetNormalized() * 1000*self.Scale) )
		Shrapnel:SetDieTime( math.random( 0.3, 0.5) * self.Scale )
		Shrapnel:SetStartAlpha( 255 )
		Shrapnel:SetEndAlpha( 0 )
		Shrapnel:SetStartSize( math.random(4,7)*self.Scale )
		Shrapnel:SetRoll( math.Rand(0, 360) )
		Shrapnel:SetRollDelta( math.Rand(-5, 5) )			
		Shrapnel:SetAirResistance( 10 ) 			 			
		Shrapnel:SetColor( 53,50,45 )
		Shrapnel:SetGravity( Vector( 0, 0, -600) ) 
		Shrapnel:SetCollide( true )
		Shrapnel:SetBounce( 0.8 )			
		end
		end

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.10 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 10*self.Scale do		
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 30,120*self.Scale) + VectorRand():GetNormalized() * math.random( 50,100*self.Scale) )
		Smoke:SetDieTime( math.Rand( 0.5 , 1 )*self.Scale  )
		Smoke:SetStartAlpha( math.Rand( 80, 100 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 10*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 100 ) 			 
		Smoke:SetGravity( Vector( math.random(-20,20)*self.Scale, math.random(-20,20)*self.Scale, 250 ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end
		
	
		for i=0, 5*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 300,600*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 30, 40 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end


				local Density = 40*self.Scale					/// This part is for the dust ring ///
				local Angle = self.DirVec:Angle()
				for i=0, Density do	
				Angle:RotateAroundAxis(Angle:Forward(), (360/Density))
				local ShootVector = Angle:Up()
				local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
				if (Smoke) then
				Smoke:SetVelocity( ShootVector * math.Rand(50,700*self.Scale) )
				Smoke:SetDieTime( math.Rand( 1 , 4 )*self.Scale  )
				Smoke:SetStartAlpha( math.Rand( 90, 120 ) )
				Smoke:SetEndAlpha( 0 )
				Smoke:SetStartSize( 40*self.Scale )
				Smoke:SetEndSize( 70*self.Scale )
				Smoke:SetRoll( math.Rand(0, 360) )
				Smoke:SetRollDelta( math.Rand(-1, 1) )			
				Smoke:SetAirResistance( 200 ) 			 
				Smoke:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )			
				Smoke:SetColor( 90,83,68 )
				end	
				end
 end

 function EFFECT:Metal()

		for i=1,3 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 50, 70 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end

 		for i=0, 30*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/spark", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( ((self.DirVec*0.75)+VectorRand()) * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(0.3, 1) ) 				 
 		Sparks:SetStartAlpha( 255 )  				 
 		Sparks:SetStartSize( math.Rand(7, 15)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 20 ) 
 		Sparks:SetGravity( Vector( 0, 0, -600 ) ) 
 		end 	
		end 

 		for i=0, 10*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/yellowflare", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( VectorRand() * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(1, 1.7) ) 				 
 		Sparks:SetStartAlpha( 200 )  				 
 		Sparks:SetStartSize( math.Rand(10, 13)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 100 ) 
 		Sparks:SetGravity( Vector( 0, 0, -60 ) ) 
 		end 	
		end 

end


 function EFFECT:Smoke()

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1200*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end


		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(100,400)*self.Scale + VectorRand():GetNormalized() * math.random(100,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 3) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 70,70,70 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 4) + (DustRing*math.Rand(3, 4))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0, 3 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,85+Rcolor,75+Rcolor )
			end
		end
end

 function EFFECT:Wood()

		for i=1,5 do 				
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000)*self.Scale )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 70, 90 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 90,85,75 )
		end
		end

		for i=0, 20*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_wood"..math.random(1,2), self.Pos+self.DirVec )
		if (Debris) then
		Debris:SetVelocity( self.DirVec * math.random(50,300)*self.Scale + VectorRand():GetNormalized() * math.random(200,600)*self.Scale )
		Debris:SetDieTime( math.random( 0.75, 2) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(10,15)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 70 ) 			 			
		Debris:SetColor( 90,85,75 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end
end

 function EFFECT:Glass()

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 30*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_glass"..math.random(1,3), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * math.random(100,600)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2.5) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(3,7)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-15, 15) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 200,200,200 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.5 )				
		end
		end


		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,800*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end
		
end

 function EFFECT:Blood()

		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 70,35,35 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end

end

 function EFFECT:YellowBlood()
		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 120,120,0 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end
end
 

function EFFECT:Think( )
return false
end

function EFFECT:Render()
end
--addons/lvs_addons/lua/effects/lvs_concussion_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(5,6) )
			particle:SetEndSize( math.Rand(12,30) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 50,50,50 )
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(10,15) )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 150,50,100 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(6,10) )
			particle:SetEndSize( math.Rand(2,3) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,100,200 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 255, 40, 100, 50 ) )
end

--addons/lvs_base/lua/effects/lvs_tracer_missile.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir
end

function EFFECT:doFX( pos, curpos )
	if not IsValid( self.emitter ) then return end

	local particle = self.emitter:Add( self.MatSmoke[ math.random(1, #self.MatSmoke ) ], pos )
	if particle then
		particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
		particle:SetVelocity( -self.Dir * 200  )
		particle:SetAirResistance( 600 ) 
		particle:SetDieTime( math.Rand(1.5,2) )
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( 60 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetRollDelta( math.Rand( -1, 1 ) )
		particle:SetColor(40,40,40)
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), pos )
	if particle then
		particle:SetVelocity( -self.Dir * math.Rand(250,800) + self.Dir * 1500 )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 8 )
		particle:SetEndSize( 1 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), curpos )
	if particle then
		particle:SetVelocity( -self.Dir * 200 + VectorRand() * 50 )
		particle:SetDieTime( 0.25 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 6 )
		particle:SetEndSize( 2 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then
		if self.emitter then
			self.emitter:Finish()
		end

		return false
	end

	if not self.emitter then return true end

	local T = CurTime()

	if (self.nextDFX or 0) <= T then
		self.nextDFX = T + 0.02
		
		local bullet = LVS:GetBullet( self.ID )

		local Pos = bullet:GetPos()

		local Sub = self.OldPos - Pos
		local Dist = Sub:Length()
		local Dir = Sub:GetNormalized()

		for i = 0, Dist, 45 do
			local cur_pos = self.OldPos + Dir * i

			self:doFX( cur_pos, Pos )
		end

		self.OldPos = Pos
	end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local pos = bullet:GetPos()

	render.SetMaterial( self.MatSprite )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--addons/arccw_weapons/lua/effects/new_blue2.lua:
EFFECT.Material = "effects/drc_sw/flash1"
EFFECT.Colour	= Color(0, 150, 255)
EFFECT.Time		= 0.07
EFFECT.Speed	= 5
EFFECT.Size		= 0.25
EFFECT.ScaleFP	= 1
EFFECT.ScaleTP	= 1

EFFECT.DoSmoke 			= true
EFFECT.SmokeMaterial	= "effects/drc_sw/plasma3"
EFFECT.SmokeChance		= 1
EFFECT.SmokeScale 		= 0.5
EFFECT.SmokeLighting 	= false
EFFECT.SmokeColour		= Color(0, 100, 150, 255)

function EFFECT:Init( data )
	if data:GetEntity() == LocalPlayer():GetViewModel() then
		self.WeaponEnt = LocalPlayer():GetActiveWeapon()
		self.TargetEnt = LocalPlayer():GetViewModel()
		self.Scale = self.ScaleFP
	else
		self.WeaponEnt = data:GetEntity()
		self.TargetEnt = data:GetEntity()
		self.Scale = self.ScaleTP
	end
	self.StartPos = data:GetStart()
	self.StartAng = data:GetAngles()
	self.EndPos = data:GetOrigin()
	self.OwnerVel = data:GetEntity():GetOwner():GetVelocity()
	self.EffectColour = self.WeaponEnt.EffectTint
	
	local emitter = ParticleEmitter( self.StartPos )
	local emitterSmoke = ParticleEmitter( self.StartPos )
	
	if math.Rand(0,1) < self.SmokeChance then
		for i = 1,20 do
			local particle = emitterSmoke:Add( self.SmokeMaterial, self.StartPos + Vector( math.random(0,0),math.random(0,0),math.random(0,0) ) ) 
			if (particle) then
				particle.CreateTime = RealTime()
				particle.Speed = self.Speed
				particle.Num = i
				particle:SetVelocity(Vector(self.StartAng:Forward() * 0.25 * i * self.Speed) + self.OwnerVel)
				particle:SetLifeTime(0) 
				particle:SetDieTime(self.Time*0.5 * i) 
				particle:SetStartAlpha(50*i)
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(0, 1)*i*self.Size*self.Scale*self.SmokeScale)
				particle:SetEndSize(math.Rand(2, 20)*self.Size*self.Scale*self.SmokeScale)
				particle:SetAngles( Angle(21.424716258016,3.5762036133102,5.6347174018494) )
				particle:SetRoll(math.Rand(0, 180))
				particle:SetColor(self.SmokeColour.r, self.SmokeColour.g, self.SmokeColour.b)
				particle:SetGravity(Vector(0,0,(0.02*i)*i))
				particle:SetAirResistance(240)  
				particle:SetCollide(true)
				particle:SetBounce(0.1419790559388)
				particle:SetLighting(self.SmokeLighting)
			end
		end
	end
	
	emitter:Finish()
	emitterSmoke:Finish()
end

function EFFECT:Think()	
	return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/new_explo_fire.lua:
EFFECT.FlashLarge = {
	"effects/drc_sw/expl_fire0_bwa",
	"effects/drc_sw/expl_fire1_bw",
	"effects/drc_sw/expl_fire2_bw",
	"effects/drc_sw/expl_fire3_bw",
}
EFFECT.LargeFlashes = 12
EFFECT.LargeFlashLifeTimeMin = 0.3
EFFECT.LargeFlashLifeTimeMax = 0.6

EFFECT.Dots = {
	"effects/drc_sw/flash1",
	"effects/drc_sw/flash3",
}
EFFECT.DotsAmount = 10

EFFECT.Streaks = {
	"effects/drc_sw/flash1",
	"effects/drc_sw/flash3",
}
EFFECT.StreakCount = 38

EFFECT.Smoke = {
	"effects/drc_sw/dirt1",
	"effects/drc_sw/dust0",
	"effects/drc_sw/dust1",
}
EFFECT.SmokePuffs 		= 100
EFFECT.SmokeLighting 	= true
EFFECT.SmokeColour 		= Color(0, 0, 0, 255)
EFFECT.SmokeScale		= 1

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.DataNormal = data:GetNormal()
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	
	self.LargeFlashLifeTime = math.Rand(self.LargeFlashLifeTimeMin, self.LargeFlashLifeTimeMax)
	
	local sub = self.EndPos - self.StartPos
	self.Normal = sub:GetNormal()
	
	local emitter = ParticleEmitter(Pos)
	for i = 1,self.LargeFlashes do
		local variance = math.Rand(0, 1)
		local sele = self.FlashLarge[math.Round(math.Rand(1, #self.FlashLarge))]
		local particle = emitter:Add(sele, Pos + Vector( math.random(0,0),math.random(0,0),math.random(0,0) ) ) 
		if particle == nil then particle = emitter:Add(sele, Pos + Vector(   math.random(0,0),math.random(0,0),math.random(0,0) ) ) end
		if (particle) then
		--	particle:SetVelocity(Vector(math.random(-12,12),math.random(-12,12),math.random(-12,12)))
			particle:SetLifeTime(0) 
			particle:SetDieTime(self.LargeFlashLifeTime) 
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(120 * variance)
			particle:SetEndSize(0)
			particle:SetAngles(Angle(21.4 * variance, 3.5 * variance, 5.6 * variance))
			particle:SetAngleVelocity(Angle(5 * variance))
			particle:SetRoll(math.Rand( 0, 360 ) * variance)
			particle:SetColor(math.random(200,220),math.random(90,100),math.random(47,83),math.random(180,255))
			particle:SetGravity( Vector(0,0,0) ) 
			particle:SetAirResistance(-68.167394537726 )  
			particle:SetCollide(true)
			particle:SetBounce(0.1419790559388)
		end
	end
	
	local emitter2 = ParticleEmitter(Pos)
	for i = 1,self.DotsAmount do
		local sele = self.Dots[math.Round(math.Rand(1, #self.Dots))]
		local particle2 = emitter2:Add(sele, Pos + Vector( math.random(-6,6),math.random(-6,6),math.random(0,0))) 
		if particle2 == nil then particle2 = emitter2:Add(sele, Pos + Vector(   math.random(-6,6),math.random(-6,6),math.random(0,0) ) ) end
		if (particle2) then
			particle2:SetVelocity((-self.Normal+VectorRand() * 45):GetNormal() * math.Rand(95, 295));
			particle2:SetLifeTime(math.Rand(0.05, 0.5)) 
			particle2:SetDieTime(math.Rand(2,7)) 
			particle2:SetStartAlpha(255)
			particle2:SetEndAlpha(0)
			particle2:SetStartSize(2) 
			particle2:SetEndSize(0)
			particle2:SetAngleVelocity( Angle(4.2934407040912,14.149586106307,0.18606363772742) ) 
			particle2:SetRoll(math.Rand( 0, 360 ))
			particle2:SetColor(math.random(200,220),math.random(90,100),math.random(47,83),math.random(180,255))
			particle2:SetGravity( Vector(0,0,-400) ) 
			particle2:SetAirResistance(0)  
			particle2:SetCollide(true)
			particle2:SetBounce(0)
		end
	end
	
	local emitter3 = ParticleEmitter(Pos)
	for i = 1,self.SmokePuffs do
		local sele = self.Smoke[math.Round(math.Rand(1, #self.Smoke))]
		local particle3 = emitter3:Add(sele, Pos + Vector( math.random(-6,6),math.random(-6,6),math.random(0,0))) 
		if particle3 == nil then particle3 = emitter3:Add(sele, Pos + Vector(   math.random(-6,6),math.random(-6,6),math.random(0,0) ) ) end
		if (particle3) then
			particle3:SetVelocity(Vector(math.random(-10,10),math.random(-10,10),math.Rand(-10,10)):GetNormal() * math.random(300, 500	))
			particle3:SetLifeTime(math.Rand(0.05, 0.5)) 
			particle3:SetDieTime(math.Rand(0.3,0.6)) 
			particle3:SetStartAlpha(255)
			particle3:SetEndAlpha(0)
			particle3:SetLighting(self.SmokeLighting)
			particle3:SetStartSize(math.Rand(7,12)) 
			particle3:SetEndSize(math.Rand(37,65))
			particle3:SetAngleVelocity( Angle(4.2934407040912,14.149586106307,0.18606363772742) ) 
			particle3:SetRoll(math.Rand( 0, 360 ))
			particle3:SetColor(self.SmokeColour.r, self.SmokeColour.g, self.SmokeColour.b, self.SmokeColour.a)
			particle3:SetGravity( Vector(0,0,0) ) 
			particle3:SetAirResistance(0.01)  
			particle3:SetCollide(true)
			particle3:SetBounce(0)
		end
	end
	
	local emitter5 = ParticleEmitter (Pos)
	for i = 1,self.StreakCount do
		local sele = self.Streaks[math.Round(math.Rand(1, #self.Streaks))]
		local particle5 = emitter5:Add(sele, Pos + Vector( math.random(0,0),math.random(0,0),math.random(0,0) ) ) 
		if particle5 == nil then particle5 = emitter5:Add(sele, Pos + Vector(   math.random(0,0),math.random(0,0),math.random(0,0) ) ) end
		if (particle5) then
			particle5:SetVelocity((-self.Normal+VectorRand() * math.Rand(15,45)):GetNormal() * math.Rand(305, 965));
			particle5:SetLifeTime(0) 
			particle5:SetDieTime(0.2) 
			particle5:SetStartAlpha(255)
			particle5:SetEndAlpha(0)
			particle5:SetStartSize(5) 
			particle5:SetEndSize(0)
			particle5:SetStartLength(100)
			particle5:SetEndLength(0)
			particle5:SetAngles( Angle(21.424716258016,3.5762036133102,5.6347174018494) )
			particle5:SetAngleVelocity( Angle(0) ) 
			particle5:SetRoll(0)
			particle5:SetColor(math.random(200,220),math.random(90,100),math.random(47,83),math.random(180,255))
			particle5:SetGravity( Vector(0,0,0) ) 
			particle5:SetAirResistance( 0.5 )  
			particle5:SetCollide(true)
			particle5:SetBounce(0.1419790559388)
		end
	end

	emitter:Finish()
	emitter2:Finish()
	emitter3:Finish()
	emitter5:Finish()	
end

function EFFECT:Think()		
	return false
end

function EFFECT:Render()
end


--addons/weapon_jedi/lua/effects/rb655_force_repulse_out.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local rad = data:GetRadius()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "effects/rb655_conc_warp", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.25 * 5 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( 0 )
		particle:SetEndSize( rad * 2 ) --math.random( 1000, 2000 ) )

		particle:SetStartAlpha( math.random( 128, 200 ) )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 255, 255, 255 )
	end

	local particle2 = emitter:Add( "effects/rb655_splash_warpring1", pos )
	if ( particle2 ) then
		particle2:SetLifeTime( 0 )
		particle2:SetDieTime( 0.25 * 5 )

		particle2:SetGravity( Vector( 0, 0, 0 ) )
		particle2:SetVelocity( Vector( 0, 0, 0 ) )

		particle2:SetStartSize( 0 )
		particle2:SetEndSize( rad * 2 ) --math.random( 1000, 2000 ) )

		particle2:SetStartAlpha( math.random( 128, 200 ) )
		particle2:SetEndAlpha( 0 )

		particle2:SetColor( 255, 255, 255 )
	end

	--[[local part3 = emitter:Add( "effects/select_ring", pos )
	if ( part3 ) then
		part3:SetLifeTime( 0 )
		part3:SetDieTime( .5 )

		part3:SetGravity( Vector( 0, 0, 0 ) )
		part3:SetVelocity( Vector( 0, 0, 0 ) )

		part3:SetStartSize( 0 )
		part3:SetEndSize( rad )--math.random( 1000, 2000 ) )

		part3:SetStartAlpha( 255 )
		part3:SetEndAlpha( 0 )

		part3:SetColor( 0, 255, 255 )
		--part3:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end]]

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/reconnect_crash_screen/lua/crashmenu/sh_config.lua:
crashmenu.Config = {} -- Don't touch this

-- Do NOT touch this. Assigned directly upon download of the add-on.
crashmenu.Config.ChatRoomID = '52f585f6-486d-47c3-825c-3b50c24f5c9c' -- Chat room which will be used to discuss about the server crash

crashmenu.Config.LogoURL = "https://i.imgur.com/ue7ioC1.png" -- Must be a direct link to an image
crashmenu.Config.Gradient = false -- Turn on gradient or not?
crashmenu.Config.Color1 = Color(0, 0, 0, 203) -- Customize the color of the border and background here.
crashmenu.Config.BigFont = "Roboto Bk" -- Font for the header.
crashmenu.Config.Font = "Roboto" -- Font for the buttons and help text
crashmenu.Config.FontShadows = true
crashmenu.Config.CrashSound = "common/bugreporter_failed.wav" -- Sound path that will be played when the panel shows up. Comment this line or set it to nil to disable the sound.

crashmenu.Config.Title = "Oh man, Server müde - Server schlafen."
crashmenu.Config.SubTitle = [[
Scheint so als würde der Server gleich den Geist aufgeben.
Sollte der Server sich nicht erholen, nutzen wir kurz 
einen Elektroschocker und wecken ihn wieder auf.
Bleibe einfach in dem Fenster, du wirst automatisch Reconnected.
]]

-- This table is useful for adding other buttons to the screen.
-- Adding a button with an "IP" field will redirect clients to another server upon clicking it.
-- Adding a button with an "URL" field will open a page in the Steam overlay for the client upon clicking it.
-- DON'T make a button with both, "IP" will take priority over "URL".
crashmenu.Config.Servers = { -- Examples below
    {
        Name = "212th Forum",
        URL = "http://212th.de"
    },
}
