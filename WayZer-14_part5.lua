--Stealed clientside server code by exechack.cc
--Hostname: WayZer's Role Play | Быстрая загрузка - Part 5/5 - 06/04/2025


--addons/_wlib/lua/wlib/libraries/pon.lua:
--[[
	PON
	created by thelastpenguin
	improved by Octothorp Team
]]
local pon = {}
_G.pon = pon

local type = type
local tonumber = tonumber
local format = string.format
local insert = table.insert

do
	local encode = {}

	local cacheSize = 0

	encode["table"] = function(tbl, output, cache)
		if cache[tbl] then
			insert(output, format("(%u)", cache[tbl]))
			return
		else
			cacheSize = cacheSize + 1
			cache[tbl] = cacheSize
		end

		local first = next(tbl)
		local predictedNumeric = 1

		-- starts with a sequential type
		if first == 1 then
			insert(output, "{")

			for k, v in next, tbl do
				if k == predictedNumeric then
					predictedNumeric = predictedNumeric + 1

					local tv = type(v)
					if tv == "string" then
						local pid = cache[v]
						if pid then
							insert(output, format("(%u)", pid))
						else
							cacheSize = cacheSize + 1
							cache[v] = cacheSize
							encode.string(v, output)
						end
					else
						encode[tv](v, output, cache)
					end
				else
					break
				end
			end

			predictedNumeric = predictedNumeric - 1
		else
			predictedNumeric = nil
		end

		-- start with dictionary type
		if predictedNumeric == nil then
			insert(output, "[")
		else
			-- break sequential for dictionary
			local kv = next(tbl, predictedNumeric)
			if kv then
				insert(output, "~")
			end
		end

		for k, v in next, tbl, predictedNumeric do
			local tk, tv = type(k), type(v)

			-- WRITE KEY
			if tk == "string" then
				local pid = cache[k]
				if pid then
					insert(output, format("(%u)", pid))
				else
					cacheSize = cacheSize + 1
					cache[k] = cacheSize

					encode.string(k, output)
				end
			else
				encode[tk](k, output, cache)
			end

			-- WRITE VALUE
			if tv == "string" then
				local pid = cache[v]
				if pid then
					insert(output, format("(%u)", pid))
				else
					cacheSize = cacheSize + 1
					cache[v] = cacheSize

					encode.string(v, output)
				end
			else
				encode[tv](v, output, cache)
			end
		end

		insert(output, "}")
	end
	--	ENCODE STRING
	local gsub = string.gsub
	encode["string"] = function(str, output)
		local estr, count = gsub(str, ";", "\\;")
		if count == 0 then
			insert(output, "'" .. str .. ";")
		else
			insert(output, '"' .. estr .. '";')
		end
	end
	--	ENCODE NUMBER
	encode["number"] = function(num, output)
		if num % 1 == 0 then
			if num < 0 then
				insert(output, format("x%x;", -num))
			else
				insert(output, format("X%x;", num))
			end
		else
			insert(output, tonumber(num) .. ";")
		end
	end
	--	ENCODE BOOLEAN
	encode["boolean"] = function(val, output)
		insert(output, val and "t" or "f")
	end
	--	ENCODE VECTOR
	encode["Vector"] = function(val, output)
		insert(output, "v" .. val.x .. "," .. val.y .. "," .. val.z .. ";")
	end
	--	ENCODE ANGLE
	encode["Angle"] = function(val, output)
		insert(output, "a" .. val.p .. "," .. val.y .. "," .. val.r .. ";")
	end
	encode["Entity"] = function(val, output)
		insert(output, "E" .. (IsValid(val) and (val:EntIndex() .. ";") or "#"))
	end
	encode["Player"] = encode["Entity"]
	encode["Vehicle"] = encode["Entity"]
	encode["Weapon"] = encode["Entity"]
	encode["NPC"] = encode["Entity"]
	encode["NextBot"] = encode["Entity"]
	encode["PhysObj"] = encode["Entity"]

	-- untransmittable values fix
	encode["function"] = function(val, output)
		insert(output, 'w')
	end
	encode["userdata"] = function(val, output)
		insert(output, 'u')
	end
	encode["thread"] = function(val, output)
		insert(output, 'h')
	end
	encode["CSoundPatch"] = function(val, output)
		insert(output, 'c')
	end

	do
		local concat = table.concat
		function pon.encode(tbl)
			assert(istable(tbl), "Table excepted for encode.")

			local output = {}
			cacheSize = 0
			encode["table"](tbl, output, {})
			local res = concat(output)

			return res
		end
	end
end

do
	local tonumber = tonumber
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
	local Vector, Angle, Entity = Vector, Angle, Entity

	local decode = {}

	-- sequential or mixed table
	decode["{"] = function(index, str, cache)
		local cur = {}
		insert(cache, cur)

		local k = 1
		local v, tv
		while true do
			tv = sub(str, index, index)
			if not tv or tv == "~" then
				index = index + 1
				break
			end
			if tv == "}" then
				return index + 1, cur
			end

			index = index + 1
			index, v = decode[tv](index, str, cache)

			cur[k] = v

			k = k + 1
		end

		-- dictionary after sequential
		local tk
		while true do
			tk = sub(str, index, index)
			if not tk or tk == "}" then
				index = index + 1
				break
			end

			index = index + 1
			index, k = decode[tk](index, str, cache)

			tv = sub(str, index, index)
			index = index + 1
			index, v = decode[tv](index, str, cache)

			cur[k] = v
		end

		return index, cur
	end

	-- dictionary table
	decode["["] = function(index, str, cache)
		local cur = {}
		insert(cache, cur)

		local k, v, tk, tv
		while true do
			tk = sub(str, index, index)
			if not tk or tk == "}" then
				index = index + 1
				break
			end

			index = index + 1
			index, k = decode[tk](index, str, cache)

			tv = sub(str, index, index)
			index = index + 1
			index, v = decode[tv](index, str, cache)

			cur[k] = v
		end

		return index, cur
	end

	-- pointer
	decode["("] = function(index, str, cache)
		local finish = find(str, ")", index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1
		return index, cache[num]
	end

	-- string
	decode["'"] = function(index, str, cache)
		local finish = find(str, ";", index, true)
		local res = sub(str, index, finish - 1)
		index = finish + 1

		insert(cache, res)
		return index, res
	end
	-- escaped string
	decode['"'] = function(index, str, cache)
		local finish = find(str, '";', index, true)
		local res = gsub(sub(str, index, finish - 1), "\\;", ";")
		index = finish + 2

		insert(cache, res)
		return index, res
	end

	-- number
	decode["n"] = function(index, str)
		index = index - 1
		local finish = find(str, ";", index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1
		return index, num
	end
	decode["0"] = decode["n"]
	decode["1"] = decode["n"]
	decode["2"] = decode["n"]
	decode["3"] = decode["n"]
	decode["4"] = decode["n"]
	decode["5"] = decode["n"]
	decode["6"] = decode["n"]
	decode["7"] = decode["n"]
	decode["8"] = decode["n"]
	decode["9"] = decode["n"]
	decode["-"] = decode["n"]
	-- positive hex
	decode["X"] = function(index, str)
		local finish = find(str, ";", index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1
		return index, num
	end
	-- negative hex
	decode["x"] = function(index, str)
		local finish = find(str, ";", index, true)
		local num = -tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1
		return index, num
	end

	-- boolean
	decode["t"] = function(index)
		return index, true
	end
	decode["f"] = function(index)
		return index, false
	end

	-- Vector
	decode["v"] = function(index, str)
		local finish = find(str, ";", index, true)
		local vecStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(",", vecStr, false)
		return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end
	-- Angle
	decode["a"] = function(index, str)
		local finish = find(str, ";", index, true)
		local angStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(",", angStr, false)
		return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end
	-- Entity
	decode["E"] = function(index, str)
		if str[index] == "#" then
			index = index + 1
			return index, NULL
		else
			local finish = find(str, ";", index, true)
			local num = tonumber(sub(str, index, finish - 1))
			index = finish + 1
			return index, Entity(num)
		end
	end

	-- untransmittable values fix
	decode["w"] = function(index)
		return index, 'function'
	end
	decode["u"] = function(index)
		return index, 'userdata'
	end
	decode["h"] = function(index)
		return index, 'thread'
	end
	decode["с"] = function(index)
		return index, 'sound'
	end

	function pon.decode(data)
		assert(isstring(data), "String excepted for decode.")

		local succ, _, res = pcall(decode[sub(data, 1, 1)], 2, data, {})
		if succ then return res end
	end
end
--addons/_wlib/lua/wlib/libraries/_client/circles.lua:
if SERVER then return false end

local _R = debug.getregistry()
if _R.Circles then return _R.Circles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({Count = 0})

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = {Count = 0}
		local step = distance / radius

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
		self.m_Vertices.Count >= 3 and
		self.m_Radius >= 1 and
		self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		if inner_r >= radius then
			self:SetShouldRender(false)
		else
			if inner_r >= 1 then
				inner:SetType(CIRCLE_FILLED)

				inner:SetRadius(inner_r)
				inner:SetAngles(start_angle, end_angle)

				inner:SetColor(false)
				inner:SetMaterial(false)

				inner:SetShouldRender(true)
			else
				inner:SetShouldRender(false)
			end

			self:SetShouldRender(true)
		end

		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then
			self:Calculate()
		end

		if not self.m_ShouldRender or not self:IsValid() then
			return false
		end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				self.m_ChildCircle()

				render.SetStencilCompareFunction(STENCIL_GREATER)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				surface.DrawPoly(self.m_Vertices)

				render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.SetMaterial(blur)

				local sw, sh = ScrW(), ScrH()

				for i = 1, self.m_BlurLayers do
					blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
					blur:Recompute()

					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(0, 0, sw, sh)
				end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		if x == 0 and y == 0 then return end

		self.m_X = self.m_X + x
		self.m_Y = self.m_Y + y

		if not self:IsValid() then return end

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = vertex.x + x
			vertex.y = vertex.y + y
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Translate(x, y)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))
		if scale == 1 then return end

		self.m_Radius = self.m_Radius * scale

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = x + (vertex.x - x) * scale
			vertex.y = y + (vertex.y - y) * scale
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Scale(scale)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))
		if rotation == 0 then return end

		self.m_Rotation = self.m_Rotation + rotation

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y
		local vertices = self.m_Vertices
		local rotate_uv = self.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Rotate(rotation)
		end
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if isfunction(callback) then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesX(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function OffsetVerticesY(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesY(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function UpdateRotation(circle, old, new)
		if not circle:IsValid() then return end

		local vertices = circle.m_Vertices
		local x, y = circle.m_X, circle.m_Y
		local rotation = new - old
		local rotate_uv = circle.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			UpdateRotation(circle.m_ChildCircle, old, new)
		end

		return new
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)				-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)				-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)			-- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")			-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")		-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")		-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")			-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)				-- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)				-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")		-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or 0
		y = tonumber(y) or 0

		self:Translate(x - self.m_X, y - self.m_Y)
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.Circles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

wlib.Circles = _R.Circles

return _R.Circles
--addons/_wlib/lua/wlib/modules/afk/shared.lua:
nw.Register('AFKTime')
    :Write(net.WriteUInt, 32)
    :Read(net.ReadUInt, 32)
    :SetPlayer()

nw.Register('IsAFK')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()
    :SetHook('PlayerGoneAFK')

nw.Register('AFKStart')
    :Write(net.WriteUInt, 32)
    :Read(net.ReadUInt, 32)
    :SetPlayer()

local meta = FindMetaTable('Player')

function meta:IsAFK()
	return self:GetNetVar('IsAFK') or false
end

function meta:GetAFKStart()
	return self:GetNetVar('AFKStart') or CurTime()
end

function meta:GetAFKTime()
	return self:IsAFK() and CurTime() - self:GetAFKStart() or 0
end

function meta:GetAFKTotalTime()
	return self:GetNetVar('AFKTime', 0) + self:GetAFKTime()
end

function team.GetActivePlayers(t)
    return wlib.array.filter(team.GetPlayers(t), function(ply)
        return ply:GetAFKTime() < CFG.afkDemoteTime
    end)
end

function team.GetInactivePlayers(t)
    local p = wlib.array.filter(team.GetPlayers(t), function(ply)
        return ply:GetAFKTime() >= CFG.afkDemoteTime
    end)
    table.sort(p, function(a, b) return a:GetAFKTime() > b:GetAFKTime() end)
    return p
end

function team.NumActivePlayers(t)
    return #team.GetActivePlayers(t)
end
--addons/_wlib/lua/wlib/modules/chat/shared.lua:
wlib.chat = wlib.chat or {}

nw.Register('IsTyping')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()
    :SetNoSync()

local pmeta = FindMetaTable('Player')
function pmeta:IsTyping()
    return self:GetNetVar('IsTyping', false)
end
--addons/_wlib/lua/wlib/modules/delays/shared.lua:
nw.Register('Delays')
    :Write(function(d)
        net.WriteUInt(table.Count(d), 5)
        
        for id, delay in pairs(d) do
            net.WriteString(id)
            net.WriteString(delay:GetText())
            net.WriteFloat(delay:GetStart())
            net.WriteFloat(delay:GetDuration())
            net.WriteFloat(delay:GetStartProgress())
        end
    end)
    :Read(function()
        local d = {}

        local count = net.ReadUInt(5)
        
        for i=1, count do
            local id = net.ReadString()
            local text = net.ReadString()
            local start = net.ReadFloat()
            local duration = net.ReadFloat()
            local startProgress = net.ReadFloat()
        
            d[#d+1] = {
                id = id,
                text = text,
                start = start,
                duration = duration,
                startProgress = startProgress,
            }
        end

        return d
    end)
    :SetPlayer()
    :SetHook('DelaysUpdated')
--addons/_wlib/lua/wlib/modules/delays/client.lua:
hook.Add('DelaysUpdated', 'delays', function(ply, val)
    ply.delayIDs = {}
    for k, v in ipairs(val) do
        if not ply.delayIDs then return end
        ply.delayIDs[v.id] = k
    end
end)

local PLAYER = FindMetaTable('Player')
function PLAYER:GetDelay(id)
    return self:GetNetVar('Delays') and self:GetNetVar('Delays')[self.delayIDs[id] or -1]
end

--

local font = 'chelog-ib.small'
local radius = 60
local color_dark = Color(43,49,54, 245)
local color_bright = Color(236,113,71)

local blur = wlib.Circles.New(CIRCLE_FILLED, radius, ScrW()/2, ScrH()/2, 3, 10)
blur:SetMaterial(true)
blur:SetColor(color_dark)

local progress = wlib.Circles.New(CIRCLE_FILLED, radius, ScrW()/2, ScrH()/2)
progress:SetMaterial(true)
progress:SetColor(color_bright)
progress:SetStartAngle(-90)

hook.Add('HUDPaint', 'drawdelay', function()
    local delays = LocalPlayer():GetNetVar('Delays')
    if not delays or #delays == 0 then return end

    local d
    local elapsed
    for i = #delays, 1, -1 do
        d = delays[i]
        elapsed = d.duration * d.startProgress + (CurTime() - d.start)
        if elapsed > d.duration then
            delays[i] = nil
            d = nil
            return
        end

        break
    end

    local text = d.text
    for i=1, math.floor((CurTime()-delays[1].start)/0.5%3)+1 do
        text = text..'.'
    end

    surface.SetFont(font)
    local w, h = surface.GetTextSize(text)
    local allh = radius+h

    local y = ScrH()/2 - allh/2

    blur:SetY(y)
    blur()

    progress:SetY(y)
    progress:SetEndAngle(360*(elapsed/d.duration) - 90)
    progress()

	surface.SetTextColor(color_white)
    surface.SetTextPos(ScrW()/2 - w/2, ScrH()/2 + allh/2 - h/2)
    surface.DrawText(text)
end)
--addons/_wlib/lua/wlib/modules/incognito/client.lua:
local pmeta = FindMetaTable('Player')

hook.Add('Think', 'wlib.incognito.cl', function()
    hook.Remove('Think', 'wlib.incognito.cl')
    timer.Simple(1, function()
        pmeta.Name = pmeta.DisplayName
        pmeta.GetName = pmeta.DisplayName
        pmeta.Nick = pmeta.DisplayName

        pmeta.SteamName = pmeta.DisplaySteamName
    
        pmeta.GetUserGroup = pmeta.GetDisplayUserGroup
    
        pmeta.SteamID = pmeta.DisplaySteamID
        pmeta.SteamID64 = pmeta.DisplaySteamID64

        pmeta.GetUTime = pmeta.GetDisplayUTime
        pmeta.GetUTimeStart = pmeta.GetDisplayUTimeStart
        pmeta.GetUTimeSessionTime = pmeta.GetDisplayUTimeSessionTime
        pmeta.GetUTimeTotalTime = pmeta.GetDisplayUTimeTotalTime
        
        pmeta.GetMainOrgID = pmeta.GetDisplayMainOrgID

        local voicenotify = vgui.GetControlTable('VoiceNotify')
        if voicenotify then
            voicenotify.Setup = function(self, ply)
                self.ply = ply
                self.LabelName:SetText(ply:Nick())
                self.Avatar:SetSteamID(ply:SteamID64(), 32)
                
                self.Color = team.GetColor(ply:Team())
                
                self:InvalidateLayout()
            end
        end

        pmeta.GetRealFriendStatus = pmeta.GetRealFriendStatus or pmeta.GetFriendStatus
        pmeta.GetFriendStatus = function(self)
            if self:GetNetVar('Incognito') then return 'none' end

            return self:GetRealFriendStatus()
        end
    end)
end)
--addons/_wlib/lua/wlib/modules/notification/shared.lua:
notification = notification or {}

NOTIFY_GENERIC = 0
NOTIFY_ERROR = 1
NOTIFY_UNDO = 2
NOTIFY_HINT = 3
NOTIFY_CLEANUP = 4
NOTIFY_POLICE = 5
NOTIFY_CHAT = 6

notification.Icons = {
	[NOTIFY_GENERIC] = Material('icon72/bulb.png'),
	[NOTIFY_ERROR] = Material('icon72/warning.png'),
	[NOTIFY_UNDO] = Material('icon72/leftwards_arrow_with_hook.png'),
	[NOTIFY_HINT] = Material('icon72/video_game.png'),
	[NOTIFY_CLEANUP] = Material('icon72/four_leaf_clover.png'),
	[NOTIFY_POLICE] = Material('icon72/rotating_light.png'),
	[NOTIFY_CHAT] = Material('icon72/speech_balloon.png'),
}
--addons/_wlib/lua/wlib/modules/players/client.lua:
local PLAYER = FindMetaTable('Player')

function PLAYER:GetAvatar()
    return self.steamavatar
end

hook.Add('SteamAvatarUpdated', 'avatar', function(ply)
    timer.Simple(0, function()
        if not IsValid(ply) then return end
        http.DownloadMaterial(ply:GetAvatarURL('full'), nil, function(mat)
            if IsValid(ply) then
                ply.steamavatar = mat and not mat:IsError() and mat
            end
        end)
    end)
end)
--addons/_wlib/lua/wlib/modules/_client/icons.lua:
wlib.icons = wlib.icons or {}

wlib.icons.keys = {
    [KEY_E] = 'icon72/key_e.png',
    [KEY_R] = 'icon72/key_r.png',
    [KEY_M] = 'icon72/key_m.png',
    [KEY_LSHIFT] = 'icon72/key_shift.png',
    [MOUSE_LEFT] = 'icon72/key_lkm.png',
    [MOUSE_RIGHT] = 'icon72/key_pkm.png',
}

wlib.icons.keysMaterials = wlib.icons.keysMaterials or {}

function wlib.icons.getKeyPath(key)
    return wlib.icons.keys[key]
end

function wlib.icons.getKey(key)
    if wlib.icons.keysMaterials[key] then return wlib.icons.keysMaterials[key] end

    local path = wlib.icons.getKeyPath(key)
    if not path then return end

    local mat = Material(path)

    wlib.icons.keysMaterials[key] = mat
    return mat
end
--addons/_wlib/lua/wlib/modules/_client/panels.lua:
wlib.panels = wlib.panels or {}

function wlib.panels.overlay(parent, pnl, persist, bg)
	local o = vgui.Create(persist and 'DPanel' or 'DButton')
	if IsValid(pnl) then parent:Add(o) end

	local p
	if isstring(pnl) then
		p = o:Add(pnl)
	else
		pnl:SetParent(o)
		p = pnl
	end

	function o:Think()
		local par = self:GetParent()
		if not IsValid(par) then return end

		local newW, newH = par:GetSize()
		if newW ~= self.overlay_oldW or self.overlay_oldH ~= newH then
			self:SetPos(0, 0)
			self:SetSize(newW, newH)
			if IsValid(p) then p:Center() end
		end
		self.overlay_oldW, self.overlay_oldH = newW, newH
	end

	o.bgCol = bg or Color(0,0,0,200)
	function o:Paint(w, h)
		draw.RoundedBox(4, 0, 0, w, h, self.bgCol)
	end

	if not persist then
		o:SetText('')
		function o:DoClick()
			self:Remove()
		end
	end

    p.OnRemove = function() o:Remove() end

	return p, o
end

local tooltip
function wlib.panels.tooltip(parent, pnl)
	if not IsValid(tooltip) then
		tooltip = vgui.Create('DPanel')
		tooltip:DockPadding(4,4,4,4)
		tooltip:MakePopup()
		tooltip:SetMouseInputEnabled(false)
		tooltip:SetKeyboardInputEnabled(false)
	end

	tooltip:SetSize(pnl:GetWide()+8, pnl:GetTall()+8)
	pnl:SetParent(tooltip)
	pnl:Center()

	tooltip.Think = function(s)
		if not IsValid(parent) or not parent:IsVisible() then return s:Remove() end
		s:SetPos(parent:LocalToScreen(parent:GetWide()/2-tooltip:GetWide()/2, -tooltip:GetTall()))
	end
end

function wlib.panels.removeTooltip()
	if IsValid(tooltip) then tooltip:Remove() end
end

function wlib.panels.iconPicker(callback, q)
	
end
--addons/_wlib/lua/wlib/vgui/multipanel.lua:
local PANEL = {}

function PANEL:Init()
    self.panels = {}
    self.active = nil
end

function PANEL:Clear()
    for _, v in ipairs(self.panels) do
        v:Remove()
    end
    self.panels = {}
end

function PANEL:AddPanel(panel, id, selected)
    panel:SetSize(self:GetSize())
    panel:SetVisible(false)
    panel:SetParent(self)

    panel.ID = table.insert(self.panels, panel)
    panel.ID = id or panel.ID

    if selected then self:SelectPanel(panel.ID) end

    return panel.ID
end

function PANEL:SelectPanel(id, ...)
    for _, panel in ipairs(self.panels) do
        panel.Active = panel.ID == id

        panel:SetVisible(false)
        panel:Dock(NODOCK)

        if panel.ID == id then
            self.active = panel
            panel:SetVisible(true)
            panel:Dock(FILL)

            if panel.OnSelected then panel:OnSelected(...) end
        end
    end
end

function PANEL:GetActivePanel()
	return self.active
end

function PANEL:GetActiveID()
    return self.active and self.active.ID
end

function PANEL:GetPanel(id)
    return wlib.array.find(self.panels, function(i) return i.ID == id end)
end

vgui.Register('wlib.multipanel', PANEL, 'DPanel')
--addons/module_scoreboard/lua/wayscore/core.lua:
wayscore.info = {
    {
        name = 'Имя',
        icon = 'icon72/dividers.png',
        get = function(ply)
            return ply:Name()
        end,
        align = TEXT_ALIGN_LEFT,
        size = 0.20,
    },
    {
        name = 'Организация',
        icon = 'icon72/crossed_swords.png',
        get = function(ply)
            local clan = dOrgs.orgs[ply:GetMainOrgID()]
            return clan and clan:GetName() or ''
        end,
        align = TEXT_ALIGN_CENTER,
        size = 0.15,
    },
    {
        name = 'Профессия',
        icon = 'icon72/briefcase.png',
        get = function(ply)
            return ply:GetNetVar('job', '')
        end,
        align = TEXT_ALIGN_CENTER,
        center = false,
        size = 0.30,
    },
    {
        name = 'AFK',
        icon = 'icon72/alarm_clock.png',
        get = function(ply)
            local t = ply:GetAFKTime()
            return ply:IsAFK() and ('%02i:%02i:%02i'):format(math.floor(t/3600), math.floor(t/60%60), t%60) or ''
        end,
        align = TEXT_ALIGN_CENTER,
        size = 0.20,
    },
    {
        name = 'Пинг',
        icon = 'icon72/satellite.png',
        get = function(ply)
            return ply:Ping()
        end,
        --[[
        check = function()
            return LocalPlayer():IsAdmin()
        end,
        ]]
        align = TEXT_ALIGN_RIGHT,
        size = 0.15,
    },
}

CreateClientConVar('wayscore_sort', 2, true)
CreateClientConVar('wayscore_sort_desc', 0, true)

wayscore.view = 'main'
wayscore.viewData = {}

wayscore.ActionButtons = wayscore.ActionButtons or {}
wayscore.Information = wayscore.Information or {}

function wayscore:Show()
    if not IsValid(LocalPlayer()) then return end
    
    gui.EnableScreenClicker(true)
    if IsValid(self.frame) then
        self.frame:SetVisible(true)
        self:SelectView(self.view, unpack(self.viewData))
        hook.Run('wayscore.Show', self.frame)
        return true
    end

    self.frame = vgui.Create('wayscore_frame')

    self.views = {}
    self:AddView('main', 'wayscore_playerlist')
    self:AddView('player', 'wayscore_view_player')

    self:SelectView(self.view, unpack(self.viewData))

    hook.Run('wayscore.Show', self.frame)

    return true
end

function wayscore:Hide()
    if IsValid(self.frame) then
        self.frame:SetVisible(false)
    end
    gui.EnableScreenClicker(false)

    hook.Run('wayscore.Hide')
    
    return true
end

function wayscore:IsVisible()
    return IsValid(self.frame) and self.frame:IsVisible() or false
end

function wayscore:Reload()
    if IsValid(self.frame) then self.frame:Remove() end
    self:Show()
end

concommand.Add('wayscore_reload', function()
    wayscore:Reload()
end)

timer.Simple(0, function()
    hook.Remove('ScoreboardShow', 'FAdmin_scoreboard')
    hook.Remove('ScoreboardHide', 'FAdmin_scoreboard')

    hook.Add('ScoreboardShow', 'wayscore', function()
        return wayscore:Show()
    end)

    hook.Add('ScoreboardHide', 'wayscore', function()
        if wayscore.fixed then return true end
        return wayscore:Hide()
    end)
end)

hook.Add('wayscore.PlayerRowColor', 'disguise', function(ply)
    if not ply:GetNetVar('disguised') then return end
    if LocalPlayer():Team() == TEAM_ADMIN then return end

    return (LocalPlayer():isCP() and ply:isCP()) and team.GetColor(ply:Team()) or team.GetColor(ply:GetNetVar('disguise_team'))
end)
--addons/module_scoreboard/lua/wayscore/util.lua:
function wayscore:AddView(name, p)
    p = isstring(p) and vgui.Create(p) or p

    p:SetParent(self.frame)
    p:Dock(NODOCK)
    p:SetVisible(false)

    self.views[name] = p
end

function wayscore:SelectView(view, ...)
    if not IsValid(self.frame) then self:Open() end
    if not self.views[view] then return end

    self.view = view
    self.viewData = {...}

    for k, v in pairs(self.views) do
        if k == view then
            v:SetParent(self.frame)
            v:Dock(FILL)
            v:SetVisible(true)
            if v.Select then v:Select(...) end
        else
            v:Dock(NODOCK)
            v:SetVisible(false)
        end
    end
end

-- Не думал, что до такого дойдет
local rus_alp = {
    ['а'] = 'А', ['б'] = 'Б', ['в'] = 'В', ['г'] = 'Г', ['д'] = 'Д', ['е'] = 'Е',
    ['ё'] = 'Ё', ['ж'] = 'Ж', ['з'] = 'З', ['и'] = 'И', ['й'] = 'Й', ['к'] = 'К',
    ['л'] = 'Л', ['м'] = 'М', ['н'] = 'Н', ['о'] = 'О', ['п'] = 'П', ['р'] = 'Р',
    ['с'] = 'С', ['т'] = 'Т', ['у'] = 'У', ['ф'] = 'Ф', ['х'] = 'Х', ['ц'] = 'Ц',
    ['ч'] = 'Ч', ['ш'] = 'Ш', ['щ'] = 'Щ', ['ъ'] = 'Ъ', ['ы'] = 'Ы', ['ь'] = 'Ь',
    ['э'] = 'Э', ['ю'] = 'Ю', ['я'] = 'Я',
}

function wayscore.upper(str)
    local res = str:upper():gsub(utf8.charpattern, rus_alp)
    return res
end

local rus_alp_lower = {
    ['А'] = 'а', ['Б'] = 'б', ['В'] = 'в', ['Г'] = 'г', ['Д'] = 'д', ['Е'] = 'е',
    ['Ё'] = 'ё', ['Ж'] = 'ж', ['З'] = 'з', ['И'] = 'и', ['Й'] = 'й', ['К'] = 'к',
    ['Л'] = 'л', ['М'] = 'м', ['Н'] = 'н', ['О'] = 'о', ['П'] = 'п', ['Р'] = 'р',
    ['С'] = 'с', ['Т'] = 'т', ['У'] = 'у', ['Ф'] = 'ф', ['Х'] = 'х', ['Ц'] = 'ц',
    ['Ч'] = 'ч', ['Ш'] = 'ш', ['Щ'] = 'щ', ['Ъ'] = 'ъ', ['Ы'] = 'ы', ['Ь'] = 'ь',
    ['Э'] = 'э', ['Ю'] = 'ю', ['Я'] = 'я',
}

function wayscore.lower(str)
    local res = str:lower():gsub(utf8.charpattern, rus_alp_lower)
    return res
end

function wayscore.AddInfo(id, data)
    data.id = id
    local _, index = wlib.array.find(wayscore.Information, function(val) return val.id == id end)
    if index then
        wayscore.Information[index] = data
    else
        table.insert(wayscore.Information, data)
    end
end

function wayscore.AddActionButton(id, data)
    data.id = id
    local _, index = wlib.array.find(wayscore.ActionButtons, function(val) return val.id == id end)
    if index then
        wayscore.ActionButtons[index] = data
    else
        table.insert(wayscore.ActionButtons, data)
    end
end

function wayscore.PortActions()
    local i = 1
    for _, v in ipairs(FAdmin and FAdmin.ScoreBoard and FAdmin.ScoreBoard.Player.ActionButtons or {}) do
        wayscore.AddActionButton(i, {
            name = v.Name,
            icon = v.Image,
            color = v.color,
            check = isfunction(v.Visible) and v.Visible,
            callback = v.Action,
            onCreated = v.OnButtonCreated,
            order = i,
        })
        i = i+1
    end
    i = 1
    for _, v in ipairs(FAdmin and FAdmin.ScoreBoard and FAdmin.ScoreBoard.Player.Information or {}) do
        wayscore.AddInfo(i, {
            name = v.name,
            get = v.func,
            newPanel = v.NewPanel,
        })
        i = i+1
    end
end

timer.Simple(0, function()
    wayscore.PortActions()
end)

--

wayscore.AddInfo('name', {
    name = 'Имя',
    get = function(ply) return ply:Name() end,
    order = 1000,
})
--[[
wayscore.AddInfo('kills', {
    name = 'Убийств',
    get = function(ply) return ply:Frags() end,
    order = 2000,
})
wayscore.AddInfo('deaths', {
    name = 'Смертей',
    get = function(ply) return ply:Deaths() end,
    order = 3000,
})
]]
wayscore.AddInfo('steamid', {
    name = 'SteamID',
    get = function(ply) return ply:SteamID() end,
    order = 4000,
})

wayscore.AddActionButton('friend', {
    name = function(ply) return FPP.Buddies[ply:SteamID()] and 'Удалить из друзей' or 'Добавить в друзья' end,
    icon = function(ply) return 'icon72/two_hearts.png', FPP.Buddies[ply:SteamID()] and 'fadmin/icons/disable' end,
    order = -2000,
    rightClick = true,
    check = function(ply) return ply ~= LocalPlayer() end,
    callback = function(ply, btn)
        local val = FPP.Buddies[ply:SteamID()] and 0 or 1
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'physgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'gravgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'toolgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'playeruse',    val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'entitydamage', val)

        if val == 0 then
            btn:SetText('Добавить в друзья')
            btn:SetImage2('null')
            btn:GetParent():InvalidateLayout()
        else
            btn:SetText('Удалить из друзей')
            btn:SetImage2('fadmin/icons/disable')
            btn:GetParent():InvalidateLayout()
        end
    end,
})

wayscore.AddActionButton('pm', {
    name = 'Сообщение',
    icon = 'icon72/speech_balloon.png',
    order = -1500,
    rightClick = true,
    check = function(ply) return ply ~= LocalPlayer() end,
    callback = function(ply, btn)
        Derma_StringRequest('Сообщение', 'Введи ниже сообщение, которое хочешь отправить', '', function(text)
            RunConsoleCommand('darkrp', 'pm', ply:UserID(), text)
        end)
    end,
})
--addons/model_altair/lua/autorun/altair_ibnlaahad.lua:
/*
	Addon by Voikanaa	
*/

player_manager.AddValidModel( "Altair Ibn-La'Ahad", 	"models/player/altair_ibnlaahad.mdl" );
player_manager.AddValidHands( "Altair Ibn-La'Ahad", 	"models/player/altair_ibnlaahad_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Altair Ibn-La'Ahad", 	"models/player/altair_ibnlaahad.mdl" );
--addons/module_bank/lua/autorun/bank_load.lua:
wbank = wbank or {}

wlib.include.prefixed('wbank')
--addons/module_cats/lua/autorun/cats-load.lua:
-- please at least do not remove this comment
    -- by chelog

include "cats/shared.lua"

if SERVER then
    AddCSLuaFile "cats/client.lua"
    AddCSLuaFile "cats/shared.lua"
    include "cats/server.lua"
else
    include "cats/client.lua"
end

print("[CATS] Files loaded.")

--addons/module_cats/lua/cats/shared.lua:
-- proudly coded by chelog

if SERVER then function ScrW() return 1920 end function ScrH() return 1080 end end cats = cats or {} cats.config = {}
-- ^
-- | please do not touch these

------------------------------------------------------
-- BASIC CONFIG
------------------------------------------------------

-- positions
cats.config.spawnSize = { 450, 220 }
cats.config.spawnPosAdmin = { ScrW() - 500, 50 }
cats.config.spawnPosUser = { ScrW() - 500, ScrH() - 250 }

-- appearance
cats.config.punchCardMode = 'dots' -- 'line', 'dots' or 'columns'
cats.config.punchCardStart = 5

-- rating
cats.config.defaultRating = 3
cats.config.ratingTimeout = 60

-- sound
cats.config.newTicketSound = 'common/null.wav'

-- language
cats.lang = {
    openTickets = "Открытые жалобы",
    myTicket = "Моя жалоба",
    userDisconnected = "Пользователь вышел",
    claimedBy = "Разбирается",
    sendMessage = "Написать сообщение...",
    typeYourMessage = "Введите сообщение:",
    actions = "Действия",
    action_claim = "Взять жалобу",
    action_unclaim = "Передать жалобу",
    action_spectate = "Наблюдать",
    action_goto = "К нему",
    action_bring = "К себе",
    action_return = "Вернуть на место",
    action_returnself = "Вернуться на место",
    action_sit = "ТП в админзону",
    action_copySteamID = "Скопировать SteamID",
    action_callon = "Включить просьбу о помощи",
    action_calloff = "Выключить просьбу о помощи",
    action_close = "Закрыть жалобу",
    error_wait = "Тихо-тихо... Куда так разогнался?",
    error_noAccess = "Ошибка доступа",
    error_playerNotFound = "Игрок не найден",
    error_ticketNotEnded = "Жалоба не закрыта",
    error_ticketNotFound = "Жалоба не найдена",
    error_ticketEnded = "Жалоба уже решена",
    error_ticketNotClaimed = "Жалоба никем не взята",
    error_ticketAlreadyClaimed = "Жалоба уже взята",
    error_needToRate = "Ты должен оценить прошлую жалобу!",
	error_cantCancelHasAdmin = "Нельзя отменить жалобу, которую рассматривают",
    error_needAdminTeam = "Ты должен быть в профессии Администратора",
    error_muted = "Ты не можешь писать в жалобе, будучи в муте",
    ticketClaimed = "Жалоба взята",
    ticketUnclaimed = "Жалоба отдана",
    ticketClaimedBy = "Твою жалобу принял %s",
    ticketUnclaimedBy = "Твоя жалоба передана",
    ticketClosed = "Жалоба закрыта",
    ticketClosedBy = "%s закрыл жалобу. Оцени его работу!",
    ticketRatedForAdmin = "Оценка по твоей жалобе: %s",
    ticketRatedForUser = "Ты оценил решение жалобы на %s",
    ticketUserLeft = "Пользователь, чью жалобу ты решал, вышел",
    rateAdmin = "Нажми ниже, чтобы выбрать оценку",
    ok = "Готово",
    cancel = "Отмена",
    ticket_noAdmins = "На сервере нет администраторов, но если кто-то зайдет, он увидит твою жалобу",
    dow = {"ПН","ВТ","СР","ЧТ","ПТ","СБ","ВС"},
}

------------------------------------------------------
-- ADVANCED SETTINGS (do not edit unless you're a dev)
------------------------------------------------------

local adminRanks = {
    ['Patron'] = true,
	['Curator'] = true,
	['+Eventer'] = true,
	['+Helper'] = true,
	['Helper'] = true,
	['moder'] = true,
	['admin'] = true,
	['Trusted'] = true,
	['WayZer Team'] = true,
    ['superadmin'] = true,
}

cats.config.serverID = "wayzer"
cats.config.getPlayerName = function(ply)
    return ply:Name() .. " (" .. ply:SteamName() .. ")"
end
cats.config.playerCanSeeTicket = function(ply, ticketSteamID)
    return adminRanks[ply:GetUserGroup()] or ply:SteamID() == ticketSteamID
end
cats.config.triggerText = function(ply, text)
    if cats.config.playerCanSeeTicket(ply, "") then return false end
    if ply:FAdmin_GetGlobal("FAdmin_chatmuted") then return false end

    text = text:Trim()
    if text:sub(1,1) == '@' then
        return true, text:sub(2):Trim()
    elseif text:sub(1,3) == '///' then
        return true, text:sub(4):Trim()
    end

    return false
end
cats.config.notify = function(ply, msg, type, duration)
    if IsValid(ply) then
        DarkRP.notify(ply, type, duration, msg)
    end
end

local naborka = {
	['+Eventer'] = true,
	['+Helper'] = true,
	['Helper'] = true,
	['moder'] = true,
	['admin'] = true,
	['Trusted'] = true,
	['WayZer Team'] = true,
    ['superadmin'] = true,
}

cats.config.canPerformActions = function(ply)
    return ply:Team() == TEAM_ADMIN or naborka[ply:GetUserGroup()]
end

-- NOTE: these are clientside
cats.config.commands = {
    { -- spectate
        text = cats.lang.action_spectate,
        icon = 'camera_go',
        click = function(ply)
            RunConsoleCommand('FSpectate', ply:SteamID())
        end
    },
    { -- bring
        text = cats.lang.action_bring,
        icon = 'user_go',
        click = function(ply)
            RunConsoleCommand('FAdmin', 'bring', ply:SteamID())
        end
    },
    { -- return
        text = cats.lang.action_return,
        icon = 'arrow_undo',
        click = function(ply)
            RunConsoleCommand('FAdmin', 'return', ply:SteamID())
        end
    },
    { -- goto
        text = cats.lang.action_goto,
        icon = 'arrow_right',
        click = function(ply)
            RunConsoleCommand('FAdmin', 'goto', ply:SteamID())
        end
    },
    { -- return self
        text = cats.lang.action_returnself,
        icon = 'arrow_rotate_clockwise',
        click = function(ply)
            RunConsoleCommand('FAdmin', 'return', LocalPlayer():SteamID())
        end
    },
    { -- return self
        text = cats.lang.action_sit,
        icon = 'group_go',
        click = function(ply)
            RunConsoleCommand('FAdmin', 'sit', ply:SteamID())
        end
    },
    { -- copy steamID
        text = cats.lang.action_copySteamID,
        icon = 'key_go',
        click = function(ply)
            SetClipboardText( ply:SteamID() )
        end
    },
}

-- | also please do not touch these
-- V
if SERVER then ScrW = nil ScrH = nil end

--addons/module_eventpanel/lua/devents/sh_config.lua:
dEvents.config = {
    adminGroups = {
        ['Patron'] = true,
        ['Curator'] = true,
        ['Eventer'] = true,
        ['+Eventer'] = true,
        ['Helper'] = true,
        ['+Helper'] = true,
        ['moder'] = true,
        ['admin'] = true,
        ['Trusted'] = true,
        ['WayZer Team'] = true,
        ['superadmin'] = true,
    },

    superAdminGroups = {
        ['Trusted'] = true,
        ['WayZer Team'] = true,
        ['superadmin'] = true,
    },

    maxPositions = 4,
    minEventMembers = 2,

    startTime = {min = 10, max = 60, default = 20},
    maxMembers = {min = 2, max = 60, default = 10},

    hp = {min = 1, max = 1000000, default = 100},
    armor = {min = 0, max = 1000000, default = 0},
    speedScale = {min = 0.5, max = 3, default = 1},
    jumpScale = {min = 0, max = 3, default = 1},
    modelScale = {min = 0.1, max = 5, default = 1},

    mainColor = Color(54,57,62),
    secondColor = Color(47,49,54),

    startMenuSize = {w = 0.2, h = 0.4},
    eventMenuSize = {w = 0.4, h = 0.3},
    giveWeaponSize = {w = 0.3, h = 0.5},
    adminMenuSize = {w = 0.3, h = 0.7},

    permittedCategories = {
        ['Разрешено'] = true,
        ['Премиум'] = true,
    },
    permittedWeapons = {
        weapon_physgun = 'PhysGun',
        weapon_physcannon = 'GravityGun',
        weapon_fists = 'Кулаки',
        keys = 'Ключи',
        gmod_camera = 'Камера',
        gmod_tool = 'Тулган',
        swat_shield = 'Щит',
        stunstick = 'Дубинка',
        weapon_ghost = 'Ghost Weapon',
        rchainsaw = 'Бензопила',
        stungun = 'Тайзер',
        ls_sniper = 'Снайперский тайзер',
        weapon_cuff_police = 'Наручники',
        weapon_cuff_rope = 'Веревка',
        weapon_slam = 'S.L.A.M',
        wrp_weapon_grizzly = 'LAR Grizzly .50',
        wrp_weapon_mosin = 'Винтовка Мосина',
        wrp_weapon_mp7 = 'HK MP7',
        wrp_weapon_spas12 = 'Franchi SPAS12',
        wrp_weapon_ar2 = 'S-LAR AR2',
        wrp_weapon_nailgun = 'Гвоздомёт',
        wrp_weapon_huntrifle = 'Охотничья винтовка',
        wrp_weapon_dbshotgun = 'Двуствольный дробовик',
        wrp_weapon_python = 'Colt Python',
        wrp_weapon_fal = 'FN Fal',
        wrp_weapon_csg = 'CSG-12 Drum',
        wrp_weapon_thompson = 'M1A1 Thompson',
        wrp_weapon_mauser = 'C96 Mauser',
        wrp_weapon_hk21 = 'HK21',


        weapon_hl2katana = 'Катана',
        weapon_hl2axe = 'Топор',
        weapon_hl2bottle = 'Бутылка',
        weapon_hl2hook = 'Крюк',
        weapon_hl2pan = 'Сковородка',
        weapon_hl2pickaxe = 'Кирка',
        weapon_hl2pipe = 'Труба',
        weapon_hl2pot = 'Ковш',
        weapon_hl2shovel = 'Лопата',
    },
    weaponPresets = {
        {
            name = 'Ничего не делать'
            -- Реально ничего не делает :flushed:
        },
        {
            name = 'Забрать все',
            weapons = {}, -- Да, это заберет все
        },
    }
}

dEvents.lang = {
    error_notEventer = 'Ты не являешься Ивентером',
    error_eventFounder = 'Ты уже проводишь ивент',
    error_noMembers = 'К ивенту никто не подключился :c',
    error_lowMembers = 'Недостаточно участников (%s/%s)',
    error_inEvent = 'Ты уже участвуешь в ивенте',
    error_eventNotExist = 'Ивент не существует',
    error_eventFull = 'Достигнуто максимальное количество участников',
    error_unknownCommand = 'Неизвестная команда',
    error_noEvent = 'Ты не проводишь ивент',
    error_arrested = 'Ты не можешь участвовать в ивенте из-за своего ареста',
    error_noEvents = 'Сейчас нет начинающихся ивентов',
    error_notInEvent = 'Ты сейчас не на ивенте',
    error_presetNameSize = 'Название пресета должно быть больше %s и меньше %s',
    error_eventPreparing = 'Сейчас начинается другой ивент. Попробуй позже',
    error_joining = 'Ты уже подключаешься к ивенту',
    error_notSAdmin = 'Ты не являешься Высшим Администратором',

    error_shortName = 'Название ивента должно быть длиннее 3 символов',
    error_maxPositions = 'Достигнут лимит позиций',
    error_stripNotChosen = 'Ты не выбрал выдачу оружия',
    error_noPositions = 'Ты не установил позиции для ивента',

    hint_teleported = 'Ты был телепортирован на ивент, приятной игры! Если ты захочешь покинуть его, то используй команду /leave',
    hint_respawned = 'Ты был возвращен на ивент',
    hint_kicked = 'Ты был исключен из ивента',
    hint_died = 'Ты был исключен из ивента из-за смерти',
    hint_eventEnded = 'Ивент был завершен',
    hint_arrested = 'Ты был исключен из ивента из-за ареста',
    hint_joined = 'Ты зарегистрировался на ивент и скоро будешь телепортирован',
    hint_eventInit = 'Ивент запущен',
    hint_eventStarted = 'Ивент начался. В ивент-меню ты можешь выделять игроков с помощью Shift и нажатием ПКМ применять на них команды. Также тебе доступен ивент-чат по команде /e',
    hint_left = 'Ты покинул ивент',

    hint_positionAdded = 'Позиция №%s установлена',

    vgui_preEvent = 'Начало ивента',
    vgui_preEvent_startTime = 'Существование команды',
    vgui_preEventPanelGuide = 'В этом меню ты можешь установить основные настройки для ивента.', --После его начала, тебе будут доступны более точные функции',
    vgui_preEvent_maxMembers = 'Максимум участников',
    vgui_preEvent_strip = 'Что с оружием?',
    vgui_preEvent_respawn = 'Включить возрождения',
    vgui_preEvent_positions = 'Установить точки телепорта',
    vgui_preEvent_start = 'Начать ивент',
    vgui_preEvent_posGuide = 'Устанавливай позиции в тех местах, где много свободного места, иначе игроки могут застревать в стенах или вовсе не телепортироваться',
    
    vgui_presetRemove = 'Выбери пресет, который ты хочешь удалить ниже',
    
    vgui_spectate = 'Наблюдать',
    vgui_goto = 'К нему',
    vgui_bring = 'К себе',

    event = 'Ивент',
    presetCreate = 'Создание пресета',
    giveWeapon = 'Выдача оружия',
    presetRemove = 'Удаление пресета',
    cooldown = 'Эй, не спеши так',

    log_usedCMD = 'Eventer %s(%s) used command %s on %s with args %s',
    log_eventStart = 'Eventer %s(%s) started event',
    log_eventEnd = 'Event from %s(%s) ended',

    init = 'Ивентер %s запустил ивент. Команда для подключения: /go (или go в консоль)\nНазвание: %s',
}
--addons/module_clans/lua/dorgs/classes/member.lua:
dOrgs.classes = dOrgs.classes or {}

dOrgs.classes.member = {
    __index = dOrgs.classes.member,
}

function dOrgs.classes.member:New(d)
    local obj = {}

    table.Merge(obj, d or {})

    --obj.__index = self

    return setmetatable(obj, {
        __index = dOrgs.classes.member
    })
end

AccessorFunc(dOrgs.classes.member, 'id', 'ID')
AccessorFunc(dOrgs.classes.member, 'rankLvl', 'RankLevel')
AccessorFunc(dOrgs.classes.member, 'name', 'Name')
AccessorFunc(dOrgs.classes.member, 'orgId', 'OrgID')

function dOrgs.classes.member:GetOrg()
    return self:GetOrgID() and dOrgs.orgs[self:GetOrgID()]
end

function dOrgs.classes.member:SetOrg(org)
    self:SetOrgID(org and org:GetID())
end

function dOrgs.classes.member:SetSteamID(sid)
    self.steamid = sid
    local ply = player.GetBySteamID(sid)
    if IsValid(ply) then
        self:SetPlayer(ply)
    end
end

function dOrgs.classes.member:GetSteamID()
    return self.steamid
end
dOrgs.classes.member.SteamID = dOrgs.classes.member.GetSteamID

function dOrgs.classes.member:GetRank()
    return self:GetOrg() and self:GetOrg():GetRank(self:GetRankLevel())
end

function dOrgs.classes.member:HasFlag(perm)
    return self:GetRank():HasFlag(perm)
end

function dOrgs.classes.member:SetPlayer(ply)
    if not IsValid(ply) then return end

    self.player = ply
end

function dOrgs.classes.member:GetPlayer()
    if IsValid(self.player) and CLIENT then
        if self.player:SteamID() ~= self.player:RealSteamID() then return end
    end
    return self.player
end

if SERVER then
    function dOrgs.classes.member:SetRank(level, cb)
        level = isnumber(level) and level or level:GetLevel()
        self:SetRankLevel(level)

        dOrgs.provider:UpdateMember(self, cb)
    end
end
--addons/module_clans/lua/dorgs/classes/upgrade.lua:
dOrgs.classes = dOrgs.classes or {}

dOrgs.classes.upgrade = {
    __index = dOrgs.classes.upgrade,
}

function dOrgs.classes.upgrade:New(d)
    local obj = {
        level = 0,
        maxLevel = 0,
    }

    table.Merge(obj, d or {})

    --obj.__index = self

    return setmetatable(obj, {
        __index = dOrgs.classes.upgrade
    })
end

wlib.accessor(dOrgs.classes.upgrade, 'id', 'ID')
wlib.accessor(dOrgs.classes.upgrade, 'name', 'Name')
wlib.accessor(dOrgs.classes.upgrade, 'desc', 'Description')
wlib.accessor(dOrgs.classes.upgrade, 'price', 'Price')
wlib.accessor(dOrgs.classes.upgrade, 'image', 'Image')
wlib.accessor(dOrgs.classes.upgrade, 'level', 'Level')
wlib.accessor(dOrgs.classes.upgrade, 'maxLevel', 'MaxLevel')

function dOrgs.classes.upgrade:SetImage(img)
    if SERVER then return self end
    self.image = img
    
    return self
end

function dOrgs.classes.upgrade:GetPrice(level)
    level = level or 1
    if not self.price then return end

    return istable(self.price) and self.price[level] or self.price
end

function dOrgs.classes.upgrade:Save()
    dOrgs.upgrades[self:GetID()] = self
end

function dOrgs.createUpgrade(id)
    local upg = dOrgs.classes.upgrade:New()
    upg:SetID(id)

    return upg
end
--addons/module_clans/lua/dorgs/sh_orgs.lua:
local PLAYER = FindMetaTable('Player')

function PLAYER:GetOrgMember(id)
    local data = self:GetNetVar('dOrgs.OrgMembers')

    return data and data[id]
end

function PLAYER:SetOrgMember(id, member)
    local old = self:GetNetVar('dOrgs.OrgMembers') or {}

    if id then
        old[id] = member
    else
        old = member
    end

    self:SetNetVar('dOrgs.OrgMembers', old)
end

function PLAYER:GetMainOrgID()
    return next(self:GetNetVar('dOrgs.OrgMembers') or {})
end

function player.GetByOrg(org)
    local id = isnumber(org) and org or org:GetID()
    local a = {}
    for _, v in player.Iterator() do
        if v:GetOrgMember(id) then a[#a+1] = v end
    end
    return a
end

function dOrgs.getOrg(id)
    return dOrgs.orgs[id]
end
--addons/module_clans/lua/dorgs/vgui/vgui_playerrow.lua:
--
--addons/module_clans/lua/dorgs/vgui/vgui_upgrade.lua:
local mat_gradient = Material('gui/center_gradient')
local color_green = Color(0, 255, 0)

local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self:SetTooltipDelay(0)
end

wlib.accessor(PANEL, 'org', 'Org')
wlib.accessor(PANEL, 'upgrade', 'Upgrade')
wlib.accessor(PANEL, 'color', 'Color')

function PANEL:SetOrg(org)
    self.org = org

    if self.upgrade then self:SetUpgrade(self.upgrade) end
end

function PANEL:SetUpgrade(upg)
    self.upgrade = upg

    local lvl = 0
    if self.org then
        lvl = self.org:GetUpgradeLevel(upg:GetID())
        
        if lvl < upg:GetMaxLevel() and self.org:GetMoney() >= upg:GetPrice(lvl+1) then
            self.color = color_green
        end
    end

    local lvlStr = ''
    if lvl > 0 and lvl ~= upg:GetMaxLevel() then
        lvlStr = (' (%s/%s)'):format(lvl, upg:GetMaxLevel())
    end

    self.nameText = upg:GetName() .. lvlStr
    self.priceText = lvl == upg:GetMaxLevel() and 'МАКС' or DarkRP.formatMoney(upg:GetPrice(lvl+1))

    self:SetTooltip(upg:GetDescription())
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, w, h, f4menu.col.bg)
    if self.color then
        surface.SetMaterial(mat_gradient)
        surface.SetDrawColor(self.color)
        surface.DrawTexturedRect(0, 0, w, h)
    end
    draw.RoundedBox(4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor)

    if self.upgrade then
        draw.SimpleText(self.nameText, 'dorgs.20', w/2, 4, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
        draw.SimpleText(self.priceText, 'dorgs.20', w/2, h-4, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

        local mat = self.upgrade:GetImage()
        if mat then
            local size = math.min(h-65, 72)
            surface.SetDrawColor(color_white)
            surface.SetMaterial(mat)
            surface.DrawTexturedRect(w/2 - size/2, h/2 - size/2, size, size)
        end
    end
end

function PANEL:DoClick()
    if not self.org or not self.upgrade then return end

    local lvl = self.org:GetUpgradeLevel(self.upgrade:GetID())

    if lvl >= self.upgrade:GetMaxLevel() then return notification.AddLegacy('Достигнут максимальный уровень улучшения', 1, 5) end

    local desc = ''
    if self.upgrade:GetDescription() then
        desc = '\n\n'..self.upgrade:GetDescription()
    end

    Derma_Query(
        ('Ты уверен, что хочешь купить улучшение %q (%s уровень)?%s'):format(self.upgrade:GetName(), lvl+1, desc),
        'Покупка улучшения',
        'Да',
        function()
            RunConsoleCommand('dorgs', 'buyupgrade', self.org:GetID(), self.upgrade:GetID())
        end,
        'Нет'
    )
end

vgui.Register('dorgs.upgrade', PANEL, 'DButton')
--addons/module_duels/lua/duelsystem/cl/cl_main.lua:
local countdown

net.Receive('duelSystem.CountDownDuel', function()
    countdown = net.ReadUInt(8)

    timer.Create('duelSystem.Sound', 1, countdown, function()
        LocalPlayer():EmitSound('UI/buttonclick.wav')
        countdown = countdown - 1
    end)

    timer.Simple(countdown + 0.1, function()
        countdown = nil
    end)

    LocalPlayer():EmitSound('UI/buttonclick.wav')
end)

local w, h = ScrW() / 2, ScrH() / 2

hook.Add('HUDPaint', 'duelSystem.countdown', function()
    if not countdown then return end
    draw.SimpleText(countdown, 'DermaLarge', w, h, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end)
--addons/module_meth/lua/autorun/eml_config.lua:
--I moved everything  to one file.

-- Drawing 3D2D things distance.
EML_DrawDistance = 100;

-- Allow physgun drag and drop on entities.
EML_Ingredients_Physgun = true; -- Allow physgun use on iodine, muriatic acid, sulfur and water.
EML_Products_Physgun = true; -- Allow physgun use on crystalized iodine, red phosphorus, meth.
EML_Cookware_Physgun = true; -- Allow physgun use on pot, special pot and jar.

EML_Gas_Physgun = true; -- Allow physgun use on gas canister.
EML_Stove_Physgun = true; -- Allow physgun use on stove.


-- Stove consumption on heat amount.
EML_Stove_Consumption = 1;
-- Stove heat amount.
EML_Stove_Heat = 1;
-- Amount of gas inside.
EML_Stove_Storage = 600;
-- Can grab with gravity gun?
EML_Stove_GravityGun = true;
-- 0 - Can't be exploded/destroyed; 1 - Can be destroyed without explosion; 2 - Explodes after taking amount of damage.
EML_Stove_ExplosionType = 2;
-- Stove health if type 1 or 2.
EML_Stove_Health = 400;
-- Stove explosion damage if type 2.
EML_Stove_ExplosionDamage = 100;
-- Stove smoke color.
EML_Stove_SmokeColor_R = 100;
EML_Stove_SmokeColor_G = 100;
EML_Stove_SmokeColor_B = 0;
-- Stove indicator color.
EML_Stove_IndicatorColor = Color(255, 222, 0, 255);


-- Pot default time.
EML_Pot_StartTime = 60;
-- Default time, which will be added to pot on collision with Muriatic Acid.
EML_Pot_OnAdd_MuriaticAcid = 10;
-- Default time, which will be added to pot on collision with Liquid Sulfur.
EML_Pot_OnAdd_LiquidSulfur = 10;
-- Change to false if you won't water/iodine/acid/sulfur disappear on empty.
EML_Pot_DestroyEmpty = true;


-- Special Pot default time.
EML_SpecialPot_StartTime = 60;
-- Default time, which will be added to pot on collision with Red Phosphorus.
EML_SpecialPot_OnAdd_RedPhosphorus = 20;
-- Default time, which will be added to pot on collision with Crystallized Iodine.
EML_SpecialPot_OnAdd_CrystallizedIodine = 20;
-- Change to false if you won't Red Phosphorus/Crystallized Iodine disappear on empty.
EML_SpecialPot_DestroyEmpty = true;


-- Default Liquid Sulfur amount.
EML_Sulfur_Amount = 2;
EML_Sulfur_Color = Color(243, 213, 19, 255);
-- Default Muriatic Acid amount.
EML_MuriaticAcid_Amount = 3;
EML_MuriaticAcid_Color = Color(160, 221, 99, 255);
-- Default Liquid Iodine amount.
EML_Iodine_Amount = 2;
EML_Iodine_Color = Color(137, 69, 54, 255);
-- Default Water amount.
EML_Water_Amount = 3;
EML_Water_Color = Color(133, 202, 219, 255);


-- Meth value modifier. (1500/lbs)
EML_Meth_ValueModifier = 12000;
-- Meth addicted person (I don't like NPCs at all).
EML_Meth_UseSalesman = false;
-- Make player wanted once he sold meth?
EML_Meth_MakeWanted = false;

-- Type 'methbuyer_setpos <name>' to add NPC on map (at your target position and faces to you).
-- Type 'methbuyer_remove <name>' to remove NPC from map.

-- Use text above salesman's head?
EML_Meth_SalesmanText = false;
-- Salesman name.
EML_Meth_Salesman_Name = "Скупщик мета";
-- Salesman name color.
EML_Meth_Salesman_Name_Color = Color(1, 241, 249, 255);
-- Salesman phrases if player don't have meth.
EML_Meth_Salesman_NoMeth = {
	"Уходи от сюда!",
	"Принеси мне мет!",
	"Мет,мет,мет?",
	"МЕТ!"
	};
-- Salesman sounds if player don't have meth.
EML_Meth_Salesman_NoMeth_Sound = {
	"vo/npc/male01/gethellout.wav",
	"vo/npc/male01/no02.wav",
	"vo/npc/male01/no01.wav",
	"vo/npc/male01/ohno.wav"	
	};
-- Salesman phrases if player got meth.
EML_Meth_Salesman_GotMeth = {
	"Оххх",
	"Ох как хорошо!",
	"О мой бог!",
	"Ох мне так хорошо стало!"
	};	
-- Salesman phrases if player don't have meth.	
EML_Meth_Salesman_GotMeth_Sound = {
	"vo/npc/male01/yeah02.wav",
	"vo/npc/male01/finally.wav",
	"vo/npc/male01/oneforme.wav",
	};

-- It starts on 0%.
EML_Jar_StartProgress = 0;
-- Minimal speed on shaking. (25 is ok)
EML_Jar_MinShake = 25;
-- Minimal speed on shaking. (1000 is ok)
EML_Jar_MaxShake = 1000;
-- Progress on correct shaking.
EML_Jar_CorrectShake = 4;
-- Progress on correct shaking.
EML_Jar_WrongShake = 1;
-- Change to false if you won't acid/iodine/water disappear on empty.
EML_Jar_DestroyEmpty = true;


-- Default gas amount in gas canister.
EML_Gas_Amount = 900;
-- 0 - Can't be exploded/destroyed; 1 - Can be destroyed without explosion; 2 - Explodes instantly.
EML_Gas_ExplosionType = 0;
-- Removes when out of gas.
EML_Gas_Remove = true;
--addons/module_elitef4menu/lua/f4/client.lua:
f4menu = f4menu or {}

surface.CreateFont('f4.header', {
	font = "Open Sans",
	size = 29,
	weight = 200
} )

surface.CreateFont('f4.main', {
	font = "Roboto",
	size = 19,
	weight = 500,
	extended = true,
})

surface.CreateFont('f4.sub', {
	font = "Roboto",
	size = 16,
	weight = 500,
	extended = true,
})

local cos = math.cos
local sin = math.sin
local rad = math.rad

f4menu.tabs = f4menu.tabs or {}

function f4menu.addTab(id, info)
	info.id = id
	local _, index = wlib.array.find(f4menu.tabs, function(t) return t.id == id end)
	if index then table.remove(f4menu.tabs, index) end
	table.insert(f4menu.tabs, info)
end

local circlered = Material('icon72/red_circle.png')
local yellowcircle = Material('icon72/yellow_circle.png')
local greencircle = Material('icon72/green_circle.png')
local menuicon = Material('icon72/bar_chart.png')
local gradient = Material('vgui/gradient-r')
local gradientUp = Material("gui/gradient_up")

f4menu.col = {
	bg = Color(43, 49, 54, 254),
	sidebar_bg = Color(43, 49, 54, 254),
	secondcolor = Color(38, 42, 46, 254),
	text_inactive = Color(200,200,200,255),
	linebar = Color(38, 42, 46, 254),--Color(43, 49, 54, 255),
	profile = Color(38, 42, 46, 250),
	header = Color(43, 49, 54, 255),
	gradientCol = Color(50,50,65),
	color_scroll = Color(0,0,0,70),
	buttonCol = Color(57, 52, 57, 255),
	buttonCol_hover = Color(47, 42, 47, 255),
}

f4menu.frame = f4menu.frame
function f4menu:open()
	self = self or f4menu

	self.createdTime = CurTime()
	if IsValid(self.frame) then
		for _, v in ipairs(self.frame.sidebar.scroll:GetCanvas():GetChildren()) do
			if v.tab.check then
				v:SetVisible(v.tab.check())
			end
		end
		self.frame.sidebar.scroll:InvalidateLayout()
		self.frame:SetVisible(true)

		hook.Run('f4menu.opened', self.frame)
		return
	end

    self.buttons = {}

	local tall = math.min(ScrH()-100, 900)

	self.frame = vgui.Create('DFrame')
	self.frame:SetSize(math.min(tall*1.5, ScrW()-100), tall)
	self.frame:Center()
	self.frame:SetTitle('')
	self.frame:MakePopup()
	self.frame:ShowCloseButton(false)
	self.frame:DockPadding(0,32,0,0)
	self.frame.Paint = function(s, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, 32, self.col.header, true, true, false, false)
		
        surface.SetDrawColor( color_white )
		surface.SetMaterial( circlered )
		surface.DrawTexturedRect( 16, 12, 12, 12 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( yellowcircle )
		surface.DrawTexturedRect( 16 + 12 + 4, 12, 12, 12 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( greencircle )
		surface.DrawTexturedRect( 16 + 12 + 12 + 8, 12, 12, 12 )
		
		if input.IsKeyDown(95) and CurTime() - self.createdTime > 0.2 then
			self:close()
		end
	end
	
	self.frame.close = vgui.Create('DButton', self.frame)
	self.frame.close:SetSize( 32, 32 )
	self.frame.close:SetPos(self.frame:GetWide() - 32, 0)
	self.frame.close:SetText('r')
	self.frame.close:SetFont('marlett')
	self.frame.close:SetTextColor(self.col.text_inactive)
	self.frame.close.Paint = wlib.func.blank
	self.frame.close.DoClick = function(s) self:close() end

	self.frame.sidebar = vgui.Create('DPanel', self.frame)
	self.frame.sidebar:Dock(LEFT)
	self.frame.sidebar:SetWide(180)
	self.frame.sidebar.Paint = function(s, w, h)
		draw.RoundedBoxEx( 4, 0, 0, w, h, self.col.sidebar_bg, false, false, true, false )
    	surface.SetMaterial( gradientUp )
    	surface.SetDrawColor( f4menu.col.gradientCol )
    	surface.DrawTexturedRect( 0, 0, w, h )
	end

	self.frame.sidebar.info = vgui.Create('DPanel', self.frame.sidebar)
	self.frame.sidebar.info:Dock(TOP)
	self.frame.sidebar.info:DockMargin(0,1,5,1)
	self.frame.sidebar.info:SetTall(50)
	self.frame.sidebar.info.Paint = function(s, w, h)
        draw.RoundedBox( 0, 0, 0, w, h, f4menu.col.profile)
	end

	self.frame.sidebar.info.avatar = vgui.Create('AvatarImage', self.frame.sidebar.info)
	self.frame.sidebar.info.avatar:SetSize(36, 36)
	self.frame.sidebar.info.avatar:SetPos(12, 7)
	self.frame.sidebar.info.avatar:SetSteamID(LocalPlayer():SteamID64(), 32)

	self.frame.sidebar.info.name = vgui.Create('DLabel', self.frame.sidebar.info)
	self.frame.sidebar.info.name:SetWide( 128 )
	self.frame.sidebar.info.name:SetPos( 54, 5 )
	self.frame.sidebar.info.name:SetAutoStretchVertical(true)
	self.frame.sidebar.info.name:SetFont('f4.main')
	self.frame.sidebar.info.name:SetText(utf8.upper(LocalPlayer():Name()))
	self.frame.sidebar.info.name:SetTextColor(color_white)

	self.frame.sidebar.info.online = vgui.Create('DLabel', self.frame.sidebar.info)
	self.frame.sidebar.info.online:SetWide( 128 )
	self.frame.sidebar.info.online:SetPos( 54, 25 )
	self.frame.sidebar.info.online:SetAutoStretchVertical(true)
	self.frame.sidebar.info.online:SetFont('f4.main')
	self.frame.sidebar.info.online:SetText('')
	self.frame.sidebar.info.online:SetTextColor(color_white)
	local nxt = CurTime()
	self.frame.sidebar.info.online.Think = function(self)
		if nxt > CurTime() then return end
		nxt = CurTime()+1

		local t = LocalPlayer():GetUTimeTotalTime()
		self:SetText(('%02i:%02i:%02i'):format(math.floor(t/3600), math.floor(t/60%60), t%60))
	end

	self.frame.sidebar.scroll = vgui.Create('DScrollPanel', self.frame.sidebar)
	self.frame.sidebar.scroll:Dock(FILL)

	self.frame.header = vgui.Create('DPanel', self.frame)
	self.frame.header:Dock(TOP)
	self.frame.header:SetTall(50)
	self.frame.header.Paint = function(self, w, h)
		draw.RoundedBox( 0, 0, 0, w, h, f4menu.col.linebar) -- белая хуйня
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial(self.icon or menuicon)
		surface.DrawTexturedRect( 15, (h-32)/2, 32, 32 )
	end

	self.frame.header.title = vgui.Create('DLabel', self.frame.header)
	self.frame.header.title:Dock(LEFT)
	self.frame.header.title:DockMargin(56, 0, 0, 0)
	self.frame.header.title:SetFont('f4.header')
	self.frame.header.title:SetText('')
	self.frame.header.title:SetTextColor(color_white)
	self.frame.header.title:SizeToContents()

	self.frame.main = vgui.Create('wlib.multipanel', self.frame)
	self.frame.main:Dock(FILL)
	self.frame.main.Paint = function(self, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, h, f4menu.col.bg)
    	surface.SetMaterial( gradientUp )
    	surface.SetDrawColor( f4menu.col.gradientCol )
    	surface.DrawTexturedRect( 0, 0, w, h )
	end

	self.frame.main:InvalidateParent(true)

	table.SortByMember(self.tabs, 'order', true)
	for k, tab in ipairs(self.tabs) do
		local btn = vgui.Create('DButton', self.frame.sidebar.scroll)
		btn.tab = tab
		btn:Dock(TOP)
		btn:DockMargin(5,5,5,5)
		btn:SetTall(50)
		btn:SetText('')
		btn:SetTextColor(tab.color or self.col.text_inactive)
		btn:SetFont('f4.main')
		btn.Paint = function(s,w,h)
			if s.hovered or s.selected then
			    draw.RoundedBox(6,0,0,w,h, f4menu.col.buttonCol)
			end
			--if s.hovered then
			--surface.SetDrawColor(col_hovered)
			--surface.SetMaterial(gradient)
			--surface.DrawTexturedRect(0, 0, w, h)
			--end

			surface.SetDrawColor(color_white)
			surface.SetMaterial(tab.icon)
			surface.DrawTexturedRect(10, 10, 30, 30)

			local col = s.hovered and (tab.hoveredColor or color_white) or (tab.color or self.col.text_inactive)
			draw.SimpleText(tab.title or 'Вкладка', 'f4.main', 50, h/2, col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		btn.OnCursorEntered = function(s)
			s.hovered = true
			s:SetTextColor(tab.hoveredColor or color_white)
		end

		btn.OnCursorExited = function(s)
			s.hovered = false
			s:SetTextColor(tab.color or Color(151, 154, 160))
		end
		
		table.insert(self.buttons, btn)

        if tab.panel then
            local pnl = tab:panel(self.frame.main)
		    self.frame.main:AddPanel(pnl, tab.id)
			if k == 1 then
				self:selectTab(tab.id)
			end

            btn.DoClick = function(s, w, h)
				self:selectTab(tab.id)
            end
        elseif tab.callback then
            btn.DoClick = fp{tab.callback, tab}
        end

		self.frame.sidebar.scroll:AddItem(btn)

		if tab.check then
			btn:SetVisible(tab.check())
		end
	end
	self.frame.sidebar.scroll:InvalidateLayout()

	hook.Run('f4menu.opened', self.frame)
end

function f4menu:close()
	self = self or f4menu
	if IsValid(self.frame) then self.frame:SetVisible(false) end

	hook.Run('f4menu.closed')
end

function f4menu:toggle()
	self = self or f4menu
	if IsValid(self.frame) and self.frame:IsVisible() then
		self:close()
	else
		self:open()
	end
end

function f4menu:remove()
	self = self or f4menu
	if IsValid(self.frame) then self.frame:Remove() end
end

function f4menu:getPanel(id)
	if not IsValid(self.frame) then return end
	return self.frame.main:GetPanel(id)
end

function f4menu:updateTabs()
	self = self or f4menu
	if not IsValid(self.frame) then return end
	
	local pnl = self.frame.main:GetActivePanel()
	if IsValid(pnl) and pnl.OnSelected then pnl:OnSelected() end
end

function f4menu:selectTab(id)
	local tab = wlib.array.find(f4menu.tabs, function(t) return t.id == id end)
	if not tab or not IsValid(self.frame) then return end

	self.frame.header.icon = tab.icon
	self.frame.main:SelectPanel(tab.id)
	self.frame.header.title:SetText(tab.title or 'Вкладка')
	self.frame.header.title:SizeToContents()
	
	for _, v in ipairs(self.buttons) do
		v.selected = v.tab.id == tab.id
	end
end

timer.Create('F4Override', 2, 0, function()
	GAMEMODE.ShowSpare2 = fp{f4menu.toggle, f4menu}
end) 

function f4menu:styleVBar(vbar)
	vbar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	vbar.btnUp.Paint = wlib.func.blank
	vbar.btnDown.Paint = wlib.func.blank
	vbar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end
end
--addons/module_elitef4menu/lua/f4/tabs/weapons.lua:
local gradient = Material("gui/center_gradient")

local function GetColorBasedOnPrice(price)
    local minPrice = 10000
    local maxPrice = 150000

    local normalized = math.Clamp((price - minPrice) / (maxPrice - minPrice), 0, 1)

    if normalized <= 0.5 then
        local progress = normalized * 2
        local r = math.floor(255 * progress)
        local g = math.floor(255 * progress)
        local b = math.floor(255 * (1 - progress))
        return Color(r, g, b)
    else
        local progress = (normalized - 0.5) * 2
        local r = 255
        local g = math.floor(255 * (1 - progress))
        local b = 0
        return Color(r, g, b)
    end
end

local function OpenWeaponsTab(tab, parent)
	local pnl = vgui.Create('DPanel', parent)
	pnl:Dock(FILL)
	pnl.Paint = function(s,w,h)
		draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
	end
	pnl:DockMargin(30, 30, 30, 30)
	pnl:DockPadding(25, 25, 25, 25)

	local lbl = vgui.Create('DLabel', pnl)
	lbl:Dock(TOP)
	lbl:SetAutoStretchVertical(true)
	lbl:SetFont('f4.main')
	lbl:SetTextColor(f4menu.col.text_inactive)
	lbl:SetText('Коробки с оружием')
	
	local scroll = vgui.Create('DScrollPanel', pnl)
	scroll:Dock(FILL)
	scroll.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	scroll.VBar.btnUp.Paint = function( s, w, h ) end
	scroll.VBar.btnDown.Paint = function( s, w, h ) end
	scroll.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end

	local panel_list = vgui.Create('DIconLayout', scroll)
	panel_list:Dock(FILL)
	panel_list:SetSpaceX(4)
	panel_list:SetSpaceY(8)
	panel_list:DockMargin(0, 10, 0, 0)
	panel_list:DockPadding( 0, 5, 10, 0 )
	pnl:InvalidateParent(true)
	scroll:InvalidateParent(true)
	scroll:PerformLayoutInternal()
	panel_list:InvalidateParent(true)
	panel_list:InvalidateLayout(true)

	pnl.OnSelected = function()
		panel_list:Clear()
		for k, v in pairs( CustomShipments ) do
			if not v.noship and table.HasValue(v.allowed, LocalPlayer():Team())
				and (not v.customCheck or (v.customCheck and v.customCheck(LocalPlayer()))) then

				local entpan = vgui.Create( "Panel" )
				entpan.price = GetColorBasedOnPrice(v.price)
				entpan.Paint = function( self, w, h )
        			draw.RoundedBox( 4, 0, 0, w, h, f4menu.col.bg)-- v.color )
                	surface.SetMaterial( gradient )
                	surface.SetDrawColor( self.price )
                	surface.DrawTexturedRect( 0, 0, w, h )
        			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )
					
					draw.SimpleText( v.name..' x5', "f4.main", 56, 14, color_white )
					draw.SimpleText( "Цена: "..DarkRP.formatMoney(v.price), "f4.main", 56, 35, Color( 100, 100, 100 ) )
				end
				
				local entModel = vgui.Create( "SpawnIcon", entpan )
				entModel:SetSize( 45, 45 )
				entModel:SetPos( 5, 5 )
				entModel:SetModel(v.model)
				entModel:SetMouseInputEnabled(false)
				entModel.PaintOver = wlib.func.blank

				entpan:SetSize((scroll:GetWide() - scroll.VBar:GetWide())/2 - 8, 60)

				local entButton = vgui.Create( "DButton", entpan )
				entButton:SetSize( entpan:GetWide(), entpan:GetTall() )
				entButton:SetText( "" )
				entButton.Paint = wlib.func.blank
				entButton.DoClick = function()
					RunConsoleCommand('darkrp', 'buyshipment', v.name)
				end
				entButton.OnCursorEntered = function( self )
					self.hover = true
				end
				entButton.OnCursorExited = function( self )
					self.hover = false
				end
				
				panel_list:Add( entpan )
			end
		end

		scroll:PerformLayoutInternal()
	end
	
	return pnl
end

f4menu.addTab('weapons', {
	order = 200,
	title = 'Оружие',
	panel = OpenWeaponsTab,
	icon = Material('icon72/gun.png'),
	check = function()
		return LocalPlayer():Team() == TEAM_GUN
	end,
})
--addons/module_hits/lua/autorun/hitload.lua:
hitSystem = hitSystem or {}

local function sh(path)
    if SERVER then
        AddCSLuaFile(path)
    end

    include(path)
end

local function cl(path)
    if SERVER then
        AddCSLuaFile(path)
    else
        include(path)
    end
end

local function sv(path)
    if SERVER then
        include(path)
    end
end

-- nw
sh('hitsystem/nwvars.lua')
--SH
sh('hitsystem/lang.lua')
sh('hitsystem/config.lua')
sh('hitsystem/sh/sh_funcs.lua')
--SV
sv('hitsystem/sv/sv_subfuncs.lua')
sv('hitsystem/sv/sv_funcs.lua')
sv('hitsystem/sv/sv_hooks.lua')
sv('hitsystem/sv/sv_net.lua')
--CL
cl('hitsystem/cl/cl_main.lua')
--addons/module_market/lua/autorun/market_init.lua:
wmarket = wmarket or {}

wlib.include.prefixed('market', {
    'sh_config',
    'sh_util',
    '*',
})

wlib.include.shared('market/items')
wlib.include.shared('market/currencies')
wlib.include.client('market/vgui')

hook.Add('Think', 'wmarket.init', function()
    hook.Remove('Think', 'wmarket.init')

    timer.Simple(5, function()
        if SERVER then
            for _, cur in ipairs(wmarket.currencies) do
                for _, item in ipairs(wmarket.items) do
                    wmarket.updateItem(cur.id, item.id, true)
                end
            end
        end
    end)
end)
--addons/module_market/lua/market/items/currencies.lua:
http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/gem.png', 'gem.png')

wmarket.addItem('points', {
    name = 'Рубли',
    description = 'Валюта для покупки донат-предметов',
    currency = 'darkrp',
    visible_currencies = {'darkrp', 'points'},
    list_order = 0,
    material = 'data/wimages/gem.png',
    getMaterial = function(self)
        return self.material
    end,
    canAdd = function(self, ply, amount)
        return true
    end,
    add = function(self, ply, amount)
        ply:PS_GivePoints(amount)
    end,
    canTake = function(self, ply, amount)
        return ply:PS_HasPoints(amount)
    end,
    take = function(self, ply, amount)
        ply:PS_TakePoints(amount)
    end,
    getAmount = function(self, ply)
        return ply:PS_GetPoints()
    end,
})
--addons/module_market/lua/market/items/itemstore.lua:
local items = {
    {'fake_license', nil, 'icon72/not_renamed/1faaa.png'},
    {'durgz_fireammo', 'models/jaanus/aspbtl.mdl', 'icon72/fire.png'},
    {'craft_scrap', nil, 'icon72/gear.png'},
    {'craft_electronics', nil, 'icon72/gear.png'},
}

timer.Simple(0, function()
    for _, v in ipairs(items) do
        local class = v[1]
    
        local ITEM = itemstore.items.Get(class)
        if not ITEM then continue end
    
        wmarket.addItemStoreItem(class, {
            name = ITEM.Name,
            description = ITEM.Description,
            category = 'Прочее',
            material = v[3] or 'icon72/gear.png',
            getMaterial = function(self)
                return self.material
            end,
            itemstore_class = class,
            item_fields = {
                ['Model'] = v[2],
            },
        })
    end
end)
--addons/module_market/lua/market/vgui/item.lua:
local PANEL = {}
local gradient = Material("gui/center_gradient")
local function GetColorBasedOnPrice(price)
    local minPrice = 500000
    local maxPrice = 100000000

    local normalized = math.Clamp((price - minPrice) / (maxPrice - minPrice), 0, 1)

    if normalized <= 0.5 then
        local progress = normalized * 2
        local r = math.floor(255 * progress)
        local g = math.floor(255 * progress)
        local b = math.floor(255 * (1 - progress))
        return Color(r, g, b)
    else
        local progress = (normalized - 0.5) * 2
        local r = 255
        local g = math.floor(255 * (1 - progress))
        local b = 0
        return Color(r, g, b)
    end
end

function PANEL:Init()
    self:SetText('')
    
    self.image = vgui.Create('DImageButton', self)
    self.image:Dock(LEFT)
    self.image:DockMargin(2,2,2,2)

    self.image.OnCursorEntered = function()
        local item = self:GetItem()
        if item and item.preview then
            local p = item:preview()
            wlib.panels.tooltip(self.image, p)
        end
    end

    self.image.OnCursorExited = function()
        wlib.panels.removeTooltip()
    end

    self.name = vgui.Create('DLabel', self)
    self.name:Dock(LEFT)
    self.name:DockMargin(4,0,0,0)
    self.name:SetFont('wmarket.24')
    self.name:SetText('')
    self.name:SetTextColor(color_white)

    self.amount = vgui.Create('DLabel', self)
    self.amount:Dock(RIGHT)
    self.amount:DockMargin(0,0,4,0)
    self.amount:SetFont('wmarket.24')
    self.amount:SetText('')
    self.amount:SetTextColor(color_white)
end
wlib.accessor(PANEL, 'item', 'Item')
wlib.accessor(PANEL, 'currency', 'Currency')

function PANEL:IsSelected()
    if not wmarket.selectedItem or not wmarket.selectedCurrency then return false end
    if self.item.id ~= wmarket.selectedItem.id then return false end

    if self.item.visible_currencies and table.HasValue(self.item.visible_currencies, wmarket.selectedCurrency.id) then
        return true
    elseif self.currency.id == wmarket.selectedCurrency.id then
        return true
    end
    
    return false
end

function PANEL:PerformLayout(w, h)
    self.image:SetWide(h-4)
end

function PANEL:Rebuild()
    if not self.item or not self.currency then return end
    local sum = wmarket.summary[self.currency.id] and wmarket.summary[self.currency.id][self.item.id]
    if not sum then return end

    self.image:SetMaterial(self.item.getMaterial and self.item:getMaterial())
    self.colprice = GetColorBasedOnPrice(sum[MARKET_SELL].minPrice or 0)
    self.name:SetText(self.item.name)
    self.amount:SetText(('%s шт. от %s'):format(sum[MARKET_SELL].total or 0, self.currency:formatAmount(math.Round(sum[MARKET_SELL].minPrice or 0, self.currency.decimals or 0))))

    self.name:SizeToContents()
    self.amount:SizeToContents()
end

function PANEL:Paint(w, h)
    draw.RoundedBox( 4, 0, 0, w, h, f4menu.col.bg)-- v.color )
    surface.SetMaterial( gradient )
    surface.SetDrawColor( self.colprice )
    surface.DrawTexturedRect( 0, 0, w, h )
    draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )
    
    if self:IsSelected() or self:IsHovered() then
        draw.RoundedBox(6,0,0,w,h, f4menu.col.buttonCol)
    end
end

function PANEL:PaintOver(w, h)
    if self.startGlow then
        local elapsed = CurTime()-self.startGlow

        surface.SetDrawColor(233, 84, 90, math.sin(elapsed*3.14)*150)
        surface.DrawRect(0,0,w,h)
    
        if elapsed > 1 then self.startGlow = nil end
    end
end

function PANEL:Glow()
    self.startGlow = CurTime()
end

vgui.Register('wmarket_item', PANEL, 'DButton')
--addons/ent_moneyclickers/lua/autorun/money_clickers.lua:
MCLICKERS = MCLICKERS or {}

include("mclickers_config.lua")

if SERVER then
    AddCSLuaFile("mclickers_config.lua")

    if MCLICKERS.useWorkshop then
        resource.AddWorkshop("685912753")
    else
        resource.AddFile("resource/fonts/roboto.ttf")

        resource.AddFile("materials/moneyclickers/heat.vmt")
        resource.AddFile("materials/moneyclickers/creditcard.vmt")
        resource.AddFile("materials/moneyclickers/health.vmt")
        resource.AddFile("materials/moneyclickers/repair.vmt")

        resource.AddFile("materials/moneyclickers/upgrade_autoclick.vmt")
        resource.AddFile("materials/moneyclickers/upgrade_clickpower.vmt")
        resource.AddFile("materials/moneyclickers/upgrade_cooling.vmt")
        resource.AddFile("materials/moneyclickers/upgrade_storage.vmt")
    end
end

function MCLICKERS.error(...)
    MsgC(Color(255, 150, 0), "[MClickers-Error] ", ...)
    MsgC("\n")
end

function MCLICKERS.print(...)
    MsgC(Color(0, 255, 0), "[MClickers] ", Color(255, 255, 255), ...)
    MsgC("\n")
end

function MCLICKERS.formatPoints(pts)
    return string.format(MCLICKERS.language.textPointsAmount, pts)
end

if SERVER then
    include("mclickers_version.lua")

end

--addons/module_outfitter/lua/includes/modules/fileextras.lua:
if SERVER then
	AddCSLuaFile()
end


local File = FindMetaTable"File"

local visit_folders
visit_folders = function(init_path,scope,cb)
	scope = scope or 'GAME'
	
	local stack = {
		init_path,
	}
	
	-- "models/player"
	
	-- "models/player/fld1"
	-- "models/player/fld2"
	
	-- "models/player/fld1/asd"
	-- "models/player/fld1/qwe"
	-- "models/player/fld2"
	
	while stack[1] do
		local entry = stack[1]
		table.remove(stack,1)
		
		local fi,fo = file.Find(entry..'/*.*',scope)
		local ret = cb(entry..'/',fi,fo)
		if ret == nil then
			for k,v in next,fo do
				table.insert(stack,1,entry..'/'..v)
			end
		elseif ret == false then return end
	end
	
end


file.RecurseFolders = visit_folders

local tmp = {}
function File.ReadString(f,n,ch)
	n = n or 256
	ch = ch or '\0'
	local startpos = f:Tell()
	local offset = 0
	local tmpn = 0
	local sz = f:Size()
	
	--TODO: Use n and sz instead
	for i=1,1048576 do
--	while true do
		if f:Tell()>=sz then return nil,"eof" end
		local str = f:Read(n)
		--if not str then return nil,"eof","wtf" end
		local pos = str:find(ch,1,true)
		if pos then
			--offset = offset + pos
			
			--reset position
			f:Seek(startpos+offset+pos)
			
			tmp[tmpn + 1] = str:sub(1,pos - 1)
			return table.concat(tmp,'',1,tmpn+1)
		else
			tmpn = tmpn + 1
			tmp[tmpn] = str
			offset = offset + n
		end
	end
	return nil,"not found"
end
--addons/module_outfitter/lua/includes/modules/mdlinspect.lua:
local Tag='mdlinspect'

module(Tag,package.seeall)

local function from_int(s,...)
	local size = 4
	local n = from_u_int(s,...)
	if n >= 2^(size*8-1) then
		return n - 2^(size*8)
	end
	return n
end


-- Format: https:--developer.valvesoftware.com/wiki/MDL#File_format
local vstruct
local needvstruct needvstruct = function()
	vstruct = vstruct or _G.vstruct
	if not vstruct then
		local ok,ret = pcall(require,'vstruct')
		if ok then vstruct=ret or _G.vstruct end
	end
	
	needvstruct=function() return vstruct end
	
	return vstruct
end

MAX_FORMAT = 49
local MDL = {}
local _M = {__index = MDL,__tostring=function(self) return "MDL Parser" end}
function Open(f)
	if isstring(f) then
		f = file.Open(f,'rb','GAME')
	end
	
	if not f then error"invalid file" end
	
	local initial_offset = f:Tell()
	
	local hdr = f:Read(4)
	if hdr~='IDST' then
		return nil,"notmdl"
	end
	
	local version = from_int(f:Read(4),true)
	
	if version>MAX_FORMAT then
		return nil,'newformat',version
	end
	
	local T = {
		file = f,
		version = version,
		initial_offset=initial_offset
	}
	
	return setmetatable(T,_M)
	
end

function MDL:IsValid()
	return self.file and true or false
end

function MDL:GetFile()
	return self.file
end

function MDL:Close()
	local f = self.file
	f:Close()
	self.file = false
end

function MDL:_ParseFail(reason)
	self.parsed_header = false
	self.parse_error = reason or "?"
	self.error = "Parsing failed: "..tostring(reason)
	return nil,reason
end

function MDL:GetError()
	return self.error
end

function MDL:HasFlag(f)
	local bit=ubit or bit
	return bit.band(self.flags,f)==f
end



local flaglist={
[0]="AUTOGENERATED_HITBOX",
"USES_ENV_CUBEMAP",
"FORCE_OPAQUE",
"TRANSLUCENT_TWOPASS",
"STATIC_PROP",
"USES_FB_TEXTURE",
"HASSHADOWLOD",
"USES_BUMPMAPPING",
"USE_SHADOWLOD_MATERIALS",
"OBSOLETE",
"UNUSED",
"NO_FORCED_FADE",
"FORCE_PHONEME_CROSSFADE",
"CONSTANT_DIRECTIONAL_LIGHT_DOT",
"FLEXES_CONVERTED",
"BUILT_IN_PREVIEW_MODE",
"AMBIENT_BOOST",
"DO_NOT_CAST_SHADOWS",
"CAST_TEXTURE_SHADOWS",
}

function MDL:ListFlags()
	local t = {}
	for i=0,#flaglist do
		if self:HasFlag(2^i) then
			t[flaglist[i]] = true
		end
	end
	return t
end

function MDL:Validate(filesize)
	local size = self.dataLength
	
	local f=self.file
	--TODO: can be wrong
	local fsize = filesize or (f:Size()-self.initial_offset)
	

	if fsize ~=size then
		return nil,"size"
	end
	
	--local checksum = from_int(self.checksum,true)
	--local crc = util.CRC(dat)
	--dat = nil
	--
	--if tostring(checksum)~=tostring(crc) then
	--	return nil,"checksum","("..tostring(crc)..','..tostring(checksum)..")"
	--end
	
	return true
end

function MDL:ParseHeader()
	if self.parsed_header~=nil then
		return self.parsed_header
	end
	self.parsed_header = false
	
	local f = self.file
	local res = self
	
	res.checksum = f:Read(4)
	
	local name = f:Read(64)
	name = name:match'^[^%z]*' or ""
	res.name = name
	
	local dataLength = from_int(f:Read(4),true)
	res.dataLength = dataLength
	
	-- TODO: skip Vectors, read elsewhere
	f:Seek( f:Tell()+4 * 3 *6 )
	
	res.flags=from_int(f:Read(4),true)
	
	-- mstudiobone_t
	res.bone_count = from_int(f:Read(4),true)	-- Number of data sections (of type mstudiobone_t)
	res.bone_offset = from_int(f:Read(4),true)	-- Offset of first data section
 
	-- mstudiobonecontroller_t
	res.bonecontroller_count = from_int(f:Read(4),true)
	res.bonecontroller_offset = from_int(f:Read(4),true)
 
	-- mstudiohitboxset_t
	res.hitbox_count = from_int(f:Read(4),true)
	res.hitbox_offset = from_int(f:Read(4),true)
 
	-- mstudioanimdesc_t
	res.localanim_count = from_int(f:Read(4),true)
	res.localanim_offset = from_int(f:Read(4),true)
 
	-- mstudioseqdesc_t
	res.localseq_count = from_int(f:Read(4),true)
	res.localseq_offset = from_int(f:Read(4),true)
 
	res.activitylistversion = from_int(f:Read(4),true) -- ??
	res.eventsindexed = from_int(f:Read(4),true)	-- ??
 
	-- VMT texture filenames
	-- mstudiotexture_t
	res.texture_count = from_int(f:Read(4),true)
	res.texture_offset = from_int(f:Read(4),true)
 
	-- This offset points to a series of ints.
		-- Each int value, in turn, is an offset relative to the start of this header/the-file,
		-- At which there is a null-terminated string.
	res.texturedir_count = from_int(f:Read(4),true)
	res.texturedir_offset = from_int(f:Read(4),true)
 
	-- Each skin-family assigns a texture-id to a skin location
	res.skinreference_count = from_int(f:Read(4),true)
	res.skinrfamily_count = from_int(f:Read(4),true)
	res.skinreference_index = from_int(f:Read(4),true)
 
	-- mstudiobodyparts_t
	res.bodypart_count = from_int(f:Read(4),true)
	res.bodypart_offset = from_int(f:Read(4),true)
 
	-- Local attachment points
	-- mstudioattachment_t
	res.attachment_count = from_int(f:Read(4),true)
	res.attachment_offset = from_int(f:Read(4),true)
 
	-- Node values appear to be single bytes, while their names are null-terminated strings.
	res.localnode_count = from_int(f:Read(4),true)
	res.localnode_index = from_int(f:Read(4),true)
	res.localnode_name_index = from_int(f:Read(4),true)
 
	-- mstudioflexdesc_t
	res.flexdesc_count = from_int(f:Read(4),true)
	res.flexdesc_index = from_int(f:Read(4),true)
 
	-- mstudioflexcontroller_t
	res.flexcontroller_count = from_int(f:Read(4),true)
	res.flexcontroller_index = from_int(f:Read(4),true)
 
	-- mstudioflexrule_t
	res.flexrules_count = from_int(f:Read(4),true)
	res.flexrules_index = from_int(f:Read(4),true)
 
	-- IK probably referse to inverse kinematics
	-- mstudioikchain_t
	res.ikchain_count = from_int(f:Read(4),true)
	res.ikchain_index = from_int(f:Read(4),true)
 
	-- Information about any "mouth" on the model for speech animation
	-- More than one sounds pretty creepy.
	-- mstudiomouth_t
	res.mouths_count = from_int(f:Read(4),true)
	res.mouths_index = from_int(f:Read(4),true)
 
	-- mstudioposeparamdesc_t
	res.localposeparam_count = from_int(f:Read(4),true)
	res.localposeparam_index = from_int(f:Read(4),true)
 
	--[[
	 * For anyone trying to follow along, as of this writing,
	 * the next "surfaceprop_index" value is at position 0x0134 (308)
	 * from the start of the file.
	 --]]
 
	-- Surface property value (single null-terminated string)
	res.surfaceprop_index = from_int(f:Read(4),true)
 
	-- Unusual: In this one index comes first, then count.
	-- Key-value data is a series of strings. If you can't find
	-- what you're interested in, check the associated PHY file as well.
	res.keyvalue_index = from_int(f:Read(4),true)
	res.keyvalue_count = from_int(f:Read(4),true)
 
	-- More inverse-kinematics
	-- mstudioiklock_t
	res.iklock_count = from_int(f:Read(4),true)
	res.iklock_index = from_int(f:Read(4),true)
 
 
	res.mass = f:ReadFloat() -- Mass of object (4-bytes)
	res.contents = from_int(f:Read(4),true)	-- ??
 
	-- Other models can be referenced for re-used sequences and animations
	-- (See also: The $includemodel QC option.)
	-- mstudiomodelgroup_t
	res.includemodel_count = from_int(f:Read(4),true)
	res.includemodel_index = from_int(f:Read(4),true)
 
	res.virtualModel = from_int(f:Read(4),true)	-- Placeholder for mutable-void*
 
	-- mstudioanimblock_t
	res.animblocks_name_index = from_int(f:Read(4),true)
	res.animblocks_count = from_int(f:Read(4),true)
	res.animblocks_index = from_int(f:Read(4),true)
 
	res.animblockModel = from_int(f:Read(4),true) -- Placeholder for mutable-void*
 
	-- Points to a series of bytes?
	res.bonetablename_index = from_int(f:Read(4),true)
 
	res.vertex_base = from_int(f:Read(4),true)	-- Placeholder for void*
	res.offset_base = from_int(f:Read(4),true)	-- Placeholder for void*
 
	-- Used with $constantdirectionallight from the QC
	-- Model should have flag #13 set if enabled
	res.directionaldotproduct = f:Read(1)
 
	res.rootLod = f:Read(1)	-- Preferred rather than clamped
 
	-- 0 means any allowed, N means Lod 0 -> (N-1)
	res.numAllowedRootLods = f:Read(1);
 
	f:Read(1)--		unused; -- ??
	res.unused = from_int(f:Read(4),true) -- ??
 
	-- mstudioflexcontrollerui_t
	res.flexcontrollerui_count = from_int(f:Read(4),true)
	res.flexcontrollerui_index = from_int(f:Read(4),true)
 
	--[[*
	 * Offset for additional header information.
	 * May be zero if not present, or also 408 if it immediately
	 * follows this studiohdr_t
	 --]]
	-- studiohdr2_t
	res.studiohdr2index = from_int(f:Read(4),true)
	
	return true
	
end

local offsetreaderinfo_1 = {}
local offsetreaderinfo_2 = {}
function MDL:IncludedModels()
	local f = self.file
	local t = self.included_models
	if t then return t end
	
	local ok = self:SeekTo(self.includemodel_index)
	assert(ok)
	
	t = {}
	
	for i=1,self.includemodel_count do
	
		local pos = self:Tell()
		
		local labelOffset = from_int(f:Read(4),true)
		local fileNameOffset = from_int(f:Read(4),true)
		offsetreaderinfo_1[i]=labelOffset 		+ pos
		offsetreaderinfo_2[i]=fileNameOffset	+ pos
	end
	for i=1,self.includemodel_count do
		
		
		local labelOffset = offsetreaderinfo_1[i]
		local fileNameOffset = offsetreaderinfo_2[i]
		
		--print(i,labelOffset,fileNameOffset)
		
		assert(self:SeekTo(labelOffset))
		local label = f:ReadString()

		assert(self:SeekTo(fileNameOffset))
		
		local fileName = f:ReadString()

		t[i] = {label,fileName}
		
	end
	
	self.included_models = t
	
	return t
end


local mstudioattachment_t_size =
	4 			-- int					sznameindex;
	+4 			-- unsigned int			flags;
	+4			-- int					localbone;
	+(3*4)*4	-- matrix3x4_t			local; // attachment point
	+4*8    	-- int					unused[8];

function MDL:offsetAttachment( i )
	assert(i>=0 and i<=self.attachment_count)
	return self.attachment_offset + mstudioattachment_t_size * i
end


function MDL:SurfaceName()
	local f = self.file
	local name = self.surfaceprop_name
	if name then return name end
	
	assert(self:SeekTo(self.surfaceprop_index))
	name = f:ReadString()
	assert(name)
	self.surfaceprop_name = name
	return name
end
	
function MDL:Attachments()
	local f = self.file
	local t = self.attachment_nameslist
	if t then return t end
	
	t = {}
	
	for i=0,self.attachment_count-1 do -- mstudioattachment_t --
		
			local thispos = self:offsetAttachment(i)
			assert(self:SeekTo(thispos))
			
			local sznameindex = from_int(f:Read(4),true)
			
			local flags = from_u_int(f:Read(4),true)
			
			assert(self:SeekTo(thispos + sznameindex))
			local name = f:ReadString()
			
			t[#t+1] = {name,flags}
			
	end

	self.attachment_nameslist = t
	
	return t
end
-----------------------------


local mstudiotexture_t_size =
	4  -- int		sznameindex;
	+4 -- int		flags;
	+4 -- int		used;
	+4 -- int		unused1;
	+4 -- int		material;
	+4 -- int		client_material;
	+4*10 -- int	unused[10];

function MDL:offsetTexture( i )
	assert(i>=0 and i<=self.texture_count)
	return self.texture_offset + mstudiotexture_t_size * i
end

function MDL:Textures()
	local f = self.file
	local t = self.texture_nameslist
	if t then return t end
	
	t = {}
	
	for i=0,self.texture_count-1 do -- mstudiotexture_t --
	
		local thispos = self:offsetTexture(i)
		assert(self:SeekTo(thispos))
		
		local sznameindex = from_int(f:Read(4),true)
		
		assert(self:SeekTo(thispos + sznameindex))
		local name = f:ReadString()
		
		t[#t+1] = {name}
		
	end

	self.texture_nameslist = t
	
	return t
end
-----------------------------
function MDL:ParseSkins()
	if self.skintable then return self.skintable end
	local f = self.file
	local textures = self:Textures()
	local skintable = {}
	assert(self:SeekTo(self.skinreference_index))

	for i = 1, self.skinrfamily_count do
		skintable[i] = {}

		for j = 1, self.skinreference_count do
			local textureid = f:Read(1):byte() + f:Read(1):byte() * 256
			skintable[i][j] = textures[textureid + 1]
		end
	end

	self.skintable = skintable

	return skintable
end

-----------------------------

function MDL:TextureDirs()
	local f = self.file
	local t = self.texturedirs
	if t then return t end

	t = {}

	assert(self:SeekTo(self.texturedir_offset))
	local offsets={}
	for i=1,self.texturedir_count do
		local offset = from_int(f:Read(4),true)
		offsets[i]=offset
	end
	
	for _,offset in next,offsets do
		assert(self:SeekTo(offset))
		local name = f:ReadString()

		t[#t+1] = name

	end

	self.texturedirs = t

	return t
end






-----------------------------

local mstudiobodyparts_t_size =
	4 -- int	sznameindex;
	+ 4 -- int	nummodels;
	+ 4 -- int	base;
	+ 4 -- int	modelindex; 
	
function MDL:offsetBodyPart( i )
	assert(i>=0 and i<=self.bodypart_count)
	return self.bodypart_offset + mstudiobodyparts_t_size * i
end



function MDL:BodyParts()
	local f = self.file
	local t = self.bodyparts
	if t then return t end
	
	t = {}
	
	self:ParseHeader()
	for i=0,self.bodypart_count-1 do -- mstudiobodyparts_t --
		
			local thispos = self:offsetBodyPart(i)
			assert(self:SeekTo(thispos))
			
			local sznameindex = from_int(f:Read(4),true)
			
			local nummodels = from_u_int(f:Read(4),true)
			local base = from_u_int(f:Read(4),true)
			local modelindex = from_u_int(f:Read(4),true)
			
			assert(self:SeekTo(thispos + sznameindex))
			local name = f:ReadString()
			
			
			t[#t+1] = {this=thispos,name=name,base=base,nummodels=nummodels,modelindex=modelindex}
			
	end

	self.bodyparts = t
	
	return t
end




-- bodypart model

local  mstudiomodel_t_size =
 64 -- char		name[64];
+ 4 -- int		type;
+ 4 -- float	boundingradius;
+ 4 -- int		nummeshes;	
+ 4 -- int		meshindex;
+ 4 -- int		numvertices;		
+ 4 -- int		vertexindex;		
+ 4 -- int		tangentsindex;		
+ 4 -- int		numattachments;
+ 4 -- int		attachmentindex;
+ 4 -- int		numeyeballs;
+ 4 -- int		eyeballindex;
+ 4 -- void		*pVertexData;
+ 4 -- void		*pTangentData;
+ 4*8 -- int	unused[8];

function MDL:offsetBodyPartModel( part, i )
	local f = self.file
	assert(i>=0 and i < part.nummodels)
	return part.this + part.modelindex + mstudiomodel_t_size * i
	
end

function MDL:BodyPartModel(part,i)
	local f = self.file
	
	local thispos = self:offsetBodyPartModel(part, i)
	assert(self:SeekTo(thispos))
	
	local name = f:Read(64):gsub("%z*$","")
	local modeltype = from_u_int(f:Read(4),true)
	local boundingradius = f:ReadFloat()
	local nummeshes = from_u_int(f:Read(4),true)
	local meshindex = from_u_int(f:Read(4),true)
	local numvertices = from_u_int(f:Read(4),true)
	local vertexindex = from_u_int(f:Read(4),true)
	local tangentsindex = from_u_int(f:Read(4),true)
	local numattachments = from_u_int(f:Read(4),true)
	local attachmentindex = from_u_int(f:Read(4),true)
	local numeyeballs = from_u_int(f:Read(4),true)
	local eyeballindex = from_u_int(f:Read(4),true)
	local pVertexData = from_u_int(f:Read(4),true)
	local pTangentData = from_u_int(f:Read(4),true)
	f:Skip(4*8) -- unused
	
	local t = {
		name = name,
		modeltype = modeltype,
		boundingradius = boundingradius,
		nummeshes = nummeshes,
		meshindex = meshindex,
		numvertices = numvertices,
		vertexindex = vertexindex,
		tangentsindex = tangentsindex,
		numattachments = numattachments,
		attachmentindex = attachmentindex,
		numeyeballs = numeyeballs,
		eyeballindex = eyeballindex,
		pVertexData = pVertexData,
		pTangentData = pTangentData
	}
	return t
end


function MDL:BodyPartsEx()
	local t = self.bodypartsx
	if t then return t end
	
	self:ParseHeader()
	t = table.Copy(self:BodyParts())
	
	for _,part in next,t do
		for i=0,part.nummodels-1 do
			
			part.models=part.models or {}
			part.models[i+1] = self:BodyPartModel(part,i)
			
		end
	end

	self.bodypartsx = t
	
	return t
end

-- bones


local bone_section_size =
	  4 -- int
	+ 4  -- int parent
	+ 4*6 --int					bonecontroller[6];	// bone controller index, -1 == none

	+ 4*3 --Vector				pos;
	+ 4*4 --Quaternion			quat;
	+ 4*3 --RadianEuler			rot;

	+ 4*3 --Vector				posscale;
	+ 4*3 --Vector				rotscale;
	+ 48 --matrix3x4_t			poseToBone;

	+ 4*4 --Quaternion			qAlignment;
	+ 4 --int					flags;
	+ 4 --int					proctype;
	+ 4 --int					procindex;		// procedural rule
	+ 4 --mutable int			physicsbone;	// index into physically simulated bone
	+ 4 --int					surfacepropidx;	// index into string tablefor property name
	+ 4 --int					contents;		// See BSPFlags.h for the contents flags
	+ 4 --int 					surfacepropLookup
	+ 4*7 --int					unused[7];		// remove as appropriate
	
function MDL:offsetBone( i )
	assert(i>=0 and i<=self.bone_count)
	return self.bone_offset + bone_section_size * i
end


function MDL:BoneNames()
	local f = self.file
	local t = self.bone_nameslist
	if t then return t end
	
	t = {}
	
	for i=0,self.bone_count-1 do -- mstudiobone_t --
	
		local thispos = self:offsetBone(i)
		assert(self:SeekTo(thispos))
		
		local nameoffset = from_int(f:Read(4),true)
		
		assert(self:SeekTo(thispos + nameoffset))
		local name = f:ReadString()
		
		t[#t+1] = name
		
		
	end

	self.bone_nameslist = t
	
	return t
end


function MDL:SeekTo(offset)
	
	local f = self.file
	local off = self.initial_offset + offset
	
	if off>f:Size() then
		--print("offset too big",off-f:Size())
		return false
	end
	
	f:Seek(off)
	return f:Tell()==off
	
end

function MDL:Tell()
	return self.file:Tell()-self.initial_offset
end


-- bodygroup builder

local MT={}
function MT:SetBodygroup( group, val )
	assert(group)
	assert(val)
	local bodypart = self.data[group]
	
	if not bodypart then
		for _, candidate in next, self.data do
			if candidate.name == group then
				-- there can be duplicates, choose the last one
				if candidate.nummodels > 1 then
					bodypart = candidate
				else
					bodypart = bodypart or candidate
				end
			end
		end
	
		if not bodypart then return false, 1, 'bodypart missing' end
	end
	
	assert(bodypart.nummodels,"malformed data")
	if bodypart.base == 0 or bodypart.nummodels == 0 then return false,2,'no such part' end

	local cur = math.floor(self.bodynum / bodypart.base) % bodypart.nummodels

	if val >= bodypart.nummodels then
		return false,3,"no such model numberr",cur -- we could not set the right one
	end
	
	self.bodynum = math.floor(self.bodynum - math.floor(cur * bodypart.base) + math.floor(val * bodypart.base))

	return true
end

MT.Set = MT.SetBodygroup
function MT:GetValue()
	return self.bodynum
end
function MT:Reset(m)
	self.bodynum = m or 0
end

function MT:GetData()
	return self.data
end

function BodyPartBuilder(t,cur)
	assert(t,"need bodypart data")
	return setmetatable({data=t,bodynum=cur or 0},{__index=MT})
end

--

local TEST = false

if TEST then
	local mdl = mdlinspect.Open(LocalPlayer():GetModel())
	local bodyparts = mdl:BodyParts()
	local bp = mdlinspect.BodyPartBuilder(bodyparts, 0)
	PrintTable(bp)
end

return _M

--addons/module_outfitter/lua/includes/modules/playerextras.lua:
if SERVER then
	AddCSLuaFile()
end

do -- is stuck checker

	local output = {}
	local pl_filt
	local filter_tbl  = {}
	local function filter_func(e)
		if e==pl_filt then return false end
		local cg = e:GetCollisionGroup()

		return
			cg~=15 -- COLLISION_GROUP_PASSABLE_DOOR
		and cg~=11 -- COLLISION_GROUP_WEAPON
		and cg~=1 -- COLLISION_GROUP_DEBRIS
		and cg~=2 -- COLLISION_GROUP_DEBRIS_TRIGGER
		and cg~=20 -- COLLISION_GROUP_WORLD

	end
	local t = {output = output ,mask=MASK_PLAYERSOLID}
	FindMetaTable"Player".IsStuck=function(pl,fast,pos)
		t.start = pos or pl:GetPos()
		t.endpos = t.start
		if fast then
			filter_tbl[1] = pl
			t.filter = filter_tbl
		else
			pl_filt = pl
			t.filter = filter_func
		end


		util.TraceEntity(t,pl)
		return output.StartSolid,output.Entity,output
	end

end


--------------

local Tag = "player_cache"

local next=next

local cache = player.GetAllCached and player.GetAllCached() or {}
local cache_count = player.CountAll and player.CountAll() or 0

function player.GetAllCached()
	return cache
end
function player.CountAll()
	return cache_count
end

function player.All()
	return next,cache
end

function player.iterator()
	local i=1
	local function iter_all()
		local val=cache[i]
		i=val and i+1 or 1
		return val
	end
	return iter_all
end


local SERVER=SERVER

local function EntityCreated(pl)
	--assert(pl:IsPlayer()==pl:IsPlayer(),"isplayer mismatch")
	if pl:IsPlayer() then
		--print("Creating", pl)
		if SERVER then
			local uid = pl:UserID()
			for k, v in next, cache do
				if uid == v:UserID() then

					table.remove(cache, k)
					cache_count = cache_count - 1
				   -- print("NOCREAET, CACHE REMOVE", pl:UserID(), pl)
					return
				end

			end

		end

		table.insert(cache, pl)
		cache_count = cache_count + 1
	end

end

if SERVER then
	hook.Add("OnEntityCreated", Tag, EntityCreated)
else
	hook.Add("NetworkEntityCreated", Tag, EntityCreated)
end

local function add(pl)
	for k,pl2 in next,cache do
		if pl2==pl then return end
	end
	table.insert(cache,pl)
	cache_count = cache_count + 1
end
for k, pl in player.Iterator() do
	add(pl)
end

local function EntityRemoved(pl)
	--assert(pl:IsPlayer()==pl:IsPlayer(),"isplayer mismatch")
	if pl:IsPlayer() then
		--print("Removing", pl)
		for k, v in next, cache do
			if pl == v then
				table.remove(cache, k)
				cache_count = cache_count - 1
				-- return -- Add or not? Recursion even?
			end

		end

	end

end

if SERVER then
	hook.Add("PlayerDisconnected", Tag, EntityRemoved)
end
hook.Add("EntityRemoved", Tag, EntityRemoved)


-------------------------------------

local Tag = 'PlayerSlowThink'
--By: Python1320, original by Lixquid

local RealTime = RealTime
local player = player
local hook = hook
local next = next
local FrameTime = FrameTime
local math = math
local ticint
	local function getintervals()
		return ticint
	end

	local function getintervalc()
		local ft = FrameTime()
		return ft > 0.3 and 0.3 or ft
	end

	local getinterval
	getinterval = function()
		if SERVER then
			ticint = engine.TickInterval()
			getinterval = getintervals
		else
			getinterval = getintervalc
		end

		return getinterval()
	end

local iterating_players = {  }
local function refreshplayers(t)
	local pls = player.GetAllCached()
	local plsc = #pls
	for i = 1, plsc do
		iterating_players[i] = pls[i]
	end

	local ipc = #iterating_players
	if ipc == plsc then
		return plsc
	end

	for i = ipc, plsc + 1, -1 do
		iterating_players[i] = nil
	end

	return plsc
end

function GetPlayerThinkCache()
	return iterating_players
end

local function Call(pl)
	if not pl:IsValid() then
		return
	end

	hook.Call(Tag, nil, pl)
end

local iterid = 1
local function iter()
	iterid = iterid + 1
	local pl = iterating_players[iterid]
	if pl == nil then
		iterid = 1
		return true
	end

	Call(pl)
end

local iterations_per_tick
local iterations_per_tick_frac
local fracpart = 0
local nextthink = 0
local printed
local function Think()
	local pl = iterating_players[iterid]
	if pl == nil then
		local now = RealTime()
		if nextthink > now then
			--if not printed then
			--	printed = true
			--	--print("=========",nextthink - now)
			--end

			return
		end

		nextthink = now + 1
		--printed = false
		fracpart = fracpart >= 1 and 1 or fracpart
		local plc = refreshplayers(iterating_players)
		if plc == 0 then
			return
		end

		iterid = 1
		iterations_per_tick = #player.GetAllCached() * getinterval()
		iterations_per_tick_frac = iterations_per_tick - math.floor(iterations_per_tick)
		iterations_per_tick = math.floor(iterations_per_tick)
		pl = iterating_players[iterid]
		if pl == nil then
			return
		end
		if fracpart>=0.3 then
			fracpart = 0
			Call(pl)
			iterid = iterid + 1
			pl = iterating_players[iterid]
			if pl == nil then
				return
			end
		end
	end

	fracpart = fracpart + iterations_per_tick_frac
	if fracpart > 1 then
		fracpart = fracpart - 1
		Call(pl)
		iterid = iterid + 1
		pl = iterating_players[iterid]
		if pl == nil then
			return
		end

	end

	for i = 1, iterations_per_tick do
		Call(pl)
		iterid = iterid + 1
		pl = iterating_players[iterid]
		if pl == nil then
			return
		end

	end

end


hook.Add("Think", Tag, Think)


-- Fix parent positioning function --

local Tag="f_pp"
if SERVER then

	util.AddNetworkString(Tag)

	local Entity=FindMetaTable"Entity"
	function Entity:FixParentPositioning()

		local ply = self:GetParent()
		if not ply:IsPlayer() then error"Parent is not a player" end

		net.Start(Tag)
			net.WriteEntity(self)
		net.Send(ply)
	end

end


-- player revive
if SERVER then
	local Player = FindMetaTable"Player"
	Player.Revive=Player.Revive or function(pl)
		if pl:Alive() then return end
		local pos = pl:GetPos()
		pl:Spawn()
		pl:SetPos(pos)
	end
end

if SERVER then return end

local t={}

local added = false

local LocalPlayer=LocalPlayer

local function PreDrawOpaqueRenderables()
	local mypos=LocalPlayer():GetPos()
	local ok
	for _,ent in next,t do
		ok=true
		if not ent:IsValid() then
			t[_]=nil
			continue
		end
		ent:SetRenderAngles(ent:GetNetworkAngles())
		ent:SetRenderOrigin(ent:GetNetworkOrigin()+mypos)
	end
	if not ok then
		added=false
		hook.Remove("PreDrawOpaqueRenderables",Tag)
	end
end

net.Receive(Tag,function()
	if not added then
		hook.Add("PreDrawOpaqueRenderables",Tag,PreDrawOpaqueRenderables)
		added = true
	end

	local ent = net.ReadEntity()

	if not IsValid(ent) then return end

	table.insert(t,ent)

end)

player.GetByUserID = player.GetByID
--addons/module_outfitter/lua/includes/modules/sqlext.lua:
--https://gist.github.com/Python1320/eec8cdc84828a8261b00

AddCSLuaFile()

local sql=sql

local tablevers

-- http://www.sqlite.org/lang_corefunc.html#last_insert_rowid
function sql.LastRowID()
	local ret = sql.Query("SELECT last_insert_rowid() as x")[1].x
	return ret
end

setmetatable(sql,{__call=function(self,query,...)
	local t = {...}
	for k,v in next,t do
		if isstring(v) then
			t[k] = sql.SQLStr(v)
		elseif isbool(v) then
			v=tostring(v)
		end
	end
	query = query..';'
	if #t > 0 then
		query = query:format(unpack(t))
	end
	local ret = sql.Query(query)
	
	assert(ret~=true,'uuuhoh')
	if ret == false then
		return nil,sql.LastError()..' (Query: '..query..')'
	elseif ret == nil then
		return true
	else
		return ret
	end
end})

-- http://www.tutorialspoint.com/sqlite/sqlite_date_time.htm
local escape=sql.SQLStr
local function gen_datefunc(fname)
	local beginning = "SELECT "..fname.."("
	local function func(...)
		
		local mods = {...}
		for k,v in next,mods do
			mods[k]=isnumber(v) and v or escape(v)
		end
		local q=beginning..table.concat(mods,",")..") as x;"

		local ret = sql.Query(q)
		ret = ret and ret[1]
		ret = ret and ret.x
		ret = ret and ret~="NULL" and ret
		
		return ret
		
	end
	
	sql[fname]=func
end

gen_datefunc 'date'
gen_datefunc 'time'
gen_datefunc 'datetime'
gen_datefunc 'julianday'
gen_datefunc 'strftime'
	
	
	
	


local mt = {}
function mt:create(infos,after,...)
	local name = getmetatable(self).name
	assert(name)
	if not sql.TableExists(name) then
		MsgN("Creating ",name)
		assert(sql(("CREATE TABLE %%s (%s) %s"):format(infos,after or ""),name,...))
		if tablevers then
			tablevers:update("ver = 0 WHERE name = %s",name)
		end
	end
	return self
end

function mt:coerce(kv)
	getmetatable(self).coerce = kv
	return self
end

function mt:drop()
	local name = getmetatable(self).name
	if sql.TableExists(name) then
		assert(sql(("DROP TABLE %s"):format(name)))
	end
	return self
end
function mt:insert(kv,or_replace)
	local name = getmetatable(self).name
	
	local keys,values={},{}
	local i=0
	for k,v in pairs(kv) do
		i=i+1
		keys[i] = sql.SQLStr(k)
		values[i] = (isnumber(v)) and tostring(v)
		or v==true and 1
		or v==false and 0
		or isstring(v) and sql.SQLStr(v)
		or error"Invalid input"
	end
	
	local a,b = sql(("INSERT %sINTO %s (%s) VALUES (%s)"):format(or_replace and "OR REPLACE " or "",name,table.concat(keys,", "),table.concat(values,", ")))
	if a==true then
		return tonumber(sql.LastRowID())
	end
	return a,b
end

function mt:coercer(a,...)
	local coerce = getmetatable(self).coerce
	if coerce and a and a~=true then
		for i=1,#a do
			local t = a[i]
			for k,v in next,t do
				local coercer = coerce[k]
				if coercer then
					t[k] = coercer(v)
				end
			end
		end
	end
	return a,...
end
function mt:select(vals,extra,...)
	local name = getmetatable(self).name
	
	return self:coercer(self:sql(("SELECT %s FROM %s %s"):format(vals,name,extra or ""),...))
end


local function return_changes(a,...)
	if a==true then
		local changes = tonumber(sql'SELECT changes() as changes'[1].changes)
		return changes
	end
	return a,...
end
function mt:update(extra,...)
	local name = getmetatable(self).name
	local query = ("UPDATE %s SET %s"):format(name,extra)
	return return_changes( self:sql( query ,...) )
end

function mt:alter(extra,...)
	local name = getmetatable(self).name
	local query = ("ALTER TABLE %s %s"):format(name,extra)
	return assert(return_changes( self:sql( query ,...) ))
end

function mt:delete(extra,...)
	local name = getmetatable(self).name
	local query = ("DELETE FROM %s WHERE %s"):format(name,extra)
	return return_changes( self:sql( query ,...) )
end

local function firstval(a,...)
	if a and a~=true then assert(not a[2]) return a[1] end
	return a,...
end
function mt:select1(...) return firstval(self:select(...)) end


function mt:sql(a,...)
	local t = {...}
	local name = getmetatable(self).name
	
	for k,v in next,t do
		local mt = istable(v) and getmetatable(v)
		if mt and mt.name then t[k] = mt.name end
	end
	
	return sql(a,unpack(t))
end
function mt:sql1(...) return firstval(self:sql(...)) end

local function columns(a,b)
	if a then
		return a[1].name
	end
	return a,b
end
function mt:columns()
	local name = getmetatable(self).name
	if sql.TableExists(name) then
		return columns(sql("PRAGMA table_info(%s)",name))
	end
	return nil,'no such table'
end


function sql.obj(name)
	return setmetatable({name=name},{name=name,__index=mt})
end


local ok,err = xpcall(function()
	local t = assert(sql.obj("sqlext"))
		:create([[
			`name`		TEXT NOT NULL CHECK(name <> '') UNIQUE,
			`ver`		INTEGER NOT NULL DEFAULT 0]])
		:coerce{ver=tonumber}
	tablevers = t
end,debug.traceback)
if not ok then
	ErrorNoHalt(err..'\n')
end

local function read_table_version(name)
	if not tablevers then return nil,'tablevers unavailable' end
	local ret,err = tablevers:select("*","WHERE name = %s",name)
	if ret == nil then return nil,err end
	if ret == true then return false end
	return ret and ret[1] and ret[1].ver or false
end

function mt:migrate(cb)
	local info = getmetatable(self)
	
	local name = info.name
	local _ver = (info._ver or 0) + 1
	info._ver = _ver
	
	if info._migrate_errors then return nil,'migration errors' end
	
	local table_version = read_table_version(name)
	if table_version == nil then
		return self
	elseif not table_version then
		table_version = 0
		tablevers:insert{name=name,ver=1}
	end
	if _ver <= table_version then
		return self
	end
	
	local ok,ret = xpcall(cb,debug.traceback,self,name)
	
	if not ok then
		ErrorNoHalt(ret..'\n')
		info._migrate_errors = true
		return nil,'migration errors'
	end
	
	if ret==false then
		return self
	end
	
	tablevers:update("ver = %d WHERE name = %s",_ver,name)
	MsgN("Upgraded ",name," to version ",_ver)
	
	return self
end

--addons/module_outfitter/lua/outfitter/cl_util.lua:
local Tag='outfitter'
local NTag = 'OF'

require'mdlinspect'
require'gmaparse'

module(Tag,package.seeall)

local SAVE=true  --TODO: make save after end of debugging

local Player = FindMetaTable"Player"

function TranslateError(err,...)
	if err=='maxverts' then
		err = 'Model is too complex (too many vertexes). This would lag lower quality PCs.'
	elseif err=='nobones' then
		err = "Playermodel needs to have bones"
	elseif err=='noattachments' then
		err = "Does not have eyes attachment, this breaks many addons"
	end
	return err
end


function Fullupdate()
	timer.Create(Tag..'fullupdate',.2,1,function()
		UIFullupdate()
		LocalPlayer():ConCommand("record removeme",true)
		RunConsoleCommand'stop'
		
	end)
end

--TODO: Make outfitter mount all after enabling?
outfitter_enabled = CreateClientConVar("outfitter_enabled","1",true,true)
cvars.AddChangeCallback("outfitter_enabled",function(cvar,old,new)
	if new=='0' then
		DisableEverything()
	elseif new=='1' then
		EnableEverything()
	end
end)

do
	local outfitter_enabled = outfitter_enabled
	function IsEnabled()
		return outfitter_enabled:GetBool()
	end
end

do
	local outfitter_download_notifications = CreateClientConVar("outfitter_download_notifications","0",true,false)
	function CanDownloadNotification()
		return outfitter_download_notifications:GetBool()
	end
end


--TODO: Make outfitter mount all after enabling?
outfitter_fix_error_players = CreateClientConVar("outfitter_fix_error_players","1",true,true)
cvars.AddChangeCallback("outfitter_fix_error_players",function(cvar,old,new)
	
end)

do
	local outfitter_fix_error_players = outfitter_fix_error_players
	function ShouldFixErrorPlayers()
		return outfitter_fix_error_players:GetBool()
	end
end


local function AutoWearTimer()
	if co.make() then return end
	if OUTFITTER_NO_UI then return end
	local _ = coDoAutowear and coDoAutowear()
end

local timestarted = math.huge
local function InitPostEntity()
	timestarted = RealTime()
	timer.Simple(0.5,function()
	timer.Simple(0.5,function()
		timestarted = RealTime()
		AutoWearTimer()
	end)
	end)
end
hook.Add("InitPostEntity",Tag,InitPostEntity)

do
	local outfitter_sounds = CreateClientConVar("outfitter_sounds","1",true)
	function CanPlaySounds()
		local ok = outfitter_sounds:GetBool()
		if not ok then return ok end
		
		if GetElapsedInteractive()<30 then return false end
		
		return ok
	end
end

do
	local outfitter_hands = CreateClientConVar("outfitter_hands","1",true)
	function ShouldHands()
		return outfitter_hands:GetBool()
	end
end

do
	local outfitter_animfix_oldmethod = CreateClientConVar("outfitter_animfix_oldmethod","0",true)
	function UseOldAnimFixMethod()
		return outfitter_animfix_oldmethod:GetBool()
	end
	function FixLocalPlayerAnimations(allow_old)
		if allow_old and UseOldAnimFixMethod() then
			return Fullupdate()
		end
		dbgn(8,"FixLocalPlayerAnimations()",allow_old and "allow_old" or "")
		-- credits to Henke for finding a possible "fix"
		local state = LocalPlayer():GetPredictable()
		LocalPlayer():SetPredictable(not state)
		LocalPlayer():SetPredictable(state)
	end
end
	
do
	-- -1: server preference
	-- 0: force disable distance check
	-- 1: force enable distance check
	local outfitter_distance_mode = CreateClientConVar("outfitter_distance_mode","0",false)
	local outfitter_distance = CreateClientConVar("outfitter_distance","600",false)
	function ShouldDistance()
		local mode = outfitter_distance_mode:GetInt()
		if mode==0 then
			return false
		elseif mode==1 then
			return true
		end
		return ServerSuggestDistance()
	end
	
	function GetDistance()
		local d = outfitter_distance:GetFloat()
		if ShouldDistance() then return d>0 and d end
	end
	
	function VisibleFilter(pl1,pl2)
		local pos1,pos2 = pl1:GetPos(),pl2:GetPos()
		local dist = GetDistance()
		if not dist then return false end
		return pos1:DistToSqr(pos2)>(dist*dist)
	end
end

do

	local outfitter_nohighperf = CreateClientConVar("outfitter_nohighperf","0",false)
	local highperf = 0
	local prehighperf=true
	function IsHighPerf(n)
		if n and n>1 then return end -- TODO: ultra high perf

		return prehighperf or (not outfitter_nohighperf:GetBool() and highperf>0)
	end

	function SetHighPerf(mode,refresh_all)
		local washigh = highperf>0
		highperf = highperf + (mode and 1 or -1)
		highperf = highperf<0 and 0 or highperf
		assert(highperf < 12,"HIGHPERF FAIL")
		local ishigh = highperf>0
		
		if ishigh~=washigh and refresh_all then
			RefreshPlayers()
		end
	end
	
	hook.Add("RenderScene",Tag..'_highperf',function()
		prehighperf=false
		hook.Remove("RenderScene",Tag..'_highperf')
		dbgn(2,'Stopping forced highperf mode',IsHighPerf())
	end)
	
	function coMinimizeGarbage()
		for i=1,2048 do
			if collectgarbage('step',math.ceil(i^2)) then 
				local steps_done = (i+1)^2-1
				return steps_done
			end
			co.waittick()
		end
		return 2049^2-1
	end
	
end

--TODO
do
	local outfitter_use_autoblacklist = CreateClientConVar("outfitter_use_autoblacklist","0",true)
	function AutoblacklistEnabled()
		return outfitter_use_autoblacklist:GetBool()
	end
end

--TODO
do
	local function proc(data)
		
		if istable(data) then data=table.concat(data,"\n") end

		local t= {}
		for l in data:gmatch'[^\r\n]+' do
			if #string.Trim(l)>0 then
				table.insert(t,string.Trim(l):lower())
			end
		end
		return t,table.concat(t,"\n")
	end
	local blocklist = proc(file.Read("outfitter_blocklist.txt") or "") or {}
	function SetTitleBlocklist(str)
		local thelist,data = proc(str)
		blocklist = thelist
		file.Write("outfitter_blocklist.txt",data)
	end
	function GetTitleBlocklist()
		return blocklist
	end
	function IsTitleBlocked(title)
		
		if not AllowNSFW() and title:lower():find"nsfw" then
			return true
		end 

		for _,l in pairs(blocklist) do
			if title:lower():find(l,1,true) then
				return l
			end
		end
		return false
	end
end


do
	local outfitter_extra_safe_downloading = CreateClientConVar("outfitter_extra_safe_downloading","0",true)
	function IsParanoidMode()
		return outfitter_extra_safe_downloading:GetBool()
	end
end

do


	-- Censorship depends on steam language
	-- shortest racial slur from every language from steam api in 2021
	local racial_slur_testers = util.Base64Decode("bmlnZ2VyCmhvbW8KYmliYQpwaWNoa3UKbmVncgpsZXNiYQpwZApqaWQKz4DOv8+Nz4PPhM63CmphcMOzCmNoZWNjCuyVoOyekAptYXJpY2EKY2lwCmZ1ZmEKbXVpc3QKZmF4YQpvw6cK0LPQtdC5CsSRxKk="):Split("\n")
	local is_steam_filtering_chat = nil

	function IsSteamFilteringChat()
		if is_steam_filtering_chat ~= nil then return is_steam_filtering_chat end

		-- we can only loosen restrictions so this should catch most cases
		-- BUG: We cannot catch custom filtered words, but the player then likely has filtering on regardless
		for filter_mode = TEXT_FILTER_UNKNOWN, TEXT_FILTER_NAME do
			for _, racial_slur_test in pairs(racial_slur_testers) do
				local filtered = util.FilterText(racial_slur_test, filter_mode)

				if filtered ~= racial_slur_test then
					is_steam_filtering_chat = true

					return true
				end
			end
		end

		is_steam_filtering_chat = false

		return false
	end

	--global nsfw?
	local nsfw = CreateClientConVar("nsfw","1",true,true,"Allow NSFW content (Steam can still block with text filter)")
	function AllowNSFW()
		return not IsSteamFilteringChat() and nsfw:GetBool()
	end
end

do
	local outfitter_download_strip_lua = CreateClientConVar("outfitter_download_strip_lua","1",true)
	function ShouldStripLuaFromDownloads()
		return outfitter_download_strip_lua:GetBool()
	end
end

do
	local outfitter_allow_http = CreateClientConVar("outfitter_allow_http_test","0",true)
	function CanDownloadViaHTTP()
		return outfitter_allow_http:GetBool()
	end
end
do
	local outfitter_allow_unsafe_http = CreateClientConVar("outfitter_allow_unsafe_http","0",true)
	local whitelist = {}
	-- TODO: https://github.com/thegrb93/StarfallEx/blob/68527049b110af75ee08020255318099ddda58d5/lua/starfall/permissions/providers_sh/url_whitelist.lua
	function AllowedHTTPURL(url,bypass_can_download)
		if not CanDownloadViaHTTP() and bypass_can_download~=true then return false end
		if outfitter_allow_unsafe_http:GetBool() then return true end
		return true -- TODO
	end
	function AddHTTPWhitelist(str,strtype)
		if not strtype or strtype=="url" then
			if not str:find"^https?://" then
				error("Invalid URL: "..str)
			end
		elseif strtype=="pattern" then
			-- TODO
		else
			error("Invalid type: "..tostring(strtype))
		end
	end
end

-- never save because of malicious servers?
do
	local outfitter_unsafe = CreateClientConVar("outfitter_unsafe","0",false)
	function IsUnsafe()
		return outfitter_unsafe:GetBool()
	end
end

do
	
	-- TODO: OnPlayerVisible calling
	
	local outfitter_friendsonly = CreateClientConVar("outfitter_friendsonly","0",true)

	cvars.AddChangeCallback("outfitter_friendsonly",function(cvar,old,new)
		if new=='1' then
			EnableEverything()
		end
	end)


	function IsFriendly(pl)
		if not outfitter_friendsonly:GetBool() then return true end
		
		if pl.IsFriend then
			return LocalPlayer():IsFriend(pl)
		end
		
		local fs = pl:GetFriendStatus()
		if fs=="friend" then return true end
		return false
	end
end

--TODO
local outfitter_failsafe = CreateClientConVar("outfitter_failsafe","0",true)
function IsFailsafe()
	return outfitter_failsafe:GetBool()
end
function SetFailsafe()
	if not outfitter_failsafe.Set then return end
	outfitter_failsafe:Set'1'
end

--TODO
outfitter_maxsize = CreateClientConVar("outfitter_maxsize","11",false)

-- Model enforcing
	
	-- ragdoll model

	local function Enforce(rag)
		local mdl = rag.enforce_model
		if mdl then
			--TODO: not having this causes crashes?
			rag:InvalidateBoneCache()
			
			rag:SetModel(mdl)
			rag:InvalidateBoneCache()
			
		end
	end

	local enforce_models = {}
	function ThinkEnforce_DeathRagdoll()
		for rag,count in next,enforce_models do
			if rag:IsValid() and count>0 then
				
				enforce_models[rag] = count - 1
				Enforce(rag)
				
			else
				enforce_models[rag] = nil
			end
		end
	end


	function DeathRagdoll_RenderOverride(rag)
		if rag.enforce_model then
			rag:SetModel(rag.enforce_model)
			if enforce_models[rag] then
				rag:InvalidateBoneCache()
			end
		end
		rag:DrawModel()
	end

	local cache={}
	local function BadRagdoll(mdl)
		local cached=cache[mdl]
		if cached~=nil then return cached end
		cache[mdl] = false
		
		local sz = file.Size(mdl:gsub("%.mdl$",'.phy'),'GAME')
		cache[mdl]=cached
		
		if sz and sz>100*1000 then
			cached=true
		end
		cache[mdl]=cached
		
		return cached
	end
	
	function OnDeathRagdollCreated(rag,pl)
		local mdl = pl:GetEnforceModel()
		if not mdl then return end
		
		if BadRagdoll(mdl) then 
			dbgn(2,'Bad ragdoll',mdl)
			if not IsUnsafe() then
				return
			end
		end
		
		local mdlr = rag:GetModel()
		local mdlp = pl:GetModel()
		
		local hasenforced   = mdlr==mdl
		local isplyenforced = mdlp==mdl
		dbgn(2,"DeathRagdollEnforce",pl,rag,mdl,hasenforced and ("ENFORCED RAG: "..tostring(mdlr)) or "" ,isplyenforced and "" or ("NOT ENFORCED PLY: "..tostring(mdlp)) )
		
		rag.enforce_model = mdl
		enforce_models[rag] = 8
		Enforce(rag)
		
		rag.RenderOverride=DeathRagdoll_RenderOverride
		
	end





	-- player model
	-- TODO: ResetHull()
	local function Enforce(pl)
		if pl.enforce_model then
			pl:SetModel(pl.enforce_model)
			pl:ResetHull() -- sorry PAC
		end
	end

	local enforce_models = {}
	function ThinkEnforce()
		for pl,count in next,enforce_models do
			if pl:IsValid() and count>0 then
				
				enforce_models[pl] = count - 1
				Enforce(pl)
				
			else
				enforce_models[pl] = nil
			end
		end
	end

	-- Set model and start setting it for next 3 ticks while some other forces fight us
	--TODO: what forces
	function StartEnforcing(pl)
		enforce_models[pl] = 34
		Enforce(pl)
	end
	
	
	-- Set or unset actual model to be enforced clientside
	--TODO: Check if loaded, if not: Refine so that the model is parsed for materials, load materials and then enforce model. less lag!
	function Player.EnforceModel(pl,mdl,nocheck)
		dbg("EnforceModel",pl,mdl or "UNENFORCE")
		
		if not mdl then
			if pl.original_model then
				pl:SetModel(pl.original_model)
				pl.original_model = nil
			end
			pl.enforce_model = nil
				
			-- need to fullupdate or it doesn't reset either
			if pl==LocalPlayer() then
				FixLocalPlayerAnimations(true)
			end
			
			return true
		end
		
		if not nocheck then
			local exists = HasMDL(mdl)
			if not exists then return false,"invalid" end
		end
		
		local curmdl = pl:GetModel()
		local curenforce = pl.enforce_model
		local origmdl = pl.original_model
		
		if not origmdl then
			if not curmdl or curmdl=="" or curmdl == "models/error.mdl" or curmdl == "models/player.mdl" then
				dbg("EnforceModel","invalid GetModel",curmdl)
				curmdl=nil
			end
			pl.original_model = curmdl
		end
		
		pl.enforce_model = mdl
		
		StartEnforcing(pl)
		
		if pl==LocalPlayer() and curmdl ~= mdl then
			LazyFullupdate(mdl)
			if pl:GetNWBool("IsListenServerHost",false) or not mdl then
				FixLocalPlayerAnimations(true)
			end
		end
		
		return true
		
	end

	function Player.GetEnforceModel(pl,mdl)
		return pl.enforce_model
	end

	function OnPlayerInPVS(pl)
		if not pl.enforce_model then return end
		
		local orig = pl.original_model
		local neworig = pl:GetModel()
		-- pl.original_model = neworig
		dbgn(2,"OnPlayerInPVS","enforce",pl,pl.enforce_model,"orig",orig,orig==neworig)
		StartEnforcing(pl)
	end
	
	--TODO: REVISIT (Single frame spazzing on local player wear)
	local recursing
	local localpl
	hook.Add("PlayerPostThink",Tag,function(p)
		localpl = localpl or LocalPlayer()
		if p~=localpl then
			return
		end
		
		if recursing then return end
		recursing=true
					
			Enforce(p)
			--p:DrawModel()
		
		recursing=false
		--return true
	end)
	
	-- Between Think and This is where the player gets reset to original model for some reason, every think
	local recursing
	hook.Add("PlayerTick",Tag,function(p)
		localpl = localpl or LocalPlayer()
		if p~=localpl then
			return
		end
		
		if recursing then return end
		recursing=true
					
			Enforce(p)
		
		recursing=false
	end)

function TestLZMA(fpath)
	-- if IsUGCFilePath(fpath) -- TODO
	
	local f = file.Open(fpath,'rb','MOD')

	if not f then
		return nil,"file"
	end
	
	local dat = f:Read(14)
	f:Close()
	
	if not dat or #dat<14 then return false,'size' end
	
	local decompressed_size,dict_size,props = util.DecompressInfo(dat)
	if not decompressed_size then return decompressed_size,dict end
	if decompressed_size > 1024*1024*512 then
		return nil,'oversize'
	end
	
	--TODO: Check 2^n and 2^n + 2^(n-1)
	-- https://svn.python.org/projects/external/xz-5.0.3/doc/lzma-file-format.txt
	
	return true
	
end
function GMABlacklist(fpath,wsid)
	assert(fpath)

	local f = file.Open(fpath,'rb','MOD')
	dbg("GMABlacklist",fpath,f and "" or (IsUGCFilePath(fpath) and "UGC, SKIP" or "INVALIDFILE"))
	
	if not f then
		if IsUGCFilePath(fpath) then return true,'file' end -- Can no longer access gma data
		return nil,"file"
	end
	
	local gma,err = gmaparse.Parser(f)
	if not gma then return nil,err end

	local ok ,err = gma:ParseHeader()
	if not ok then return nil,err end
	

	local paths = {}
	local check_vtfs = {}
	for i=1,8192*2 do
		local entry,err = gma:EnumFiles()
		if not entry then
			if err then dbge("GMABlacklist","enumfiles",wsid,err) end
			break
		end
		local path = entry.Name
		assert(path)
		
		paths[#paths+1] = path:lower()
		if path:Trim():sub(-4):lower()=='.vtf' then
			--print(path,entry.Offset)
			assert(not check_vtfs[entry.Offset] )
			check_vtfs[entry.Offset] = path
		end
	end
	
	local endheader = f:Tell()
	
	if not next(check_vtfs) then dbgn(3,"CheckVTF","none found??") end
	
	for offset,path in next, check_vtfs do
		dbgn(2,"CheckVTF",path)
		
		if not gma:SeekToFileOffset(offset) then return nil,'seekfail' end
		
		local dat, err = file.ParseVTF(f)
		if not dat then 
			dbge("GMABlacklist","ParseVTF",path,wsid,"could not parse",err)
		elseif dat.width>4096 or dat.height>4096 then
			dbge("GMABlacklist","ParseVTF",wsid,"oversize")
			return nil,'oversize vtf'
		end
	end
	
	for i=1,#paths do
		local path = paths[i]
		
		--Check 1: modules
		if path :find("includes",4,true) and path:gsub("\\","/"):gsub("/./","/"):gsub("/./","/"):gsub("/+","/"):find("lua/includes/",1,true) then
			return nil,"includes"
		end
		
		--Check 2
		-- Model overrides / script overrides / config overrides / etc

		
	end
	
	return true
	
end


function GMAParseModels(gma)
	assert(gma)
	local mdls,vvds,mdlfiles,phys = {},{},{},{}
	for i=1,32000 do
		local entry,err = gma:EnumFiles()
		if not entry then
			if err then
				dbge("GMAParseModels",err) 
				return nil,err
			end
			break
		end
		local path = entry.Name
		local ext = path:sub(-4):lower()
		local path_extless = path:sub(1,-5):lower()
		
		if ext=='.mdl' then
			mdls[#mdls+1] = table.Copy(entry)
		elseif ext=='.vvd' then
			mdlfiles[path_extless] = true
			vvds[path:lower()] = entry.Offset
		elseif ext=='.vtx' then
			--mdlfiles[path:gsub("%.[^%.]+%.vtx$",""):lower()] = true
			mdlfiles[path_extless] = true
		elseif ext=='.phy' then
			phys[path_extless] = {entry.Offset,entry.Size}
		end
	end
	return mdls,vvds,mdlfiles,phys
end
function FileListParseModels(files)
	local mdls,vvds,mdlfiles,phys = {},{},{},{}
	for _,path in pairs(files) do
	
		local ext = path:sub(-4):lower()
		local path_extless = path:sub(1,-5):lower()
		
		if ext=='.mdl' then
			mdls[#mdls+1] = {Name=path,path=path,nogma=true}
		elseif ext=='.vvd' then
			mdlfiles[path_extless] = true
			vvds[path:lower()] = true
		elseif ext=='.vtx' then
			--mdlfiles[path:gsub("%.[^%.]+%.vtx$",""):lower()] = true
			mdlfiles[path_extless] = true
		elseif ext=='.phy' then
			phys[path_extless] = true
		end
	end
	return mdls,vvds,mdlfiles,phys
end
-- purge {false,false,good,false}
function RemoveListVals(t,val)
	for i=#t,1,-1 do
		if t[i]==val then
			table.remove(t,i)
		end
	end
end

function CategorizeBadModelPath(n)
	if n:find("/c_arms",1,true) 				then return "arms" end
	if n:find("/c_hands",1,true) 				then return "arms" end
	if n:find("arms.",1,true) 				then return "arms" end
	if n:find("hands.",1,true) 				then return "arms" end
	if n:find("/c_",1,true) 				then return "viewmodel" end
	if n:find("/w_",1,true) 				then return "worldmodel" end
	--if n:find("_animations.mdl",1,true) 	then return "animation" end
	if n:find("_animation",1,true) 	then return "animation" end
	if n:find("_anims_",1,true) 			then return "animation" end
	if n:find("/weapons/.",1,true) 			then return "prop" end
	if n:find("/prop_",1,true) 			then return "prop" end
	if n:find("/props_",1,true) 			then return "prop" end
end

function CheckPHY(gma,phys,path_extless)

	local data = phys[path_extless..'.phy']
	if not data then return end
	
	--if phy_size then
	--	if not IsUnsafe() and phy_size>128*1000 then
	--		return false,'filesize'
	--	end
	--end
	local phy_offset = data[1]
	if phy_offset then
		if not gma:SeekToFileOffset(phy_offset) then return nil,"seekfail" end
	end
	return true
end

function CheckVVD(gma,vvds,path_extless,path_fd)
	-- validate VVD vertex count 
	local vvd_offset = vvds[path_extless..'.vvd'] or vvds[path_extless..'.VVD']
	if vvd_offset then
		if gma and not gma:SeekToFileOffset(vvd_offset) then return nil,"seekfail" end
		local ok ,in_err,verts = ValidateVVDVerts(not gma and path_extless..'.vvd' or gma:GetFile())
		if not ok and in_err=='file missing' then
			dbgn("CheckVVD","ValidateVVDVerts",path_extless,in_err,verts)
			return true
		end
		if not ok then
			dbg("CheckVVD","ValidateVVDVerts",path_extless,in_err,verts)
			if not IsUnsafe() then
				if DrawingDecals() then
					return false,in_err
				end
			end
		end
		return true
	else
		dbg("CheckVVD","vvd not found?",path_extless..'.vvd')
	end
end

function GetGMAFiles(fpath)
	local ok ,files = MountWS( fpath )
	if ok and files then
		return files
	end
	return nil,files
end

-- helper function that probably should not exist
local function GMAORFILE(a,gma,...)
	if gma then return gma,... end
	if isstring(a) then return a end
	a:Seek(0)
	return a
end



function GMAPlayerModels(fpath)
	assert(fpath)
	local f = file.Open(fpath,'rb','MOD')
	dbgn(2,"GMAPlayerModels pre",fpath,f and "" or (IsUGCFilePath(fpath) and "UGC, SKIP" or "INVALIDFILE"))
	
	local gma,files,err
	if f then 
		gma,err = gmaparse.Parser(f)
		if not gma then return nil,err end
	else
		files,err = GetGMAFiles(fpath)
		if not files then
			return nil,err
		end
	end
	
	if gma then
		local ok ,err = gma:ParseHeader()
		if not ok then return nil,err end
	end
	
	local modellist,vvds,mdlfiles,phys
	if gma then
		modellist,vvds,mdlfiles,phys = GMAParseModels(gma) 
	else
		modellist,vvds,mdlfiles,phys = FileListParseModels(files)
	end
	
	if not modellist then return nil,vvds end


	local playermodels = {}
	local hands = {}
	local potential = {}
	local discards = {}
	local extra = {
		playermodels = playermodels,
		hands = hands,
		potential = potential,
		discards = discards
	}
	
	--TODO: Check CRC?
	--TODO: Check other files exist for mdl (otherwise might be anim for example)
	
	-- go through all model entries found from the gma
	
	
	for k,entry in next,modellist do
		local path = entry.Name
		local path_extless = entry.Name:sub(1,-5)
		
		local cat = CategorizeBadModelPath(path)
		
		if gma and not gma:SeekToFileOffset(entry) then return nil,"seekfail" end
		local path_fd = not gma and file.Open(path,'rb','GAME')
		if not path_fd and not gma then
			dbge("GMAParseModels","file should exist but doesn't",path_fd,path,fpath)
			continue
		end
		
		can = mdlfiles[path_extless]
		local discard
		local isplr,err,err2 = MDLIsPlayermodel(GMAORFILE(path_fd,gma and gma:GetFile(),entry.Size))
		local hasAnims = err
		local plerr
		if isplr==nil then 
			dbge("MDLIsPlayermodel",path_extless,err,err2) 
			discard="MDLIsPlayermodel"
		elseif not isplr then
			plerr = err
			entry.error_player = plerr
		elseif not phys[path_extless] and not hasAnims then
			isplr=false
			plerr = 'physics'
			entry.error_player = plerr
		end
		
		if gma and not gma:SeekToFileOffset(entry) then return nil,"seekfail" end
		local ishands,err,err2 = MDLIsHands(GMAORFILE(path_fd,gma and gma:GetFile(),entry.Size))
		local handserr
		if ishands==nil then 
			dbge("MDLIsHands",path_extless,err,err2) 
		elseif not isplr then
			handserr = err
			entry.error_hands = handserr
		elseif phys[path_extless] then
			ishands = false
			handserr = 'physics'
			entry.error_hands = handserr
		end
		
		-- TODO: fix non gma
		if phys[path_extless] and gma then
			local phy_ok,err = CheckPHY(gma,phys,path_extless)
			entry.phy_ok = phy_ok
			if not phy_ok then
				discard = "phy"
			end
		end
		
		local vvd_ok,err = CheckVVD(gma,vvds,path_extless)
		entry.vvd_ok = vvd_ok
		entry.error_vvd = err
		
		if not vvd_ok then
			discard = "vvd"
			ishands = false
			isplr = false
		end
		if not ((ishands and not isplr) or (isplr and not ishands) or (not ishands and not isplr)) then
			dbg("GMAPlayerModels","unable to categorize",fpath,path,"isHands=",ishands,"isPlayer=",isplr)
			ishands = false
			isplr = false
		end
		dbgn(2,"CategorizeModel",cat,isplr and "player" or ishands and "hands" or "unkn",path)
		
		discard = discard 
			or plerr == 'nobones'
			
			or cat == 'arms' 
			or cat == 'prop' 
			or cat == 'animation' 
			or cat == 'viewmodel' 
			or cat == 'worldmodel'
		
		entry.discard = discard
		
		if isplr then
			playermodels[path]=entry
		elseif ishands then
			hands[path]=entry
		elseif not discard then
			potential[path]=entry
		else
			discards[path]=entry
		end
	end
	
	dbg("GMAPlayerModels",fpath,table.Count(playermodels),table.Count(potential),table.Count(hands))
	if IsUnsafe() then
		for k,v in next,potential do
			playermodels[k]=v
		end
	end
		
	
	local mdl_list = {}
	for path,entry in next,playermodels do
		mdl_list[#mdl_list+1] = entry -- entry.Name 
	end
	return mdl_list,extra
	
end

--outfitter.EnforceHands("models/weapons/c_arms_timeshiftsoldier.mdl")

local needmdl,omdl
local _twhen=0
function ThinkFullupdate()
	if needmdl then
		if util.IsValidModel(needmdl) then
			dbg("Fullupdate","Became valid",needmdl,CurTime()-_twhen)
			needmdl = nil
			
			FixLocalPlayerAnimations(true)
		end
	end
	
	local mdl = LocalPlayer():GetModel()
	if mdl ~= omdl then
		omdl=mdl
		if not util.IsValidModel(mdl) then
			dbg("Requesting fullupdate for",mdl)
			_twhen = CurTime()
			needmdl = mdl
		else
			dbg("Fullupdate","not needed",mdl)
		end
	end
	
end


local function OnEntityCreated(ent)
	local me = LocalPlayer()
	if ent~=me then return end
	dbgn(2,'LocalPlayer (re)created')
end

hook.Add("OnEntityCreated", Tag, OnEntityCreated)

function LazyFullupdate(mdl)
	needmdl = mdl
end

-------------------
local elapsed=0
function GetElapsedInteractive()
	return elapsed
end
local function ElapsedThink()
	local ft = FrameTime()
	ft = ft>0.3 and 0.3 or ft
	elapsed=elapsed+ft
	
end
	
local function Think()
	ThinkEnforce()
	ThinkEnforce_DeathRagdoll()
	ThinkFullupdate()
	ElapsedThink()
end
hook.Add("Think",Tag,Think)




-------------------

local viewing
local view={}
local lastt
function CalcView(pl,pos,oang,fov)
	local speedup = 20
	local off = GetGUIInteractionOffset()
	off = off and -off*speedup*math.pi*8
		
	local speedytime = RealTime()*speedup
	
	local t = (off and lastt or speedytime) + (off or 0)
	lastt = off and lastt or speedytime
	
	t=( t )%360
	local slowdown= math.sin(t/360*math.pi*2 +math.pi + math.pi*.1)*speedup*.80
	
	local ang = Angle(15, ((t - slowdown) + LocalPlayer():GetAngles().y)%360,0)
	view.origin = pl:GetPos()+Vector(0,0,pl:OBBMaxs().z*.5) - ang:Forward()*65 - ang:Right()*20
	view.fov = fov
	view.angles = ang
	return view
end
function ShouldDrawLocalPlayer()
	return viewing
end
function InThirdperson()
	return viewing
end

local off
function ToggleThirdperson(want)
	if want==false or (viewing and want==nil) then
		hook.Remove("CalcView",Tag)
		hook.Remove("ShouldDrawLocalPlayer",Tag)
		viewing = false
	elseif not viewing and want~=false then
		viewing = true
		off=nil
		hook.Add("CalcView",Tag,CalcView)
		hook.Add("ShouldDrawLocalPlayer",Tag,ShouldDrawLocalPlayer)
	end

end

function GetGUIInteractionOffset()
	return off
end
local mstartx
local function GUIMousePressed()
	mstartx = input.GetCursorPos()
end
hook.Add( "GUIMousePressed", Tag, GUIMousePressed )

local function GUIMousePressedThink()
	if not mstartx then return end
	local x = input.GetCursorPos()
	off = (x-mstartx)/ScrW()
end
hook.Add( "Think", Tag..'mintoff', GUIMousePressedThink )

local function GUIMouseReleased()
	if false --[[todo]] then
		off=nil
	end
	mstartx=nil
end

hook.Add( "GUIMouseReleased", Tag, GUIMouseReleased )




concommand.Add("outfitter_camera_toggle",function(a,b,c) if c[1] then ToggleThirdperson(tonumber(c[1])) else ToggleThirdperson() end end) 

------------




local MAX_NUM_LODS = 8
function ParseVVD(f)
	local dat = {}
	dat.id					= f:Read(4)
	if dat.id~='IDSV' then return nil,'not vvd' end
	dat.version				= f:ReadLong()
	if (dat.version or 9999)>10 then return nil,'invalid vvd' end
	dat.checksum			= f:ReadLong()
	dat.numLODs				= f:ReadLong()
	if (dat.numLODs or 9999)>MAX_NUM_LODS then return nil,'invalid vvd' end

	local t = {}
	for i=1,MAX_NUM_LODS do
		t[i] = f:ReadLong()
	end

	dat.numLODVertexes = t
	dat.numFixups			= f:ReadLong()
	dat.fixupTableStart		= f:ReadLong()
	dat.vertexDataStart		= f:ReadLong()
	dat.tangentDataStart	= f:ReadLong()
	return dat
end

function ValidateVVDVerts(f)
	local do_close
	if isstring(f) then
		f = file.Open(f,'rb','GAME')
		if not f then return nil,'file missing' end
		do_close = true
	end
	local function RETURN(...)
		if do_close then f:Close() end
		return ...
	end
		
	local dat,err = ParseVVD(f)
	
	if not dat then return RETURN(nil,err) end
	
	local num = dat.numLODVertexes[1]
	if num > 64534 --[[magic]] then return RETURN(false,'maxverts',num) end
	return RETURN(true,num)
end

local r_drawdecals = GetConVar"r_drawdecals"
function DrawingDecals()
	return r_drawdecals:GetBool()
end


do 
	--TODO: skin, bodygroup, etc??
	local HACKT=Tag.."_handshack"
	local function hackt()
		local h = LocalPlayer():GetHands()
		if not h or not h:IsValid() then return end
		local m = h:GetModel()
		if not m then return end
		h:SetModel(m)
	end
	
	local oldmodel
	local enforce,skin,bodygroup
	local function PreDrawPlayerHands(ent)
		local old = ent:GetModel()
		if old~=enforce then
			dbgn(3,'EnforceHands',oldmodel,old,enforce)
			if enforce==nil then
				dbgn(3,"EnforceHands","oldmodel",oldmodel)
				local _=oldmodel and ent:SetModel(oldmodel)
				oldmodel = nil
				hook.Remove("PreDrawPlayerHands",Tag)
				timer.Destroy(HACKT)
			else
				dbgn(3,"EnforceHands","enforce",enforce)
				local _=enforce and ent:SetModel(enforce)
			end
			oldmodel = old
		end
	end

	function EnforceHands(mdl,_skin,_bodygroup)
		enforce = mdl
		
		local t = {mdl=mdl,skin=skin,bodygroup=bodygroup}
		LocalPlayer().outfitter_hands = t
		
		if enforce then
			if not timer.Exists(HACKT) then
				timer.Create(HACKT,5,0,hackt)
			end
			hook.Add("PreDrawPlayerHands",Tag,PreDrawPlayerHands)
		else
			timer.Destroy(HACKT)
		end
		_skin,_bodygroup = skin,bodygroup
	end
end



function MDLToUI(s)
	if not s then return s end
	if #s==0 then return s end
	s=s:gsub("^models/player/","")
	s=s:gsub("^models/","")
	  
	s=s:gsub("_([a-z])",function(a) return ' '..a:upper() end)
	s=s:gsub("_"," ")
	  
	s=s:gsub("%.mdl","")
	  
	s=s:gsub("/([a-z])",function(a) return '/'..a:upper() end)
	
	local a,b = s:match'^(.+)/(.-)$'
	if b then
		s = ('%s ( %s )'):format(b,a)
	end
	
	s=s:gsub("/",", ")
	
	return s
end

do
	local _vgui = vgui

	local recurse recurse = function(pnl)
		pnl:SetSkin('default')
		--print(pnl)
		for k,v in next,pnl:GetChildren() do
			recurse(v)
		end
	end

	local vgui = {
		Create=function(...)
			local ret = _vgui.Create(...)
			local _ = ret and ret:IsValid() and recurse(ret)
			timer.Simple(0,function()
				local _ = ret and ret:IsValid() and recurse(ret)
			end)
			return ret
		end,
		CreateFromTable=function(...)
			local ret = _vgui.CreateFromTable(...)
			local _ = ret and ret:IsValid() and recurse(ret)
			timer.Simple(0,function()
				local _ = ret and ret:IsValid() and recurse(ret)
			end)
			return ret
		end,
		
	}
	--timer.Simple(1,function() derma.RefreshSkins()  end)
	setmetatable(vgui,{__index=_vgui})

	function GetVGUI()
		return vgui
	end
end



require 'gmaparse'
local cache={}
function AlreadyMounted(fpath,fd)
	local cached = cache[fpath]
	if cached~=nil then return cached end
	
	if not fpath then return nil, 'no filepath' end
	local f = fd or file.Open(fpath, 'rb', 'MOD')
	assert(not fd or f==fd)
	if not f then 
		if IsUGCFilePath(fpath) then
			return nil,'ugc'
		end
		return nil, "file" 
	end
	local gma, err = gmaparse.Parser(f)
	if not gma then return nil, err end
	local ok, err = gma:ParseHeader()
	if not ok then return nil, err end
	local paths = {}


	for i = 1, 2 ^ 14 do
		local entry, err = gma:EnumFiles(i==1)

		if not entry then
			if err then return nil, err end
			break
		end

		local path = entry.Name
		assert(path)
		paths[#paths + 1] = path
	end
	if not fd then
		gma:Close()
	end
	if #paths >= 2^16 then
		return nil,'Over 2^16 files???'
	end
	if #paths == 0 then
		return nil,'No files??'
	end
	
	for i = 1, #paths do
		local path = paths[i]
		if not file.Exists(path,'workshop') then
			return false,path
		end
	end
	cache[fpath] = paths or true --  we had to check all the files in the gma, let's not check them again
	return paths or true
end

hook.Add("OutfitterDownloadUGCResult",Tag..'_alreadymounter',function(fileid,path,fd)
	if not fileid or not path or not fd then return end
	local pos = fd:Tell()
	local sz = fd:Size()
	fd:Seek(pos)
	dbg("Preload AlreadyMounted",fileid,path,fd,fd and string.NiceSize(sz),"ret=",pcall(AlreadyMounted,path,fd))
	fd:Seek(pos)
end)

function GMAFiles(fpath)
	if not fpath then return nil, 'no filepath' end
	local f = file.Open(fpath, 'rb', 'MOD')
	if not f then return nil, "file" end
	local gma, err = gmaparse.Parser(f)
	if not gma then return nil, err end
	local ok, err = gma:ParseHeader()
	if not ok then return nil, err end
	local paths = {}
	for i = 1, 2 ^ 14 do
		local entry, err = gma:EnumFiles(i==1)

		if not entry then
			if err then return nil, err end
			break
		end

		local path = entry.Name
		assert(path)
		paths[#paths + 1] = path
	end
	gma:Close()
	return paths
end

local game_MountGMA = game.MountGMA
function MountGMA(fpath,opt)
	if opt~='force' then
		local ok,res,err = pcall(AlreadyMounted,fpath)
		if not ok then
			res,err = nil,res
		end
		
		if res then
			dbg("MountGMA","Not remounting",fpath)
			return true,res
		else
			if err then
				if res~=false then
					dbg("MountGMA",(("AlreadyMounted(%q) returning error, mounting anyway, info: %s\n"):format(fpath,err)))
				end
			else
				-- not mounted, all ok
			end
		end
	end
	dbg("Running game.MountGMA",fpath)
	local files,err = game_MountGMA(fpath,opt)
	dbg("Finished game.MountGMA:",istable(files) and table.Count(files) or files,err)
	if cache[fpath] ~= nil then
		dbg("Stuffing AlreadyMounted cache with", fpath, files, err)
		cache[fpath] = files or err
	end
	return files,err
end


---------------



--addons/module_outfitter/lua/outfitter/skin.lua:
--
--addons/module_outfitter/lua/outfitter/gui_about.lua:

-- Credits --

local Tag='outfitter'

module(Tag,package.seeall)



local avatar_size=184
local avatars = {}
-- FUCK YOU GARRY
local function GetCachedAvatar184(sid64)
	local c = avatars[sid64]
	if c then
		c.shouldhide = false
		if c.hidden then
			c.hidden =false
			c:SetVisible(true)
		end
		return c
	end

	local a = vgui.Create'AvatarImage'
	a:SetPaintedManually(true)
	a:SetSize(1,1)
	a:ParentToHUD()
	a:SetAlpha(0)
	a:SetPos(ScrW()-1,ScrH()-1)
	a:SetSteamID(sid64,avatar_size)
	a.Think=function(self)
		if self.shouldhide then
			if not self.hidden then
				self.hidden = true
				self:SetVisible(false)
			end
		else
			self.shouldhide = true
		end
	end
	a.shouldhide = false
	avatars[sid64]=a
	return a
end


local avatar_size=184
local avatars = {}
local function GetCachedAvatar184(sid64)
	local c = avatars[sid64]
	if c then
		c.shouldhide = false
		if c.hidden then
			c.hidden =false
			c:SetVisible(true)
		end
		return c
	end

	local a = vgui.Create'AvatarImage'
	a:SetPaintedManually(true)
	a:SetSize(1,1)
	a:ParentToHUD()
	a:SetAlpha(0)
	a:SetPos(2,2)
	a:SetSteamID(sid64,avatar_size)
	a.Think=function(self)
		if self.shouldhide then
			if not self.hidden then
				self.hidden = true
				self:SetVisible(false)
			end
		else
			self.shouldhide = true
		end
	end
	a.shouldhide = false
	avatars[sid64]=a
	return a
end
function SetAvatarTexture184(sid64)
	local cached = GetCachedAvatar184(sid64)
	surface.SetTexture(0)
	if cached then
		cached:SetPaintedManually(false)
		cached:PaintManual()
		cached:SetPaintedManually(true)
	end
end


local credits = {
	{
		"Willox",
		"76561197998909316",
		[[Ex-Facepunch who gave us the tools to make outfitter]],
	},{
		"CapsAdmin",
		"76561197978977007",
		[[Insipration from Player Appearance Customizer (PAC3)]],
	},{
		"Aerthas",
		"76561198053556165",
		[[Help with initial outfitter prototyping]],
	},{
		"Henke",
		"76561198000730944",
		[[Found anim fix alternative]],
	},{
		"Facepunch forums",
		{'76561197960279927','http://steamcommunity.com/groups/facepunch'},
		[[For helping with all the LAU selflessly and also for emotional support over the years for all of us. Lots of stuff would not have been possible without!]],
	},{
		"Garry",
		"76561197960279927",
		[[<Garry :D> You guys are crazy WTF]],
	},{
		"Python1320",
		"76561197986413226",
		[[The guy who wrote this madness]],
	},{
		"Meta Construct",
		{'76561198047188411',"http://metastruct.eu"},
		[[The programming community that made outfitter possible]],
	},
}

local inited
local function initcredits()
	if inited then return end
	inited=true
	
	credits[#credits+1] = {
		LocalPlayer():GetName(),
		LocalPlayer():SteamID64(),
		[[For being interested in outfitter!]],
	}
end

local PANEL={}

function PANEL:Init(asd) local _
	
	asd = asd==true
	self.is_panel = asd
	
	initcredits()
	if not self.is_panel then
		self:SetTitle"Outfitter (About)"
		local W,H=290,350
		self:SetMinHeight(100)
		self:SetMinWidth(200)
		self:SetSize(W,H)
		self:SetDeleteOnClose(true)
		self:Center()

		_=self.btnMinim and self.btnMinim:SetVisible(false)
		_=self.btnMaxim and self.btnMaxim:SetVisible(false)
		
		self:SetDraggable( true )
		self:SetSizable( true )
		
		local title = self.lblTitle
		if title then
			self:SetIcon'icon16/information.png'
			
		end
	end
	
	local pnl = vgui.Create('DScrollPanel',self)
	self.content = pnl
	
	-- HACK
		pnl.VBar:SetParent(self)
		pnl.VBar:Dock(RIGHT)
		pnl.VBar:DockMargin(-pnl.VBar:GetWide()+4,0,0,0)
	pnl:Dock(FILL)
	
	self:GenDesc()
	for _,entry in next,credits do
		self:GenAbout(entry)
	end
end

function PANEL:GenDesc()
	
	
	local lbl_desc = vgui.Create('DLabel',self)
	local amt = #file.Find("cache/workshop/*.*",'MOD')
	
	local txt = ("Workshop cache: %d addons!"):format(amt)
	lbl_desc:SetText(txt)
	lbl_desc:DockMargin(4,4,4,4)
	lbl_desc:SetTextColor(Color(255,255,255,255))
	lbl_desc:SetFont"BudgetLabel"
	lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	self:AddItem(lbl_desc)
	
	
	local lbl_desc = vgui.Create('DLabel',self)
	lbl_desc:SetText[[Hello there! Outfitter was made to fill the need of the GMod community and for procrastination.
Although mostly working, outfitter still has bugs and you can help with that by reporting them.]]
	lbl_desc:DockMargin(4,4,4,14)
	--lbl_desc:SetFont(fdesc)
	lbl_desc:SetDark(false)
	lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	self:AddItem(lbl_desc)
	
		
	local b = vgui.Create( "DButton", self )
	b:SetText"Bug reporting"
	b.DoClick=function()
		gui.OpenURL"https://github.com/Metastruct/outfitter/issues"
	end
	b:DockMargin(4,2,4,2)
	self:AddItem(b)
	
	local b = vgui.Create( "DButton", self )
	b:SetText"Get outfitter"
	b.DoClick=function()
		gui.OpenURL"http://www.google.com/search?q=garrysmod+outfitter"
	end
	b:DockMargin(4,2,4,2)
	self:AddItem(b)
	
	local lbl_desc = vgui.Create('DLabel',self)
	lbl_desc:SetText[[Finally, the people responsible for this mess include but are not limited to:]]
	lbl_desc:DockMargin(4,14,4,8)
	--lbl_desc:SetFont(fdesc)
	lbl_desc:SetDark(false)
	lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	self:AddItem(lbl_desc)
end

function PANEL:AddItem(i)
	i:Dock(TOP)
	self.content:AddItem(i)
end
local link
function PANEL:GenAbout(entry)
	local title,id,desc = unpack(entry)
	local sid64 = isstring(id) and id:match'^%d+$' and id
	local custom
	if istable(id) then
		sid64=id[1]
		id = id[2]
		custom=true
	end
	
	local pnl = vgui.Create('DPanel',self)
	
	local ftitle,fdesc = 'TargetID','default'
	
	self:AddItem(pnl)
	pnl:SetTall(140)
	pnl:DockMargin(0,0,0,4)
	pnl:DockPadding(1,1,1,4)
	
	local avatar = vgui.Create('EditablePanel',pnl)
	avatar:Dock(LEFT)
	avatar:SetWidth(48)
	avatar:DockMargin(2,2,2,2)
	
	avatar.Paint=sid64 and function(avatar,w,h)
		local sz = w<h and w or h
		SetAvatarTexture184(sid64)
		local ox = w-sz
		local oy = 0
		if h-sz<5 then
			oy = h*.5-sz*.5
		end
		
		surface.SetDrawColor(255,255,255,255)
		surface.DrawTexturedRect(ox,oy,sz,sz)
		--surface.SetDrawColor(33,33,33,111)
		--surface.DrawOutlinedRect(0,0,w,h)
		if avatar:IsHovered() then
			surface.SetDrawColor(111,155,255,77)
			surface.DrawRect(ox,oy,sz,sz)
		end
	end or function(avatar,w,h)
		local sz = w<h and w or h
		local ox = w-sz
		local oy = 0
		if h-sz<5 then
			oy = h*.5-sz*.5
		end
		surface.SetDrawColor(120,110,100,90)
		surface.DrawOutlinedRect(ox,oy,sz,sz)
		
		surface.SetDrawColor(255,255,255,255)
		link = link or Material"icon16/link.png"
		surface.SetMaterial(link)
		surface.DrawTexturedRect(ox+sz*.5-8,oy+sz*.5-8,16,16)
		--surface.SetDrawColor(33,33,33,111)
		--surface.DrawOutlinedRect(0,0,w,h)
	end

	avatar:SetCursor"hand"
	avatar:SetMouseInputEnabled(true)
	avatar.OnMousePressed = function(avatar)
		local url = id
		if url:match'^%d+$' then
			url = 'http://steamcommunity.com/profiles/'..url
		end
		gui.OpenURL(url)
	end
	
	--function pnl.Paint(pnl,w,h)
	--	surface.SetDrawColor(255,255,255,100)
	--	surface.DrawOutlinedRect(0,0,w,h)
	--end

	local lbl = vgui.Create('DButton',pnl)
	lbl:SetText(title)
	lbl:SetFont(ftitle) lbl:SetDark(true) lbl:SetAutoStretchVertical(true)
	lbl:Dock(TOP)
	lbl:SetDrawBorder(false)
	lbl:SetDrawBackground(false)
	lbl:SetContentAlignment( 1 )
	lbl:SetCursor"hand"
	if sid64 and not custom then 
		co(function()
			local nick,err = co.steamnick(sid64)
			if not nick or not lbl:IsValid() then return end
			lbl:SetText(tostring(nick))
		end)
	end
	
	lbl:DockMargin(4,0,0,0)
	lbl:SetMouseInputEnabled(true)
	lbl.DoClick = function()
		local url = id
		if url:match'^%d+$' then
			url = 'http://steamcommunity.com/profiles/'..url
		end
		gui.OpenURL(url)
	end
	
	local lbl_desc = vgui.Create('DLabel',pnl)
	lbl_desc:SetText(desc)
	lbl_desc:DockMargin(4+4,0,0,0)
	lbl_desc:SetFont(fdesc) lbl_desc:SetDark(true) lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	lbl_desc.PaintOver=function(lbl,w,h)
		surface.SetDrawColor(120,110,100,5)
		surface.DrawOutlinedRect(0,0,w,h)
	end
	
	function pnl.PerformLayout(pnl)
		local t = {}
		local minh = self:GetTall()
		for k,v in next,pnl:GetChildren() do
			local dock = v:GetDock()
			if dock==LEFT or dock==RIGHT then
				t[v]={dock,v:GetSize()}
				v:SetTall(1)
			end
		end
		pnl:SizeToChildren(false,true)
		local msz = 48+1*2+2*2+3.456
		if pnl:GetTall()<msz then
			pnl:SetTall(msz)
		end
		--for p,dat in next,t do
		--	p:Dock(dat[1])
		--	p:SetSize(dat[2],dat[3])
		--end
		--
	end
end

PANEL._Init = PANEL.Init
local PANEL2=table.Copy(PANEL)

function PANEL:PerformLayout(w,h)
	DFrame.PerformLayout(self,w,h)
end
function PANEL:Hide()
        self:SetVisible(false)
end


function PANEL:Show()
	surface.PlaySound"garrysmod/ui_return.wav"
	self:SetVisible(true)
	self:MakePopup()
end

function PANEL:Init() self:_Init(false) end
local factory = vgui.RegisterTable(PANEL,'DFrame')

function PANEL2:Init() self:_Init(true) end
about_factory = vgui.RegisterTable(PANEL2,'EditablePanel')

if this.m_pAboutDlg and ValidPanel(this.m_pAboutDlg) then
	m_pAboutDlg:Remove()
end

m_pAboutDlg = NULL
function GUIAbout()
	
	if not ValidPanel(m_pAboutDlg) then
		local d = vgui.CreateFromTable(factory,nil,Tag..'_about')
		m_pAboutDlg = d
	end
	
	
	m_pAboutDlg:Show()
	
	return m_pAboutDlg
end

	
concommand.Add(Tag..'_about',function()
	GUIAbout()
end)
--addons/module_outfitter/lua/outfitter/gui.lua:
local Tag='outfitter'

-- lua_openscript_cl srv/outfitter/lua/outfitter/ui.lua;lua_openscript_cl srv/outfitter/lua/outfitter/gui.lua;outfitter_open

module(Tag,package.seeall)
local NOUI=OUTFITTER_NO_UI

local outfitter_gui_focusdim = CreateClientConVar("outfitter_gui_focusdim","0",true)
local vgui = GetVGUI()

-- GUIWantChangeModel
	local PANEL = {}
	
	local matUp = Material"icon16/arrow_up.png"
	
	function PANEL:Init()
		local txt = vgui.Create('DLabel',self,'msg')
		txt:Dock(TOP)
		txt:SetText"If the browser does not change URL please paste the URL yourself in the browser bar from your web browser."
		txt:SetTextColor(Color(0,0,0,255))
		local b = vgui.Create('DButton',self.top,'choose button')
			
			self.chooseb = b
			b:Dock(RIGHT)
			b:SetIcon("icon16/accept.png")
			b:SetText"#select_character"
			b:SizeToContents()
			
			b:SetWidth(math.min(b:GetSize(),256)+32)
			b:SetEnabled(false)
			b:SetZPos(100)
			b:SetCookieName("ofchoosewsbutn")
			b.hideusehint = b:GetCookie("hideusehint")
			b:NoClipping(false)
			b.PaintOver = function(b,w,h)

				if b:IsEnabled() then
					DisableClipping(true)
					
					surface.SetDrawColor(30,255,0,30)
					surface.DrawRect(0,0,w,h)
					surface.SetDrawColor(66,255,22,255*.5 + 255*.3 * (math.sin(RealTime()*7)>0.3 and 1 or -1))
					surface.SetDrawColor(66,255,22,255*.5 + 255*.3 * (math.sin(RealTime()*7)>0.3 and 1 or -1))

					surface.DrawOutlinedRect(-1,-1,w+2,h+2)
					surface.DrawOutlinedRect(0,0,w,h)
					
					
					surface.SetDrawColor(255,255,255,255)
					surface.SetMaterial(matUp)
					local sz = 32
					surface.DrawTexturedRect(w*.5-sz*.5,h-2+math.sin(RealTime()*7)*4,sz,sz)
					
					DisableClipping(false)
				end
			end
		
			b.DoClick=function(b,mc)
				b.hideusehint=true
				b:SetCookie("hideusehint",'1')
				self:WSChoose()
			end
			self:GetBrowser():AddFunction( "gmod", "wssubscribe", function() self:WSChoose() end )
			
	end

	function PANEL:WSChoose()
		self:Hide()
		if self.chosen_id then
			surface.PlaySound"npc/vort/claw_swing1.wav"
			UIChoseWorkshop(self.chosen_id,self.returntoui)
		end
	end
	function PANEL:LoadedURL(url,title)
		self.BaseClass.LoadedURL(self,url,title)
		if not url or url=="" then return end
		
		-- sharedfiles/filedetails/?id=422403917&searchtext=playermodel

		local id = UrlToWorkshopID(url)
		self.chooseb:SetEnabled(id and true or false)
		self.chosen_id = tonumber(id)
		--print(id)
	end
	
	function PANEL:InjectScripts(browser)
		--dbg("Injecting browser code",browser or "NOBROWSER")
		browser:QueueJavascript[[
		
			function SubscribeItem() {
				gmod.wssubscribe();
			};
			
			setTimeout(function() {
				function SubscribeItem() {
					gmod.wssubscribe();
				};
			
				var sub = document.getElementById("SubscribeItemOptionAdd");
				if (sub) {
					sub.innerText = "Select";
				};
			}, 0);
			
		]]
	end
	function PANEL:Show(str,returntoui)
		
		self.returntoui = returntoui
		
		local dourl = not self.already_loaded
		self.already_loaded = true
		
		local url = 'http://steamcommunity.com/workshop/browse/?appid=4000&searchtext=playermodel&childpublishedfileid=0&browsesort=trend&section=readytouseitems&requiredtags%5B%5D=Model'
		if str then
			str = str and tostring(str)
			str = str and #str>0 and str
			if str then
				str = string.urlencode and string.urlencode(str) or str
				url = 'http://steamcommunity.com/workshop/browse/?appid=4000&searchtext=playermodel+'..str..'&childpublishedfileid=0&browsesort=trend&section=readytouseitems&requiredtags%5B%5D=Model'
			end
		end
		
		if dourl then
			self:OpenURL(url)
		end
		self.BaseClass.Show(self)
	end
	function PANEL:CheckEntryURLChange()
		if self.chooseb:IsEnabled() then return end
		local txt = self.entry and self.entry:GetValue()
		if not txt then return end
		if txt~=self.lasttextobserved then
			self.lasttextobserved = txt
			local id = UrlToWorkshopID(txt)
			--print("checked entry, found",id,"from",txt)
			self.chooseb:SetEnabled(id and true or false)
			self.chosen_id = tonumber(id)

		end
		
	end
	
	function PANEL:Think()
		self.BaseClass.Think(self)
		self:CheckEntryURLChange()
	end
	vgui.Register(Tag,PANEL,'custombrowser')

	m_vModelDlg = NULL
	function GUIWantChangeModel(str,returntoui)
		
		if not ValidPanel(m_vModelDlg) then
			local d = vgui.Create(Tag,nil,Tag)
			m_vModelDlg = d
		end
		
		m_vModelDlg:Show(str,returntoui)
		
		return m_vModelDlg
	end

	
	
	

	
	
	
	
	
	
	
	
	
-- GUIOpen



local PANEL = {}
function PANEL:Init()
	
	local functions = self:Add('DPanel','settings')
	functions:Dock(LEFT)
	functions:SetWidth(300)
	functions:SetHeight(300)
	functions:DockMargin(4,1,24,0)
	functions:SetPaintBackground(false)
	
	--functions:EnableVerticalScrollbar()

	local function Add(itm,b)
		local c= vgui.Create(itm,functions,b)
		--settingslist:AddItem(c)
		c:Dock(BOTTOM)
		return c
	end
	
	do
		local b = functions:Add('DButton','choose button')
			self.btn_choose = b

			b:Dock(TOP)
			b:SetText("#open_workshop")
			b:SetTooltip[[Choose a workshop addon which contains an outfit]]

			b.DoClick= function()
				gui.OpenURL('http://steamcommunity.com/workshop/browse/?appid=4000&searchtext=playermodel&childpublishedfileid=0&browsesort=trend&section=readytouseitems&requiredtags%5B%5D=Model')
				--GUIWantChangeModel(nil,true)
				
				--self:GetParent():Hide()
			end
			b:DockMargin(0,4,1,8)
			b:SetImage'icon16/folder_user.png'
			b.PaintOver = function(b,w,h)
				if not next(self.mdllist:GetLines()) then
					b:NoClipping(false)
					surface.SetDrawColor(140,255,140,255*.5 + 255*.3 * math.sin(RealTime()*4))

					surface.DrawOutlinedRect(-1,-1,w+2,h+2)
					surface.DrawOutlinedRect(0,0,w,h)
					b:NoClipping(true)
				end
			end
	end
	do
		local b = functions:Add('DTextEntry','url input')
			self.input_mdlsource = b

			b:Dock(TOP)
			b:SetText("")
			b:SetPlaceholderText("https://steamcommunity.com/sharedfiles/filedetails/?id=1234")

			b.OnEnter= function()
				
				local url = b:GetValue():Trim()
				if url =="puze" then 
					url="https://g2cf.metastruct.net/delme/puze.gma"
				end
				local wsid = UrlToWorkshopID(url,true)
				dbg("GUI","UrlToWorkshopID",url,wsid)
				if wsid then

					surface.PlaySound"npc/vort/claw_swing1.wav"
					UIChoseWorkshop(wsid,true)
					self:GetParent():Hide()
				else
					if IsHTTPURL(url) then
						if AllowedHTTPURL(url) then
							self:GetParent():Hide()
							UIChoseHTTPGMA(url,true)
						else
							chat.AddText("This HTTP URL is not in allowlist")					
							surface.PlaySound"common/warning.wav"
						end
					else
						dbg("Not HTTP URL",url)
						surface.PlaySound"common/warning.wav"
					end
				end
			end
			b:DockMargin(0,4,1,8)
	end

	local l = functions:Add( "DLabel",'chosen' )
		self.lbl_chosen = l
		l:Dock(TOP)
		l:DockMargin(1,1,1,1)
		l:SetWrap(true)
		l:SetTooltip[[Title of the chosen workshop addon]]
		l:SetText("1. Choose a workshop addon")
		l:SetTall(44)
		l:SetFont"BudgetLabel"
		l:SetTextColor(Color(255,255,255,255))
		
		
	
	local mdllist = functions:Add( "DListView",'modelname' )
		mdllist:SetMultiSelect( false )
		mdllist:AddColumn( "#gameui_playermodel" )
		self.mdllist = mdllist
		mdllist:SetTooltip[[Click one of the models on this list to choose as your outfit]]
		mdllist:DockMargin(0,5,0,0)
		mdllist:Dock(FILL)
		mdllist:SetTall(128)
		mdllist.OnRowSelected = function(mdllist,n,itm)
			local ret = GUIChooseMDL(n)
			if not ret then
				surface.PlaySound"common/warning.wav"
			end
			self.btn_bg:Refresh()
		end
		--TODO : OnRowRightClick
		function mdllist.PerformLayout(mdllist)
			DListView.PerformLayout(mdllist)
			self.btn_bg:InvalidateLayout()
		end
		mdllist.PaintOver = function(b,w,h)
			if next(mdllist:GetLines()) and not mdllist:GetSelectedLine() then
				mdllist:NoClipping(false)
				surface.SetDrawColor(255,66,22,255*.5 + 255*.3 * math.sin(RealTime()*4))

				surface.DrawOutlinedRect(-1,-1,w+1,h+1)
				surface.DrawOutlinedRect(0,0,w,h)
				mdllist:NoClipping(true)
			end
		end
		
	local sheet = self:Add( "DPropertySheet" )
		self.sheet = sheet
		sheet:Dock( FILL )
		
	local mdlhistpanel = self:Add( "EditablePanel" )
		self.mdlhistpanel=mdlhistpanel
		sheet:AddSheet( "#servers_history", mdlhistpanel, "icon16/user.png" )
	local settingspnl = self:Add( "DScrollPanel" )
		self.settingspnl=settingspnl
		sheet:AddSheet( "#spawnmenu.utilities.settings", settingspnl, "icon16/cog.png" )
	local blocklistPanel = self:Add( "EditablePanel" )
		self.blocklistPanel=blocklistPanel
		sheet:AddSheet( "#Blocklist", blocklistPanel, "icon16/stop.png" )
	local infopanel = self:Add( "EditablePanel" )
		self.infopanel=infopanel
		infopanel.Think=function()
			infopanel.Think=wlib.func.blank
			
			local p = vgui.CreateFromTable(about_factory,infopanel)
			self.aboutpnl = p
			--print"create about"
			infopanel.aboutpnl = p
			p:Dock(FILL)
		end
		infopanel:Dock(FILL)
		sheet:AddSheet( "#information", infopanel, "icon16/information.png" )
		
		local function AddS(itm,b)
			
			local c= vgui.Create(itm,settingspnl,b)
			--settingslist:AddItem(c)
			c:Dock(TOP)
			return c
		end
		
		
	
	
	----------------------------------------------------


	blocklistPanel:DockPadding( 2,1,2,1 )


	local txt = blocklistPanel:Add('DLabel','infomsg')
	txt:Dock(TOP)
	txt:SetText"Title blocklist"
	txt:SetWrap(true)
	txt:SetTextColor(Color(0,0,0,255))


	
	local check = blocklistPanel:Add( "DCheckBoxLabel",'nsfwtoggle' )
	 	check:SetConVar("nsfw")
		check:SetText( "Allow NSFW")
		check:SizeToContents()
		check:SetTooltip[[Allow NSFW content in title]]
		check:DockMargin(1,0,1,1)
		check:Dock(TOP)

	local TextEntry = blocklistPanel:Add("DTextEntry", "blocklist" )
	TextEntry:SetSize(100,200)
	TextEntry:Dock( FILL )
	TextEntry:SetValue(table.concat(GetTitleBlocklist(),"\n"))
	TextEntry:SetMultiline(true)
	TextEntry:SetVerticalScrollbarEnabled(true)
	TextEntry:SetAllowNonAsciiCharacters(true)
	TextEntry:SetEditable(true)
	TextEntry:SetTooltip"Add a banned sentence per line.\n An outfit's title matching any of the sentences will be blocked."
	TextEntry:SetPlaceholderText"Add a banned sentence per line.\n An outfit's title matching any of the sentences will be blocked."
	function TextEntry.OnLoseFocus()
		SetTitleBlocklist(TextEntry:GetValue())
		TextEntry:SetValue(table.concat(GetTitleBlocklist(),"\n"))
	end
	----------------------------------------------------

	mdlhistpanel:DockPadding( 2,1,2,1 )

	local function hr()
		local b = AddS('EditablePanel')
		b:SetTall(2)
		b:DockMargin(1,24,1,2)
		b.Paint = function(b,w,h)
			surface.SetDrawColor(240,240,240,200)
			surface.DrawRect(0,0,w,h)
		end
		local hr_line1 = b
	end

	local scroll = mdlhistpanel:Add( "DScrollPanel",'mdlhistscroll' )
	scroll:Dock(FILL)
	local mdlhist = scroll:Add( "DIconLayout",'mdlhist' )
		mdlhist:DockMargin(4,4,4,4)
		--mdlhist:SetMultiSelect( false )
		--mdlhist:AddColumn( "#name" )
		--mdlhist:AddColumn( "#gameui_playermodel" )
		self.mdlhist = mdlhist
	
		
		mdlhist:Dock(FILL)
		mdlhist.OnRowSelected = function(mdlhist,n,itm)
			local dat = GUIGetHistory()[n]
			if not dat then return end
			if not self:WantOutfitMDL(unpack(dat)) then
				surface.PlaySound"common/warning.wav"
			end
		end

		function mdlhist:Clear()
			local chld = self:GetChildren()
			for k, v in pairs( chld ) do
				v:Remove()
			end
		end
		
	local b = mdlhistpanel:Add('DButton','choose button')
		self.btn_clearhist = b
		
		b:Dock(BOTTOM)
		
		b:SetText("#gameui_clearbutton")
		b.DoClick= function()
			GUIClearHistory()
		end
		b:DockMargin(0,5,0,0)
		b:SetImage'icon16/bin.png'
	
	
	
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_enabled")
		check:SetText( "#gameui_enabled")
		check:SizeToContents()
		check:SetTooltip[[Toggle this if someone's outfit got blocked or should be showing]]
		check:DockMargin(1,0,1,1)
		local btn_en = check
		
	local check = AddS( "DCheckBoxLabel" )
		check:SetConVar(Tag.."_friendsonly")
		check:SetText( "Load only outfits of friends")
		check:SetTooltip[[When non friend wears an outfit it gets blocked]]
		check:SizeToContents()

		check:DockMargin(1,4,1,1)
	local d_5 = check

	hr()

	local slider = AddS( "DNumSlider" )
		slider:SetText( "Outfit download distance" )
		slider:SizeToContents()
		slider:DockPadding(0,16,0,0)
		slider.Label:Dock(TOP)
		slider.Label:DockMargin(0,-16,0,0)
		slider:SetTooltip[[How near does a player have to be for an outfit to download]]

		slider:DockMargin(1,12,1,1)
		slider:SetMin( 0 )
		slider:SetMax( 5000 )
		slider:SetDecimals( 0 )
		slider:SetConVar( Tag..'_distance' )
		local sld_dist = slider
			
	local c = AddS( "DComboBox" )
	c:SetSize( 100, 20 )
	c:SetTooltip[[Distance mode: start downloading outfits when you get near a player]]
	--c.SetValue = function(c,val)
	--	local setv = val==0 and 2 or val==1 and 3 or 1 
	--	dbgn(2,"ChooseDistanceModeCtrl",val,'->',setv)
	--	c:ChooseOptionID(setv)
	--end
	local distance_mode
	c.OnSelect = function(c,val)
		distance_mode=distance_mode or GetConVar(Tag..'_distance_mode')
		local choose = val==1 and -1 or val==2 and 0 or 1
		dbgn(2,"ChooseDistanceMode", val, '->', choose )
		distance_mode:SetInt(choose)
	end
	c:AddChoice( "Default Mode", '-1' )
	c:AddChoice( "See All Outfits", '0' )
	c:AddChoice( "Nearby Outfits Only", '1' )
	
	c:SetConVar(Tag..'_distance_mode')
	local d_4 = c
	c:DockMargin(0,12,0,0)
	
	
	hr()

	local slider = AddS( "DNumSlider" )
		slider:SetText( "Maximum download size (in MB)" )
		slider:SizeToContents()
		slider:DockPadding(0,16,0,0)
		slider.Label:Dock(TOP)
		slider.Label:DockMargin(0,-16,0,0)
		
		slider:SetTooltip[[This is how big an outfit you can receive without it being blocked]]

		slider:DockMargin(1,4,1,1)
		slider:SetMin( 0 )
		slider:SetMax( 256 )
		slider:SetDecimals( 0 )
		slider:SetConVar( Tag..'_maxsize' )
		local sld_dl = slider
	--TODO
	--local check = functions:Add( "DCheckBoxLabel" )
	-- 	check:SetConVar(Tag.."_ask")
	--	check:SetText( "Ask mode")
	--	check:SizeToContents()
	--	check:Dock(TOP)
	--	check:DockMargin(1,4,1,1)
	
	
	hr()

	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_hands")
		check:SetText( "Use hands")
		check:SetTooltip[[Should we guess hands for the playermodels]]
		check:SizeToContents() 

		check:DockMargin(1,4,1,1)
	local d_6 = check
	
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_sounds")
		check:SetText( "UI sounds")
		check:SetTooltip[[Should we play informational sounds]]
		check:SizeToContents() 

		check:DockMargin(1,4,1,1)
	local d_7 = check
	
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_gui_focusdim")
		check:SetText( "Dim GUI")
		check:SetTooltip[[When mouse leaves the UI should we dim it?]]
		check:SizeToContents()
		check:DockMargin(1,4,1,1)
		
	hr()
	local check = AddS( "DCheckBoxLabel" )
		check:SetConVar(Tag.."_allow_http_test")
		check:SetText( "Allow outfits from outside workshop")
		check:SetTooltip[[Allow HTTP downloads from outside workshop. Unsafe potentially!!!]]
		check:SizeToContents()

		check:DockMargin(1,4,1,1)




	local check = AddS( "DCheckBoxLabel" )
		check:SetConVar(Tag.."_allow_unsafe_http")
		check:SetText( "Load outfits from untrusted URLs (UNSAFE, may leak IP!!!)")
		check:SetTooltip[[Outfitter by default does not allow HTTP downloads from everywhere, but can be set to allow them for local testing]]
		check:SizeToContents()

		check:DockMargin(1,4,1,1)

	hr()

	local debug = AddS( "DCheckBoxLabel" )
	 	debug:SetConVar(Tag.."_dbg")
		debug:SetText( "#debug")
		debug:SetTooltip[[Print debug stuff to console. Enable this if something is wrong and in the bugreport give the log output.]]
		debug:SizeToContents()
 
		debug:DockMargin(1,14,1,1)
		local d_3 = debug

	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_unsafe")
		check:SetText( "Unsafe")
		check:SizeToContents()

		check:SetTooltip[[Remove some outfit checks (for yourself only). This should not be needed ever.]]
		check:DockMargin(1,4,1,1)
		local d_1 = check
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_failsafe")
		check:SetText( "Failsafe")
		check:SizeToContents()
		check:SetTooltip[[This gets ticked if you were detected to crash right after applying outfit.]]

		check:DockMargin(1,4,1,1)
		local d_2 = check
		
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_use_autoblacklist")
		check:SetText( "Autoblacklist")
		check:SizeToContents()
		check:SetTooltip[[Blacklists outfits that crashed you automatically]]
		check:DockMargin(1,4,1,1)
		local d_2 = check
	hr()
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_animfix_oldmethod")
		check:SetText( "Legacy: Use fullupdate for local player animations")
		check:SizeToContents()
		check:SetTooltip[[Previously we needed a fullupdate to fix animations. Now a different technique is used.]]

		check:DockMargin(1,4,1,1)
		
	local check = AddS( "DCheckBoxLabel" )
		check:SetConVar(Tag.."_download_notifications")
		check:SetText( "Legacy: Show downloading notifications")
		check:SizeToContents()
		check:SetTooltip[[Show downloading notifications when downloading models from the workshop]]

		check:DockMargin(1,4,1,1)

	local check = AddS( "DButton" )
	 	check:SetText( "FIX: Clear models blacklist") 
		check:DockMargin(1,4,1,1)
		check.DoClick=function()
			RunConsoleCommand"outfitter_blacklist_clear"
		end
		check:SetImage'icon16/tag_blue_delete.png'
		
	local check = AddS( "DButton" )
	 	check:SetText( "FIX: Fullupdate") 
		check:DockMargin(1,4,1,1)
		check.DoClick=function()
			Fullupdate()
		end
		check:SetImage'icon16/transmit_error.png'
		
	local check = AddS( "DButton" )
	 	check:SetText( "FIX: Local player animations") 
		check:DockMargin(1,4,1,1)
		check.DoClick=function()
			FixLocalPlayerAnimations(true)
		end
		check:SetImage'icon16/transmit_error.png'
		
	local b = Add('DButton','thirdperson')
		b:SetText("#tool.camera.name")
		b:SetTooltip[[Enables/disable thirdperson (if one is installed)]]

		b.DoClick=function() ToggleThirdperson() end
		b:DockMargin(16,2,16,1)
		b:SetImage'icon16/find.png'
	
	
	
	--local b = Add('EditablePanel')
	--b:SetTall(1)
	--b:DockMargin(-4,24,-4,1)
	--b.Paint = function(b,w,h)
	--	surface.SetDrawColor(240,240,240,200)
	--	surface.DrawRect(0,0,w,h)
	--end
	--local hr_line1 = b
	
	--------------------------------------------------
	
	
		
	-- second layer
	local cont = functions:Add('EditablePanel','container')
	cont:SetTall(24)
	cont:Dock(BOTTOM)
		
	local b = vgui.Create('DButton',mdllist,'Bodygroups button')
		function b.Refresh(b)
			-- poor man's pcall
			co(function()
				b.mdl = false
				b:SetEnabled2(false)
				dbg("Bodygroup","BTN","Refresh")
				
				local l = UIGetMDLList()
				if not l then return end
				local chosen = UIGetChosenMDL()
				if not chosen then return false end
				local mdl = l[chosen]
				if not mdl then return false end
				if not file.Exists(mdl.Name,'workshop') and not file.Exists(mdl.Name,'GAME') then return false end
				local a = mdlinspect.Open(mdl.Name)
				a:ParseHeader()
				local parts = a:BodyPartsEx()
				local ok 
				for k,v in next,parts do
					if v.nummodels>1 then
						ok=true
						break
					end
				end
				if not ok then return end
				
				b:SetEnabled2(true)
				b.mdl = mdl
			end)
		end
		
		
		self.btn_bg= b
		b:Dock(NODOCK)
		b:SetText("")
		b:SetSize(24,24)
		b:SetTooltip[[#GameUI_Modify]]
		b.DoClick= function()
			GUIOpenBodyGroupOverlay(self) --, b.mdl.Name)
		end
		b:SetImage'icon16/group_edit.png'
		b.PerformLayout=function(b,w,h)
			DButton.PerformLayout(b,w,h)
			
			local w2 = b:GetParent():GetCanvas():GetWide()
			
			local _,y = b:GetParent():GetSize()
			b:SetPos(w2-w-1,y-h-1)
		end
		function b.SetEnabled2(b,v)
			b:SetDisabled(not v)
			b._set_enabled = v
		end
		--b.PaintOver= function(b,w,h)
		--	if b._set_enabled then
		--		if UIGetChosenMDL() and UIGetMDLList() and LocalPlayer().latest_want~=UIGetMDLList()[UIGetChosenMDL()] then
		--			surface.SetDrawColor(55,240,55,40+25*math.sin(RealTime()*7)^2)
		--			surface.DrawRect(1,1,w-2,h-2)
		--		end
		--	end
		--end
	
	local b = cont:Add('DButton','Autowear button')
		self.btn_autowear = b
		b:SetTooltip[[Automatically wear this outfit on servers]]
		b:SetText("#makepersistent")
		b:Dock(FILL)
		b:SizeToContents()
		b.DoClick = function()
			local m = DermaMenu()
				m:AddOption("#makepersistent",function()
					SetAutowear()
				end):SetIcon'icon16/vcard_edit.png'
				m:AddOption("#vgui_htmlreload",function()
					if co.make() then return end
					coDoAutowear()
				end):SetIcon'icon16/transmit_go.png'
			m:Open()
		end
		b:SetImage'icon16/disk.png'
	
	
	--------------------------------------------------

	
	local cont = functions:Add('EditablePanel','container')
	cont:SetTall(32)
	cont:Dock(BOTTOM)
	
	local b = cont:Add('DButton','Send button')
		self.btn_send= b
		b:Dock(LEFT)
		b:SetText("#gameui_submit")
		b:SetTooltip[[This broadcasts the outfit you have chosen to the whole server]]
		b.DoClick= function()
			GUIBroadcastMyOutfit()
			b._set_enabled  = false
			self:GetParent():Hide()
		end
		b:SetImage'icon16/transmit.png'
		b.PerformLayout=function(b,w,h)
			DButton.PerformLayout(b,w,h)
			b:SetWide(b:GetParent():GetWide()*.5)
		end
		self.btnSendOutfit = b
		function b.SetEnabled2(b,v)
			b:SetDisabled(not v)
			b._set_enabled = v
		end
		b.PaintOver= function(b,w,h)
			if b._set_enabled then
				if UIGetChosenMDL() and UIGetMDLList() and LocalPlayer().latest_want~=UIGetMDLList()[UIGetChosenMDL()] then
					surface.SetDrawColor(55,240,55,40+25*math.sin(RealTime()*7)^2)
					surface.DrawRect(1,1,w-2,h-2)
				end
			end
		end
	
	
	
	local b = cont:Add('DButton','Clear button')
		self.btn_clear = b
		b:SetTooltip[[This removes all traces of you wearing an outfit]]
		b:SetText("#gameui_cancel")
		b:Dock(FILL)
		b:SizeToContents()
		b.DoClick= function()
			UICancelAll()
			self:DoRefresh(trychoose_mdl)
			--self:GetParent():Hide()
		end
		b:SetImage'icon16/cancel.png'
		
		
	
	local div = self:Add"DHorizontalDivider"
	div:Dock( FILL )
	
	functions:Dock(NODOCK)
	sheet:Dock(NODOCK)
	div:SetCookieName(Tag)
	div:SetLeft( functions )
	div:SetRight( sheet )
	div:SetDividerWidth( 4 ) --set the divider width. DEF: 8
	div:SetLeftMin( 150 )	 --set the minimun width of left side
	div:SetRightMin( 0 )
	div:SetLeftWidth( 300 )

	--------------------------------------------------
	
end


gui_readytosend = false
local wanting = false
local want_wsid
local want_mdl
function PANEL:WantOutfitMDL(wsid,mdl,title)
	dbg("WantOutfitMDL",wanting and "ALREADY WANTING" or "",wsid,mdl,title)
	if wanting and want_wsid == wsid then
		want_mdl = mdl
	end
	
	if wanting then return false end
	want_wsid = wsid
	want_mdl = mdl
	
	local worker=co(function()
		if wanting then return end
		wanting = true
		self:GetParent():Hide()
		dbg("WantOutfitMDL",wanting and "ALREADY WANTING" or "",wsid,mdl,title)
		local ok,err = xpcall(UIChoseWorkshop,debug.traceback,wsid)
		if not ok then ErrorNoHalt(err..'\n') wanting=false return end
		GUIOpen(nil,want_mdl)
		wanting = false
	end)
	
	return worker

end


function PANEL:WSChoose()
	self:Hide()
	if self.chosen_id then
		surface.PlaySound"npc/vort/claw_swing1.wav"
		UIChoseWorkshop(self.chosen_id)
	end
end


function GUIBroadcastMyOutfit()
	local mdl,wsid = UIBroadcastMyOutfit()
	if mdl and wsid then
		co(function()
			local self = GUIPanel()
			--if self and self.lbl_chosen:IsValid() then
			--	self.lbl_chosen:SetText( "Loading info..." )
			--end
			
			
			
			local info = co_steamworks_FileInfo(wsid)
			local title = info.title
			local self = GUIPanel()
			--if self and self.lbl_chosen:IsValid() then
			--	self.lbl_chosen:SetText( title or "" )
			--end
			if not title then return end
			GUIAddHistory(wsid,title,mdl)
		end)
	end
end

local want_n
local choosing
function GUIChooseMDL(n)
	
	dbg("GUIChooseMDL",n,choosing and "already choosing, changing" or "",want_n)
	want_n = n
	
	if choosing then return false end
	local mdllist = UIGetMDLList()
	local mdl = mdllist and mdllist[n]
	if not mdl then return false end
	
	co(function()
		if choosing then return end
		choosing = true
		UIChangeModelToID(n)
		if n~=want_n and want_n then
			dbg("CHANGE WANT OT",want_n)
			UIChangeModelToID(want_n,true)
		end
		dbg("GUIChooseMDL","FINISH",n)
		want_n = nil
		choosing = false
		GUICheckTransmit()
	end)
	return mdl
end


function GUIClearHistory()
	GUIDelHistory(-1)
end

local function SAVE(t)
	local s= json.encode(t)
	util.SetPData("0",Tag,s)
end

local function LOAD()
	local s= util.GetPData("0",Tag,false)
	if not s or s=="" or s=="nil" then return {} end
	local t = json.decode(s)
	return t or {}
end

local hist
function GUIAddHistory(wsid,title,mdl)
	if not title or not mdl or not wsid then return end
	if not hist then
		GUIGetHistory()
	end
	for k,v in next,hist do
		local wsid2,mdl2 = v[1],v[2]
		if wsid2==wsid and mdl2==mdl then return end
	end
	
	local t = {wsid,mdl,title}
	table.insert(hist,t)
	SAVE(hist)
	
	GUIRefresh()
	
	return t
end

function GUIGetHistory()
	if not hist then hist = LOAD() end
	return hist
end

function GUIDelHistory(n)
	if n<0 then table.Empty(hist) end
	local ret = table.remove(hist,n)
	SAVE(hist)
	
	GUIRefresh()
	
	return ret
end

function GUICheckTransmit()
	local gui  = GUIPanel()
	if not gui then return end
	local self = gui.content
	if not self then return end
	
	local cansend = UIGetChosenMDL() and UIGetDownloadInfoX() and UIGetMDLList()
	self.btnSendOutfit:SetEnabled2(cansend)
	self.btn_bg:Refresh()
end

function PANEL:DoRefresh(trychoose_mdl)
	dbg("doRefresh",trychoose_mdl)
	self.mdllist:Clear()
	self.btn_bg:Refresh()
	self.mdlhist:Clear()
	
	self.lbl_chosen:SetText("Please choose a workshop addon")

	local wsid = UIGetWSID()
	
	co(function()
		self.lbl_chosen:SetText("-")

		if wsid and tonumber(wsid) then
			self.lbl_chosen:SetText( "Loading info..." )
			local info = co_steamworks_FileInfo(wsid)
			if not self:IsValid() then return end
			if not self.lbl_chosen:IsValid() then return end
			
			if wsid~=UIGetWSID() then
				return
			end
			if not info or not info.title then
				self.lbl_chosen:SetText("-")
			else
				local str = ("%s (%s)"):format(info.title,string.NiceSize(info.size or 0))
				self.lbl_chosen:SetText(str)
			end
		
		elseif wsid and #wsid:find"http" then -- it's a gma download
			local ok,body,len,hdrs,code = co_head(wsid)
			if ok then
				self.lbl_chosen:SetText("GMA: Not OK?")
			else
				local size = hdrs and hdrs["Content-Length"] and tonumber(hdrs["Content-Length"])
				self.lbl_chosen:SetText(("GMA HEAD OK (%s)"):format(size and string.NiceSize(size) or "Size Unknown!"))
			end
		end
	end)

	
	local tm = UITriedMounting()
	local mdllist = UIGetMDLList()
	
	GUICheckTransmit()
	
	
	-- model list
	local chosen
	for k,dat in next,mdllist or {} do
		if trychoose_mdl and trychoose_mdl==dat.Name then
			chosen = true
		end
		local pnl = self.mdllist:AddLine( dat.Name and MDLToUI(dat.Name) or "???" )
		
		if chosen and chosen==true then
			chosen = pnl
		end
		
	end
	
	local extra = UIGetMDLListExtra()
	if extra and extra.discards then
		
		for k,dat in next,extra.discards or {} do
			local pnl = self.mdllist:AddLine( dat.Name and MDLToUI(dat.Name) or "???" )
			pnl:SetTooltip(dat.error_player or dat.error_vvd or "INVALID MODEL")
			local Paint = pnl.Paint or wlib.func.blank
			pnl.Paint = function(pnl,w,h)
				local r = Paint(pnl,w,h)
				surface.SetDrawColor(240,30,30,120)
				surface.DrawRect(0,0,w,h)
				return r
			end
		end
	
	end
	
	for _,v in next,GUIGetHistory() do
		local wsid,mdl,title = unpack(v)

		
		local pnl = self.mdlhist:Add( 'DOWorkshopIcon' )
		pnl:SetAddon({wsid = wsid,title=MDLToUI(mdl)})
		self.mdlhist:Layout()
		pnl:SetTooltip(title .. '\n'..mdl)
		pnl._OnMousePressed = pnl.OnMousePressed
		pnl.OnMousePressed = function(pnl,mc)
			if mc==MOUSE_RIGHT then
				local m = DermaMenu()
					m:AddOption("#open_workshop",function()
						gui.OpenURL(("https://steamcommunity.com/workshop/filedetails/?id=%d"):format(wsid))
					end):SetIcon'icon16/world.png'
					m:AddOption("#gameui_delete",function()
						for n,vv in next,GUIGetHistory() do
							if vv==v then
								GUIDelHistory(n)
								return
							end
						end
					end):SetIcon'icon16/bin.png'
				m:Open()
				return
			elseif mc==MOUSE_LEFT then
				if not self:WantOutfitMDL(unpack(v))then
					surface.PlaySound"common/warning.wav"
				end
			end
			
		end
	end

	if chosen then
		if chosen~=true then
			
			dbg("SelectItem","AUTO",chosen,trychoose_mdl)
			
			self.mdllist:SelectItem(chosen)

		else
			dbg("Choose missing",trychoose_mdl)
		end
		
	end
	
	self.btn_bg:Refresh()
	
end

local factory = vgui.RegisterTable(PANEL,'EditablePanel')









-- main panel

local PANEL={}
function PANEL:Init()

	local pnl = vgui.CreateFromTable(factory,self)
	self.content = pnl
	pnl:Dock(FILL)
	
	local t=os.date"*t"
	self.m_bPaintHat = t.month==12 and t.day<=25
	
	self:SetCookieName"ofp"
	self:SetTitle"Outfitter"
	self:SetMinHeight(290)
	self:SetMinWidth(312)
	self:SetPos(32,32)
	self:SetDeleteOnClose(false)
	self.btnMinim:SetEnabled(true)
	self.btnMaxim:SetEnabled(true)
	local had_max = self:GetCookie( "pmax", "" ) == '1'
	
	if had_max then
		self:SetSize(640,400)
	else
		self:SetSize(313,293)
	end
	 
	self.btnMaxim.DoClick=function()
		self:SetSize(640,400)
		self:SetCookie( "pmax", '1' )
		had_max = true
		self:CenterVertical()
	end
	
	self:CenterVertical()
	
	if not had_max then
		self.btnMaxim.PaintOver = function(b,w,h)
			if had_max then return end
			b:NoClipping(false)
			surface.SetDrawColor(255,66,22,255*.5 + 255*.3 * math.sin(RealTime()*4))

			surface.DrawOutlinedRect(-1,-1,w+1,h+1)
			surface.DrawOutlinedRect(0,0,w,h)
			b:NoClipping(true)
		end
	end
	self.btnMinim.DoClick=function()
		self:SetSize(313,293)
		self:CenterVertical()
		
	end
	self:SetDraggable( true )
    self:SetSizable( true )
	
	local title = self.lblTitle
	if title then
		self:SetIcon'icon16/user.png'
		--local img = vgui.Create('DImage',title)
		--img:SetImage("icon16/user.png")
		--img:Dock(LEFT)
		--img.PerformLayout = function()
		--	img:SetWide(img:GetTall())
		--	title:SetTextInset(img:GetTall() + 5,0)
		--end
	
		local check = self:Add( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_enabled")
		check:SetText( "#gameui_enabled")
		check:SizeToContents()
		check:SetTooltip[[Toggle this if someone's outfit got blocked or should be showing]]
		self.btnCheck = check
	end
	local OnMouseReleased = self.OnMouseReleased
	self.OnMouseReleased = function(...)
		self.OnMouseReleasedHook(...)
		return OnMouseReleased(...)
	end
	local Think = self.Think
	self.Think = function(...)
				
		Think(...)

		local hovered = self:IsHovered() or self:IsChildHovered()
		
		if hovered and not self.hadhover then
			self.hadhover = true
		end 
		
		local hasf = not outfitter_gui_focusdim:GetBool() or (hovered or not self.hadhover) or self.Dragging or self.Sizing
		if hasf~=self.hierfocused then
			self.hierfocused = hasf
			if hasf then
				self.fadeouttime=nil
				self:SetAlpha(255)
			else
				self.fadeouttime = RealTime()
			end
		end
		if self.fadeouttime then
			local f = (RealTime()-self.fadeouttime)/0.15
			f=1-f
			f=f>1 and 1 or f<0 and 0 or f
			self:SetAlpha(f*200+55)
		end
		
		local x,y=self:CursorPos()
		if x>0 and x<20 and y>0 and y<20 then
			self:SetCursor( "hand" )
		end
	end
end

function PANEL:OnMouseReleasedHook(mc)

	local x,y = self:CursorPos()
	if x<0 or x>20 then return end
	if y<0 or y>20 then return end
	
	
	if mc==MOUSE_LEFT then
		GUIAbout()
		return
	end
	
	local menu = DermaMenu()
	
	if UIGetChosenMDL() and UIGetMDLList() and LocalPlayer().latest_want~=UIGetMDLList()[UIGetChosenMDL()] then
		menu:AddOption( "#gameui_submit", function() GUIBroadcastMyOutfit() end ):SetImage'icon16/transmit.png'
	end
	
	--menu:AddLine()
	
	menu:AddOption( "About", function() GUIAbout() end ):SetImage'icon16/information.png'
	menu:AddOption( "Close", function() self:Hide() end ):SetImage'icon16/door_out.png'
	menu:Open()
end

function PANEL:PerformLayout(w,h)
	DFrame.PerformLayout(self,w,h)
	self.btnMinim:SetEnabled(w>(self:GetMinWidth() + 5) or h>(5 + self:GetMinHeight()))
	
	local check = self.btnCheck
	local cw,ch = 0,0
	if check then
		cw,ch = check:GetSize()
	end
	
	local b = self.btnMinim or self.btnMaxim
	if b and b:IsValid() then
		local bw,bh = b:GetWide(),b:GetTall()
		local bx,by = b:GetPos()
		if check then
			check:SetPos(bx-cw-4,by+bh*.5-ch*.5+1)
			check:SetVisible(w>256)
		end
	end
end
function PANEL:Hide()
	self:SetVisible(false)
	--hook.Run("OnContextMenuClose")
	self:OnClose()
end

function PANEL:OnClose()
	self.want_thirdperson = InThirdperson()
	ToggleThirdperson(false)
end

function PANEL:Show(_,trychoose_mdl)
	--if not self:IsVisible() then
		surface.PlaySound"garrysmod/ui_return.wav"
	--end
	self:SetVisible(true)
	self:MakePopup()
	self:DoRefresh(trychoose_mdl)
	if self.want_thirdperson then
		ToggleThirdperson(true)
	end
end
function PANEL:DoRefresh(trychoose_mdl)
	if not self:IsVisible() then return end
	
	self.content:DoRefresh(trychoose_mdl)
	
end

local factory = vgui.RegisterTable(PANEL,'DFrame')

if this.m_vGUIDlg and ValidPanel(this.m_vGUIDlg) then
	m_vGUIDlg:Remove()
end


function GUIPanel()
	return ValidPanel(m_vGUIDlg) and m_vGUIDlg
end

function GUIRefresh()
	local gui = GUIPanel()
	if gui then gui:DoRefresh() end
end

local prev = rawget(_M,'m_vGUIDlg')
if ValidPanel(prev) then prev:Remove() end
m_vGUIDlg = NULL
local alerted
function GUIOpen(_,trychoose_mdl)
	

	if not ValidPanel(m_vGUIDlg) then
		local d = vgui.CreateFromTable(factory,nil,Tag..'_GUI')
		m_vGUIDlg = d
	end
	
	
	m_vGUIDlg:Show(nil,trychoose_mdl)
	
	if Derma_Message and not alerted and game.SinglePlayer() then
		alerted = true
		Derma_Message("You are playing singleplayer. Outfitter may not work at all.",'WARNING')
	end
	
	return m_vGUIDlg
end

	

if NOUI then return end
concommand.Add(Tag..'_open',function()
	GUIOpen()
end)
--RunConsoleCommand(Tag..'_open')
--addons/module_wayban/lua/permaban/client.lua:
local frame = {}

local function openPermaMenu()
    if not WayBan.config.userGroups[LocalPlayer():GetUserGroup()] then return LocalPlayer():ChatPrint('Мне почему-то кажется, что тебе нельзя пользоваться этим.') end
    
    frame.main = vgui.Create('DFrame')
    frame.main:SetSize(ScrW()*0.5, ScrH()*0.5)
    frame.main:SetTitle('Пермабан')
    frame.main:SetIcon('icon16/shield.png')
    frame.main:MakePopup()
    frame.main:Center()
    frame.main.Paint = function (self, w, h)
        draw.RoundedBox(0,0,0,w,h,Color(54,57,62))
    end

    frame.bottomPnl = vgui.Create('DPanel', frame.main)
    frame.bottomPnl:Dock(BOTTOM)
    frame.bottomPnl:SetTall(30)

    frame.entry = vgui.Create('DTextEntry', frame.bottomPnl)
    frame.entry:Dock(LEFT)
    frame.entry:SetText('SteamID нарушителя')
    frame.entry:SetWide(frame.main:GetWide()*0.8)
    frame.entry.OnGetFocus = function (self)
        if self:GetValue() == 'SteamID нарушителя' then self:SetValue('') end
    end

    frame.ban = vgui.Create('DButton', frame.bottomPnl)
    frame.ban:Dock(RIGHT)
    frame.ban:SetText('Забанить')
    frame.ban:SetWide(frame.main:GetWide()*0.2)

    frame.list = vgui.Create('DListView', frame.main)
    frame.list:Dock(FILL)
    frame.list:AddColumn('SteamID игрока')
    frame.list:AddColumn('Причина')
    frame.list:AddColumn('Никнейм Админа')
    frame.list:AddColumn('SteamID Админа')
    frame.list:AddColumn('Дата выдачи')
    frame.list:SetHeaderHeight(20)
    frame.list:SetMultiSelect(false)
    frame.list.OnRowRightClick = function (line, id)
        local menu = DermaMenu()

        menu:AddOption('SteamID', function ()
            SetClipboardText(frame.list:GetLine(id):GetColumnText(1))
            LocalPlayer():ChatPrint('SteamID нарушителя скопирован в буфер обмена')
        end)

        menu:AddOption('SteamID Админа', function ()
            SetClipboardText(frame.list:GetLine(id):GetColumnText(4))
            LocalPlayer():ChatPrint('SteamID Админа скопирован в буфер обмена')
        end)

        menu:AddSpacer()

        menu:AddOption('Разбанить', function ()
            RunConsoleCommand('wayban_unban', frame.list:GetLine(id):GetColumnText(1))
            frame.list:RemoveLine(id)
        end)

        menu:Open()
    end

    frame.ban.DoClick = function ()
        if not frame.entry:GetValue() or not string.match(frame.entry:GetValue(), 'STEAM_') then return notification.AddLegacy('Ты указал неверный SteamID', 1, 5) end
        Derma_StringRequest(
            'Пермабан',
            'Введи сюда причину бана',
            '',
            function (text)
                RunConsoleCommand('wayban', frame.entry:GetValue(), tostring(text))
                RunConsoleCommand('wayban_search')
            end
        )
    end

    RunConsoleCommand('wayban_search')
end

net.Receive('WayBan.getBannedData', function ()
    if not IsValid(frame.list) then return end

    --frame.list:Clear()

    local count = net.ReadUInt(32)

    for i=1, count do
        frame.list:AddLine(net.ReadString(), net.ReadString(), net.ReadString(), net.ReadString(), net.ReadString()) -- Лол)
    end
end)

concommand.Add('wayban_menu', openPermaMenu)
--addons/module_donate/lua/pointshop/cl_init.lua:
--[[
	pointshop/cl_init.lua
	first file included clientside.
]]--

include "sh_init.lua"
include "cl_player_extension.lua"

include "vgui/DPointShopMenu.lua"
include "vgui/DPointShopItem.lua"
include "vgui/DPointShopPreview.lua"
include "vgui/DPointShopColorChooser.lua"
include "vgui/DPointShopGivePoints.lua"
include "vgui/DPointShopOpenCase.lua"
include "vgui/DPointShopCaseSpin.lua"

PS.ShopMenu = nil
PS.ClientsideModels = {}

PS.HoverModel = nil
PS.HoverModelClientsideModel = nil

local invalidplayeritems = {}

PS_ModelOffsets = PS_ModelOffsets or {}

function PS_SaveOffsets()

	file.CreateDir( "ps_offsets" )
	file.Write( "ps_offsets/data.dat", util.TableToJSON(PS_ModelOffsets) )

	chat.AddText( "Saved PS items to 'ps_offsets/data.dat'." )

end

function PS_LoadOffsets()

	if not file.Exists( "ps_offsets/data.dat", "DATA" ) then
		chat.AddText( "No 'ps_offsets/data.dat' file." )
		return
	end

	local data = file.Read( "ps_offsets/data.dat" )
	PS_ModelOffsets = util.JSONToTable( data )

	chat.AddText( "Loaded PS items from 'ps_offsets/data.dat'." )

end
concommand.Add( "ps_loadoffsets", PS_LoadOffsets )

net.Receive('PS_ModelOffsets', function( len )

	PS_ModelOffsets = net.ReadTable()

end)

concommand.Add( "ps_offseteditor", function()

	local mdl = LocalPlayer():GetModel()
	local data = PS_ModelOffsets[ mdl ]
	if not data then
		PS_ModelOffsets[ mdl ] = {
			face = { Vector( 0, 0, 0 ), 1 },
			hat = { Vector( 0, 0, 0 ), 1 },
			back = { Vector( 0, 0, 0 ), 1 },
			neck = { Vector( 0, 0, 0 ), 1 },
		}
		data = PS_ModelOffsets[ mdl ]
	end

	local w = vgui.Create( "DFrame" )
	w:SetTitle( "PS offset editor" )
	w:SetSize( 400, 600 )
	w:Center()
	w:MakePopup()

	for typeName, offsetData in pairs( data ) do
		local s1 = vgui.Create( "DNumSlider", w )
		s1:SetTall( 30 )
		s1:Dock( TOP )
		s1:SetText( typeName .. " x" )
		s1:SetMin( -10 )
		s1:SetMax( 10 )
		s1:SetDecimals( 2 )
		s1:SetValue( offsetData[1].x )
		function s1.OnValueChanged( self, val )
			offsetData[1].x = val
		end

		local s2 = vgui.Create( "DNumSlider", w )
		s2:SetTall( 30 )
		s2:Dock( TOP )
		s2:SetText( typeName .. " y" )
		s2:SetMin( -10 )
		s2:SetMax( 10 )
		s2:SetDecimals( 2 )
		s2:SetValue( offsetData[1].y )
		function s2.OnValueChanged( self, val )
			offsetData[1].y = val
		end

		local s3 = vgui.Create( "DNumSlider", w )
		s3:SetTall( 30 )
		s3:Dock( TOP )
		s3:SetText( typeName .. " z" )
		s3:SetMin( -10 )
		s3:SetMax( 10 )
		s3:SetDecimals( 2 )
		s3:SetValue( offsetData[1].z )
		function s3.OnValueChanged( self, val )
			offsetData[1].z = val
		end

		local s4 = vgui.Create( "DNumSlider", w )
		s4:SetTall( 30 )
		s4:Dock( TOP )
		s4:SetText( "scale" )
		s4:SetMin( 0.05 )
		s4:SetMax( 3 )
		s4:SetDecimals( 2 )
		s4:SetValue( offsetData[2] )
		function s4.OnValueChanged( self, val )
			offsetData[2] = val
		end
	end

	local save = vgui.Create( "DButton", w )
	save:SetText( "Save" )
	save:SetTall( 30 )
	save:Dock( BOTTOM )
	save.DoClick = PS_SaveOffsets

end)

-- menu stuff

function PS:ToggleMenu()
	if not PS.ShopMenu then
		PS.ShopMenu = vgui.Create('DPointShopMenu')
		PS.ShopMenu:SetVisible(false)
	end

	if PS.ShopMenu:IsVisible() then
		PS.ShopMenu:Hide()
		gui.EnableScreenClicker(false)
	else
		PS.ShopMenu:Show()
		PS.ShopMenu.openedTime = SysTime()
		gui.EnableScreenClicker(true)
	end
end

function PS:OpenCaseMenu(data, case, s, e)
	if not IsValid(PS.ShopMenu) or not PS.ShopMenu:IsVisible() then
		PS:ToggleMenu()
	end
	PS.ShopMenu:OpenCaseMenu(data, case, s, e)
end

function PS:SetHoverItem(item_id)
	local ITEM = PS.Items[item_id]

	if ITEM.Model then
		self.HoverModel = item_id

		self.HoverModelClientsideModel = ClientsideModel(ITEM.Model, RENDERGROUP_OPAQUE)
		self.HoverModelClientsideModel:SetNoDraw(true)
	end
end

function PS:RemoveHoverItem()
	self.HoverModel = nil
	self.HoverModelClientsideModel = nil
end

-- modification stuff

function PS:ShowColorChooser(item, modifications)
	-- TODO: Do this
	local chooser = vgui.Create('DPointShopColorChooser')
	chooser:SetColor(modifications.color)

	chooser.OnChoose = function(color)
		modifications.color = color
		self:SendModifications(item.ID, modifications)
	end
end

function PS:SendModifications(item_id, modifications)
	net.Start('PS_ModifyItem')
		net.WriteString(item_id)
		net.WriteTable(modifications)
	net.SendToServer()
end

-- net hooks

net.Receive('PS_ReloadMenu', function( len, ply )
	if PS.ShopMenu then
		PS.ShopMenu:Remove()
		PS.ShopMenu = vgui.Create('DPointShopMenu')
		PS.ShopMenu:SetVisible(true)
	end
end)

net.Receive('PS_ToggleMenu', function(length)
	PS:ToggleMenu()
end)

net.Receive('PS_Items', function(length)
	local ply = net.ReadEntity()
	local items = net.ReadTable()
	ply.PS_Items = PS:ValidateItems(items)

	hook.Run('PS_UpdatedClientsideInfo', ply)
end)

net.Receive('PS_Points', function(length)
	local ply = net.ReadEntity()
	local points = net.ReadFloat()
	ply.PS_Points = PS:ValidatePoints(points)

	hook.Run('PS_UpdatedClientsideInfo', ply)
end)

net.Receive('PS_Inventory', function(length)
	local ply = net.ReadEntity()
	local inventory = net.ReadTable()
	ply.PS_Inventory = inventory

	hook.Run('PS_UpdatedClientsideInfo', ply)
end)

net.Receive('PS_AddClientsideModel', function(length)
	local ply = net.ReadEntity()
	local item_id = net.ReadString()

	if not IsValid(ply) then
		if not invalidplayeritems[ply] then
			invalidplayeritems[ply] = {}
		end

		table.insert(invalidplayeritems[ply], item_id)
		return
	end

	ply:PS_AddClientsideModel(item_id)

	hook.Run('PS_UpdatedClientsideInfo', ply)
end)

net.Receive('PS_RemoveClientsideModel', function(length)
	local ply = net.ReadEntity()
	local item_id = net.ReadString()

	if not ply or not IsValid(ply) or not ply:IsPlayer() then return end

	ply:PS_RemoveClientsideModel(item_id)

	hook.Run('PS_UpdatedClientsideInfo', ply)
end)

net.Receive('PS_SendClientsideModels', function(length)
	local itms = net.ReadTable()

	for ply, items in pairs(itms) do
		if not IsValid(ply) then -- skip if the player isn't valid yet and add them to the table to sort out later
			invalidplayeritems[ply] = items
			continue
		end

		for _, item_id in pairs(items) do
			if PS.Items[item_id] then
				ply:PS_AddClientsideModel(item_id)
			end
		end
	end
end)

net.Receive('PS_SendNotification', function(length)
	local str = net.ReadString()
	notification.AddLegacy(str, NOTIFY_GENERIC, 5)
end)

net.Receive('PS_UpdateSlots', function(length)
	LocalPlayer().PS_Slots = net.ReadTable()

	hook.Run('PS_UpdatedClientsideInfo', LocalPlayer())
end)

-- hooks

hook.Add('Think', 'PS_Think', function()
	for ply, items in pairs(invalidplayeritems) do
		if IsValid(ply) then
			for _, item_id in pairs(items) do
				if PS.Items[item_id] then
					ply:PS_AddClientsideModel(item_id)
				end
			end

			invalidplayeritems[ply] = nil
		end
	end
end)

local pointshop_cache = {}

timer.Create("pointshop_cache", 1, 0, function()
	
	local ply = LocalPlayer()

	if IsValid(ply) then
		
		local count = 0
		pointshop_cache = {}

	    for k,v in ipairs(ents.FindInSphere(ply:GetPos(), 500)) do
	    	if v:IsPlayer() then
	        	count = count + 1
	        	pointshop_cache[count] = v
	    	end
	    end

	end
end)

hook.Add('PostDrawOpaqueRenderables', 'PS_PostPlayerDraw', function()
	for k, ply in ipairs( pointshop_cache ) do

		if not IsValid(ply) then continue end
		
		local plyBody = ply
		
		if not ply:Alive() then
			plyBody = ply:GetNWEntity("DeathRagdoll")
			if not IsValid( plyBody ) then continue end
		end
		
		if IsValid(ply:GetNWEntity("ScriptedVehicle")) and IsValid(ply:GetNWEntity("OnSkate")) then
			plyBody = ply:GetNWEntity("OnSkate")
		end

		if plyBody == LocalPlayer() and ply:Alive() and not hook.Run( "ShouldDrawLocalPlayer", ply ) then continue end
		if ply == LocalPlayer() and PS.ShopMenu and PS.ShopMenu:IsVisible() then continue end
		if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and LocalPlayer():GetObserverTarget() == ply then continue end
		if plyBody:GetNoDraw() then continue end

		if not PS.ClientsideModels[ply] then continue end
		
		for item_id, model in pairs(PS.ClientsideModels[ply]) do
			if not PS.Items[item_id] then PS.ClientsideModel[ply][item_id] = nil continue end

			local ITEM = PS.Items[item_id]

			if not ITEM.Attachment and not ITEM.Bone then PS.ClientsideModel[ply][item_id] = nil continue end
			if plyBody == LocalPlayer() and ITEM.NoLocalPlayer and not hook.Run( "ShouldDrawLocalPlayer", ply ) then continue end

			--if ITEM.Job and not ITEM.Job[ply:getJobTable().command] then continue end
			--if ITEM.NoDrawDisguise == true and ply:GetNetVar('disguised') then continue end

			local pos = Vector()
			local ang = Angle()

			if ITEM.Attachment then
				local attach_id = plyBody:LookupAttachment(ITEM.Attachment)
				if not attach_id then continue end

				local attach = plyBody:GetAttachment(attach_id)

				if not attach then continue end

				pos = attach.Pos
				ang = attach.Ang
			else
				local bone_id = plyBody:LookupBone(ITEM.Bone)
				if not bone_id then continue end

				pos, ang = plyBody:GetBonePosition(bone_id)
			end

			local scale, scaleMod = 1
			if plyBody:GetModelScale() ~= 1 then
				scale = scale * plyBody:GetModelScale()
			end

			local oldpos, oldang = pos, Angle(ang.p, ang.y, ang.r)
			model, pos, ang, scaleMod = ITEM:ModifyClientsideModel(plyBody, model, pos, ang)

			local off = pos - oldpos
			pos = oldpos + (off) * scale

			local plyModel = plyBody:GetModel()
			if PS_ModelOffsets[plyModel] and PS_ModelOffsets[plyModel][ ITEM.OffsetType ] then
				local offset = PS_ModelOffsets[ plyModel ][ ITEM.OffsetType ]
				scale = scale * offset[2]
				pos = pos + (oldang:Right() * offset[1].x + oldang:Forward() * offset[1].y + oldang:Up() * offset[1].z) * scale
			end

			-- model:SetPos(pos)
			-- model:SetAngles(ang)
			if scaleMod then scale = scale * scaleMod end
			model:SetModelScale( scale )

			model:SetRenderOrigin( pos )
			model:SetRenderAngles(ang)
			model:SetupBones()
			model:DrawModel()
			model:SetRenderOrigin()
			model:SetRenderAngles()
		end
	end
end)

--addons/module_donate/lua/pointshop/vgui/dpointshoppreview.lua:
local PANEL = {}

function PANEL:Init()
	self.drawOtherModels = true
	
	self:SetModel(LocalPlayer():GetModel())
	self.Entity:SetSkin(LocalPlayer():GetSkin())
	self:SetFOV(40)

	local PrevMins, PrevMaxs = self.Entity:GetRenderBounds()
	self:SetCamPos(PrevMins:Distance(PrevMaxs) * Vector(0.30, 0.30, 0.25) + Vector(0, 0, 15))
	self:SetLookAt((PrevMaxs + PrevMins) / 2)
end

AccessorFunc(PANEL, 'drawOtherModels', 'ShouldDrawModels')

function PANEL:Paint( w, h )
	if ( !IsValid( self.Entity ) ) then return end

	local x, y = self:LocalToScreen( 0, 0 )

	self:LayoutEntity( self.Entity )

	local ang = self.aLookAngle
	if ( !ang ) then
		ang = (self.vLookatPos-self.vCamPos):Angle()
	end

	local w, h = self:GetSize()
	cam.Start3D( self.vCamPos, ang, self.fFOV, x, y, w, h, 5, 4096 )
	cam.IgnoreZ( true )

	render.SuppressEngineLighting( true )
	render.SetLightingOrigin( self.Entity:GetPos() )
	render.ResetModelLighting( self.colAmbientLight.r/255, self.colAmbientLight.g/255, self.colAmbientLight.b/255 )
	render.SetColorModulation( self.colColor.r/255, self.colColor.g/255, self.colColor.b/255 )
	render.SetBlend( self.colColor.a/255 )

	for i=0, 6 do
		local col = self.DirectionalLight[ i ]
		if ( col ) then
			render.SetModelLighting( i, col.r/255, col.g/255, col.b/255 )
		end
	end

	local curCat = PS:FindCategoryByName( PS.curCategory )
	if not curcat or not curCat.NoPlayer or PS.HoverModel then
		self:DrawModel()
	end

	self:DrawOtherModels()

	render.SuppressEngineLighting( false )
	cam.IgnoreZ( false )
	cam.End3D()

	self.LastPaint = RealTime()
end


local function FindEqualSlots(item1, item2)
	item1 = PS.Items[item1]
	item2 = PS.Items[item2]
	if item1.Slots and item2.Slots then
		for k,v in pairs(item1.Slots) do
			for j,z in pairs(item2.Slots) do
				if v == z then
					return true
				end
			end
		end
	end
	return false
end

function PANEL:DrawOtherModels()
	if not self:GetShouldDrawModels() then return end

	local ply = LocalPlayer()

	if PS.ClientsideModels[ply] then
		for item_id, model in pairs(PS.ClientsideModels[ply]) do
			local ITEM = PS.Items[item_id]

			if not ITEM.Attachment and not ITEM.Bone then PS.ClientsideModel[ply][item_id] = nil continue end

			local pos = Vector()
			local ang = Angle()

			if ITEM.Attachment then
				local attach_id = self.Entity:LookupAttachment(ITEM.Attachment)
				if not attach_id then return end

				local attach = self.Entity:GetAttachment(attach_id)

				if not attach then return end

				pos = attach.Pos
				ang = attach.Ang
			else
				local bone_id = self.Entity:LookupBone(ITEM.Bone)
				if not bone_id then return end

				pos, ang = self.Entity:GetBonePosition(bone_id)
			end

			local scale, scaleMod = 1

			local oldpos, oldang = pos, Angle(ang.p, ang.y, ang.r)
			model, pos, ang, scaleMod = ITEM:ModifyClientsideModel(ply, model, pos, ang)

			local off = pos - oldpos
			pos = oldpos + (off) * scale

			local plyModel = ply:GetModel()
			if PS_ModelOffsets[plyModel] and PS_ModelOffsets[plyModel][ ITEM.OffsetType ] then
				local offset = PS_ModelOffsets[ plyModel ][ ITEM.OffsetType ]
				scale = scale * offset[2]
				pos = pos + (oldang:Right() * offset[1].x + oldang:Forward() * offset[1].y + oldang:Up() * offset[1].z) * scale
			end

			model:SetPos(pos)
			model:SetAngles(ang)
			if scaleMod then scale = scale * scaleMod end
			model:SetModelScale( scale )

			if PS.HoverModel then
				if not FindEqualSlots(PS.HoverModel, item_id) then
					model:DrawModel()
				else
					model:SetNoDraw(true)
				end
			else
				model:DrawModel()
			end
		end
	end

	if PS.HoverModel then
		local ITEM = PS.Items[PS.HoverModel]

		if ITEM.NoPreview then return end -- don't show
		if ITEM.WeaponClass and not ITEM.Model then return end -- hack for weapons WHY!?

		if not ITEM.Attachment and not ITEM.Bone then -- must be a playermodel?
			if ITEM.Models then
				local amount = #ITEM.Models
				local curID = math.ceil( CurTime() * 2 ) % amount + 1
				self:SetModel( ITEM.Models[curID][1] )
				self.Entity:SetSkin( ITEM.Models[curID][2] )
			else
				self:SetModel(ITEM.Model)
				if ITEM.Skin then self.Entity:SetSkin(ITEM.Skin) end
			end
		else
			local model = PS.HoverModelClientsideModel

			local pos = Vector()
			local ang = Angle()

			if ITEM.Attachment then
				local attach_id = self.Entity:LookupAttachment(ITEM.Attachment)
				if not attach_id then return end

				local attach = self.Entity:GetAttachment(attach_id)

				if not attach then return end

				pos = attach.Pos
				ang = attach.Ang
			else
				local bone_id = self.Entity:LookupBone(ITEM.Bone)
				if not bone_id then return end

				pos, ang = self.Entity:GetBonePosition(bone_id)
			end

			local scale, scaleMod = 1

			local oldpos, oldang = pos, Angle(ang.p, ang.y, ang.r)
			model, pos, ang, scaleMod = ITEM:ModifyClientsideModel(ply, model, pos, ang)

			local off = pos - oldpos
			pos = oldpos + (off) * scale

			local plyModel = ply:GetModel()
			if PS_ModelOffsets[plyModel] and PS_ModelOffsets[plyModel][ ITEM.OffsetType ] then
				local offset = PS_ModelOffsets[ plyModel ][ ITEM.OffsetType ]
				scale = scale * offset[2]
				pos = pos + (oldang:Right() * offset[1].x + oldang:Forward() * offset[1].y + oldang:Up() * offset[1].z) * scale
			end

			if ITEM.Skin then model:SetSkin(ITEM.Skin) end

			model:SetPos(pos)
			model:SetAngles(ang)
			if scaleMod then scale = scale * scaleMod end
			model:SetModelScale( scale )

			model:DrawModel()
		end
	else
		self:SetModel(LocalPlayer():GetModel())
		self.Entity:SetSkin(LocalPlayer():GetSkin())
	end
end

vgui.Register('DPointShopPreview', PANEL, 'DModelPanel')

--addons/module_donate/lua/pointshop/vgui/dpointshopgivepoints.lua:
local PANEL = {}

function PANEL:Init()
	self:SetTitle("Дать "..PS.Config.PointsName)
	self:SetSize(300, 194)

	self:SetDeleteOnClose(true)
	self:SetBackgroundBlur(true)
	self:SetDrawOnTop(true)

	local l1 = vgui.Create("DLabel", self)
	l1:SetText("Игрок:")
	l1:Dock(TOP)
	l1:DockMargin(4, 0, 4, 4)
	l1:SizeToContents()

	local pselect = vgui.Create("DComboBox", self)
	pselect:SetValue("Выбери игрока")
	pselect:SetTall(24)
	pselect:Dock(TOP)
	self.playerselect = pselect

	self:FillPlayers()

	local l2 = vgui.Create("DLabel", self)
	l2:SetText("Ты отдашь:")
	l2:Dock(TOP)
	l2:DockMargin(4, 2, 4, 4)
	l2:SizeToContents()

	local pointsSelf = vgui.Create("DNumberWang", self)
	pointsSelf:SetTextColor( Color(0, 0, 0, 255) )
	pointsSelf:SetTall(24)
	pointsSelf:Dock(TOP)
    self.pselector = pointsSelf

	local l3 = vgui.Create("DLabel", self)
	l3:SetText("Игрок получит (с комиссией):")
	l3:Dock(TOP)
	l3:DockMargin(4, 2, 4, 4)
	l3:SizeToContents()

	local pointsPlayer = vgui.Create("DNumberWang", self)
	pointsPlayer:SetTextColor( Color(0, 0, 0, 255) )
	pointsPlayer:SetTall(24)
	pointsPlayer:Dock(TOP)

	local btnlist = vgui.Create("DPanel", self)
	btnlist:SetDrawBackground(false)
	btnlist:DockMargin(0, 5, 0, 0)
	btnlist:Dock(BOTTOM)

	local cancel = vgui.Create('DButton', btnlist)
	cancel:SetText('Отмена')
	cancel:DockMargin(4, 0, 0, 0)
	cancel:Dock(RIGHT)
	self.cancel = cancel

	local done = vgui.Create('DButton', btnlist)
	done:SetText('Отправить')
	done:SetDisabled(true)
	done:DockMargin(0, 0, 4, 0)
	done:Dock(RIGHT)
	self.submit = done

	self.selected_uid = nil
	pselect.OnSelect = function( s, idx, val, data )
		if data then self.selected_uid = data end

		self:Update()
	end

	pointsSelf.OnValueChanged = function(s, val)
		pointsPlayer:SetText(math.Round(val*(1-PS.Config.Comission), 2))
		self:Update()
	end

	pointsPlayer.OnValueChanged = function(s, val)
		pointsSelf:SetText(math.Round(val/(1-PS.Config.Comission), 2))
		self:Update()
	end

	done.DoClick = function()
		self:Submit()
		self:Close()
	end

	cancel.DoClick = function()
		self:Close()
	end

	self:Center()
	self:MakePopup()
end

function PANEL:FillPlayers()
	for _, ply in player.Iterator() do
		if ply == LocalPlayer() then continue end

		self.playerselect:AddChoice(ply:Nick(), ply:UniqueID())
	end
end

function PANEL:Submit()
	local other = false

	for _, ply in player.Iterator() do
		if tonumber(ply:UniqueID()) == tonumber(self.selected_uid) then
			other = ply
		end
	end

	if not other then return end -- player could have left

	net.Start('PS_SendPoints')
		net.WriteEntity(other)
		net.WriteFloat(tonumber(self.pselector:GetValue()))
	net.SendToServer()
end

function PANEL:Update()
	local disabled = false

	if not self.selected_uid then disabled = true end

	if (self.pselector:GetValue() < 1) or (self.pselector:GetValue() > LocalPlayer():PS_GetPoints()) then
		disabled = true
		self.pselector:SetTextColor(Color(180, 0, 0, 255))
	else
		self.pselector:SetTextColor(Color(0, 0, 0, 255))
	end

	self.submit:SetDisabled(disabled)
end

vgui.Register('DPointShopGivePoints', PANEL, 'DFrame')

--addons/module_donate/lua/pointshop/vgui/dpointshopcasespin.lua:
local color_line = Color(244, 129, 0, 150)
local dollarImage = 'data/wimages/moneybox.png'
local rubleImage = 'data/wimages/gem.png'
local PANEL = {}

function PANEL:Paint(w, h)
    draw.RoundedBox(0, 0, 0, w, h, Color(32, 36, 40))
end

function PANEL:SetCase(data, case, s, e)
    self.data = data
    self.case = case
    self.Speed = s
    self.EndPoint = e
    self.isSpinning = true

    -- Скип :/
    if not IsValid(self.skip) then
        self.skip = vgui.Create('DButton', self)
        self.skip:SetText('Пропустить')
        self.skip:SetIcon('icon72/x.png')
        self.skip:SetSize(200, 25)
        self.skip:SetPos(self:GetWide() / 2 - 100, 260)

        self.skip.DoClick = function()
            if self.Speed < self.EndPoint + 100 then return end
            net.Start('FinishedUnbox')
            net.SendToServer()
            surface.PlaySound('buttons/lever6.wav')
            self.main:SetVisible(false)
        end
    end

    if self.Items then
        for k, v in pairs(self.Items) do
            v.panel:Remove()
            v.modelView:Remove()
        end
    end

    self.Items = {}

    for i = 0, 99 do
        local item = {}
        item.xPos = ((((280 + 10) * i) * -1) + ((280 + 10) / 2)) - 80
        item.panel = vgui.Create('DPanel', self)
        item.panel.id = i
        item.panel.item = self.data[i]
        item.panel:SetPos(((((280 + 10) * i) * -1) + ((280 + 10) / 2)) - 55, 10)
        item.panel:SetSize(280, 240)

        item.panel.Paint = function(self, w, h)
            draw.RoundedBox(0, 0, 0, w, h, Color(20, 20, 20))
            draw.RoundedBox(0, 0, h - 40, w, 40, self.item.itemColor)
            draw.SimpleText(self.item.itemName or 'Итем ошибка...', 'SpinFont', 5, 205, Color(255, 255, 255))
        end

        if self.data[i].Type == "POINTS" then
            item.modelView = vgui.Create("DImage", item.panel)
            item.modelView:SetSize(190, 190)
            item.modelView:SetPos(40, 0)
            item.modelView:SetImage(rubleImage)
        elseif self.data[i].Type == "MONEY" then
            item.modelView = vgui.Create("DImage", item.panel)
            item.modelView:SetSize(190, 190)
            item.modelView:SetPos(40, 0)
            item.modelView:SetImage(dollarImage)
        else
            item.modelView = vgui.Create("DImage", item.panel)
            item.modelView:SetSize(190, 190)
            item.modelView:SetPos(40, 0)
            item.modelView:SetImage(item.panel.item.itemModel)
        end

        self.Items[i] = item
    end

    if not IsValid(self.Line) then
        self.Line = vgui.Create("Panel", self)
        self.Line:SetSize(4, 250)
        self.Line:SetPos(self:GetWide() / 2 - 2, 0)

        self.Line.Paint = function(self, w, h)
            draw.RoundedBox(0, w / 2 - 2, 0, 4, h, Color(244, 129, 0, 150))
        end
    end

    self.Line:SetZPos(100)
end

local prevItemValue = 0

function PANEL:Think()
    if self.isSpinning then
        if not self.Items then return end
        self.Speed = Lerp(0.4 * FrameTime(), self.Speed, self.EndPoint)

        if math.floor(self.Speed / (280 + 10)) ~= prevItemValue then
            LocalPlayer():EmitSound("common/talk.wav")
        end

        for k, v in pairs(self.Items) do
            v.panel:SetPos(v.xPos + self.Speed, 10)
        end

        if self.Speed < self.EndPoint + 10 then
            self.isSpinning = false
            net.Start('FinishedUnbox')
            net.SendToServer()
            surface.PlaySound('buttons/lever6.wav')
            self:SetVisible(false)
            self.main:SetVisible(false)
        end

        prevItemValue = math.floor(self.Speed / (280 + 10))
    end
end

vgui.Register('DPointShopCaseSpin', PANEL, 'DPanel')
--addons/module_donate/lua/pointshop/items/cases/case_halloween.lua:
ITEM.Name = 'Хэллоуин Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Компаньон череп"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_halloween.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_halloween')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_invalid.lua:
ITEM.Name = 'Сломанный кейс'
ITEM.Price = 59
ITEM.Description = "~directive = KILL while enemies = PRESENT: execute(directive)~\n\nЧто можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- Компаньон мясорубка\n- Компаньон плазмоган\n- OUTBREAK PERFECTED"
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_invalid.jpg'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_invalid')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_newyear.lua:
ITEM.Name = 'Новогодний Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Компаньон снеговик"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_newyear.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true
function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_newyear')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_points.lua:
ITEM.Name = 'Рублевый Кейс'
ITEM.Description = "Что можно выбить? \n- 5 донат рублей\n- 15 донат рублей\n- 25 донат рублей\n- 50 донат рублей\n- 100 донат рублей\n- 250 донат рублей\n- 500 донат рублей\n- 1000 донат рублей\n- 1500 донат рублей"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_points.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_points.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_points')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_snow.lua:
ITEM.Name = 'Снежный Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- Обложка дух нового года\n- Обложка теплый свитер\n- 100 рублей\n- 200 рублей\n- Huckleberry"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_snow.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
ITEM.Hidden = false

function ITEM:OnUse(ply)
	ply:OpenCrate('case_snow')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/__category.lua:
CATEGORY.Name = 'Компаньоны'
CATEGORY.Icon = 'ghost'
CATEGORY.AllowedEquipped = 1
CATEGORY.Order = 11
--addons/module_donate/lua/pointshop/items/companions/camera.lua:
ITEM.Name = 'Камера'
ITEM.Price = 299
ITEM.Model = 'models/maxofs2d/camera.mdl'
--ITEM.Material = Material( "data/wimages/bomb.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/camera.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)

	if SERVER then
		local tid = ply:SteamID64().."_camera_comp"
		timer.Create(tid, 60, 0, function()
			if not IsValid(ply) then return timer.Remove(tid) end
			ply:EmitSound( "NPC_CScanner.TakePhoto" )
		end)
	end
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
	if SERVER then timer.Destroy(ply:SteamID64().."_camera_comp") end
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
--	plyAng.z = plyAng.z + 90	
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/death.lua:
ITEM.Name = 'Смерть'
ITEM.Price = 999
ITEM.Model = 'models/roblox/ghost_of_the_week__lil_reaper.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/death.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:CanPlayerSell(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = ply:EyePos(), ply:EyeAngles()
	plyAng.y = plyAng.y + 180
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end
--addons/module_donate/lua/pointshop/items/companions/ghost.lua:
ITEM.Name = 'Призрак'
ITEM.Price = 999
ITEM.Model = 'models/roblox/ghostly_pursuit.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/ghost.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:CanPlayerSell(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = ply:EyePos(), ply:EyeAngles()
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/meatgrinder.lua:
ITEM.Name = 'Мясорубка'
ITEM.Price = 199
ITEM.Model = 'models/props_c17/grinderclamp01a.mdl'
--ITEM.Material = Material( "data/wimages/mossman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/meat.jpg'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/mossman.lua:
ITEM.Name = 'Моссман'
ITEM.Price = 199
ITEM.Model = 'models/maxofs2d/balloon_mossman.mdl'
--ITEM.Material = Material( "data/wimages/mossman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/mossman.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/snowhead.lua:
ITEM.Name = 'Снеговик ( Новый Год )'
ITEM.Price = 349
ITEM.Model = 'models/props/cs_office/snowman_face.mdl'
--ITEM.Material = Material( "data/wimages/snowman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/snowman.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/__category.lua:
CATEGORY.Name = 'Обложки'
CATEGORY.Icon = 'frame_photo'
CATEGORY.AllowedEquipped = 1
CATEGORY.Order = 12

if CLIENT then
    hook.Add('PS_UpdatedClientsideInfo', 'covers', function(ply)
        ply.ProfileCover = nil
        for id, v in pairs(ply.PS_Items or {}) do
            local item = PS.Items[id] or {}
            if v.Equipped and item.Category == 'Обложки' then
                ply.ProfileCover = item.Cover
                break
            end
        end
    end)
end
--addons/module_donate/lua/pointshop/items/cover/cover_cat.lua:
ITEM.Name = 'Пушистое облако'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_cat.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_cat.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_drive.lua:
ITEM.Name = 'На драйве'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_drive.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_drive.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_halloween.lua:
ITEM.Name = 'Тыквенный переполох'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_halloween.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_halloween.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_homelander.lua:
ITEM.Name = 'Гнев твердыни'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_homelander.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_homelander.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_katana.lua:
ITEM.Name = 'Благодать катаны'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_katana.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_katana.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_outbreak.lua:
ITEM.Name = 'Могущество прорыва'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_outbreak.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_outbreak.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_stone.lua:
ITEM.Name = 'Каменная гряда'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_stone.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_stone.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/other/govorilka.lua:
ITEM.Name = 'Говорилка на месяц'
ITEM.Description = 'Озвучивает весь написанный текст вслух!'
ITEM.Price = 49
--ITEM.Material =  Material( "data/wimages/microphone.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/microphone.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30

ITEM.Voices = {
	alyss = {
        name = 'Алиса (Ж)',
    },
	oksana = {
        name = 'Оксана (Ж)',
    },
	jane = {
        name = 'Джейн (Ж)',
    },
	omazh = {
        name = 'Оммаж (Ж)',
    },
	zahar = {
        name = 'Захар (М)',
    },
	ermil = {
        name = 'Эрмиль (М)',
    },
    google = {
        name = 'Гуглесса (Ж)',
        url = 'https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q={text}&tl=ru',
    },
}

local char_to_hex = function(c)
    return string.format("%%%02X", string.byte(c))
end

local function urlencode(url)
    if url == nil then
    return
    end
    url = url:gsub("\n", "\r\n")
    url = url:gsub("([^%w ])", char_to_hex)
    url = url:gsub(" ", "+")
    return url
end

local lowqual = CreateClientConVar('wrp_govorilka_lowquality', '0', true)

function ITEM:GetURL(voice, text)
    if not self.Voices[voice] then return end

    local url = self.Voices[voice].url or 'http://tts.voicetech.yandex.net/tts?speaker={voice}&text={text}&quality={quality}'
    url = string.Replace(url, '{voice}', voice)
    url = string.Replace(url, '{text}', urlencode(text))
    url = string.Replace(url, '{quality}', lowqual:GetBool() and 'lo' or 'hi')

    return url
end

function ITEM:OnEquip(ply, modifications)
    if not modifications or not modifications.voice then
        ply:PS_ModifyItem(self.ID, {voice = 'zahar'})

        ply:PS_Notify('Ты можешь изменить голос говорилки')
        ply:PS_Notify('Для этого нажми на нее в магазине и выбери "Изменить..."')
    end
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'voice' then return false, 'Куда ты лезешь?' end
    end

    return self.Voices[modifications.voice] or false
end

ITEM.Samples = {
	'Я в своем познании настолько преисполнился, что я как будто бы уже сто триллионов миллиардов лет проживаю на триллионах и триллионах таких же планет, как эта Земля',
	'Эх, как же хочется тяночку, худенькую, бледную, не очень высокую',
	'Нужно построить Зиккурат',
	'Купил как-то мужик шляпу, а она ему как раз!',
	'Идет медведь по лесу, видит, машина горит. Сел в нее и сгорел',
	
	'Помогите, он держит меня в заложниках и заставляет делать аддоны для гаррис мода. Я не видел солнечного света уже 2 года!',
}

local curplaying
function ITEM:Modify(modifications)
    local frame = vgui.Create('DFrame')
    frame:SetSize(300, 100)
    frame:SetTitle('Изменение голоса')
    frame:MakePopup()
    frame:Center()
    frame:SetDraggable(false)
    frame:SetBackgroundBlur(true)
    frame:SetDrawOnTop(true)

    local pnl = vgui.Create('DPanel', frame)
    pnl:SetPaintBackground(false)
    pnl:Dock(TOP)
    pnl:DockMargin(0,4,0,0)
    pnl:SetTall(25)

    pnl:InvalidateParent(true)

    local combo = vgui.Create('DComboBox', pnl)
    combo:Dock(LEFT)
    combo:SetWide(pnl:GetWide() - 30)

    for k, v in pairs(self.Voices) do
        combo:AddChoice(v.name, k, modifications and modifications.voice == k)
    end

    local play = vgui.Create('DImageButton', pnl)
    play:Dock(RIGHT)
    play:SetSize(24, 24)
    play:SetImage('icon16/sound.png')
    play.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())
        
        local text = math.random(1, 100) <= 5 and self.Samples[#self.Samples] or self.Samples[math.random(1, #self.Samples-1)]
        
        if IsValid(curplaying) then curplaying:Stop() end
	
        sound.PlayURL(self:GetURL(voice, text), 'mono', function(station, errorId, errorName)
            if IsValid(station) then
                curplaying = station
                curplaying:Play()
            end
        end)
    end

    local submit = vgui.Create('DButton', frame)
    submit:Dock(BOTTOM)
    submit:SetText('Готово')
    submit:SetTall(25)
    submit:SetImage('icon16/accept.png')

    submit.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())

        if self.Voices[voice] then
            PS:SendModifications(self.ID, {voice = voice})
        else
            notification.AddLegacy('Ты не выбрал голос', 1, 5)
        end
        
        frame:Close()
    end
end

-- говорилка

if CLIENT then
    function govorilka(voice, text, data, cb)
        local url = PS.Items['govorilka']:GetURL(voice, text)
        if not url then return end

        sound.PlayURL(url, data.flags or '', function(station, errorId, errorName)
            if IsValid(station) then
                if data.pos then station:SetPos(data.pos) end
                if data.dist then station:Set3DFadeDistance(150, data.dist) end
                station:SetVolume(data.volume or 1)
                station:Play()
            end
            if cb then cb(station, errorId, errorName) end
        end)
    end

    local whitelist = {
        ['крик'] = {
            flags = '3d',
            dist = 550,
        },
        ['шепот'] = {
            flags = '3d',
            dist = 90,
        },
        ['Громкоговоритель'] = {
            flags = '3d',
            dist = 1200,
        },
        ['Рация'] = {
            flags = 'mono',
        },
        ['Телефон'] = {
            flags = 'mono',
        },
        ['Вещание!'] = {
            flags = 'mono',
        }
    }

    hook.Add('OnPlayerChat', 'ps_govorilka', function(ply, text, team, dead, prefix)
        if not IsValid(ply) or team or dead or not prefix then return end

        if ply:Team() == TEAM_BANNED then return end

        if not ply:PS_HasItemEquipped('govorilka') and not ply:PS_HasItemEquipped('govorilka_navsegda') then return end
        local voice = (ply.PS_Items['govorilka'] or ply.PS_Items['govorilka_navsegda']).Modifiers.voice
        if not voice then return end
        
        local nameStart, nameEnd = prefix:find(ply:Name(), 1, true)
        if not nameStart then return end
        prefix = prefix:sub(1, nameStart-1) .. prefix:sub(nameEnd+1)
        
        local cmd = prefix:match('[%[%(](.+)[%]%)]')
        
        local flags = prefix == '' and (ply == LocalPlayer() and 'mono' or '3d') or (whitelist[cmd] and whitelist[cmd].flags)
        if not flags then return end

        local dist = whitelist[cmd] and whitelist[cmd].dist or 250

        govorilka(voice, utf8.sub(text, 1, 128), {
            flags = flags,
            dist = dist,
            pos = ply:GetPos(),
        }, function(sound)
            if IsValid(ply) then ply.sound = station end
        end)
    end)

    timer.Create('govorilka_followsound', 0.5, 0, function()
        for _, v in player.Iterator() do
            if IsValid(v.sound) then
                v.sound:SetPos(v:GetPos())
            end
        end
    end)
end
--addons/module_donate/lua/pointshop/items/other/outfit_bear.lua:
ITEM.Name = 'Медведь за спиной'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Model = 'models/roblox_assets/polar_bear_shoulder_friend.mdl'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.Hidden = true
ITEM.NoScroll = true
--ITEM.Job = {['citizen'] = true, ['chocmaker'] = true, ['miners'] = true, ['samogon'] = true, ['bar'] = true, ['gundealer'] = true}
--ITEM.NoDrawDisguise = false

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 5)
	ang:RotateAroundAxis(ang:Up(), -90)
	ang:RotateAroundAxis(ang:Forward(), -90)
	
	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/ranks/curator_1m.lua:
ITEM.Name = 'Curator на 1 месяц'
ITEM.Description = "- Имеет все привилегии VIP\n- Имеет все привилегии DModerator\n- Имеет все привилегии DAdmin\n- Имеет все привилегии DSAdmin\n-Имеет доступ к наборной системе жалоб\n- Иммунитет от хелперов\n- Имеет доступ к админ меню наборной администрации\n- Может установить себе размер\n- Может установить себе модель любого предмета\n- Имеет доступ к ивент меню \n- Может скринить экраны игроков \n- При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 499
--ITEM.Material = Material( "data/wimages/curator_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/curator_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Curator"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dadmin_1m.lua:
ITEM.Name = 'DAdmin на месяц'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования \n - Может заморозить игрока \n - Может выдавать оружие \n - Может поджечь игрока \n - Может дать регдолл игроку"
ITEM.Price = 199
--ITEM.Material = Material( "data/wimages/admin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/admin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DAdmin"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dmoderator_1m.lua:
ITEM.Name = 'DModerator на месяц'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/moder_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moder_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DModerator"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dsadmin_1m.lua:
ITEM.Name = 'DSAdmin на месяц'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет все привилегии DAdmin \n Доступ к спавну через Q меню, оружия, энтити, транспорта, но только из категории Разрешено \n - При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 299
--ITEM.Material = Material( "data/wimages/dsadmin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DSAdmin"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/bowie_knife.lua:
ITEM.Name = 'Нож Bowie'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_bowie"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/butterfly_knife.lua:
ITEM.Name = 'Нож Бабочка'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_butterfly"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/cyberitem.lua:
ITEM.Name = 'CYBER PACK на месяц'
ITEM.Description = "Набор из двух Кибер предметов, включая Ховерборды и оружие Laser Gun с помощью которого можно летать.\nНикто включая администрацию не способен выдать эти предметы, они не выпадают после вашей смерти."
ITEM.Price = 249
--ITEM.Material = Material( "data/wimages/cyberpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cyberpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
ITEM.WeaponClass = "laserjetpack"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'color' then return false, 'Куда ты лезешь?' end
    end
    return true 
end

function ITEM:Modify(modifications)
    PS:ShowColorChooser(self, modifications)
end
--addons/module_donate/lua/pointshop/items/weapons/magnun_hl2.lua:
ITEM.Name = 'Магнум навсегда'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 149
--ITEM.Material = Material( "data/wimages/magnum.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/magnum.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "ptp_cs_357"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/talon_knife.lua:
ITEM.Name = 'Нож Talon'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_talon"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/weapon_spawn.lua:
ITEM.Name = 'Спавн оружия через Q меню на месяц'
ITEM.Description = "Ты получаешь возможность спавнить оружия из Q меню, ТОЛЬКО из вкладки РАЗРЕШЕНОЕ"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/weapon.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/weapon.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_rewards/lua/rewards/sh_init.lua:
rewards.config = {
    api_endpoint = 'https://api.wayzer.ru/',
}
--addons/module_rewards/lua/rewards/methods/discord/client.lua:
function rewards.methods.discord:Link()
    net.Start('rewards.linkMethod')
    net.WriteString('discord')
    net.SendToServer()
end

function rewards.methods.discord:Update(data, card)
    http.Fetch(rewards.config.api_endpoint..'/discord/getme.php?access_token='..data.data.access_token, function(b)
        local res = util.JSONToTable(b)
        if not res then return end

        if res.avatar then
            rewards.imageURL(rewards.config.api_endpoint..'/discord/avatar.php?id='..data.id..'&avatar='..res.avatar, 'discordavatar.png', function(img)
                if not IsValid(card) then return end
                card:SetImage(img)
            end)
        end
    end)

    if data.received then
        card:SetText('Награда получена')
        card:SetTextColor(Color(200,200,200))
		card:SetButtonText('Получено')
        card:SetCallback(wlib.func.blank)
    else
        card:SetButtonText('Проверить вступление')
        card:SetTextColor(color_black)
        card:SetCallback(function()
            net.Start('rewards.getInfo')
            net.SendToServer()
        end)
    end
end
--addons/module_rewards/lua/rewards/methods/telegram/client.lua:
function rewards.methods.telegram:Link()
    net.Start('rewards.linkMethod')
    net.WriteString('telegram')
    net.SendToServer()
end

function rewards.methods.telegram:Update(data, card)
    rewards.imageURL(data.data.photo_url, 'telegramavatar.png', function(img)
        if not IsValid(card) then return end
        card:SetImage(img)
    end)
    
    if data.received then
        card:SetText('Награда получена')
        card:SetTextColor(Color(200,200,200))
		card:SetButtonText('Получено')
        card:SetCallback(wlib.func.blank)
    else
        card:SetButtonText('Проверить подписку')
        card:SetTextColor(color_black)
        card:SetCallback(function()
            net.Start('rewards.getInfo')
            net.SendToServer()
        end)
    end
end
--addons/module_rewards/lua/rewards/methods/telegram/shared.lua:
rewards.methods.telegram.name = 'Канал в Telegram'
rewards.methods.telegram.reward_text = '$50.000 и 15₽'
rewards.methods.telegram.link_text = 'Привязать'
rewards.methods.telegram.restricted = false
--addons/module_rewards/lua/rewards/methods/vk/shared.lua:
rewards.methods.vk.name = 'Группа в ВК'
rewards.methods.vk.reward_text = '$50.000 и 15₽'
rewards.methods.vk.link_text = 'Привязать'
rewards.methods.vk.restricted = false
--addons/module_disguise/lua/autorun/sh.lua:
if SERVER then 
    AddCSLuaFile() 
    include('autorun/server/hook.lua')
    AddCSLuaFile('autorun/client/frame.lua')
end

if CLIENT then 
    include('autorun/client/frame.lua')
end

DISGUISE_KIT_TIME = 300
DISGUISE_KIT_COOLDOWN = 300
DISGUISE_DEFAULT_CHAT = true -- Set this to false if you are not using the default chat system

nw.Register 'disguise_team'
    :Write(net.WriteUInt, 16)
    :Read(net.ReadUInt, 16)
    :SetPlayer()
    
nw.Register 'disguised'
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()

nw.Register 'last_disguise'
    :Write(net.WriteUInt, 32)
    :Read(net.ReadUInt, 32)
    :SetPlayer()
--addons/module_donate/lua/pointshop/items/cases/case_defender.lua:
ITEM.Name = 'Защищенный Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Тычковые ножи"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_defender.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_defender')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_gzt.lua:
ITEM.Name = 'Откалиброванный кейс'
ITEM.Description = [[
Что можно выбить?

Curator на 3 месяц x3
DSAdmin на 3 месяца x3
DSAdmin на месяц x3
DAdmin на 3 месяца x3
DModerator на 3 месяца x5
DModerator на месяц x5
VIP навсегда x3
VIP на 3 месяца x50
VIP на месяц x100
VIP на 15 дней x150
Двойной прыжок на месяц x30
Спавн Entity через Q меню на месяц x25
Спавн оружия через Q меню на месяц x25
Магнум навсегда x30
HL2 Станстик навсегда x30
Smart Pistol на месяц x10
CYBER PACK на месяц x10
Говорилка на месяц x30
Вовозелка на месяц x10
Своя модель на месяц x15]]

ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_gzt.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end

function ITEM:OnUse(ply)
	ply:OpenCrate('case_gzt')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_invalid.lua:
ITEM.Name = 'Сломанный кейс'
ITEM.Price = 59
ITEM.Description = "~directive = KILL while enemies = PRESENT: execute(directive)~\n\nЧто можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- Компаньон мясорубка\n- Компаньон плазмоган\n- OUTBREAK PERFECTED"
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_invalid.jpg'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_invalid')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_newyear.lua:
ITEM.Name = 'Новогодний Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Компаньон снеговик"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_newyear.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true
function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_newyear')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_spaceday.lua:
ITEM.Name = 'Космический Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Компаньон космическое устройство"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_spaceday.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_spaceday')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_spider.lua:
ITEM.Name = 'Жуткий Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- Обложка могильный мрак\n- Обложка тыквенный переполох\n- Компаньон призрак\n- Компаньон смерть\n- Пистолет Crimson"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_spider.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
ITEM.Hidden = false

function ITEM:OnUse(ply)
	ply:OpenCrate('case_spider')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/camera.lua:
ITEM.Name = 'Камера'
ITEM.Price = 299
ITEM.Model = 'models/maxofs2d/camera.mdl'
--ITEM.Material = Material( "data/wimages/bomb.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/camera.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)

	if SERVER then
		local tid = ply:SteamID64().."_camera_comp"
		timer.Create(tid, 60, 0, function()
			if not IsValid(ply) then return timer.Remove(tid) end
			ply:EmitSound( "NPC_CScanner.TakePhoto" )
		end)
	end
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
	if SERVER then timer.Destroy(ply:SteamID64().."_camera_comp") end
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
--	plyAng.z = plyAng.z + 90	
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/__category.lua:
CATEGORY.Name = 'Обложки'
CATEGORY.Icon = 'frame_photo'
CATEGORY.AllowedEquipped = 1
CATEGORY.Order = 12

if CLIENT then
    hook.Add('PS_UpdatedClientsideInfo', 'covers', function(ply)
        ply.ProfileCover = nil
        for id, v in pairs(ply.PS_Items or {}) do
            local item = PS.Items[id] or {}
            if v.Equipped and item.Category == 'Обложки' then
                ply.ProfileCover = item.Cover
                break
            end
        end
    end)
end
--addons/module_donate/lua/pointshop/items/cover/cover_city.lua:
ITEM.Name = 'Вдали от города'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_city.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_city.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_drive.lua:
ITEM.Name = 'На драйве'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_drive.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_drive.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_katana.lua:
ITEM.Name = 'Благодать катаны'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_katana.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_katana.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_line.lua:
ITEM.Name = 'Абстрактные линии'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_line.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_line.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_sun.lua:
ITEM.Name = 'Над небесами'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_sun.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_sun.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_sunline.lua:
ITEM.Name = 'Луч надежды'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_sunline.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_sunline.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_toska.lua:
ITEM.Name = 'Вечная тоска'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_toska.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_toska.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/moneypacks/10kk.lua:
ITEM.Name = '10,000,000 $'
ITEM.Price = 399
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 10000000 )
end

--addons/module_donate/lua/pointshop/items/other/outfit_axe.lua:
-- только на маньяке

ITEM.Name = 'Топор за спиной'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.Model = 'models/props/cs_militia/axe.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.NoScroll = true
ITEM.Hidden = true
--ITEM.Job = {['maniak'] = true}
--ITEM.NoDrawDisguise = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 4) + (ang:Up() * 1) + (ang:Forward() * 1)
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Up(), 60)

	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/ranks/dsadmin_1m.lua:
ITEM.Name = 'DSAdmin на месяц'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет все привилегии DAdmin \n Доступ к спавну через Q меню, оружия, энтити, транспорта, но только из категории Разрешено \n - При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 299
--ITEM.Material = Material( "data/wimages/dsadmin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DSAdmin"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/patron_navsegda.lua:
ITEM.Name = 'Patron навсегда'
ITEM.Description = "*Особая привилегия*\n**Возможна выдача роли в Discord сервере**\n\n- Весь функционал наборного администратора\n- Весь функционал донатных администраторов\n- Увеличенный инвентарь до размера хранилища\n- Переливающийся ник над головой\n- Переливающийся разноцветный скин\n - Переливающийся physgun\n- Наборная модель администратора за профессию Администратор\n- Неограниченая возможность изменения личной модели из Workshop\n- Доступ ко всему запрещенному/крафтовому оружию, включая RPG и все остальное\n- Все вопросы касаемо нарушений рассматриваются высшей администрацией"
ITEM.Price = 29990
--ITEM.Material = Material( "data/wimages/patron_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/patron_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Patron"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_1m.lua:
ITEM.Name = 'VIP на месяц'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 24
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/butterfly_knife.lua:
ITEM.Name = 'Нож Бабочка'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_butterfly"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/cyberitem.lua:
ITEM.Name = 'CYBER PACK на месяц'
ITEM.Description = "Набор из двух Кибер предметов, включая Ховерборды и оружие Laser Gun с помощью которого можно летать.\nНикто включая администрацию не способен выдать эти предметы, они не выпадают после вашей смерти."
ITEM.Price = 249
--ITEM.Material = Material( "data/wimages/cyberpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cyberpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
ITEM.WeaponClass = "laserjetpack"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'color' then return false, 'Куда ты лезешь?' end
    end
    return true 
end

function ITEM:Modify(modifications)
    PS:ShowColorChooser(self, modifications)
end
--addons/module_donate/lua/pointshop/items/weapons/talon_knife.lua:
ITEM.Name = 'Нож Talon'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_talon"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/wayvape.lua:
ITEM.Name = 'WayZer Vape навсегда'
ITEM.Description = "Вейп с жижкой из логотипов сервера, ускоренно восстанавливает HP и Броню"
ITEM.Price = 149
--ITEM.Material = Material( "data/wimages/vape.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vape.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_vape_wayzer"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/wep_palka.lua:
ITEM.Name = 'HL2 Станстик навсегда'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам."
ITEM.Price = 24
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_stunstick"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/_smallscripts/lua/autorun/sh_network.lua:
hook.Add('Think', 'nw.lockdown', function()
hook.Remove('Think', 'nw.lockdown')

nw.Register 'lockdown'
	:Write(function(d)
		net.WriteString(d.title)
		net.WriteString(d.text)
		net.WriteColor(d.color, true)
		net.WriteUInt(d.start, 32)
		net.WriteUInt(IsValid(d.initiator) and d.initiator:EntIndex() or 0, 13)
	end)
	:Read(function()
		return {
			title = net.ReadString(),
			text = net.ReadString(),
			color = net.ReadColor(),
			start = net.ReadUInt(32),
			initiator = Entity(net.ReadUInt(13)),
		}
	end)
	:SetHook('LockdownUpdated')
	:SetGlobal()

--[[
nw.Register 'lockdown.started'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetGlobal()

nw.Register 'lockdown.title'
	:Write(net.WriteString)
	:Read(net.ReadString)
	:SetGlobal()
	
nw.Register 'lockdown.text'
	:Write(net.WriteString)
	:Read(net.ReadString)
	:SetGlobal()
	
nw.Register 'lockdown.color'
	:Write(net.WriteVector)
	:Read(net.ReadVector)
	:SetGlobal()
]]

nw.Register 'Energy'
	:Write(net.WriteUInt, 32)
	:Read(net.ReadUInt, 32)
	:SetLocalPlayer()

nw.Register 'job'
	:Write(net.WriteString)
	:Read(net.ReadString)
	:SetPlayer()

nw.Register 'rpname'
	:Write(net.WriteString)
	:Read(net.ReadString)
	:SetPlayer()

nw.Register 'money'
	:Write(function(val)
		net.WriteUInt64(tostring(val))
	end)
	:Read(function()
		return tonumber(net.ReadUInt64())
	end)
	:SetLocalPlayer()
	
nw.Register 'salary'
	:Write(net.WriteUInt, 32)
	:Read(net.ReadUInt, 32)
	:SetLocalPlayer()

nw.Register 'HasGunlicense'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetPlayer()

nw.Register 'wanted'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetPlayer()

nw.Register 'wantedReason'
	:Write(net.WriteString)
	:Read(net.ReadString)
	:SetPlayer()

nw.Register 'Arrested'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetPlayer()

nw.Register 'hitTarget'
	:Write(net.WriteEntity)
	:Read(net.ReadEntity)
	:SetPlayer()

nw.Register 'agenda'
	:Write(net.WriteString)
	:Read(net.ReadString)
	:SetPlayer()
	
end)
--addons/weapon_vape/lua/autorun/sh_vapeswep.lua:
-- autorun/client/cl_vapeswep.lua
-- Defines shared globals for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/


--override Entity:SetMaterial to make sure vape shows for ponies
meta = FindMetaTable("Entity")
if meta.VapeOrigSetMaterial == nil then
	meta.VapeOrigSetMaterial = meta.SetMaterial
	meta.SetMaterial = function(self, materialName, forceMaterial)
		if self:GetClass():sub(1,11)=="weapon_vape" and materialName=="Models/effects/vol_light001" then return end
		self:VapeOrigSetMaterial(materialName, forceMaterial)
	end
end
--addons/module_weed/lua/autorun/sh_weed_config.lua:
    WEED_CONFIG = {}
--Only enable this in case gonzo asks it
WEED_CONFIG.Debug = false
WEED_CONFIG.WeedSpeed = 3
--Beeper price
WEED_CONFIG.BeeperPrice = 10000
--How many weed does give a vial
WEED_CONFIG.VialAmount = 15
--Destroyable? greater than 0 to make stuff destroyable
WEED_CONFIG.ItemsHealth = 50
--Seconds between taking battery
WEED_CONFIG.LampDrain = 5
--How many water do we loss
WEED_CONFIG.WaterLoss = {1, 5}
--Every time weed grows, we have a chance to loss water, what's that chance
WEED_CONFIG.WaterLossChance = 70
--Waterizer power
WEED_CONFIG.WaterEffectiveness = 3
--How many seconds until tank gets 1%
WEED_CONFIG.WaterSourceSpeed = 0.25
--How many buckets can you load
WEED_CONFIG.WaterSourceBuckets = 50
--Charger reload rate
WEED_CONFIG.ReloadRate = 1
--Provider's tablet price
WEED_CONFIG.TabletPrice = 15000
--Weed can purchase? //DISABLED BECAUSE POSSIBLE BAD USAGE/EXPLOIT
WEED_CONFIG.WeedPurchase = false
--Weed price -> Quantity
WEED_CONFIG.QuantityPrice = 0.75
--Weed price -> Quality
WEED_CONFIG.QualityPrice = 2
--Wweed price -> Sell
WEED_CONFIG.SellingPrice = 0.75
--Demo mode, no health and ultra fast growing
WEED_CONFIG.Demo = false

timer.Simple(1, function()
    --Jobs that CANT use this dealer
    WEED_CONFIG.AvoidJobs = {TEAM_POLICE, TEAM_CHEFPOLICE}
    WEED_CONFIG.Tablet = {TEAM_DEALER}
    --Jobs that CAN use this dealer, leave it blank so everyone can use it
    WEED_CONFIG.AbleJobs = {}
    --Give sniffers to the following jobs
    WEED_CONFIG.Sniffers = {}
    --Use group data?
    WEED_CONFIG.UseGroupData = true

    --Groups data, {groupname,how many pots according every element players can have}
    WEED_CONFIG.GroupData = {
        user = 1,
        vip = 2.5,
        supervip = 5,
        admin = 10
    }

    --Custom function to check
    --If this is true, we'll override jobs check
    WEED_CONFIG.GoesFirst = true
    --Custom function to run
    WEED_CONFIG.Check = function(s, ply) return false end --Replace this to true in case you want to let everyone that's not on the avoidjobs list to use this end

    --Can use dealer
    function WEED_CONFIG:CanDeal(ply)
        if self.GoesFirst and self:Check(ply) then
            return true
        end

        if (table.HasValue(self.AvoidJobs, ply:Team())) then return false end
        if (table.HasValue(self.AbleJobs, ply:Team()) or #self.AbleJobs == 0) then return true end

        return self:Check(ply)
    end
end)

-- фулл раскумар за столько грамм
WEED_CONFIG.AmountToRaskumar = 10
-- длительность фулл раскумара
WEED_CONFIG.Duration = 60
-- скок времени будет длиться один эффект раскумара
WEED_CONFIG.LerpTime = 10

WEED_CONFIG.Effects = {
    {
        bloom = {0.729, 0.462, 0.125},
        colormodify = {
            ["pp_colour_addr"] = 0.729,
            ["pp_colour_addg"] = 0.462,
            ["pp_colour_addb"] = 0.125,
            ["pp_colour_brightness"] = -0.3,
            ["pp_colour_contrast"] = 1,
            ["pp_colour_colour"] = 1,
            ["pp_colour_mulr"] = 0,
            ["pp_colour_mulg"] = 0,
            ["pp_colour_mulb"] = 0,
        },
    },
    {
        bloom = {0.901,  0, 0.231},
        colormodify = {

            ["pp_colour_addr"] = 0.901,
            ["pp_colour_addg"] = 0,
            ["pp_colour_addb"] = 0.231,
            ["pp_colour_brightness"] = -0.2,
            ["pp_colour_contrast"] = 1,
            ["pp_colour_colour"] = 0.8,
            ["pp_colour_mulr"] = 0,
            ["pp_colour_mulg"] = 0,
            ["pp_colour_mulb"] = 0,
        },
    },
    {
        bloom = {0.376,  0.466, 0.074},
        colormodify = {
            ["pp_colour_addr"] = 0.376,
            ["pp_colour_addg"] = 0.466,
            ["pp_colour_addb"] = 0.074,
            ["pp_colour_brightness"] = -0.3,
            ["pp_colour_contrast"] = 1,
            ["pp_colour_colour"] = 0.5,
            ["pp_colour_mulr"] = 0,
            ["pp_colour_mulg"] = 0,
            ["pp_colour_mulb"] = 0,
        },
    },
    {
        bloom = {0.752,  0.101, 1},
        colormodify = {
            ["pp_colour_addr"] = 0.752,
            ["pp_colour_addg"] = 0.101,
            ["pp_colour_addb"] = 1,
            ["pp_colour_brightness"] = -0.6,
            ["pp_colour_contrast"] = 1,
            ["pp_colour_colour"] = 0.5,
            ["pp_colour_mulr"] = 0,
            ["pp_colour_mulg"] = 0,
            ["pp_colour_mulb"] = 0,
        },
    },
    {
        bloom = {0.349,  0.501, 0},
        colormodify = {
            ["pp_colour_addr"] = 0.349,
            ["pp_colour_addg"] = 0.501,
            ["pp_colour_addb"] = 0,
            ["pp_colour_brightness"] = -0.5,
            ["pp_colour_contrast"] = 1,
            ["pp_colour_colour"] = 0.2,
            ["pp_colour_mulr"] = 0,
            ["pp_colour_mulg"] = 0,
            ["pp_colour_mulb"] = 0,
        },
    },
    {
        bloom = {0.729,  0.125, 0.211},
        colormodify = {

            ["pp_colour_addr"] = 0.729,
            ["pp_colour_addg"] = 0.125,
            ["pp_colour_addb"] = 0.211,
            ["pp_colour_brightness"] = -0.5,
            ["pp_colour_contrast"] = 1,
            ["pp_colour_colour"] = 0.2,
            ["pp_colour_mulr"] = 0,
            ["pp_colour_mulg"] = 0,
            ["pp_colour_mulb"] = 0
        },
    },
    {
        bloom = {0.560,  0.050, 0.788},
        colormodify = {
            ["pp_colour_addr"] = 0.560,
            ["pp_colour_addg"] = 0.050,
            ["pp_colour_addb"] = 0.788,
            ["pp_colour_brightness"] = -0.5,
            ["pp_colour_contrast"] = 1,
            ["pp_colour_colour"] = 0.2,
            ["pp_colour_mulr"] = 0,
            ["pp_colour_mulg"] = 0,
            ["pp_colour_mulb"] = 0
        },
    },
}
--addons/module_weed/lua/autorun/sh_weed_items.lua:

WEED_ITEMS = {}

WEED_ITEMS.__index = __index
WEED_ITEMS.Items = {}

if SERVER then
  util.AddNetworkString("PurchaseItem")
end

function WEED_ITEMS:Add(item,data)
  if(self.Items[data.category or "Pots"] == nil) then
    self.Items[data.category or "Pots"] = {}
  end
  self.Items[data.category or "Pots"][item] = data
end

function WEED_ITEMS:Purchase(who,item)
  local f = false
  for k,v in pairs(self.Items) do
    for a,j in pairs(v) do
      if(a==item) then
        if(who:GetNetVar("money") >= j.price) then
          if(WEED_CONFIG.UseGroupData && (j.max or 0) > 0) then
              local user = WEED_CONFIG.GroupData[who:GetUserGroup()] or 1
              if(who.Pots == nil) then
                who.Pots = {}
              end
              if(who.Pots[a] == nil) then
                who.Pots[a] = 1
              else
                if(who.Pots[a] < (j.max or 0)*user) then
                  who.Pots[a] = who.Pots[a] + 1
                else
                  DarkRP.notify(who, 1, 3, "Достигнут лимит")
                  return
                end
              end
          end
          if(j.ent != nil) then

            local trace = {}
            trace.start = who:EyePos()
            trace.endpos = trace.start + who:GetAimVector() * 85
            trace.filter = who

            local tr = util.TraceLine(trace)

            local ent = ents.Create(j.ent)
            ent:SetPos(tr.HitPos)
            ent:SetAngles(Angle(0,who:EyeAngles().y,0))
            ent:Spawn()
            ent.SID = who.SID
            if(ent.Setowning_ent) then
                ent:Setowning_ent(who)
            end
            ent:CPPISetOwner(who)
            ent.weed_owner = who
            ent.Owner = who
            ent.cls = a
            if(isfunction(j.purchase)) then
              j:purchase(ent)
            end
          end
          if(j.wep != nil) then
            if(!who:HasWeapon(j.wep)) then
              who:Give(j.wep)
            else
              DarkRP.notify(who, 1, 3, "У тебя уже есть этот товар!")
              return
            end
          end
          who:addMoney(-j.price)
          DarkRP.notify(who, 3, 3, "Ты купил "..j.name.." за "..j.price)
        end
        f = true
        break
      end
      if(f) then
        break
      end
    end
  end
end

if SERVER then
hook.Add("EntityRemoved","RemovePotPetition",function(ent)
    if(ent.Owner != nil) then
        if(ent.Owner.Pots != nil && ent.Owner.Pots[ent.cls or ""] != nil) then
            ent.Owner.Pots[ent.cls or ""] = ent.Owner.Pots[ent.cls or ""] - 1
        end
    end
end)


end

net.Receive("PurchaseItem",function(l,ply)
  WEED_ITEMS:Purchase(ply,net.ReadString())
end)


WEED_ITEMS:Add("base_seed",{name="Amnesia Haze (1 шт)",
category="Семена",
description="Семена Amnesia Haze от Gonzo Seeds, вырасти удивительное растение с великолепным вкусом!",
price=190,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(1) end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(150,200,150))
end,
model="models/props_junk/watermelon01.mdl",
max=5})

WEED_ITEMS:Add("base_seed3",{name="Amnesia Haze (3 шт)",
category="Семена",
description="Набор Amnesia Haze",
price=75,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(1)
    for k=1,2 do
        local a = ents.Create("sent_seed")
        a:SetPos(ent:GetPos() + ent:GetUp()*24*k)
        a:Spawn()
        a:CPPISetOwner(ent.Owner)
        a:SetSeed(1)
    end
end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(150,200,150))
end,
model="models/props_junk/watermelon01.mdl",
max=5})

WEED_ITEMS:Add("water_seed",{name="Bubble Kush (1 шт)",
category="Семена",
description="Хорошие семена! Понадобится больше воды, чтобы растение не погибло. Получается качественная дурь!",
price=450,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(2) end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(255,175,100))
end,
model="models/props_junk/watermelon01.mdl",
max=5})

WEED_ITEMS:Add("water_seed3",{name="Bubble Kush (3 шт)",
category="Семена",
description="Набор Bubble Kush",
price=400*3,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(2)
    for k=1,2 do
        local a = ents.Create("sent_seed")
        a:SetPos(ent:GetPos() + ent:GetUp()*24*k)
        a:Spawn()
        a:CPPISetOwner(ent.Owner)
        a:SetSeed(2)
    end
end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(255,175,75))
end,
model="models/props_junk/watermelon01.mdl",
max=5})

WEED_ITEMS:Add("elder_seed",{name="O.G. Kush (1 шт)",
category="Семена",
description="Этому семени требуется гораздо больше времени, чтобы вырасти, но, черт ВОЗЬМИ! Ты получишь лучшую дурь на свете, братан!",
price=750,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(3) end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(25,75,25)) end,
model="models/props_junk/watermelon01.mdl",
max=5})

WEED_ITEMS:Add("elder_seed3",{name="O.G. Kush (3 шт)",
category="Семена",
description="Набор O.G. Kush",
price=650*3,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(3)
    for k=1,2 do
        local a = ents.Create("sent_seed")
        a:SetPos(ent:GetPos() + ent:GetUp()*24*k)
        a:Spawn()
        a:CPPISetOwner(ent.Owner)
        a:SetSeed(3)
    end
end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(25,75,25))
end,
model="models/props_junk/watermelon01.mdl",
max=5})
//76561198044940228
WEED_ITEMS:Add("quick_seed",{name="Haze Berry (1 шт)",
category="Семена",
description="Ты слишком ленивый? Возьми самые быстрые семена Haze Berry!",
price=500,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(4) end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(255,75,255)) end,
model="models/props_junk/watermelon01.mdl",
max=5})

WEED_ITEMS:Add("quick_seed3",{name="Haze Berry (3 шт)",
category="Семена",
description="Набор Haze Berry",
price=400*3,
ent="sent_seed",
purchase=function(_,ent) ent:SetSeed(4)
    for k=1,2 do
        local a = ents.Create("sent_seed")
        a:SetPos(ent:GetPos() + ent:GetUp()*24*k)
        a:Spawn()
        a:CPPISetOwner(ent.Owner)
        a:SetSeed(4)
    end
end,
draw=function(_,ent,b)
  ent:SetMaterial("models/gonzo/weed/weed")
  b:SetColor(Color(255,75,255))
end,
model="models/props_junk/watermelon01.mdl",
max=5})

--------------------------------------------------------------------------------

WEED_ITEMS:Add("plastic_pot",{name="Ведро",
category="Емкости",
description="Выглядит как обычное ведро для краски, но здесь легко могло бы вырасти растение!",
price=3000,
ispot = true,
ent="sent_pot",
purchase=function(_,ent) ent:SetPot(2) end,
model="models/gonzo/weedb/pot2.mdl",
max=7})

WEED_ITEMS:Add("stone_pot",{name="Разбитый горшок",
category="Емкости",
description="Очень прочный и может удерживать гораздо больше воды!",
price=7500,
ispot = true,
ent="sent_pot",
purchase=function(_,ent) ent:SetPot(1) end,
model="models/gonzo/weedb/pot1.mdl",
max=7})

WEED_ITEMS:Add("cool_pot",{name="Цветочный горшок",
category="Емкости",
description="Отличный сосуд для выращивания травы! Вмещает еще больше воды!!!",
price=12500,
ispot = true,
ent="sent_pot",
purchase=function(_,ent) ent:SetPot(3) end,
model="models/gonzo/weedb/pot3.mdl",
max=7})

WEED_ITEMS:Add("extra_pot",{name="Ванна",
category="Емкости",
description="Нужно вырастить сразу 3 растения? Нет проблем!",
price=125000,
ispot = true,
ent="sent_pot",
purchase=function(_,ent) ent:SetPot(4) end,
model="models/gonzo/weedb/pot4.mdl",
max=4})

-----------------------------------------------------------------------

WEED_ITEMS:Add("battery_simple",{name="Батарейка",
category="Энергия",
description="Вам нужен быстрый и одноразовый источник энергии? Попробуйте эту батарею!",
price=1500,
ent="sent_battery",
purchase=function(_,ent) ent:SetBattery(1) end,
model="models/gonzo/weedb/battery.mdl",
max=6})

WEED_ITEMS:Add("battery_rechargeable",{name="Перезаряжаемая батарея",
category="Энергия",
description="Вам нужно продолжить производство? Возьми с собой перезаряжаемую литиевую батарею.",
price=5500,
ent="sent_battery",
purchase=function(_,ent) ent:SetBattery(2) end,
model="models/gonzo/weedb/battery.mdl",
max=3})

WEED_ITEMS:Add("charger",{name="Зарядное устройство",
category="Энергия",
description="Заряжайте аккумуляторы с помощью этого устройства! *ВНИМАНИЕ! Вы можете зарядить не более 20 аккумуляторов до истечения срока действия этого устройства*",
price=15500,
ent="sent_charger",
model="models/gonzo/weedb/charger.mdl",
max=6})

-----------------------------------------------------------------------

WEED_ITEMS:Add("lamp_base",{name="Стандартная лампа",
category="Освещение",
description="Вам нужна лампа, чтобы ваши растения оставались в тепле? Нет проблем! Эта лампа излучает тепло в виде конуса, расположенного перед ней.",
price=15000,
ent="sent_light",
purchase=function(_,ent) ent:SetLight(1) end,
model="models/gonzo/weedb/lamp.mdl",
max=6})

WEED_ITEMS:Add("lamp_radial",{name="Радиальная лампа",
category="Освещение",
description="Вам нужна лампа, чтобы ваши растения оставались в тепле? Нет проблем! Эта лампа излучает тепло вокруг себя.",
price=25000,
ent="sent_light",
purchase=function(_,ent) ent:SetLight(2) end,
model="models/gonzo/weedb/lamp2.mdl",
max=6})

-----------------------------------------------------------------------

WEED_ITEMS:Add("water_pot",{name="Лейка",
category="Вода",
description="Поддерживайте влажность ваших растущих растений с помощью этой простой лейки!",
price=1500,
ent="sent_water_pot",
purchase=function(_,ent) ent:SetWater(1) end,
model="models/gonzo/weedb/water_pot.mdl",
max=8})

WEED_ITEMS:Add("water_shower",{name="Система подачи воды",
category="Вода",
description="Поливай свои растения без каких-либо усилий!",
price=25000,
ent="sent_water_pot",
purchase=function(_,ent) ent:SetWater(2) end,
model="models/gonzo/weedb/shower.mdl",
max=5})

WEED_ITEMS:Add("water_tank",{name="Насос",
category="Вода",
description="Накапливает воду! Максимально кол-во леек - "..WEED_CONFIG.WaterSourceBuckets,
price=15000,
ent="sent_water_tank",
model="models/gonzo/weedb/water_source.mdl",
max=4})

WEED_ITEMS:Add("water_supply",{name="Балон с водой",
category="Вода",
description="Перезаряжает систему подачи воды, доступно 3 перезарядки",
price=5000,
ent="sent_water_loader",
model="models/props_c17/canister01a.mdl",
max=3})

-----------------------------------------------------------------------

WEED_ITEMS:Add("base_soil",{name="Стандартный грунт",
category="Грунт",
description="Делает ваше растение сильным и здоровым!",
price=1500,
purchase=function(_,ent) ent:SetSoil(1) end,
ent="sent_soil",
model="models/gonzo/weedb/Soil_bag.mdl",
max=5})

WEED_ITEMS:Add("acid_soil",{name="Кислотный грунт",
category="Грунт",
description="Растение будет расти быстрее, но для этого потребуется больше воды, чем обычно.",
price=5000,
purchase=function(_,ent) ent:SetSoil(2) end,
draw=function(_,ent) ent:SetSkin(1) end,
ent="sent_soil",
model="models/gonzo/weedb/Soil_bag.mdl",
max=5})

WEED_ITEMS:Add("soft_soil",{name="Водяной грунт",
category="Грунт",
description="Растение будет расти медленнее,  но для этого почти не потребуется воды!",
price=10000,
purchase=function(_,ent) ent:SetSoil(3) end,
draw=function(_,ent) ent:SetSkin(2) end,
ent="sent_soil",
model="models/gonzo/weedb/Soil_bag.mdl",
max=5})

-----------------------------------------------------------------------
--[[
WEED_ITEMS:Add("bong",{name="Бонг",
category="Инструменты",
description="Кури свою травку с этим сумасшедшим бонгом!",
price=500,
wep="sent_bong",
model="models/weapons/w_bong.mdl"})
--]]

WEED_ITEMS:Add("messure",{name="Измеритель",
category="Инструменты",
description="Следи за здоровьем своих растений и уровнем воды.",
price=3500,
wep="sent_messure",
model="models/weapons/w_messure.mdl"})

WEED_ITEMS:Add("magazine",{name="Обучающая книга",
category="Инструменты",
description="",
price=1000,
ent="sent_magazine",
model="models/props_lab/bindergreenlabel.mdl",
max=5})

--addons/model_spiderman/lua/autorun/sm2_spiderman.lua:
player_manager.AddValidModel( "Spider-Man", 	"models/sm2/Spider-Man.mdl" )
list.Set( "PlayerOptionsModel", "Spider-Man", 	"models/sm2/Spider-Man.mdl.mdl" )
player_manager.AddValidHands( "Spider-Man", "models/weapons/c_arms_sm3.mdl", 0, "00000000" )

--addons/_smallscripts/lua/smallscripts/fear/shared.lua:
FEAR_DURATION = 15

nw.Register('IsFeared')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()
    :SetHook('PlayerFearUpdated')

local meta = FindMetaTable('Player')
function meta:IsFeared()
    return self:GetNetVar('IsFeared', false)
end

function meta:GetFearCount()
    return self:getJobTable().fearCount or 1
end
--addons/module_wmap/lua/autorun/waymap_init.lua:
wayMap = {}

if SERVER then
    AddCSLuaFile('waymap/vgui_map.lua')
    AddCSLuaFile('waymap/vgui_marker.lua')

    AddCSLuaFile('waymap/cl_waymap.lua')
else    
    include('waymap/vgui_map.lua')
    include('waymap/vgui_marker.lua')

    include('waymap/cl_waymap.lua')
end

hook.Run('wayMap.initialized')

wmap = wmap or {}

wlib.include.prefixed('waymap')
--addons/module_battlepass/lua/autorun/waypass_init.lua:
waypass = waypass or {}

-- UTIL
if SERVER then
    AddCSLuaFile('waypass/sh_util.lua')
    include('waypass/sh_util.lua')
else
    include('waypass/sh_util.lua')
end

-- OBJECTS
for _, name in pairs(file.Find('waypass/objects/*.lua', 'LUA') or {}) do
    if SERVER then AddCSLuaFile('waypass/objects/'..name) end
    include('waypass/objects/'..name)
end

-- CHALLENGES
for _, name in pairs(file.Find('waypass/challenges/*.lua', 'LUA') or {}) do
    if SERVER then AddCSLuaFile('waypass/challenges/'..name) end
    include('waypass/challenges/'..name)
end

-- REWARDS
waypass.rewards = {}
function waypass.RegisterReward(id, reward)
    reward.ID = id
    waypass.rewards[id] = reward
end
for _, name in pairs(file.Find('waypass/rewards/*.lua', 'LUA') or {}) do
    if SERVER then AddCSLuaFile('waypass/rewards/'..name) end
    include('waypass/rewards/'..name)
end

-- VGUI
for _, name in pairs(file.Find('waypass/vgui/*.lua', 'LUA') or {}) do
    if SERVER then
        AddCSLuaFile('waypass/vgui/'..name)
    else
        include('waypass/vgui/'..name)
    end
end

-- OTHER SHIT
if SERVER then
    AddCSLuaFile('waypass/cl_core.lua')

    AddCSLuaFile('waypass/sh_config.lua')
    AddCSLuaFile('waypass/sh_net.lua')
    include('waypass/sh_config.lua')
    include('waypass/sh_net.lua')

    include('waypass/sv_core.lua')
    include('waypass/sv_db.lua')
    include('waypass/sv_net.lua')
else
    include('waypass/sh_config.lua')
    include('waypass/sh_net.lua')

    include('waypass/cl_core.lua')
end
--addons/module_battlepass/lua/waypass/objects/battlepass.lua:
waypass.passes = waypass.passes or {}
waypass.passes.list = waypass.passes.list or {}

local BP = {}
BP.__index = BP

function waypass.passes.Create(id, name)
    return setmetatable({
        id = id,
        name = name,
        challenges = {},
        levels = {},
        hasFree = true,
        timestamps = {},
    }, BP)
end

wlib.accessor(BP, 'id', 'ID')
wlib.accessor(BP, 'name', 'Name')
wlib.accessor(BP, 'desc', 'Desc')
wlib.accessor(BP, 'icon', 'Icon')
wlib.accessor(BP, 'levels', 'Levels')
wlib.accessor(BP, 'price', 'Price')
wlib.accessor(BP, 'pointsBarrier', 'PointsBarrier')
wlib.accessor(BP, 'challenges', 'Challenges')
wlib.accessor(BP, 'BuyCheck', 'BuyCheck')
wlib.accessor(BP, 'hasFree', 'HasFree')
wlib.accessor(BP, 'startTime', 'StartTime')
wlib.accessor(BP, 'endTime', 'EndTime')
function BP:GetPointsBarrier()
    return self.pointsBarrier or waypass.config.pointsBarrier
end

function BP:IsActive()
    return self:GetEndTime() and self:GetEndTime() > os.time()
end

function BP:AddChallenge(id, uid, goal, reward, premium, timestamp, endtime)
    local c = waypass.challenges.CreateFromID(id)
    if not c then return waypass.error('Trying to add unexisting challenge') end

    timestamp = timestamp or 0

    if not table.HasValue(self.timestamps, timestamp) then table.insert(self.timestamps, timestamp) end

    c:SetTimestamp(timestamp)
    c:SetGoal(goal)
    c:SetReward(reward)
    c:SetUID(uid)
    c:SetBP(self)
    c:SetEndTime(endtime or self:GetEndTime())

    c:SetCallback(function(self)
        local ply = self:GetPlayer()

        waypass.AddPoints(ply, self:GetBP():GetID(), self:GetReward())
        DarkRP.notify(ply, 0, 5, waypass.Format('Ты получил {1} очков за выполнение задания', self:GetReward()))
    end)

    self.challenges[uid] = c

    return self
end

function BP:GetChallenge(uid)
    return self:GetChallenges()[uid]
end

function BP:GetChallengesByTimestamp(time)
    local a = {}
    for uid, c in pairs(self:GetChallenges()) do
        if c:GetTimestamp() == time then a[#a+1] = c end
    end
    return a
end

function BP:AddLevel(lvl, free, premium)
    for i=1, lvl do
        self.levels[i] = self.levels[i] or {free = {}, premium = {}}
    end
    self.levels[lvl].free = free and (istable(free[1]) and free or {free}) or {}
    self.levels[lvl].premium = premium and (istable(premium[1]) and premium or {premium}) or {}

    return self
end

function BP:GetLevelRewards(lvl)
    return self.levels[lvl]
end

function BP:GetMaxLevel()
    return #self.levels
end

function BP:Register()
    waypass.passes.Register(self)
end

function BP:GetNextChallengesTimestamp()
    local next = math.huge
    for _, v in ipairs(self.timestamps) do
        if os.time() < v then
            next = math.min(next, v)
        end
    end
    return next
end

function BP:CreateChallengesTimer()
    local diff = self:GetNextChallengesTimestamp()-os.time()

    timer.Create('waypass_'..self:GetID()..'_givechallenges', diff, 1, function()
        local plys = {}
        for _, v in player.Iterator() do
            if not v:HasBP(self:GetID()) then continue end

            plys[#plys+1] = v
            waypass.GiveActiveChallenges(v, self:GetID())
        end

        DarkRP.notify(plys, 3, 10, waypass.Format('[{1}] Доступны новые задания', self:GetName()))

        self:CreateChallengesTimer()
    end)
end

function waypass.passes.Register(bp)
    waypass.passes.list[bp:GetID()] = bp

    table.sort(bp.timestamps)

    if SERVER then
        bp:CreateChallengesTimer()
    end
end

function waypass.passes.Get(id)
    return waypass.passes.list[id]
end

waypass.GetBP = waypass.passes.Get
--addons/module_battlepass/lua/waypass/challenges/bitminer.lua:
waypass.challenges.Create('bitminer')
    :SetName('Майнер')
    :SetDesc('Заработай {goal} с помощью битмайнеров')
    :AddHook('BitcoinSell', function(self, ply, owner, money)
        if ply ~= owner then return end
        self:AddProgress(money)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/death.lua:
waypass.challenges.Create('death')
    :SetName('В последний путь')
    :SetDesc('Умри {goal} раз')
    :AddHook('PlayerDeath', function(self, owner, v, i, a)
        if v == a then return end
        if v ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/vgui/_main.lua:
local challenge_width = 250
local font = 'dorgs.24'
local lvl_height = 140
local lvl_width = (lvl_height-20)*2
local lvl_footer_height = 50
local padding = 8

local mat_prev = Material('icon72/arrow_backward.png')
local mat_next = Material('icon72/arrow_forward.png')

local color_red = Color(250, 0, 0)

local PANEL = {}

function PANEL:Init()
    self.hideCompleted = false

    hook.Add('waypass.PreviewReward', 'preview', function(panel, reward, value)
        if not IsValid(self) then return end
        self:SetPreviewReward(reward, value, panel:GetPremium())
    end)
    hook.Add('waypass.UnPreviewReward', 'preview', function(panel, reward, value)
        if not IsValid(self) then return end
        self:SetPreviewReward()
    end)

    self:DockPadding(padding,padding,0,0)

    self.sidebar = vgui.Create('DScrollPanel', self)
    self.sidebar:Dock(RIGHT)
    self.sidebar:SetWide(challenge_width+8)
    self.sidebar:SetPaintBackground(false)

    local sbar = self.sidebar:GetVBar()
    sbar:SetWide(4)
    function sbar:Paint(w, h)
    end
    function sbar.btnUp:Paint(w, h)
    end
    function sbar.btnDown:Paint(w, h)
    end
    function sbar.btnGrip:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, waypass.skin.COLOR_PRIMARY)
    end

    self.preview = vgui.Create('DPointShopPreview', self)
    self.preview:Dock(FILL)
    self.preview:SetModel(LocalPlayer():GetModel())
    --self.preview.LayoutEntity = wlib.func.blank
    --self.preview:SetLookAt(self.preview.Entity:GetPos()+Vector(0,0,48))
    function self.preview:ResetPos()
        local PrevMins, PrevMaxs = self.Entity:GetRenderBounds()
        self:SetCamPos(PrevMins:Distance(PrevMaxs) * Vector(0.30, 0.30, 0.25) + Vector(0, 0, 15))
        self:SetLookAt((PrevMaxs + PrevMins) / 2)
        self:SetFOV(70)
    end
    self.preview:ResetPos()

    self.preview.Angles = Angle( 0, 40, 0 )
    self.preview.Pos = Vector( -10, -10, -20 )

    function self.preview:DragMousePress()
        self.PressX, self.PressY = gui.MousePos()
        self.Pressed = true
    end

    function self.preview:DragMouseRelease()
        self.Pressed = false
        self.lastPressed = RealTime()
    end

    function self.preview:LayoutEntity( thisEntity )
        if ( self.bAnimated ) then self:RunAnimation() end

        if ( self.Pressed ) then
            local mx, my = gui.MousePos()
            self.Angles = self.Angles - Angle( 0, ( self.PressX or mx ) - mx, 0 )
            self.Pos = self.Pos + Vector( 0, 0, ((self.PressY or my) - my) / 10 )
            self.PressX, self.PressY = gui.MousePos()
        end

        thisEntity:SetAngles( self.Angles )
        thisEntity:SetPos( self.Pos )
    end

    self.levelbar = vgui.Create('waypass_levelbar', self)
    self.levelbar:SetSize(300, 70)
    self.levelbar:SetPos(padding, padding)

    self.prevbp = vgui.Create('waypass_button', self)
    self.prevbp:SetSize(120, 32)
    self.prevbp:SetPos(padding, padding+self.levelbar:GetTall()+4)
    self.prevbp:SetVisible(false)
    self.prevbp.DoClick = function()
        if self:GetBP():IsActive() then
            local lastbp = waypass.GetLastBP()
            if lastbp then self:SetBPID(lastbp:GetID()) end
        else
            self:SetBPID(waypass.GetActiveBP():GetID())
        end
    end

    -- LEVELS
    self.levels = vgui.Create('DPanel', self)
    self.levels:Dock(BOTTOM)
    self.levels:SetPaintBackground(false)
    self.levels:SetTall(lvl_height+lvl_footer_height)

    self.levels.footer = vgui.Create('DPanel', self.levels)
    self.levels.footer:Dock(BOTTOM)
    self.levels.footer:SetPaintBackground(false)
    self.levels.footer:SetTall(lvl_footer_height)

    self.levels.multi = vgui.Create('waypass_multipanel', self.levels)
    self.levels.multi:Dock(FILL)
    self.levels.multi:SetPaintBackground(false)

    self.levels.prev = vgui.Create('DImageButton', self.levels.footer)
    self.levels.prev:SetSize(24, 24)
    self.levels.prev:SetMaterial(mat_prev)
    self.levels.prev.DoClick = function()
        self.levels.multi:SelectPanel(math.max(1, self.levels.multi:GetActiveID()-1))
        self:LayoutFooter()
    end

    self.levels.next = vgui.Create('DImageButton', self.levels.footer)
    self.levels.next:SetSize(24, 24)
    self.levels.next:SetMaterial(mat_next)
    self.levels.next.DoClick = function()
        self.levels.multi:SelectPanel(math.min(#self.levels.multi.panels, self.levels.multi:GetActiveID()+1))
        self:LayoutFooter()
    end

    self.levels.label = vgui.Create('DLabel', self.levels.footer)
    self.levels.label:SetFont(font)
    self.levels.label:SetColor(color_white)
end

AccessorFunc(PANEL, 'bpId', 'BPID')
function PANEL:GetBP()
    return waypass.GetBP(self:GetBPID())
end
function PANEL:SetBPID(id)
    self.bpId = id

    self:Reload()
end

function PANEL:SetPreviewReward(reward, val, premium)
    self.reward = isstring(reward) and waypass.rewards[reward] or reward
    self.rewardValue = val
    self.rewardPremium = premium
end

function PANEL:RebuildLevels(oldPage)
    local bp = self:GetBP()
    if not bp then return end

    local bpInfo = LocalPlayer():GetBPInfo()[bp:GetID()]

    self.levels.multi:Clear()

    local w = self.levels:GetWide()
    local count = math.floor(w/lvl_width)
    local gap = count>1 and math.floor((w-lvl_width*count)/(count-1)) or 0

    local p = vgui.Create('DIconLayout')
    p:SetSpaceX(gap)

    local i=0
    for lvl, rewards in ipairs(bp.levels) do
        if #rewards.free == 0 and #rewards.premium == 0 then continue end
        i = i+1

        local lvlp = vgui.Create('waypass_level', p)
        lvlp:SetSize(lvl_width, lvl_height)
        lvlp:SetLevel(lvl)
        lvlp:SetReached(bpInfo and bpInfo.level >= lvl)
        lvlp:SetBPID(bp:GetID())

        lvlp.free:SetReward(rewards.free[1][1], rewards.free[1][2])
        lvlp.free:SetClaimed(bpInfo and table.HasValue(bpInfo.claims.free, lvl))
        lvlp.free:SetObtainable(lvlp:GetReached())
        lvlp.free:SetLevel(lvl)
        lvlp.free:SetPreviewPanel(self.preview)

        lvlp.premium:SetReward(rewards.premium[1][1], rewards.premium[1][2])
        lvlp.premium:SetClaimed(bpInfo and table.HasValue(bpInfo.claims.premium, lvl))
        lvlp.premium:SetObtainable(lvlp:GetReached() and bpInfo and bpInfo.premium)
        lvlp.premium:SetLevel(lvl)
        lvlp.premium:SetPreviewPanel(self.preview)
        if not bpInfo or not bpInfo.premium then
            lvlp.premium:SetTooltip('Доступно только с премиум-версией боевого пропуска')
        end

        p:Add(lvlp)

        if i>=count then
            self.levels.multi:AddPanel(p)

            p = vgui.Create('DIconLayout')
            p:SetSpaceX(gap)

            i=0
        end
    end
    if i>0 then
        self.levels.multi:AddPanel(p)
    end
    self.levels.multi:SelectPanel(oldPage or 1)
end

function PANEL:LayoutFooter()
    local cur = self.levels.multi:GetActiveID() or 1
    local text = 'Страница '..cur..'/'..#self.levels.multi.panels

    surface.SetFont(font)
    local tw, th = surface.GetTextSize(text)

    local fw, fh = self.levels.footer:GetSize()

    self.levels.label:SetSize(tw, th)
    self.levels.label:SetPos(fw/2-tw/2, fh/2-th/2)
    self.levels.label:SetText(text)

    self.levels.prev:SetPos(fw/2-tw/2 - 8 - 24, fh/2 - 12)
    self.levels.next:SetPos(fw/2+tw/2 + 8, fh/2 - 12)
end

function PANEL:RebuildChallenges()
    local bp = self:GetBP()
    if not bp then return end

    self.sidebar:Clear()

    --[[
    local hidePan = vgui.Create('DCheckBoxLabel', self.sidebar)
    hidePan:Dock(TOP)
    hidePan:SetChecked(self.hideCompleted)
    hidePan:DockMargin(4, 0, 0, 4)
    hidePan:SetText('Скрыть выполненые')

    function hidePan.OnChange(s, val)
        self.hideCompleted = val
        self:RebuildChallenges()
    end
    ]]

    local info = LocalPlayer():GetBPChallenges()[bp:GetID()] or {}

    local challengesByEndTime = {}
    for uid, c in SortedPairsByMemberValue(info, 'progress', true) do
        challengesByEndTime[c:GetEndTime()] = challengesByEndTime[c:GetEndTime()] or {}
        table.insert(challengesByEndTime[c:GetEndTime()], c)
    end

    for ts, v in SortedPairs(challengesByEndTime) do
        --[[
        local time = vgui.Create('DPanel', self.sidebar)
        time:Dock(TOP)
        time:DockMargin(0, fst and 0 or 4, 0, 8)
        time:SetTall(25)
        time.Paint = function(s,w,h)
            draw.SimpleText('Неделя '..i, 'dorgs.24', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        ]]

        for _, c in ipairs(v) do
            if not c:IsActive() or (c:IsCompleted() and self.hideCompleted) then continue end

            local p = vgui.Create('waypass_challenge', self.sidebar)
            p:Dock(TOP)
            p:SetWide(challenge_width)
            p:DockMargin(4,0,0,4)
            p:SetChallenge(c)
            p:SetProgress(c:GetProgress())
        end
    end

    if table.Count(info) >= table.Count(bp:GetChallenges()) then return end
    local nextChallenges = bp:GetNextChallengesTimestamp()
    if nextChallenges == math.huge then return end

    local p = vgui.Create('DPanel', self.sidebar)
    p:Dock(TOP)
    p:DockMargin(0,0,0,8)
    p:SetTall(100)
    p:SetPaintBackground(false)
    p.Paint = function(_,w,h)
        local tbl = string.FormattedTime(nextChallenges-os.time())
        local days = math.floor(tbl.h/24)
        local text = 'через '
        if days > 0 then
            text = text..wlib.string.formatPlural({'день', 'дня', 'дней'}, days)
        else
            text = text..('%02i:%02i:%02i'):format(tbl.h, tbl.m, tbl.s)
        end

        draw.SimpleText('Новые задания', 'chelog-ib.small', w/2, h/2-20, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(text, 'chelog-ib.small', w/2, h/2+5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

function PANEL:PerformLayout(w,h)
    local bp = self:GetBP()
    if not bp then return end
    
    local curPage = self.levels.multi:GetActiveID() or 1

    self:RebuildLevels(curPage)
    self:LayoutFooter()
end

local color_red = Color(170,0,0)

function PANEL:Paint(w,h)
    local bp = self:GetBP()
    if not bp then return end

    draw.SimpleText(bp:GetName(), 'dorgs.24', w-self.sidebar:GetWide()-4, padding, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)

    if bp:GetEndTime() then
        local text = 'Осталось '
        local remaining = bp:GetEndTime()-os.time()
        if remaining < 0 then
            text = 'Закончился'
        else
            local tbl = string.FormattedTime(bp:GetEndTime()-os.time())
            local days = math.floor(tbl.h/24)
            if days > 0 then
                text = text..wlib.string.formatPlural({'день', 'дня', 'дней'}, days)
            else
                text = text..('%02i:%02i:%02i'):format(tbl.h, tbl.m, tbl.s)
            end
        end

        surface.SetFont('dorgs.bold.20')
        local tw, th = surface.GetTextSize(text)

        local boxW, boxH = tw+8, th+4

        draw.RoundedBox(0, w-self.sidebar:GetWide()-4-boxW, padding+24+2, boxW, boxH, color_red)
        draw.SimpleText(text, 'dorgs.bold.20', w-self.sidebar:GetWide()-4-4, padding+24+2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
    end
end

local triangle_w = 8
function PANEL:PaintOver(w,h)
    if self.reward then
        local rtext = self.rewardPremium and 'ПРЕМИУМ' or 'БАЗОВЫЙ'
        local ntext = ('%s (%s)'):format(self.reward:GetName(self.rewardValue), self.reward.GetCount and self.reward:GetCount(self.rewardValue) or 'x1')

        -- RARITY
        surface.SetFont('dorgs.bold.20')
        local rw, rh = surface.GetTextSize(rtext)

        surface.SetFont('dorgs.bold.24')
        local nw, nh = surface.GetTextSize(ntext)

        local centerX, centerY = (w-self.sidebar:GetWide())/2, h-lvl_height-lvl_footer_height-20
        
        local boxW, boxH = rw+8+triangle_w*2, rh

        local wholeW = boxW+12+nw

        draw.NoTexture()
        surface.SetDrawColor(self.rewardPremium and waypass.skin.COLOR_PRIMARY or waypass.skin.COLOR_SECONDARY)
        surface.DrawPoly({
            {x = centerX-wholeW/2+triangle_w, y = centerY-boxH/2},
            {x = centerX-wholeW/2+triangle_w, y = centerY+boxH/2},
            {x = centerX-wholeW/2, y = centerY+boxH/2},
        })
        surface.DrawPoly({
            {x = centerX-wholeW/2+boxW-triangle_w, y = centerY-boxH/2},
            {x = centerX-wholeW/2+boxW, y = centerY-boxH/2},
            {x = centerX-wholeW/2+boxW-triangle_w, y = centerY+boxH/2},
        })
        surface.DrawRect(centerX-wholeW/2+triangle_w, centerY-boxH/2, boxW-triangle_w*2+1, boxH)

        draw.SimpleText(rtext, 'dorgs.bold.20', centerX-wholeW/2+triangle_w+4, centerY, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

        draw.SimpleText(ntext, 'dorgs.bold.24', centerX+wholeW/2-6, centerY, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
    end
end

function PANEL:Reload()
    local bp = self:GetBP()
    if not bp then return end

    local curPage = self.levels.multi:GetActiveID() or 1
    local info = LocalPlayer():GetBPInfo()[bp:GetID()] or {}

    self.levelbar:SetBPID(bp:GetID())
    self.levelbar:SetPremium(info.premium)
    self.levelbar:SetPoints(info.points)
    self.levelbar:SetLevel(info.level)

    if waypass.GetLastBP() then
        self.prevbp:SetVisible(true)
        if bp:IsActive() then
            self.prevbp:SetColor(waypass.skin.COLOR_SECONDARY)
            self.prevbp:SetOutlineColor(waypass.skin.COLOR_SECONDARY)
            self.prevbp:SetButtonText('Прошлый сезон')
            self.prevbp:SetIcon('icon72/arrow_backward.png')
            self.prevbp:SizeToContents()
        else
            self.prevbp:SetColor(waypass.skin.COLOR_PRIMARY)
            self.prevbp:SetOutlineColor(waypass.skin.COLOR_PRIMARY)
            self.prevbp:SetButtonText('Текущий сезон')
            self.prevbp:SetIcon('icon72/arrow_forward.png')
            self.prevbp:SizeToContents()
        end
    end
    
    self:RebuildLevels(curPage)
    self:RebuildChallenges()
    self:LayoutFooter()
end

vgui.Register('waypass_main', PANEL, 'DPanel')
--addons/module_battlepass/lua/waypass/vgui/_skin.lua:
waypass.skin = {}

waypass.skin.COLOR_PRIMARY = Color(236,113,71)
waypass.skin.COLOR_SECONDARY = Color(54,57,62)
waypass.skin.COLOR_CLAIMED = Color(5,161,0,59)
waypass.skin.COLOR_OUTLINE = Color(37,39,44)
-- Color(47,49,54)
--MediaLib_DynFile_gdrive.lua:
local a=medialib.load("oop")local b=a.class("GDriveService","HTMLService")b.identifier="GDrive"local c={"^https?://drive.google.com/file/d/([^/]*)/edit"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local function h(i)if i then i=string.gsub(i,"\n","\r\n")i=string.gsub(i,"([^%w ])",function(j)return string.format("%%%02X",string.byte(j))end)i=string.gsub(i," ","+")end;return i end;local k="https://wyozi.github.io/gmod-medialib/mp4.html?id=%s"local l="https://drive.google.com/uc?export=download&confirm=yTib&id=%s"function b:resolveUrl(d,m)local n=self:parseUrl(d)local o=string.format(k,h(string.format(l,n.id)))m(o,{start=n.start})end;function b:directQuery(d,m)m(nil,{title=d:match("([^/]+)$")})end;function b:hasReliablePlaybackEvents()return true end;return b
--addons/module_media/lua/wayradio/3dvol.lua:
local function startBASSThink(clip)
    if clip.fadeMax3D then
        clip.chan:Set3DFadeDistance(0, clip.fadeMax3D)
    end

    if clip.pos3D then
        clip.chan:SetPos(clip.pos3D)
    elseif clip.ent3D then
        local hookId = "MediaLib.3DThink." .. clip:hashCode()

        hook.Add("Think", hookId, function()
            -- Stop hook if chan is invalid
            if not clip:isValid() then
                hook.Remove("Think", hookId)

                return
            end

            -- Stop media if entity is invalid
            if not IsValid(clip.ent3D) then
                clip:stop()

                return
            end

            -- Update pos
            clip.chan:SetPos(clip.ent3D:GetPos())
        end)
    end
end

local cvar_debugobs = CreateConVar("medialib_vol3d_debugobstacle", "0")
local trQuery, trResult = {}, {}
trQuery.output = trResult
trQuery.mask = MASK_SOLID_BRUSHONLY

local function getObstacleMultiplier(pos)
    local eyepos = LocalPlayer():EyePos()
    local debug = cvar_debugobs:GetBool()
    local normal = (eyepos - pos):GetNormalized()
    local crs_right = normal:Cross(Vector(0, 0, 1))
    local crs_up = -normal:Cross(crs_right)
    --debugoverlay.Line(pos, pos+crs_right*100, 0.1, Color(0, 255, 0))
    --debugoverlay.Line(pos, pos+crs_up*100, 0.1, Color(255, 0, 0))
    local traces = 8
    local hitWall = 0
    local circleRadius = 20

    for i = 1, traces do
        local rad = math.pi * 2 * (i / traces)
        local start = pos + math.cos(rad) * circleRadius * crs_right + math.sin(rad) * circleRadius * crs_up
        trQuery.start = start
        trQuery.endpos = eyepos
        local tr = util.TraceLine(trQuery)

        if tr.Hit then
            hitWall = hitWall + 1
        end

        if debug then
            debugoverlay.Line(start, eyepos, 0.1, tr.Hit and Color(255, 0, 0) or Color(255, 127, 0))
        end
    end

    local frac = hitWall / traces

    return math.Remap(1 - frac, 0, 1, 0.3, 1), frac == 1 and 1.2 or 1
end

local function startHTMLThink(clip)
    local hookId = "MediaLib.3DThink." .. clip:hashCode()

    hook.Add("Think", hookId, function()
        -- Stop hook if chan is invalid
        if not clip:isValid() then
            hook.Remove("Think", hookId)

            return
        end

        local pos

        if clip.pos3D then
            pos = clip.pos3D
        elseif clip.ent3D then
            -- Stop media if entity is invalid
            if not IsValid(clip.ent3D) then
                clip:stop()

                return
            end

            pos = clip.ent3D:GetPos()
        end

        if not pos then return end
        local eyep = LocalPlayer():EyePos()
        local dist = eyep:Distance(pos)
        local fadeMax = clip.fadeMax3D or 1024
        local fadeFrac = dist / fadeMax
        local vol = 0

        if fadeFrac < 1 then
            local obsVolMul, obsFadeMul = getObstacleMultiplier(pos)

            if clip.attenuationType == "linear" then
                vol = 1 - fadeFrac
            else
                vol = 1 / ((fadeFrac + 1) ^ 7)
            end

            vol = vol * obsVolMul
            vol = math.Clamp(vol, 0, 1)
        end

        -- Set the internal volume so that users can still set relative volume
        clip.internalVolume = math.Approach(clip.internalVolume or 0, vol, FrameTime() * 2)
        clip:applyVolume()
    end)
end

local function startThink(clip)
    if clip:getBaseService() == "bass" then
        startBASSThink(clip)
    elseif clip:getBaseService() == "html" then
        startHTMLThink(clip)
    end
end

hook.Add("Medialib_ProcessOpts", "Medialib_Volume3d", function(media, opts)
    if not opts.use3D then return end
    media.is3D = true

    if media:getBaseService() == "bass" then
        table.insert(media.bassPlayOptions, "3d")
    end

    function media:set3DPos(pos)
        self.pos3D = pos
        self.ent3D = nil
    end

    function media:set3DEnt(ent)
        self.pos3D = nil
        self.ent3D = ent
    end

    function media:set3DFadeMax(fademax)
        self.fadeMax3D = fademax

        if IsValid(self.chan) and self:getBaseService() == "bass" then
            self.chan:Set3DFadeDistance(0, fademax)
        end
    end

    function media:set3DAttenuationType(type)
        self.attenuationType = type
    end

    if opts.pos3D then
        media:set3DPos(opts.pos3D)
    end

    if opts.ent3D then
        media:set3DEnt(opts.ent3D)
    end

    if opts.attenuationType then
        media:set3DAttenuationType(opts.attenuationType)
    end

    media:runCommand(function()
        startThink(media)
    end)
end)
--addons/module_scoreboard/lua/wayscore/core.lua:
wayscore.info = {
    {
        name = 'Имя',
        icon = 'icon72/dividers.png',
        get = function(ply)
            return ply:Name()
        end,
        align = TEXT_ALIGN_LEFT,
        size = 0.20,
    },
    {
        name = 'Организация',
        icon = 'icon72/crossed_swords.png',
        get = function(ply)
            local clan = dOrgs.orgs[ply:GetMainOrgID()]
            return clan and clan:GetName() or ''
        end,
        align = TEXT_ALIGN_CENTER,
        size = 0.15,
    },
    {
        name = 'Профессия',
        icon = 'icon72/briefcase.png',
        get = function(ply)
            return ply:GetNetVar('job', '')
        end,
        align = TEXT_ALIGN_CENTER,
        center = false,
        size = 0.30,
    },
    {
        name = 'AFK',
        icon = 'icon72/alarm_clock.png',
        get = function(ply)
            local t = ply:GetAFKTime()
            return ply:IsAFK() and ('%02i:%02i:%02i'):format(math.floor(t/3600), math.floor(t/60%60), t%60) or ''
        end,
        align = TEXT_ALIGN_CENTER,
        size = 0.20,
    },
    {
        name = 'Пинг',
        icon = 'icon72/satellite.png',
        get = function(ply)
            return ply:Ping()
        end,
        --[[
        check = function()
            return LocalPlayer():IsAdmin()
        end,
        ]]
        align = TEXT_ALIGN_RIGHT,
        size = 0.15,
    },
}

CreateClientConVar('wayscore_sort', 2, true)
CreateClientConVar('wayscore_sort_desc', 0, true)

wayscore.view = 'main'
wayscore.viewData = {}

wayscore.ActionButtons = wayscore.ActionButtons or {}
wayscore.Information = wayscore.Information or {}

function wayscore:Show()
    if not IsValid(LocalPlayer()) then return end
    
    gui.EnableScreenClicker(true)
    if IsValid(self.frame) then
        self.frame:SetVisible(true)
        self:SelectView(self.view, unpack(self.viewData))
        hook.Run('wayscore.Show', self.frame)
        return true
    end

    self.frame = vgui.Create('wayscore_frame')

    self.views = {}
    self:AddView('main', 'wayscore_playerlist')
    self:AddView('player', 'wayscore_view_player')

    self:SelectView(self.view, unpack(self.viewData))

    hook.Run('wayscore.Show', self.frame)

    return true
end

function wayscore:Hide()
    if IsValid(self.frame) then
        self.frame:SetVisible(false)
    end
    gui.EnableScreenClicker(false)

    hook.Run('wayscore.Hide')
    
    return true
end

function wayscore:IsVisible()
    return IsValid(self.frame) and self.frame:IsVisible() or false
end

function wayscore:Reload()
    if IsValid(self.frame) then self.frame:Remove() end
    self:Show()
end

concommand.Add('wayscore_reload', function()
    wayscore:Reload()
end)

timer.Simple(0, function()
    hook.Remove('ScoreboardShow', 'FAdmin_scoreboard')
    hook.Remove('ScoreboardHide', 'FAdmin_scoreboard')

    hook.Add('ScoreboardShow', 'wayscore', function()
        return wayscore:Show()
    end)

    hook.Add('ScoreboardHide', 'wayscore', function()
        if wayscore.fixed then return true end
        return wayscore:Hide()
    end)
end)

hook.Add('wayscore.PlayerRowColor', 'disguise', function(ply)
    if not ply:GetNetVar('disguised') then return end
    if LocalPlayer():Team() == TEAM_ADMIN then return end

    return (LocalPlayer():isCP() and ply:isCP()) and team.GetColor(ply:Team()) or team.GetColor(ply:GetNetVar('disguise_team'))
end)
--addons/module_scoreboard/lua/wayscore/vgui/playerlist.lua:
local PANEL = {}
local color_scroll = Color(38, 42, 46, 255)

function PANEL:Init()
    self:Dock(FILL)
    self.SortBox = vgui.Create('Panel', self)
    self.SortBox:Dock(TOP)
    self.SortBox:DockMargin(10, 6, 0, 0)
    self.SortBox:SetTall(30)

    self.Search = vgui.Create('DImageButton', self.SortBox)
    self.Search:SetImage('icon72/mag.png')
    self.Search:SetTooltip('Поиск по игрокам')
    self.Search.DoClick = function()
        if self.SearchEntry:IsVisible() then
            self.SearchEntry:Hide()
        else
            self.SearchEntry:Show()
        end
    end

    self.Sorts = {}


    for k, v in ipairs(wayscore.info or {}) do
        if v.check and not v.check() then continue end

        local check = vgui.Create('DImageButton', self.SortBox)
        check.info = table.Copy(v)
        check:SetImage(v.icon)
        check:SetTooltip(v.name)
        check:SetSize(30, 30)
        local id = table.insert(self.Sorts, check)
        check.id = id
        check.DoClick = function(s, val)
            self:Sort(id, val)
        end
    end

    self.LocalPlayer = vgui.Create('wayscore_player', self)
    self.LocalPlayer:Dock(TOP)
    self.LocalPlayer:DockMargin(0, 6, 0, 0)
    self.LocalPlayer:InvalidateLayout()
    self.LocalPlayer:SetPlayer(LocalPlayer())

    self.PlayerList = vgui.Create('DScrollPanel', self)
    self.PlayerList:Dock(FILL)

    local vbar = self.PlayerList:GetVBar()
    vbar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h - 20, Color(60,60,60))
    end
    vbar.btnUp.Paint = function( s, w, h ) end
    vbar.btnDown.Paint = function( s, w, h ) end
    vbar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h, color_scroll)
    end
    
    --self.PlayerList:DockMargin(0, 6, 0, 0)

    self.Players = player.GetAll()
    self:Sort()

    --[[
    timer.Create('wayscore_addplayers', .5, 0, function()
        if not IsValid(self) then return timer.Remove('wayscore_fetchplayers') end
        self.Players = player.GetAll()
        self:Sort()
    end)
    ]]

    self.SearchEntry = vgui.Create('DTextEntry', self)
    self.SearchEntry:SetSize(180, 25)
    self.SearchEntry:SetVisible(false)
    self.SearchEntry:SetUpdateOnType(true)
    self.SearchEntry:SetFont('chelog-ib.small')
    self.SearchEntry:AllowInput(true)
    self.SearchEntry:MakePopup()

    self.SearchEntry.Hover = Color(170, 78, 48)
    self.SearchEntry.Selected = Color(236, 113, 73)
    self.SearchEntry.idle = Color(0, 0, 0)
    self.SearchEntry.Color = self.SearchEntry.idle
    self.SearchEntry.Showing = 0
    self.SearchEntry.Showing2 = 150

    function self.SearchEntry:Paint(w,h)
        self.Last = self.Color

        if self:IsEditing() then
            self.Color = self.Selected
        elseif self:IsHovered() then
            self.Color = self.Hover
        else
            self.Color = self.idle
        end

        if self.Last ~= self.Color then
            self.Showing = 0
            self.Showing2 = 150
        end

        if self.Showing <= 150 then
            self.Showing = Lerp(FrameTime() * 3, self.Showing, 150)
        end

        if self.Showing2 ~= 0 then
            self.Showing2 = Lerp(FrameTime() * 3, self.Showing2, 0)
        end

        draw.RoundedBox(0, w / 2 - 1, h - h / 10, self.Showing, h / 10, self.Color)
        draw.RoundedBox(0, self.Showing2 + 1, h - h / 10, (w / 2) - self.Showing2, h / 10, self.Color)
        self:DrawTextEntryText(Color(255, 255, 255), Color(0, 0, 0), Color(255, 255, 255))
    end

    self.SearchEntry.Show = function()
        self.SearchEntry:SetVisible(true)
        wayscore.fixed = true

        self.SearchEntry:SetValue('')
        self:Filter()

        hook.Add('ShouldOpenEscapeMenu', 'wayscore', function()
            if IsValid(self.SearchEntry) and self.SearchEntry:HasFocus() then return false end
        end)
    end
    self.SearchEntry.Hide = function()
        self.SearchEntry:SetVisible(false)
        wayscore.fixed = false

        self.SearchEntry:SetValue('')
        self:Filter()
    end

    self.SearchEntry.OnValueChange = function(s, val)
        self:Filter(val)
    end
    self.SearchEntry.OnKeyCode = function(s, key)
        if key == KEY_ESCAPE then
            self.SearchEntry:Hide()
            gui.HideGameUI()
        end
    end
end

local function getx(offset, tw, wide, align)
    if align == TEXT_ALIGN_CENTER then
        return offset+tw/2-wide/2
    elseif align == TEXT_ALIGN_LEFT then
        return offset
    elseif align == TEXT_ALIGN_RIGHT then
        return offset+tw-wide
    end
end

function PANEL:PerformLayout(w, h)
    self.Search:SetSize(self.SortBox:GetTall()-4, self.SortBox:GetTall()-4)
    self.Search:SetPos(2, 2)

    --self.SearchEntry:SetX(self:LocalToScreen(self:GetWide()/2 - self.SearchEntry:GetWide()/2))
    --self.SearchEntry:SetY(self:LocalToScreen(self:GetTall()-self.SearchEntry:GetTall()))

    self.SearchEntry:SetX(ScrW()/2 - self.SearchEntry:GetWide()/2)
    self.SearchEntry:SetY(ScrH()/2 + self:GetTall()/2 - self.SearchEntry:GetTall() - 10)

    local canvas = self.PlayerList:GetCanvas()

    local offset = 64-8
    for k, v in ipairs(self.Sorts) do
        local piece = math.floor((canvas:GetWide()-64-8)*v.info.size)

        local x = v.info.center and (w-68)/2 or getx(offset, piece, v:GetWide(), v.info.align)
        v:SetPos(x, self.SortBox:GetTall()/2-v:GetTall()/2)
        
        offset = offset+piece
    end

    self.LocalPlayer:DockMargin(4, 6, self.PlayerList.VBar:IsVisible() and self.PlayerList.VBar:GetWide()+4 or 4, 7)
end

local cvar_sort = GetConVar('wayscore_sort')
local cvar_desc = GetConVar('wayscore_sort_desc')

function PANEL:Sort(id, desc)
    id = id == nil and cvar_sort:GetInt() or id
    desc = desc == nil and cvar_desc:GetBool() or desc
    local sort = self.Sorts[id]
    if not sort then return end

    cvar_sort:SetInt(id)
    cvar_desc:SetBool(desc)

    local pls = table.Copy(self.Players)
    table.sort(pls, function(a, b)
        if not IsValid(a) or not IsValid(b) then return true end
        local ares, bres = sort.info.get(a), sort.info.get(b)
        if not ares then return true end
        if not bres then return false end
        
        if desc then
            return ares > bres
        else
            return ares < bres
        end
    end)
    self:Clear()

    local lp = LocalPlayer()
    for _, v in ipairs(pls) do
        if v == lp then continue end
        self:AddPlayer(v)
    end
end

function PANEL:Filter(val)
    local a = {}
    for _, v in player.Iterator() do
        if not val or v:SteamID() == val or wayscore.lower(v:Name()):match(wayscore.lower(val)) then
            table.insert(a, v)
        end
    end
    self.Players = a
    self:Sort()
end

function PANEL:AddPlayer(ply)
    local row = self.PlayerList:Add('wayscore_player')
    row:InvalidateLayout()
    row:SetPlayer(ply)
    self.Players[#self.Players+1] = ply
end

function PANEL:Clear()
    self.PlayerList:Clear()
    self.Players = {}
end

function PANEL:Select()
    self.Players = player.GetAll()
    self:Sort()
end

vgui.Register('wayscore_playerlist', PANEL, 'Panel')
--addons/weapon_melee/lua/autorun/weapon_hitless.lua:
sound.Add({
	['name'] = "hiltless_holster",
	['channel'] = CHAN_STATIC,
	['sound'] = { "weapons/hiltiless/holster.mp3" },
	['pitch'] = {95,105}
})


sound.Add({
	['name'] = "hiltless_hand",
	['channel'] = CHAN_STATIC,
	['sound'] = { "weapons/hiltiless/hand.wav" },
	['pitch'] = {95,105}
})

sound.Add({
	['name'] = "makato_hitflesh",
	['channel'] = CHAN_WEAPON,
	['sound'] = { "weapons/tfa_makato/makato_hitflesh1.wav", "weapons/tfa_makato/makato_hitflesh2.wav", "weapons/tfa_makato/makato_hitflesh3.wav", "weapons/tfa_makato/makato_hitflesh4.wav"	},
	['pitch'] = {100,100}
})
--addons/module_skins/lua/weaponskins/client.lua:
net.Receive('weaponSkins.send', function()
    local lp = LocalPlayer()
    lp.weaponSkins = net.ReadTable()
end)

local cvar_enabled = CreateClientConVar('wrp_skins_viewmodel', '1')

local cur
waySettings.registerVar('wrp_skins_viewmodel', 'Отображать скины от 1-го лица', 'Оружие', 'bool'):SetConVar('wrp_skins_viewmodel', TYPE_BOOL)
    :SetOnChange(function()
        cur = nil
    end)

hook.Add('weaponSkin.selectedUpdate', 'refreshskin', function()
	cur = nil
end)

hook.Add('PreDrawViewModel', 'weaponSkins.viewModel', function(viewmodel, ply, wep)
    if cur == wep then return end
    cur = wep

    local mat = ply:GetNetVar('weaponSkin')
    if not mat then return end

    if weaponSkins.isBlacklisted(wep) or not cvar_enabled:GetBool() then
        viewmodel:SetSubMaterial(nil, mat)
    else
		local subs = weaponSkins.config.submaterials[wep:GetClass()]
		if subs then
			for _, v in ipairs(istable(subs) and subs or {subs}) do
				viewmodel:SetSubMaterial(v, mat)
			end
		else
			viewmodel:SetSubMaterial(0, mat)
		end
	    
    end
end)
--[[ 
local function getSorted()
	local a = {}
	local i = 1
	for k, v in SortedPairsByValue(weaponSkins.config.skins) do
		a[i] = {material = k, price = v}
		i = i + 1
	end
	return a
end
--]] 

function weaponSkins.preview(mat)
	local curSkins = LocalPlayer():GetNetVar('weaponSkin.list', {})
    local frame = vgui.Create('DFrame')
    frame:SetSize(400, 500)
    frame:ShowCloseButton(false)
    frame:MakePopup()
    frame:Center()
    frame:SetDraggable(false)
    frame:SetTitle('')

    frame.Paint = function( self, w, h )
		draw.RoundedBox( 6, 0, 0, w, h, f4menu.col.secondcolor )
	end
	

    local cl = vgui.Create('DButton', frame)
    cl:SetSize(50, 20)
    cl:SetPos(frame:GetWide() - 50, 0)
    cl:SetText('X')
    cl:SetFont('Default')
    cl:SetTextColor(color_white)
    cl.Paint = function( self, w, h )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol )
			
		if self:IsHovered() then
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol_hover )
		end
    end
    cl.DoClick = function()
        frame:Close()
    end
    cl.OnCursorEntered = function(self)
        self.hover = true
    end
    cl.OnCursorExited = function(self)
        self.hover = false
    end

    local combo = vgui.Create('DComboBox', frame)
    combo:Dock(TOP)
    combo:SetTall(25)

    local model = vgui.Create('DModelPanel', frame)
    model:Dock(FILL)
    
    local price = weaponSkins.config.skins[mat]
    if price then
    	local sorted = table.SortByKey(weaponSkins.config.skins, true)
    	local current = table.KeyFromValue(sorted, mat)
    	
        local buy = vgui.Create('DButton', model)
        buy:SetText(curSkins[mat] and 'Куплено' or DarkRP.formatMoney(weaponSkins.config.skins[mat]))
        buy:SetFont('f4.main')
        buy:SetTextColor(color_white)
        buy:SetSize(110, 35)
        buy.Paint = function( self, w, h )
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol )
			
			if self:IsHovered() then
				draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol_hover )
			end
		end
        buy:SetPos(frame:GetWide()/2 - buy:GetWide()/2, frame:GetTall()-buy:GetTall()-70)
        buy.OnCursorEntered = function( self )
			self.hover = true
		end
		buy.OnCursorExited = function( self )
			self.hover = false
		end
		
		local prev = vgui.Create('DButton', model)
		prev:SetText('<')
		prev:SetFont('f4.main')
		prev:SetTextColor(color_white)
		prev:SetSize(40,  35)
		prev:SetPos(frame:GetWide()/2 - buy:GetWide()/2 - prev:GetWide()-10, frame:GetTall()-prev:GetTall()-70)
		prev.Paint = function( self, w, h )
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol )
			
			if self:IsHovered() then
				draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol_hover )
			end
		end
        prev.OnCursorEntered = function( self )
			self.hover = true
		end
		prev.OnCursorExited = function( self )
			self.hover = false
		end
		prev.DoClick = function()
			current = current > 1 and current - 1 or 1
			mat = sorted[current]
			
			model.Entity:SetMaterial(mat)
			buy:SetText(curSkins[mat] and 'Куплено' or DarkRP.formatMoney(weaponSkins.config.skins[mat]))
		end
		
		local next = vgui.Create('DButton', model)
		next:SetText('>')
		next:SetFont('f4.main')
		next:SetTextColor(color_white)
		next:SetSize(40,  35)
		next:SetPos(frame:GetWide()/2 + buy:GetWide()/2 + 10, frame:GetTall()-next:GetTall()-70)
		next.Paint = function( self, w, h )
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol )
			
			if self:IsHovered() then
				draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol_hover )
			end
		end
        next.OnCursorEntered = function( self )
			self.hover = true
		end
		next.OnCursorExited = function( self )
			self.hover = false
		end
		next.DoClick = function()
			current = current < #sorted and current + 1 or #sorted
			mat = sorted[current]
			
			model.Entity:SetMaterial(mat)
			buy:SetText(curSkins[mat] and 'Куплено' or DarkRP.formatMoney(weaponSkins.config.skins[mat]))
		end
		
		buy.DoClick = function()
			if curSkins[mat] then return end
			Derma_Query( 'Ты действительно хочешь купить этот скин за '..DarkRP.formatMoney(weaponSkins.config.skins[mat])..'?', 'Покупка скина на оружие', 
				'Да', 
				function() 
					net.Start('weaponSkins.buy')
					net.WriteString(mat)
					net.SendToServer()
				end, 'Нет')
		end
	end

    combo.OnSelect = function()
        local _, data = combo:GetSelected()
        model:SetModel(data)
        model.Entity:SetMaterial(mat)

        min, max = model.Entity:GetRenderBounds()

        model:SetCamPos( Vector( 0.55, 0.55, 0.55 ) * min:Distance( max ) )
        model:SetLookAt( ( min + max ) / 2 )
    end

    for _, swep in ipairs(weapons.GetList()) do
        if swep.Category ~= 'Разрешено' then continue end
        combo:AddChoice(swep.PrintName, swep.WorldModel)
	end

    combo:ChooseOptionID(1)
end
--addons/_wlib/lua/wlib/libraries/fn.lua:
/*---------------------------------------------------------------------------
Functional library

by FPtje Atheos
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
Function currying
    Take a function with n parameters.
    Currying is the procedure of storing k < n parameters "in the function"
     in such a way that the remaining function can be called with n - k parameters

    Example:
    DebugPrint = fp{print, "[DEBUG]"}
    DebugPrint("TEST")
    > [DEBUG] TEST
---------------------------------------------------------------------------*/
function fp(tbl)
    local func = tbl[1]

    return function(...)
        local fnArgs = {}
        local arg = {...}
        local tblN = table.maxn(tbl)

        for i = 2, tblN do fnArgs[i - 1] = tbl[i] end
        for i = 1, table.maxn(arg) do fnArgs[tblN + i - 1] = arg[i] end

        return func(unpack(fnArgs, 1, table.maxn(fnArgs)))
    end
end

local unpack = unpack
local table = table
local pairs = pairs
local ipairs = ipairs
local error = error
local math = math
local select = select
local type = type
local _G = _G
local fp = fp


module("fn")

/*---------------------------------------------------------------------------
Parameter manipulation
---------------------------------------------------------------------------*/
Id = function(...) return ... end

Flip = function(f)
    if not f then error("not a function") end
    return function(b, a, ...)
        return f(a, b, ...)
    end
end

-- Definition from http://lua-users.org/wiki/CurriedLua
ReverseArgs = function(...)

   --reverse args by building a function to do it, similar to the unpack() example
   local function reverse_h(acc, v, ...)
      if select('#', ...) == 0 then
         return v, acc()
      else
         return reverse_h(function () return v, acc() end, ...)
      end
   end

   -- initial acc is the end of the list
   return reverse_h(function () return end, ...)
end

/*---------------------------------------------------------------------------
Misc functions
---------------------------------------------------------------------------*/
-- function composition
do
    local function comp_h(a, b, ...)
        if b == nil then return a end
        b = comp_h(b, ...)
        return function(...)
            return a(b(...))
        end
    end
    Compose = function(funcs, ...)
        if type(funcs) == "table" then
            return comp_h(unpack(funcs))
        else
            return comp_h(funcs, ...)
        end
    end
end

_G.fc = Compose

-- Definition from http://lua-users.org/wiki/CurriedLua
Curry = function(func, num_args)
    if not num_args then error("Missing argument #2: num_args") end
    if not func then error("Function does not exist!", 2) end
    -- helper
    local function curry_h(argtrace, n)
        if n == 0 then
            -- reverse argument list and call function
            return func(ReverseArgs(argtrace()))
        else
            -- "push" argument (by building a wrapper function) and decrement n
            return function(x)
                return curry_h(function() return x, argtrace() end, n - 1)
            end
        end
   end

   -- no sense currying for 1 arg or less
   if num_args > 1 then
      return curry_h(function() return end, num_args)
   else
      return func
   end
end

-- Thanks Lexic!
Partial = function(func, ...)
    local args = {...}
    return function(...)
        return func(unpack(table.Add( args, {...})))
    end
end

Apply = function(f, ...) return f(...) end

Const = function(a, b) return a end
Until = function(cmp, fn, val)
    if cmp(val) then
        return val
    end
    return Until(cmp, fn, fn(val))
end

Seq = function(f, x) f(x) return x end

GetGlobalVar = function(key) return _G[key] end

/*---------------------------------------------------------------------------
Mathematical operators and functions
---------------------------------------------------------------------------*/
Add = function(a, b) return a + b end
Sub = function(a, b) return a - b end
Mul = function(a, b) return a * b end
Div = function(a, b) return a / b end
Mod = function(a, b) return a % b end
Neg = function(a)    return -a    end

Eq  = function(a, b) return a == b end
Neq = function(a, b) return a ~= b end
Gt  = function(a, b) return a > b  end
Lt  = function(a, b) return a < b  end
Gte = function(a, b) return a >= b end
Lte = function(a, b) return a <= b end

Succ = Compose{Add, 1}
Pred = Compose{Flip(Sub), 1}
Even = Compose{fp{Eq, 0}, fp{Flip(Mod), 2}}
Odd  = Compose{Not, Even}

/*---------------------------------------------------------------------------
Functional logical operators and conditions
---------------------------------------------------------------------------*/
FAnd = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if not val[1] then return unpack(val) end
        end
        if val then return unpack(val) end
    end
end

FOr = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if val[1] then return unpack(val) end
        end
        return false, unpack(val, 2)
    end
end

Not = function(x) return not x end

If = function(f, Then, Else)
    return function(x)
        if f(x) then
            return Then
        else
            return Else
        end
    end
end

/*---------------------------------------------------------------------------
List operations
---------------------------------------------------------------------------*/
Map = function(f, xs)
    for k, v in pairs(xs) do
        xs[k] = f(v)
    end
    return xs
end

Append = function(xs, ys)
    return table.Add(xs, ys)
end

Filter = function(f, xs)
    local res = {}
    for k,v in pairs(xs) do
        if f(v) then res[k] = v end
    end
    return res
end

ForEach = function(f, xs)
    for k,v in pairs(xs) do
        local val = f(k, v)
        if val ~= nil then return val end
    end
end

Head = function(xs)
    return table.GetFirstValue(xs)
end

Last = function(xs)
    return xs[#xs] or table.GetLastValue(xs)
end

Tail = function(xs)
    table.remove(xs, 1)
    return xs
end

Init = function(xs)
    xs[#xs] = nil
    return xs
end

GetValue = function(i, xs)
    return xs[i]
end

Null = function(xs)
    for k, v in pairs(xs) do
        return false
    end
    return true
end

Length = function(xs)
    return #xs
end

Index = function(xs, i)
    return xs[i]
end

Reverse = function(xs)
    local res = {}
    for i = #xs, 1, -1 do
        res[#xs - i + 1] = xs[i]
    end
    return res
end

/*---------------------------------------------------------------------------
Folds
---------------------------------------------------------------------------*/
Foldr = function(func, val, xs)
    for i = #xs, 1, -1 do
        val = func(xs[i], val)
    end

    return val
end

Foldl = function(func, val, xs)
    for k, v in ipairs(xs) do
        val = func(val, v)
    end

    return val
end

And = function(xs)
    for k, v in pairs(xs) do
        if v ~= true then return false end
    end
    return true
end

Or = function(xs)
    for k, v in pairs(xs) do
        if v == true then return true end
    end
    return false
end

Any = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) == true then return true end
    end
    return false
end

All = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) ~= true then return false end
    end
    return true
end

Sum = _G.fp{Foldr, Add, 0}

Product = _G.fp{Foldr, Mul, 1}

Concat = _G.fp{Foldr, Append, {}}

Maximum = _G.fp{Foldl, math.Max, -math.huge}

Minimum = _G.fp{Foldl, math.Min, math.huge}

Snd = _G.fp{select, 2}

Thrd = _G.fp{select, 3}

--addons/_wlib/lua/wlib/modules/afk/client.lua:
local timeout = 1 * 60
local lastpress = CurTime()
local unfocused = false

timer.Create('AFKTick', 1, 0, function()
	local hasFocus = system.HasFocus()
	if hasFocus and unfocused then
		unfocused = false
		net.Start('UpdateAFK')
		net.WriteBool(false)
		net.SendToServer()
		return
	end

	if not LocalPlayer().IsAFK or LocalPlayer():IsAFK() then return end

	if not hasFocus then
		unfocused = true
		net.Start('UpdateAFK')
			net.WriteBool(true)
		net.SendToServer()
	elseif CurTime() - lastpress > timeout then
		net.Start('UpdateAFK')
			net.WriteBool(true)
		net.SendToServer()
	end
end)

hook.Add('PlayerButtonDown', 'AFKTick', function( ply )
	local lp = LocalPlayer()
	if ply ~= lp then return end

	lastpress = CurTime()
	if ply:IsAFK() then
		net.Start('UpdateAFK')
			net.WriteBool(false)
		net.SendToServer()
	end
end)
--addons/_wlib/lua/wlib/modules/chat/client.lua:
local isTyping = false
local function setTyping(b)
    if isTyping == b then return end
    isTyping = b
    net.Start('wlib.chat.updateTyping')
    net.WriteBool(b)
    net.SendToServer()
end

hook.Add('FinishChat', 'updateTyping', function()
    setTyping(false)
end)

hook.Add('ChatTextChanged', 'updateTyping', function(text)
    if text == '' then
        setTyping(false)
    else
        setTyping(true)
    end
end)

net.Receive('wlib.chat.addText', function()
    local args = {}

    for i=1, net.ReadUInt(8) do
        table.insert(args, net.ReadBool() and net.ReadColor() or net.ReadString())
    end

    chat.AddText(unpack(args))
    chat.PlaySound()
end)

function wlib.chat.say(...)
    local args = table.concat({...}, ' ')
    
    net.Start('wlib.chat.say')
    net.WriteString(args)
    net.SendToServer()
end
--addons/_wlib/lua/wlib/modules/http.lua:
if not file.Exists('wimages', 'DATA') then
    file.CreateDir('wimages')
end

local cache = {}
local queue = {}
local callbacks = {}
local downloading = false
local mat_error = Material('error')

local uid = 1

function http.DownloadMaterial(url, name, cb, ignorequeue)
    assert(isstring(url), 'URL must be a string')
    cb = cb or wlib.func.blank
    uid = uid + 1

    if cache[url] then return cb(cache[url]) end
    
    local path = 'wimages/' .. (name or uid..'.png')
    if name then
        if file.Exists(path, 'DATA') then
            cache[url] = Material('data/'..path)
            return cb(cache[url])
        end
    end

    local download = function()
        downloading = true
        http.Fetch(url, function(img)
            if not isstring(img) or img:find('<!DOCTYPE HTML>', 1, true) then return cb(mat_error) end
    
            file.Write(path, img)
            cache[url] = Material('data/'..path)

            for _, v in ipairs(callbacks[url]) do
                v(cache[url])
            end
            queue[url] = nil
            callbacks[url] = nil
    
            if not name then
                file.Delete(path, 'DATA')
            end
            downloading = false
        end, function()
            downloading = false
            queue[url] = nil
        end)
    end

    queue[url] = download
    callbacks[url] = callbacks[url] or {}
    table.insert(callbacks[url], cb)

    if ignorequeue then return download() end

    if not timer.Exists('wlib_downloadmaterial') then
        timer.Create('wlib_downloadmaterial', .1, 0, function()
            local url = next(queue)
            if not url then return timer.Remove('wlib_downloadmaterial') end

            if not downloading then queue[url]() end
        end)
    end
end
--addons/_wlib/lua/wlib/modules/incognito/client.lua:
local pmeta = FindMetaTable('Player')

hook.Add('Think', 'wlib.incognito.cl', function()
    hook.Remove('Think', 'wlib.incognito.cl')
    timer.Simple(1, function()
        pmeta.Name = pmeta.DisplayName
        pmeta.GetName = pmeta.DisplayName
        pmeta.Nick = pmeta.DisplayName

        pmeta.SteamName = pmeta.DisplaySteamName
    
        pmeta.GetUserGroup = pmeta.GetDisplayUserGroup
    
        pmeta.SteamID = pmeta.DisplaySteamID
        pmeta.SteamID64 = pmeta.DisplaySteamID64

        pmeta.GetUTime = pmeta.GetDisplayUTime
        pmeta.GetUTimeStart = pmeta.GetDisplayUTimeStart
        pmeta.GetUTimeSessionTime = pmeta.GetDisplayUTimeSessionTime
        pmeta.GetUTimeTotalTime = pmeta.GetDisplayUTimeTotalTime
        
        pmeta.GetMainOrgID = pmeta.GetDisplayMainOrgID

        local voicenotify = vgui.GetControlTable('VoiceNotify')
        if voicenotify then
            voicenotify.Setup = function(self, ply)
                self.ply = ply
                self.LabelName:SetText(ply:Nick())
                self.Avatar:SetSteamID(ply:SteamID64(), 32)
                
                self.Color = team.GetColor(ply:Team())
                
                self:InvalidateLayout()
            end
        end

        pmeta.GetRealFriendStatus = pmeta.GetRealFriendStatus or pmeta.GetFriendStatus
        pmeta.GetFriendStatus = function(self)
            if self:GetNetVar('Incognito') then return 'none' end

            return self:GetRealFriendStatus()
        end
    end)
end)
--addons/_wlib/lua/wlib/modules/_client/icons.lua:
wlib.icons = wlib.icons or {}

wlib.icons.keys = {
    [KEY_E] = 'icon72/key_e.png',
    [KEY_R] = 'icon72/key_r.png',
    [KEY_M] = 'icon72/key_m.png',
    [KEY_LSHIFT] = 'icon72/key_shift.png',
    [MOUSE_LEFT] = 'icon72/key_lkm.png',
    [MOUSE_RIGHT] = 'icon72/key_pkm.png',
}

wlib.icons.keysMaterials = wlib.icons.keysMaterials or {}

function wlib.icons.getKeyPath(key)
    return wlib.icons.keys[key]
end

function wlib.icons.getKey(key)
    if wlib.icons.keysMaterials[key] then return wlib.icons.keysMaterials[key] end

    local path = wlib.icons.getKeyPath(key)
    if not path then return end

    local mat = Material(path)

    wlib.icons.keysMaterials[key] = mat
    return mat
end
--addons/_wlib/lua/wlib/vgui/viewpanel.lua:
local PANEL = {}

function PANEL:Init()
    self.origin = LocalPlayer():GetPos()
    self.angles = LocalPlayer():GetAngles()
    self.fov = 60
    self.canMove = true
    self.speed = 5

    self.mx = self:GetWide() * 0.5
    self.my = self:GetTall() * 0.5
end

AccessorFunc(PANEL, 'origin', 'Origin')
AccessorFunc(PANEL, 'angles', 'Angles')
AccessorFunc(PANEL, 'fov', 'FOV')
AccessorFunc(PANEL, 'canMove', 'CanMove')
AccessorFunc(PANEL, 'speed', 'Speed')

function PANEL:ValidateOrigin(origin)
end

function PANEL:Paint(w,h)
    local x, y = self:GetParent():LocalToScreen(self:GetPos())

    render.RenderView({
        origin = self:GetOrigin(),
        angles = self:GetAngles(),
        x = x,
        y = y,
        w = w,
        h = h,
        fov = self:GetFOV(),
        drawviewmodel = false,
        aspect = self:GetWide() / self:GetTall(),
    })
end

function PANEL:OnMousePressed(mousecode)
	self:MouseCapture(true)
	self.Capturing = true
	self.MouseKey = mousecode

	self:CaptureMouse()
end

function PANEL:OnMouseReleased()
	self:MouseCapture(false)
	self.Capturing = false
end

function PANEL:OnMouseWheeled(delta)
    local fov = math.Clamp(self:GetFOV() - delta * 5, 20, 140)
    self:SetFOV(fov)
end

function PANEL:Think()
    if not self:GetCanMove() then return end

	if ( !self.Capturing ) then return end

	return self:FirstPersonControls()
end

function PANEL:CaptureMouse()
	local x, y = input.GetCursorPos()

	local dx = x - self.mx
	local dy = y - self.my

	local centerx, centery = self:LocalToScreen( self:GetWide() * 0.5, self:GetTall() * 0.5 )
	input.SetCursorPos(centerx, centery)
	self.mx = centerx
	self.my = centery

	return dx, dy
end

function PANEL:FirstPersonControls()
	local x, y = self:CaptureMouse()

	local scale = self:GetFOV() / 180
	x = x * -0.5 * scale
	y = y * 0.5 * scale

	if (self.MouseKey == MOUSE_LEFT) then
        self:SetAngles(self:GetAngles() + Angle(y * 4, x * 4, 0))
	end

	-- Look around
	--self.aLookAngle = self.aLookAngle + Angle( y, x, 0 )

	local Movement = Vector(0,0,0)

	-- TODO: Use actual key bindings, not hardcoded keys.
	if ( input.IsKeyDown( KEY_W ) || input.IsKeyDown( KEY_UP ) ) then Movement = Movement + self:GetAngles():Forward() end
	if ( input.IsKeyDown( KEY_S ) || input.IsKeyDown( KEY_DOWN ) ) then Movement = Movement - self:GetAngles():Forward() end
	if ( input.IsKeyDown( KEY_A ) || input.IsKeyDown( KEY_LEFT ) ) then Movement = Movement - self:GetAngles():Right() end
	if ( input.IsKeyDown( KEY_D ) || input.IsKeyDown( KEY_RIGHT ) ) then Movement = Movement + self:GetAngles():Right() end
	if ( input.IsKeyDown( KEY_SPACE ) ) then Movement = Movement + self:GetAngles():Up() end
	if ( input.IsKeyDown( KEY_LCONTROL ) ) then Movement = Movement - self:GetAngles():Up() end

	local speed = input.IsShiftDown() and self.speed * 3 or self.speed
    local newPos = self:GetOrigin() + Movement * speed

    if self:ValidateOrigin(newPos) == false then return end

	self:SetOrigin(newPos)
end

vgui.Register('DViewPanel', PANEL, 'DPanel')
--addons/module_scoreboard/lua/wayscore/util.lua:
function wayscore:AddView(name, p)
    p = isstring(p) and vgui.Create(p) or p

    p:SetParent(self.frame)
    p:Dock(NODOCK)
    p:SetVisible(false)

    self.views[name] = p
end

function wayscore:SelectView(view, ...)
    if not IsValid(self.frame) then self:Open() end
    if not self.views[view] then return end

    self.view = view
    self.viewData = {...}

    for k, v in pairs(self.views) do
        if k == view then
            v:SetParent(self.frame)
            v:Dock(FILL)
            v:SetVisible(true)
            if v.Select then v:Select(...) end
        else
            v:Dock(NODOCK)
            v:SetVisible(false)
        end
    end
end

-- Не думал, что до такого дойдет
local rus_alp = {
    ['а'] = 'А', ['б'] = 'Б', ['в'] = 'В', ['г'] = 'Г', ['д'] = 'Д', ['е'] = 'Е',
    ['ё'] = 'Ё', ['ж'] = 'Ж', ['з'] = 'З', ['и'] = 'И', ['й'] = 'Й', ['к'] = 'К',
    ['л'] = 'Л', ['м'] = 'М', ['н'] = 'Н', ['о'] = 'О', ['п'] = 'П', ['р'] = 'Р',
    ['с'] = 'С', ['т'] = 'Т', ['у'] = 'У', ['ф'] = 'Ф', ['х'] = 'Х', ['ц'] = 'Ц',
    ['ч'] = 'Ч', ['ш'] = 'Ш', ['щ'] = 'Щ', ['ъ'] = 'Ъ', ['ы'] = 'Ы', ['ь'] = 'Ь',
    ['э'] = 'Э', ['ю'] = 'Ю', ['я'] = 'Я',
}

function wayscore.upper(str)
    local res = str:upper():gsub(utf8.charpattern, rus_alp)
    return res
end

local rus_alp_lower = {
    ['А'] = 'а', ['Б'] = 'б', ['В'] = 'в', ['Г'] = 'г', ['Д'] = 'д', ['Е'] = 'е',
    ['Ё'] = 'ё', ['Ж'] = 'ж', ['З'] = 'з', ['И'] = 'и', ['Й'] = 'й', ['К'] = 'к',
    ['Л'] = 'л', ['М'] = 'м', ['Н'] = 'н', ['О'] = 'о', ['П'] = 'п', ['Р'] = 'р',
    ['С'] = 'с', ['Т'] = 'т', ['У'] = 'у', ['Ф'] = 'ф', ['Х'] = 'х', ['Ц'] = 'ц',
    ['Ч'] = 'ч', ['Ш'] = 'ш', ['Щ'] = 'щ', ['Ъ'] = 'ъ', ['Ы'] = 'ы', ['Ь'] = 'ь',
    ['Э'] = 'э', ['Ю'] = 'ю', ['Я'] = 'я',
}

function wayscore.lower(str)
    local res = str:lower():gsub(utf8.charpattern, rus_alp_lower)
    return res
end

function wayscore.AddInfo(id, data)
    data.id = id
    local _, index = wlib.array.find(wayscore.Information, function(val) return val.id == id end)
    if index then
        wayscore.Information[index] = data
    else
        table.insert(wayscore.Information, data)
    end
end

function wayscore.AddActionButton(id, data)
    data.id = id
    local _, index = wlib.array.find(wayscore.ActionButtons, function(val) return val.id == id end)
    if index then
        wayscore.ActionButtons[index] = data
    else
        table.insert(wayscore.ActionButtons, data)
    end
end

function wayscore.PortActions()
    local i = 1
    for _, v in ipairs(FAdmin and FAdmin.ScoreBoard and FAdmin.ScoreBoard.Player.ActionButtons or {}) do
        wayscore.AddActionButton(i, {
            name = v.Name,
            icon = v.Image,
            color = v.color,
            check = isfunction(v.Visible) and v.Visible,
            callback = v.Action,
            onCreated = v.OnButtonCreated,
            order = i,
        })
        i = i+1
    end
    i = 1
    for _, v in ipairs(FAdmin and FAdmin.ScoreBoard and FAdmin.ScoreBoard.Player.Information or {}) do
        wayscore.AddInfo(i, {
            name = v.name,
            get = v.func,
            newPanel = v.NewPanel,
        })
        i = i+1
    end
end

timer.Simple(0, function()
    wayscore.PortActions()
end)

--

wayscore.AddInfo('name', {
    name = 'Имя',
    get = function(ply) return ply:Name() end,
    order = 1000,
})
--[[
wayscore.AddInfo('kills', {
    name = 'Убийств',
    get = function(ply) return ply:Frags() end,
    order = 2000,
})
wayscore.AddInfo('deaths', {
    name = 'Смертей',
    get = function(ply) return ply:Deaths() end,
    order = 3000,
})
]]
wayscore.AddInfo('steamid', {
    name = 'SteamID',
    get = function(ply) return ply:SteamID() end,
    order = 4000,
})

wayscore.AddActionButton('friend', {
    name = function(ply) return FPP.Buddies[ply:SteamID()] and 'Удалить из друзей' or 'Добавить в друзья' end,
    icon = function(ply) return 'icon72/two_hearts.png', FPP.Buddies[ply:SteamID()] and 'fadmin/icons/disable' end,
    order = -2000,
    rightClick = true,
    check = function(ply) return ply ~= LocalPlayer() end,
    callback = function(ply, btn)
        local val = FPP.Buddies[ply:SteamID()] and 0 or 1
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'physgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'gravgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'toolgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'playeruse',    val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'entitydamage', val)

        if val == 0 then
            btn:SetText('Добавить в друзья')
            btn:SetImage2('null')
            btn:GetParent():InvalidateLayout()
        else
            btn:SetText('Удалить из друзей')
            btn:SetImage2('fadmin/icons/disable')
            btn:GetParent():InvalidateLayout()
        end
    end,
})

wayscore.AddActionButton('pm', {
    name = 'Сообщение',
    icon = 'icon72/speech_balloon.png',
    order = -1500,
    rightClick = true,
    check = function(ply) return ply ~= LocalPlayer() end,
    callback = function(ply, btn)
        Derma_StringRequest('Сообщение', 'Введи ниже сообщение, которое хочешь отправить', '', function(text)
            RunConsoleCommand('darkrp', 'pm', ply:UserID(), text)
        end)
    end,
})
--addons/module_scoreboard/lua/wayscore/vgui/button.lua:
local PANEL = {}

function PANEL:Init()
    self:SetDrawBackground(false)
    self:SetDrawBorder(false)
    self:SetStretchToFit(false)
    self:SetSize(120, 40)

    self.TextLabel = vgui.Create("DLabel", self)
    self.TextLabel:SetColor(color_white)
    self.TextLabel:SetFont("wayscore.small")

    self.m_Image2 = vgui.Create("DImage", self)

    self.BorderColor = Color(190,40,0,255)

    self.FontColor = Color( 236, 240, 241)
    self.BackgroundColor = Color(48, 48, 48)
end

function PANEL:SetData(v, ply)
    local imageType = TypeID(v.icon)

    if imageType == TYPE_STRING then
        self:SetImage(v.icon or 'icon16/exclamation')
    elseif imageType == TYPE_TABLE then
        self:SetImage(v.icon[1])

        if v.icon[2] then
            self:SetImage2(v.icon[2])
        end
    elseif imageType == TYPE_FUNCTION then
        local img1, img2 = v.icon(ply)
        self:SetImage(img1)

        if img2 then
            self:SetImage2(img2)
        end
    else
        self:SetImage('icon16/exclamation')
    end

    local name = v.name

    if isfunction(name) then
        name = name(ply)
    end

    self:SetText(DarkRP.deLocalise(name))
    self:SetBorderColor(v.color)
end

function PANEL:SetText(text)
    self.TextLabel:SetText(text)
    self.TextLabel:SizeToContents()

    self:SetWide(self.TextLabel:GetWide() + 44)
end

function PANEL:PerformLayout()
    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)

    self.m_Image2:SetSize(32, 32)
    self.m_Image2:SetPos(4,4)

    self.TextLabel:SetPos(38, 8)
end

function PANEL:SetImage2(Mat, bckp)
    self.m_Image2:SetImage(Mat, bckp)
end

function PANEL:SetBorderColor(Col)
    self.BorderColor = Col or Color(190,40,0,255)
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, self:GetWide(), self:GetTall(), Color(32, 36, 46, 255))
    draw.RoundedBox(4, 2, 2, self:GetWide() - 4, self:GetTall() - 4, self.BackgroundColor)
end

function PANEL:OnMousePressed(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(24,24)
    self.m_Image:SetPos(8,8)
    self.Depressed = true
end

function PANEL:OnMouseReleased(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)
    self.Depressed = false
    self:DoClick()
end

vgui.Register('wayscore_button', PANEL, 'DImageButton')
--addons/tool_duplicator/lua/advdupe2/cl_file.lua:
local function AdvDupe2_ReceiveFile(len, ply)
	local AutoSave = net.ReadUInt(8) == 1

	net.ReadStream(nil, function(data)
		AdvDupe2.RemoveProgressBar()
		if(!data)then
			AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
			return
		end
		local path
		if AutoSave then
			if(LocalPlayer():GetInfo("advdupe2_auto_save_overwrite")~="0")then
				path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath, true)
			else
				path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath)
			end
		else
			path = AdvDupe2.GetFilename(AdvDupe2.SavePath)
		end

		local dupefile = file.Open(path, "wb", "DATA")
		if(!dupefile)then
			AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
			return
		end
		dupefile:Write(data)
		dupefile:Close()
		
		local errored = false
		if(LocalPlayer():GetInfo("advdupe2_debug_openfile")=="1")then
			if(not file.Exists(path, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end
			
			local readFile = file.Open(path, "rb", "DATA")
			if not readFile then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
			local readData = readFile:Read(readFile:Size())
			readFile:Close()
			local success,dupe,info,moreinfo = AdvDupe2.Decode(readData)
			if(success)then
				AdvDupe2.Notify("DEBUG CHECK: File successfully opens. No EOF errors.")
			else
				AdvDupe2.Notify("DEBUG CHECK: " .. dupe, NOTIFY_ERROR)
				errored = true
			end
		end
		
		local filename = string.StripExtension(string.GetFileFromFilename( path ))
		if(AutoSave)then
			if(IsValid(AdvDupe2.FileBrowser.AutoSaveNode))then
				local add = true
				for i=1, #AdvDupe2.FileBrowser.AutoSaveNode.Files do
					if(filename==AdvDupe2.FileBrowser.AutoSaveNode.Files[i].Label:GetText())then
						add=false
						break
					end
				end
				if(add)then
					AdvDupe2.FileBrowser.AutoSaveNode:AddFile(filename)
					AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.AutoSaveNode)
				end
			end
		else
			AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode:AddFile(filename)
			AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode)
		end
		if(!errored)then
			AdvDupe2.Notify("File successfully saved!",NOTIFY_GENERIC, 5)
		end
	end)
end
net.Receive("AdvDupe2_ReceiveFile", AdvDupe2_ReceiveFile)

local uploading = nil
function AdvDupe2.UploadFile(ReadPath, ReadArea)
	if uploading then AdvDupe2.Notify("Already opening file, please wait.", NOTIFY_ERROR) return end
	if(ReadArea==0)then
		ReadPath = AdvDupe2.DataFolder.."/"..ReadPath..".txt"
	elseif(ReadArea==1)then
		ReadPath = AdvDupe2.DataFolder.."/-Public-/"..ReadPath..".txt"
	else
		ReadPath = "adv_duplicator/"..ReadPath..".txt"
	end
	
	if(not file.Exists(ReadPath, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end
	
	local read = file.Read(ReadPath)
	if not read then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
	local name = string.Explode("/", ReadPath)
	name = name[#name]
	name = string.sub(name, 1, #name-4)
	
	local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
	if(success)then
		net.Start("AdvDupe2_ReceiveFile")
		net.WriteString(name)
		uploading = net.WriteStream(read, function()
			uploading = nil
			AdvDupe2.File = nil
			AdvDupe2.RemoveProgressBar()
		end)
		net.SendToServer()
		
		AdvDupe2.LoadGhosts(dupe, info, moreinfo, name)
	else
		AdvDupe2.Notify("File could not be decoded. ("..dupe..") Upload Canceled.", NOTIFY_ERROR)
	end
end

--addons/module_outfitter/lua/autorun/client/chat_commands_cl.lua:
-- Example: list.Set("ChatCommands","test",function(paramstr,msg) PrintTable{paramstr,msg} return true end)

local cmds={["!"]=true,["\\"]=true,["/"]=true,["."]=true}
local disable_legacy,disable_legacy2
local function Parse(pl,msg)
	if not cmds[msg:sub(1,1)] then return end
	local pos=string.find(msg," ",1,true)

	local com,paramstr
	if pos then
		com,paramstr=msg:sub(2,pos-1),msg:sub(pos+1,-1)
	else
		com=msg:sub(2,-1)
		paramstr=""
	end

	local ret = hook.Run("ChatCommand",com,paramstr,msg)
	if ret==true then return ret end
	if ret==false then return end
	
	local commands = list and list.GetForEdit("ChatCommands")
	local command = commands[com] or commands[com:lower()]
	
	if command then
		local ok,ret = xpcall(command,debug.traceback,paramstr,msg)
		if not ok then ErrorNoHalt(("%s\n"):format(ret)) end
		if ret==true then return ret end
		if ret==false then return end
	end
	
end

hook.Add("OnPlayerChat","ChatCommand",function(pl,msg)
	if pl~=LocalPlayer() then return end
	return Parse(pl,msg)
end)

hook.Add("PlayerSay","ChatCommand",function(pl,msg)
	if pl~=LocalPlayer() then return end
	if not disable_legacy then
		hook.Remove("OnPlayerChat","ChatCommand")
		disable_legacy =  true
	end

	return Parse(pl,msg)
end)

-- For custom chatboxes
hook.Add("OnClientChatCommand","ChatCommand",function(...)
	if not disable_legacy2 then
		hook.Remove("PlayerSay","ChatCommand")
		hook.Remove("OnPlayerChat","ChatCommand")
		disable_legacy2 = true
	end	
	return Parse(...)
end)

--addons/_smallscripts/lua/autorun/client/cl_2d.lua:
net.Receive("Set2DPlayer", function()
	local ply = LocalPlayer()
	local a = ply:LookupBone("ValveBiped.Bip01_Head1")
	local b = ply:LookupBone("ValveBiped.Bip01_R_Thigh")
	local c = ply:LookupBone("ValveBiped.Bip01_L_Thigh")
	local d = ply:LookupBone("ValveBiped.Bip01_R_Calf")
	local e = ply:LookupBone("ValveBiped.Bip01_L_Calf")
	local f = ply:LookupBone("ValveBiped.Bip01_R_UpperArm")
	local g = ply:LookupBone("ValveBiped.Bip01_L_UpperArm")
	local h = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
	local i = ply:LookupBone("ValveBiped.Bip01_L_Forearm")
	local j = ply:LookupBone("ValveBiped.Bip01_R_Clavicle")
	local k = ply:LookupBone("ValveBiped.Bip01_L_Clavicle")

  for k,v in player.Iterator() do
    v:ManipulateBoneScale( a, Vector(4,0,4))
    v:ManipulateBoneScale( b, Vector(0,0,0))
    v:ManipulateBoneScale( c, Vector(0,0,0))
    v:ManipulateBoneScale( d, Vector(0,0,1))
    v:ManipulateBoneScale( e, Vector(0,0,1))
    v:ManipulateBoneScale( f, Vector(0,0,0))
    v:ManipulateBoneScale( g, Vector(0,0,0))
    v:ManipulateBoneScale( h, Vector(1,1.5,1.5))
    v:ManipulateBoneScale( i, Vector(1,1.5,1.5))
    v:ManipulateBoneScale( j, Vector(0,0,0))
    v:ManipulateBoneScale( k, Vector(0,0,0))
  end

  timer.Simple(300, function()
		for k,v in player.Iterator() do
			v:ManipulateBoneScale( a, Vector(1,1,1))
			v:ManipulateBoneScale( b, Vector(1,1,1))
			v:ManipulateBoneScale( c, Vector(1,1,1))
			v:ManipulateBoneScale( d, Vector(1,1,1))
			v:ManipulateBoneScale( e, Vector(1,1,1))
			v:ManipulateBoneScale( f, Vector(1,1,1))
			v:ManipulateBoneScale( g, Vector(1,1,1))
			v:ManipulateBoneScale( h, Vector(1,1,1))
			v:ManipulateBoneScale( i, Vector(1,1,1))
			v:ManipulateBoneScale( j, Vector(1,1,1))
			v:ManipulateBoneScale( k, Vector(1,1,1))
		end
  end)
end)
--addons/module_apg/lua/apg/cl_menu.lua:
--[[------------------------------------------

    A.P.G. - a lightweight Anti Prop Griefing solution (v{{ script_version_name }})
    Made by :
    - While True (http://steamcommunity.com/id/76561197972967270)
    - LuaTenshi (http://steamcommunity.com/id/76561198096713277)

    Licensed to : http://steamcommunity.com/id/{{ user_id }}

]]--------------------------------------------
APG_panels = APG_panels or {}

local utils = include( "cl_utils.lua" ) or { }

local function APGBuildStackPanel()
    local panel = APG_panels["stack_detection"]
    panel.Paint = function( i, w, h) end

    utils.numSlider(panel, 0, 40, 500, 20, "Maximum stacked ents", "stackMax", 3, 50, 0 )
    utils.numSlider(panel, 0, 75, 500, 20, "Stack distance (gmod units)", "stackArea", 5, 50, 0)
end

local function APGBuildMiscPanel()
    local panel = APG_panels["misc"]
    panel.Paint = function( i, w, h) end

    utils.switch( panel, 0, 40, 395, 20, "Auto freeze over time", "autoFreeze" )
    utils.numSlider(panel, 0, 70, 500, 20, "Auto freeze delay(seconds)", "autoFreezeTime", 5, 600, 0 )
    utils.switch( panel, 0, 100, 395, 20, "Disable vehicle damages", "vehDamage" )
    utils.switch( panel, 0, 130, 395, 20, "Disable vehicle collisions (with players)", "vehNoCollide" )
    utils.switch( panel, 0, 160, 395, 20, "Block Physgun Reload", "blockPhysgunReload" )
    utils.switch( panel, 0, 190, 395, 20, "Block players from moving contraptions", "blockContraptionMove" )
    --APG_numSlider(panel, 0, 75, 500, 20, "Vehicle NoCollide", "vehNoCollide", 5, 50, 0)
end

local function APGBuildLagPanel()
    local panel = APG_panels["lag_detection"]
    panel.Paint = function( i, w, h) end

    utils.numSlider(panel, 0, 40, 500, 20, "Lag threshold (%)", "lagTrigger", 5, 1000, 0 )
    utils.numSlider(panel, 0, 75, 500, 20, "Frames lost", "lagsCount", 1, 20, 0)
    utils.numSlider(panel, 0, 110, 500, 20, "Heavy lag trigger (seconds)", "bigLag", 1, 5, 1)
    utils.comboBox(panel, 0, 145, 500, 20, "Lag fix function", "lagFunc", APG_lagFuncs)
    utils.numSlider(panel, 0, 180, 500, 20, "Lag func. delay (seconds)", "lagFuncTime", 1, 300, 0)
    --utils.numSlider(panel, 0, 215, 500, 20, "Notification mode ", "lagFuncNotify", 0, 2, 0)
end

local function APGBuildToolHackPanel()
    local panel = APG_panels["misc2"]
    panel.Paint = function( i, w, h) end

    utils.switch( panel, 0, 40, 395, 20, "Inject custom hooks into Fading Doors", "thFadingDoors" )
    utils.switch( panel, 0, 75, 395, 20, "Activate FRZR9K (Sleepy Physics)", "sleepyPhys" )
    utils.switch( panel, 0, 110, 395, 20, "Hook FRZR9K into collision (Experimental)", "hookSP" )
    utils.switch( panel, 0, 145, 395, 20, "Allow prop killing", "allowPK" )
end

local function APGBuildGhostPanel()
    local panel = APG_panels["ghosting"]
    panel.Paint = function( i, w, h)
        draw.RoundedBox(0,0,37,170,135,Color( 38, 38, 38, 255))
        draw.DrawText( "Ghosting color:", "APG_element_font",5, 37, Color( 189, 189, 189), 3 )

        draw.RoundedBox(0,175,37,250,250,Color( 38, 38, 38, 255))
        draw.DrawText( "Bad entities:", "APG_element_font", 180, 37, Color( 189, 189, 189), 3 )
        draw.DrawText( "(Right-Click to Toggle)", "APG_title2_font", 280, 38, Color( 189, 189, 189), 3 )
    end
    utils.switch( panel, 0, 180, 170, 20, "Always frozen", "alwaysFrozen" )
    utils.switch( panel, 0, 215, 170, 20, "Apply to doors", "fadingDoorGhosting" )
    utils.switch( panel, 0, 250, 170, 20, "Ignore Vehicles", "dontGhostVehicles" )

    local Mixer = vgui.Create( "CtrlColor", panel )
    Mixer:SetPos(5,55)
    Mixer:SetSize(160,110)
    Mixer.Mixer.ValueChanged = function(self,color)
        APG.cfg["ghost_color"].value = Color( color.r, color.g, color.b, color.a)
    end

    local dList = vgui.Create("DListView", panel)
    dList:Clear()
    dList:SetPos( 180, 55 )
    dList:SetSize(panel:GetWide() - 185, panel:GetTall()-5-55)
    dList:SetMultiSelect(false)
    dList:SetHideHeaders(false)
    dList:AddColumn("Class")
    dList:AddColumn("Exact")

    function dList:OnRowRightClick( id, line )
        local key = line:GetColumnText(1)
        local value = !tobool(line:GetColumnText(2))
        line:SetColumnText(2, value)
        APG.cfg["bad_ents"].value[key] = value
    end

    local function updtTab()
        dList:Clear()
        for class,complete in pairs(APG.cfg["bad_ents"].value) do
            dList:AddLine(class, complete)
        end
    end
    updtTab()

    dList.Paint = function(i,w,h)
        draw.RoundedBox(0,0,0,w,h,Color(150, 150, 150, 255))
    end
    dList.VBar.Paint = function(i,w,h)
        surface.SetDrawColor(88, 110, 110, 240)
        surface.DrawRect(0,0,w,h)
    end
    dList.VBar.btnGrip.Paint = function(i,w,h)
        surface.SetDrawColor(255, 83, 13,50)
        surface.DrawRect(0,0,w,h)
        draw.RoundedBox( 0, 1,1,w-2,h-2, Color( 72, 89, 89, 255 ) )
    end
    dList.VBar.btnUp.Paint = function(i,w,h)
        draw.RoundedBox( 0, 0,0,w,h, Color( 72, 89, 89, 240 ) )
    end
    dList.VBar.btnDown.Paint = function(i,w,h)
        draw.RoundedBox( 0, 0,0,w,h, Color( 72, 89, 89, 240 ) )
    end

    local TextEntry = vgui.Create( "DTextEntry", panel )
    TextEntry:SetPos( 180, 240 )
    TextEntry:SetSize( 150,20 )
    TextEntry:SetText( "Entity class" )
    TextEntry.OnEnter = function( self )
        chat.AddText( self:GetValue() )
    end

    local Add = vgui.Create( "DButton" , panel)
    Add:SetPos( 320, 240 )
    Add:SetSize( 75,20 )
    Add:SetText( "Add" )
    Add.DoClick = function()
        if TextEntry:GetValue() == "Entity class" then return end
        utils.addBadEntity( TextEntry:GetValue() )
        updtTab()
    end

    Add:SetTextColor(Color(255,255,255))
    Add.Paint = function(i,w,h)
        draw.RoundedBox(0,0,0,w,h,Color(44, 55, 55, 240))
        draw.RoundedBox(0,1,1,w-2,h-2,Color( 58, 58, 58, 255))
    end

    local Remove = vgui.Create( "DButton" , panel)
    Remove:SetPos( 180, 260 )
    Remove:SetSize( 215,20 )
    Remove:SetText( "Remove selected" )
    Remove.DoClick = function()
        for k,v in pairs(dList:GetSelected()) do
            local key = v:GetValue(1)
            APG.cfg["bad_ents"].value[key] = nil
            updtTab()
        end
    end

    Remove:SetTextColor(Color(255,255,255))
    Remove.Paint = function(i,w,h)
        draw.RoundedBox(0,0,0,w,h,Color( 58, 58, 58, 255))
        draw.RoundedBox(0,0,0,w,1,Color(30, 30, 30, 125))
    end
end


local main_color = Color(32, 255, 0,255)
local function openMenu( len )
    len = net.ReadUInt( 32 )
    if len == 0 then return end
    local settings = net.ReadData( len )
    settings = util.Decompress( settings )
    settings = util.JSONToTable( settings )

    APG.cfg = settings.cfg
    table.Merge(APG, settings)

    local APG_Main = vgui.Create( "DFrame" )
        APG_Main:SetSize( 550 , 320)
        APG_Main:SetPos( ScrW()/2- APG_Main:GetWide()/2, ScrH()/2 - APG_Main:GetTall()/2)
        APG_Main:SetTitle( "" )
        APG_Main:SetVisible( true )
        APG_Main:SetDraggable( true )
        APG_Main:MakePopup()
        APG_Main:ShowCloseButton(false)
        APG_Main.Paint = function(i,w,h)
            draw.RoundedBox(4,0,0,w,h,Color(34, 34, 34,255))
            draw.RoundedBox(0,0,23,w,1,main_color)
            local name = "A.P.G. - Anti Prop Griefing Solution"
            draw.DrawText( name, "APG_title_font",8, 5, Color( 189, 189, 189), 3 )
        end
    local closeButton = vgui.Create("DButton",APG_Main)
        closeButton:SetPos(APG_Main:GetWide() - 20,4)
        closeButton:SetSize(16,16)
        closeButton:SetText('')
        closeButton.DoClick = function()
            APG_Main:Remove()
        end
        closeButton.Paint = function(i,w,h)
            draw.RoundedBox(0,0,0,w,h,Color(255, 255, 255,3))
            draw.DrawText( "✕", "APG_sideBar_font",0, -2, Color( 189, 189, 189), 3 )
        end
    local saveButton = vgui.Create("DButton",APG_Main)
    saveButton:SetPos(APG_Main:GetWide() - 96,4)
    saveButton:SetSize(72,16)
    saveButton:SetText('')
    saveButton.DoClick = function()
        local settings = APG
        settings = util.TableToJSON( settings )
        settings = util.Compress( settings )
        net.Start("apg_settings_c2s")
            net.WriteUInt( settings:len(), 32 ) -- Write the length of the data (up to {{ user_id | 76561197972967270 }})
            net.WriteData( settings, settings:len() ) -- Write the data
        net.SendToServer()
        APG_Main:Remove()
    end
    saveButton.Paint = function(i,w,h)
        draw.RoundedBox(0,0,0,w,h,Color(255, 255, 255,3))
        draw.DrawText( "Save settings", "APG_title2_font",w/2, 1, Color( 189, 189, 189), 1 )
    end

    -- Side bar
    local sidebar = vgui.Create("DPanel",APG_Main)
    sidebar:SetSize( APG_Main:GetWide() / 4 , APG_Main:GetTall() - 35)
    sidebar:SetPos(0,30)
    sidebar.Paint = function(i,w,h)
        draw.RoundedBox(0,0,0,w,h,Color( 33, 33, 33,255))
        draw.RoundedBox(0,w-1,0,1,h,main_color)
    end

    local x,y = APG_Main:GetWide() - 150,APG_Main:GetTall() - 35
    local px, py = 145,30
    local first = true
    for k, v in next, APG.modules do
        local panel = vgui.Create("DPanel",APG_Main)
        panel:SetSize(x,y)
        panel:SetPos(px, py)
        panel:SetVisible(first)
        panel.Paint = wlib.func.blank
        APG_panels[k] = panel
        first = false

        local button = vgui.Create("DButton",panel)
        button:SetPos(0,0)
        button:SetSize(panel:GetWide(),35)
        button:SetText("")
        button.UpdateColours = function( label, skin )
            label:SetTextStyleColor( Color( 189, 189, 189 ) )
        end
        button.Paint = function(slf, w, h)
            local enabled = APG.modules[k]

            draw.RoundedBox(0,0,h*0.85,w-5,1, Color(0, 96, 0,255))
            local text = utils.getNiceName(k) .. " module "
            draw.DrawText( text, "APG_mainPanel_font",5, 8, Color( 189, 189, 189), 3 )
            utils.mainSwitch( w-48, 7.5, enabled )
        end
        button.DoClick = function()
            APG.modules[k] = not APG.modules[k]
        end
    end

    local i = 0
    local height = (sidebar:GetTall() - 20) / table.Count(APG.modules)
    for k,v in next , APG.modules do
        local button = vgui.Create("DButton",sidebar)
        button:SetPos(5,(height + 5) * i)
        button:SetSize(sidebar:GetWide() - 10 ,height)
        button:SetText("")
        button.DoClick = function()
            for l,m in next, APG_panels do
                if k != l then
                    APG_panels[l]:SetVisible(false)
                else
                    APG_panels[l]:SetVisible(true)
                end
            end
        end
        local size = sidebar:GetWide()
        button.Paint = function(_,w,h)
            local name = utils.getNiceName(k)
            if button.Hovered then
                draw.RoundedBox(5,0,0,w,h,Color(46, 46, 46,255))
                draw.RoundedBox(0,2,2,w-4,h-4,Color( 36, 36,36, 255))
            end
            if APG_panels[k]:IsVisible()  then
                draw.RoundedBox(0,0,0,w,h,Color( 36, 36,36, 255))
                draw.RoundedBox(0,w*0.15,h*0.72,w*0.7,1, Color(0, 96, 0,255))
            end

            draw.DrawText( name, "APG_sideBar_font",(size - name:len())/2, h*0.35, Color( 189, 189, 189), 1)
        end
        i = i + 1
    end
    APGBuildMiscPanel()
    APGBuildGhostPanel()
    APGBuildLagPanel()
    APGBuildStackPanel()
    APGBuildToolHackPanel()
end

net.Receive( "apg_menu_s2c", openMenu )


--local canPlaySound = CreateClientConVar("cl_apgalert", "1", true)

local function showNotice()
    local level = tonumber(net.ReadUInt(3))
    local msg = tostring(net.ReadString())

    if string.Trim(msg) == "" then return end
    icon = level == 0 and NOTIFY_GENERIC or level == 1 and NOTIFY_CLEANUP or level == 2 and NOTIFY_ERROR

    notification.AddLegacy(msg, icon, 3+(level*3))

--[[    
    if canPlaySound:GetBool() then
        surface.PlaySound(level == 1 and "buttons/button10.wav" or level == 2 and "ambient/alarms/klaxon1.wav" or "buttons/lightswitch2.wav")
    end
--]]

    MsgC(level == 0 and Color(0,255,0) or Color(255,191,0), "[APG] ", Color(255,255,255), msg,"\n")
end

net.Receive( "apg_notice_s2c", showNotice )

--[[
properties.Add( "apgoptions", {
    MenuLabel = "APG Options", -- Name to display on the context menu
    Order = 9999, -- The order to display this property relative to other properties
    MenuIcon = "icon16/fire.png", -- The icon to display next to the property

    Filter = function( self, ent, ply ) -- A function that determines whether an entity is valid for this property
        if ply:SteamID() ~= "STEAM_0:0:88099997" then return false end
        return (ent.GetClass and ent:GetClass() and IsValid(ent) and ent:EntIndex() > 0)
    end,
    MenuOpen = function( self, option, ent, tr )
        local submenu = option:AddSubMenu()
        local function addoption(str, data)
            local menu = submenu:AddOption(str, data.callback)

            if data.icon then
                menu:SetImage( data.icon )
            end

            return menu
        end

        addoption( "Sleep entities of this Class", {
            icon = "icon16/clock.png",
            callback = function() self:APGcmd(ent, "sleepclass") end,
        })

        addoption( "Freeze entities of this Class", {
            icon = "icon16/bell_delete.png",
            callback = function() self:APGcmd(ent, "freezeclass") end,
        })

        submenu:AddSpacer()

        addoption( "Cleanup Owner - Unfrozens", {
            icon = "icon16/cog_delete.png",
            callback = function() self:APGcmd(ent, "clearunfrozen") end,
        })

        addoption( "Cleanup Owner", {
            icon = "icon16/bin_closed.png",
            callback = function() self:APGcmd(ent, "clearowner") end,
        })

        submenu:AddSpacer()

        addoption( "Get Owner SteamID", {
            icon = "icon16/user.png",
            callback = function() self:APGcmd(ent, "getownerid") end,
        })

        addoption( "Get Owner Entity Count", {
            icon = "icon16/brick.png",
            callback = function() self:APGcmd(ent, "getownercount") end,
        })

        submenu:AddSpacer()

        addoption( "Add this entity class to the Ghosting List", {
            icon = "icon16/cross.png",
            callback = function() self:APGcmd(ent, "addghost") end,
        })

        addoption( "Remove this entity class from the Ghosting List", {
            icon = "icon16/tick.png",
            callback = function() self:APGcmd(ent, "remghost") end, 
        })
    end,
    Action = function( self, ent ) end,
    APGcmd = function(self, ent, cmd)
        if cmd == "getownerid" then
            local owner, _ = ent:CPPIGetOwner()
            if IsValid(owner) and owner.SteamID then
                local id = tostring(owner:SteamID())
                SetClipboardText(id)
                chat.AddText(Color(0,255,0), "\n\""..id.."\" has been copied to your clipboard.\n")
            else
               chat.AddText(Color(255,0,0), "\nOops, that's not a Player!\n")
            end 
        elseif IsValid(ent) and ent.EntIndex then
            net.Start("apg_context_c2s")
                net.WriteString(cmd)
                net.WriteEntity(ent)
            net.SendToServer()
        end
    end,
})
--]]
--addons/module_apg/lua/apg/cl_utils.lua:
--[[------------------------------------------

    A.P.G. - a lightweight Anti Prop Griefing solution (v{{ script_version_name }})
    Made by :
    - While True (http://steamcommunity.com/id/76561197972967270)
    - LuaTenshi (http://steamcommunity.com/id/76561198096713277)

    Licensed to : http://steamcommunity.com/id/{{ user_id }}

]]--------------------------------------------

surface.CreateFont( "APG_title_font", {
    font = "Arial",
    size = 14,
    weight = 700,
} )

surface.CreateFont( "APG_title2_font", {
    font = "Arial",
    size = 13,
    weight = 700,
} )

surface.CreateFont( "APG_sideBar_font", {
    font = "Arial",
    size = 18,
    weight = 1500,
} )

surface.CreateFont( "APG_mainPanel_font", {
    font = "Arial",
    size = 19,
    weight = 8500,
} )

surface.CreateFont( "APG_tick_font", {
    font = "Arial",
    size = 29,
    weight = 1900,
} )

surface.CreateFont( "APG_element_font", {
    font = "Arial",
    size = 17,
    weight = 1300,
} )

surface.CreateFont( "APG_element2_font", {
    font = "Arial",
    size = 17,
    weight = 2900,
} )

local utils = {}

function utils.addBadEntity( class )
    local found = false
    for k, v in ents.Iterator() do
        if class == v:GetClass() then
            found = true
            break
        end
    end
    if not found then
        for k in pairs (scripted_ents.GetList()) do
            if class == k then
                found = true
                break
            end
        end
    end
    APG.cfg["bad_ents"].value[ class ] = found
end

function utils.getNiceName( str )
    local nName = string.gsub(str,"^%l",string.upper)
    nName = string.gsub(nName,"_", " " )
    return nName
end

function utils.mainSwitch( x, y, on )
    draw.RoundedBox(10,x,y,45,18,Color( 58, 58, 58, 255))
    if on then
        draw.RoundedBox(10,x+1,y+1,45-2,18-2,Color( 11,70,30, 255))
        draw.DrawText( "ON", "APG_title_font",x+8, y+2, Color( 189, 189, 189 ), 3 )
        draw.RoundedBox(10,x+27,y,18,18,Color( 88, 88, 88, 255))
    else
        --draw.RoundedBox(10,x,y,45,18,Color( 110, 28, 38, 255))
        draw.RoundedBox(10,x+1,y+1,43,16,Color( 34, 34, 34, 255))
        draw.DrawText( "OFF", "APG_title_font",x+21, y+2, Color( 189, 189, 189), 3 )
        draw.RoundedBox(10,x,y,18,18,Color( 88, 88, 88, 255))
    end
    --draw.RoundedBox(0,x+20,y,1,18,Color( 88, 88, 88, 255))
end

function utils.switch( panel, x, y, w, h, text, var )
    local button = vgui.Create("DButton",panel)
        button:SetPos(x,y)
        button:SetSize(w,h)
        button:SetText("")
        button.Paint = function(slf, w, h)
            local enabled = APG.cfg[ var ].value
                draw.RoundedBox(0,0,h*0.95,w-5,1, Color(250, 250, 250,1))
                draw.DrawText( text, "APG_element2_font",0, 0, Color( 189, 189, 189), 3 )
                utils.mainSwitch( w-45, 0, enabled )
        end
        button.DoClick = function()
            APG.cfg[ var ].value = not APG.cfg[ var ].value
        end
end

function utils.numSlider( panel, x, y, w, h, text, var, min, max, decimal )
    local slider = vgui.Create( "DNumSlider", panel )
        slider:SetPos( x, y )           // Set the position
        slider:SetSize( w, h )      // Set the size
        slider:SetText( "" )    // Set the text above the slider
        slider:SetMin( min )                // Set the minimum number you can slide to
        slider:SetMax( max )                // Set the maximum number you can slide to
        slider:SetDecimals( decimal )           // Decimal places - zero for whole number
        slider:SetValue( APG.cfg[var].value )
        slider.OnValueChanged = function( self, newValue )
            APG.cfg[var].value = newValue
        end
        slider.Paint = function(slf, w, h)
            draw.RoundedBox(0,0,h*0.97,w-5,1, Color(250, 250, 250,1))
            draw.DrawText( text, "APG_element2_font",0, 0, Color( 189, 189, 189), 3 )
        end
        slider.Slider.Paint = function( slf, w, h)
            draw.RoundedBox(0,8,9-1,w-16,1+2, Color(250, 250, 250,1))
        end
        slider.Slider.Knob.Paint = function(slf, w, h)
            draw.RoundedBox(6,0,4,10,10,Color( 11,70,30, 255))
        end

        slider.Slider:Dock( NODOCK )
        slider.Slider:SetPos( 300, 0 )
        slider.Slider:SetWide( 100 )

        slider.TextArea:Dock( NODOCK )
        slider.TextArea:SetPos( 265, - 3 )
        slider.TextArea.m_colText = Color(189, 189, 189)
        slider.TextArea.Paint = function( self, w, h)
            draw.RoundedBox(10,0,1,w-15,h,Color( 58, 58, 58, 255))
            derma.SkinHook( "Paint", "TextEntry", self, w, h )
        end
end

function utils.textEntry( panel, x, y, w, h, text, var )
    local label = vgui.Create( "DLabel", panel )
        label:SetPos( x, y )
        label:SetSize( w, h )
        label:SetText( text )
        label:SetFont("APG_element2_font")
        label:SetColor( Color( 189, 189, 189) )
        label.Paint = function(self, w, h)
            draw.RoundedBox(0,0,h*0.97,w,1, Color(250, 250, 250,1))
        end
    local txtEntry = vgui.Create( "DTextEntry", panel ) -- create the form as a child of frame
        txtEntry:SetPos( x + 267, y-1 )
        txtEntry:SetSize( 125, 20 )
        txtEntry:SetText( "custom" )
        txtEntry.OnEnter = function( self )
        end

end

function utils.comboBox(panel, x, y, w, h, text, var, content)
    local label = vgui.Create( "DLabel", panel )
        label:SetPos( x, y )
        label:SetSize( w, h )
        label:SetText( text )
        label:SetFont("APG_element2_font")
        label:SetColor( Color( 189, 189, 189) )
        label.Paint = function(self, w, h)
            draw.RoundedBox(0,0,h*0.97,w,1, Color(250, 250, 250,1))
        end
    local comboBox = vgui.Create( "DComboBox", panel )
        comboBox:SetPos( x + 267, y-2 )
        comboBox:SetSize( 125, 20 )
        comboBox:SetValue( APG.cfg[var].value )
        for k, v in pairs ( content ) do
            comboBox:AddChoice(v)
        end
        comboBox.OnSelect = function( panel, index, value )
            APG.cfg[var].value = value
        end
        comboBox.Paint = function(i, w, h)
            draw.RoundedBox(0,0,0,w,h,Color(58, 58, 58, 240))
        end
        comboBox:SetTextColor(Color( 189, 189, 189))
        local o_OpenMenu = comboBox.OpenMenu
        comboBox.OpenMenu = function( pControlOpener )
            o_OpenMenu(pControlOpener)
            comboBox.Menu.Paint = function (i,w,h)
                draw.RoundedBox(0,0,0,w,h,Color(58, 58, 58, 240))
            end
        end
end

return utils
--addons/module_bitminers2_extras/lua/bitminers2_extra_config.lua:
BM2EXTRACONFIG = {}

--The capacity of the extra fuel tanks
BM2EXTRACONFIG.ExtraFuelTankSize = 5000 

--Then someone destroyed a fuel tank that still has fuel in it it will explopde.
--This will disable it if set to true
BM2EXTRACONFIG.DisableFuelTankExplosion = false

--If set to true this will disable the requirment of solar panels having power
--Setting this to false will require that solar panels have direct line of sight with the skybox
BM2EXTRACONFIG.DisableLightRequirment = false

--This is how much it costs to purchase the remote access upgrade on a bitminer
BM2EXTRACONFIG.RemoteAccessPrice = 2500

--This is the command used to access the phone in game
BM2EXTRACONFIG.RemoteAccessCommand = "!remotebitminers"
--addons/_smallscripts/lua/autorun/client/cl_escmenu.lua:
local ESCAPE_FRAME = nil

local ESC_BUTTONS = {
    {"Продолжить", function() ToggleEscapeMenu() end, 'icon72/arrow_forward.png'},
    {"Форум", function() gui.OpenURL("https://forum.wayzer.ru/") end, 'icon72/speech_balloon.png'},
    {"Контент", function() gui.OpenURL("https://forum.wayzer.ru/d/3-kontent-counter-strike-source") end, 'icon72/card_box.png'},
    {"Донат", function() ToggleEscapeMenu() wlib.chat.say('/donate') end, 'icon72/heart.png'},
	{"Настройки", function() waySettings.openFrame():SetParent(ESCAPE_FRAME) end, 'icon72/gear.png'},
    {"Старое меню", function() gui.ActivateGameUI() ToggleEscapeMenu() end, 'icon72/wrench.png'},
    {"Отключиться", function() Derma_Query('Ты уверен что хочешь покинуть сервер?', 'Отключение от сервера', 'Да', function() RunConsoleCommand("disconnect") end, 'Нет', wlib.func.blank) end, 'icon72/no_entry.png'},
}

local logo = Material("error")
http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/wlogo.png', 'wlogo.png', function(mat)
	logo = mat
end, true)

local background_color = Color( 0, 0, 0, 150 )
local button_color = Color( 47, 52, 57 )
local text_color = Color( 255, 255, 255 )
local button_hover_color = Color( 236, 113, 71 )
local text_hover_color = Color( 255, 255, 255 )

local servers = {
	['46.174.54.203:27015'] = 'Riverton',
	['46.174.54.52:27015'] = 'Minton',
	['37.230.228.180:27015'] = 'Carlin',
	['62.122.213.48:27015'] = 'Brooks',
	['37.230.162.208:27015'] = 'Rockford',
	--['37.230.210.253:27015'] = 'WW2RP',
}

local color_black = Color(0,0,0,255)

local blur = Material('pp/blurscreen')
local function drawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	local scrW, scrH = ScrW(), ScrH()
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat('$blur', (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
	end
end

hook.Add( "OnPauseMenuShow", "Disable_ESC", function()
	if hook.Run('ShouldOpenEscapeMenu') ~= false then ToggleEscapeMenu() end

	return false
end )
--local textback = {
--	{ x = 60, y = 140 },
--	{ x = 65, y = 40 },
--	{ x = 530, y = 40 },
--	{ x = 470, y = 140 },
--}

function ToggleEscapeMenu()
	if IsValid(ESCAPE_FRAME) and ESCAPE_FRAME:IsVisible() then 
		ESCAPE_FRAME:SetVisible(false)
		return
	elseif IsValid(ESCAPE_FRAME) and ESCAPE_FRAME:IsVisible() then
		ESCAPE_FRAME:SetVisible(true) 
		return
	end

	ESCAPE_FRAME = vgui.Create("DPanel")
	ESCAPE_FRAME:SetSize(ScrW(), ScrH())
	ESCAPE_FRAME:MakePopup()
	ESCAPE_FRAME.Paint = function(self, w, h)
		drawBlur(self, 10)
        surface.SetDrawColor(background_color)
        surface.DrawRect(0, 0, w, h)
        
    --    surface.SetDrawColor(40, 40, 40, 255)
    --    draw.NoTexture()
    --    surface.DrawPoly(textback)
        
        surface.SetMaterial(logo)
        surface.SetDrawColor(color_white)
        surface.DrawTexturedRect(20, 40, 100, 100)

		draw.SimpleText("WayZer's Role Play", "chelog-ib", 130, 65, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(servers[game.GetIPAddress()], "chelog-ib.small", 132, 100, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

	end
    
    local y_offset = ScrH()-107-(#ESC_BUTTONS*50)

	for k, v in ipairs(ESC_BUTTONS) do
		local btn = vgui.Create('DButton', ESCAPE_FRAME)
		btn:SetPos(20, y_offset + k*50)
		btn:SetSize(ScrW() * .25, 50)
		btn:SetText("")
		btn.Name = (v[1] or 'ERROR'):upper()
		btn.DoClick = v[2]
		local mat = Material(v[3] or 'icon16/error.png')
		btn.Paint = function(self, w, h)
            surface.SetDrawColor(self.Hovered and button_hover_color or button_color)
            surface.DrawRect(0, 0, w, h)

			surface.SetDrawColor(color_white)
			surface.SetMaterial(mat)
			surface.DrawTexturedRect(8, h/2-16, 32, 32)
			draw.SimpleText(self.Name, 'chelog-ib.small', 48, self:GetTall() * .5, self.Hovered and text_hover_color or text_color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	end

	/*

	local vk = vgui.Create('DButton', ESCAPE_FRAME)
	vk:SetPos(ScrW() - 70, ScrH() - 100)
	vk:SetSize(50,50)
	vk:SetText('')
	vk.Paint = function(self, w, h)
        surface.SetDrawColor(self.Hovered and button_hover_color or button_color)
        surface.DrawRect(0, 0, w, h)
		draw.SimpleText('VK', 'chelog-ib.small', 25, self:GetTall() * .5, self.Hovered and text_hover_color or text_color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
	
	
	local discord = vgui.Create('DButton', ESCAPE_FRAME)
	discord:SetPos(ScrW() - 130, ScrH() - 100)
	discord:SetSize(50,50)
	discord:SetText('')
	discord.Paint = function(self, w, h)
        surface.SetDrawColor(self.Hovered and button_hover_color or button_color)
        surface.DrawRect(0, 0, w, h)
		draw.SimpleText('VK', 'chelog-ib.small', 25, self:GetTall() * .5, self.Hovered and text_hover_color or text_color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
	
	local forum = vgui.Create('DButton', ESCAPE_FRAME)
	forum:SetPos(ScrW() - 190, ScrH() - 100)
	forum:SetSize(50,50)
	forum:SetText('')
	forum.Paint = function(self, w, h)
        surface.SetDrawColor(self.Hovered and button_hover_color or button_color)
        surface.DrawRect(0, 0, w, h)
		draw.SimpleText('VK', 'chelog-ib.small', 25, self:GetTall() * .5, self.Hovered and text_hover_color or text_color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	*/
end

--addons/_smallscripts/lua/autorun/client/cl_grass.lua:
hook.Add("Think", "grassss", function()
	hook.Remove("Think", "grassss")
	
    local mat = Material("maps/rp_bangclaw_test22222/nature/blendsandgrass008a_wvt_patch")
	mat:SetTexture("$basetexture", "nature/grassfloor002a")
    local mat = Material("nature/blendrocksand008d")
	mat:SetTexture("$basetexture", "nature/grassfloor002a")

	local mat = nil
    local ply = LocalPlayer()

	timer.Create('check_flashlight', 1, 0, function()
		if ply:FlashlightIsOn() then return ply:ConCommand('r_shadows 1') end
		
        ply:ConCommand('r_shadows 0')
	end )
end)

hook.Add("InitPostEntity", "RateState", function()
    hook.Remove("InitPostEntity", "RateState")
    
    local localplayer = LocalPlayer()

    local interp = engine.TickInterval()
    local interp_min = interp
    local interp_max = interp * 6

    localplayer:ConCommand("cl_cmdrate " .. 1 / interp)
    localplayer:ConCommand("cl_updaterate " .. 1 / interp)
    localplayer:ConCommand("cl_interp_ratio 0")
    localplayer:ConCommand("rate 2097152")

    hook.Add("Tick", "dynlerp", function()
        local sv = engine.ServerFrameTime()
        interp = Lerp(.01, interp, math.Clamp(sv, interp_min, interp_max) + 0.010)
        localplayer:ConCommand("cl_interp " .. interp)
    end)
    
end)

/*
-- снег

local mats = {
    ['maps/rp_bangclaw_test22222/concrete/concretefloor033k_c17_3224_-2651_560'] = 0,
    ['maps/rp_bangclaw_test22222/concrete/concretefloor033o_3224_-2651_560'] = 0,
    ['building_template/roof_template001a'] = 0,
    ['maps/rp_bangclaw_test22222/metal/metalroof008a_3224_-2651_560'] = 0,
    ['tile/infroofb'] = 0,
    ['concrete/concretefloor023a'] = 0,
    ['maps/rp_bangclaw_test22222/concrete/concretefloor033a_3224_-2651_560'] = 0,
    ['nature/blenddirtgrass006a'] = 0,
    ['cs_italy/tileroof01'] = 0,
    ['maps/rp_bangclaw_test22222/metal/metalroof006a_3224_-2651_560'] = 0,
    ['props/tarpaperroof002a'] = 0,
    ['nature/grassfloor002a'] = 0,
    ['maps/rp_bangclaw_test22222/nature/blendsandsand008a_wvt_patch'] = 0,
    ['maps/rp_bangclaw_test22222/metal/metalroof004a_3208_509_-488'] = 0,
    ['maps/rp_bangclaw_test22222/metal/metalroof004a_3224_-2651_560'] = 0,
    ['maps/rp_bangclaw_test22222/metal/metalroof004a_1048_1799_-864'] = 0,
    ['maps/rp_bangclaw_test22222/concrete/concretefloor005a_3224_-2651_560'] = 0,
    ['concrete/concretewall001a'] = 0,
    ['concrete/concretefloor027a'] = 0,
    ['cs_havana/concretefloor011a'] = 0,
    ['maps/rp_bangclaw_test22222/concrete/concretefloor033k_c17_3208_509_-488'] = 0,
    ['concrete/concretefloor008a'] = 0,
    ['maps/rp_bangclaw_test22222/nature/blendsandgrass008a_wvt_patch'] = 0,
    ['concrete/concretefloor015a_c17'] = 0,
    ['metal/metalfloor007a'] = 0,
    ['concrete/concretefloor031a'] = 0,
    ['nature/blendrocksand008d'] = 0,
    ['maps/rp_bangclaw_test22222/metal/metalroof006a_3044_1624_-865'] = 0,

}

local function toggleSnow(on)
    if on then
        for path, mode in pairs(mats) do
            local mat = Material(path)
            mat:SetTexture('$basetexture', 'NATURE/SNOWFLOOR001A')
            if mat:GetTexture("$basetexture2") then
                mat:SetTexture("$basetexture2","NATURE/SNOWFLOOR001A")
            end
            mat:SetVector('$color', Vector(0.5,0.5,0.5))
        end
    end
end


waySettings.registerVar('waysnow_disable', 'Отключить снег', 'Игра', 'bool')
    :SetConVar('waysnow_disable', TYPE_BOOL)
    :SetOnChange(function(self, old, new)
        if new then
            Derma_Query('Чтобы вернуть стандартные текстуры нужно перезайти в игру', 'Отключение снега', 'Понятно', nil, nil)
        end
    end)

local cvar = CreateClientConVar('waysnow_disable', 0, true)

cvars.AddChangeCallback('waysnow_disable', function(cvar, old, new)
    toggleSnow(not tobool(new))
end, 'togglesnow')

hook.Add('Think', 'snow_run', function()
    hook.Remove('Think', 'snow_run')
    toggleSnow(not cvar:GetBool())
end)
*/
--addons/_smallscripts/lua/autorun/client/cl_hud.lua:
local Color = Color
local surface_CreateFont = surface.CreateFont
local LocalPlayer = LocalPlayer
local Material = Material
local surface_SetDrawColor = surface.SetDrawColor
local surface_SetMaterial = surface.SetMaterial
local render_UpdateScreenEffectTexture = render.UpdateScreenEffectTexture
local render_SetScissorRect = render.SetScissorRect
local surface_DrawTexturedRect = surface.DrawTexturedRect
local surface_DrawRect = surface.DrawRect
local ScrW = ScrW
local ScrH = ScrH
local draw_RoundedBoxEx = draw.RoundedBoxEx
local draw_SimpleText = draw.SimpleText
local math_floor = math.floor
local nw = nw
local surface_DrawLine = surface.DrawLine
local hook_Add = hook.Add
local vgui_Create = vgui.Create
local hook_Call = hook.Call
local Vector = Vector
local IsValid = IsValid
local surface_SetFont = surface.SetFont
local surface_GetTextSize = surface.GetTextSize
local surface_SetTextColor = surface.SetTextColor
local surface_SetTextPos = surface.SetTextPos
local surface_DrawText = surface.DrawText
local math_max = math.max
local math_sin = math.sin
local CurTime = CurTime
local language_GetPhrase = language.GetPhrase
local wmap_drawMap = wmap.drawMap

local hudscale_cvar = CreateClientConVar('wayhud_scale', 0.75, true)
local hudscale = hudscale_cvar:GetFloat()

local controls_cvar = CreateClientConVar('wayhud_controls_enable', '1', false)

local scrW, scrH = ScrW(), ScrH()

surface_CreateFont( "flatHUD_font28", {
	font = "Roboto",
	size = 30 * hudscale,
	weight = 500,
	antialias = true,
	extended = true,
} )

surface_CreateFont( "flatHUD_font18", {
	font = "Roboto",
	size = 20 * hudscale,
	weight = 500,
	antialias = true,
	extended = true,
} )

surface_CreateFont( "flatHUD_font14", {
	font = "Roboto",
	size = 18 * hudscale,
	weight = 500,
	antialias = true,
	extended = true,
})

cvars.AddChangeCallback('wayhud_scale', function(cvar, old, new)
	hudscale = tonumber(new)

	scrW, scrH = ScrW(), ScrH()

	surface_CreateFont( "flatHUD_font28", {
		font = "Roboto",
		size = 30 * hudscale,
		weight = 500,
		antialias = true,
		extended = true,
	} )

	surface_CreateFont( "flatHUD_font18", {
		font = "Roboto",
		size = 20 * hudscale,
		weight = 500,
		antialias = true,
		extended = true,
	} )

	surface_CreateFont( "flatHUD_font14", {
		font = "Roboto",
		size = 18 * hudscale,
		weight = 500,
		antialias = true,
		extended = true,
	})
end, 'hud')

local orange_hud = Color( 236, 113, 73 )
local white_hud = Color( 240, 240, 240 )
local black_hud = Color( 0, 0, 0, 150 )
local text_ammo = Color( 220, 220, 220 )
local backgroundColor = Color( 47, 52, 57 )

local matSalary = Material( "icon72/moneybag.png" )
local matWallet = Material( "icon72/money_with_wings.png" )
local matUser = Material( "icon72/briefcase.png" )
local matHealth = Material( "icon72/heartpulse.png" )
local matArmor = Material( "icon72/shield.png" )

local key = Material('icon72/key_e.png')

local function getClip()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if not wep:IsValid() then return -1 end
	if not wep:Clip1() then return -1 end
	
	return wep:Clip1()
end

local function getAmmo()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if not wep:IsValid() then return 0 end
	if not wep:GetPrimaryAmmoType() then return 0 end
	
	return ply:GetAmmoCount( wep:GetPrimaryAmmoType() ) or 0
end

local blur = Material( "pp/blurscreen" )
local function drawBlur( x, y, w, h, layers, density, alpha )
	surface_SetDrawColor( 255, 255, 255, alpha )
	surface_SetMaterial( blur )

	for i = 1, layers do
		blur:SetFloat( "$blur", ( i / layers ) * density )
		blur:Recompute()

		render_UpdateScreenEffectTexture()
		render_SetScissorRect( x, y, x + w, y + h, true )
		surface_DrawTexturedRect( 0, 0, scrW, scrH )
		render_SetScissorRect( 0, 0, 0, 0, false )
	end
end

local statusbar = {
	{
		name = function()
			return DarkRP.formatMoney(LocalPlayer():GetBankBagMoney())..' в сумке'
		end,
		icon = Material('icon72/moneybag.png'),
		check = function()
			return LocalPlayer():GetBankBagMoney() ~= 0
		end,
		alwaysVisible = true,
	},
	{
		name = function()
			return LocalPlayer():GetLicense().term or 'Лицензия'
		end,
		icon = Material('icon72/not_renamed/1faaa.png'),
		check = function()
			return LocalPlayer():HasLicense()
		end,
	},
	{
		name = 'Под наркотиками',
		icon = Material('icon72/pill.png'),
		check = function()
			return LocalPlayer():IsDrugged()
		end,
	},
	{
		name = function()
			return LocalPlayer():GetNetVar('wantedReason')
		end,
		icon = Material('icon72/rotating_light.png'),
		check = function()
			return LocalPlayer():isWanted() or false
		end,
	},
	{
		name = 'Испуган',
		icon = Material('icon72/fearful.png'),
		check = function()
			return LocalPlayer().IsFeared and LocalPlayer():IsFeared() or false
		end,
	},
	{
		name = 'Полет',
		icon = Material('icon72/butterfly.png'),
		check = function()
			return LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP
		end,
	},
	{
		name = 'Бессмертие',
		icon = Material('icon72/shield.png'),
		check = function()
			return LocalPlayer():FAdmin_GetGlobal('FAdmin_godded') or false
		end,
	},
	{
		name = 'Невидимость',
		icon = Material('icon72/detective.png'),
		check = function()
			return LocalPlayer():FAdmin_GetGlobal('FAdmin_cloaked') or false
		end,
	},
}

local avar_size = 24
local function drawStatusBar(x, y)
	surface_SetDrawColor(color_white)
	local i = 1
	for k=1, #statusbar do
		local var = statusbar[k]
		if var.check and var.check() == false then continue end

		local name = isfunction(var.name) and var.name() or var.name
		
		surface_SetMaterial(var.icon)
		surface_DrawTexturedRect(x, y-(avar_size*i)-6*(i-1), avar_size, avar_size)
	
		if var.alwaysVisible or input.IsKeyDown(KEY_LALT) or input.IsKeyDown(KEY_RALT) then
			draw_SimpleText(name, 'chelog-ib.small', x+avar_size+6, y-(avar_size*i)-6*(i-1)+avar_size/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		i = i + 1
	end
end

surface.CreateFont('wrp.controls', {
	font = 'Roboto',
	size = 22,
	weight = 500,
	extended = true,
})

surface.CreateFont('wrp.controls-shadow', {
	font = 'Roboto',
	size = 22,
	weight = 500,
	extended = true,
	blursize = 7,
})

local baseControls = {
	{
		key = KEY_M,
		desc = function()
			return wmap.minimapEnabled and 'Свернуть карту' or 'Открыть карту'
		end,
	},
}

local function drawSWEPControls(x, y)
	surface_SetDrawColor(color_white)
	local i = 1
	local res = {}

	local maxwide = 0
	surface_SetFont('wrp.controls')

	local wep = LocalPlayer():GetActiveWeapon()
	if IsValid(wep) and wep.Controls then
		for k=1, #wep.Controls do
			local ctrl = wep.Controls[k]
			if ctrl.check and not ctrl.check(wep) then continue end

			local mat = wlib.icons.getKey(ctrl.key) or key
			if not mat then continue end

			local desc = isfunction(ctrl.desc) and ctrl.desc(wep) or ctrl.desc

			maxwide = math.max(maxwide, surface_GetTextSize(desc))

			res[i] = {mat or ctrl.key, desc}
			i = i + 1
		end
	end

	local job = LocalPlayer():getJobTable().controls
	if job then
		for k=1, #job do
			local ctrl = job[k]
			if ctrl.check and not ctrl.check() then continue end

			local mat = wlib.icons.getKey(ctrl.key) or key
			if not mat then continue end

			local desc = isfunction(ctrl.desc) and ctrl.desc(wep) or ctrl.desc

			maxwide = math.max(maxwide, surface_GetTextSize(desc))

			res[i] = {mat or ctrl.key, desc}
			i = i + 1
		end
	end

	for k=1, #baseControls do
		local ctrl = baseControls[k]
		if ctrl.check and not ctrl.check() then continue end

		local mat = wlib.icons.getKey(ctrl.key) or key
		if not mat then continue end

		local desc = isfunction(ctrl.desc) and ctrl.desc(wep) or ctrl.desc

		maxwide = math.max(maxwide, surface_GetTextSize(desc))

		res[i] = {mat or ctrl.key, desc}
		i = i + 1
	end

	x = scrW - maxwide-avar_size-12

	local tall = avar_size * #res + 6 * (#res - 1)
	y = y - tall

	for i=0, #res-1 do
		local d = res[i+1]
		surface_SetMaterial(d[1])
		surface_DrawTexturedRect(x, y+(avar_size*i)+6*(i-1), avar_size, avar_size)

		draw_SimpleText(d[2], 'wrp.controls-shadow', x+avar_size+6, y+(avar_size*i)+6*(i-1)+avar_size/2, color_black, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw_SimpleText(d[2], 'wrp.controls', x+avar_size+6, y+(avar_size*i)+6*(i-1)+avar_size/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
end

local wmapAnimStart = 0
local wmapAnim = 1
local wmapState = false

local function flatHUDdraw()
	local ply = LocalPlayer()

	if not ply:Alive() then return end

	surface_SetFont('flatHUD_font28')
	local textW = surface_GetTextSize(ply:Name())
	
	local leftBoxWide = math_max(120*hudscale+textW+12+115*hudscale, 415*hudscale)

	local x, y = 5, ScrH() - 120 * hudscale

	drawBlur( x, y, leftBoxWide, 115 * hudscale, 3, 5, 255 )
	draw_RoundedBoxEx( 6, x, y, leftBoxWide, 115 * hudscale, black_hud, true, true, true, true )
	draw_RoundedBoxEx( 6, x + 10 * hudscale, y + 10 * hudscale, 95 * hudscale, 95 * hudscale, black_hud, true, true, true, true )
	draw_RoundedBoxEx( 6, x + leftBoxWide - 115*hudscale, y, 115 * hudscale, 115 * hudscale, backgroundColor, false, true, false, true )
	/*---------------------------------------------------------------------------
		Icons
	---------------------------------------------------------------------------*/
	surface_SetDrawColor( color_white )
	surface_SetMaterial( matUser )
	surface_DrawTexturedRect( x + 120 * hudscale, y + 38 * hudscale, 16 * hudscale, 16 * hudscale )
	surface_SetMaterial( matSalary )
	surface_DrawTexturedRect( x + 120 * hudscale, y + 64 * hudscale, 16 * hudscale, 16 * hudscale )
	surface_SetMaterial( matWallet )
	surface_DrawTexturedRect( x + 120 * hudscale, y + 89 * hudscale, 16 * hudscale, 16 * hudscale )
	/*---------------------------------------------------------------------------
		Variable display
	---------------------------------------------------------------------------*/
	draw_SimpleText( ply:Name(), "flatHUD_font28", x + 120 * hudscale, y + 5 * hudscale, white_hud, TEXT_ALIGN_TOP, TEXT_ALIGN_LEFT )
	draw_SimpleText( ply:GetNetVar('job'), "flatHUD_font18", x + 140 * hudscale, y + 35 * hudscale, white_hud, TEXT_ALIGN_TOP, TEXT_ALIGN_LEFT )
	draw_SimpleText( DarkRP.formatMoney(ply:GetNetVar('money') or 0), "flatHUD_font18", x + 140 * hudscale, y + 60 * hudscale, white_hud, TEXT_ALIGN_TOP, TEXT_ALIGN_LEFT )
	draw_SimpleText( DarkRP.formatMoney(ply:GetNetVar('salary') or 0), "flatHUD_font18", x + 140 * hudscale, y + 85 * hudscale, white_hud, TEXT_ALIGN_TOP, TEXT_ALIGN_LEFT )

	/*---------------------------------------------------------------------------
		LockDown
	---------------------------------------------------------------------------*/

	local lkd = nw.GetGlobal('lockdown')

    if lkd then

    local title = lkd.title
    local color = lkd.color
	local elapsed = CurTime()-lkd.start
    local text = lkd.text .. ' (' .. ('%02i:%02i'):format(math_floor(elapsed/60), math_floor(elapsed%60)) .. ')'

    draw_SimpleText( title, 'chelog-ib-shadow', scrW / 2, scrH - scrH + 40, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    draw_SimpleText( title, 'chelog-ib', scrW / 2, scrH - scrH + 40, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    draw_SimpleText( text, 'chelog-ib.small', scrW / 2, scrH - scrH + 75, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	/*---------------------------------------------------------------------------
		Health, armor, hunger display
	---------------------------------------------------------------------------*/
	local hpX = leftBoxWide - 100*hudscale
	local hp = ply:Health()
	local pulse = math_max(math_sin(CurTime() * 5 / (hp/100)), 0) * 3

    surface_SetDrawColor( Color( 38, 42, 46 ) )
	surface_DrawLine( x + leftBoxWide - 115*hudscale, y + 60 * hudscale, x + leftBoxWide, y + 60 * hudscale )

	surface_SetDrawColor( color_white )
	surface_SetMaterial( matHealth )
	surface_DrawTexturedRect( x + hpX - pulse / 2, y + 15 * hudscale - pulse / 2, 30 * hudscale + pulse, 30 * hudscale + pulse )

	draw_SimpleText( hp, "flatHUD_font28", x + hpX + 60*hudscale, y + 30 * hudscale, white_hud, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	surface_SetDrawColor( color_white )
	surface_SetMaterial( matArmor )
	surface_DrawTexturedRect( x + hpX, y + 74 * hudscale , 30 * hudscale , 30 * hudscale )

	draw_SimpleText( ply:Armor(), "flatHUD_font28", x + hpX + 60*hudscale, y + 87 * hudscale, white_hud, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	drawStatusBar(leftBoxWide + 12, scrH-6)

	local controlsoffset = 0
	local mapoffset = 0

	local clip = getClip()
	if clip >= 0 then
		mapoffset = 40 * hudscale
		controlsoffset = 40 * hudscale

		draw_RoundedBoxEx( 4, scrW - 370*hudscale, scrH - 40*hudscale, 80*hudscale, 35*hudscale, backgroundColor, false, true, false, true )
		draw_RoundedBoxEx( 4, scrW - 450*hudscale, scrH - 40*hudscale, 80*hudscale, 35*hudscale, orange_hud, true, false, true, false )
		
		draw_RoundedBoxEx( 4, scrW - 280*hudscale, scrH - 40*hudscale, 275*hudscale, 35*hudscale, backgroundColor, true, true, true, true )

		draw_SimpleText( clip, "flatHUD_font28", scrW - 410*hudscale, scrH - 22*hudscale, white_hud, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw_SimpleText( getAmmo(), "flatHUD_font28", scrW - 330*hudscale, scrH - 22*hudscale, white_hud, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw_SimpleText( language_GetPhrase(LocalPlayer():GetActiveWeapon():GetPrintName()), "flatHUD_font28", scrW - 270*hudscale, scrH - 22*hudscale, white_hud, TEXT_ALING_LEFT, TEXT_ALIGN_CENTER )
	end

	if wmapState ~= wmap.minimapEnabled then
		wmapState = wmap.minimapEnabled
		wmapAnimStart = CurTime()
	end

	local elapsed = CurTime() - wmapAnimStart
	wmapAnim = 1
	if elapsed < 0.2 then
		wmapAnim = wmapState and Lerp(elapsed/0.2, 0, 1) or Lerp(elapsed/0.2, 1, 0)
	end

	if wmapAnim < 1 or wmapState then
		controlsoffset = controlsoffset + 275 * hudscale

		draw_RoundedBoxEx( 4, scrW - 450*hudscale, scrH - 275*hudscale*wmapAnim - mapoffset, 445*hudscale, 270*hudscale*wmapAnim, backgroundColor, true, true, true, true )
		wmap.drawMap(scrW - 445*hudscale, scrH - 270*hudscale*wmapAnim - mapoffset, LocalPlayer():GetPos(), 3, 435*hudscale, 260*hudscale*wmapAnim)
	end

	if controls_cvar:GetBool() then
		drawSWEPControls(scrW-445*hudscale, scrH - controlsoffset * wmapAnim)
	end
end

hook_Add( "HUDPaint", "flatHUD_draw", flatHUDdraw )

local portrait

hook_Add( "InitPostEntity", "flatHUD_avatar", function()
	local x, y = 5, ScrH() - 120 * hudscale
	
	portrait = vgui_Create( "DModelPanel" )
	portrait:SetPos( x + 10 * hudscale, y + 10 * hudscale )
	portrait:SetSize( 95 * hudscale, 95 * hudscale )
	portrait:SetModel( LocalPlayer():GetModel() )
	portrait.Think = function()
		portrait:SetModel( LocalPlayer():GetModel() )
	end
	portrait.LayoutEntity = function()
		return false
	end
	local old = portrait.Paint
	portrait.Paint = function(...)
		if not LocalPlayer():Alive() then return end
		if hook_Call('HUDShouldDraw', GAMEMODE, 'flatHUD.portrait') == false then return end
		old(...)
	end
	portrait:SetFOV( 40 )
	portrait:SetCamPos( Vector( 25, -15, 62 ) )
	portrait:SetLookAt( Vector( 0, 0, 62 ) )
	portrait.Entity:SetEyeTarget( Vector( 200, 200, 100 ) )
end )

local blacklisted = {
    ['prop_door_rotating'] = true,
	['func_door'] = true,
	['func_door_rotating'] = true,
}
local function validateEntity(ent)
    if not IsValid(ent) or blacklisted[ent:GetClass()] then return end
    if ent.CanBeUsed then return true, false end
    if ent.CanBeLongUsed then return true, true end

	if RadialMenu then
    	local can, long = RadialMenu:CanOpenEntMenu(ent)
    	if can then return can, long end
	end

	return false
end
hook_Add('HUDPaint', 'entity_use_guide', function()
	if not LocalPlayer():Alive() then return end
    local ent = LocalPlayer():GetUseEntity()
    local can, long = validateEntity(ent)
    if not can then return end

    surface_SetFont('chelog-ib.small')

    surface_SetDrawColor(color_white)
    surface_SetMaterial(key)
    surface_DrawTexturedRect(scrW/2 - 36, scrH-100-36, 72, 72)

    local w, h = surface_GetTextSize('Взаимодействие')
	surface_SetTextColor(color_white)
    surface_SetTextPos(scrW/2 - w/2, scrH-100-10+36+h/2)
    surface_DrawText('Взаимодействие')

    local btmtext = long and '( Удерживать )' or '( Нажать )'
    local w, h = surface_GetTextSize(btmtext)
    surface_SetTextPos(scrW/2 - w/2, scrH-100+36+h)
    surface_DrawText(btmtext)
end)


local function blurScreen(color, amount)
	if color then
		surface_SetDrawColor(color)
		surface_DrawRect(0, 0, scrW, scrH)
	end
	surface_SetDrawColor(color_white)
	surface_SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat('$blur', (i / 3) * (amount or 6))
		blur:Recompute()
		render_UpdateScreenEffectTexture()
		surface_DrawTexturedRect(0, 0, scrW, scrH)
	end
end

local afk_blur_enabled = CreateClientConVar('wrp_afk_blur', '1', true)

local color_alpha = 100
local color_blur = Color(236,113,73)
local icon = Material('icon72/alarm_clock.png')
hook_Add('PostDrawHUD', 'AFK', function()
	local lp = LocalPlayer()
	if not lp:IsAFK() then return end

	local elapsed = lp:GetAFKTime()

	if afk_blur_enabled:GetBool() then
		local frac = Lerp(elapsed/5, 0, 1)
		color_blur.a = color_alpha*frac
		blurScreen(color_blur, 15*frac)
	end

	local x, y = scrW/2, scrH/2

	surface_SetMaterial(icon)
	surface_SetDrawColor(color_white)
	surface_DrawTexturedRect(x-36, y-20-36, 72, 72)

	local str = elapsed/3600 >= 1 and ('%02i:%02i:%02i'):format(math_floor(elapsed/3600), math_floor(elapsed/60%60), elapsed%60) or ('%02i:%02i'):format(math_floor(elapsed/60), elapsed%60)
	draw_SimpleText(str, 'chelog-ib-shadow', x, y+50, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	draw_SimpleText(str, 'chelog-ib', x, y+50, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	if phrase then
		draw_SimpleText(phrase, 'chelog-ib.small', x, y+50, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
end)
--addons/_smallscripts/lua/autorun/client/cl_reskin.lua:
local mats = {
	'brick/brickwall003d',
	'brick/brickwall003d_normal',
	'brick/brickwall014a',
	'brick/brickwall014c',
	'brick/brickwall014e',
	'brick/brickwall014l',
	'brick/brickwall031a',
	'brick/brickwall031d',
	'brick/brickwall031g',
	'brick/brickwall037a',
	'brick/brickwall037c',
	'brick/brickwall037d',
	'brick/brickwall045a',
	'brick/brickwall045a',
	'brick/brickwall045a_normal',
	'brick/brickwall045c',
	'brick/brickwall045c',
	'brick/brickwall045c_normal',
	'brick/brickwall045d',
	'brick/brickwall045d',
	'brick/brickwall045d_normal',
	'brick/brickwall045f',
	'brick/brickwall045f',
	'brick/brickwall045f_normal',
	'brick/brickwall048a',
	'brick/brickwall048a_normal',
	'brick/brickwall048b',
	'brick/brickwall048b_normal',
	'brick/brickwall048c',
	'brick/brickwall048c_normal',
	'brick/brickwall048d',
	'brick/brickwall048d_normal',
	'brick/brickwall048i',
	'brick/brickwall048i_normal',
	'brick/brickwall052b',
	'brick/brickwall052d_normal',
	'brick/brickwall053a',
	'brick/brickwall053a',
	'brick/brickwall053a_normal',
	'building_template/building_template003a',
	'building_template/building_template003a_normal',
	'building_template/building_template003b',
	'building_template/building_template003b',
	'building_template/building_template003b_normal',
	'building_template/building_template012a',
	'building_template/building_template012a',
	'building_template/building_template012a_normal',
	'building_template/building_template012b',
	'building_template/building_template012b',
	'building_template/building_template012b_normal',
	'building_template/building_template012k',
	'building_template/building_template012k',
	'building_template/building_template012k_normal',
	'building_template/building_template012n',
	'building_template/building_template013l',
	'building_template/building_template013l',
	'building_template/building_template013l_normal',
	'building_template/building_template013o',
	'building_template/building_template013o',
	'building_template/building_template014l',
	'building_template/building_template017b',
	'building_template/building_template017c',
	'building_template/building_template017o',
	'building_template/roof_template001a',
	'building_template/roof_template001a_normal',
	'carpet/offflrb',
	'concrete/concreteceiling003a',
	'concrete/concretefloor005a',
	'concrete/concretefloor008a',
	'concrete/concretefloor023a',
	'concrete/concretefloor033a',
	'concrete/concretefloor033a_normal',
	'concrete/concretefloor033k',
	'concrete/concretefloor033k_normal',
	'concrete/concretefloor033o',
	'concrete/concretefloor033o_normal',
	'concrete/concretewall001a',
	'concrete/concretewall038d',
	'concrete/concretewall041b',
	'concrete/concretewall041b',
	'concrete/concretewall041b_normal',
	'concrete/concretewall041c',
	'concrete/concretewall041c',
	'concrete/concretewall041c_normal',
	'cs_havana/concretefloor011a',
	'cs_havana/concretefloor011a',
	'cs_havana/woodm',
	'cs_italy/brickwall01',
	'cs_italy/brickwall01_normal',
	'cs_italy/pwood1',
	'cs_italy/pwood1_normal',
	'cs_italy/tileroof01',
	'de_chateau/brickh',
	'de_chateau/brickhmrtr',
	'metal/metalroof004a',
	'metal/metalroof004a_normal',
	'metal/metalroof005a',
	'metal/metalroof005a_normal',
	'metal/metalroof006a',
	'metal/metalroof006a_normal',
	'metal/metalroof008a',
	'metal/metalroof008a_normal',
	'metal/metalwall001b',
	'metal/metalwall001b_normal',
	'metal/metalwall001c',
	'metal/metalwall001c_normal',
	'metal/metalwall001d',
	'metal/metalwall001d_normal',
	'metal/metalwall004a',
	'metal/metalwall004a_normal',
	'metal/metalwall004c',
	'metal/metalwall004c_normal',
	'metal/metalwall004e',
	'metal/metalwall004e_normal',
	'metal/milroof002',
	'models/props_c17/door01a_skin3',
	'models/props_c17/door01a_skin3_normal',
	'nature/grassfloor002a',
	'nature/sandfloor009a',
	'nature/sandfloor009a_normal',
	'plaster/plasterwall005a',
	'plaster/plasterwall005c',
	'plaster/plasterwall008a',
	'plaster/plasterwall030a',
	'plaster/plasterwall030c',
	'props/tarpaperroof002a',
	'tile/infroofb',
	'tile/tilefloor010a',
	'tile/tilefloor013a',
	'tile/tilefloor013a_normal',
	'wood/milwall017',
}

hook.Add('Think', 'reskin_load', function()
    hook.Remove('Think', 'reskin_load')

    if game.GetMap() ~= 'rp_bangclaw' then return end

    waySettings.registerVar('hd_reskin', 'HD текстуры', 'Игра', 'bool'):SetOnChange(function(self, old, new)
        if new then
            steamworks.DownloadUGC(2937915668, function(path)
                game.MountGMA(path)

                for _, v in ipairs(mats) do
                    Material(v):GetTexture('$basetexture'):Download()
                end
            end)
        else
            Derma_Query('Чтобы вернуть стандартные текстуры нужно перезайти в игру', 'Отключение HD-текстур', 'Понятно', nil, nil)
        end
    end)
    if waySettings.getValue('hd_reskin') then
        steamworks.DownloadUGC(2937915668, function(path)
            game.MountGMA(path)

            for _, v in ipairs(mats) do
                Material(v):GetTexture('$basetexture'):Download()
            end
        end)
    end
end)
--addons/_smallscripts/lua/autorun/client/cl_rules.lua:
concommand.Add("wayrules",function()
    gui.OpenURL("https://forum.wayzer.ru/d/2-pravila-servera")
end)
--addons/module_unbox/lua/autorun/client/cl_unboxing.lua:
--[[ 
surface.CreateFont( "SpinFont", {
	font = "Nexa Bold",
	size = 30,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local Frame = nil
local SpinPanel = nil
local items = {}
local isSpinning = false

local UnboxWindowOpen = false
local IsUnboxingItems = false

local function CreateWindow()

	UnboxWindowOpen = true

	SpinPanel = vgui.Create("DPanel" , Frame)
	SpinPanel:SetSize(680 , 315)
	SpinPanel:SetPos(ScrW() / 2, ScrH() / 2)
	SpinPanel.Paint = function(self, w ,h)

		draw.RoundedBox(0,0,0,w,h,Color(30,30,30))

    end

end

local dollarImage = "data/wimages/moneybox.png"
local rubleImage = "data/wimages/gem.png"

local function GenerateItems(DataTable)

	local randomItems = DataTable

	for i = 0 , 99 do
		
		items[i] = {}
		items[i].xPos = ((((280 + 10) * i) * -1) + ((280 + 10)/2)) - 80

		items[i].panel = vgui.Create("DPanel" , SpinPanel)
		items[i].panel.id = i
		items[i].panel.item = randomItems[i]
		items[i].panel:SetPos( ((((280 + 10) * i) * -1) + ((280 + 10)/2)) - 55 ,10)
		items[i].panel:SetSize(280 , 280)
		items[i].panel.Paint = function(self , w , h)

			draw.RoundedBox(0,0,0,w,h,Color(20,20,20))
			draw.RoundedBox(0,0,h-80,w,80,self.item.itemColor)
			draw.SimpleText(self.item.itemName , "SpinFont" , 5,205 , Color(255,255,255))

		end

		if randomItems[i].Type == "POINTS" then

			items[i].modelView  = vgui.Create("DImage" , items[i].panel )
			items[i].modelView:SetSize(200,200)
			items[i].modelView:SetPos(40,0)
			items[i].modelView:SetImage(rubleImage)

		elseif randomItems[i].Type == "MONEY" then
			items[i].modelView  = vgui.Create("DImage" , items[i].panel )
			items[i].modelView:SetSize(200,200)
			items[i].modelView:SetPos(40,0)
            items[i].modelView:SetImage(dollarImage)
		else
			items[i].modelView  = vgui.Create("DImage" , items[i].panel )
			items[i].modelView:SetSize(200,200)
			items[i].modelView:SetPos(40,0)
            items[i].modelView:SetImage(items[i].panel.item.itemModel)
		end

	end

	Line = vgui.Create("DPanel" , SpinPanel)
	Line:SetSize(680 , 300)
	Line.Paint = function(self , w , h)
		draw.RoundedBox(0,680/2 - 2 , 0 , 4 , h , Color(244,129,0 , 150))
	end
	
    skip = vgui.Create("DButton", SpinPanel)
    skip:Dock(BOTTOM)
    skip:DockMargin(SpinPanel:GetWide() / 3,0,SpinPanel:GetWide() / 3,1)
    skip:SetText('Пропустить')
    skip:SetIcon('icon16/cross.png')
    --skip:SetSkin('WayZer')
    skip.DoClick = function()
		isSpinning = false

		net.Start("FinishedUnbox")
		net.SendToServer()

		surface.PlaySound("buttons/lever6.wav")

		IsUnboxingItems = false
		
		SpinPanel:Remove()
    end

end

local Speed = 10000
local EndPoint = 0

local function Spin(data, case, s, e)

	CreateWindow()

	for k ,v in pairs(items) do
		
		if IsValid(items[k].panel) then

			items[k].panel:Remove()
			items[k].modelView:Remove()

		end

	end

	if IsValid(Line) then

		Line:Remove()

	end

	IsUnboxingItems = true

	GenerateItems(data)
	
	isSpinning = true

	Speed = s
	EndPoint = e
end

local prevItemValue = 0



local function SpinItems()

	Speed = Lerp(0.4*FrameTime() , Speed , EndPoint )

	for k ,v in pairs(items) do
		
		v.panel:SetPos(v.xPos + Speed , 10)

	end



	if Speed < EndPoint + 10 then
		
		isSpinning = false

		net.Start("FinishedUnbox")
		net.SendToServer()

		surface.PlaySound("buttons/lever6.wav")

		IsUnboxingItems = false
		
		SpinPanel:Remove()

	end

end

local function spinUpdate()

	if isSpinning then
		
		SpinItems()

	end


end


hook.Add("Think" , "Spin The Items" , spinUpdate)

--]] 

surface.CreateFont( "SpinFont", {
	font = "Nexa Bold",
	size = 30,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

net.Receive("InitSpin" , function()

	local data = net.ReadTable()
	local case = net.ReadString()
	local s = net.ReadInt(16)
	local e = net.ReadInt(16)

	--Spin(data, case, s, e)
	PS:OpenCaseMenu(data, case, s, e)

end)

--addons/module_waygrab/lua/autorun/client/cl_waygrab.lua:
local quality = CreateClientConVar('waygrab_quality', '30', true)

local capturing = false
local screenshotRequested = false
--local screenshotFailed = false
local stopScreenGrab = false
local inFrame = false
local screenshotRequestedLastFrame = false
local split = 20000
local screengrabParts = {}
local frame = {}
local shouldSaveScreengrab = false
local screengrabQuality = 30
 
hook.Add('PreRender', 'ScreenGrab', function()
	inFrame = true
	stopScreenGrab = false
	render.SetRenderTarget()
end)
 
local screengrabRT = GetRenderTarget('ScreengrabRT' .. ScrW() .. '_' .. ScrH(), ScrW(), ScrH())
 
hook.Add('PostRender', 'ScreenGrab', function(vOrigin, vAngle, vFOV)
	if stopScreenGrab then return end
    if not screenshotRequested then return end
	inFrame = false
 
	if screenshotRequestedLastFrame then
		render.PushRenderTarget(screengrabRT)
	else
		render.CopyRenderTargetToTexture(screengrabRT)
		render.SetRenderTarget(screengrabRT)
	end
 
	if screenshotRequested or screenshotRequestedLastFrame then
        local selfScreengrabParts = {}
		screenshotRequested = false
 
        --[[
		if jit.version == 'LuaJIT 2.1.0-beta3' then
			if screenshotRequestedLastFrame then
				screenshotRequestedLastFrame = false
			else
				screenshotRequestedLastFrame = true
			    return
            end
		end
        ]]

        cam.Start2D()
			surface.SetFont('Trebuchet24')
			local text = LocalPlayer():SteamID()
			local x, y = ScrW() * 0.5, ScrH() * 0.5
			local w, h = surface.GetTextSize(text)
 
			surface.SetDrawColor(0, 0, 0, 100)
			surface.DrawRect(x - w * 0.5 - 5, y - h * 0.5 - 5, w + 10, h + 10)
 
			surface.SetTextPos(math.ceil(x - w * 0.5 ), math.ceil(y - h * 0.5))
			surface.SetTextColor(255, 255, 255)
			surface.DrawText(text)
 
			surface.SetDrawColor(255, 255, 255)
			surface.DrawRect(0, 0, 1, 1)
		cam.End2D()

		render.CapturePixels()
		local r, g, b = render.ReadPixel( 0, 0 )
		if r != 255 or g != 255 or b != 255 then
			net.Start('waygrab.fail')
				net.WriteString('Попытка подделки скриншота. (1)')
			net.SendToServer()
			--return
		end
 
		capturing = true
		local frame1 = FrameNumber()
		local data = render.Capture({
			format = 'jpeg',
			quality = screengrabQuality,
			x = 0,
			y = 0,
			w = ScrW(),
			h = ScrH()
		})
		local frame2 = FrameNumber()
		capturing = false
 
		if frame1 ~= frame2 then
			net.Start('waygrab.fail')
				net.WriteString('Попытка подделки скриншота. (2)')
			net.SendToServer()
			--return
		end

        local base = util.Compress(util.Base64Encode(data))
        local len = base:len()

        local parts = math.ceil(len/split)

        for i = 1, parts do
            local min
            local max
            if i == 1 then
                min = i
                max = split
            elseif i > 1 and i ~= parts then
                min = (i - 1) * split + 1
                max = min + split - 1
            elseif i > 1 and i == parts then
                min = (i - 1) * split + 1
                max = len
            end
            local str = string.sub(base, min, max)
            selfScreengrabParts[i] = str
        end

        local i = 1
        timer.Create('waygrab.sendParts', .1, #selfScreengrabParts, function()
            local part = selfScreengrabParts[i]

            net.Start('waygrab.sendPart')
            net.WriteUInt(part:len(), 32)
            net.WriteData(part, part:len())
            net.SendToServer()

            if i == #selfScreengrabParts then
                timer.Simple(.1, function()
                    net.Start('waygrab.success')
                    net.SendToServer()
                end)
            end

            i = i + 1
        end)
	end
 
	if screenshotRequestedLastFrame then
		render.PopRenderTarget()
		render.CopyRenderTargetToTexture(screengrabRT)
		render.SetRenderTarget(screengrabRT)
	end
end)

net.Receive('waygrab.sendPart', function()
    local len = net.ReadUInt(32)
    local data = net.ReadData(len)

    table.insert(screengrabParts, data)
end)
 
hook.Add('PreDrawViewModel', 'ScreenGrab', function()
	if capturing then
		net.Start('waygrab.fail')
			net.WriteString('Попытка подделки скриншота. (3)')
		net.SendToServer()
		--screenshotFailed = true
	end
end)

local function displayData(str, name)
    local main = vgui.Create('DFrame', vgui.GetWorldPanel())
    main:SetPos(0, 0)
    main:SetSize(ScrW(), ScrH())
    main:SetTitle(name or 'Скринграб')
    main:MakePopup()

    local html = vgui.Create('HTML', main)
    html:DockMargin(0, 0, 0, 0)
    html:Dock(FILL)
    html:SetHTML([[ <img width="]] .. ScrW() .. [[" height="]] .. ScrH() .. [[" src="data:image/jpeg;base64, ]] .. str .. [["/> ]])
end
 
net.Receive('waygrab.start', function()
	screenshotRequested = true
    screengrabQuality = net.ReadUInt(8) or 30
end)
 
net.Receive('waygrab.success', function()
    local finalData = util.Decompress(table.concat(screengrabParts))

    if shouldSaveScreengrab then
        if not file.Exists('waygrabs', 'DATA') then
            file.CreateDir('waygrabs')
        end
        file.Write('waygrabs/'..net.ReadString()..'_'..os.date('%H-%M_%d-%m-%Y')..'.txt', finalData)
    end

    displayData(finalData, net.ReadString())

    screengrabParts = {}
    shouldSaveScreengrab = false
end)
 
hook.Add('ShutDown', 'waygrab.stop', function()
	stopScreenGrab = true
	render.SetRenderTarget()
end)
 
hook.Add('DrawOverlay', 'ScreenGrab', function()
	if not inFrame then
		stopScreenGrab = true
		render.SetRenderTarget()
	end
end)

local canScreengrab = {
    ['Curator'] = true,
    ['Patron'] = true,
    ['Helper'] = true,
    ['+Helper'] = true,
    ['moder'] = true,
    ['admin'] = true,
    ['Trusted'] = true,
    ['WayZer Team'] = true,
    ['superadmin'] = true,
}

local function openFrame()
    if not canScreengrab[LocalPlayer():GetRealUserGroup()] then return LocalPlayer():ChatPrint('No Access') end

    frame.main = vgui.Create('DFrame')
    frame.main:SetSize(600, 250)
    frame.main:SetTitle('Скринграб')
    frame.main:SetIcon('icon16/camera.png')
    frame.main:MakePopup()
    frame.main.Paint = function(s,w,h)
        draw.RoundedBox(4,0,0,w,h,Color(54,57,62))
    end

    frame.savedPnl = vgui.Create('DPanel', frame.main)
    frame.savedPnl:Dock(LEFT)
    frame.savedPnl:SetPaintBackground(false)
    frame.savedPnl:SetWide(frame.main:GetWide()*0.35)

    frame.openSaved = vgui.Create('DButton', frame.savedPnl)
    frame.openSaved:Dock(BOTTOM)
    frame.openSaved:SetText('Открыть')

    frame.saved = vgui.Create('DListView', frame.savedPnl)
    frame.saved:Dock(FILL)
    frame.saved:AddColumn('Название')
    frame.saved:SetMultiSelect(false)
    for _, v in pairs(file.Find('waygrabs/*.txt', 'DATA')) do
        local line = frame.saved:AddLine(v)
        line.DoRightClick = function()
            local menu = DermaMenu()

            menu:AddOption('Удалить', function()
                file.Delete('waygrabs/'..v, 'DATA')
            end)

            menu:Open()
        end
    end

    frame.openSaved.DoClick = function()
        local id = frame.saved:GetSelectedLine()
        if not id then return notification.AddLegacy('Ты не выбрал сохранение', 1, 3) end

        local line = frame.saved:GetLine(id)
        local name = line:GetColumnText(1)
        local data = file.Read('waygrabs/'..name, 'DATA')
        displayData(data, name)
    end

    frame.quality = vgui.Create('DNumSlider', frame.main)
    frame.quality:Dock(TOP)
    frame.quality:SetText('Качество скринграба')
    frame.quality:SetConVar('waygrab_quality')
    frame.quality:SetMinMax(1, 60)
    frame.quality:SetDecimals(0)
    frame.quality:SetTall(25)

    frame.players = vgui.Create('DComboBox', frame.main)
    frame.players:Dock(TOP)
    frame.players:SetValue('Выбери игрока')
    frame.players:SetTall(25)
    frame.players:DockMargin(0,8,0,0)
    for _, v in player.Iterator() do
        frame.players:AddChoice(v:Name(), v:SteamID())
    end

    frame.shouldSave = vgui.Create('DCheckBoxLabel', frame.main)
    frame.shouldSave:Dock(TOP)
    frame.shouldSave:SetText('Сохранить файл')
    frame.shouldSave:DockMargin(0,8,0,0)
    frame.shouldSave.OnChange = function(val)
        shouldSaveScreengrab = val
    end

    frame.screengrab = vgui.Create('DButton', frame.main)
    frame.screengrab:Dock(TOP)
    frame.screengrab:SetText('Скринграбнуть')
    frame.screengrab:DockMargin(0,8,0,0)
    frame.screengrab:SetTall(25)

    frame.screengrab.DoClick = function()
        local sid = frame.players:GetOptionData(frame.players:GetSelectedID())
        if not sid then return notification.AddLegacy('Ты не выбрал игрока', 1, 3) end

        RunConsoleCommand('waygrab', sid, quality:GetInt())
        frame.main:Close()
    end

    frame.main:InvalidateLayout(true)
    frame.main:SizeToChildren(false, true)
    frame.main:Center()
end

concommand.Add('waygrab_menu', openFrame)

wayscore.AddActionButton('screengrab', {
    name = 'Скринграб',
    icon = 'icon72/camera.png',
    order = -2000,
    rightClick = true,
    check = function(ply) return canScreengrab[LocalPlayer():GetRealUserGroup()] end,
    callback = function(ply)
        RunConsoleCommand('waygrab', ply:SteamID(), quality:GetInt())
    end,
})
--addons/tool_keypad/lua/pkeypad/client/dpatterngrid.lua:

local surface_SetDrawColor = surface.SetDrawColor

local PANEL = {}

Derma_Install_Convar_Functions(PANEL)

AccessorFunc(PANEL, "m_Combination", "Combination")
AccessorFunc(PANEL, "gridWidth", "GridWidth")
AccessorFunc(PANEL, "gridHeight", "GridHeight")

function PANEL:Init()
    self.grid = {}
    self.gridWidth = 3
    self.gridHeight = 3

    self.path = {}
    self.combination = {}

    self.circleRadiusHover = 24
    self.circleRadiusChecked = 32
    self.circleRadius = 16

    self.colPrimary = Color(69, 90, 100)
    self.colSecondary = Color(211, 47, 47)

    for x = 1, self.gridWidth do
        for y = 1, self.gridHeight do
            self.grid[x + y * self.gridWidth] = {
                radius = 0,
                color = Color(0, 0, 0, 80),
                x = 0,
                y = 0,
            }
        end
    end

    self.sliderWidth = vgui.Create("DNumSlider", self)
    self.sliderWidth:SetPos(10, 10)
    self.sliderWidth:SetText(PatternKeypad.language.toolGridColumns)
    self.sliderWidth:SetMin(2)
    self.sliderWidth:SetMax(4)
    self.sliderWidth:SetValue(self.gridWidth)
    self.sliderWidth:SetDecimals(0)
    self.sliderWidth.Label:SetTextColor(Color(0, 0, 0))

    self.sliderWidth.OnValueChanged = function(pnl, v)
        local new = math.Round(v)
        if self:GetGridWidth() == new then return end

        self:SetGridWidth(new)
        self:SetCombination({})
        self:UpdateGrid(true)
        self:UpdatePath()
    end

    self.sliderHeight = vgui.Create("DNumSlider", self)
    self.sliderHeight:SetPos(10, 30)
    self.sliderHeight:SetText(PatternKeypad.language.toolGridRows)
    self.sliderHeight:SetMin(2)
    self.sliderHeight:SetMax(4)
    self.sliderHeight:SetValue(self.gridHeight)
    self.sliderHeight:SetDecimals(0)
    self.sliderHeight.Label:SetTextColor(Color(0, 0, 0))

    self.sliderHeight.OnValueChanged = function(pnl, v)
        local new = math.Round(v)
        if self:GetGridHeight() == new then return end

        self:SetGridHeight(new)
        self:SetCombination({})
        self:UpdateGrid(true)
        self:UpdatePath()
    end

end

function PANEL:UpdateGrid(noUpdateSliders)
    local w, h = self:GetSize()

    local offsetX = w / (self.gridWidth + 1)
    local offsetY = w / (self.gridHeight + 1)

    for x = 1, self.gridWidth do
        for y = 1, self.gridHeight do
            local entry = self.grid[x + y * self.gridWidth]
            if not entry then
                entry = {
                    radius = 0,
                    color = Color(0, 0, 0, 80),
                    x = 0,
                    y = 0,
                }
                self.grid[x + y * self.gridWidth] = entry
            end

            entry.x = offsetX * x
            entry.y = h - offsetY * self.gridHeight + (y - 1) * offsetY + 10
        end
    end

    if not noUpdateSliders then
        self.sliderWidth:SetValue(self.gridWidth)
        self.sliderHeight:SetValue(self.gridHeight)
    end
end

function PANEL:PerformLayout(w, h)
    self:SetTall(w + 40)
    self.sliderWidth:SetWide(w - 20)
    self.sliderHeight:SetWide(w - 20)

    self:UpdateGrid()
end

function PANEL:ClearPath()
    for i = 1, #self.path do
        self.grid[self.path[i].id].checked = false
    end
    self.path = {}
end

function PANEL:UpdateConVar(str)
    RunConsoleCommand(self.m_strConVar, str)
end


function PANEL:SetCombination(combination)
    self.m_Combination = combination

    local comboStr = ""
    for i = 1, #combination do
        comboStr = comboStr .. (combination[i] - self.gridWidth)
        if i ~= #combination then
            comboStr = comboStr .. ","
        end
    end
    local convarStr = self.gridWidth .. "," .. self.gridHeight .. ":" .. comboStr

    self:UpdateConVar(convarStr)
end

function PANEL:UpdatePath()
    local oldPath = self.path
    self:ClearPath()

    for i = 1, #self:GetCombination() do
        local id = self:GetCombination()[i]
        local time = oldPath[i] and oldPath[i].time or 0

        self.path[i] = {
            id = id,
            time = time
        }

        self.grid[id].checked = true
    end
end

function PANEL:SetValue(value)
    if value == "" then return end

    self.gridWidth, self.gridHeight, self.m_Combination = PatternKeypad.parseCombination(value)

    self:UpdateGrid()
    self:UpdatePath()
end


function PANEL:Think()
    self:ConVarStringThink()

    if input.IsMouseDown(MOUSE_LEFT) then
        if not self.oldClick then self.firstHover = true end

        for cx = 1, self.gridWidth do
            for cy = 1, self.gridHeight do
                local entry = self.grid[cx + cy * self.gridWidth]

                if entry.hovered then
                    if self.firstHover then
                        self:ClearPath()
                        self.firstHover = false
                    end

                    if not entry.checked then
                        surface.PlaySound(PatternKeypad.soundClick)

                        self.path[#self.path + 1] = {
                            id = cx + cy * self.gridWidth,
                            time = 0,
                        }
                    end

                    entry.checked = true
                end
            end
        end
    else
        if #self.path > 0 and self.oldClick then
            if #self.path == 1 then
                self:ClearPath()
            else
                local combination = {}

                for i = 1, #self.path do
                    combination[#combination + 1] = self.path[i].id
                end

                if #combination > 1 then
                    self:SetCombination(combination)
                end
            end
        end
        self.firstHover = false
    end

    self.oldClick = input.IsMouseDown(MOUSE_LEFT)
end

function PANEL:Paint(w, h)
    local elapsed = FrameTime()

    draw.NoTexture()

    local cursorX, cursorY = self:LocalCursorPos()

    local wFract = w / 415
    local radiusChecked = self.circleRadiusChecked * wFract
    local radiusHover = self.circleRadiusHover * wFract
    local radius = self.circleRadius * wFract
    local lineWidth = 20 * wFract

    for i = 1, #self.path - 1 do
        local dat = self.path[i]
        dat.time = dat.time + (1 - dat.time) * 12 * elapsed

        local entry = self.grid[dat.id]
        local nextEntry = self.grid[self.path[i + 1].id]

        local dx = nextEntry.x - entry.x
        local dy = nextEntry.y - entry.y
        local ang = math.deg(math.atan2(-dy, dx))

        local mx = (nextEntry.x + entry.x) / 2
        local my = (nextEntry.y + entry.y) / 2
        local dist = math.sqrt(dx * dx + dy * dy)
        surface_SetDrawColor(ColorAlpha(self.colSecondary, dat.time * 255))
        surface.DrawTexturedRectRotated(mx, my, dist + 2, dat.time * lineWidth, ang)
    end

    for cx = 1, self.gridWidth do
        for cy = 1, self.gridHeight do
            local entry = self.grid[cx + cy * self.gridWidth]

            local dx = cursorX - entry.x
            local dy = cursorY - entry.y
            local dist = math.sqrt(dx * dx + dy * dy)

            local hovered = dist < radiusChecked
            if not entry.checked and not entry.hovered and hovered then
                surface.PlaySound(PatternKeypad.soundHover)
            end
            entry.hovered = hovered

            if entry.checked then
                entry.radius = entry.radius + (radiusChecked - entry.radius) * 12 * elapsed
                entry.color = PatternKeypad.lerpColor(entry.color, self.colSecondary, 12 * elapsed)
            else
                if hovered then
                    entry.radius = entry.radius + (radiusHover - entry.radius) * 12 * elapsed
                else
                    entry.radius = entry.radius + (radius - entry.radius) * 8 * elapsed
                end
                entry.color = PatternKeypad.lerpColor(entry.color, Color(0, 0, 0, 80), 12 * elapsed)
            end

            PatternKeypad.drawCircle(entry.x, entry.y, math.Round(entry.radius, 1), 16, entry.color)
        end
    end

    for i = 1, #self.path - 1 do
        local dat = self.path[i]

        local entry = self.grid[dat.id]
        local nextEntry = self.grid[self.path[i + 1].id]

        local dir = Vector(nextEntry.x - entry.x, nextEntry.y - entry.y, 0):GetNormalized()
        local perp = Vector(-dir.y, dir.x, 0)

        local sx = entry.x
        local sy = entry.y
        local sr = (entry.radius / 2) * dat.time
        local arrowWidth = dat.time * 10 * wFract

        local tbl = {
            { x = sx + dir.x * (sr + arrowWidth), y = sy + dir.y * (sr + arrowWidth) },
            { x = sx + dir.x * (sr - 3) + perp.x * arrowWidth, y = sy + dir.y * (sr - 3) + perp.y * arrowWidth },
            { x = sx + dir.x * (sr - 3) - perp.x * arrowWidth, y = sy + dir.y * (sr - 3) - perp.y * arrowWidth },
        }

        surface_SetDrawColor(Color(255, 255, 255, dat.time * 255))
        surface.DrawPoly(tbl)
    end
end

vgui.Register("DPatternKeypadGrid", PANEL, "Panel")

--gamemodes/darkrp/gamemode/config/config.lua:
--[[-------------------------------------------------------------------------
DarkRP config settings.
-----------------------------------------------------------------------------

This is the settings file of DarkRP. Every DarkRP setting is listed here.

Warning:
If this file is missing settings (because of e.g. an update), DarkRP will assume default values for these settings.
You need not worry about updating this file. If a new setting is added you can manually add them to this file.
---------------------------------------------------------------------------]]


--[[
Toggle settings.
Set to true or false.
]]

-- voice3D - Enable/disable 3DVoice is enabled.
GM.Config.voice3D                       = true
-- AdminsCopWeapons - Enable/disable admins spawning with cop weapons.
GM.Config.AdminsCopWeapons              = false
-- adminBypassJobCustomCheck - Enable/disable whether an admin can force set a job with whenever customCheck returns false.
GM.Config.adminBypassJobRestrictions    = true
-- allow people getting their own custom jobs.
GM.Config.allowjobswitch                = true
-- allowrpnames - Allow Players to Set their RP names using the /rpname command.
GM.Config.allowrpnames                  = true
-- allowsprays - Enable/disable the use of sprays on the server.
GM.Config.allowsprays                   = false
-- allowvehicleowning - Enable/disable whether people can own vehicles.
GM.Config.allowvehicleowning            = true
-- allowvnocollide - Enable/disable the ability to no-collide a vehicle (for security).
GM.Config.allowvnocollide               = false
-- alltalk - Enable for global chat, disable for local chat.
GM.Config.alltalk                       = false
-- autovehiclelock - Enable/Disable automatic locking of a vehicle when a player exits it.
GM.Config.autovehiclelock               = false
-- babygod - people spawn godded (prevent spawn killing).
GM.Config.babygod                       = false
-- canforcedooropen - whether players can force an unownable door open with lockpick or battering ram or w/e.
GM.Config.canforcedooropen              = true
-- chatsounds - sounds are played when some things are said in chat.
GM.Config.chatsounds                    = false
-- chiefjailpos - Allow the Chief to set the jail positions.
GM.Config.chiefjailpos                  = false
-- cit_propertytax - Enable/disable property tax that is exclusive only for citizens.
GM.Config.cit_propertytax               = false
-- copscanunfreeze - Enable/disable the ability of cops to unfreeze other people's props.
GM.Config.copscanunfreeze               = true
-- copscanunweld - Enable/disable the ability of cops to unweld other people's props.
GM.Config.copscanunweld                 = true
-- cpcanarrestcp - Allow/Disallow CPs to arrest other CPs.
GM.Config.cpcanarrestcp                 = false
-- currencyLeft - The position of the currency symbol. true for left, false for right.
GM.Config.currencyLeft                  = true
-- customjobs - Enable/disable the /job command (personalized job names).
GM.Config.customjobs                    = true
-- customspawns - Enable/disable whether custom spawns should be used.
GM.Config.customspawns                  = false
-- deathblack - Whether or not a player sees black on death.
GM.Config.deathblack                    = false
-- showdeaths - Display kill information in the upper right corner of everyone's screen.
GM.Config.showdeaths                    = false
-- deadtalk - Enable/disable whether people talk and use commands while dead.
GM.Config.deadtalk                      = false
-- deadvoice - Enable/disable whether people talk through the microphone while dead.
GM.Config.deadvoice                     = false
-- deathpov - Enable/disable whether people see their death in first person view.
GM.Config.deathpov                      = false
-- decalcleaner - Enable/Disable clearing ever players decals.
GM.Config.decalcleaner                  = true
-- disallowClientsideScripts - Clientside scripts can be very useful for customizing the HUD or to aid in building. This option bans those scripts.
GM.Config.disallowClientsideScripts     = false
-- doorwarrants - Enable/disable Warrant requirement to enter property.
GM.Config.doorwarrants                  = true
-- dropmoneyondeath - Enable/disable whether people drop money on death.
GM.Config.dropmoneyondeath              = true
-- droppocketarrest - Enable/disable whether people drop the stuff in their pockets when they get arrested.
GM.Config.droppocketarrest              = false
-- droppocketdeath - Enable/disable whether people drop the stuff in their pockets when they die.
GM.Config.droppocketdeath               = false
-- dropweapondeath - Enable/disable whether people drop their current weapon when they die.
GM.Config.dropweapondeath               = true
-- Whether players can drop the weapons they spawn with.
GM.Config.dropspawnedweapons            = false
-- dynamicvoice - Enable/disable whether only people in the same room as you can hear your mic.
GM.Config.dynamicvoice                  = true
-- earthquakes - Enable/disable earthquakes.
GM.Config.earthquakes                   = false
-- enablebuypistol - Turn /buy on of off.
GM.Config.enablebuypistol               = true
-- enforceplayermodel - Whether or not to force players to use their role-defined character models.
GM.Config.enforceplayermodel            = true
-- globalshow - Whether or not to display player info above players' heads in-game.
GM.Config.globalshow                    = false
-- ironshoot - Enable/disable whether people need iron sights to shoot.
GM.Config.ironshoot                     = true
-- showjob - Whether or not to display a player's job above their head in-game.
GM.Config.showjob                       = false
-- letters - Enable/disable letter writing / typing.
GM.Config.letters                       = true
-- license - Enable/disable People need a license to be able to pick up guns.
GM.Config.license                       = false
-- lockdown - Enable/Disable initiating lockdowns for mayors.
GM.Config.lockdown                      = false
-- lockpickfading - Enable/disable the lockpicking of fading doors.
GM.Config.lockpickfading                = false
-- logging - Enable/disable logging everything that happens.
GM.Config.logging                       = true
-- lottery - Enable/disable creating lotteries for mayors.
GM.Config.lottery                       = true
-- showname - Whether or not to display a player's name above their head in-game.
GM.Config.showname                      = false
-- showhealth - Whether or not to display a player's health above their head in-game.
GM.Config.showhealth                    = false
-- needwantedforarrest - Enable/disable Cops can only arrest wanted people.
GM.Config.needwantedforarrest           = false
-- noguns - Enabling this feature bans Guns and Gun Dealers.
GM.Config.noguns                        = false
-- norespawn - Enable/Disable that people don't have to respawn when they change job.
GM.Config.norespawn                     = false
-- npcarrest - Enable/disable arresting npc's.
GM.Config.npcarrest                     = true
-- ooc - Whether or not OOC tags are enabled.
GM.Config.ooc                           = true
-- propertytax - Enable/disable property tax.
GM.Config.propertytax                   = false
-- proppaying - Whether or not players should pay for spawning props.
GM.Config.proppaying                    = false
-- propspawning - Enable/disable props spawning. Applies to admins too.
GM.Config.propspawning                  = true
-- removeclassitems - Enable/disable shipments/microwaves/etc. removal when someone changes team.
GM.Config.removeclassitems              = true
-- removeondisconnect - Enable/disable shipments/microwaves/etc. removal when someone disconnects.
GM.Config.removeondisconnect            = true
-- respawninjail - Enable/disable whether people can respawn in jail when they die.
GM.Config.respawninjail                 = true
-- restrictallteams - Enable/disable Players can only be citizen until an admin allows them.
GM.Config.restrictallteams              = false
-- restrictbuypistol - Enabling this feature makes /buy available only to Gun Dealers.
GM.Config.restrictbuypistol             = false
-- restrictdrop - Enable/disable restricting the weapons players can drop. Setting this to true disallows weapons from shipments from being dropped.
GM.Config.restrictdrop                  = false
-- revokeLicenseOnJobChange - Whether licenses are revoked when a player changes jobs.
GM.Config.revokeLicenseOnJobChange      = true
-- shouldResetLaws - Enable/Disable resetting the laws back to the default law set when the mayor changes.
GM.Config.shouldResetLaws               = true
-- strictsuicide - Whether or not players should spawn where they suicided.
GM.Config.strictsuicide                 = false
-- telefromjail - Enable/disable teleporting from jail.
GM.Config.telefromjail                  = true
-- teletojail - Enable/disable teleporting to jail.
GM.Config.teletojail                    = true
-- unlockdoorsonstart - Enable/Disable unlocking all doors on map start.
GM.Config.unlockdoorsonstart            = false
-- voiceradius - Enable/disable local voice chat.
GM.Config.voiceradius                   = true
-- tax - Whether players pay taxes on their wallets.
GM.Config.wallettax                     = false
-- wantedsuicide - Enable/Disable suiciding while you are wanted by the police.
GM.Config.wantedsuicide                 = false
-- realisticfalldamage - Enable/Disable dynamic fall damage. Setting mp_falldamage to 1 will over-ride this.
GM.Config.realisticfalldamage           = true
-- printeroverheat - Whether the default money printer can overheat on its own.
GM.Config.printeroverheat               = true
-- weaponCheckerHideDefault - Hide default weapons when checking weapons.
GM.Config.weaponCheckerHideDefault      = true
-- weaponCheckerHideNoLicense - Hide weapons that do not require a license.
GM.Config.weaponCheckerHideNoLicense    = false

--[[
Value settings
]]
-- adminnpcs - Whether or not NPCs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminnpcs                     = 2
-- adminsents - Whether or not SENTs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminsents                    = 1
-- adminvehicles - Whether or not vehicles should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminvehicles                 = 2
-- adminweapons - Who can spawn weapons: 0: admins only, 1: supadmins only, 2: no one
GM.Config.adminweapons                  = 1
-- arrestspeed - Sets the max arrest speed.
GM.Config.arrestspeed                   = 100
-- babygodtime - How long the babygod lasts.
GM.Config.babygodtime                   = 5
-- chatsoundsdelay - How long to wait before letting a player emit a sound from their chat again.
-- Leave this on at least a few seconds to prevent people from spamming sounds. Set to 0 to disable.
GM.Config.chatsoundsdelay               = 5
-- deathfee - the amount of money someone drops when dead.
GM.Config.deathfee                      = 2500
-- decaltimer - Sets the time to clear clientside decals (in seconds).
GM.Config.decaltimer                    = 120
-- demotetime - Number of seconds before a player can rejoin a team after demotion from that team.
GM.Config.demotetime                    = 120
-- doorcost - Sets the cost of a door.
GM.Config.doorcost                      = 6000
-- entremovedelay - how long to wait before removing a bought entity after disconnect.
GM.Config.entremovedelay                = 0
-- gunlabweapon - The weapon that the gunlab spawns.
GM.Config.gunlabweapon                  = "weapon_p2282"
-- jailtimer - Sets the jailtimer (in seconds).
GM.Config.jailtimer                     = 300
-- lockdowndelay - The amount of time a mayor must wait before starting the next lockdown
GM.Config.lockdowndelay                 = 600
-- maxadvertbillboards - The maximum number of /advert billboards a player can place.
GM.Config.maxadvertbillboards           = 0
-- maxdoors - Sets the max amount of doors one can own.
GM.Config.maxdoors                      = 3
-- maxdrugs - Sets max drugs.
GM.Config.maxdrugs                      = 2
-- maxfoods - Sets the max food cartons per Microwave owner.
GM.Config.maxfoods                      = 2
-- maxlawboards - The maximum number of law boards the mayor can place.
GM.Config.maxlawboards                  = 0
-- maxletters - Sets max letters.
GM.Config.maxletters                    = 10
-- maxlotterycost - Maximum payment the mayor can set to join a lottery.
GM.Config.maxlotterycost                = 50000000
-- maxvehicles - Sets how many vehicles one can buy.
GM.Config.maxvehicles                   = 5
-- microwavefoodcost - Sets the sale price of Microwave Food.
GM.Config.microwavefoodcost             = 30
-- minlotterycost - Minimum payment the mayor can set to join a lottery.
GM.Config.minlotterycost                = 30
-- Money packets will get removed if they don't get picked up after a while. Set to 0 to disable.
GM.Config.moneyRemoveTime               = 60
-- mprintamount - Value of the money printed by the money printer.
GM.Config.mprintamount                  = 250
-- normalsalary - Sets the starting salary for newly joined players.
GM.Config.normalsalary                  = 45
-- npckillpay - Sets the money given for each NPC kill.
GM.Config.npckillpay                    = 1
-- paydelay - Sets how long it takes before people get salary.
GM.Config.paydelay                      = 120
-- pocketitems - Sets the amount of objects the pocket can carry.
GM.Config.pocketitems                   = 10
-- pricecap - The maximum price of items (using /price).
GM.Config.pricecap                      = 500
-- pricemin - The minimum price of items (using /price).
GM.Config.pricemin                      = 50
-- propcost - How much prop spawning should cost (prop paying must be enabled for this to have an effect).
GM.Config.propcost                      = 10
-- quakechance - Chance of an earthquake happening.
GM.Config.quakechance                   = 4000
-- respawntime - Minimum amount of seconds a player has to wait before respawning.
GM.Config.respawntime                   = 1
-- changejobtime - Minimum amount of seconds a player has to wait before changing job.
GM.Config.changejobtime                 = 40
-- runspeed - Sets the max running speed.
GM.Config.runspeed                      = 240
-- runspeed - Sets the max running speed for CP teams.
GM.Config.runspeedcp                    = 255
-- searchtime - Number of seconds for which a search warrant is valid.
GM.Config.searchtime                    = 300
-- ShipmentSpawnTime - Antispam time between spawning shipments.
GM.Config.ShipmentSpamTime              = 3
-- shipmenttime - The number of seconds it takes for a shipment to spawn.
GM.Config.shipmentspawntime             = 2
-- startinghealth - the health when you spawn.
GM.Config.startinghealth                = 100
-- startingmoney - your wallet when you join for the first time.
GM.Config.startingmoney                 = 100000
-- vehiclecost - Sets the cost of a vehicle (To own it).
GM.Config.vehiclecost                   = 40
-- wallettaxmax - Maximum percentage of tax to be paid.
GM.Config.wallettaxmax                  = 5
-- wallettaxmin - Minimum percentage of tax to be paid.
GM.Config.wallettaxmin                  = 1
-- wallettaxtime - Time in seconds between taxing players. Requires server restart.
GM.Config.wallettaxtime                 = 600
-- wantedtime - Number of seconds for which a player is wanted for.
GM.Config.wantedtime                    = 300
-- walkspeed - Sets the max walking speed.
GM.Config.walkspeed                     = 160
-- falldamagedamper - The damper on realistic fall damage. Default is 15. Decrease this for more damage.
GM.Config.falldamagedamper              = 15
-- falldamageamount - The base damage taken from falling for static fall damage. Default is 10.
GM.Config.falldamageamount              = 10
-- printeroverheatchance - The likelyhood of a printer overheating. The higher this number, the less likely (minimum 3, default 22).
GM.Config.printeroverheatchance         = 22
-- printerreward - Reward for destroying a money printer.
GM.Config.printerreward                 = 950
-- Количество выпадающих денег при смерти
GM.Config.dropmoneyondeath              = 500
--[[---------------------------------------------------------------------------
Other settings
---------------------------------------------------------------------------]]

-- The classname of money packets. Use this to create your own money entity!
-- Note: the money packet must support the "Setamount" method (or the amount DTVar).
GM.Config.MoneyClass = "spawned_money"
-- In case you do wish to keep the default money, but change the model, this option is the way to go:
GM.Config.moneyModel = "models/props/cs_assault/money.mdl"
-- You can set your own, custom sound to be played for all players whenever a lockdown is initiated.
-- Note: Remember to include the folder where the sound file is located.
GM.Config.lockdownsound = "npc/overwatch/cityvoice/f_confirmcivilstatus_1_spkr.wav"

-- The skin DarkRP uses. Set to "default" to use the GMod default derma theme.
GM.Config.DarkRPSkin = "DarkRP"
GM.Config.currency = "$"
GM.Config.chatCommandPrefix = "/"
GM.Config.F1MenuHelpPage = "http://wiki.darkrp.com/index.php/Main_Page"
GM.Config.F1MenuHelpPageTitle = "Wiki page"

-- Put Steam ID's and ranks in this list, and the players will have that rank when they join.
GM.Config.DefaultPlayerGroups = {
    ["STEAM_0:0:00000000"] = "superadmin",
    ["STEAM_0:0:11111111"] = "admin",
}

-- Custom modules in this addon that are disabled.
GM.Config.DisabledCustomModules = {
       ["hudreplacement"] = false,
       ["extraf4tab"] = false,
}

-- The list of weapons that players are not allowed to drop. Items set to true are not allowed to be dropped.
GM.Config.DisallowDrop = {
    ["arrest_stick"] = true,
    ["door_ram"] = true,
    ["gmod_camera"] = true,
    ["gmod_tool"] = true,
    ["keys"] = true,
    ["lockpick"] = true,
    ["med_kit"] = true,
    ["pocket"] = true,
    ["stunstick"] = true,
    ["unarrest_stick"] = true,
    ["weapon_keypadchecker"] = true,
    ["weapon_physcannon"] = true,
    ["weapon_physgun"] = true,
    ["weaponchecker"] = true,
    ["weapon_fists"] = true,
    ["weapon_rape"] = true,
    ["weapon_suicide"] = true,
    ["climb_swep2"] = true,
    ["keypad_cracker"] = true,
    ["guitar_stalker"] = true,
    ["laserjetpack"] = true,
    ["weapon_army"] = true,
    ['stungun'] = true,
    ['mp_weapon_smart_pistol'] = true,
    ['itemstore_pickup'] = true,
}

-- The list of weapons people spawn with.
GM.Config.DefaultWeapons = {
    "keys",
    "weapon_physcannon",
    "gmod_camera",
    "gmod_tool",
    "itemstore_pickup",
    "weapon_physgun",
    "weapon_fists",
}

-- Override categories.
-- NOTE: categories are to be set in the "category" field of the custom jobs/shipments/entities/ammo/pistols/vehicles.
-- Use this only to override the categories of _default_ things.
-- This will NOT work for your own custom stuff.
-- Make sure the category is created in the darkrp_customthings/categories.lua, otherwise it won't work!
GM.Config.CategoryOverride = {
    jobs = {
        ["Citizen"]                             = "Citizens",
        ["Hobo"]                                = "Citizens",
        ["Gun Dealer"]                          = "Citizens",
        ["Medic"]                               = "Citizens",
        ["Civil Protection"]                    = "Civil Protection",
        ["Gangster"]                            = "Gangsters",
        ["Mob boss"]                            = "Gangsters",
        ["Civil Protection Chief"]              = "Civil Protection",
        ["Mayor"]                               = "Civil Protection",
    },
    entities = {
        ["Drug lab"]                            = "Other",
        ["Money printer"]                       = "Other",
        ["Gun lab"]                             = "Other",
    },
    shipments = {
        ["AK47"]                                = "Rifles",
        ["MP5"]                                 = "Rifles",
        ["M4"]                                  = "Rifles",
        ["Mac 10"]                              = "Other",
        ["Pump shotgun"]                        = "Shotguns",
        ["Sniper rifle"]                        = "Snipers",
    },
    weapons = {
        ["Desert eagle"]                        = "Pistols",
        ["Fiveseven"]                           = "Pistols",
        ["Glock"]                               = "Pistols",
        ["P228"]                                = "Pistols",
    },
    vehicles = {}, -- There are no default vehicles.
    ammo = {
        ["Pistol ammo"]                         = "Other",
        ["Shotgun ammo"]                        = "Other",
        ["Rifle ammo"]                          = "Other",
    },
}

-- The list of weapons admins spawn with, in addition to the default weapons, a job's weapons and GM.Config.AdminsCopWeapons.
GM.Config.AdminWeapons = {
    "weapon_keypadchecker",
}

-- These are the default laws, they're unchangeable in-game.
GM.Config.DefaultLaws = {
    "Если принтеры легальны,то только на хранение у банкира"
}

GM.Config.PocketBlacklist = {
    ["fadmin_jail"] = true,
    ["meteor"] = true,
    ["door"] = true,
    ["func_"] = true,
    ["player"] = true,
    ["beam"] = true,
    ["worldspawn"] = true,
    ["env_"] = true,
    ["path_"] = true,
    ["prop_physics"] = true,
    ["money_printer"] = true,
    ["gunlab"] = true,
    ["prop_dynamic"] = true,
    ["prop_vehicle_prisoner_pod"] = true,
    ["keypad_wire"] = true,
    ["gmod_button"] = true,
    ["gmod_rtcameraprop"] = true,
    ["gmod_cameraprop"] = true,
    ["gmod_dynamite"] = true,
    ["gmod_thruster"] = true,
    ["gmod_light"] = true,
    ["gmod_lamp"] = true,
    ["gmod_emitter"] = true,
}

-- These weapons are classed as 'legal' in the weapon checker and are not stripped when confiscating weapons.
-- This setting is used IN ADDITION to GM.Config.weaponCheckerHideDefault and GM.Config.weaponCheckerHideNoLicense.
-- You should use the former if you want to class the default weapons (GM.Config.DefaultWeapons and, if admin, GM.Config.AdminWeapons) and a player's job weapons as legal.
-- The latter takes GM.NoLicense weapons as legal (see licenseweapons.lua).
-- The format of this config is similar to GM.Config.DisallowDrop.
GM.Config.noStripWeapons = {
    ["weapon_handcuffed"] = true,
}

-- The entities listed here will not be removed when a player changes their job.
-- This only applies when removeclassitems is set to true.
-- Note: entities will only be removed when the player changes to a job that is not allowed to have the entity.
GM.Config.preventClassItemRemoval = {
    ["gunlab"] = false,
    ["microwave"] = false,
    ["spawned_shipment"] = false,
}

-- Properties set to true are allowed to be used. Values set to false or are missing from this list are blocked.
GM.Config.allowedProperties = {
    remover = true,
    extinguish = true,
    collision = true,
    skin = true,
    bodygroups = true,
    ignite = false,
    keepupright = false,
    gravity = false,
    bonemanipulate = false,
    persist = false,
}

--[[---------------------------------------------------------------------------
F4 menu
---------------------------------------------------------------------------]]
-- hide the items that you can't buy and the jobs you can't get (instead of graying them out).
-- this option hides items when you don't have enough money, when the maximum is reached for a job or any other reason.
GM.Config.hideNonBuyable = false

-- Hide only the items that you have the wrong job for (or for which the customCheck says no).
-- When you set this option to true and hideNonBuyable to false, you WILL see e.g. items that are too expensive for you to buy.
-- but you won't see gundealer shipments when you have the citizen job.
GM.Config.hideTeamUnbuyable = true

--[[---------------------------------------------------------------------------
AFK module
---------------------------------------------------------------------------]]
-- The time of inactivity before being demoted.
GM.Config.afkdemotetime = 600
-- Prevent people from spamming AFK.
GM.Config.AFKDelay = 300

--[[---------------------------------------------------------------------------
Hitmenu module
---------------------------------------------------------------------------]]
-- The minimum price for a hit.
GM.Config.minHitPrice = 1000
-- The maximum price for a hit.
GM.Config.maxHitPrice = 50000
-- The minimum distance between a hitman and his customer when they make the deal.
GM.Config.minHitDistance = 200
-- The text that tells the player he can press use on the hitman to request a hit.
GM.Config.hudText = "Это наёмник.\nНажми Е чтобы сделать заказ!"
-- The text above a hitman when he's got a hit.
GM.Config.hitmanText = " "
-- The cooldown time for a hit target (so they aren't spam killed).
GM.Config.hitTargetCooldown = 60
-- How long a customer has to wait to be able to buy another hit (from the moment the hit is accepted).
GM.Config.hitCustomerCooldown = 10

--[[---------------------------------------------------------------------------
Hungermod module
---------------------------------------------------------------------------]]
-- hungerspeed <Amount> - Set the rate at which players will become hungry (2 is the default).
GM.Config.hungerspeed = 2
-- starverate <Amount> - How much health that is taken away every second the player is starving  (3 is the default).
GM.Config.starverate = 3

--gamemodes/darkrp/gamemode/libraries/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

IMPORTANT: This is a draft script. It is very much WIP.

Follows the specification on this page:
https://docs.google.com/document/d/1QIRVcAgZfAYf1aBl_dNV_ewR6P25wze2KmUVzlbFgMI


Structures:
	CAMI_USERGROUP, defines the charactaristics of a usergroup:
	{
		Name
			string
			The name of the usergroup
		Inherits
			string
			The name of the usergroup this usergroup inherits from
	}

	CAMI_PRIVILEGE, defines the charactaristics of a privilege:
	{
		Name
			string
			The name of the privilege
		MinAccess
			string
			One of the following three: user/admin/superadmin
		HasAccess
			function(
				privilege :: CAMI_PRIVILEGE,
				actor     :: Player,
				target    :: Player
			) :: bool
			optional
			Function that decides whether a player can execute this privilege,
			optionally on another player (target).
	}
]]

-- Version number in YearMonthDay format.
local version = 20150902.1

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version

--[[
usergroups
	Contains the registered CAMI_USERGROUP usergroup structures.
	Indexed by usergroup name.
]]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
	user = {
		Name = "user",
		Inherits = "user"
	},
	admin = {
		Name = "admin",
		Inherits = "user"
	},
	superadmin = {
		Name = "superadmin",
		Inherits = "admin"
	}
}

--[[
privileges
	Contains the registered CAMI_PRIVILEGE privilege structures.
	Indexed by privilege name.
]]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--[[
CAMI.RegisterUsergroup
	Registers a usergroup with CAMI.

	Parameters:
		usergroup
			CAMI_USERGROUP
			(see CAMI_USERGROUP structure)
		source
			any
			Identifier for your own admin mod. Can be anything.
			Use this to make sure CAMI.RegisterUsergroup function and the
			CAMI.OnUsergroupRegistered hook don't cause an infinite loop



	Return value:
		CAMI_USERGROUP
			The usergroup given as argument.
]]
function CAMI.RegisterUsergroup(usergroup, source)
	usergroups[usergroup.Name] = usergroup

	hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
	return usergroup
end

--[[
CAMI.UnregisterUsergroup
	Unregisters a usergroup from CAMI. This will call a hook that will notify
	all other admin mods of the removal.

	Call only when the usergroup is to be permanently removed.

	Parameters:
		usergroupName
			string
			The name of the usergroup.
		source
			any
			Identifier for your own admin mod. Can be anything.
			Use this to make sure CAMI.UnregisterUsergroup function and the
			CAMI.OnUsergroupUnregistered hook don't cause an infinite loop

	Return value:
		bool
			Whether the unregistering succeeded.
]]
function CAMI.UnregisterUsergroup(usergroupName, source)
	if not usergroups[usergroupName] then return false end

	local usergroup = usergroups[usergroupName]
	usergroups[usergroupName] = nil

	hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

	return true
end

--[[
CAMI.GetUsergroups
	Retrieves all registered usergroups.

	Return value:
		Table of CAMI_USERGROUP, indexed by their names.
]]
function CAMI.GetUsergroups()
	return usergroups
end

--[[
CAMI.GetUsergroup
	Receives information about a usergroup.

	Return value:
		CAMI_USERGROUP
			Returns nil when the usergroup does not exist.
]]
function CAMI.GetUsergroup(usergroupName)
	return usergroups[usergroupName]
end

--[[
CAMI.UsergroupInherits
	Returns true when usergroupName1 inherits usergroupName2.
	Note that usergroupName1 does not need to be a direct child.
	Every usergroup trivially inherits itself.

	Parameters:
		usergroupName1
			string
			The name of the usergroup that is queried.
		usergroupName2
			string
			The name of the usergroup of which is queried whether usergroupName1
			inherits from.

	Return value:
		bool
			Whether usergroupName1 inherits usergroupName2.
]]
function CAMI.UsergroupInherits(usergroupName1, usergroupName2)
	repeat
		if usergroupName1 == usergroupName2 then return true end

		usergroupName1 = usergroups[usergroupName1] and
						 usergroups[usergroupName1].Inherits or
						 usergroupName1
	until not usergroups[usergroupName1] or
		  usergroups[usergroupName1].Inherits == usergroupName1

	-- One can only be sure the usergroup inherits from user if the
	-- usergroup isn't registered.
	return usergroupName1 == usergroupName2 or usergroupName2 == "user"
end

--[[
CAMI.InheritanceRoot
	All usergroups must eventually inherit either user, admin or superadmin.
	Regardless of what inheritance mechism an admin may or may not have, this
	always applies.

	This method always returns either user, admin or superadmin, based on what
	usergroups eventually inherit.

	Parameters:
		usergroupName
			string
			The name of the usergroup of which the root of inheritance is
			requested

	Return value:
		string
			The name of the root usergroup (either user, admin or superadmin)
]]
function CAMI.InheritanceRoot(usergroupName)
	if not usergroups[usergroupName] then return end

	local inherits = usergroups[usergroupName].Inherits
	while inherits ~= usergroups[usergroupName].Inherits do
		usergroupName = usergroups[usergroupName].Inherits
	end

	return usergroupName
end

--[[
CAMI.RegisterPrivilege
	Registers a privilege with CAMI.
	Note: do NOT register all your admin mod's privileges with this function!
	This function is for third party addons to register privileges
	with admin mods, not for admin mods sharing the privileges amongst one
	another.

	Parameters:
		privilege
			CAMI_PRIVILEGE
			See CAMI_PRIVILEGE structure.

	Return value:
		CAMI_PRIVILEGE
			The privilege given as argument.
]]
function CAMI.RegisterPrivilege(privilege)
	privileges[privilege.Name] = privilege

	hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

	return privilege
end

--[[
CAMI.UnregisterPrivilege
	Unregisters a privilege from CAMI. This will call a hook that will notify
	all other admin mods of the removal.

	Call only when the privilege is to be permanently removed.

	Parameters:
		privilegeName
			string
			The name of the privilege.

	Return value:
		bool
			Whether the unregistering succeeded.
]]
function CAMI.UnregisterPrivilege(privilegeName)
	if not privileges[privilegeName] then return false end

	local privilege = privileges[privilegeName]
	privileges[privilegeName] = nil

	hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

	return true
end

--[[
CAMI.GetPrivileges
	Retrieves all registered privileges.

	Return value:
		Table of CAMI_PRIVILEGE, indexed by their names.
]]
function CAMI.GetPrivileges()
	return privileges
end

--[[
CAMI.GetPrivilege
	Receives information about a privilege.

	Return value:
		CAMI_PRIVILEGE when the privilege exists.
			nil when the privilege does not exist.
]]
function CAMI.GetPrivilege(privilegeName)
	return privileges[privilegeName]
end

--[[
CAMI.PlayerHasAccess
	Queries whether a certain player has the right to perform a certain action.
	Note: this function does NOT return an immediate result!
	The result is in the callback!

	Parameters:
		actorPly
			Player
			The player of which is requested whether they have the privilege.
		privilegeName
			string
			The name of the privilege.
		callback
			function(bool, string)
			This function will be called with the answer. The bool signifies the
			yes or no answer as to whether the player is allowed. The string
			will optionally give a reason.
		targetPly
			Optional.
			The player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				Fallback
					string
					Either of user/admin/superadmin. When no admin mod replies,
					the decision is based on the admin status of the user.
					Defaults to admin if not given.
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.

	Return value:
		None, the answer is given in the callback function in order to allow
		for the admin mod to perform e.g. a database lookup.
]]
-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
	function(_, actorPly, privilegeName, callback, _, extraInfoTbl)
		-- The server always has access in the fallback
		if not IsValid(actorPly) then return callback(true, "Fallback.") end

		local priv = privileges[privilegeName]

		local fallback = extraInfoTbl and (
			not extraInfoTbl.Fallback and actorPly:IsAdmin() or
			extraInfoTbl.Fallback == "user" and true or
			extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
			extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


		if not priv then return callback(fallback, "Fallback.") end

		callback(
			priv.MinAccess == "user" or
			priv.MinAccess == "admin" and actorPly:IsAdmin() or
			priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()
			, "Fallback.")
	end,
	["CAMI.SteamIDHasAccess"] =
	function(_, _, _, callback)
		callback(false, "No information available.")
	end
}
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
	hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
		privilegeName, callback, targetPly, extraInfoTbl)
end

--[[
CAMI.GetPlayersWithAccess
	Finds the list of currently joined players who have the right to perform a
	certain action.
	NOTE: this function will NOT return an immediate result!
	The result is in the callback!

	Parameters:
		privilegeName
			string
			The name of the privilege.
		callback
			function(players)
			This function will be called with the list of players with access.
		targetPly
			Optional.
			The player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				Fallback
					string
					Either of user/admin/superadmin. When no admin mod replies,
					the decision is based on the admin status of the user.
					Defaults to admin if not given.
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.
]]
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
	local allowedPlys = {}
	local countdown = player.GetCount()

	local function onResult(ply, hasAccess, _)
		countdown = countdown - 1

		if hasAccess then table.insert(allowedPlys, ply) end
		if countdown == 0 then callback(allowedPlys) end
	end

	for _, ply in player.Iterator() do
		CAMI.PlayerHasAccess(ply, privilegeName,
			function(...) onResult(ply, ...) end,
			targetPly, extraInfoTbl)
	end
end

--[[
CAMI.SteamIDHasAccess
	Queries whether a player with a steam ID has the right to perform a certain
	action.
	Note: the player does not need to be in the server for this to
	work.

	Note: this function does NOT return an immediate result!
	The result is in the callback!

	Parameters:
		actorSteam
			Player
			The SteamID of the player of which is requested whether they have
			the privilege.
		privilegeName
			string
			The name of the privilege.
		callback
			function(bool, string)
			This function will be called with the answer. The bool signifies the
			yes or no answer as to whether the player is allowed. The string
			will optionally give a reason.
		targetSteam
			Optional.
			The SteamID of the player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.

	Return value:
		None, the answer is given in the callback function in order to allow
		for the admin mod to perform e.g. a database lookup.
]]
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
	hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
		privilegeName, callback, targetSteam, extraInfoTbl)
end

--[[
CAMI.SignalUserGroupChanged
	Signify that your admin mod has changed the usergroup of a player. This
	function communicates to other admin mods what it thinks the usergroup
	of a player should be.

	Listen to the hook to receive the usergroup changes of other admin mods.

	Parameters:
		ply
			Player
			The player for which the usergroup is changed
		old
			string
			The previous usergroup of the player.
		new
			string
			The new usergroup of the player.
		source
			any
			Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalUserGroupChanged(ply, old, new, source)
	hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--[[
CAMI.SignalSteamIDUserGroupChanged
	Signify that your admin mod has changed the usergroup of a disconnected
	player. This communicates to other admin mods what it thinks the usergroup
	of a player should be.

	Listen to the hook to receive the usergroup changes of other admin mods.

	Parameters:
		ply
			string
			The steam ID of the player for which the usergroup is changed
		old
			string
			The previous usergroup of the player.
		new
			string
			The new usergroup of the player.
		source
			any
			Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
	hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--gamemodes/darkrp/gamemode/libraries/tablecheck.lua:
--[[
tablecheck

WIP

Author: FPtje Falco

Purpose:
Allow validating tables by creating schemas of tables. Inspired by Joi (https://github.com/hapijs/joi)

Requires fn library (https://github.com/FPtje/GModFunctional),

Example:
```lua
local schema = tc.checkTable{
    name   = tc.addHint(isstring, "The name must be a string!"),
    id     = tc.addHint(isnumber, "The id must be a number!"),
    gender = tc.addHint(tc.oneOf{"male", "female", "carp"}, "Gender missing or not recognised!", {"Perhaps you are a carp?"}),
}

local correct, err, hints = schema({name = "Dick", id = 3, gender = "carp"})
print(correct) -- true


local correct, err, hints = schema({name = "Dick", id = 3, gender = "crap"})
print(correct) -- false
print(err) -- Gender missing or not recognised!
PrintTable(hints) -- {"Perhaps you are a carp?"}
```

For further examples, including nesting and combining of schemas, please see the `unitTests` function for now.
--]]

module("tc", package.seeall)

-- Helpers for quick access to metatables
angle                  = FindMetaTable("Angle")
convar                 = FindMetaTable("ConVar")
effectdata             = FindMetaTable("CEffectData")
entity                 = FindMetaTable("Entity")
file                   = FindMetaTable("File")
imaterial              = FindMetaTable("IMaterial")
irestore               = FindMetaTable("IRestore")
isave                  = FindMetaTable("ISave")
itexture               = FindMetaTable("ITexture")
lualocomotion          = FindMetaTable("CLuaLocomotion")
movedata               = FindMetaTable("CMoveData")
navarea                = FindMetaTable("CNavArea")
navladder              = FindMetaTable("CNavLadder")
nextbot                = FindMetaTable("NextBot")
npc                    = FindMetaTable("NPC")
pathfollower           = FindMetaTable("PathFollower")
physobj                = FindMetaTable("PhysObj")
player                 = FindMetaTable("Player")
recipientfilter        = FindMetaTable("CRecipientFilter")
soundpatch             = FindMetaTable("CSoundPatch")
takedamageinfo         = FindMetaTable("CTakeDamageInfo")
usercmd                = FindMetaTable("CUserCmd")
vector                 = FindMetaTable("Vector")
vehicle                = FindMetaTable("Vehicle")
vmatrix                = FindMetaTable("VMatrix")
weapon                 = FindMetaTable("Weapon")

-- Assert function, asserts a property and returns the error if false.
-- Allows f to override err and hints by simply returning them
addHint = function(f, err, hints) return function(...)
    local res = {f(...)}
    res[2] = err
    res[3] = hints

    return unpack(res)
end end

--[[ Validates a table against a schema
Capable of nesting
--]]
function checkTable(schema)
    return function(tbl)
        if not istable(tbl) then
            return false, "Not a table!"
        end

        for k, v in pairs(schema or {}) do
            local correct, err, hints = tbl[v] ~= nil
            if isfunction(v) then correct, err, hints, replace, replaceWith = v(tbl[k], tbl) end


            if not correct then
                err = err or string.format("Element '%s' is corrupt!", k)
                return correct, err, hints
            end

            -- Update the value
            if correct and replace == true and replaceWith then
                tbl[k] = replaceWith
            end
        end

        return true
    end
end

-- Returns whether a value is nil
isnil = fn.Curry(fn.Eq, 2)(nil)

-- Returns whether a value is a color
iscolor = IsColor

-- Returns true on the client
client = function() return CLIENT end

-- returns true on the server
server = function() return SERVER end

-- Optional value, when filled in it must meet the conditions
optional = function(...) return fn.FOr{isnil, ...} end

-- Default value, implies optional. Only works in combination with tc.checkTable
-- Note that the tc.addHint is to be the second parameter of default.
--      tc.addHint(tc.default(x)) does NOT work, default(x, tc.addHint(...)) does.
-- example: tc.checkTable{test = tc.default(3, tc.addHint(isnumber, "must be a number"))}
-- example: tc.checkTable{test = tc.default(3)}
default = function(def, f)
    return function(val, ...)
        if val == nil then
            -- second return value is the default value. Expects parent function to actually change the value
            return true, nil, nil, true, def
        end
        -- Return in if statement rather than "return f and f(val) or true" to allow multiple return values
        if f then return f(val, ...) else return true end
    end
end

-- A table of which each element must meet condition f
-- i.e. "this must be a table of xxx"
-- example: tc.tableOf(isnumber) demands that the table contains only numbers
tableOf = function(f) return function(tbl, parentTbl)
    if not istable(tbl) then return false end
    for k,v in pairs(tbl) do
        local res = {f(v, parentTbl)}
        if not res[1] then
            return unpack(res)
        end
    end

    return true
end end

-- Checks whether a value is amongst a given set of values
-- exapmle: tc.oneOf{"jobs", "entities", "shipments", "weapons", "vehicles", "ammo"}
oneOf = function(f) return fp{table.HasValue, f} end

-- A table that is non-empty, also useful for wrapping around tableOf
-- example: tc.nonEmpty(tc.tableOf(isnumber))
-- example: tc.nonEmpty() -- just checks that the table is non-empty
nonEmpty = function(f) return function(tbl, parentTbl)
    if not istable(tbl) or #tbl == 0 then return false end
    if not f then return true end
    return f(tbl, parentTbl)
end end

-- Number check: minimum
min = function(n) return fn.FAnd{isnumber, fp{fn.Lte, n}} end

-- Number check: maximum
max = function(n) return fn.FAnd{isnumber, fp{fn.Gte, n}} end

-- Number check: positive
positive = min(0)

-- Number check: negative
negative = max(0)


-- Whether the input matches regex
-- Note: uses string.match, so it doesn't support full regex.
-- May also allow numbers, since string.match also accepts numbers.
-- Note, also matches on substrings. Use ^pattern$ for a full match.
regex = function(pattern, startpos) return function(val)
    return (isstring(val) or isnumber(val)) and tobool(string.match(val, pattern, startpos))
end end

-- Requires that the value only contains alphanumeric characters
alphanum = regex("^[a-zA-Z0-9]+$")


-- Test cases. Also serve as nice examples
function unitTests()
    local id = 0

    -- unit test helper functions
    local function checkCorrect(correct, err, hints)
        id = id + 1

        if correct ~= true then
            print(id, "Incorrect value that should be correct!", correct, err, hints)
            if hints then PrintTable(hints) end
            return
        end

        print(id, "Correct")
    end

    local function checkIncorrect(correct, err, hints)
        id = id + 1

        if correct then
            print(id, "Correct value that should be incorrect!", correct, err, hints)
            if hints then PrintTable(hints) end
            return
        end

        print(id, "Correct")
    end

    --[[
    Simple value schema. Checks whether the input is a number.
    ]]
    local simpleSchema = tc.addHint(isnumber, "Must be a number!")

    -- This is how a schema is to be used. Just call it with the value you want to check.
    -- In further unit tests, the schema function is immediately called inside the checkCorrect/checIncorrect call for brevity
    local correct, err, hints = simpleSchema(3)

    checkCorrect(correct, err, hints)


    --[[
    Simple table schema
    ]]
    local simpleTableSchema = tc.checkTable{
        name        = tc.addHint(isstring, "The name must be a string!"),
        id          = tc.addHint(isnumber, "The id must be a number!"),
        gender      = tc.addHint(tc.oneOf{"male", "female", "carp"}, "Gender missing or not recognised!", {"Perhaps you are a carp?"}),
        nilthing    = tc.addHint(tc.isnil, "nilthing must be nil"),
        nonEmpty    = tc.addHint(tc.nonEmpty(tc.tableOf(isnumber)), "nonEmpty not table of numbers"),
        optnum      = tc.addHint(tc.optional(isnumber), "optnum given, but not a number"),
        strnum      = tc.addHint(fn.FOr{isstring, isnumber}, "strnum must either be a string or a number"),
        minmax      = tc.addHint(fn.FAnd{tc.min(5), tc.max(10)}),
        pos         = tc.addHint(tc.optional(tc.positive)),
        regx        = tc.addHint(tc.optional(tc.regex("[a-z]+"))),
        letters     = tc.addHint(tc.optional(tc.alphanum)),
    }

    checkCorrect(simpleTableSchema({name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 5, regx = "asdf", letters = "asdfj", pos = 3}))

    -- Counterexamples, should throw errors
    local badTables = {
        {},
        {name = 1, id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7},
        {name = "Dick", id = "3", gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7},
        {name = "Dick", id = 3, gender = "other", nonEmpty = {1,2,3}, strnum = "str", minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {}, strnum = "str", minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = {}, minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", optnum = "nope", minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 4},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 11},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str"},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7, regx = "666"},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7, regx = "asdf", letters = ">:D"},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7, regx = "asdf", letters = ">:D", pos = -1},
    }

    for _, tbl in pairs(badTables) do
        checkIncorrect(simpleTableSchema(tbl))
    end

    --[[
    Table Schema with no explicit keys
    ]]
    local nokeysSchema = tc.checkTable{
        tc.addHint(isstring, "The first value must be a string."),
        tc.addHint(isnumber, "The second value must be a number!"),
    }
    checkCorrect(nokeysSchema({"string", 3}))

    --[[
    Nested table schema
    ]]
    local nestedSchema = tc.checkTable{
        nested = tc.checkTable{
            val = tc.addHint(isnumber, "'val' must be a number!")
        }
    }

    checkCorrect(nestedSchema({nested = {val = 3}}))
    checkIncorrect(nestedSchema({}))

    --[[
    Combining schemas using the fn library
    ]]
    local andSchema = fn.FAnd{
        tc.checkTable{
            num = tc.addHint(isnumber, "num is not a number")
        },
        tc.checkTable{
            str = tc.addHint(isstring, "str is not a string")
        }
    }

    checkCorrect(andSchema({num = 1, str = "string!"}))
    checkIncorrect(andSchema({num = 1}))
    checkIncorrect(andSchema({str = "string!"}))

    local orSchema = fn.FOr{
        tc.checkTable{
            num = tc.addHint(isnumber, "num is not a number")
        },
        tc.checkTable{
            str = tc.addHint(isstring, "str is not a string")
        }
    }
    checkCorrect(orSchema({num = 1}))
    checkCorrect(orSchema({str = "string!"}))

    --[[
    Default value with a check
    ]]
    local withDefaultSchema = tc.checkTable{
        value = tc.default(10, tc.addHint(isnumber, "must be a number!"))
    }
    checkCorrect(withDefaultSchema({value = 30}))
    checkIncorrect(withDefaultSchema({value = "string"}))

    local empty = {}
    checkCorrect(withDefaultSchema(empty))
    if empty.value ~= 10 then
        print("Default did NOT set the value to 10!")
    else
        print("Default test OK!")
    end

    --[[
    Default value with no checks
    ]]
    local withDefaultNoCheck = tc.checkTable{
        value = tc.default(10)
    }
    checkCorrect(withDefaultNoCheck({}))
    checkCorrect(withDefaultNoCheck({value = "string"}))

    --[[
    Creating your own checker function that returns an error message
    When both the function and the tc.addHint define error messages, there's a conflict
    ]]
    local function customCheck(val)
        return false, "function error message", {"function hint"}
    end

    local customCheckSchema = tc.checkTable{
        value = tc.addHint(customCheck, "added error message", {"added hint"})
    }
    checkIncorrect(customCheckSchema{value = 1})
    checkIncorrect(customCheckSchema{})

    _, err, hints = customCheckSchema{value = 2}
    if err ~= "added error message" or hints[1] ~= "added hint" then
        print("Wrong conflict solution", err, hints[1])
    else
        print("Conflict solution OK!")
    end

    print("finished")
end

--gamemodes/darkrp/gamemode/modules/chat/sh_interface.lua:
DarkRP.declareChatCommand = DarkRP.stub{
    name = "declareChatCommand",
    description = "Declare a chat command (describe it)",
    parameters = {
        {
            name = "table",
            description = "The description of the chat command. Has to contain a string: command, string: description, number: delay, optional function: condition",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeChatCommand = DarkRP.stub{
    name = "removeChatCommand",
    description = "Remove a chat command",
    parameters = {
        {
            name = "command",
            description = "The chat command to remove",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.chatCommandAlias = DarkRP.stub{
    name = "chatCommandAlias",
    description = "Create an alias for a chat command",
    parameters = {
        {
            name = "command",
            description = "An already existing chat command.",
            type = "string",
            optional = false
        },
        {
            name = "alias",
            description = "One or more aliases for the chat command.",
            type = "vararg",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getChatCommand = DarkRP.stub{
    name = "getChatCommand",
    description = "Get the information on a chat command.",
    parameters = {
        {
            name = "command",
            description = "The chat command",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "chatTable",
            description = "A table containing the information of the chat command.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getChatCommands = DarkRP.stub{
    name = "getChatCommands",
    description = "Get every chat command.",
    parameters = {

    },
    returns = {
        {
            name = "commands",
            description = "A table containing every command. Table indices are the command strings.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getSortedChatCommands = DarkRP.stub{
    name = "getSortedChatCommands",
    description = "Get every chat command, sorted by their name.",
    parameters = {

    },
    returns = {
        {
            name = "commands",
            description = "A table containing every command.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getIncompleteChatCommands = DarkRP.stub{
    name = "getIncompleteChatCommands",
    description = "chat commands that have been defined, but not declared. Information about these chat commands is missing.",
    parameters = {
    },
    returns = {
        {
            name = "commands",
            description = "A table containing the undeclared chat commands.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--gamemodes/darkrp/gamemode/libraries/disjointset.lua:
/*---------------------------------------------------------------------------
Disjoint-set forest implementation
Inspired by the book Introduction To Algorithms (third edition)

by FPtje Atheos

Running time per operation (Union/FindSet): O(a(n)) where a is the inverse of the Ackermann function.
---------------------------------------------------------------------------*/

local pairs = pairs
local setmetatable = setmetatable
local string = string
local table = table
local tostring = tostring

module("disjoint")

local metatable

-- Make a singleton set. Parent parameter is optional, must be a disjoint-set as well.
function MakeSet(x, parent)
    local set  = {}
    set.value  = x
    set.rank   = 0
    set.parent = parent or set

    setmetatable(set, metatable)

    return set
end

local function Link(x, y)
    if x == y then return x end

    -- Union by rank
    if x.rank > y.rank then
        y.parent = x
        return x
    end

    x.parent = y

    if x.rank == y.rank then
        y.rank = y.rank + 1
    end

    return y
end

-- Apply the union operation between two sets.
function Union(x, y)
    return Link(FindSet(x), FindSet(y))
end

function FindSet(x)
    local parent = x
    local listParents

    -- Go up the tree to find the parent
    while parent ~= parent.parent do
        parent = parent.parent

        listParents = listParents or {}
        table.insert(listParents, parent)
    end

    -- Path compression, update all parents to refer to the top parent
    if listParents then
        for k,v in pairs(listParents) do
            v.parent = parent
        end
    end

    return parent
end

function Disconnect(x)
    x.parent = x

    return x
end


metatable = {
    __tostring = function(self)
        return string.format("Disjoint-Set [value: %s][Rank: %s][Parent: %s]", tostring(self.value), self.rank, tostring(self.parent.value))
    end,
    __metatable = true, -- restrict access to metatable
    __add = Union
}

--gamemodes/darkrp/gamemode/modules/sandbox/sh_player_extension.lua:

local meta = FindMetaTable( "Player" )

-- Return if there's nothing to add on to
if ( !meta ) then return end

g_SBoxObjects = {}

local limits = {
	['props'] = 300,
	['ragdolls'] = 0,
	['vehicles'] = 2,
	['effects'] = 0,
	['balloons'] = 0,
	['cameras'] = 3,
	['npc'] = 0,
	['sents'] = 5,
	['dynamite'] = 0,
	['lamps'] = 0,
	['lights'] = 4,
	['wheels'] = 0,
	['thrusters'] = 0,
	['hoverballs'] = 0,
	['buttons'] = 4,
	['emitters'] = 0,
	['textscreens'] = 6,
	['hoverboards'] = 1,
	['skateboards'] = 1,
	['pattern_keypads'] = 10,
}

function meta:CheckLimit( str )

	local c = limits[str] or 0
	local count = self:GetCount( str )

	local ret = hook.Run( "PlayerCheckLimit", self, str, count, c )
	if ( ret != nil ) then
		if ( !ret && SERVER ) then self:LimitHit( str ) end
		return ret
	end

	if ( c < 0 ) then return true end

	if ( count > c - 1 ) then
		if ( SERVER ) then self:LimitHit( str ) end
		return false
	end

	return true

end

function meta:GetCount( str, minus )

	if ( CLIENT ) then
		return self:GetNWInt( "Count." .. str, 0 )
	end

	minus = minus or 0

	if ( !self:IsValid() ) then return end

	local key = self:UniqueID()
	local tab = g_SBoxObjects[ key ]

	if ( !tab || !tab[ str ] ) then

		self:SetNWInt( "Count." .. str, 0 )
		return 0

	end

	local c = 0

	for k, v in pairs( tab[ str ] ) do

		if ( IsValid( v ) && !v:IsMarkedForDeletion() ) then
			c = c + 1
		else
			tab[ str ][ k ] = nil
		end

	end

	self:SetNWInt( "Count." .. str, math.max( c - minus, 0 ) )

	return c

end

function meta:AddCount( str, ent )

	if ( SERVER ) then

		local key = self:UniqueID()
		g_SBoxObjects[ key ] = g_SBoxObjects[ key ] or {}
		g_SBoxObjects[ key ][ str ] = g_SBoxObjects[ key ][ str ] or {}

		local tab = g_SBoxObjects[ key ][ str ]

		table.insert( tab, ent )

		-- Update count (for client)
		self:GetCount( str )

		ent:CallOnRemove( "GetCountUpdate", function( ent, ply, str ) ply:GetCount( str ) end, self, str )

	end

end

function meta:LimitHit( str )
	if CLIENT then return end

	DarkRP.notify(self, 1, 3, 'Достигнут лимит '..str)
end

function meta:AddCleanup( type, ent )

	cleanup.Add( self, type, ent )

end

function meta:GetTool( mode )

	local wep = self:GetWeapon( "gmod_tool" )
	if ( !IsValid( wep ) || !wep.GetToolObject ) then return nil end

	local tool = wep:GetToolObject( mode )
	if ( !tool ) then return nil end

	return tool

end
--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contentsidebartoolbox.lua:

include( "contentheader.lua" )

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "Tree" )
PANEL.m_bBackground = true -- Hack for above

function PANEL:Init()

	self:SetOpenSize( 200 )
	self:DockPadding( 5, 5, 5, 5 )

	local label = vgui.Create( "DTextEntry", self )
	label:Dock( TOP )
	label:SetZPos( 1 )
	label:DockMargin( 0, 0, 0, 2 )
	label:SetTooltip( "#spawnmenu.listname_tooltip" )

	local panel = vgui.Create( "DPanel", self )
	panel:Dock( TOP )
	panel:SetZPos( 2 )
	panel:SetSize( 24, 24 )
	panel:DockPadding( 2, 2, 2, 2 )

	local Button = vgui.Create( "DImageButton", panel )
	Button:SetImage( "icon16/text_heading_1.png" )
	Button:Dock( LEFT )
	Button:SetStretchToFit( false )
	Button:SetSize( 20, 20 )
	Button:SetCursor( "sizeall" )
	Button:SetTooltip( "#spawnmenu.header_tooltip" )
	Button:Droppable( "SandboxContentPanel" )

	Button.OnDrop = function( s, target )

		local label = vgui.Create( "ContentHeader", target )
		return label

	end

	local panel = vgui.Create( "Panel", self )
	panel:Dock( FILL )
	panel:SetZPos( 3 )

	local icon_filter = vgui.Create( "DTextEntry", panel )
	icon_filter:Dock( TOP )
	icon_filter:SetUpdateOnType( true )
	icon_filter:SetPlaceholderText( "#spawnmenu.quick_filter" )
	icon_filter:DockMargin( 0, 2, 0, 1 )

	local icons = vgui.Create( "DIconBrowser", panel )
	icons:Dock( FILL )

	icon_filter.OnValueChange = function( s, str )
		icons:FilterByText( str )
	end

	local overlay = vgui.Create( "DPanel", self )
	overlay:SetZPos( 9999 )
	overlay.Paint = function( s, w, h )
		surface.SetDrawColor( 0, 0, 0, 200 )
		surface.DrawRect( 0, 0, w, h )
	end
	self.Overlay = overlay

	--
	-- If we select a node from the sidebar, update the text/icon/actions in the toolbox (at the bottom)
	--
	hook.Add( "ContentSidebarSelection", "SidebarToolboxSelection", function( pnlContent, node )

		if ( !IsValid( node ) || !IsValid( label ) || !IsValid( icons ) ) then return end

		if ( node.CustomSpawnlist ) then
			label:SetText( node:GetText() )
			icons:SelectIcon( node:GetIcon() )
			icons:ScrollToSelected()
			overlay:SetVisible( false )
		else
			label:SetText( "" )
			overlay:SetVisible( true )
		end

		label.OnChange = function()
			if ( !node.CustomSpawnlist ) then return end
			node:SetText( label:GetText() )
			hook.Run( "SpawnlistContentChanged" )
		end

		icons.OnChange = function()
			if ( !node.CustomSpawnlist ) then return end
			node:SetIcon( icons:GetSelectedIcon() )
			hook.Run( "SpawnlistContentChanged" )
		end

	end )

end

function PANEL:PerformLayout()
	-- Not using docking because it will mess up other elements using docking!
	self.Overlay:SetSize( self:GetSize() )
end

vgui.Register( "ContentSidebarToolbox", PANEL, "DDrawer" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/postprocess.lua:

hook.Add( "PopulatePostProcess", "AddPostProcess", function( pnlContent, tree, node )

	-- Get a list of postproceess effects
	-- and organise them into categories
	local Categorised = {}
	local PostProcess = list.Get( "PostProcess" )

	if ( PostProcess ) then

		for k, v in pairs( PostProcess ) do

			local Category = v.category or "Other"
			if ( !isstring( Category ) ) then Category = tostring( Category ) end
			Categorised[ Category ] = Categorised[ Category ] or {}

			v.name = k
			table.insert( Categorised[ Category ], v )

		end

	end

	--
	-- Create an entry for each category
	--
	for CategoryName, v in SortedPairs( Categorised ) do

		-- Add a node to the tree
		local node = tree:AddNode( CategoryName, "icon16/picture.png" )

		-- When we click on the node - populate it using this function
		node.DoPopulate = function( self )

			-- If we've already populated it - forget it.
			if ( self.PropPanel ) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, pp in SortedPairsByMemberValue( v, "PrintName" ) do

				if ( pp.func ) then
					pp.func( self.PropPanel )
					continue
				end

				spawnmenu.CreateContentIcon( "postprocess", self.PropPanel, {
					name	= pp.name,
					icon	= pp.icon
				} )

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function( self )

			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode( 0 )
	if ( IsValid( FirstNode ) ) then
		FirstNode:InternalDoClick()
	end

end )

spawnmenu.AddCreationTab( "#spawnmenu.category.postprocess", function()

	local ctrl = vgui.Create( "SpawnmenuContentPanel" )
	ctrl:CallPopulateHook( "PopulatePostProcess" )
	return ctrl

end, "icon16/picture.png", 100 )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/vehicles.lua:

hook.Add( "PopulateVehicles", "AddEntityContent", function( pnlContent, tree, node )

	local Categorised = {}

	-- Add this list into the tormoil
	local Vehicles = list.Get( "Vehicles" )
	if ( Vehicles ) then
		for k, v in pairs( Vehicles ) do

			local Category = v.Category or "Other"
			if ( !isstring( Category ) ) then Category = tostring( Category ) end
			Categorised[ Category ] = Categorised[ Category ] or {}

			v.ClassName = k
			v.PrintName = v.Name
			v.ScriptedEntityType = "vehicle"
			table.insert( Categorised[ Category ], v )

		end
	end

	--
	-- Add a tree node for each category
	--
	for CategoryName, v in SortedPairs( Categorised ) do

		-- Add a node to the tree
		local node = tree:AddNode( CategoryName, "icon16/bricks.png" )

			-- When we click on the node - populate it using this function
		node.DoPopulate = function( self )

			-- If we've already populated it - forget it.
			if ( self.PropPanel ) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= ent.IconOverride or "entities/" .. ent.ClassName .. ".png",
					admin		= ent.AdminOnly
				} )

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function( self )

			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode( 0 )
	if ( IsValid( FirstNode ) ) then
		FirstNode:InternalDoClick()
	end

end )

spawnmenu.AddCreationTab( "#spawnmenu.category.vehicles", function()

	local ctrl = vgui.Create( "SpawnmenuContentPanel" )
	ctrl:EnableSearch( "vehicles", "PopulateVehicles" )
	ctrl:CallPopulateHook( "PopulateVehicles" )
	return ctrl

end, "icon16/car.png", 50 )

--gamemodes/darkrp/gamemode/modules/sandbox/cl_init.lua:
--DEFINE_BASECLASS( "gamemode_base" )

function GM:LimitHit( name )

	self:AddNotify( "#SBoxLimit_" .. name, NOTIFY_ERROR, 6 )

end

function GM:OnUndo(name, strCustomString)
	self:AddNotify((strCustomString and strCustomString or "#Undone_" .. name), NOTIFY_UNDO, 2)
end

function GM:OnCleanup(name)
	self:AddNotify("#Cleaned_" .. name, NOTIFY_CLEANUP, 5)
end
--gamemodes/darkrp/gamemode/modules/positions/sh_commands.lua:
local plyMeta = FindMetaTable("Player")

DarkRP.declareChatCommand{
    command = "setspawn",
    description = "Reset the spawn position for some job and place a new one at your position (use the command name of the job as argument)",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "addspawn",
    description = "Add a spawn position for some job (use the command name of the job as argument)",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "removespawn",
    description = "Remove a spawn position for some job (use the command name of the job as argument)",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "jailpos",
    description = "Reset jail positions and create a new one at your position.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.isChief, fn.Compose{fn.Curry(fn.GetValue, 2)("chiefjailpos"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}}
}

DarkRP.declareChatCommand{
    command = "setjailpos",
    description = "Reset jail positions and create a new one at your position.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.isChief, fn.Compose{fn.Curry(fn.GetValue, 2)("chiefjailpos"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}}
}

DarkRP.declareChatCommand{
    command = "addjailpos",
    description = "Add a jail position where you're standing.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.isChief, fn.Compose{fn.Curry(fn.GetValue, 2)("chiefjailpos"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}}
}

--gamemodes/darkrp/gamemode/modules/police/sh_init.lua:
local plyMeta = FindMetaTable("Player")

--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function plyMeta:isArrested()
    return self:GetNetVar("Arrested")
end

function plyMeta:isWanted()
    return self:GetNetVar("wanted")
end

function plyMeta:getWantedReason()
    return self:GetNetVar("wantedReason")
end

function plyMeta:isCP()
    if not IsValid(self) then return false end
    local Team = self:Team()
    return GAMEMODE.CivilProtection and GAMEMODE.CivilProtection[Team] or false
end

plyMeta.isMayor = fn.Compose{fn.Curry(fn.GetValue, 2)("mayor"), plyMeta.getJobTable}
plyMeta.isChief = fn.Compose{fn.Curry(fn.GetValue, 2)("chief"), plyMeta.getJobTable}


--[[---------------------------------------------------------------------------
Hooks
---------------------------------------------------------------------------]]

function DarkRP.hooks:canRequestWarrant(target, actor, reason)
    if not reason or string.len(reason) == 0 then return false, DarkRP.getPhrase("vote_specify_reason") end
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("get_a_warrant")) end
    if target.warranted then return false, DarkRP.getPhrase("already_a_warrant") end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("get_a_warrant")) end

    return true
end

function DarkRP.hooks:canRemoveWarrant(target, actor)
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("remove_a_warrant")) end
    if not target.warranted then return false, DarkRP.getPhrase("not_warranted") end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("remove_a_warrant")) end
    if actor:isArrested() then return false, DarkRP.getPhrase("unable", DarkRP.getPhrase("remove_a_warrant"), "") end

    return true
end

function DarkRP.hooks:canWanted(target, actor, reason)
    if not reason or string.len(reason) == 0 then return false, DarkRP.getPhrase("vote_specify_reason") end
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("make_someone_wanted")) end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("make_someone_wanted")) end
    if target:isWanted() then return false, DarkRP.getPhrase("already_wanted") end
    if not target:Alive() then return false, DarkRP.getPhrase("suspect_must_be_alive_to_do_x", DarkRP.getPhrase("make_someone_wanted")) end
    if target:isArrested() then return false, DarkRP.getPhrase("suspect_already_arrested") end

    return true
end

function DarkRP.hooks:canUnwant(target, actor)
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("remove_wanted_status")) end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("remove_wanted_status")) end
    if not target:isWanted() then return false, DarkRP.getPhrase("not_wanted") end
    if not target:Alive() then return false, DarkRP.getPhrase("suspect_must_be_alive_to_do_x", DarkRP.getPhrase("remove_wanted_status")) end

    return true
end

--[[---------------------------------------------------------------------------
Chat commands
---------------------------------------------------------------------------]]
for _, cmd in pairs{"cr", "911", "999", "112", "000"} do
    DarkRP.declareChatCommand{
        command = cmd,
        description = "Cry for help, the police will come (hopefully)!",
        delay = 1.5
    }
end

DarkRP.declareChatCommand{
    command = "warrant",
    description = "Get a search warrant for a certain player. With this warrant you can search their house.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}},
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "unwarrant",
    description = "Remove a search warrant for a certain player. With a warrant you can search their house.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}},
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "wanted",
    description = "Make a player wanted. This is needed to get them arrested.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}},
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "unwanted",
    description = "Remove a player's wanted status.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}}
}

DarkRP.declareChatCommand{
    command = "agenda",
    description = "Set the agenda.",
    delay = 1.5,
    condition = fn.Compose{fn.Not, fn.Curry(fn.Eq, 2)(nil), plyMeta.getAgenda}
}

DarkRP.declareChatCommand{
    command = "addagenda",
    description = "Add a line of text to the agenda.",
    delay = 1.5,
    condition = fn.Compose{fn.Not, fn.Curry(fn.Eq, 2)(nil), plyMeta.getAgenda}
}

DarkRP.declareChatCommand{
    command = "lottery",
    description = "Start a lottery.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "lockdown",
    description = "Start a lockdown. Everyone will have to stay inside.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "unlockdown",
    description = "Stop a lockdown.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "arrest",
    description = "Forcefully arrest a player.",
    delay = 0.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "unarrest",
    description = "Forcefully unarrest a player.",
    delay = 0.5,
    tableArgs = true
}
--gamemodes/darkrp/gamemode/modules/jobs/sh_commands.lua:
local plyMeta = FindMetaTable("Player")

DarkRP.declareChatCommand{
    command = "job",
    description = "Change your job name",
    delay = 1.5,
    condition = fn.Compose{fn.Not, plyMeta.isArrested}
}

-- DarkRP.declareChatCommand{
--     command = "demote",
--     description = "Demote a player from their job",
--     delay = 1.5,
--     condition = fn.Compose{fn.Curry(fn.Flip(fn.Gt), 2)(1), fn.Length, player.GetAll},
--     tableArgs = true
-- }

DarkRP.declareChatCommand{
    command = "switchjob",
    description = "Switch jobs with the player you're looking at",
    delay = 1.5,
    condition = fn.Compose{fn.Curry(fn.GetValue, 2)("allowjobswitch"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "switchjobs",
    description = "Switch jobs with the player you're looking at",
    delay = 1.5,
    condition = fn.Compose{fn.Curry(fn.GetValue, 2)("allowjobswitch"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "jobswitch",
    description = "Switch jobs with the player you're looking at",
    delay = 1.5,
    condition = fn.Compose{fn.Curry(fn.GetValue, 2)("allowjobswitch"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "teamban",
    description = "Ban someone from getting a certain job",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "teamunban",
    description = "Undo a teamban",
    delay = 1.5,
    tableArgs = true
}

--gamemodes/darkrp/gamemode/modules/fspectate/sh_init.lua:
if not CAMI then return end

CAMI.RegisterPrivilege{
    Name = "FSpectate",
    MinAccess = "admin"
}

CAMI.RegisterPrivilege{
    Name = "FSpectateTeleport",
    MinAccess = "admin"
}

--gamemodes/darkrp/gamemode/modules/fspectate/cl_init.lua:
FSpectate = {}

local stopSpectating, startFreeRoam
FSpectate.isSpectating = false
local specEnt
local thirdperson = true
local isRoaming = false
local roamPos -- the position when roaming free
local roamVelocity = Vector(0)
local thirdPersonDistance = 100

/*---------------------------------------------------------------------------
Retrieve the current spectated player
---------------------------------------------------------------------------*/
function FSpectate.getSpecEnt()
    if FSpectate.isSpectating and not isRoaming then
        return IsValid(specEnt) and specEnt or nil
    else
        return nil
    end
end

/*---------------------------------------------------------------------------
startHooks
FAdmin tab buttons
---------------------------------------------------------------------------*/
hook.Add("Initialize", "FSpectate", function()
    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Default"})

    if not FAdmin then return end
    FAdmin.StartHooks["zzSpectate"] = function()
        FAdmin.Commands.AddCommand("Spectate", nil, "<Player>")

        -- Right click option
        FAdmin.ScoreBoard.Main.AddPlayerRightClick("Следить", function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)

        local canSpectate = false
        CAMI.PlayerHasAccess(LocalPlayer(), "FSpectate", function(b, _)
            canSpectate = true
        end)

        wayscore.AddActionButton('spectate', {
            name = 'Наблюдать',
            icon = 'fadmin/icons/spectate',
            color = Color(0,200,0),
            category = 'Администрирование',
            order = 21000,
            rightClick = true,
            check = function(ply) return canSpectate and ply ~= LocalPlayer() end,
            callback = function(ply)
                RunConsoleCommand('FSpectate', ply:UserID())
            end,
        })
    end
end)

/*---------------------------------------------------------------------------
Get the thirdperson position
---------------------------------------------------------------------------*/
local function getThirdPersonPos(ent)
    local aimvector = LocalPlayer():GetAimVector()
    local startPos = ent:IsPlayer() and ent:GetShootPos() or ent:LocalToWorld(ent:OBBCenter())
    local endpos = startPos - aimvector * thirdPersonDistance

    local tracer = {
        start = startPos,
        endpos = endpos,
        filter = specEnt
    }

    local trace = util.TraceLine(tracer)

    return trace.HitPos + trace.HitNormal * 10
end

/*---------------------------------------------------------------------------
Get the CalcView table
---------------------------------------------------------------------------*/
local view = {}
local function getCalcView()
    if not isRoaming then
        if thirdperson then
            view.origin = getThirdPersonPos(specEnt)
            view.angles = LocalPlayer():EyeAngles()
        else
            view.origin = specEnt:IsPlayer() and specEnt:GetShootPos() or specEnt:LocalToWorld(specEnt:OBBCenter())
            view.angles = specEnt:IsPlayer() and specEnt:EyeAngles() or specEnt:GetAngles()
        end

        roamPos = view.origin
        view.drawviewer = false

        return view
    end

    view.origin = roamPos
    view.angles = LocalPlayer():EyeAngles()
    view.drawviewer = true

    return view
end

/*---------------------------------------------------------------------------
specCalcView
Override the view for the player to look through the spectated player's eyes
---------------------------------------------------------------------------*/
local function specCalcView(ply, origin, angles, fov)
    if not IsValid(specEnt) and not isRoaming then
        startFreeRoam()
        return
    end

    view = getCalcView()

    if IsValid(specEnt) then
        specEnt:SetNoDraw(not thirdperson)
    end

    return view
end

/*---------------------------------------------------------------------------
Find the right player to spectate
---------------------------------------------------------------------------*/
local function findNearestObject()
    local aimvec = LocalPlayer():GetAimVector()

    local fromPos = not isRoaming and IsValid(specEnt) and specEnt:EyePos() or roamPos

    local lookingAt = util.QuickTrace(fromPos, aimvec * 5000, LocalPlayer())

    if IsValid(lookingAt.Entity) then return lookingAt.Entity end

    local foundPly, foundDot = nil, 0

    for _, ply in player.Iterator() do
        if ply == LocalPlayer() then continue end

        local pos = ply:GetShootPos()
        local dot = (pos - fromPos):GetNormalized():Dot(aimvec)

        -- Discard players you're not looking at
        if dot < 0.97 then continue end
        -- not a better alternative
        if dot < foundDot then continue end

        local trace = util.QuickTrace(fromPos, pos - fromPos, ply)

        if trace.Hit then continue end

        foundPly, foundDot = ply, dot
    end

    return foundPly
end

/*---------------------------------------------------------------------------
Spectate the person you're looking at while you're roaming
---------------------------------------------------------------------------*/
local function spectateLookingAt()
    local obj = findNearestObject()

    if not IsValid(obj) then return end

    isRoaming = false
    specEnt = obj

    net.Start("FSpectateTarget")
        net.WriteEntity(obj)
    net.SendToServer()
end

/*---------------------------------------------------------------------------
specBinds
Change binds to perform spectate specific tasks
---------------------------------------------------------------------------*/
-- Manual keysDown table, so I can return true in plyBindPress and still detect key presses
local keysDown = {}
local fullbright = false
local function specBinds(ply, bind, pressed)
    local key = input.LookupBinding(bind)
    
    if bind == "+jump" then
        stopSpectating()
        return true
    elseif bind == "impulse 100" and pressed then
        if not fullbright then
            render.SetLightingMode(2)
            fullbright = true
        else
            render.SetLightingMode(0)
            fullbright = false
        end
    elseif bind == "+attack" and pressed then
        if not isRoaming then
            startFreeRoam()
        else
            spectateLookingAt()
        end
        return true
    elseif bind == "+attack2" and pressed then
        if isRoaming then
            roamPos = roamPos + LocalPlayer():GetAimVector() * 500
            return true
        end
        thirdperson = not thirdperson

        return true
    elseif isRoaming and not LocalPlayer():KeyDown(IN_USE) then
        local keybind = string.lower(string.match(bind, "+([a-z A-Z 0-9]+)") or "")
        if not keybind or keybind == "use" or keybind == "showscores" or string.find(bind, "messagemode") then return end

        keysDown[keybind:upper()] = pressed

        return true
    elseif not isRoaming and thirdperson and (key == "MWHEELDOWN" or key == "MWHEELUP") then
        thirdPersonDistance = thirdPersonDistance + 10 * (key == "MWHEELDOWN" and 1 or -1)
    end
    -- Do not return otherwise, spectating admins should be able to move to avoid getting detected
end

/*---------------------------------------------------------------------------
Scoreboardshow
Set to main view when roaming, open on a player when spectating
---------------------------------------------------------------------------*/
local function fadminmenushow()
    if isRoaming then
        FAdmin.ScoreBoard.ChangeView("Main")
    elseif IsValid(specEnt) and specEnt:IsPlayer() then
        FAdmin.ScoreBoard.ChangeView("Main")
        FAdmin.ScoreBoard.ChangeView("Player", specEnt)
    end
end

local function wayscoreshow()
    if isRoaming then
        wayscore:SelectView("main")
    elseif IsValid(specEnt) and specEnt:IsPlayer() then
        wayscore:SelectView("player", specEnt)
    end
end


/*---------------------------------------------------------------------------
RenderScreenspaceEffects
Draws the lines from players' eyes to where they are looking
---------------------------------------------------------------------------*/
local LineMat = Material("cable/new_cable_lit")
local linesToDraw = {}
local function lookingLines()
    if not linesToDraw[0] then return end

    render.SetMaterial(LineMat)

    cam.Start3D(view.origin, view.angles)
        for i = 0, #linesToDraw, 3 do
            render.DrawBeam(linesToDraw[i], linesToDraw[i + 1], 4, 0.01, 10, linesToDraw[i + 2])
        end
    cam.End3D()
end

/*---------------------------------------------------------------------------
gunpos
Gets the position of a player's gun
---------------------------------------------------------------------------*/
local function gunpos(ply)
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then return ply:EyePos() end
    local att = wep:GetAttachment(1)
    if not att then return ply:EyePos() end
    return att.Pos
end

/*---------------------------------------------------------------------------
Spectate think
Free roaming position updates
---------------------------------------------------------------------------*/
local function specThink()
    local ply = LocalPlayer()

    -- Update linesToDraw
    local pls = player.GetAll()
    local lastPly = 0
    local skip = 0
    for i = 0, #pls - 1 do
        local p = pls[i + 1]
        if not isRoaming and p == specEnt and not thirdperson then skip = skip + 3 continue end

        local tr = p:GetEyeTrace()
        local sp = gunpos(p)

        local pos = i * 3 - skip

        linesToDraw[pos] = tr.HitPos
        linesToDraw[pos + 1] = sp
        linesToDraw[pos + 2] = team.GetColor(p:Team())
        lastPly = i
    end

    -- Remove entries from linesToDraw that don't match with a player anymore
    for i = #linesToDraw, lastPly * 3 + 3, -1 do linesToDraw[i] = nil end

    if not isRoaming or keysDown["USE"] then return end

    local roamSpeed = 1000
    local aimVec = ply:GetAimVector()
    local direction
    local frametime = RealFrameTime()

    if keysDown["FORWARD"] then
        direction = aimVec
    elseif keysDown["BACK"] then
        direction = -aimVec
    end

    if keysDown["MOVELEFT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction - right):GetNormalized() or -right
    elseif keysDown["MOVERIGHT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction + right):GetNormalized() or right
    end

    if keysDown["SPEED"] then
        roamSpeed = 2500
    elseif keysDown["WALK"] or keysDown["DUCK"] then
        roamSpeed = 300
    end

    roamVelocity = (direction or Vector(0, 0, 0)) * roamSpeed

    roamPos = roamPos + roamVelocity * frametime
end

/*---------------------------------------------------------------------------
Draw help on the screen
---------------------------------------------------------------------------*/
local uiForeground, uiBackground = Color(240, 240, 255, 255), Color(20, 20, 20, 120)
local red = Color(255, 0, 0, 255)
local function drawHelp()
    local scrHalfH = math.floor(ScrH() / 2)
    draw.WordBox(2, 10, scrHalfH, "ЛКМ: Выбрать игрока для наблюдения", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 20, isRoaming and "ПКМ: Быстрое перемещение вперед" or "ПКМ: Переключить вид от третьего лица", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 40, "Прыжок: Закончить наблюдение", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 60, "Фонарик: Вкл/Выкл освещение", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 80, "Нажатие на Tab откроет меню наблюдаемого игрока", "UiBold", uiBackground, uiForeground)

    local target = findNearestObject()
    local pls = player.GetAll()
    for i = 1, #pls do
        local ply = pls[i]
        if not isRoaming and ply == specEnt then continue end

        local pos = ply:GetShootPos():ToScreen()
        if not pos.visible then continue end

        local x, y = pos.x, pos.y

        draw.RoundedBox(2, x, y - 6, 12, 12, team.GetColor(ply:Team()))
        draw.WordBox(2, x, y - 66, ply:Nick(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 46, "Health: " .. ply:Health(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 26, ply:GetUserGroup(), "UiBold", uiBackground, uiForeground)
    end

    if not isRoaming then return end

    if not IsValid(target) then return end

    local center = target:LocalToWorld(target:OBBCenter())
    local eyeAng = EyeAngles()
    local rightUp = eyeAng:Right() * 16 + eyeAng:Up() * 36
    local topRight = (center + rightUp):ToScreen()
    local bottomLeft = (center - rightUp):ToScreen()

    draw.RoundedBox(12, bottomLeft.x, bottomLeft.y, math.max(20, topRight.x - bottomLeft.x), topRight.y - bottomLeft.y, red)
    draw.WordBox(2, bottomLeft.x, bottomLeft.y + 12, "Left click to spectate!", "UiBold", uiBackground, uiForeground)
end

/*---------------------------------------------------------------------------
Start roaming free, rather than spectating a given player
---------------------------------------------------------------------------*/
startFreeRoam = function()
    if IsValid(specEnt) and specEnt:IsPlayer() then
        roamPos = thirdperson and getThirdPersonPos(specEnt) or specEnt:GetShootPos()
        specEnt:SetNoDraw(false)
    else
        roamPos = FSpectate.isSpectating and roamPos or LocalPlayer():GetShootPos()
    end

    specEnt = nil
    isRoaming = true
    keysDown = {}
end

/*---------------------------------------------------------------------------
specEnt
Spectate a player
---------------------------------------------------------------------------*/

local ENTITY = FindMetaTable('Entity')
ENTITY._GetPos = ENTITY._GetPos or ENTITY.GetPos

local function startSpectate(um)
    local lp = LocalPlayer()

    isRoaming = net.ReadBool()
    specEnt = net.ReadEntity()
    specEnt = IsValid(specEnt) and specEnt or nil

    if isRoaming then
        startFreeRoam()
    end

    FSpectate.isSpectating = true
    keysDown = {}

    function ENTITY:GetPos()
        return self == lp and FSpectate.isSpectating and roamPos or self:_GetPos()
    end

    hook.Add("CalcView", "FSpectate", specCalcView)
    hook.Add("PlayerBindPress", "FSpectate", specBinds)
    hook.Add("ShouldDrawLocalPlayer", "FSpectate", function() return isRoaming or thirdperson end)
    hook.Add("Think", "FSpectate", specThink)
    hook.Add("HUDPaint", "FSpectate", drawHelp)
    hook.Add("FAdmin_ShowFAdminMenu", "FSpectate", fadminmenushow)
    hook.Add("wayscore.Show", "FSpectate", wayscoreshow)
    hook.Add("RenderScreenspaceEffects", "FSpectate", lookingLines)

    timer.Create("FSpectatePosUpdate", 0.5, 0, function()
        if not isRoaming then return end

        RunConsoleCommand("_FSpectatePosUpdate", roamPos.x, roamPos.y, roamPos.z)
    end)
end
net.Receive("FSpectate", startSpectate)

/*---------------------------------------------------------------------------
stopSpectating
Stop spectating a player
---------------------------------------------------------------------------*/
stopSpectating = function()
    hook.Remove("CalcView", "FSpectate")
    hook.Remove("PlayerBindPress", "FSpectate")
    hook.Remove("ShouldDrawLocalPlayer", "FSpectate")
    hook.Remove("Think", "FSpectate")
    hook.Remove("HUDPaint", "FSpectate")
    hook.Remove("FAdmin_ShowFAdminMenu", "FSpectate")
    hook.Remove("wayscore.Show", "FSpectate")
    hook.Remove("RenderScreenspaceEffects", "FSpectate")

    timer.Remove("FSpectatePosUpdate")

    render.SetLightingMode(0)
    fullbright = false

    ENTITY.GetPos = ENTITY._GetPos

    if IsValid(specEnt) then
        specEnt:SetNoDraw(false)
    end

    RunConsoleCommand("FSpectate_StopSpectating")
    FSpectate.isSpectating = false
end
--gamemodes/darkrp/gamemode/modules/fpp/cl_fpp.lua:
include("pp/sh_settings.lua")
include("pp/client/menu.lua")
include("pp/client/hud.lua")
include("pp/client/buddies.lua")
include("pp/client/ownability.lua")
include("pp/sh_cppi.lua")

--gamemodes/darkrp/gamemode/modules/fpp/pp/client/menu.lua:
local AdminPanel
local EditGroupTools
local RetrieveRestrictedTool
local RetrieveBlockedModels
local BlockedLists = {}
local CatsOpened = {}
local ShowBlockedModels
FPP = FPP or {}

FPP.Groups = {}
FPP.GroupMembers = {}

net.Receive("FPP_Settings_Update", function()
    local skipK, skipS, value = net.ReadUInt(8), net.ReadUInt(8), net.ReadDouble()
    local K, S = 0, 0

    FPP.ForAllSettings(function(k, s)
        K = K + 1
        if K ~= skipK then return true end
        K, S = K - 1, S + 1
        if S ~= skipS then return end

        FPP.Settings[k][s] = value
    end)
end)

net.Receive("FPP_Settings", function()
    FPP.ForAllSettings(function(k, s, v)
        FPP.Settings[k][s] = net.ReadDouble()
    end)
end)

local canEditSettings = false
local canCleanup = false

local function updatePrivs()
    CAMI.PlayerHasAccess(LocalPlayer(), "FPP_Settings", function(b, _)
        canEditSettings = b
    end)

    CAMI.PlayerHasAccess(LocalPlayer(), "FPP_Cleanup", function(b, _)
        canCleanup = b
    end)
end
hook.Add("InitPostEntity", "FPP_Menu", updatePrivs)

function FPP.AdminMenu(Panel)
    updatePrivs()
    AdminPanel = Panel
    AdminPanel:SetSize(100, 400)
    AdminPanel:Clear(true)

    AdminPanel.contents = AdminPanel.contents or vgui.Create("DListLayout")
    AdminPanel.contents:Clear()

    if not canEditSettings then
        AdminPanel.contents:Add(Label("You are not a superadmin\nThe changes you make will not have any effect."))
        local AmAdmin = AdminPanel.contents:Add("DButton")
        AmAdmin:SetText("Unlock buttons anyway")
        AmAdmin:SetTooltip("If you're REALLY not an admin it won't work")

        function AmAdmin:DoClick()
            AmAdmin:SetText("Buttons unlocked")
            AmAdmin:SetTooltip("The changes you make now DO have effect unless you're really not an admin")
            canEditSettings = true
        end
    end

    local function MakeOption(Name)
        local cat = AdminPanel.contents:Add("DCollapsibleCategory")
        cat:SetLabel(Name)
        cat:SetExpanded(CatsOpened[Name])
        cat.oldtoggle = cat.Toggle
        function cat:Toggle()
            self:oldtoggle()
            CatsOpened[Name] = cat:GetExpanded()
            AdminPanel:Toggle()
            timer.Simple(0, function() AdminPanel:Toggle() end)
        end

        local pan = vgui.Create("DListLayout")
        cat:SetContents(pan)
        return cat, pan
    end

    local function addchk(label, command, plist)
        local box = plist:Add("DCheckBoxLabel")
        box:SetText(label)
        box:SetDark(true)
        box:SetValue(tobool(FPP.Settings[command[1]][command[2]]))
        box.Button.Toggle = function()
            if not canEditSettings then return end--Hehe now you can't click it anymore non-admin!
            if box.Button:GetChecked() == nil or not box.Button:GetChecked() then
                box.Button:SetValue( true )
            else
                box.Button:SetValue( false )
            end
            local tonum = {}
            tonum[false] = "0"
            tonum[true] = "1"
            RunConsoleCommand("FPP_Setting", command[1], command[2], tonum[box.Button:GetChecked()])
        end
    end

    local function addblock(pan, Type)
        local label = pan:Add("DLabel")
        label:SetText("\n" .. Type .. " black/whitelist entities:")
        label:SetTextColor(Color(0, 0, 0, 255))
        label:SizeToContents()

        local lview = pan:Add("DListView")
        lview:AddColumn("Entity")

        BlockedLists[string.lower(Type)] = lview
        RunConsoleCommand("FPP_sendblocked", Type)

        local RemoveSelected = pan:Add("DButton")
        RemoveSelected:SetText("Remove Selected items from the list")
        RemoveSelected:SetDisabled(not canEditSettings)
        RemoveSelected.DoClick = function()
            for k, v in pairs(lview.Lines) do
                if v:IsLineSelected() then
                    local text = v.text
                    timer.Simple(k / 10, function() RunConsoleCommand("FPP_RemoveBlocked", Type, text) end)
                    lview:RemoveLine(k)
                    lview:SetTall(17 + #lview:GetLines() * 17)
                    pan:InvalidateLayout()
                    pan:GetParent():GetParent():InvalidateLayout()
                end
            end
        end

        local AddLA = pan:Add("DButton")
        AddLA:SetText("Add the entity you're looking at")
        AddLA:SetDisabled(not canEditSettings)
        AddLA.DoClick = function()
            local ent = LocalPlayer():GetEyeTraceNoCursor().Entity
            if not IsValid(ent) then return end
            for _, v in pairs(lview.Lines) do
                if v.text == string.lower(ent:GetClass()) then return end
            end
            RunConsoleCommand("FPP_AddBlocked", Type, ent:GetClass())

            lview:AddLine(ent:GetClass()).text = ent:GetClass()
            lview:SetTall(17 + #lview:GetLines() * 17)
            pan:InvalidateLayout()
            pan:GetParent():GetParent():InvalidateLayout()
        end

        local AddManual = pan:Add("DButton")
        AddManual:SetText("Add entity manually")
        AddManual:SetDisabled(not canEditSettings)
        AddManual.DoClick = function()
            Derma_StringRequest("Enter entity manually", "Enter the classname of the entity you would like to add.", nil,
            function(a)
            RunConsoleCommand("FPP_AddBlocked", Type, a)
            end, wlib.func.blank )
        end
    end

    local function addsldr(max, command, text, plist, decimals)
        local label = plist:Add("DLabel")
        label:SetText(text)
        label:SetTextColor(Color(0, 0, 0, 255))
        label:SizeToContents()

        local sldr = plist:Add("DNumSlider")
        sldr.Label:SetVisible(false)
        sldr:SetMinMax(0, max)
        decimals = decimals or 1
        sldr:SetDecimals(decimals)
        sldr:SetDark(true)
        sldr:SetValue(FPP.Settings[command[1]][command[2]])
        function sldr.Slider:OnMouseReleased()
            self:SetDragging(false)
            self:MouseCapture(false)
            if not canEditSettings then
                sldr:SetValue(FPP.Settings[command[1]][command[2]])
                return
            end
            RunConsoleCommand("FPP_Setting", command[1], command[2], sldr:GetValue())
        end

        function sldr.TextArea:OnEnter()
            if not canEditSettings then
                sldr:SetValue(FPP.Settings[command[1]][command[2]])
                return
            end
            RunConsoleCommand("FPP_Setting", command[1], command[2], sldr:GetValue())
        end

        local KnobMouseReleased = sldr.Slider.Knob.OnMouseReleased
        function sldr.Slider.Knob:OnMouseReleased(...)
            KnobMouseReleased(self, ...)
            sldr.Slider:OnMouseReleased()
        end
    end

    local _, general = MakeOption("General options")
    addchk("Freeze disconnected players's entities", {"FPP_GLOBALSETTINGS1", "freezedisconnected"}, general)
    addchk("Cleanup disconnected players's entities", {"FPP_GLOBALSETTINGS1", "cleanupdisconnected"}, general)
    addchk("Cleanup admin's entities on disconnect", {"FPP_GLOBALSETTINGS1", "cleanupadmin"}, general)
    addsldr(600, {"FPP_GLOBALSETTINGS1", "cleanupdisconnectedtime"}, "Deletion time", general, 0)
    addchk("Anti E2 mingery (mass killing with E2)", {"FPP_GLOBALSETTINGS1", "antie2minge"}, general)

    local delnow = general:Add("DButton")
    delnow:SetText("Delete disconnected players' entities")
    delnow:SetConsoleCommand("FPP_cleanup", "disconnected")
    delnow:SetDisabled(not canCleanup)

    local other = general:Add(Label("\nDelete player's entities:"))
    other:SizeToContents()
    other:SetTextColor(Color(0, 0, 0, 255))

    local areplayers = false
    for _, v in player.Iterator() do
        if not IsValid(v) then continue end
        areplayers = true
        local rm = general:Add("DButton")
        rm:SetText(v:Nick())
        rm:SetConsoleCommand("FPP_Cleanup", v:UserID())
        rm:SetDisabled(not canCleanup)
    end
    if not areplayers then
        local nope = general:Add(Label("<No players available>"))
        nope:SizeToContents()
    end

    local _, antispam = MakeOption("Antispam options")
    addchk("Spam protection enabled on/off", {"FPP_ANTISPAM1", "toggle"}, antispam)
    addchk("Prevent spawning a prop in a prop", {"FPP_ANTISPAM1", "antispawninprop"}, antispam)
    addchk("Big prop spam protection", {"FPP_ANTISPAM1", "bigpropantispam"}, antispam)
    addsldr(10, {"FPP_ANTISPAM1", "bigpropwait"}, "Time (seconds) between spawning two big props", antispam)
    addsldr(10, {"FPP_ANTISPAM1", "smallpropdowngradecount"}, "Spawn delay (in fraction) to consider spam", antispam)
    addsldr(10, {"FPP_ANTISPAM1", "smallpropghostlimit"}, "How many props to spam before ghosting", antispam)
    addsldr(20, {"FPP_ANTISPAM1", "smallpropdenylimit"}, "How many props to spam before blocking", antispam)
    addsldr(10, {"FPP_ANTISPAM1", "duplicatorlimit"}, "How many duplications to spam before blocking", antispam)

    local _, physgun = MakeOption("Physgun options")
    addchk("Physgun protection enabled", {"FPP_PHYSGUN1", "toggle"}, physgun)
    addchk("Privileged users can physgun all entities", {"FPP_PHYSGUN1", "adminall"}, physgun)
    addchk("People can physgun world entities", {"FPP_PHYSGUN1", "worldprops"}, physgun)
    addchk("Admins can physgun world entities", {"FPP_PHYSGUN1", "adminworldprops"}, physgun)
    addchk("People can physgun blocked entities", {"FPP_PHYSGUN1", "canblocked"}, physgun)
    addchk("Admins can physgun blocked entities", {"FPP_PHYSGUN1", "admincanblocked"}, physgun)
    addchk("Physgun reload protection enabled", {"FPP_PHYSGUN1", "reloadprotection"}, physgun)
    addchk("The blocked list is a white list", {"FPP_PHYSGUN1", "iswhitelist"}, physgun)
    addblock(physgun, "Physgun1")

    local _, gravgun = MakeOption("Gravity gun options")
    addchk("Gravity gun protection enabled", {"FPP_GRAVGUN1", "toggle"}, gravgun)
    addchk("Privileged users can gravgun all entities", {"FPP_GRAVGUN1", "adminall"}, gravgun)
    addchk("People can gravgun world entities", {"FPP_GRAVGUN1", "worldprops"}, gravgun)
    addchk("Admins can gravgun world entities", {"FPP_GRAVGUN1", "adminworldprops"}, gravgun)
    addchk("People can gravgun blocked entities", {"FPP_GRAVGUN1", "canblocked"}, gravgun)
    addchk("Admins can gravgun blocked entities", {"FPP_GRAVGUN1", "admincanblocked"}, gravgun)
    addchk("People can't punt props", {"FPP_GRAVGUN1", "noshooting"}, gravgun)
    addchk("The blocked list is a white list", {"FPP_GRAVGUN1", "iswhitelist"}, gravgun)
    addblock(gravgun, "Gravgun1")

    local _, toolgun = MakeOption("Toolgun options")
    addchk("Toolgun protection enabled", {"FPP_TOOLGUN1", "toggle"}, toolgun)
    addchk("Admins can use tool all entities", {"FPP_TOOLGUN1", "adminall"}, toolgun)
    addchk("People can use tool on world entities", {"FPP_TOOLGUN1", "worldprops"}, toolgun)
    addchk("Admins can use tool on world entities", {"FPP_TOOLGUN1", "adminworldprops"}, toolgun)
    addchk("People can use tool on blocked entities", {"FPP_TOOLGUN1", "canblocked"}, toolgun)
    addchk("Admins can use tool on blocked entities", {"FPP_TOOLGUN1", "admincanblocked"}, toolgun)
    addchk("The blocked list is a white list", {"FPP_TOOLGUN1", "iswhitelist"}, toolgun)
    addblock(toolgun, "Toolgun1")

    addchk("Duplicator restriction (blocked list)", {"FPP_TOOLGUN1", "duplicatorprotect"}, toolgun)
    addchk("People can't duplicate weapons", {"FPP_TOOLGUN1", "duplicatenoweapons"}, toolgun)
    addchk("Duplicator blocked list is a white list", {"FPP_TOOLGUN1", "spawniswhitelist"}, toolgun)
    addchk("Admins can spawn blocked weapons", {"FPP_TOOLGUN1", "spawnadmincanweapon"}, toolgun)
    addchk("Admins can spawn blocked entities", {"FPP_TOOLGUN1", "spawnadmincanblocked"}, toolgun)
    addblock(toolgun, "Spawning1")

    local _, playeruse = MakeOption("Player use options")
    addchk("Use protection enabled", {"FPP_PLAYERUSE1", "toggle"}, playeruse)
    addchk("Privileged users can use all entities", {"FPP_PLAYERUSE1", "adminall"}, playeruse)
    addchk("People can use world entities", {"FPP_PLAYERUSE1", "worldprops"}, playeruse)
    addchk("Admins can use world entities", {"FPP_PLAYERUSE1", "adminworldprops"}, playeruse)
    addchk("People can use blocked entities", {"FPP_PLAYERUSE1", "canblocked"}, playeruse)
    addchk("Admins can use blocked entities", {"FPP_PLAYERUSE1", "admincanblocked"}, playeruse)
    addchk("The blocked list is a white list", {"FPP_PLAYERUSE1", "iswhitelist"}, playeruse)
    addblock(playeruse, "PlayerUse1")

    local _, damage = MakeOption("Entity damage options")
    local antiDMGLabel = Label("Prevents players from damaging other players' props")
    antiDMGLabel:SetTextColor(Color(0, 0, 0, 255))
    damage:Add(antiDMGLabel)

    addchk("Damage protection enabled", {"FPP_ENTITYDAMAGE1", "toggle"}, damage)
    addchk("Protect against damage by props", {"FPP_ENTITYDAMAGE1", "protectpropdamage"}, damage)
    addchk("Privileged users can damage all entities", {"FPP_ENTITYDAMAGE1", "adminall"}, damage)
    addchk("People can damage world entities", {"FPP_ENTITYDAMAGE1", "worldprops"}, damage)
    addchk("Admins can damage world entities", {"FPP_ENTITYDAMAGE1", "adminworldprops"}, damage)
    addchk("People can damage blocked entities", {"FPP_ENTITYDAMAGE1", "canblocked"}, damage)
    addchk("Admins can damage blocked entities", {"FPP_ENTITYDAMAGE1", "admincanblocked"}, damage)
    addchk("The blocked list is a white list", {"FPP_ENTITYDAMAGE1", "iswhitelist"}, damage)
    addblock(damage, "EntityDamage1")

    local _, blockedmodels = MakeOption("Blocked models options")
    local BlockedModelsLabel = blockedmodels:Add("DLabel")
    BlockedModelsLabel:SetText("\nTo add a model in the blocked models list:\nOpen the spawn menu, right click a prop and\nadd it to the blocked list")
    BlockedModelsLabel:SetTextColor(Color(0, 0, 0, 255))
    BlockedModelsLabel:SizeToContents()

    addchk("Blocked models enabled", {"FPP_BLOCKMODELSETTINGS1", "toggle"}, blockedmodels)
    addchk("Apply to props only", {"FPP_BLOCKMODELSETTINGS1", "propsonly"}, blockedmodels)
    addchk("The blocked models list is a white list", {"FPP_BLOCKMODELSETTINGS1", "iswhitelist"}, blockedmodels)

    local BlockedModelsAddLA = blockedmodels:Add("DButton")
    BlockedModelsAddLA:SetText("Add model of entity you're looking at")
    function BlockedModelsAddLA:DoClick()
        if not IsValid(LocalPlayer():GetEyeTraceNoCursor().Entity) then return end
        RunConsoleCommand("FPP_AddBlockedModel", LocalPlayer():GetEyeTraceNoCursor().Entity:GetModel(), LocalPlayer():GetEyeTraceNoCursor().Entity:EntIndex())
    end

    local BlockedModelsList = blockedmodels:Add("DButton")
    BlockedModelsList:SetText("Show blocked models")
    BlockedModelsList:SetTooltip("If there are no models in the list THIS BUTTON WON'T DO ANYTHING")
    function BlockedModelsList:DoClick()
        RunConsoleCommand("FPP_sendblockedmodels")

        local frame = vgui.Create("DFrame")
        frame:MakePopup()
        frame:SetVisible(true)
        frame:SetSize(math.Min(1280, ScrW() - 100), math.Min(720, ScrH() - 100))
        frame:Center()
        frame:SetTitle(((tobool(FPP.Settings.FPP_BLOCKMODELSETTINGS1.iswhitelist) and "Allowed") or "Blocked") .. " models list")
        function frame:Close()
            ShowBlockedModels = nil
            self:Remove()
        end

        local Explanation = vgui.Create("DLabel", frame)
        Explanation:SetPos(5, 25)
        Explanation:SetText([[This is the list of props that are currently in the Blocked/Allowed props list.
        If this is a whitelist (set in settings), only the entities with the models in this list can be spawned
        If it's a blacklist, people will be able to spawn any model except for the ones in this list.

        To remove a model from the list, click the model in this list and click remove.
        To add a model to this list:
                - open your spawn menu (Q by default)
                - find the model in the props list
                - right click it
                - click "Add to blocked models"]])
        Explanation:SizeToContents()

        frame.pan = vgui.Create("DPanelList", frame)
        frame.pan:SetPos(5, 160)
        frame.pan:SetSize(frame:GetWide() - 10, frame:GetTall() - 165)
        frame.pan:EnableHorizontal(true)
        frame.pan:EnableVerticalScrollbar(true)
        frame.pan:SetSpacing(0)
        frame.pan:SetPadding(4)
        frame.pan:SetAutoSize(false)
        ShowBlockedModels = frame
    end

    local _, ToolRestrict = MakeOption("Tool restriction") --spawnmenu.GetTools()

    FPP.DtreeToolRestrict = ToolRestrict:Add(IsValid(FPP.DtreeToolRestrict) and FPP.DtreeToolRestrict or "DTree")
    FPP.multirestricttoollist = ToolRestrict:Add(IsValid(FPP.multirestricttoollist) and FPP.multirestricttoollist or "DListView")
    FPP.DtreeToolRestrict:SetVisible(true)
    FPP.DtreeToolRestrict:SetSize(0, 300)

    FPP.SELECTEDRESTRICTNODE = FPP.SELECTEDRESTRICTNODE or "weld"

    if not FPP.DtreeToolRestrict.Items then
        FPP.DtreeToolRestrict.Items = true
        for a, b in pairs(spawnmenu.GetTools()) do
            for c, d in pairs(spawnmenu.GetTools()[a].Items) do
                local addnodes = {}
                for _, f in pairs(spawnmenu.GetTools()[a].Items[c]) do
                    if type(f) == "table" and string.find(f.Command, "gmod_tool") then
                        table.insert(addnodes, {f.Text, f.ItemName})
                    end
                end
                if #addnodes ~= 0 then
                    local node1 = FPP.DtreeToolRestrict:AddNode(d.ItemName)
                    for _, f in pairs(addnodes) do
                        local node2 = node1:AddNode(f[1])
                        node2.Icon:SetImage("gui/silkicons/wrench")
                        node2.Tool = f[2]
                        function node2:DoClick()
                            FPP.SELECTEDRESTRICTNODE = self.Tool

                            for k, v in pairs(weapons.Get("gmod_tool").Tool) do
                                if v.Mode and v.Mode == FPP.SELECTEDRESTRICTNODE then
                                    --Add to DListView
                                    for a,b in pairs(FPP.multirestricttoollist:GetLines()) do
                                        if b.Columns[1].Value == k then
                                            return
                                        end
                                    end
                                    FPP.multirestricttoollist:AddLine(k)
                                    return
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    local SingleEditTool = ToolRestrict:Add("DButton")
    SingleEditTool:SetText("Edit/view selected tool restrictions")
    SingleEditTool:SetTooltip("Edit or view the restrictions of the selected tool!")
    SingleEditTool.DoClick = function()
        for _, v in pairs(weapons.Get("gmod_tool").Tool) do
            if v.Mode and v.Mode == FPP.SELECTEDRESTRICTNODE then
                RunConsoleCommand("FPP_SendRestrictTool", k)
                return
            end
        end
        SingleEditTool:SetText("No tool selected!")

        timer.Simple(1, function()
            if IsValid(SingleEditTool) then
                SingleEditTool:SetText("Edit/view selected tool's restrictions")
            end
        end)
    end

    local multiToolEditLabel = Label("\nMultiple tool editor.\nAdd tools in this list by clicking on them,\nthen click \"Edit multiple tools\"\nto edit multiple tools at once!")
    multiToolEditLabel:SetTextColor(Color(0, 0, 0, 255))
    local EditToolListLabel = ToolRestrict:Add(multiToolEditLabel)
    EditToolListLabel:SizeToContents()

    if #FPP.multirestricttoollist.Columns ~= 1 then
        FPP.multirestricttoollist:AddColumn("Tool names")
    end

    FPP.multirestricttoollist:SetTall(150)
    function FPP.multirestricttoollist:OnClickLine(line)
        line:SetSelected(true)
        FPP.multirestricttoollist:RemoveLine(FPP.multirestricttoollist:GetSelectedLine())
    end

    local StartEditMultiTool = ToolRestrict:Add("DButton")
    StartEditMultiTool:SetText("Edit multiple tools")
    StartEditMultiTool:SetTooltip("Start editing the tools in above list!")
    StartEditMultiTool:SetDisabled(not canEditSettings)
    StartEditMultiTool.DoClick = function()
        local lines = FPP.multirestricttoollist:GetLines()
        local EditTable = {}
        if #lines > 0 then
            for _, v in ipairs(lines) do
                table.insert(EditTable, v.Columns[1].Value)
            end
            RetrieveRestrictedTool(EditTable)

            return
        end

        StartEditMultiTool:SetText("List is empty!")


        timer.Simple(1, function()
            if IsValid(StartEditMultiTool) then
                StartEditMultiTool:SetText("Edit multiple tools")
            end
        end)
    end

    local _, GroupRestrict = MakeOption("Group tool restriction")

    local pressLoadFirstLabel = Label("Press \"Load groups and members\" first!")
    pressLoadFirstLabel:SetTextColor(Color(0, 0, 0, 255))
    local PressLoadFirst = GroupRestrict:Add(pressLoadFirstLabel)
    local  membersLabel = Label("Group Members: NOTE: People who have the\nusergroup that matches with this group\nare automatically in this group!")
    membersLabel:SizeToContents()
    membersLabel:SetTextColor(Color(0, 0, 0, 255))
    GroupRestrict:Add(membersLabel)

    local LoadGroups = GroupRestrict:Add("DButton")
    LoadGroups:SetText("Load groups and members")
    LoadGroups.DoClick = function()
        RunConsoleCommand("FPP_SendGroups")
        RunConsoleCommand("FPP_SendGroupMembers")
        PressLoadFirst:SetText("Groups loaded!")
    end

    local ChkAllowDefault
    local GroupList = GroupRestrict:Add("DListView")
    GroupList:AddColumn("Group names")
    GroupList:SetSize(0, 100)
    function GroupList:OnClickLine(line)
        self:ClearSelection()
        line:SetSelected(true)
        ChkAllowDefault:SetValue(FPP.Groups[GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()].allowdefault)
    end

    ChkAllowDefault = GroupRestrict:Add("DCheckBoxLabel")
    ChkAllowDefault:SetText("Allow all tools by default")
    ChkAllowDefault:SetDark(true)
    ChkAllowDefault:SetTooltip([[Ticked: All tools are allowed, EXCEPT for the tools in the tool list
    Unticked: NO tools will be allowed, EXCEPT for the tools in the tool list]])
    if GroupList:GetSelectedLine() and FPP.Groups[GroupList:GetSelectedLine().Columns[1]:GetValue()] then
        ChkAllowDefault:SetValue(FPP.Groups[GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()].allowdefault)
    end
    ChkAllowDefault.Button.Toggle = function()
        local line = GroupList:GetSelectedLine()
        if not line then return end
        local value = 0
        if not ChkAllowDefault.Button:GetChecked() then value = 1 end
        local lineObj = GroupList:GetLine(line)
        RunConsoleCommand("FPP_ChangeGroupStatus", lineObj.Columns[1]:GetValue(), value)
        ChkAllowDefault.Button:SetValue(not ChkAllowDefault.Button:GetChecked())
    end

    local AddGroupBtn = GroupRestrict:Add("DButton")
    AddGroupBtn:SetText("Add a group")
    AddGroupBtn.DoClick = function()
        Derma_StringRequest("Name of the group", "What will be the name of the group?\nNOTE: YOU WILL NOT BE ABLE TO CHANGE THIS AFTERWARDS", "", function(text)
            RunConsoleCommand("FPP_AddGroup", text)
        end)
    end

    local RemGroupBtn = GroupRestrict:Add("DButton")
    RemGroupBtn:SetText("Remove selected group")
    RemGroupBtn.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end
        RunConsoleCommand("FPP_RemoveGroup", GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
        GroupList:RemoveLine(GroupList:GetSelectedLine())
        PressLoadFirst:SetText("List might be corrupted, reload is recommended")
    end

    local EditGroupBtn = GroupRestrict:Add("DButton")
    EditGroupBtn:SetText("Edit selected group's tools")
    EditGroupBtn.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end
        EditGroupTools(GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
    end

    local groupMemLabel = Label("Group Members:")
    groupMemLabel:SetTextColor(Color(0, 0, 0, 255))
    GroupRestrict:Add(groupMemLabel)
    local GroupMembers = GroupRestrict:Add("DListView")
    GroupMembers:AddColumn("SteamID")
    GroupMembers:AddColumn("Name")
    GroupMembers:AddColumn("Member of")
    GroupMembers:SetSize(0, 150)

    local AddPerson = GroupRestrict:Add("DButton")
    AddPerson:SetText("Change group of this person to selected")
    AddPerson.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end

        for k, v in pairs(GroupMembers:GetSelected()) do
            timer.Simple(k / 10, function() RunConsoleCommand("FPP_SetPlayerGroup", v.Columns[1]:GetValue(), GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()) end)
        end
    end

    local AddPersonManual = GroupRestrict:Add("DButton")
    AddPersonManual:SetText("Add person/SteamID to selected group")
    AddPersonManual.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end

        local menu = DermaMenu()
        menu:SetPos(gui.MouseX(), gui.MouseY())

        for _, b in player.Iterator() do
            if not IsValid(b) then continue end
            menu:AddOption(b:Nick(), function()
                RunConsoleCommand("FPP_SetPlayerGroup", b:UserID(), GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
                PressLoadFirst:SetText("List might be corrupted, reload is recommended")
            end)
        end

        menu:AddOption("other...", function()
            Derma_StringRequest("Enter steam ID", "Enter the Steam ID of the person you would like to add to this group.", "", function(text)
                RunConsoleCommand("FPP_SetPlayerGroup", text, GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
            end)
        end)
        menu:Open()
    end

    local function RetrieveGroups(len)
        FPP.Groups = net.ReadTable()
        GroupList:Clear()
        for k, _ in pairs(FPP.Groups) do
            GroupList:AddLine(k)
        end
        GroupList:SelectFirstItem()
        if #FPP.Groups == 0 then return end
        ChkAllowDefault:SetValue(FPP.Groups[GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()].allowdefault)
    end
    net.Receive("FPP_Groups", RetrieveGroups)

    local function RetrieveGroupMembers(len)
        FPP.GroupMembers = net.ReadTable()
        GroupMembers:Clear()
        for _, v in pairs(FPP.GroupMembers) do
            local name = "Unknown"
            for _, ply in player.Iterator() do
                if ply:SteamID() == k then
                    name = ply:Nick()
                    break
                end
            end
            GroupMembers:AddLine(k, name, v)
        end
        GroupMembers:SelectFirstItem()
    end
    net.Receive("FPP_GroupMembers", RetrieveGroupMembers)

    local lbl = Label("\nFalco's Prop Protection\nMade by Falco A.K.A. FPtje")
    lbl:SizeToContents()
    lbl:SetTextColor(Color(0, 0, 0, 255))
    AdminPanel.contents:Add(lbl)
    AdminPanel:SetContents(AdminPanel.contents)
    AdminPanel:Dock(FILL)
end

RetrieveBlockedModels = function(len)
    if not ShowBlockedModels then return end
    local data = net.ReadData(len)

    local models = string.Explode('\0', util.Decompress(data))

    for _, model in pairs(models) do
        local Icon = vgui.Create("SpawnIcon", ShowBlockedModels.pan)
        Icon:SetModel(model, 1)
        Icon:SetSize(64, 64)
        Icon.DoClick = function()
            local menu = DermaMenu()
            menu:AddOption("Remove from FPP blocked models list", function() -- I use a DMenu so people don't accidentally click the wrong icon and go FFFUUU
                RunConsoleCommand("FPP_RemoveBlockedModel", model)
                Icon:Remove()
                ShowBlockedModels.pan:InvalidateLayout()
            end)
            menu:Open()
        end
        ShowBlockedModels.pan:AddItem(Icon)
    end
end
net.Receive("FPP_BlockedModels", RetrieveBlockedModels)

RetrieveRestrictedTool = function(um)
    local tool, admin, Teams = um, 0, {}--Settings when it's not a usermessage
    if type(um) ~= "table" then
        tool = net.ReadString()
        admin = net.ReadUInt(2)
        local teamCount = net.ReadUInt(10)

        for i = 1, teamCount do
            Teams[net.ReadUInt(10)] = true
        end
    end

    local frame = vgui.Create("DFrame")
    if type(tool) == "table" then
        frame:SetTitle("Edit multiple tools' restrictions")
    else
        frame:SetTitle("Edit/view " .. tool .. " restrictions")
    end
    frame:MakePopup()
    frame:SetVisible( true )
    frame:SetSize(250, 400)
    frame:Center()

    local pan = vgui.Create("DPanelList", frame)
    pan:SetPos(10, 30)
    pan:SetSize(230, 1)
    pan:SetSpacing(5)
    pan:EnableHorizontal(false)
    pan:EnableVerticalScrollbar(true)
    pan:SetAutoSize(true)

    local adminsCHKboxes = {}

    adminsCHKboxes[1] = vgui.Create("DCheckBoxLabel")
    adminsCHKboxes[1]:SetText("for everyone")
    adminsCHKboxes[1].GoodValue = 0
    if admin == 0 then
        adminsCHKboxes[1].Button:SetValue(1)
    end
    pan:AddItem(adminsCHKboxes[1])

    adminsCHKboxes[2] = vgui.Create("DCheckBoxLabel")
    adminsCHKboxes[2]:SetText("Admin only")
    adminsCHKboxes[2].GoodValue = 1
    if admin == 1 then
        adminsCHKboxes[2].Button:SetValue(1)
    end
    pan:AddItem(adminsCHKboxes[2])

    adminsCHKboxes[3] = vgui.Create("DCheckBoxLabel")
    adminsCHKboxes[3]:SetText("Superadmin only")
    adminsCHKboxes[3].GoodValue = 2
    if admin == 2 then
        adminsCHKboxes[3].Button:SetValue(1)
    end
    pan:AddItem(adminsCHKboxes[3])

    for k in pairs(adminsCHKboxes) do
        adminsCHKboxes[k].Button.Toggle = function()
            if adminsCHKboxes[k].Button:GetChecked() == nil or not adminsCHKboxes[k].Button:GetChecked() then
                for a in pairs(adminsCHKboxes) do
                    adminsCHKboxes[a].Button:SetValue(false)
                end
                adminsCHKboxes[k].Button:SetValue( true )
                if type(tool) ~= "table" then
                    RunConsoleCommand("FPP_restricttool", tool, "admin", adminsCHKboxes[k].GoodValue)
                else
                    local i = 0
                    for _, b in pairs(tool) do
                        i = i + 1
                        timer.Simple(i / 10, function() -- Timer to prevent lag of executing multiple commands at the same time.
                            RunConsoleCommand("FPP_restricttool", b, "admin", adminsCHKboxes[k].GoodValue)
                        end)
                    end
                end
            else
                return false -- You can't turn a checkbox off
            end
        end
    end

    local RestrictPlayerButton = vgui.Create("DButton", frame)
    RestrictPlayerButton:SetPos(10, #adminsCHKboxes * 20 + 35)
    RestrictPlayerButton:SetSize(230, 20)
    RestrictPlayerButton:SetText("Restrict per player")
    RestrictPlayerButton:SetTooltip[[Default: reset their privileges and let them use this/these tool(s) like anyone else
    Allow: Allow them to use this tool no matter what team/admin access the tool is restricted to
    Disallow: Disallow them to use this tool no matter what team/admin access the tool is restricted to]]

    RestrictPlayerButton.DoClick = function(self)
        local menu = DermaMenu(self)
        menu:SetPos(gui.MouseX(), gui.MouseY())

        for _, v in player.Iterator() do
            if not IsValid(v) then continue end
            local submenu = menu:AddSubMenu(v:Nick())


            submenu:AddOption( "Default", function()
                if type(tool) ~= "table" then
                    RunConsoleCommand("FPP_restricttoolplayer", tool, v:UserID(), 2)
                else
                    for a, b in pairs(tool) do
                        timer.Simple(a / 10, function()
                            RunConsoleCommand("FPP_restricttoolplayer", b, v:UserID(), 2)
                        end)
                    end
                end
            end)


            submenu:AddOption( "Allow", function()
                if type(tool) ~= "table" then
                    RunConsoleCommand("FPP_restricttoolplayer", tool, v:UserID(), 1)
                else
                    for a, b in pairs(tool) do
                        timer.Simple(a / 10, function()
                            RunConsoleCommand("FPP_restricttoolplayer", b, v:UserID(), 1)
                        end)
                    end
                end
            end)


            submenu:AddOption( "Disallow", function()
                if type(tool) ~= "table" then
                    RunConsoleCommand("FPP_restricttoolplayer", tool, v:UserID(), 0)
                else
                    for a, b in pairs(tool) do
                        timer.Simple(a / 10, function()
                            RunConsoleCommand("FPP_restricttoolplayer", b, v:UserID(), 0)
                        end)
                    end
                end
            end)
        end
        menu:Open()
    end

    local Tpan = vgui.Create("DPanelList", frame)
    local count = #adminsCHKboxes
    Tpan:SetPos(10, count * 20 + 65)
    Tpan:SetSize(230, 325 - count * 20)
    Tpan:SetSpacing(5)
    Tpan:EnableHorizontal(false)
    Tpan:EnableVerticalScrollbar(true)

    for k, v in pairs(team.GetAllTeams()) do
        local chkbx = vgui.Create("DCheckBoxLabel")
        chkbx:SetText(v.Name)
        chkbx:SetDark(true)
        chkbx.Team = k
        chkbx.Button:SetValue(Teams[k])

        chkbx.Button.Toggle = function()
            if chkbx.Button:GetChecked() == nil or not chkbx.Button:GetChecked() then
                chkbx.Button:SetValue(true)
            else
                chkbx.Button:SetValue(false)
            end

            local tonum = {}
            tonum[false] = "0"
            tonum[true] = "1"
            if type(tool) ~= "table" then
                RunConsoleCommand("FPP_restricttool", tool, "team", chkbx.Team, tonum[chkbx.Button:GetChecked()] )
            else
                for a, b in pairs(tool) do
                    timer.Simple(a / 10, function()
                        RunConsoleCommand("FPP_restricttool", b, "team", chkbx.Team, tonum[chkbx.Button:GetChecked()])
                    end)
                end
            end
        end

        Tpan:AddItem(chkbx)
    end

end
net.Receive("FPP_RestrictedToolList", RetrieveRestrictedTool)

EditGroupTools = function(groupname)
    if not FPP.Groups[groupname] then return end
    local tools = FPP.Groups[groupname].tools
    local frame = vgui.Create("DFrame")
    frame:SetTitle("Edit tools of " .. groupname)
    frame:MakePopup()
    frame:SetVisible( true )
    frame:SetSize(640, 480)
    frame:Center()

    local GroupTools = vgui.Create("DListView", frame)
    GroupTools:SetPos(340, 25)
    GroupTools:SetSize(295, 450)
    GroupTools:AddColumn("Tools currently in " .. groupname)

    for _, v in pairs(tools or {}) do
        GroupTools:AddLine(v)
    end

    local SelectTool = Label("Select a tool or a folder", frame)
    SelectTool:SetPos(5, 25)
    SelectTool:SizeToContents()

    local ToolList = vgui.Create("DTree", frame)
    ToolList:SetPos(5, 45)
    ToolList:SetSize(300, 430)

    for a in pairs(spawnmenu.GetTools()) do
        for c,d in pairs(spawnmenu.GetTools()[a].Items) do
            local addnodes = {}
            for g, h in pairs(weapons.Get("gmod_tool").Tool) do
                if h.Category and h.Category == d.ItemName then
                    table.insert(addnodes, {h.Name, g})
                end
            end

            if #addnodes ~= 0 then
                local node1 = ToolList:AddNode(d.ItemName)
                node1.Tool = d.ItemName
                for _, f in pairs(addnodes) do
                    local node2 = node1:AddNode(f[1])
                    node2.Icon:SetImage("icon16/wrench.png")
                    node2.Tool = f[2]
                end
            end
        end
    end

    local AddTool = vgui.Create("DButton", frame)
    AddTool:SetPos(310, 45)
    AddTool:SetSize(25, 25)
    AddTool:SetText(">")
    AddTool.DoClick = function()

        if not ToolList.m_pSelectedItem then return end
        local SelectedTool = string.lower(ToolList.m_pSelectedItem.Tool)

        if not ToolList.m_pSelectedItem.ChildNodes then -- if it's not a folder
            for _, v in pairs(GroupTools:GetLines()) do
                if v.Columns[1]:GetValue() == SelectedTool then
                    return
                end
            end
            RunConsoleCommand("FPP_AddGroupTool", groupname, SelectedTool)
            GroupTools:AddLine(SelectedTool)
        else--if it's a folder:
            for k, v in pairs(ToolList.m_pSelectedItem.ChildNodes:GetChildren()) do
                local found = false
                for _, b in pairs(GroupTools:GetLines()) do
                    if b.Columns[1]:GetValue() == string.lower(v.Tool) then
                        found = true
                        break
                    end
                end
                if not found then
                    GroupTools:AddLine(string.lower(v.Tool))
                    timer.Simple(k / 10, function()
                        RunConsoleCommand("FPP_AddGroupTool", groupname, v.Tool)
                    end)
                end
            end
        end
    end

    local RemTool = vgui.Create("DButton", frame)
    RemTool:SetPos(310, 75)
    RemTool:SetSize(25, 25)
    RemTool:SetText("<")
    RemTool.DoClick = function()
        for k, v in pairs(GroupTools:GetSelected()) do
            local toolname = v.Columns[1]:GetValue()
            timer.Simple(k / 10, function()
                RunConsoleCommand("FPP_RemoveGroupTool", groupname, toolname)
            end)
            GroupTools:RemoveLine(v.m_iID)
        end
    end
end

local function retrieveblocked(um)
    local Type = string.lower(um:ReadString())
    if not BlockedLists[Type] then return end
    local text = um:ReadString()
    local line = BlockedLists[Type]:AddLine(text)
    line.text = text
    BlockedLists[Type]:SetTall(18 + #BlockedLists[Type]:GetLines() * 17)
end
usermessage.Hook("FPP_blockedlist", retrieveblocked)

local BuddiesPanel
function FPP.BuddiesMenu(Panel)
    BuddiesPanel = BuddiesPanel or Panel
    if not IsValid(BuddiesPanel) then return end

    Panel:ClearControls()
    BuddiesPanel:Clear()

    Panel:AddControl("Label", {Text = "\nBuddies menu\nNote: Your buddies are saved and will work in all servers with FPP\nThe buddies list includes players that aren't here\n\nYour buddies:"})
    local BuddiesList = vgui.Create("DListView")
    BuddiesList:AddColumn("Steam ID")
    BuddiesList:AddColumn("Name")
    BuddiesList:SetTall(150)
    BuddiesList:SetMultiSelect(false)
    BuddiesPanel:AddPanel(BuddiesList)
    for k, v in pairs(FPP.Buddies) do
        BuddiesList:AddLine(k, v.name)
    end
    BuddiesList:SelectFirstItem()

    local remove = vgui.Create("DButton")
    remove:SetText("Remove selected buddy")
    remove.DoClick = function()
        local line = BuddiesList:GetLine(BuddiesList:GetSelectedLine())--Select the only selected line
        if not line then return end
        FPP.SaveBuddy(line.Columns[1]:GetValue(), line.Columns[2]:GetValue(), "remove")
        FPP.BuddiesMenu(BuddiesPanel) -- Restart the entire menu
    end
    BuddiesPanel:AddPanel(remove)

    local edit = vgui.Create("DButton")
    edit:SetText("Edit selected buddy")
    edit.DoClick = function()
        local line = BuddiesList:GetLine(BuddiesList:GetSelectedLine())--Select the only selected line
        if not line then return end
        local tmp = FPP.Buddies[line.Columns[1]:GetValue()]
        if not tmp then return end
        local data = {tmp.physgun, tmp.gravgun, tmp.toolgun, tmp.playeruse, tmp.entitydamage}
        FPP.SetBuddyMenu(line.Columns[1]:GetValue(), line.Columns[2]:GetValue(), data)
    end
    BuddiesPanel:AddPanel(edit)

    local AddManual = vgui.Create("DButton")
    AddManual:SetText("Add steamID manually")
    AddManual.DoClick = function()
        Derma_StringRequest("Add buddy manually",
        "Please enter the SteamID of the player you want to add in your buddies list",
        "",
        function(ID)

            Derma_StringRequest("Name of buddy",
            "What is the name of this buddy? (You can enter any name, it will change the next time you meet in a server with FPP)",
            "",
            function(Name)
                FPP.SetBuddyMenu(ID, Name)
            end)
        end)
    end
    BuddiesPanel:AddPanel(AddManual)

    Panel:AddControl("Label", {Text = "\nAdd buddy:"})
    local AvailablePlayers = false
    for _, v in SortedPairs(player.GetAll(), function(a, b) return a:Nick() > b:Nick() end) do
        if not IsValid(v) then continue end
        local cantadd = false
        if v == LocalPlayer() then cantadd = true end
        for a in pairs(FPP.Buddies) do
            if a == v:SteamID() then
                cantadd = true
                break
            end
        end

        if not cantadd then
            local add = vgui.Create("DButton")
            add:SetText(v:Nick())
            add.DoClick = function()
                FPP.SetBuddyMenu(v:SteamID(), v:Nick())
            end
            BuddiesPanel:AddPanel(add)
            AvailablePlayers = true
        end
    end
    if not AvailablePlayers then
        Panel:AddControl("Label", {Text = "<No players available>"})
    end
end

function FPP.SetBuddyMenu(SteamID, Name, data)
    local frame = vgui.Create("DFrame")
    frame:SetTitle(Name)
    frame:MakePopup()
    frame:SetVisible( true )
    frame:SetSize(150, 130)
    frame:Center()

    local count = 1.5
    local function AddChk(name, Type, value)
        local box = vgui.Create("DCheckBoxLabel", frame)
        box:SetText(name .. " buddy")
        box:SetDark(true)

        box:SetPos(10, count * 20)
        count = count + 1
        box:SetValue(tobool(value))
        box.Button.Toggle = function()
            if box.Button:GetChecked() == nil or not box.Button:GetChecked() then
                box.Button:SetValue( true )
            else
                box.Button:SetValue( false )
            end
            local tonum = {}
            tonum[false] = 0
            tonum[true] = 1

            FPP.SaveBuddy(SteamID, Name, Type, tonum[box.Button:GetChecked()])
            FPP.BuddiesMenu(BuddiesPanel) -- Restart the entire menu
        end
        box:SizeToContents()
    end

    data = data or {0,0,0,0,0}
    AddChk("Physgun", "physgun", data[1])
    AddChk("Gravgun", "gravgun", data[2])
    AddChk("Toolgun", "toolgun", data[3])
    AddChk("Use", "playeruse", data[4])
    AddChk("Entity damage", "entitydamage", data[5])
end

local PrivateSettings = {
    ["touch my own entities"] = "OwnProps",
    ["touch world entities"] = "WorldProps",
    ["touch other people's entities"] = "OtherPlayerProps",
    ["touch blocked entities"] = "BlockedProps",
    ["see the owners of props"] = "HideOwner"
}

local privateSettingVars = {}
for _, v in pairs(PrivateSettings) do
    privateSettingVars[v] = CreateClientConVar("FPP_PrivateSettings_" .. v, 0, true, true)
end
CreateClientConVar("cl_pickupplayers", 1, true, true)

function FPP.getPrivateSetting(setting)
    return privateSettingVars[setting]:GetBool()
end

local PrivateSettingsPanel
function FPP.PrivateSettings(Panel)
    PrivateSettingsPanel = PrivateSettingsPanel or Panel

    Panel:ClearControls()
    PrivateSettingsPanel:Clear()

    Panel:AddControl("Label", {Text = "\nPrivate settings menu\nUse to set settings that override server settings\n\nThese settings can only restrict you further.\n"})
    for k, v in pairs(PrivateSettings) do
        local box = vgui.Create("DCheckBoxLabel")
        box:SetText("I don't want to " .. k)
        box:SetValue(GetConVar("FPP_PrivateSettings_" .. v):GetBool())
        box:SetDark(true)

        box.Button.Toggle = function(self)
            RunConsoleCommand("FPP_PrivateSettings_" .. v, self:GetChecked() and "0" or "1")
            self:SetValue(not self:GetChecked())
            RunConsoleCommand("_FPP_RefreshPrivatePlayerSettings")
        end

        box:SizeToContents()
        Panel:AddItem(box)
    end
    Panel:AddControl("CheckBox", {Label = "I want to pick up players", Command = "cl_pickupplayers"})

    local fallbackChoice = Panel:ComboBox("Fallback player")
    fallbackChoice:AddChoice("None", -1, true)

    for _, v in player.Iterator() do
        if v == LocalPlayer() then continue end
        fallbackChoice:AddChoice(v:Nick(), v:UserID(), PrivateSettingsPanel.FallbackSelected == v:UserID())
    end

    fallbackChoice.OnSelect = function(_, _, nick, uid)
        RunConsoleCommand("FPP_FallbackOwner", uid)
        PrivateSettingsPanel.FallbackSelected = uid
    end
end

local function makeMenus()
    spawnmenu.AddToolMenuOption( "Utilities", "Falco's prop protection", "Falco's prop protection admin settings", "Admin settings", "", "", FPP.AdminMenu)
    spawnmenu.AddToolMenuOption( "Utilities", "Falco's prop protection", "Falco's prop protection buddies", "Buddies", "", "", FPP.BuddiesMenu)
    spawnmenu.AddToolMenuOption( "Utilities", "Falco's prop protection", "Falco's prop protection Private settings", "Private Settings", "", "", FPP.PrivateSettings)
end
hook.Add("PopulateToolMenu", "FPPMenus", makeMenus)

local function UpdateMenus()
    if IsValid(AdminPanel) then
        FPP.AdminMenu(AdminPanel)
    end
    if IsValid(BuddiesPanel) then
        FPP.BuddiesMenu(BuddiesPanel)
    end
    if IsValid(PrivateSettingsPanel) then
        FPP.PrivateSettings(PrivateSettingsPanel)
    end
end
hook.Add("SpawnMenuOpen", "FPPMenus", UpdateMenus)

function FPP.SharedMenu(um)
    local ent = um:ReadEntity()
    local frame = vgui.Create("DFrame")
    if not IsValid(ent) then frame:Close() return end
    frame:SetTitle("Share " .. ent:GetClass())
    frame:MakePopup()
    frame:SetVisible( true )

    local count = 1.5
    local row = 1
    local function AddChk(name, Type, value)
        local box = vgui.Create("DCheckBoxLabel", frame)
        if type(name) == "string" then
            box:SetText(name .. " share this entity")
        elseif name:IsPlayer() and name:IsValid() then
            box:SetText(name:Nick() .. " can touch this")
        else
            return
        end

        if count * 20 - (row - 1) * ScrH() > ScrH() - 30 - (row - 1) * 50 then
            row = row + 1
        end

        box:SetPos(10 + (row - 1) * 155, count * 20 - (row - 1) * ScrH() + (row - 1) * 40)
        count = count + 1
        box:SetValue(value)
        box.Button.Toggle = function()
            if not IsValid(ent) then frame:Close() return end
            if box.Button:GetChecked() == nil or not box.Button:GetChecked() then
                box.Button:SetValue( true )
            else
                box.Button:SetValue( false )
            end
            local tonum = {}
            tonum[false] = "0"
            tonum[true] = "1"
            RunConsoleCommand("FPP_ShareProp", ent:EntIndex(), Type, tonum[box.Button:GetChecked()])
        end
        box:SizeToContents()
    end
    AddChk("Physgun", "SharePhysgun1", um:ReadBool())
    AddChk("Gravgun", "ShareGravgun1", um:ReadBool())
    AddChk("Use", "SharePlayerUse1", um:ReadBool())
    AddChk("Damage", "ShareEntityDamage1", um:ReadBool())
    AddChk("Toolgun", "ShareToolgun1", um:ReadBool())

    local long = um:ReadLong()
    local SharedWith = {}

    if long > 0 then
        for i = 1, long do
            table.insert(SharedWith, um:ReadEntity())
        end
    end

    if player.GetCount() ~= 1 then
        count = count + 1
    end
    for _, v in player.Iterator() do
        if IsValid(v) and v ~= LocalPlayer() then
            local IsShared = false
            if table.HasValue(SharedWith, v) then
                IsShared = true
            end
            AddChk(v, v:UserID(), IsShared)
        end
    end
    local height = count * 20
    if row > 1 then
        height = ScrH() - 20
    end
    frame:SetSize(math.Min(math.Max(165 + (row - 1) * 165, 165), ScrW()), height)
    frame:Center()
end
usermessage.Hook("FPP_ShareSettings", FPP.SharedMenu)

properties.Add("addFPPBlocked",
{
    MenuLabel   =   "Add to FPP blocked models",
    Order       =   2001,
    MenuIcon    =   "icon16/cross.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) or ent:IsPlayer() then return false end
                        return ply:IsSuperAdmin()
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("FPP_AddBlockedModel", ent:GetModel(), ent:EntIndex())
                    end
})

properties.Add("removeFPPBlocked",
{
    MenuLabel   =   "Remove from FPP blocked models",
    Order       =   2002,
    MenuIcon    =   "icon16/tick.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) or ent:IsPlayer() then return false end
                        return ply:IsSuperAdmin()
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("FPP_RemoveBlockedModel", ent:GetModel(), ent:EntIndex())
                    end
})

--gamemodes/darkrp/gamemode/modules/fpp/pp/client/hud.lua:
FPP = FPP or {}

hook.Add("CanTool", "FPP_CL_CanTool", function(ply, trace, tool) -- Prevent client from SEEING his toolgun shoot while it doesn't shoot serverside.
    if IsValid(trace.Entity) and not FPP.canTouchEnt(trace.Entity, "Toolgun") then
        return false
    end
end)

-- This looks weird, but whenever a client touches an ent he can't touch, without the code it'll look like he picked it up. WITH the code it really looks like he can't
-- besides, when the client CAN pick up a prop, it also looks like he can.
hook.Add("PhysgunPickup", "FPP_CL_PhysgunPickup", function(ply, ent)
    if not FPP.canTouchEnt(ent, "Physgun") then
        return false
    end
end)

-- Makes sure the client doesn't think they can punt props
hook.Add("GravGunPunt", "FPP_CL_GravGunPunt", function(ply, ent)
    if tobool(FPP.Settings.FPP_GRAVGUN1.noshooting) then return false end
    if IsValid(ent) and not FPP.canTouchEnt(ent, "Gravgun") then
        return false
    end
end)

local weaponClassTouchTypes = {
    ["weapon_physgun"] = "Physgun",
    ["weapon_physcannon"] = "Gravgun",
    ["gmod_tool"] = "Toolgun",
}

local allowclass = {
    ["weapon_physgun"] = true,
    ["weapon_physcannon"] = true,
    ["gmod_tool"] = true,
}

local green = Color(0, 255, 0, 255)
local red = Color(255, 0, 0, 255)
local scrH = ScrH()
local font = "Default"
local bgColor = Color(0, 0, 0, 110)

local function HUDPaint()
    local ply = LocalPlayer()

    local weapon = ply:GetActiveWeapon()
    if not IsValid(weapon) then return end

    local class = weapon:GetClass()
    if not allowclass[class] then return end

    local LAEnt = ply:GetEyeTraceNoCursor().Entity
    if not IsValid(LAEnt) then return end

    local touchType = weaponClassTouchTypes[class] or "EntityDamage"
    local reason = FPP.entGetTouchReason(LAEnt, touchType)
    if not reason then return end

    surface.SetFont(font)
    local w,h = surface.GetTextSize(reason)
    local col = FPP.canTouchEnt(LAEnt, touchType) and green or red

    draw.RoundedBox(4, 0, scrH / 2 - h - 2, w + 10, 20, bgColor)
    draw.DrawText(reason, font, 5, scrH / 2 - h, col, 0)
    surface.SetDrawColor(255, 255, 255, 255)
end
hook.Add("HUDPaint", "FPP_HUDPaint", HUDPaint)
--gamemodes/darkrp/gamemode/modules/fadmin/sh_fadmin_darkrp.lua:
FAdmin = FAdmin or {}

FAdmin.PlayerActions = FAdmin.PlayerActions or {}
FAdmin.StartHooks = FAdmin.StartHooks or {}

--[[

Utilities!

]]
function FAdmin.FindPlayer(info, caller)
    if info == '~' then return {caller} end

    local players = wlib.player.findAll(info)
    return players and players[1] and {players[1]} or nil
end

function FAdmin.SteamToProfile(ply) -- Thanks decodaman
    return "http://steamcommunity.com/profiles/" .. (ply:SteamID64() or "BOT")
end

--[[
    FAdmin global settings
]]
FAdmin.GlobalSetting = FAdmin.GlobalSetting or {}


--[[Dependency solver:
    Many plugins are dependant of one another.
    To prevent plugins calling functions from other plugins that haven't been opened yet
    there will be a hook that is called when all plugins are loaded.
    This way there will be no hassle with which plugin loads first, which one next etc.
]]
timer.Simple(0, function()
    for k,v in pairs(FAdmin.StartHooks) do if type(k) ~= "string" then FAdmin.StartHooks[k] = nil end end
    for k,v in SortedPairs(FAdmin.StartHooks) do
        v()
    end
end)

--gamemodes/darkrp/gamemode/modules/fadmin/cl_fadmin.lua:
local function IncludeFolder(fol)
    fol = string.lower(fol)
    local _, folders = file.Find(fol .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if folder ~= "." and folder ~= ".." then
            for _, File in SortedPairs(file.Find(fol .. folder .. "/sh_*.lua", "LUA"), true) do
                include(fol .. folder .. "/" .. File)
            end

            for _, File in SortedPairs(file.Find(fol .. folder .. "/cl_*.lua", "LUA"), true) do
                include(fol .. folder .. "/" .. File)
            end
        end
    end
end

IncludeFolder(GM.FolderName .. "/gamemode/modules/fadmin/fadmin/")
IncludeFolder(GM.FolderName .. "/gamemode/modules/fadmin/fadmin/playeractions/")

--[[---------------------------------------------------------------------------
FAdmin global settings
---------------------------------------------------------------------------]]
net.Receive("FAdmin_GlobalSetting", function(len)
    local setting, value = net.ReadString(), net.ReadType(net.ReadUInt(8))

    FAdmin.GlobalSetting = FAdmin.GlobalSetting or {}
    FAdmin.GlobalSetting[setting] = value
end)

net.Receive("FAdmin_PlayerSetting", function(len)
    local uid, setting, value = net.ReadUInt(16), net.ReadString(), net.ReadType(net.ReadUInt(8))

    FAdmin.PlayerSettings = FAdmin.PlayerSettings or {}
    FAdmin.PlayerSettings[uid] = FAdmin.PlayerSettings[uid] or {}
    FAdmin.PlayerSettings[uid][setting] = value
end)

timer.Create("FAdmin_CleanPlayerSettings", 300, 0, function()
    if not FAdmin.PlayerSettings then return end

    -- find highest userID
    local max = math.huge
    for k, v in player.Iterator() do
        if v:UserID() > max then max = v:UserID() end
    end

    -- Anything lower than the maximal UserID can be culled
    -- This prevents data from joining players from being removed
    -- New players always get a strictly higher UserID than any player before them
    for uid, settings in pairs(FAdmin.PlayerSettings) do
        if IsValid(Player(uid)) or uid > max then continue end

        FAdmin.PlayerSettings[uid] = nil
    end
end)

local plyMeta = FindMetaTable("Player")

function plyMeta:FAdmin_GetGlobal(setting)
    local uid = self:UserID()
    return FAdmin.PlayerSettings and FAdmin.PlayerSettings[uid] and FAdmin.PlayerSettings[uid][setting] or nil
end

net.Receive("FAdmin_GlobalPlayerSettings", function(len)
    local globalCount = net.ReadUInt(8)

    FAdmin.GlobalSetting = FAdmin.GlobalSetting or {}

    for i = 1, globalCount do
        FAdmin.GlobalSetting[net.ReadString()] = net.ReadType(net.ReadUInt(8))
    end

    local plyCount = net.ReadUInt(8)
    FAdmin.PlayerSettings = FAdmin.PlayerSettings or {}

    for i = 1, plyCount do
        local uid = net.ReadUInt(16)
        local count = net.ReadUInt(8)

        FAdmin.PlayerSettings[uid] = FAdmin.PlayerSettings[uid] or {}

        for j = 1, count do
            FAdmin.PlayerSettings[uid][net.ReadString()] = net.ReadType(net.ReadUInt(8))
        end
    end
end)


--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/pickupplayers/cl_init.lua:
local AdminsCanPickUpPlayers = CreateConVar("AdminsCanPickUpPlayers", 1, {FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE})
local PlayersCanPickUpPlayers = CreateConVar("PlayersCanPickUpPlayers", 0, {FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE})

FAdmin.StartHooks["PickUpPlayers"] = function()
    FAdmin.Access.AddPrivilege("PickUpPlayers", 2)
    FAdmin.ScoreBoard.Server:AddPlayerAction(function() return (AdminsCanPickUpPlayers:GetBool() and "Disable" or "Enable") .. " Admin>Player pickup" end,
    function() return "fadmin/icons/pickup", AdminsCanPickUpPlayers:GetBool() and "fadmin/icons/disable" end, Color(0, 155, 0, 255), function(ply) return ply:IsSuperAdmin() end, function(button)
        button:SetImage2((not AdminsCanPickUpPlayers:GetBool() and "fadmin/icons/disable") or "null")
        button:SetText((not AdminsCanPickUpPlayers:GetBool() and "Disable" or "Enable") .. " Admin>Player pickup")
        button:GetParent():InvalidateLayout()
        RunConsoleCommand("_FAdmin", "AdminsCanPickUpPlayers", AdminsCanPickUpPlayers:GetBool() and "0" or "1")
    end)

    FAdmin.ScoreBoard.Server:AddPlayerAction(function() return (PlayersCanPickUpPlayers:GetBool() and "Disable" or "Enable") .. " Player>Player pickup" end,
    function() return "fadmin/icons/pickup", PlayersCanPickUpPlayers:GetBool() and "fadmin/icons/disable" end, Color(0, 155, 0, 255), function(ply) return ply:IsSuperAdmin() end, function(button)
        button:SetImage2((not PlayersCanPickUpPlayers:GetBool() and "fadmin/icons/disable") or "null")
        button:SetText((not PlayersCanPickUpPlayers:GetBool() and "Disable" or "Enable") .. " Player>Player pickup")
        button:GetParent():InvalidateLayout()
        RunConsoleCommand("_FAdmin", "PlayersCanPickUpPlayers", PlayersCanPickUpPlayers:GetBool() and "0" or "1")
    end)

    FAdmin.Messages.RegisterNotification({
        name = "physgun_pickup",
        hasTarget = true,
        message = {"instigator", " схватил тебя Physics Gun'ом"},
        receivers = "targets",
        logging = false,
    })

    FAdmin.Messages.RegisterNotification({
        name = "physgun_freeze",
        hasTarget = true,
        message = {"instigator", " зафризил тебя Physics Gun'ом"},
        receivers = "targets",
        logging = false,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/cl_scoreboardplayer.lua:
FAdmin.ScoreBoard.Player.Information = {}
FAdmin.ScoreBoard.Player.ActionButtons = {}

function FAdmin.ScoreBoard.Player.Show(ply)
    ply = ply or FAdmin.ScoreBoard.Player.Player
    FAdmin.ScoreBoard.Player.Player = ply

    if not IsValid(ply) or not IsValid(FAdmin.ScoreBoard.Player.Player) then FAdmin.ScoreBoard.ChangeView("Main") return end

    local ScreenHeight = ScrH()

    FAdmin.ScoreBoard.Player.Controls.AvatarBackground = vgui.Create("AvatarImage")
    FAdmin.ScoreBoard.Player.Controls.AvatarBackground:SetPos(FAdmin.ScoreBoard.X + 20, FAdmin.ScoreBoard.Y + 100)
    FAdmin.ScoreBoard.Player.Controls.AvatarBackground:SetSize(184, 184)
    FAdmin.ScoreBoard.Player.Controls.AvatarBackground:SetSteamID(ply:SteamID64(), 184)
    FAdmin.ScoreBoard.Player.Controls.AvatarBackground:SetVisible(true)

    FAdmin.ScoreBoard.Player.InfoPanels = FAdmin.ScoreBoard.Player.InfoPanels or {}
    for k,v in pairs(FAdmin.ScoreBoard.Player.InfoPanels) do
        if IsValid(v) then
            v:Remove()
            FAdmin.ScoreBoard.Player.InfoPanels[k] = nil
        end
    end

    if IsValid(FAdmin.ScoreBoard.Player.Controls.InfoPanel1) then
        FAdmin.ScoreBoard.Player.Controls.InfoPanel1:Remove()
    end

    FAdmin.ScoreBoard.Player.Controls.InfoPanel1 = vgui.Create("DListLayout")
    FAdmin.ScoreBoard.Player.Controls.InfoPanel1:SetPos(FAdmin.ScoreBoard.X + 20, FAdmin.ScoreBoard.Y + 100 + 184 + 5 --[[ + Avatar size]])
    FAdmin.ScoreBoard.Player.Controls.InfoPanel1:SetSize(184, ScreenHeight * 0.1 + 2)
    FAdmin.ScoreBoard.Player.Controls.InfoPanel1:SetVisible(true)
    FAdmin.ScoreBoard.Player.Controls.InfoPanel1:Clear(true)

    FAdmin.ScoreBoard.Player.Controls.InfoPanel2 = FAdmin.ScoreBoard.Player.Controls.InfoPanel2 or vgui.Create("FAdminPanelList")
    FAdmin.ScoreBoard.Player.Controls.InfoPanel2:SetPos(FAdmin.ScoreBoard.X + 25 + 184 --[[+ Avatar]], FAdmin.ScoreBoard.Y + 100)
    FAdmin.ScoreBoard.Player.Controls.InfoPanel2:SetSize(FAdmin.ScoreBoard.Width - 184 - 30 - 10, 184 + 5 + ScreenHeight * 0.1 + 2)
    FAdmin.ScoreBoard.Player.Controls.InfoPanel2:SetVisible(true)
    FAdmin.ScoreBoard.Player.Controls.InfoPanel2:Clear(true)

    local function AddInfoPanel()
        local pan = FAdmin.ScoreBoard.Player.Controls.InfoPanel2:Add("DListLayout")
        pan:SetSize(1, FAdmin.ScoreBoard.Player.Controls.InfoPanel2:GetTall())

        table.insert(FAdmin.ScoreBoard.Player.InfoPanels, pan)
        return pan
    end

    local SelectedPanel = AddInfoPanel() -- Make first panel to put the first things in

    for k, v in pairs(FAdmin.ScoreBoard.Player.Information) do
        SelectedPanel:Dock(LEFT)
        local Value = v.func(FAdmin.ScoreBoard.Player.Player)
        --if not Value or Value == "" then return --[[ Value = "N/A" ]] end
        if Value and Value ~= "" then

            local Text = vgui.Create("DLabel")
            Text:Dock(LEFT)
            Text:SetFont("Default")
            Text:SetText(v.name .. ": " .. Value)
            Text:SizeToContents()
            Text:SetColor(Color(200,200,200,200))
            Text:SetTooltip("Click to copy " .. v.name .. " to clipboard")
            Text:SetMouseInputEnabled(true)

            function Text:OnMousePressed(mcode)
                self:SetTooltip(v.name .. " copied to clipboard!")
                ChangeTooltip(self)
                SetClipboardText(Value)
                self:SetTooltip("Click to copy " .. v.name .. " to clipboard")
            end

            timer.Create("FAdmin_Scoreboard_text_update_" .. v.name, 1, 0, function()
                if not IsValid(ply) or not IsValid(FAdmin.ScoreBoard.Player.Player) or not IsValid(Text) then
                    timer.Remove("FAdmin_Scoreboard_text_update_" .. v.name)
                    if FAdmin.ScoreBoard.Visible and (not IsValid(ply) or not IsValid(FAdmin.ScoreBoard.Player.Player)) then FAdmin.ScoreBoard.ChangeView("Main") end
                    return
                end
                Value = v.func(FAdmin.ScoreBoard.Player.Player)
                if not Value or Value == "" then Value = "N/A" end
                Text:SetText(v.name .. ": " .. Value)
            end)

            if (#FAdmin.ScoreBoard.Player.Controls.InfoPanel1:GetChildren() * 17 + 17) <= FAdmin.ScoreBoard.Player.Controls.InfoPanel1:GetTall() and not v.NewPanel then
                FAdmin.ScoreBoard.Player.Controls.InfoPanel1:Add(Text)
            else
                if #SelectedPanel:GetChildren() * 17 + 17 >= SelectedPanel:GetTall() or v.NewPanel then
                    SelectedPanel = AddInfoPanel() -- Add new panel if the last one is full
                end
                SelectedPanel:Add(Text)
                if Text:GetWide() > SelectedPanel:GetWide() then
                    SelectedPanel:SetWide(Text:GetWide() + 40)
                end
            end
        end
    end

    local CatColor = team.GetColor(ply:Team())
    if GAMEMODE.Name == "Sandbox" then
        CatColor = Color(100, 150, 245, 255)
        if ply:Team() == TEAM_CONNECTING then
            CatColor = Color(200, 120, 50, 255)
        elseif ply:IsAdmin() then
            CatColor = Color(30, 200, 50, 255)
        end

        if ply:GetFriendStatus() == "friend" then
            CatColor = Color(236, 181, 113, 255)
        end
    end
    CatColor = hook.Run("FAdmin_PlayerRowColour", ply, CatColor) or CatColor

    FAdmin.ScoreBoard.Player.Controls.ButtonCat = FAdmin.ScoreBoard.Player.Controls.ButtonCat or vgui.Create("FAdminPlayerCatagory")
    FAdmin.ScoreBoard.Player.Controls.ButtonCat:SetLabel("  Player options!")
    FAdmin.ScoreBoard.Player.Controls.ButtonCat.CatagoryColor = CatColor
    FAdmin.ScoreBoard.Player.Controls.ButtonCat:SetSize(FAdmin.ScoreBoard.Width - 40, 100)
    FAdmin.ScoreBoard.Player.Controls.ButtonCat:SetPos(FAdmin.ScoreBoard.X + 20, FAdmin.ScoreBoard.Y + 100 + FAdmin.ScoreBoard.Player.Controls.InfoPanel2:GetTall() + 5)
    FAdmin.ScoreBoard.Player.Controls.ButtonCat:SetVisible(true)

    function FAdmin.ScoreBoard.Player.Controls.ButtonCat:Toggle()
    end

    FAdmin.ScoreBoard.Player.Controls.ButtonPanel = FAdmin.ScoreBoard.Player.Controls.ButtonPanel or vgui.Create("FAdminPanelList", FAdmin.ScoreBoard.Player.Controls.ButtonCat)
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:SetSpacing(5)
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:EnableHorizontal(true)
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:EnableVerticalScrollbar(true)
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:SizeToContents()
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:SetVisible(true)
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:SetSize(0, (ScreenHeight - FAdmin.ScoreBoard.Y - 40) - (FAdmin.ScoreBoard.Y + 100 + FAdmin.ScoreBoard.Player.Controls.InfoPanel2:GetTall() + 5))
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:Clear()
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:DockMargin(5, 5, 5, 5)


    for k,v in ipairs(FAdmin.ScoreBoard.Player.ActionButtons) do
        if v.Visible == true or (type(v.Visible) == "function" and v.Visible(FAdmin.ScoreBoard.Player.Player) == true) then
            local ActionButton = vgui.Create("FAdminActionButton")
            if type(v.Image) == "string" then
                ActionButton:SetImage(v.Image or "icon16/exclamation")
            elseif type(v.Image) == "table" then
                ActionButton:SetImage(v.Image[1])
                if v.Image[2] then ActionButton:SetImage2(v.Image[2]) end
            elseif type(v.Image) == "function" then
                local img1, img2 = v.Image(ply)
                ActionButton:SetImage(img1)
                if img2 then ActionButton:SetImage2(img2) end
            else
                ActionButton:SetImage("icon16/exclamation")
            end
            local name = v.Name
            if type(name) == "function" then name = name(FAdmin.ScoreBoard.Player.Player) end
            ActionButton:SetText(DarkRP.deLocalise(name))
            ActionButton:SetBorderColor(v.color)

            function ActionButton:DoClick()
                if not IsValid(FAdmin.ScoreBoard.Player.Player) then return end
                return v.Action(FAdmin.ScoreBoard.Player.Player, self)
            end
            FAdmin.ScoreBoard.Player.Controls.ButtonPanel:AddItem(ActionButton)
            if v.OnButtonCreated then
                v.OnButtonCreated(FAdmin.ScoreBoard.Player.Player, ActionButton)
            end
        end
    end
    FAdmin.ScoreBoard.Player.Controls.ButtonPanel:Dock(TOP)
end
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/teleport/cl_init.lua:

FAdmin.StartHooks["zz_Teleport"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "goto",
        hasTarget = true,
        receivers = "admins",
        message = {"instigator", " телепортировался к ", "targets"},
    }

    FAdmin.Messages.RegisterNotification{
        name = "return",
        hasTarget = true,
        receivers = "involved+admins",
        message = {"instigator", " вернул ", "targets", " на место до телепортации"},
    }

    FAdmin.Messages.RegisterNotification{
        name = "bring",
        hasTarget = true,
        receivers = "involved+admins",
        message = {"instigator", " телепортировал ", "targets", " к ", "extraInfo.1"},
        writeExtraInfo = function(i) net.WriteEntity(i) end,
        readExtraInfo = function()
            local ent = net.ReadEntity()
            return {ent:IsPlayer() and ent:Name() or tostring(ent)}
        end,
        extraInfoColors = {Color(160, 171, 189)},
    }

    FAdmin.Messages.RegisterNotification{
        name = "teleport",
        hasTarget = true,
        receivers = "involved+admins",
        message = {"instigator", " телепортировал ", "targets"},
    }

    FAdmin.Messages.RegisterNotification{
        name = "sit",
        hasTarget = false,
        receivers = "admins",
        message = {"instigator", " телепортировался в админ-зону"},
    }

    FAdmin.Messages.RegisterNotification{
        name = "sit_target",
        hasTarget = true,
        receivers = "admins",
        message = {"instigator", " телепортировал себя и ", "targets", " в админ-зону"},
    }

    FAdmin.Access.AddPrivilege("Teleport", 2)

    FAdmin.Commands.AddCommand("Teleport", nil, "[Player]")
    FAdmin.Commands.AddCommand("TP", nil, "[Player]")
    FAdmin.Commands.AddCommand("Bring", nil, "<Player>", "[Player]")
    FAdmin.Commands.AddCommand("goto", nil, "<Player>")
    FAdmin.Commands.AddCommand("Return", nil, '<Player>')

    wayscore.AddActionButton('tp', {
        name = 'Телепортировать',
        icon = 'fadmin/icons/teleport',
        color = Color(0,200,0),
        category = 'Телепорт',
        order = 22000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Teleport') and ply ~= LocalPlayer() end,
        callback = function(ply)
            RunConsoleCommand('_FAdmin', 'tp', ply:UserID())
        end,
    })

    wayscore.AddActionButton('goto', {
        name = 'К нему',
        icon = 'fadmin/icons/teleport',
        color = Color(0,200,0),
        category = 'Телепорт',
        order = 23000,
        rightClick = true,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Teleport') and ply ~= LocalPlayer() end,
        callback = function(ply)
            RunConsoleCommand('_FAdmin', 'goto', ply:UserID())
        end,
    })

    wayscore.AddActionButton('bring', {
        name = 'К себе',
        icon = 'fadmin/icons/teleport',
        color = Color(0,200,0),
        category = 'Телепорт',
        order = 24000,
        rightClick = true,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Teleport') and ply ~= LocalPlayer() end,
        callback = function(ply, button)
            RunConsoleCommand('_FAdmin', 'bring', ply:UserID())
        end,
    })

    wayscore.AddActionButton('sit', {
        name = 'В АдминЗону',
        icon = 'fadmin/icons/teleport',
        color = Color(0,200,0),
        category = 'Телепорт',
        order = 25000,
        rightClick = true,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Teleport') end,
        callback = function(ply)
            RunConsoleCommand('_FAdmin', 'sit', ply:UserID())
        end,
    })

    wayscore.AddActionButton('return', {
        name = 'Вернуть',
        icon = 'fadmin/icons/teleport',
        color = Color(0,200,0),
        category = 'Телепорт',
        order = 26000,
        rightClick = true,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Teleport') end,
        callback = function(ply)
            RunConsoleCommand('_FAdmin', 'return', ply:UserID())
        end,
    })

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("К себе", function(ply)
        if not IsValid(ply) then return end
        RunConsoleCommand("_Fadmin", "bring", ply:UserID())
    end)

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("К нему", function(ply)
        if not IsValid(ply) then return end
        RunConsoleCommand("_Fadmin", "goto", ply:UserID())
    end)

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("В АдминЗону", function(ply)
        if not IsValid(ply) then return end
        RunConsoleCommand("_Fadmin", "sit", ply:UserID())
    end)

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("Вернуть", function(ply)
        if not IsValid(ply) then return end
        RunConsoleCommand("_Fadmin", "return", ply:UserID())
    end)
end
--gamemodes/darkrp/gamemode/modules/base/sh_entityvars.lua:
local pmeta = FindMetaTable("Player")
pmeta.SteamName = pmeta.SteamName or pmeta.Name
function pmeta:Name()
    return self:GetNetVar("rpname") or self:SteamName()
end
pmeta.GetName = pmeta.Name
pmeta.Nick = pmeta.Name

nw.Register('NextSpawnTime')
    :Read(net.ReadUInt, 16)
    :Write(net.WriteUInt, 16)
    :SetPlayer()
--gamemodes/darkrp/gamemode/modules/base/sh_createitems.lua:
local plyMeta = FindMetaTable("Player")

-----------------------------------------------------------
-- Job commands --
-----------------------------------------------------------
local function declareTeamCommands(CTeam)
    local k = 0
    for num,v in pairs(RPExtraTeams) do
        if v.command == CTeam.command then
            k = num
        end
    end

    local chatcommandCondition = function(ply)
        local plyTeam = ply:Team()

        if plyTeam == k then return false end
        if CTeam.admin == 1 and not ply:IsAdmin() or CTeam.admin == 2 and not ply:IsSuperAdmin() then return false end
        if isnumber(CTeam.NeedToChangeFrom) and plyTeam ~= CTeam.NeedToChangeFrom then return false end
        if istable(CTeam.NeedToChangeFrom) and not table.HasValue(CTeam.NeedToChangeFrom, plyTeam) then return false end
        if CTeam.customCheck and CTeam.customCheck(ply) == false then return false end
        if ply:isArrested() then return false end
        if CTeam.max ~= 0 and ((CTeam.max % 1 == 0 and team.NumPlayers(k) >= CTeam.max) or (CTeam.max % 1 ~= 0 and (team.NumPlayers(k) + 1) / player.GetCount() > CTeam.max)) then return false end
        if ply.LastJob and 10 - (CurTime() - ply.LastJob) >= 0 then return false end
        if ply.LastVoteCop and CurTime() - ply.LastVoteCop < 80 then return false end

        return true
    end

    if CTeam.vote or CTeam.RequiresVote then
        DarkRP.declareChatCommand{
            command = "vote" .. CTeam.command,
            description = "Vote to become " .. CTeam.name .. ".",
            delay = 1.5,
            condition =
                function(ply)
                    if CTeam.RequiresVote and not CTeam.RequiresVote(ply, k) then return false end
                    if CTeam.canStartVote and not CTeam.canStartVote(ply) then return false end

                    return chatcommandCondition(ply)
                end
        }
        --[[
        DarkRP.declareChatCommand{
            command = CTeam.command,
            description = "Become " .. CTeam.name .. " and skip the vote.",
            delay = 1.5,
            condition =
                function(ply)
                    local requiresVote = CTeam.RequiresVote and CTeam.RequiresVote(ply, k)

                    if requiresVote then return false end
                    if requiresVote ~= false and CTeam.admin == 0 and not ply:IsAdmin() or CTeam.admin == 1 and not ply:IsSuperAdmin() then return false end
                    if CTeam.canStartVote and not CTeam.canStartVote(ply) then return false end

                    return chatcommandCondition(ply)
                end
        }
        ]]
    else
        DarkRP.declareChatCommand{
            command = CTeam.command,
            description = "Become " .. CTeam.name .. ".",
            delay = 1.5,
            condition = chatcommandCondition
        }
    end
end

DarkRP.teamVotes = {}

local function addTeamCommands(CTeam, max)
    if CLIENT then return end

    if not GAMEMODE:CustomObjFitsMap(CTeam) then return end
    local k = 0
    for num,v in pairs(RPExtraTeams) do
        if v.command == CTeam.command then
            k = num
        end
    end

    if CTeam.vote or CTeam.RequiresVote then
        DarkRP.defineChatCommand("vote" .. CTeam.command, function(ply)
            if CTeam.RequiresVote and not CTeam.RequiresVote(ply, k) then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("job_doesnt_require_vote_currently"))

                return ""
            end

            if CTeam.canStartVote and not CTeam.canStartVote(ply) then
                local reason = isfunction(CTeam.canStartVoteReason) and CTeam.canStartVoteReason(ply, CTeam) or CTeam.canStartVoteReason or ""
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("unable", "/vote" .. CTeam.command, reason))

                return ""
            end

            if CTeam.admin == 1 and not ply:IsAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", "/" .. "vote" .. CTeam.command))

                return ""
            elseif CTeam.admin > 1 and not ply:IsSuperAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_sadmin", "/" .. "vote" .. CTeam.command))

                return ""
            end

            if type(CTeam.NeedToChangeFrom) == "number" and ply:Team() ~= CTeam.NeedToChangeFrom then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_be_before", team.GetName(CTeam.NeedToChangeFrom), CTeam.name))

                return ""
            elseif type(CTeam.NeedToChangeFrom) == "table" and not table.HasValue(CTeam.NeedToChangeFrom, ply:Team()) then
                local teamnames = ""

                for a, b in pairs(CTeam.NeedToChangeFrom) do
                    teamnames = teamnames .. " or " .. team.GetName(b)
                end

                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_be_before", string.sub(teamnames, 5), CTeam.name))

                return ""
            end

            if CTeam.customCheck and not CTeam.customCheck(ply) then
                local message = isfunction(CTeam.CustomCheckFailMsg) and CTeam.CustomCheckFailMsg(ply, CTeam) or CTeam.CustomCheckFailMsg or DarkRP.getPhrase("unable", team.GetName(t), "")
                DarkRP.notify(ply, 1, 4, message)

                return ""
            end

            local allowed, time = ply:changeAllowed(k)
            if not allowed then
                local notif = time and DarkRP.getPhrase("have_to_wait",  math.ceil(time), "/job, " .. DarkRP.getPhrase("banned_or_demoted")) or DarkRP.getPhrase("unable", team.GetName(k), DarkRP.getPhrase("banned_or_demoted"))
                DarkRP.notify(ply, 1, 4, notif)

                return ""
            end

            if ply:Team() == k then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("unable", CTeam.command, ""))

                return ""
            end

            if max ~= 0 and ((max % 1 == 0 and team.NumPlayers(k) >= max) or (max % 1 ~= 0 and (team.NumPlayers(k) + 1) / player.GetCount() > max)) then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("team_limit_reached", CTeam.name))

                return ""
            end

            if ply.LastJob and 10 - (CurTime() - ply.LastJob) >= 0 then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("have_to_wait", math.ceil(10 - (CurTime() - ply.LastJob)), GAMEMODE.Config.chatCommandPrefix .. CTeam.command))

                return ""
            end

            ply.LastVoteCop = ply.LastVoteCop or -80

            if CurTime() - ply.LastVoteCop < 80 then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("have_to_wait", math.ceil(80 - (CurTime() - ply:GetTable().LastVoteCop)), GAMEMODE.Config.chatCommandPrefix .. CTeam.command))

                return ""
            end

            local existVote = DarkRP.teamVotes[CTeam.command]
            if existVote then
                if existVote.started then
                    DarkRP.notify(ply, 1, 5, 'Голосование уже идет')
                elseif existVote.players[ply:SteamID()] then
                    DarkRP.notify(ply, 1, 5, 'Ты уже зарегистрирован на голосование')
                else
                    DarkRP.notify(ply, 0, 5, 'Ты успешно зарегистрирован на голосование')
                    DarkRP.teamVotes[CTeam.command].players[ply:SteamID()] = true
                end
            else
                DarkRP.teamVotes[CTeam.command] = {
                    started = false,
                    players = {
                        [ply:SteamID()] = true,
                    },
                }

                wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, 'Через 30 секунд пройдет голосование на профессию '..CTeam.name)
                wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, 'Чтобы принять в нем участие, выбери эту профессию в F4')

                timer.Create('DarkRP_teamVote_'..CTeam.command, 30, 1, function()
                    local vote = DarkRP.teamVotes[CTeam.command]
                    if not vote or vote.started then return end

                    local exclude = {}
                    local choices = {}
                    for sid, _ in pairs(vote.players) do
                        local p = player.GetBySteamID(sid)
                        if not IsValid(p) then continue end

                        exclude[p] = true

                        table.insert(choices, {
                            text = p:DisplayName(),
                            id = sid,
                        })
                    end

                    if #choices == 0 then
                        wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, 'Все участники голосования вышли с сервера')
                        DarkRP.teamVotes[CTeam.command] = nil
                    elseif #choices == 1 then
                        if IsValid(ply) then
                            wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, ply:DisplayName()..' победил в голосовании т.к. он единственный его участник')
                            ply:changeTeam(k)
                        end
                        DarkRP.teamVotes[CTeam.command] = nil
                    else
                        local first
                        for p, _ in pairs(exclude) do
                            if not IsValid(p) then continue end
                            first = p
                            break
                        end

                        vote.started = true
                        timer.Simple(20, function()
                            DarkRP.teamVotes[CTeam.command] = nil
                        end)
                        wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, 'Голосование на профессию "'..CTeam.name..'" началось')

                        DarkRP.createVote('Голосование на профессию "'..CTeam.name..'"', 'job_'..CTeam.command, first, 20, function(vote, win, choicescount)
                            DarkRP.teamVotes[CTeam.command] = nil
                            
                            local p = player.GetBySteamID(win)
                            if not IsValid(p) then
                                wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, 'Победитель голосования вышел с сервера')
                                return
                            end
            
                            p:changeTeam(k)

                            local votesCount = 0
                            for _, v in pairs(choicescount) do
                                votesCount = votesCount + v
                            end

                            local sortedKeys = table.SortByKey(choicescount)

                            wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, p:DisplayName()..' победил в голосовании на профессию "'..CTeam.name..'", получив '..choicescount[p:SteamID()]..' голосов.')
                            wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, 'Всего проголосовало '..votesCount..' человек.')
                            wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, 'Финалисты голосования:')
                            local i = 1
                            for _, sid in pairs(sortedKeys) do
                                local target = player.GetBySteamID(sid)
                                wlib.chat.talkTo(player.GetAll(), CTeam.color, '[Выборы] ', color_white, i..'. '..(target and target:DisplayName() or sid)..' - '..choicescount[sid]..' голосов')
                            
                                i = i + 1
                                if i > 3 then break end
                            end
                            
                        end, exclude, nil, {
                            targetTeam = k
                        }, choices)
                    end
                    
                end)
            end

            ply.LastVoteCop = CurTime()

            return ""
        end)

        local function onJobCommand(ply, hasPriv)
            if hasPriv then
                ply:changeTeam(k)
                return
            end

            local a = CTeam.admin
            if a > 0 and not ply:IsAdmin()
            or a > 1 and not ply:IsSuperAdmin()
            then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", CTeam.name))
                return
            end

            if not CTeam.RequiresVote and
                (a == 0 and not ply:IsAdmin()
                or a == 1 and not ply:IsSuperAdmin()
                or a == 2)
            or CTeam.RequiresVote and CTeam.RequiresVote(ply, k)
            then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_make_vote", CTeam.name))
                return
            end

            ply:changeTeam(k)
        end
        --[[
        DarkRP.defineChatCommand(CTeam.command, function(ply)
            CAMI.PlayerHasAccess(ply, "DarkRP_GetJob_" .. CTeam.command, fp{onJobCommand, ply})

            return ""
        end)
        ]]
    else
        DarkRP.defineChatCommand(CTeam.command, function(ply)
            if CTeam.admin == 1 and not ply:IsAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", "/" .. CTeam.command))

                return ""
            end

            if CTeam.admin > 1 and not ply:IsSuperAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_sadmin", "/" .. CTeam.command))

                return ""
            end

            ply:changeTeam(k)

            return ""
        end)
    end

    --[[
    concommand.Add("rp_" .. CTeam.command, function(ply, cmd, args)
        if ply:EntIndex() ~= 0 and not ply:IsAdmin() then
            ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_admin", cmd))
            return
        end

        if CTeam.admin > 1 and not ply:IsSuperAdmin() and ply:EntIndex() ~= 0 then
            ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_sadmin", cmd))
            return
        end

        if CTeam.vote then
            if CTeam.admin >= 1 and ply:EntIndex() ~= 0 and not ply:IsSuperAdmin() then
                ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_sadmin", cmd))
                return
            elseif CTeam.admin > 1 and ply:IsSuperAdmin() and ply:EntIndex() ~= 0 then
                ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_to_make_vote", CTeam.name))
                return
            end
        end

        if not args or not args[1] then
            DarkRP.printConsoleMessage(ply, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
            return
        end

        local target = DarkRP.findPlayer(args[1])

        if not target then
            DarkRP.printConsoleMessage(ply, DarkRP.getPhrase("could_not_find", tostring(args[1])))
            return
        end

        target:changeTeam(k, true)
        local nick
        if (ply:EntIndex() ~= 0) then
            nick = ply:Nick()
        else
            nick = "Console"
        end
        DarkRP.notify(target, 0, 4, DarkRP.getPhrase("x_made_you_a_y", nick, CTeam.name))
    end)
    ]]
end

hook.Add('OnPlayerChangedTeam', 'DarkRP.stopVote', function(ply, _, t)
    local job = RPExtraTeams[t]
    if DarkRP.teamVotes[job.command] then
        DarkRP.teamVotes[job.command] = nil
        timer.Remove('DarkRP_teamVote_'..job.command)
    end
end)

local function addEntityCommands(tblEnt)
    DarkRP.declareChatCommand{
        command = tblEnt.cmd,
        description = "Purchase a " .. tblEnt.name,
        delay = 0.5,
        condition =
            function(ply)
                if ply:isArrested() then return false end
                if istable(tblEnt.allowed) and not table.HasValue(tblEnt.allowed, ply:Team()) then return false end
                if not ply:canAfford(tblEnt.price) then return false end
                if tblEnt.customCheck and tblEnt.customCheck(ply) == false then return false end

                return true
            end
    }

    if CLIENT then return end

    -- Default spawning function of an entity
    -- used if tblEnt.spawn is not defined
    local function defaultSpawn(ply, tr, tblE)
        local ent = ents.Create(tblE.ent)
        if not ent:IsValid() then error("Entity '" .. tblE.ent .. "' does not exist or is not valid.") end
        ent.dt = ent.dt or {}
        ent.dt.owning_ent = ply
        if ent.Setowning_ent then ent:Setowning_ent(ply) end
        ent:SetPos(tr.HitPos)
        -- These must be set before :Spawn()
        ent.SID = ply.SID
        ent.allowed = tblE.allowed
        ent.DarkRPItem = tblE
        ent:Spawn()

        local phys = ent:GetPhysicsObject()
        if phys:IsValid() then phys:Wake() end

        return ent
    end

    local function buythis(ply, args)
        if ply:isArrested() then return "" end
        if type(tblEnt.allowed) == "table" and not table.HasValue(tblEnt.allowed, ply:Team()) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("incorrect_job", tblEnt.name))
            return ""
        end

        if tblEnt.customCheck and not tblEnt.customCheck(ply) then
            local message = isfunction(tblEnt.CustomCheckFailMsg) and tblEnt.CustomCheckFailMsg(ply, tblEnt) or
                tblEnt.CustomCheckFailMsg or
                DarkRP.getPhrase("not_allowed_to_purchase")
            DarkRP.notify(ply, 1, 4, message)
            return ""
        end

        if ply:customEntityLimitReached(tblEnt) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("limit", tblEnt.name))
            return ""
        end

        local canbuy, suppress, message, price = hook.Call("canBuyCustomEntity", nil, ply, tblEnt)

        local cost = price or tblEnt.getPrice and tblEnt.getPrice(ply, tblEnt.price) or tblEnt.price

        if not ply:canAfford(cost) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("cant_afford", tblEnt.name))
            return ""
        end

        if canbuy == false then
            if not suppress and message then DarkRP.notify(ply, 1, 4, message) end
            return ""
        end

        ply:addMoney(-cost)

        local trace = {}
        trace.start = ply:EyePos()
        trace.endpos = trace.start + ply:GetAimVector() * 85
        trace.filter = ply

        local tr = util.TraceLine(trace)

        local ent = (tblEnt.spawn or defaultSpawn)(ply, tr, tblEnt)
        ent.onlyremover = true
        -- Repeat these properties to alleviate work in tblEnt.spawn:
        ent.SID = ply.SID
        ent.allowed = tblEnt.allowed
        ent.DarkRPItem = tblEnt

        hook.Call("playerBoughtCustomEntity", nil, ply, tblEnt, ent, cost)

        DarkRP.notify(ply, 0, 4, DarkRP.getPhrase("you_bought", tblEnt.name, DarkRP.formatMoney(cost), ""))

        ply:addCustomEntity(tblEnt)
        return ""
    end
    DarkRP.defineChatCommand(tblEnt.cmd, buythis)
end

RPExtraTeams = {}
local jobByCmd = {}
DarkRP.getJobByCommand = function(cmd)
    if not jobByCmd[cmd] then return nil, nil end
    return RPExtraTeams[jobByCmd[cmd]], jobByCmd[cmd]
end
plyMeta.getJobTable = function(ply)
    local tbl = RPExtraTeams[ply:Team()]
    -- don't error when the player has not fully joined yet
    if not tbl and (ply.DarkRPInitialised or ply.DarkRPDataRetrievalFailed) then
        DarkRP.error(
            string.format("There is a player with an invalid team!\n\nThe player's name is %s, their team number is \"%s\", which has the name \"%s\"",
                ply:EntIndex() == 0 and "Console" or IsValid(ply) and ply:Nick() or "unknown",
                ply:Team(),
                team.GetName(ply:Team())),
            1,
            {
                "It is the server owner's responsibility to figure out why that player has no valid team.",
                "This error is very likely to be caused by an earlier error. If you don't see any errors in your own console, look at the server console."
            }
        )
    end
    return tbl
end
local jobCount = 0
function DarkRP.createJob(Name, colorOrTable, model, Description, Weapons, command, maximum_amount_of_this_class, Salary, admin, Vote, Haslicense, NeedToChangeFrom, CustomCheck)
    local tableSyntaxUsed = not IsColor(colorOrTable)

    local CustomTeam = tableSyntaxUsed and colorOrTable or
        {color = colorOrTable, model = model, description = Description, weapons = Weapons, command = command,
            max = maximum_amount_of_this_class, salary = Salary, admin = admin or 0, vote = tobool(Vote), hasLicense = Haslicense,
            NeedToChangeFrom = NeedToChangeFrom, customCheck = CustomCheck
        }
    CustomTeam.name = Name
    CustomTeam.default = DarkRP.DARKRP_LOADING

    -- Disabled job
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["jobs"][CustomTeam.command] then return end

    local valid, err, hints = DarkRP.validateJob(CustomTeam)
    if not valid then DarkRP.error(string.format("Corrupt team: %s!\n%s", CustomTeam.name or "", err), 2, hints) end

    jobCount = jobCount + 1
    CustomTeam.team = jobCount

    CustomTeam.salary = math.floor(CustomTeam.salary)

    CustomTeam.customCheck           = CustomTeam.customCheck           and fp{DarkRP.simplerrRun, CustomTeam.customCheck}
    CustomTeam.CustomCheckFailMsg = isfunction(CustomTeam.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, CustomTeam.CustomCheckFailMsg} or CustomTeam.CustomCheckFailMsg
    CustomTeam.CanPlayerSuicide      = CustomTeam.CanPlayerSuicide      and fp{DarkRP.simplerrRun, CustomTeam.CanPlayerSuicide}
    CustomTeam.PlayerCanPickupWeapon = CustomTeam.PlayerCanPickupWeapon and fp{DarkRP.simplerrRun, CustomTeam.PlayerCanPickupWeapon}
    CustomTeam.PlayerDeath           = CustomTeam.PlayerDeath           and fp{DarkRP.simplerrRun, CustomTeam.PlayerDeath}
    CustomTeam.PlayerLoadout         = CustomTeam.PlayerLoadout         and fp{DarkRP.simplerrRun, CustomTeam.PlayerLoadout}
    CustomTeam.PlayerSelectSpawn     = CustomTeam.PlayerSelectSpawn     and fp{DarkRP.simplerrRun, CustomTeam.PlayerSelectSpawn}
    CustomTeam.PlayerSetModel        = CustomTeam.PlayerSetModel        and fp{DarkRP.simplerrRun, CustomTeam.PlayerSetModel}
    CustomTeam.PlayerSpawn           = CustomTeam.PlayerSpawn           and fp{DarkRP.simplerrRun, CustomTeam.PlayerSpawn}
    CustomTeam.PlayerSpawnProp       = CustomTeam.PlayerSpawnProp       and fp{DarkRP.simplerrRun, CustomTeam.PlayerSpawnProp}
    CustomTeam.RequiresVote          = CustomTeam.RequiresVote          and fp{DarkRP.simplerrRun, CustomTeam.RequiresVote}
    CustomTeam.ShowSpare1            = CustomTeam.ShowSpare1            and fp{DarkRP.simplerrRun, CustomTeam.ShowSpare1}
    CustomTeam.ShowSpare2            = CustomTeam.ShowSpare2            and fp{DarkRP.simplerrRun, CustomTeam.ShowSpare2}
    CustomTeam.canStartVote          = CustomTeam.canStartVote          and fp{DarkRP.simplerrRun, CustomTeam.canStartVote}

    jobByCmd[CustomTeam.command] = table.insert(RPExtraTeams, CustomTeam)
    DarkRP.addToCategory(CustomTeam, "jobs", CustomTeam.category)
    team.SetUp(#RPExtraTeams, Name, CustomTeam.color)
    local Team = #RPExtraTeams

    timer.Simple(0, function()
        declareTeamCommands(CustomTeam)
        addTeamCommands(CustomTeam, CustomTeam.max)
    end)

    -- Precache model here. Not right before the job change is done
    if type(CustomTeam.model) == "table" then
        for k,v in pairs(CustomTeam.model) do util.PrecacheModel(v) end
    else
        util.PrecacheModel(CustomTeam.model)
    end
    return Team
end
AddExtraTeam = DarkRP.createJob

local function removeCustomItem(tbl, category, hookName, reloadF4, i)
    local item = tbl[i]
    tbl[i] = nil
    if category then DarkRP.removeFromCategory(item, category) end
    if istable(item) and (item.command or item.cmd) then DarkRP.removeChatCommand(item.command or item.cmd) end
    hook.Run(hookName, i, item)
    if CLIENT and reloadF4 and IsValid(DarkRP.getF4MenuPanel()) then DarkRP.getF4MenuPanel():Remove() end -- Rebuild entire F4 menu frame
end

function DarkRP.removeJob(i)
    local job = RPExtraTeams[i]
    jobByCmd[job.command] = nil
    jobCount = jobCount - 1

    DarkRP.removeChatCommand("vote" .. job.command)
    removeCustomItem(RPExtraTeams, "jobs", "onJobRemoved", true, i)
end

RPExtraTeamDoors = {}
RPExtraTeamDoorIDs = {}
local maxTeamDoorID = 0
function DarkRP.createEntityGroup(name, ...)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["doorgroups"][name] then return end
    RPExtraTeamDoors[name] = {...}
    RPExtraTeamDoors[name].name = name

    maxTeamDoorID = maxTeamDoorID + 1
    RPExtraTeamDoorIDs[name] = maxTeamDoorID
end
AddDoorGroup = DarkRP.createEntityGroup

DarkRP.removeEntityGroup = fp{removeCustomItem, RPExtraTeamDoors, nil, "onEntityGroupRemoved", false}

CustomVehicles = {}
CustomShipments = {}
local shipByName = {}
DarkRP.getShipmentByName = function(name)
    name = string.lower(name or "")

    if not shipByName[name] then return nil, nil end
    return CustomShipments[shipByName[name]], shipByName[name]
end

function DarkRP.createShipment(name, model, entity, price, Amount_of_guns_in_one_shipment, Sold_separately, price_separately, noshipment, classes, shipmodel, CustomCheck)
    local tableSyntaxUsed = type(model) == "table"

    price = tonumber(price)
    local shipmentmodel = shipmodel or "models/Items/item_item_crate.mdl"

    local customShipment = tableSyntaxUsed and model or
        {model = model, entity = entity, price = price, amount = Amount_of_guns_in_one_shipment,
        seperate = Sold_separately, pricesep = price_separately, noship = noshipment, allowed = classes,
        shipmodel = shipmentmodel, customCheck = CustomCheck, weight = 5}

    -- The pains of backwards compatibility when dealing with ancient spelling errors...
    if customShipment.separate ~= nil then
        customShipment.seperate = customShipment.separate
    end
    customShipment.separate = customShipment.seperate

    if customShipment.allowed == nil then
        customShipment.allowed = {}
        for k,v in pairs(team.GetAllTeams()) do
            table.insert(customShipment.allowed, k)
        end
    end

    customShipment.name = name
    customShipment.default = DarkRP.DARKRP_LOADING
    customShipment.shipmodel = customShipment.shipmodel or shipmentmodel

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["shipments"][customShipment.name] then return end

    local valid, err, hints = DarkRP.validateShipment(customShipment)
    if not valid then DarkRP.error(string.format("Corrupt shipment: %s!\n%s", name or "", err), 2, hints) end

    customShipment.spawn = customShipment.spawn and fp{DarkRP.simplerrRun, customShipment.spawn}
    customShipment.allowed = isnumber(customShipment.allowed) and {customShipment.allowed} or customShipment.allowed
    customShipment.customCheck = customShipment.customCheck   and fp{DarkRP.simplerrRun, customShipment.customCheck}
    customShipment.CustomCheckFailMsg = isfunction(customShipment.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, customShipment.CustomCheckFailMsg} or customShipment.CustomCheckFailMsg

    if not customShipment.noship then DarkRP.addToCategory(customShipment, "shipments", customShipment.category) end
    if customShipment.separate then DarkRP.addToCategory(customShipment, "weapons", customShipment.category) end

    shipByName[string.lower(name or "")] = table.insert(CustomShipments, customShipment)
    util.PrecacheModel(customShipment.model)
end
AddCustomShipment = DarkRP.createShipment

function DarkRP.removeShipment(i)
    local ship = CustomShipments[i]
    shipByName[ship.name] = nil
    removeCustomItem(CustomShipments, "shipments", "onShipmentRemoved", true, i)
end

function DarkRP.createVehicle(Name_of_vehicle, model, price, Jobs_that_can_buy_it, customcheck)
    local vehicle = istable(Name_of_vehicle) and Name_of_vehicle or
        {name = Name_of_vehicle, model = model, price = price, allowed = Jobs_that_can_buy_it, customCheck = customcheck}

    vehicle.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["vehicles"][vehicle.name] then return end

    local found = false
    for k,v in pairs(DarkRP.getAvailableVehicles()) do
        if string.lower(k) == string.lower(vehicle.name) then found = true break end
    end

    local valid, err, hints = DarkRP.validateVehicle(vehicle)
    if not valid then DarkRP.error(string.format("Corrupt vehicle: %s!\n%s", vehicle.name or "", err), 2, hints) end

    if not found then DarkRP.error("Vehicle invalid: " .. vehicle.name .. ". Unknown vehicle name.", 2) end

    vehicle.customCheck = vehicle.customCheck and fp{DarkRP.simplerrRun, vehicle.customCheck}
    vehicle.CustomCheckFailMsg = isfunction(vehicle.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, vehicle.CustomCheckFailMsg} or vehicle.CustomCheckFailMsg

    table.insert(CustomVehicles, vehicle)
    DarkRP.addToCategory(vehicle, "vehicles", vehicle.category)
end
AddCustomVehicle = DarkRP.createVehicle

DarkRP.removeVehicle = fp{removeCustomItem, CustomVehicles, "vehicles", "onVehicleRemoved", true}

--[[---------------------------------------------------------------------------
Decides whether a custom job or shipmet or whatever can be used in a certain map
---------------------------------------------------------------------------]]
function GM:CustomObjFitsMap(obj)
    if not obj or not obj.maps then return true end

    local map = string.lower(game.GetMap())
    for k,v in pairs(obj.maps) do
        if string.lower(v) == map then return true end
    end
    return false
end

DarkRPEntities = {}
function DarkRP.createEntity(name, entity, model, price, max, command, classes, CustomCheck)
    local tableSyntaxUsed = type(entity) == "table"

    local tblEnt = tableSyntaxUsed and entity or
        {ent = entity, model = model, price = price, max = max,
        cmd = command, allowed = classes, customCheck = CustomCheck}
    tblEnt.name = name
    tblEnt.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["entities"][tblEnt.name] then return end

    if type(tblEnt.allowed) == "number" then
        tblEnt.allowed = {tblEnt.allowed}
    end

    local valid, err, hints = DarkRP.validateEntity(tblEnt)
    if not valid then DarkRP.error(string.format("Corrupt entity: %s!\n%s", name or "", err), 2, hints) end

    tblEnt.customCheck = tblEnt.customCheck and fp{DarkRP.simplerrRun, tblEnt.customCheck}
    tblEnt.CustomCheckFailMsg = isfunction(tblEnt.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, tblEnt.CustomCheckFailMsg} or tblEnt.CustomCheckFailMsg
    tblEnt.getPrice    = tblEnt.getPrice    and fp{DarkRP.simplerrRun, tblEnt.getPrice}
    tblEnt.getMax      = tblEnt.getMax      and fp{DarkRP.simplerrRun, tblEnt.getMax}
    tblEnt.spawn       = tblEnt.spawn       and fp{DarkRP.simplerrRun, tblEnt.spawn}

    -- if SERVER and FPP then
    --  FPP.AddDefaultBlocked(blockTypes, tblEnt.ent)
    -- end

    table.insert(DarkRPEntities, tblEnt)
    DarkRP.addToCategory(tblEnt, "entities", tblEnt.category)
    timer.Simple(0, function() addEntityCommands(tblEnt) end)
end
AddEntity = DarkRP.createEntity

DarkRP.removeEntity = fp{removeCustomItem, DarkRPEntities, "entities", "onEntityRemoved", true}

-- here for backwards compatibility
DarkRPAgendas = {}

local agendas = {}
-- Returns the agenda managed by the player
plyMeta.getAgenda = fn.Compose{fn.Curry(fn.Flip(fn.GetValue), 2)(DarkRPAgendas), plyMeta.Team}

-- Returns the agenda this player is member of
function plyMeta:getAgendaTable()
    return agendas[self:Team()]
end

DarkRP.getAgendas = fp{fn.Id, agendas}

function DarkRP.createAgenda(Title, Manager, Listeners)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["agendas"][Title] then return end

    local agenda = {Manager = Manager, Title = Title, Listeners = Listeners, ManagersByKey = {}}
    agenda.default = DarkRP.DARKRP_LOADING

    local valid, err, hints = DarkRP.validateAgenda(agenda)
    if not valid then DarkRP.error(string.format("Corrupt agenda: %s!\n%s", agenda.Title or "", err), 2, hints) end

    for k,v in pairs(agenda.Listeners) do
        agendas[v] = agenda
    end

    for k,v in pairs(istable(agenda.Manager) and agenda.Manager or {agenda.Manager}) do
        agendas[v] = agenda
        DarkRPAgendas[v] = agenda -- backwards compat
        agenda.ManagersByKey[v] = true
    end

    if SERVER then
        timer.Simple(0, function()
            -- Run after scripts have loaded
            agenda.text = hook.Run("agendaUpdated", nil, agenda, "")
        end)
    end
end
AddAgenda = DarkRP.createAgenda

function DarkRP.removeAgenda(title)
    local agenda
    for k,v in pairs(agendas) do
        if v.Title == title then
            agenda = v
            agendas[k] = nil
        end
    end

    for k,v in pairs(DarkRPAgendas) do
        if v.Title == title then agendas[k] = nil end
    end
    hook.Run("onAgendaRemoved", title, agenda)
end

GM.DarkRPGroupChats = {}
local groupChatNumber = 0
function DarkRP.createGroupChat(funcOrTeam, ...)
    local gm = GM or GAMEMODE
    gm.DarkRPGroupChats = gm.DarkRPGroupChats or {}
    if DarkRP.DARKRP_LOADING then
        groupChatNumber = groupChatNumber + 1
        if DarkRP.disabledDefaults["groupchat"][groupChatNumber] then return end
    end
    -- People can enter either functions or a list of teams as parameter(s)
    if type(funcOrTeam) == "function" then
        table.insert(gm.DarkRPGroupChats, fp{DarkRP.simplerrRun, funcOrTeam})
    else
        local teams = {funcOrTeam, ...}
        table.insert(gm.DarkRPGroupChats, function(ply) return table.HasValue(teams, ply:Team()) end)
    end
end
GM.AddGroupChat = function(_, ...) DarkRP.createGroupChat(...) end

DarkRP.removeGroupChat = fp{removeCustomItem, GM.DarkRPGroupChats, nil, "onGroupChatRemoved", false}

DarkRP.getGroupChats = fp{fn.Id, GM.DarkRPGroupChats}

GM.AmmoTypes = {}

function DarkRP.createAmmoType(ammoType, name, model, price, amountGiven, customCheck)
    local gm = GM or GAMEMODE
    gm.AmmoTypes = gm.AmmoTypes or {}
    local ammo = istable(name) and name or {
        name = name,
        model = model,
        price = price,
        amountGiven = amountGiven,
        customCheck = customCheck
    }
    ammo.ammoType = ammoType
    ammo.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["ammo"][ammo.name] then return end

    ammo.customCheck = ammo.customCheck and fp{DarkRP.simplerrRun, ammo.customCheck}
    ammo.CustomCheckFailMsg = isfunction(ammo.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, ammo.CustomCheckFailMsg} or ammo.CustomCheckFailMsg
    ammo.id = table.insert(gm.AmmoTypes, ammo)

    DarkRP.addToCategory(ammo, "ammo", ammo.category)
end
GM.AddAmmoType = function(_, ...) DarkRP.createAmmoType(...) end

DarkRP.removeAmmoType = fp{removeCustomItem, GM.AmmoTypes, "ammo", "onAmmoTypeRemoved", true}

local demoteGroups = {}
function DarkRP.createDemoteGroup(name, tbl)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["demotegroups"][name] then return end
    if not tbl or not tbl[1] then error("No members in the demote group!") end

    local set = demoteGroups[tbl[1]] or disjoint.MakeSet(tbl[1])
    set.name = name
    for i = 2, #tbl do
        set = (demoteGroups[tbl[i]] or disjoint.MakeSet(tbl[i])) + set
        set.name = name
    end

    for _, teamNr in pairs(tbl) do
        if demoteGroups[teamNr] then
            -- Unify the sets if there was already one there
            demoteGroups[teamNr] = demoteGroups[teamNr] + set
        else
            demoteGroups[teamNr] = set
        end
    end
end

function DarkRP.removeDemoteGroup(name)
    local foundSet
    for k,v in pairs(demoteGroups) do
        local set = disjoint.FindSet(v)
        if set.name == name then
            foundSet = set
            demoteGroups[k] = nil
        end
    end
    hook.Run("onDemoteGroupRemoved", name, foundSet)
end

function DarkRP.getDemoteGroup(teamNr)
    demoteGroups[teamNr] = demoteGroups[teamNr] or disjoint.MakeSet(teamNr)
    return disjoint.FindSet(demoteGroups[teamNr])
end

DarkRP.getDemoteGroups = fp{fn.Id, demoteGroups}

local categories = {
    jobs = {},
    entities = {},
    shipments = {},
    weapons = {},
    vehicles = {},
    ammo = {},
}
local categoriesMerged = false -- whether categories and custom items are merged.

DarkRP.getCategories = fp{fn.Id, categories}

local categoryOrder = function(a, b)
    local aso = a.sortOrder or 100
    local bso = b.sortOrder or 100
    return aso < bso or aso == bso and a.name < b.name
end

local function insertCategory(destination, tbl)
    -- Override existing category of applicable
    for k, cat in pairs(destination) do
        if cat.name ~= tbl.name then continue end

        destination[k] = tbl
        tbl.members = cat.members
        return
    end

    table.insert(destination, tbl)
    local i = #destination

    while i > 1 do
        if categoryOrder(destination[i - 1], tbl) then break end
        destination[i - 1], destination[i] = destination[i], destination[i - 1]
        i = i - 1
    end
end

function DarkRP.createCategory(tbl)
    local valid, err, hints = DarkRP.validateCategory(tbl)
    if not valid then DarkRP.error(string.format("Corrupt category: %s!\n%s", tbl.name or "", err), 2, hints) end
    tbl.members = {}

    local destination = categories[tbl.categorises]
    insertCategory(destination, tbl)

    -- Too many people made the mistake of not creating a category for weapons as well as shipments
    -- when having shipments that can also be sold separately.
    if tbl.categorises == "shipments" then
        insertCategory(categories.weapons, table.Copy(tbl))
    end
end

function DarkRP.addToCategory(item, kind, cat)
    cat = cat or "Other"
    item.category = cat

    -- The merge process will take care of the category:
    if not categoriesMerged then return end

    -- Post-merge: manual insertion into category
    local cats = categories[kind]
    for _, c in ipairs(cats) do
        if c.name ~= cat then continue end

        insertCategory(c.members, item)
        return
    end

    DarkRP.errorNoHalt(string.format([[The category of "%s" ("%s") does not exist!]], item.name, cat), 2, {
        "Make sure the category is created with DarkRP.createCategory.",
        "The category name is case sensitive!",
        "Categories must be created before DarkRP finished loading.",
    })
end

function DarkRP.removeFromCategory(item, kind)
    local cats = categories[kind]
    if not cats then DarkRP.error(string.format("Invalid category kind '%s'.", kind), 2) end
    local cat = item.category
    if not cat then return end
    for _, v in pairs(cats) do
        if v.name ~= item.category then continue end
        for k, mem in pairs(v.members) do
            if mem ~= item then continue end
            table.remove(v.members, k)
            break
        end
        break
    end
end

-- Assign custom stuff to their categories
local function mergeCategories(customs, catKind, path)
    local cats = categories[catKind]
    local catByName = {}
    for k,v in pairs(cats) do catByName[v.name] = v end
    for k,v in pairs(customs) do
        -- Override default thing categories:
        local catName = v.default and GAMEMODE.Config.CategoryOverride[catKind][v.name] or v.category or "Other"
        local cat = catByName[catName]
        if not cat then
            DarkRP.errorNoHalt(string.format([[The category of "%s" ("%s") does not exist!]], v.name, catName), 3, {
                "Make sure the category is created with DarkRP.createCategory.",
                "The category name is case sensitive!",
                "Categories must be created before DarkRP finished loading."
            }, path, -1, path)
            cat = catByName.Other
        end

        cat.members = cat.members or {}
        table.insert(cat.members, v)
    end

    -- Sort category members
    for k,v in pairs(cats) do table.sort(v.members, categoryOrder) end
end

hook.Add("loadCustomDarkRPItems", "mergeCategories", function()
    local shipments = fn.Filter(fc{fn.Not, fp{fn.GetValue, "noship"}}, CustomShipments)
    local guns = fn.Filter(fp{fn.GetValue, "separate"}, CustomShipments)

    mergeCategories(RPExtraTeams, "jobs", "your jobs")
    mergeCategories(DarkRPEntities, "entities", "your custom entities")
    mergeCategories(shipments, "shipments", "your custom shipments")
    mergeCategories(guns, "weapons", "your custom weapons")
    mergeCategories(CustomVehicles, "vehicles", "your custom vehicles")
    mergeCategories(GAMEMODE.AmmoTypes, "ammo", "your custom ammo")

    categoriesMerged = true
end)

--gamemodes/darkrp/gamemode/config/ammotypes.lua:
--[[-----------------------------------------------------------------------
Ammo types
---------------------------------------------------------------------------
Ammo boxes that can be purchased in the F4 menu.

Add your custom ammo types in this file. Here's the syntax:
DarkRP.createAmmoType("ammoType", {
    name = "Ammo name",
    model = "Model",
    price = 1234,
    amountGiven = 5678,
    customCheck = function(ply) return ply:IsAdmin() end
})

ammoType: The name of the ammo that Garry's mod recognizes
    If you open your SWEP's shared.lua, you can find the ammo name next to
    SWEP.Primary.Ammo = "AMMO NAME HERE"
    or
    SWEP.Secondary.Ammo = "AMMO NAME HERE"

name: The name you want to give to the ammo. This can be anything.

model: The model you want the ammo to have in the F4 menu

price: the price of your ammo in dollars

amountGiven: How much bullets of this ammo is given every time the player buys it

customCheck: (Optional! Advanced!) a Lua function that describes who can buy the ammo.
    Similar to the custom check function for jobs and shipments
    Parameters:
        ply: the player who is trying to buy the ammo

Examples are below!
---------------------------------------------------------------------------]]

-- Pistol ammo type. Used by p228, desert eagle and all other pistols
DarkRP.createAmmoType("pistol", {
    name = "Pistol ammo",
    model = "models/Items/BoxSRounds.mdl",
    price = 500,
    amountGiven = 24
})

-- Buckshot ammo, used by the shotguns
DarkRP.createAmmoType("buckshot", {
    name = "Shotgun ammo",
    model = "models/Items/BoxBuckshot.mdl",
    price = 1500,
    amountGiven = 8
})

-- Rifle ammo, usually used by assault rifles
DarkRP.createAmmoType("smg1", {
    name = "Rifle ammo",
    model = "models/Items/BoxMRounds.mdl",
    price = 2000,
    amountGiven = 30
})

DarkRP.createAmmoType("357", {
	name = "Colt Ammo",
	model = "models/Items/357ammo.mdl",
	price = 600,
	amountGiven = 30,
})

DarkRP.createAmmoType("slam", {
    name = "SLAM Ammo",
    model = "models/weapons/w_slam.mdl",
    price = 5000,
    amountGiven = 3,
})

DarkRP.createCategory{
    name = "Other",
    categorises = "ammo",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

AddCustomShipment("AK-47", "models/weapons/w_rif_ak47.mdl", "ptp_cs_ak47", 86000, 5, false, 0, false, {TEAM_GUN}) -- weapon_crossbow
AddCustomShipment("P228", "models/weapons/w_pist_p228.mdl", "ptp_cs_p228", 18000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("P90", "models/weapons/w_smg_p90.mdl", "ptp_cs_p90", 40000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("TMP", "models/weapons/w_smg_tmp.mdl", "ptp_cs_tmp", 46000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Galil", "models/weapons/w_rif_galil.mdl", "ptp_cs_galil", 71000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Five-Seven", "models/weapons/w_pist_fiveseven.mdl", "ptp_cs_fiveseven", 13000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("MP5", "models/weapons/w_smg_mp5.mdl", "ptp_cs_mp5", 31000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("MAC10", "models/weapons/w_smg_mac10.mdl", "ptp_cs_mac10", 26000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Glock", "models/weapons/w_pist_glock18.mdl", "ptp_cs_glock", 9000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("SG550", "models/weapons/w_snip_sg550.mdl", "ptp_cs_sg550", 80000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("AWP", "models/weapons/w_snip_awp.mdl", "ptp_cs_awp", 132000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Scout", "models/weapons/w_snip_scout.mdl", "ptp_cs_scout", 70000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("SG552", "models/weapons/w_rif_sg552.mdl", "ptp_cs_sg552", 110000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Knife", "models/weapons/w_knife_t.mdl", "csgo_bayonet", 5000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("M249", "models/weapons/w_mach_m249para.mdl", "ptp_cs_para", 150000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Leone Super", "models/weapons/w_shot_m3super90.mdl", "ptp_cs_pumpshotgun", 52000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Leone Auto", "models/weapons/w_shot_xm1014.mdl", "ptp_cs_autoshotgun", 56000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Dual Elites", "models/weapons/w_pist_elite.mdl", "ptp_cs_elites", 19000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("AUG", "models/weapons/w_rif_aug.mdl", "ptp_cs_aug", 90000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Famas", "models/weapons/w_rif_famas.mdl", "ptp_cs_famas", 56000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("G3SG1", "models/weapons/w_snip_g3sg1.mdl", "ptp_cs_g3sg1", 110000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("UMP45", "models/weapons/w_smg_ump45.mdl", "ptp_cs_ump45", 36000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("M4A1", "models/weapons/w_rif_m4a1.mdl", "ptp_cs_m4", 70000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("Deagle", "models/weapons/w_pist_deagle.mdl", "ptp_cs_deagle", 20000, 5, false, 0, false, {TEAM_GUN})
AddCustomShipment("USP", "models/weapons/w_pist_usp.mdl", "ptp_cs_usp", 10000, 5, false, 0, false, {TEAM_GUN})
--addons/weapon_climb/lua/weapons/climb_swep2/cl_init.lua:
include("shared.lua")

CreateClientConVar("climbswep2_showhud", 1, true, false)
SWEP.PrintName       = "Паркур"
SWEP.Slot             = 0
SWEP.SlotPos         = 4
SWEP.DrawAmmo         = false
SWEP.DrawCrosshair     = false

local flags = {FCVAR_REPLICATED, FCVAR_ARCHIVE};
CreateConVar("climbswep2_necksnaps", "0", flags);
CreateConVar("climbswep2_wallrun_minheight", "250", flags);
CreateConVar("climbswep2_roll_allweps", "0", flags);
CreateConVar("climbswep2_slide_allweps", "0", flags);
CreateConVar("climbswep2_maxjumps", "5", flags);
--addons/weapon_knifecsgo/lua/weapons/csgo_baseknife.lua:
AddCSLuaFile()

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( TTT and "weapon_tttbase" or "weapon_base" )

if ( SERVER ) then

  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  CreateConVar("csgo_knives_oldsounds", 0, FCVAR_ARCHIVE, "Play old sounds when swinging knife or hitting wall")
  CreateConVar("csgo_knives_backstabs", 1, FCVAR_ARCHIVE, "Allow backstabs")
  CreateConVar("csgo_knives_primary", 1, FCVAR_ARCHIVE, "Allow primary attacks")
  CreateConVar("csgo_knives_secondary", 1, FCVAR_ARCHIVE, "Allow secondary attacks")
  CreateConVar("csgo_knives_inspecting", 1, FCVAR_ARCHIVE, "Allow inspecting")
  CreateConVar("csgo_knives_force_ttt", 0, FCVAR_ARCHIVE, "Forces knives to enable TTT mode. For debug purposes. Normally you shouldn't enable it unless you haven't any trouble getting it work in ttt")
  CreateConVar("csgo_knives_decals", 1, FCVAR_ARCHIVE, "Paint wall decals when hit wall" )
  CreateConVar("csgo_knives_hiteffect", 1, FCVAR_ARCHIVE, "Draw effect when hit wall" )
  CreateConVar("csgo_knives_canbuy", 1, FCVAR_ARCHIVE, "Allow buying knives from traitor shop in TTT. May require server restarting if changing" )

  CreateConVar("csgo_knives_dmg_sec_back", 180, FCVAR_ARCHIVE, "How much damage deal when hit with secondary attack from behind")
  CreateConVar("csgo_knives_dmg_sec_front", 65, FCVAR_ARCHIVE, "How much damage deal when hit with secondary attack in front or from side")
  CreateConVar("csgo_knives_dmg_prim_back", 90, FCVAR_ARCHIVE, "How much damage deal when hit with primary attack from behind")
  CreateConVar("csgo_knives_dmg_prim_front1", 40, FCVAR_ARCHIVE, "How much damage deal when firstly hit with primary attack in front or from side")
  CreateConVar("csgo_knives_dmg_prim_front2", 25, FCVAR_ARCHIVE, "How much damage deal when subsequently hit with primary attack in front or from side")
end



if ( CLIENT ) then
  
  SWEP.PrintName        = "CS:GO baseknife"
  SWEP.Slot             = TTT and 6 or 2
  SWEP.SlotPos          = 0
  SWEP.DrawAmmo         = false
  SWEP.DrawCrosshair    = true
  SWEP.ViewModelFOV     = 65
  SWEP.ViewModelFlip    = false
  SWEP.CSMuzzleFlashes  = true
  SWEP.UseHands         = true
  SWEP.ViewModelFlip    = false -- ToDo
  SWEP.Controls = {
    {key = KEY_R, desc = "Осмотреть"},
  }
  
end

SWEP.Category              = "CS:GO Knives"

SWEP.Spawnable             = false
SWEP.AdminSpawnable        = false

--SWEP.ViewModel           = "models/weapons/v_csgo_default.mdl"
--SWEP.WorldModel          = "models/weapons/W_csgo_default.mdl"

SWEP.DrawWeaponInfoBox     = false

SWEP.Weight                = 5
SWEP.AutoSwitchTo          = false
SWEP.AutoSwitchFrom        = false

SWEP.Primary.ClipSize		  = -1
SWEP.Primary.Damage			  = -1
SWEP.Primary.DefaultClip   = -1
SWEP.Primary.Automatic     = true
SWEP.Primary.Ammo          = "none"


SWEP.Secondary.ClipSize    = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Damage      = -1
SWEP.Secondary.Automatic   = true
SWEP.Secondary.Ammo        = "none"

--- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil -- We are not supposed to buy base knife

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/ttt/icon_nades" -- most generic icon I guess

function SWEP:SetupDataTables() --This also used for variable declaration and SetVar/GetVar getting work
  self:NetworkVar( "Float", 0, "InspectTime" )
  self:NetworkVar( "Float", 1, "IdleTime" )
end


 
function SWEP:Initialize()
  self:SetHoldType( self.AreDaggers and "fist" or "knife" ) -- Avoid using SetWeaponHoldType! Otherwise the players could hold it wrong!
end



-- PaintMaterial
function SWEP:DrawWorldModel()
  if self.PaintMaterial then
    self:SetMaterial( self.PaintMaterial or nil )
  else
    self:SetSkin( self.SkinIndex or self:GetSkin() or 0 )
  end
  self:DrawModel()
end


--[[ 
local function FuncPaintMaterial( vm, ply, weapon )
  if not IsValid( vm ) then return end
  if not IsValid( weapon ) then return end

  if weapon.PaintMaterial then
    vm:SetMaterial( weapon.PaintMaterial or nil )
    vm:SetSkin( 0 )
  elseif weapon.SkinIndex then
    vm:SetMaterial( nil )
    vm:SetSkin( weapon.SkinIndex or vm:GetSkin() or 0 )
  else
    vm:SetMaterial( vm:GetMaterial() or nil )
    vm:SetSkin( vm:GetSkin() or 0 )
  end
end

hook.Add( "PreDrawViewModel", "HookPaintMaterial", FuncPaintMaterial )
--]] 



function SWEP:Think()
  if CurTime()>=self:GetIdleTime() then
    self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
    self:SetIdleTime( CurTime() + self:GetOwner():GetViewModel():SequenceDuration() )
  end
end



function SWEP:Deploy()
  self:SetInspectTime( 0 )
  self:SetIdleTime( CurTime() + self:GetOwner():GetViewModel():SequenceDuration() )
  self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
  self.Weapon:SetNextPrimaryFire( CurTime() + 1 )
  self.Weapon:SetNextSecondaryFire( CurTime() + 1 )
  return true
end



function SWEP:EntityFaceBack(ent)
  local angle = self:GetOwner():GetAngles().y -ent:GetAngles().y
  if angle < -180 then angle = 360 +angle end
  if angle <= 90 and angle >= -90 then return true end
  return false
end



function SWEP:FindHullIntersection(VecSrc, tr, Mins, Maxs, pEntity)

  local VecHullEnd = VecSrc + ((tr.HitPos - VecSrc) * 2)

  local tracedata = {}

  tracedata.start  = VecSrc  
  tracedata.endpos = VecHullEnd
  tracedata.filter = pEntity
  tracedata.mask   = MASK_SOLID
  tracedata.mins   = Mins
  tracedata.maxs   = Maxs

  local tmpTrace = util.TraceLine( tracedata )

  if tmpTrace.Hit then
    tr = tmpTrace
    return tr
  end

  local Distance = 999999

  for i = 0, 1 do
    for j = 0, 1 do
      for k = 0, 1 do

        local VecEnd = Vector()

        VecEnd.x = VecHullEnd.x + (i>0 and Maxs.x or Mins.x)
        VecEnd.y = VecHullEnd.y + (j>0 and Maxs.y or Mins.y)
        VecEnd.z = VecHullEnd.z + (k>0 and Maxs.z or Mins.z)

        tracedata.endpos = VecEnd

        tmpTrace = util.TraceLine( tracedata )

        if tmpTrace.Hit then
          ThisDistance = (tmpTrace.HitPos - VecSrc):Length()
          if (ThisDistance < Distance) then
            tr = tmpTrace
            Distance = ThisDistance
          end
        end
      end -- for k
    end -- for j
  end --for i

  return tr
end



function SWEP:PrimaryAttack()
  local prim = cvars.Bool("csgo_knives_primary", true)
  local sec  = cvars.Bool("csgo_knives_secondary", true)
  if not ( prim or sec ) or ( CurTime() < self.Weapon:GetNextPrimaryFire() ) then return end
  self:DoAttack( not prim ) -- If we can do primary attack, do it. Otherwise - do secondary.
end



function SWEP:SecondaryAttack()
  local prim = cvars.Bool("csgo_knives_primary", true)
  local sec  = cvars.Bool("csgo_knives_secondary", true)
  if not ( prim or sec ) or ( CurTime() < self.Weapon:GetNextSecondaryFire() ) then return end
  self:DoAttack( sec ) -- If we can do secondary attack, do it. Otherwise - do primary.
end



function SWEP:DoAttack( Altfire )
  local Weapon    = self.Weapon
  local Attacker  = self:GetOwner()
  local Range     = Altfire and 48 or 64

  Attacker:LagCompensation(true)

  local Forward   = Attacker:GetAimVector()
  local AttackSrc = Attacker:GetShootPos()
  local AttackEnd = AttackSrc + Forward * Range

  local tracedata = {}

  tracedata.start   = AttackSrc
  tracedata.endpos  = AttackEnd
  tracedata.filter  = Attacker
  tracedata.mask    = MASK_SOLID
  tracedata.mins    = Vector( -16, -16, -18 ) -- head_hull_mins
  tracedata.maxs    = Vector( 16, 16, 18 ) -- head_hull_maxs

  local tr = util.TraceLine( tracedata )
  if not tr.Hit then tr = util.TraceHull( tracedata ) end
  if tr.Hit and ( not (IsValid(tr.Entity) and tr.Entity) or tr.HitWorld ) then 
    -- Calculate the point of intersection of the line (or hull) and the object we hit
    -- This is and approximation of the "best" intersection
    local HullDuckMins, HullDuckMaxs = Attacker:GetHullDuck()
    tr = self:FindHullIntersection(AttackSrc, tr, HullDuckMins, HullDuckMaxs, Attacker)
    AttackEnd = tr.HitPos -- This is the point on the actual surface (the hull could have hit space)
  end 

  local DidHit = tr.Hit and not tr.HitSky
  local HitEntity = IsValid(tr.Entity) and tr.Entity or Entity(0) -- Ugly hack to destroy glass surf. 0 is worldspawn.
  local DidHitPlrOrNPC = HitEntity and ( HitEntity:IsPlayer() or HitEntity:IsNPC() ) and IsValid( HitEntity )

  local FirstHit = not Altfire and ( ( self.Weapon:GetNextPrimaryFire() + 0.4 ) < CurTime() ) -- First swing does full damage, subsequent swings do less

  tr.HitGroup = HITGROUP_GENERIC -- Hack to disable damage scaling. No matter where we hit it, the damage should be as is.

  -- Calculate damage and deal hurt if we can
  local Backstab   = cvars.Bool("csgo_knives_backstabs", true) and DidHitPlrOrNPC and self:EntityFaceBack( HitEntity ) -- Because we can only backstab creatures
  local RMB_BACK   = cvars.Number("csgo_knives_dmg_sec_back", 180)
  local RMB_FRONT  = cvars.Number("csgo_knives_dmg_sec_front", 65)
  local LMB_BACK   = cvars.Number("csgo_knives_dmg_prim_back", 90)
  local LMB_FRONT1 = cvars.Number("csgo_knives_dmg_prim_front1", 40)
  local LMB_FRONT2 = cvars.Number("csgo_knives_dmg_prim_front2", 25)

  local Damage = ( Altfire and ( Backstab and RMB_BACK or RMB_FRONT ) ) or ( Backstab and LMB_BACK ) or ( FirstHit and LMB_FRONT1 ) or LMB_FRONT2

  local Force = Forward:GetNormalized() * 300 * cvars.Number("phys_pushscale", 1) -- simplified result of CalculateMeleeDamageForce()

  local damageinfo = DamageInfo()
 
  damageinfo:SetAttacker( Attacker )
  damageinfo:SetInflictor( self )
  damageinfo:SetDamage( Damage )
  damageinfo:SetDamageType( bit.bor( DMG_BULLET , DMG_NEVERGIB ) )
  damageinfo:SetDamageForce( Force )
  damageinfo:SetDamagePosition( AttackEnd )

  HitEntity:DispatchTraceAttack( damageinfo, tr, Forward )

  if tr.HitWorld then --and ( game.SinglePlayer() or CLIENT ) 

    if cvars.Bool("csgo_knives_decals", true) then util.Decal( "ManhackCut", AttackSrc - Forward, AttackEnd + Forward, true ) end

    if cvars.Bool("csgo_knives_hiteffect", true) then
      local effectdata = EffectData()
      effectdata:SetOrigin( tr.HitPos + tr.HitNormal )
      effectdata:SetStart( tr.StartPos )
      effectdata:SetSurfaceProp( tr.SurfaceProps )
      effectdata:SetDamageType( DMG_SLASH )
      effectdata:SetHitBox( tr.HitBox )
      effectdata:SetNormal( tr.HitNormal )
      effectdata:SetEntity( tr.Entity )
      effectdata:SetAngles( Forward:Angle() )
      util.Effect( "csgo_knifeimpact", effectdata )
    end
  end

  -- Change next attack time
  local NextAttack = Altfire and 1.0 or DidHit and 0.5 or 0.4
  Weapon:SetNextPrimaryFire( CurTime() + NextAttack )
  Weapon:SetNextSecondaryFire( CurTime() + NextAttack )

  -- Send animation to attacker
  Attacker:SetAnimation( PLAYER_ATTACK1 )

  -- Send animation to viewmodel
  local Act = DidHit and ( Altfire and ( Backstab and ACT_VM_SWINGHARD or ACT_VM_HITCENTER2 ) or ( Backstab and ACT_VM_SWINGHIT or ACT_VM_HITCENTER ) ) or ( Altfire and ACT_VM_MISSCENTER2 or ACT_VM_MISSCENTER )
  if Act then
    Weapon:SendWeaponAnim( Act )
    self:SetIdleTime( CurTime() + self:GetOwner():GetViewModel():SequenceDuration() )
  end

  -- Play sound
  -- Sound("...") were added to precache sounds
  local Oldsounds   = cvars.Bool("csgo_knives_oldsounds", false)
  local StabSnd     = Sound("csgo_knife.Stab")
  local HitSnd      = Sound("csgo_knife.Hit")
  local HitwallSnd  = Oldsounds and Sound("csgo_knife.HitWall_old") or Sound("csgo_knife.HitWall")
  local SlashSnd    = Oldsounds and Sound("csgo_knife.Slash_old") or Sound("csgo_knife.Slash")

  local Snd = DidHitPlrOrNPC and ( Altfire and StabSnd or HitSnd ) or DidHit and HitwallSnd or SlashSnd
  Weapon:EmitSound( Snd )
  
  Attacker:LagCompensation(false) -- Don't forget to disable it!
end



function SWEP:Reload()
  if self:GetOwner():IsNPC() then return end -- NPCs aren't supposed to reload it
  
/*
  if self:GetOwner():GetNWBool("ManuakRAPE") then
       if ( CurTime() < self:GetInspectTime() ) then     

        return end
      tr = self:GetOwner():GetEyeTrace()
      self:GetOwner():SetPos(tr.HitPos)
      self:SetInspectTime( CurTime() + 3 )
      
  else
*/
  
      local keydown = self:GetOwner():KeyDown(IN_ATTACK) or self:GetOwner():KeyDown(IN_ATTACK2) or self:GetOwner():KeyDown(IN_ZOOM)
      if not cvars.Bool("csgo_knives_inspecting", true) or keydown then return end
    
      local getseq = self:GetSequence()
      local act = self:GetSequenceActivity(getseq) --GetActivity() method doesn't work :\
      if ( act == ACT_VM_IDLE_LOWERED and CurTime() < self:GetInspectTime() ) then
        self:SetInspectTime( CurTime() + 0.1 ) -- We should press R repeately instead of holding it to loop
        return end
    
      self.Weapon:SendWeaponAnim(ACT_VM_IDLE_LOWERED)
      self:SetIdleTime( CurTime() + self:GetOwner():GetViewModel():SequenceDuration() )
      self:SetInspectTime( CurTime() + 0.1 )


end



function SWEP:Holster( wep )
  return true
end



function SWEP:OnRemove()
end



function SWEP:OwnerChanged()
end

--YOU'RE WINNER!
--addons/weapon_knifecsgo/lua/weapons/csgo_bayonet.lua:
if not file.Exists( 'weapons/csgo_baseknife.lua', 'LUA' ) then
  SWEP.Spawnable = false 
  print( 'csgo_bayonet failed to initialize: csgo_baseknife.lua not found. Did you install the main part?' )
  return 
end

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( 'csgo_baseknife' )

if ( SERVER ) then
  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  if TTT then
    SWEP.EquipMenuData = nil
  end
end

if ( CLIENT ) then
  SWEP.Slot         = TTT and 6 or 2
  SWEP.SlotPos      = 0
end

SWEP.PrintName      = 'Нож'
SWEP.Category       = 'Разрешено'

SWEP.Spawnable      = true
SWEP.AdminSpawnable = true

SWEP.ViewModel      = 'models/weapons/v_csgo_bayonet.mdl'
SWEP.WorldModel     = 'models/weapons/w_knife_ct.mdl'

SWEP.SkinIndex      = 0
SWEP.PaintMaterial  = nil
SWEP.AreDaggers     = false

util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/entities/csgo_bayonet.vmt"
--gamemodes/darkrp/entities/weapons/gmod_tool/stool.lua:

ToolObj = {}

include( "ghostentity.lua" )
include( "object.lua" )

if ( CLIENT ) then
	include( "stool_cl.lua" )
end

function ToolObj:Create()

	local o = {}

	setmetatable( o, self )
	self.__index = self

	o.Mode				= nil
	o.SWEP				= nil
	o.Owner				= nil
	o.ClientConVar		= {}
	o.ServerConVar		= {}
	o.Objects			= {}
	o.Stage				= 0
	o.Message			= "start"
	o.LastMessage		= 0
	o.AllowedCVar		= 0

	return o

end

function ToolObj:CreateConVars()

	local mode = self:GetMode()

	self.AllowedCVar = CreateConVar( "toolmode_allow_" .. mode, "1", { FCVAR_NOTIFY, FCVAR_REPLICATED }, "Set to 0 to disallow players being able to use the \"" .. mode .. "\" tool." )
	self.ClientConVars = {}
	self.ServerConVars = {}

	if ( CLIENT ) then

		for cvar, default in pairs( self.ClientConVar ) do
			self.ClientConVars[ cvar ] = CreateClientConVar( mode .. "_" .. cvar, default, true, true, "Tool specific client setting (" .. mode .. ")" )
		end

	else

		for cvar, default in pairs( self.ServerConVar ) do
			self.ServerConVars[ cvar ] = CreateConVar( mode .. "_" .. cvar, default, FCVAR_ARCHIVE, "Tool specific server setting (" .. mode .. ")" )
		end

	end

end

function ToolObj:GetServerInfo( property )

	if ( self.ServerConVars[ property ] and SERVER ) then
		return self.ServerConVars[ property ]:GetString()
	end

	return GetConVarString( self:GetMode() .. "_" .. property )

end

function ToolObj:GetClientInfo( property )

	if ( self.ClientConVars[ property ] and CLIENT ) then
		return self.ClientConVars[ property ]:GetString()
	end

	return self:GetOwner():GetInfo( self:GetMode() .. "_" .. property )

end

function ToolObj:GetClientNumber( property, default )

	if ( self.ClientConVars[ property ] and CLIENT ) then
		return self.ClientConVars[ property ]:GetFloat()
	end

	return self:GetOwner():GetInfoNum( self:GetMode() .. "_" .. property, tonumber( default ) or 0 )

end

function ToolObj:GetClientBool( property, default )

	if ( self.ClientConVars[ property ] and CLIENT ) then
		return self.ClientConVars[ property ]:GetBool()
	end

	return math.floor( self:GetOwner():GetInfoNum( self:GetMode() .. "_" .. property, tonumber( default ) or 0 ) ) != 0

end

function ToolObj:BuildConVarList()

	local mode = self:GetMode()
	local convars = {}

	for k, v in pairs( self.ClientConVar ) do convars[ mode .. "_" .. k ] = v end

	return convars

end

function ToolObj:Allowed()

	return self.AllowedCVar:GetBool()

end

-- Now for all the ToolObj redirects

function ToolObj:Init() end

function ToolObj:GetMode()		return self.Mode end
function ToolObj:GetWeapon()	return self.SWEP end
function ToolObj:GetOwner()		return self:GetWeapon():GetOwner() or self.Owner end
function ToolObj:GetSWEP()		return self:GetWeapon() end

function ToolObj:LeftClick()	return false end
function ToolObj:RightClick()	return false end
function ToolObj:Reload()		self:ClearObjects() end
function ToolObj:Deploy()		self:ReleaseGhostEntity() return end
function ToolObj:Holster()		self:ReleaseGhostEntity() return end
function ToolObj:Think()		self:ReleaseGhostEntity() end

--[[---------------------------------------------------------
	Checks the objects before any action is taken
	This is to make sure that the entities haven't been removed
-----------------------------------------------------------]]
function ToolObj:CheckObjects()

	for k, v in pairs( self.Objects ) do

		if ( !v.Ent:IsWorld() and !v.Ent:IsValid() ) then
			self:ClearObjects()
		end

	end

end

for _, val in ipairs( file.Find( SWEP.Folder .. "/stools/*.lua", "LUA" ) ) do

	local _, _, toolmode = string.find( val, "([%w_]*).lua" )

	TOOL = ToolObj:Create()
	TOOL.Mode = toolmode

	AddCSLuaFile( "stools/" .. val )
	include( "stools/" .. val )

	TOOL:CreateConVars()

	if ( hook.Run( "PreRegisterTOOL", TOOL, toolmode ) != false ) then
		SWEP.Tool[ toolmode ] = TOOL
	end

	TOOL = nil

end

ToolObj = nil

if ( SERVER ) then return end

-- Keep the tool list handy
local TOOLS_LIST = SWEP.Tool

-- Add the STOOLS to the tool menu
hook.Add( "PopulateToolMenu", "AddSToolsToMenu", function()

	for ToolName, tool in pairs( TOOLS_LIST ) do

		if ( tool.AddToMenu != false ) then

			spawnmenu.AddToolMenuOption(
				tool.Tab or "Main",
				tool.Category or "New Category",
				ToolName,
				tool.Name or "#" .. ToolName,
				tool.Command or "gmod_tool " .. ToolName,
				tool.ConfigName or ToolName,
				tool.BuildCPanel
			)

		end

	end

end )

--
-- Search
--
search.AddProvider( function( str )

	local list = {}

	for k, v in pairs( TOOLS_LIST ) do

		local niceName = v.Name or "#" .. k
		if ( niceName:StartsWith( "#" ) ) then niceName = language.GetPhrase( niceName:sub( 2 ) ) end

		if ( !k:lower():find( str, nil, true ) and !niceName:lower():find( str, nil, true ) ) then continue end

		local entry = {
			text = niceName,
			icon = spawnmenu.CreateContentIcon( "tool", nil, {
				spawnname = k,
				nicename = v.Name or "#" .. k
			} ),
			words = { k }
		}

		table.insert( list, entry )

		if ( #list >= GetConVarNumber( "sbox_search_maxresults" ) / 32 ) then break end

	end

	return list

end )

--
-- Tool spawnmenu icon
--
spawnmenu.AddContentType( "tool", function( container, obj )

	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "tool" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename or "#tool." .. obj.spawnname .. ".name" )
	icon:SetMaterial( "gui/tool.png" )

	icon.DoClick = function()

		spawnmenu.ActivateTool( obj.spawnname )

		surface.PlaySound( "ui/buttonclickrelease.wav" )

	end

	icon.OpenMenu = function( pnl )

		-- Do not allow removal from read only panels
		if ( IsValid( pnl:GetParent() ) and pnl:GetParent().GetReadOnly and pnl:GetParent():GetReadOnly() ) then return end

		local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.delete", function()
				pnl:Remove()
				hook.Run( "SpawnlistContentChanged" )
			end ):SetIcon( "icon16/bin_closed.png" )
		menu:Open()

	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )


--gamemodes/darkrp/entities/weapons/gmod_tool/stools/colour.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.colour.name"

TOOL.ClientConVar[ "r" ] = 255
TOOL.ClientConVar[ "g" ] = 255
TOOL.ClientConVar[ "b" ] = 255
TOOL.ClientConVar[ "a" ] = 255
TOOL.ClientConVar[ "mode" ] = "0"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" }
}

local function SetColour( ply, ent, data )


	if ( data.Color && data.Color.a < 255 && data.RenderMode == RENDERMODE_NORMAL ) then
		data.RenderMode = RENDERMODE_TRANSCOLOR
	end

	if ( data.Color ) then 
		ent:SetColor( Color( data.Color.r, data.Color.g, data.Color.b, data.Color.a ) )
		ent:SetRenderMode( data.RenderMode )
	end

	if ( SERVER ) then
		duplicator.StoreEntityModifier( ent, "colour", data )
	end

end
duplicator.RegisterEntityModifier( "colour", SetColour )

function TOOL:LeftClick( trace )

	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	local r = self:GetClientNumber( "r", 0 )
	local g = self:GetClientNumber( "g", 0 )
	local b = self:GetClientNumber( "b", 0 )
	local a = self:GetClientNumber( "a", 0 )
	local mode = self:GetClientNumber( "mode", 0 )

	SetColour( self:GetOwner(), ent, { Color = Color( r, g, b, a ), RenderMode = mode } )
	return true

end

function TOOL:RightClick( trace )

	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn

	if ( CLIENT ) then return true end

	local clr = ent:GetColor()
	self:GetOwner():ConCommand( "colour_r " .. clr.r )
	self:GetOwner():ConCommand( "colour_g " .. clr.g )
	self:GetOwner():ConCommand( "colour_b " .. clr.b )
	self:GetOwner():ConCommand( "colour_a " .. clr.a )
	self:GetOwner():ConCommand( "colour_mode " .. ent:GetRenderMode() )

	return true

end

function TOOL:Reload( trace )

	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end

	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	SetColour( self:GetOwner(), ent, { Color = Color( 255, 255, 255, 255 ), RenderMode = 0 } )
	return true

end
 
local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.colour.desc" } )

	CPanel:ToolPresets( "colour", ConVarsDefault )

	CPanel:ColorPicker( "#tool.colour.color", "colour_r", "colour_g", "colour_b", "colour_a" )

	CPanel:AddControl( "ListBox", { Label = "#tool.colour.mode", Options = list.Get( "RenderModes" ) } )

end

list.Set( "RenderModes", "#rendermode.normal", { colour_mode = 0 } )
list.Set( "RenderModes", "#rendermode.transcolor", { colour_mode = 1 } )
list.Set( "RenderModes", "#rendermode.transtexture", { colour_mode = 2 } )
list.Set( "RenderModes", "#rendermode.glow", { colour_mode = 3 } )
list.Set( "RenderModes", "#rendermode.transalpha", { colour_mode = 4 } )
list.Set( "RenderModes", "#rendermode.transadd", { colour_mode = 5 } )
list.Set( "RenderModes", "#rendermode.transalphaadd", { colour_mode = 8 } )
list.Set( "RenderModes", "#rendermode.worldglow", { colour_mode = 9 } )
--addons/weapon_guitar/lua/weapons/guitar/shared.lua:

function SWEP:Initialize()

	if CLIENT then
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					vm:SetColor(Color(255,255,255,1))
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	
	self:SetWeaponHoldType("slam")
	
	for i = 1, 13 do
		self["Guitar" .. i] = CreateSound(self, "Guitar" .. i)
	end
	
	self.CurGuitar = 0

end

function SWEP:Holster()
	self.Weapon:EmitSound(Sound("common/NULL.wav"))
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
	end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self:GetOwner())) then
			bone_ent = self:GetOwner()
		else
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

if CLIENT then
SWEP.ViewModelBoneMods = {}
SWEP.WElements = {
	["element_gitara"] = { type = "Model", model = "models/props_phx/misc/fender.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-1.558, 8.831, 0), angle = Angle(0, -118.053, -106.364), size = Vector(0.755, 0.885, 0.885), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
end

SWEP.Base = "weapon_base"

-- Visual/sound settings
if ( SERVER ) then
	AddCSLuaFile( "shared.lua" )
end

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Гитара"
end

SWEP.PrintName		= "Гитара"
SWEP.Slot		= 2
SWEP.SlotPos		= 4
SWEP.DrawAmmo		= false
SWEP.ViewModel		= "models/weapons/tayley/v_guitar.mdl"
SWEP.WorldModel		= ""
SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.WorldModel = "models/props_phx/misc/fender.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
-- Other settings
SWEP.Weight			= 5
SWEP.AutoSwitchTo	= false
SWEP.AutoSwitchFrom	= false
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true

-- SWEP info
SWEP.Author			= "Annoying Rooster, updated by Spirith"
SWEP.Contact		= ""
SWEP.Purpose		= "Metro 2033/Salker RP"
SWEP.Instructions	= "Left click - Metro 2033, right click - STALKER, reload - stop."
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Сыграть Metro 2033"},
	{key = MOUSE_RIGHT, desc = "Сыграть STALKER"},
	{key = KEY_R, desc = "Закончить играть"},
}
SWEP.Category       = "Разрешено"

-- Primary fire settings
SWEP.Primary.Sound				= Sound("none")
SWEP.Primary.Damage				= -1
SWEP.Primary.NumShots			= -1
SWEP.Primary.Recoil				= 0
SWEP.Primary.Cone				= 16
SWEP.Primary.Delay				= 1
SWEP.Primary.ClipSize			= 999999999
SWEP.Primary.DefaultClip		= 999999999
SWEP.Primary.Tracer				= -1
SWEP.Primary.Force				= -1
SWEP.Primary.TakeAmmoPerBullet	= false
SWEP.Primary.Automatic			= false
SWEP.Primary.Ammo				= "none"
SWEP.IronSightsPos 		= Vector(0, 0, 0)
SWEP.IronSightsAng 		= Vector(0, 0, 0)

-- Secondary fire settings
SWEP.Secondary.Sound				= Sound("Guitar/guitar_6.mp3")
SWEP.Secondary.Damage				= 0
SWEP.Secondary.NumShots				= 1
SWEP.Secondary.Recoil				= 1
SWEP.Secondary.Cone					= 3
SWEP.Secondary.Delay				= 0.01
SWEP.Secondary.ClipSize				= 1
SWEP.Secondary.DefaultClip			= 1
SWEP.Secondary.Tracer				= 1
SWEP.Secondary.Force				= 0
SWEP.Secondary.TakeAmmoPerBullet	= false
SWEP.Secondary.Automatic			= false
SWEP.Secondary.Ammo					= "none"
SWEP.IronSightsPos 		= Vector(0, 0, 0)
SWEP.IronSightsAng 		= Vector(0, 0, 0)

SWEP.MusicDuration = {[1] = 29.1,
	[2] = 51.3,
	[3] = 46.2,
	[4] = 31.2,
	[5] = 71,
	[6] = 31.5,
	[7] = 32.6,
	[8] = 38.2,
	[9] = 32.1,
	[10] = 30.9,
	[11] = 40,
	[12] = 28.6,
	[13] = 49.3}

function SWEP:PrimaryAttack()
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
		local randomsounds = {
  	"weapons/Guitar/guitar_1.mp3",
  	"weapons/Guitar/guitar_2.mp3",
  	"weapons/Guitar/guitar_3.mp3",
   	"weapons/Guitar/guitar_4.mp3",
	"weapons/Guitar/guitar_5.mp3",
	"weapons/Guitar/guitar_6.mp3",
	"weapons/Guitar/guitar_7.mp3",
	"weapons/Guitar/guitar_8.mp3",
}
local random = math.random(1, #randomsounds)
self.Weapon:EmitSound(randomsounds[random])	
end

function SWEP:SecondaryAttack()
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	local randomsounds = {
   	"weapons/Guitar/guitar_9.mp3",
   	"weapons/Guitar/guitar_10.mp3",
	"weapons/Guitar/guitar_11.mp3",
	"weapons/Guitar/guitar_12.mp3",
	"weapons/Guitar/guitar_13.mp3",
	"weapons/Guitar/guitar_14.mp3",
	"weapons/Guitar/guitar_15.mp3",
	"weapons/Guitar/guitar_16.mp3",
}
local random = math.random(1, #randomsounds)
self.Weapon:EmitSound(randomsounds[random])
end

function SWEP:Think()
end

function SWEP:Reload()
	self.Weapon:EmitSound(Sound("common/NULL.wav"))
end

function SWEP:Deploy()
	return true
end

function SWEP:OnRestore()
end

function SWEP:Precache()
end

function SWEP:OwnerChanged()
end
--addons/weapon_cracker/lua/weapons/keypad_cracker.lua:
-- This is sorta horrible

AddCSLuaFile()

local keypad_crack_time = CreateConVar("keypad_crack_time", "30", {FCVAR_ARCHIVE}, "Seconds for keypad cracker to crack keypad")

if SERVER then
	util.AddNetworkString("KeypadCracker_Sparks")
end

if CLIENT then
	SWEP.PrintName = "Взломщик кейпадов"
	SWEP.Slot = 4
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = true
end

SWEP.Category = "Запрещено"
SWEP.Author = "Willox"
SWEP.Instructions = "ЛКМ для взлома"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Взломать кейпад"},
}
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/v_c4.mdl")
SWEP.WorldModel = Model("models/weapons/w_c4.mdl")

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AnimPrefix = "python"

SWEP.Sound = Sound("weapons/deagle/deagle-1.wav")

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.KeyCrackSound = Sound("buttons/blip2.wav")

SWEP.IdleStance = "slam"

function SWEP:Initialize()
	self:SetHoldType(self.IdleStance)
end	

function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "IsCracking" )
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.4)
	
	if self:GetIsCracking() or not IsValid(self:GetOwner()) then return end

	local tr = self:GetOwner():GetEyeTrace()
	local ent = tr.Entity

	if IsValid(ent) and tr.HitPos:DistToSqr(self:GetOwner():GetShootPos()) <= 2500 and ent.IsKeypad then
		self:SetIsCracking(true)
		self:SetHoldType("pistol")

		if SERVER then
			local timerId = "KeyCrackSounds: "..self:EntIndex()
			timer.Create(timerId, 1, 20, function()
				if IsValid(self) and self:GetIsCracking() then
					self:EmitSound(self.KeyCrackSound)
				end
			end)

			self:GetOwner():StartDelay('keypadcrack', 'Взлом кейпада', 20, function(s, ply)
				self:SetHoldType(self.IdleStance)
				self:SetIsCracking(false)

				ent:Process(true)

				net.Start("KeypadCracker_Sparks")
					net.WriteEntity(ent)
				net.Broadcast()
			end, function(s, ply)
				if not IsValid(self) then return false end
				if ply:GetActiveWeapon() ~= self then return false end
			end, function()
				timer.Remove(timerId)
				if IsValid(self) then
					self:Fail()
				end
			end, {
				targetEnt = ent,
				maxDistance = 50,
			})
		end
	end
end

function SWEP:SecondaryAttack()
    local own = self:GetOwner()
    if self:GetIsCracking() or not IsValid(own) then return end
    local trace = own:GetEyeTrace()
    local target = trace.Entity

    if IsValid(target) and trace.HitPos:DistToSqr(own:GetShootPos()) <= 2500 and target.IsKeypad and target:GetStatus() ~= target.STATUS_GRANTED and not self:GetIsCracking() then
    	if target.Attached then return end
        self:SetIsCracking(true)

        if SERVER then
            own:StripWeapon(self:GetClass())
            local pos = target:GetPos()
            local ang = target:GetAngles()
            local rotation = Vector(-90, math.Rand(150, 200), 0)
            ang:RotateAroundAxis(ang:Right(), rotation.x)
            ang:RotateAroundAxis(ang:Up(), rotation.y)
            ang:RotateAroundAxis(ang:Forward(), rotation.z)
            local ent = ents.Create('keypad_cracker_ent')
            ent:SetPos(pos + target:GetForward() * 0 + target:GetUp() * 6)
            ent:SetAngles(ang)
            ent:SetIsCracking(true)
            ent.KeyPad = target
            target.Attached = true
            ent:SetOwner(own)
            ent:Spawn()
        end
    end
    
    self:SetNextSecondaryFire(CurTime() + 1)
end


function SWEP:Holster()
	self:SetIsCracking(false)

	return true
end

function SWEP:Reload()
	return true
end

function SWEP:Succeed()
	self:SetIsCracking(false)
end

function SWEP:Fail()
	self:SetIsCracking(false)
	self:SetHoldType(self.IdleStance)
end

if (CLIENT) then
	SWEP.DownAngle = Angle(-10, 0, 0)
	
	SWEP.LowerPercent = 1
	SWEP.SwayScale = 0
	
	function SWEP:GetViewModelPosition(pos, ang)
		if self:GetIsCracking() then
			local delta = FrameTime() * 3.5
			self.LowerPercent = math.Clamp(self.LowerPercent - delta, 0, 1)
		else
			local delta = FrameTime() * 5
			self.LowerPercent = math.Clamp(self.LowerPercent + delta, 0, 1)
		end
		
		ang:RotateAroundAxis(ang:Forward(), self.DownAngle.p * self.LowerPercent)
		ang:RotateAroundAxis(ang:Right(), self.DownAngle.p * self.LowerPercent)

		return self.BaseClass.GetViewModelPosition(self, pos, ang)
	end

	net.Receive("KeypadCracker_Sparks", function()
		local ent = net.ReadEntity()

		if IsValid(ent) then
			local vPoint = ent:GetPos()
			local effect = EffectData()
			effect:SetStart(vPoint)
			effect:SetOrigin(vPoint)
			effect:SetEntity(ent)
			effect:SetScale(2)
			util.Effect("cball_bounce", effect)

			ent:EmitSound("buttons/combine_button7.wav", 100, 100)
		end
	end)
end
--addons/module_phone/lua/weapons/krede_wd_phone/cl_init.lua:
include('shared.lua')
SWEP.WepSelectIcon = surface.GetTextureID("vgui/hax/phone")
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
--addons/module_phone/lua/weapons/krede_wd_phone/shared.lua:
SWEP.PrintName = "Watch_Phone"
SWEP.Author =	"Krede"
SWEP.Contact =	"Steam"
SWEP.Purpose =	"Left-click to hack entities. Right click to perform a blackout."

SWEP.Spawnable =	true
SWEP.Adminspawnable =	true
SWEP.Category = "Запрещено"

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	true
SWEP.Primary.Ammo =	"none"

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"

nw.Register("CanHack")
	:Write(net.WriteUInt, 8)
	:Read(net.ReadUInt, 8)
	:SetPlayer()

function SWEP:SetupDataTables()
	self:NetworkVar("Int", 0, "Battery")
	self:NetworkVar("Int", 1, "CameraLength")
	self:NetworkVar("Bool", 0, "WCamera")
end

function SWEP:PrimaryAttack()
	if CLIENT then return false end

	if self:GetOwner():GetNetVar("CanHack") == 1 then return false end

	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.8 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.8 )

	timer.Simple(0.35, function()
		if self == NULL or !IsValid(self) then return false end
		self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK_1 )
		if self:GetOwner():GetViewEntity() != self:GetOwner() then
			local pos = self:GetOwner():GetViewEntity():GetPos()
			local ang = self:GetOwner():GetViewEntity():GetForward()
			local td = {}
			td.start = pos
			td.endpos = pos+(ang*2000)
			td.filter = self:GetOwner():GetViewEntity()
			trace = util.TraceLine(td)
			target = trace.Entity
		else
			local pos = self:GetOwner():GetShootPos()
			local ang = self:GetOwner():GetAimVector()
			local td = {}
			td.start = pos
			td.endpos = pos+(ang*2000)
			td.filter = self:GetOwner()
			trace = util.TraceLine(td)
			target = trace.Entity
		end
		if target == NULL or !IsValid(target) then
			for num,ent in pairs(ents.FindInSphere(trace.HitPos, 200)) do
				for class,tbl in pairs(Krede_WD_HaxList) do
					if ent:GetClass() == class and self:GetOwner():GetViewEntity() != ent or string.find(class, "*") and string.find(ent:GetClass(), string.gsub(class,"*","")) and ent != self:GetOwner():GetViewEntity() then
						if target == NULL or !IsValid(target) or trace.HitPos:Distance( ent:GetPos() ) < trace.HitPos:Distance( target:GetPos() ) then
							target = ent
						end
					end
				end
			end
			if target != NULL and IsValid(target) then
				for class,tbl in pairs(Krede_WD_HaxList) do
					if target:GetClass() == class and self:GetOwner():GetViewEntity() != target or string.find(class, "*") and string.find(target:GetClass(), string.gsub(class,"*","")) and target != self:GetOwner():GetViewEntity() then
						if self:GetBattery() < tbl.cost then return false end
						self:SetBattery(self:GetBattery() - tbl.cost)
						net.Start("WP_GlowingEnt")
							net.WriteEntity(target)
						net.Send( self:GetOwner() )
						timer.Simple(0.4, function()
							if self == NULL or !IsValid(self) then return false end
							if self:GetOwner() == NULL or !IsValid(self:GetOwner()) then return false end
							net.Start("WP_GlowingEnt")
								net.WriteEntity(NULL)
							net.Send( self:GetOwner() )
						end)
						tbl.use(target, self:GetOwner())
					end
				end
			end
			return false
		end
		for class,ent in pairs(Krede_WD_HaxList) do
			if target:GetClass() == class or string.find(class, "*") and string.find(target:GetClass(), string.gsub(class,"*","")) then
				if self:GetBattery() < ent.cost then return false end
				self:SetBattery(self:GetBattery() - ent.cost)
				net.Start("WP_GlowingEnt")
					net.WriteEntity(target)
				net.Send( self:GetOwner() )
				timer.Simple(0.4, function()
					if self == NULL or !IsValid(self) then return false end
					if self:GetOwner() == NULL or !IsValid(self:GetOwner()) then return false end
					net.Start("WP_GlowingEnt")
						net.WriteEntity(NULL)
					net.Send( self:GetOwner() )
				end)
				ent.use(target, self:GetOwner())
				return true
			end
		end
	end)
end


function SWEP:SecondaryAttack()
end

function SWEP:Deploy()
	if SERVER then
		self:SetCameraLength(0)
		if self:GetOwner():GetNetVar("CanHack") == 0 then
			self:GetOwner():SetNetVar("CanHack", 2)
		end
		self:SetWCamera(false)
		self:GetOwner():SetViewEntity( self:GetOwner() )
	end
	return true
end

function SWEP:Think()
	if self:GetBattery() < 6 then
		if self.ChargeTime < CurTime() then
			self.ChargeTime = CurTime() + 15
			self:SetBattery(self:GetBattery() + 1)
		end
	else
		self.ChargeTime = CurTime() + 15
	end
	
	if self:GetOwner():GetNetVar("CanHack") == 1 then return false end
	
	if self:GetWCamera() then
		if self:GetOwner():KeyDown( IN_SPEED ) then
			Speed = 0.5
		else
			Speed = 0.3
		end
		if self:GetOwner():KeyDown( IN_BACK ) then
			self:GetOwner():GetViewEntity():SetAngles( self:GetOwner():GetViewEntity():GetAngles() + Angle(Speed,0,0))
		elseif self:GetOwner():KeyDown( IN_FORWARD ) then
			self:GetOwner():GetViewEntity():SetAngles( self:GetOwner():GetViewEntity():GetAngles() + Angle(-Speed,0,0))
		elseif self:GetOwner():KeyDown( IN_MOVERIGHT ) then
			self:GetOwner():GetViewEntity():SetAngles( self:GetOwner():GetViewEntity():GetAngles() + Angle(0,-Speed,0))
		elseif self:GetOwner():KeyDown( IN_MOVELEFT ) then
			self:GetOwner():GetViewEntity():SetAngles( self:GetOwner():GetViewEntity():GetAngles() + Angle(0,Speed,0))
		end
	end
end

function SWEP:Reload()
	if self:GetWCamera() then
		self:SetWCamera(false)
		self:GetOwner():SetViewEntity( self:GetOwner() )
	end
end

function SWEP:DrawHUD()
	draw.RoundedBox(8, ScrW()/4, ScrH()-60, 142, 30, Color(0,0,0,150))
	for i = 1, self:GetBattery() do
		draw.RoundedBox(4, math.ceil(ScrW()/4+4)+math.ceil(i*22)-20, ScrH()-55, 20, 20, Color(255,255,255,255))
	end
end

SWEP.ViewModelFOV = 55
SWEP.HoldType = "slam"
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/v_buddyfinder.mdl"
SWEP.WorldModel = "models/nitro/iphone4.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.DrawCrosshair = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_MobilePhone"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["IPhone"] = { type = "Model", model = "models/nitro/iphone4.mdl", bone = "ValveBiped.Bip01_MobilePhone", rel = "", pos = Vector(1.728, 1.774, -1.912), angle = Angle(-2.198, -90.477, 180), size = Vector(1.11, 1.01, 1.11), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/nitro/haxphone", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["IPhone"] = { type = "Model", model = "models/nitro/iphone4.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.077, 2.717, -0.733), angle = Angle(-145.758, 21.754, -7.199), size = Vector(1.171, 1.171, 1.171), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/nitro/haxphone", skin = 0, bodygroup = {} }
}


function SWEP:Initialize()

	// other initialize code goes here
	
	self:SetWeaponHoldType( self.HoldType )
	self.ChargeTime = CurTime() + 15
	self:SetBattery(6)

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	if SERVER and self:GetOwner() then
		if self:GetWCamera() then
			self:SetWCamera(false)
			self:GetOwner():SetViewEntity( self:GetOwner() )
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self:GetOwner())) then
			bone_ent = self:GetOwner()
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--addons/weapon_laser/lua/weapons/laserjetpack/shared.lua:
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= false	
SWEP.UseHands		    = true

SWEP.PrintName = "Laser Gun"
SWEP.Category  = "Премиум"
SWEP.Author			= "Dark Moule/Team Garry"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= "Left click to fire"
SWEP.Controls = {
	{
		key = KEY_R,
		desc = function(wep)
			return wep:GetDmg() and "Выключить урон" or "Включить урон"
		end,
	},
}
SWEP.Category       = "Премиум"

SWEP.HoldType = "normal"


SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true

--local sndAttackLoop 	= Sound("")
--local sndPowerDown	= Sound("")

if CLIENT then     
	SWEP.ViewModelFOV = 60
	SWEP.ViewModelFlip = false
	SWEP.Slot = 3
    SWEP.SlotPos = 0
	SWEP.ViewModel = "models/weapons/c_taucannon_v2.mdl"
	SWEP.WorldModel = "models/weapons/w_gauss_mp.mdl"
	SWEP.ShowViewModel = true
	SWEP.ShowWorldModel = true
	SWEP.ViewModelBoneMods = {}

    SWEP.DrawAmmo            = false
    SWEP.DrawCrosshair        = true
    SWEP.CSMuzzleFlashes    = true
	
	SWEP.IconLetter = "."
	
end

SWEP.ViewModel = "models/weapons/c_taucannon_v2.mdl"
SWEP.WorldModel = "models/weapons/w_gauss_mp.mdl"

SWEP.Primary.Damage            = 100
SWEP.Primary.Force             = 1
SWEP.Primary.NumShots          = 0
SWEP.Primary.Delay             = 1
SWEP.Primary.Ammo              = "none"
SWEP.Primary.Spread 		   = 5

SWEP.Primary.ClipSize        = -1
SWEP.Primary.DefaultClip    = -1
SWEP.Primary.Automatic        = false

SWEP.Secondary.Sound        = Sound("")
SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.DamageC                = false

function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Dmg" )
	self:NetworkVar( "Float", 0, "Energy" )
	self:NetworkVar( "Int", 0, "NextReload" )

	if SERVER then
		self:SetDmg(false)
		self:SetEnergy(100)
		self:SetNextReload(0)
	end
end
function SWEP:Think()

	if (!self:GetOwner() || self:GetOwner() == NULL) then return end
	
	
	if ( self:GetOwner():KeyPressed( IN_ATTACK ) ) then
		self:StartAttack()
	elseif ( self:GetOwner():KeyDown( IN_ATTACK ) ) then

		self:UpdateAttack()
		
	elseif ( self:GetOwner():KeyReleased( IN_ATTACK ) ) then
	
		self:EndAttack( true )

	end

	if self:GetEnergy() < 100 then
		if ( self:GetOwner():KeyPressed( IN_ATTACK ) ) then return end
		if ( self:GetOwner():KeyDown( IN_ATTACK ) ) then return end
		self:SetEnergy(self:GetEnergy() + 0.7)
	end

end


function SWEP:StartAttack()

	if (SERVER) then
		
		if (!self.Beam) then
			self.Beam = ents.Create( "dark_egon_beam" )
				self.Beam:SetPos( self:GetOwner():GetShootPos() )
			self.Beam:Spawn()
		end

		if self:GetEnergy() < 1 then return end
		self.Beam:SetParent( self:GetOwner() )
		self.Beam:SetOwner( self:GetOwner() )
	
	end

	self:UpdateAttack()

end

function SWEP:UpdateAttack()
	
	if ( self.Timer && self.Timer > CurTime() ) then return end
	if self:GetEnergy() < 1 then return self:EndAttack( true ) end
	
	self.Timer = CurTime() + 0.05
	if not self:GetDmg() then
	    self:GetOwner():SetVelocity(self:GetOwner():GetForward() * -70 )
	end
	
	// We lag compensate here. This moves all the players back to the spots where they were
	// when this player fired the gun (a ping time ago).
	self:GetOwner():LagCompensation( true )
	
	local trace = {}
		trace.start = self:GetOwner():GetShootPos()
		trace.endpos = trace.start + (self:GetOwner():GetAimVector() * 4096)
		trace.filter = { self:GetOwner(), self.Weapon }
		
	local tr = util.TraceLine( trace )
	
	if (SERVER && self.Beam) then
		self.Beam:GetTable():SetEndPos( tr.HitPos )
	end
	if self:GetDmg() then
		util.BlastDamage( self.Weapon, self:GetOwner(), tr.HitPos, 80, 5 )
		self:SetEnergy(self:GetEnergy() - 0.7)
	else
		util.BlastDamage( self.Weapon, self:GetOwner(), tr.HitPos, 80, 0 )
		self:SetEnergy(self:GetEnergy() - 4)
	end

	if ( tr.Entity && tr.Entity:IsPlayer() ) then
	
		local effectdata = EffectData()
			effectdata:SetEntity( tr.Entity )
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "bodyshot", effectdata )
	
	end
	
	self:GetOwner():LagCompensation( false )
	
end

function SWEP:EndAttack( shutdownsound )
	
	--self.Weapon:StopSound( sndAttackLoop )
	
	--if ( shutdownsound ) then
	--	self.Weapon:EmitSound( sndPowerDown )
	--end
	
	if ( CLIENT ) then return end
	if ( !self.Beam ) then return end
	
	self.Beam:Remove()
	self.Beam = nil
	
end


function SWEP:PrimaryAttack()
	--self.Weapon:EmitSound( sndAttackLoop )
end

function SWEP:SecondaryAttack()
    self.Weapon:SendWeaponAnim(ACT_VM_FIDGET)
    self.Weapon:SetNextSecondaryFire( CurTime() + 4)
	self.Weapon:SetNextPrimaryFire( CurTime() + 4 )
end


function SWEP:Reload()
	if self:GetNextReload() > CurTime() then return end

	self:SetHoldType(self:GetDmg() and 'normal' or 'physgun')
	
	if CLIENT then return end
	
	if self:GetDmg() then
		self:SetDmg(false)
	else
		self:SetDmg(true)
	end
	self:SetNextReload(CurTime() + 1)				
end

function SWEP:Initialize()

	// other initialize code goes here

	self:SetHoldType(self.HoldType)

end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)
    return true
end

function SWEP:Holster()
	self:EndAttack( true )
	return true
end

function SWEP:OnRemove()
	self:Holster()
	self:EndAttack( true )
	return true
end

local mode = Material( "icon72/flying_saucer.png" )
local boom = Material('icon72/boom.png')
local fly = Material( "icon72/flying_saucer.png" )

function SWEP:DrawHUD()
    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Заряд", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		if self:GetDmg() then
			mode = boom
		else
		    mode = fly
		end
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( mode ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

if SERVER then
	hook.Add('GetFallDamage', 'lasergun', function(ply)
		local wep = ply:GetActiveWeapon()
		if IsValid(wep) and wep:GetClass() == 'laserjetpack' then return 0 end
	end)
end
--addons/_smallscripts/lua/weapons/moneychecker/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.PrintName = "Просмотр кошелька"
	SWEP.Slot = 1
	SWEP.SlotPos = 9
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Instructions = "ЛКМ для проверки кошелька"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Проверить кошелек"},
}

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix	 = "rpg"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
	return true
end

function SWEP:DrawWorldModel() end

function SWEP:PreDrawViewModel(vm)
	return true
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.4)

	self:GetOwner():LagCompensation(true)
	local trace = self:GetOwner():GetEyeTrace()
	self:GetOwner():LagCompensation(false)

	if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() or trace.Entity:GetPos():DistToSqr(self:GetOwner():GetPos()) > 10000 then
		return
	end

	self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)

	if CLIENT or not IsFirstTimePredicted() then return end

	local result = trace.Entity:GetNetVar("money")

	if result <= 100000 then
		DarkRP.notify(self:GetOwner(), 1, 5, "У него нету денег, побей его и отпусти. Убивать нельзя!")
	else
		DarkRP.notify(self:GetOwner(), 0, 5, "У "..trace.Entity:Nick().." "..DarkRP.formatMoney(result).." валюты")
	end
end

--addons/_smallscripts/lua/weapons/pickpocket.lua:
if CLIENT then
	SWEP.PrintName = "Карманная кража"
	SWEP.Instructions = "ЛКМ - начать кражу"
	SWEP.Controls = {
		{key = MOUSE_LEFT, desc = "Начать кражу"},
	}
	SWEP.Slot = 1
	SWEP.SlotPos = 9
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Author = "WayZer's Role Play"
SWEP.Category = "Запрещено"

SWEP.ViewModelFOV    = 62
SWEP.ViewModelFlip    = false

SWEP.ViewModel        = ""
SWEP.WorldModel        = "models/props_lab/bindergraylabel01b.mdl"

SWEP.HoldType = "normal"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.CheckTime = 10
SWEP.StealDetection = 5 
SWEP.MoneyToSteal = {5000, 50000} 
SWEP.StealTreshold = 30000

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

function SWEP:DrawWorldModel()
end

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	self:SetNextPrimaryFire(CurTime()+1)

	if self.IsStealing then return end

	local ent = self:GetOwner():GetEyeTrace().Entity
	if not IsValid(ent) or ent:GetPos():DistToSqr(self:GetOwner():GetShootPos()) > 10000 or not ent:IsPlayer() then return end

	self.IsStealing = true

	self:GetOwner():StartDelay('pickpocket', 'Кража', self.CheckTime, function(s, ply)
		self:Steal(ent)
	end, function(s, ply)
		if not IsValid(self) then return false end
		if ply:GetActiveWeapon() ~= self then return false end
		if not self.IsStealing then return false end
		if InSpawn(self:GetOwner()) or InSpawn(ent) then return false end
	end, function()
		if IsValid(self) then
			self.IsStealing = false
		end
	end, {
		targetEnt = ent,
	})
end

function SWEP:Holster()
    self.IsStealing = false
    return true
end

function SWEP:Steal(ply)
	self.IsStealing = false
	if not IsValid(ply) then return end

	local steal = math.random(self.MoneyToSteal[1], self.MoneyToSteal[2])
	if not ply:canAfford(steal) or not ply:canAfford(self.StealTreshold) or (ply.nextSteal and ply.nextSteal > CurTime()) then return DarkRP.notify(self:GetOwner(), 1, 5, 'Сжалься над бедолагой, у него совсем нет денег') end

	ply.nextSteal = CurTime() + 120

	ply:addMoney(-steal)
	self:GetOwner():addMoney(steal)

	DarkRP.notify(self:GetOwner(), 0, 5, 'Ты украл '..DarkRP.formatMoney(steal))

	timer.Simple(self.StealDetection, function()
		if IsValid(ply) then DarkRP.notify(ply, 1, 5, 'Кто-то украл у тебя '..DarkRP.formatMoney(steal)) end
	end)


	net.Start("anim_keys")
		net.WriteEntity(self:GetOwner())
		net.WriteString("usekeys")
	net.Broadcast()


	// WayPass

	hook.Call('PlayerStealMoney', nil, self:GetOwner(), steal, ply)
end
--addons/module_css2/lua/weapons/ptp_cs_deagle/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Desert Eagle"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.355, -2.747, 2.039)
	SWEP.AimAng = Vector(0.209, 0, 0)
	
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false
end

SWEP.FadeCrosshairOnAim = true

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 22.8

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_revolver_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_pist_deagle.mdl"
SWEP.WorldModel = "models/weapons/w_pist_deagle.mdl"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 7
SWEP.Primary.DefaultClip = 21
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.FireDelay = 0.3
SWEP.FireSound = Sound("Weapon_DEagle.Single")
SWEP.Recoil = 1.5
SWEP.DryFire = true

SWEP.HipSpread = 0.03
SWEP.AimSpread = 0.006
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 70
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_famas/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Famas-F1"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-2.681, -3.332, 1.44)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"3burst", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_rif_famas.mdl"
SWEP.WorldModel = "models/weapons/w_rif_famas.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 20
SWEP.Primary.DefaultClip = 60
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.0999
SWEP.FireSound = Sound("Weapon_FAMAS.Single")
SWEP.Recoil = 0.6

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.002
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 44
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 2
--addons/module_css2/lua/weapons/ptp_cs_galil/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "IMI Galil"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.358, -2.747, 2.473)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, -1, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 3
SWEP.PlayBackRateSV = 3
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author	= ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_rif_galil.mdl"
SWEP.WorldModel = "models/weapons/w_rif_galil.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 40
SWEP.Primary.DefaultClip = 120
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_Galil.Single")	
SWEP.Recoil = 0.85

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.0025
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 40
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_para/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M249 SAW"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.941, -6.378, 2.322)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_mach_m249para.mdl"
SWEP.WorldModel = "models/weapons/w_mach_m249para.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable	= true

SWEP.Primary.ClipSize = 100
SWEP.Primary.DefaultClip = 300
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_M249.Single")	
SWEP.Recoil = 1
SWEP.Chamberable = false

SWEP.HipSpread = 0.055
SWEP.AimSpread = 0.004
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 40
SWEP.DeployTime = 1
--addons/module_weed/lua/weapons/sent_tablet.lua:

AddCSLuaFile()

SWEP.PrintName				= "Планшет"
SWEP.Author					= "Gonzalolog"
SWEP.Purpose				= "Use it to get high"

SWEP.Slot					= 2
SWEP.SlotPos				= 1
SWEP.Category 				= "Drugs"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.ViewModel				= Model( "models/weapons/c_tablet_v2.mdl" )
SWEP.WorldModel				= Model( "models/weapons/w_tablet_v2.mdl" )
SWEP.ViewModelFOV			= 54
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= 0
SWEP.Primary.DefaultClip	= 0
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= 1
SWEP.Secondary.DefaultClip	= 1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

if SERVER then
	util.AddNetworkString("OpenTablet")
	resource.AddFile("models/weapons/c_tablet_v2.mdl")
	resource.AddFile("models/weapons/w_tablet_v2.mdl")
	resource.AddFile("materials/models/weapons/c_tablet/tablet_b.vmt")
end

function SWEP:Initialize()

	self:SetHoldType( "slam" )

end

SWEP.Offset = {
	Pos = {
		Up = -4,
		Right = -3,
		Forward = 1,
	},
	Ang = {
		Up = 0,
		Right = 5,
		Forward = 0,
	}
}


function SWEP:DrawWorldModel( )
	local hand, offset

	if not IsValid( self:GetOwner() ) then
		self:DrawModel( )
		return
	end

	if not self.Hand then
		self.Hand = self:GetOwner():LookupAttachment( "anim_attachment_rh" )
	end

	hand = self:GetOwner():GetAttachment( self.Hand )

	if not hand then
		self:DrawModel( )
		return
	end

	offset = hand.Ang:Right( ) * self.Offset.Pos.Right + hand.Ang:Forward( ) * self.Offset.Pos.Forward + hand.Ang:Up( ) * self.Offset.Pos.Up

	hand.Ang:RotateAroundAxis( hand.Ang:Right( ), self.Offset.Ang.Right )
	hand.Ang:RotateAroundAxis( hand.Ang:Forward( ), self.Offset.Ang.Forward )
	hand.Ang:RotateAroundAxis( hand.Ang:Up( ), self.Offset.Ang.Up )

	self:SetRenderOrigin( hand.Pos + offset )
	self:SetRenderAngles( hand.Ang )

	self:DrawModel( )
end

function SWEP:Deploy()
	self:SetSkin(2)
	self:SendWeaponAnim( ACT_VM_DRAW )
	timer.Simple(self:SequenceDuration(),function()
		if(IsValid(self)) then
			self:SetSkin(1)
			self:SendWeaponAnim( ACT_VM_IDLE )
		end
	end)
	return true
end

function SWEP:PrimaryAttack()
	if(CLIENT && IsFirstTimePredicted()) then
		if(WEED_PANEL != nil) then
			WEED_PANEL:Remove()
		end
		WEED_PANEL = vgui.Create("dWeeder")
	end
	return
end

function SWEP:SecondaryAttack()

	return

end

function SWEP:Holster(wep)
    return true
end

--addons/module_stungun/lua/weapons/stungun/config.lua:

--[[
Stungun SWEP Created by Donkie (http://steamcommunity.com/id/Donkie/)
For personal/server usage only, do not resell or distribute!
]]

--[[
GENERAL INFORMATION

Weaponclass: "stungun"
Ammotype: "ammo_stungun"
The stungun is only being tested on Sandbox, DarkRP (latest) and TTT (latest) before releases.
]]

--[[
CONFIG FILE
ONLY EDIT STUFF IN HERE
ANY EDITS OUTSIDE THIS FILE IS NOT MY RESPONSIBILITY
]]

--[[****************
BASIC SECTION
*****************]]

-- Ragdoll physics effect, replaces old "ShouldRoll"
-- Set to either 0, 1 or 2
-- 0: No effect
-- 1: Original comical rolling around
-- 2: Ragdoll shaking
STUNGUN.PhysEffect = 1

-- Can you un-taze people with rightclick?
STUNGUN.CanUntaze = false

-- Should it display in thirdperson view for the tazed player? (if false, firstperson)
STUNGUN.Thirdperson = true

-- If above is true, should users be able to press crouch button (default ctrl) to switch between third and firstperson?
STUNGUN.AllowSwitchFromToThirdperson = false

-- Should people be able to pick a tazed player using physgun?
STUNGUN.AllowPhysgun = false

-- Should people be able to use toolgun on tazed players?
STUNGUN.AllowToolgun = false

-- Should tazed players take falldamage? (Warning: experimental, not recommended to have if players can pick them up using physgun.)
STUNGUN.Falldamage = true

-- How much damage the tazer also does
-- Set to 0 to disable
STUNGUN.StunDamage = 3

-- Should it display name and HP on tazed players?
STUNGUN.ShowPlayerInfo = true

-- Can the player be damaged while he's tazed?
STUNGUN.AllowDamage = true

-- Can the player suicide while he's paralyzed?
STUNGUN.ParalyzeAllowSuicide = false

-- Can the player suicide while he's mute?
STUNGUN.MuteAllowSuicide = false

-- Amount of seconds the player is immune to stuns after he just got up from being paralyzed. -1 to disable.
STUNGUN.Immunity = -1

-- Can people of same team stungun each other? Check further below (in the advanced section) for the check-function.
-- The check function is by default set to ignore police trying to taze police.
STUNGUN.AllowFriendlyFire = true

-- If the ragdoll version of the playermodel does not spawn correctly (incorrectly made model) then the ragdoll will be this model.
-- When done rolling around the player will get back his default model.
-- Set this to "nil" (without quotes) if you want to disable this default model and just make it not work.
STUNGUN.DefaultModel = Model("models/player/group01/male_01.mdl")

-- Thirdperson holdtype. Put "revolver" to make him carry the gun in 2 hands, put "pistol" to make him one-hand the gun.
SWEP.HoldType = "revolver"

-- Default charge for the weapon, when the guy picks the gun up, should it be filled already or wait to be filled? 100 is max charge, 0 is uncharged.
SWEP.Charge = 100

-- Should we have infinite ammo (true) or finite ammo (false)?
-- Finite ammo makes it spawn with 1 charge, unless you're running TTT in which you can specify how much ammo it should start with down below.
SWEP.InfiniteAmmo = true

-- Recharge rate. How many seconds it takes to fill the gun back up.
SWEP.RechargeTime = 4

-- How long range the weapon has. Players beyond this range won't get hit.
-- To put in perspective, in darkrp, the above-head-playerinfo has a default range of 400.
SWEP.Range = 500

--[[
There's two seperate times for this. This is so the player has a chance to escape but the robbers still have a chance to re-taze him.
Put the paralyzetime and mutetime at same to make the player able to talk exactly when he's able to get up.
Put the mutetime slightly higher than paralyze time to make him wait a few seconds before he's able to talk after he got up.
]]

-- How many seconds the player is rolling around as a ragdoll.
STUNGUN.ParalyzedTime = 10

-- How many seconds the player is mute/gagged = Unable to speak/chat.
STUNGUN.MuteTime = 12

-- How many seconds after the player has been unragdolled that he still won't be able to move.
STUNGUN.FreezeTime = 3

-- What teams are immune to the stungun? (if any).
local immuneteams = {
	TEAM_MAYOR,
	TEAM_CHIEF
}

--[[****************
ADVANCED SECTION
Contact me if you need help with any function.
*****************]]
-- If you've found that specific models appear to break it, add them here and they will turn into the default model instead.
STUNGUN.BrokenModels = {
	["models/test/model.mdl"] = true
}

--[[
Hurt sounds
]]
local combinemodels = {["models/player/police.mdl"] = true, ["models/player/police_fem.mdl"] = true}
local females = {
	["models/player/alyx.mdl"] = true,["models/player/p2_chell.mdl"] = true,
	["models/player/mossman.mdl"] = true,["models/player/mossman_arctic.mdl"] = true}
function STUNGUN.PlayHurtSound( ply )
	local mdl = ply:GetModel()

	-- Combine
	if combinemodels[mdl] or string.find(mdl, "combine") then
		return "npc/combine_soldier/pain" .. math.random(1,3) .. ".wav"
	end

	-- Female
	if females[mdl] or string.find(mdl, "female") then
		return "vo/npc/female01/pain0" .. math.random(1,9) .. ".wav"
	end

	-- Male
	return "vo/npc/male01/pain0" .. math.random(1,9) .. ".wav"
end

--[[
Custom same-team function.
]]
function STUNGUN.SameTeam(ply1, ply2)
	if STUNGUN.IsDarkRP then
		if STUNGUN.IsDarkRP25 then
			if ply1:isCP() and ply2:isCP() then return true end
		else
			if ply1:IsCP() and ply2:IsCP() then return true end
		end
	end

	-- return (ply1:Team() == ply2:Team()) -- Probably dont want this in DarkRP, nor TTT, but maybe your custom TDM gamemode.
end

--[[
Custom Immunity function.
]]
function STUNGUN.IsPlayerImmune(ply)
	if type(immuneteams) == "table" and table.HasValue(immuneteams, ply:Team()) then return true end
	return false
end


--[[****************
DarkRP Specific stuff
Only care about these if you're running it on a DarkRP server.
*****************]]

-- Should the stungun charges be buyable in the f4 store?
-- If yes, put in a number above 0 as price, if no, put -1 to disable.
STUNGUN.AddAmmoItem = 50

-- Should it be allowed to use the arrest baton on stunned people?
STUNGUN.AllowArrestOnRag = false

-- Should it be allowed to use the unarrest baton on stunned people?
STUNGUN.AllowUnArrestOnRag = true

--[[****************
TTT Specific stuff
Only care about these if you're running it on a TTT server.
*****************]]

-- Can stunned players be picked up by magnetostick?
STUNGUN.CanPickup = false

-- Default ammo.
SWEP.Ammo = 3

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP1

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = { ROLE_DETECTIVE }

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

--addons/weapon_shield/lua/weapons/swat_shield/cl_init.lua:
include('shared.lua')

function SWEP:DrawWorldModel()
	self:SetNoDraw(true) 
end
--addons/module_css2/lua/weapons/swb_base/shared.lua:


AddCSLuaFile()
AddCSLuaFile("sh_bullets.lua")
AddCSLuaFile("cl_model.lua")
AddCSLuaFile("cl_hud.lua")
AddCSLuaFile("cl_calcview.lua")
AddCSLuaFile("sh_ammotypes.lua")
AddCSLuaFile("sh_move.lua")
AddCSLuaFile("sh_sounds.lua")
AddCSLuaFile("cl_playerbindpress.lua")

include("sh_bullets.lua")
include("sh_ammotypes.lua")
include("sh_move.lua")
include("sh_sounds.lua")

game.AddParticles("particles/swb_muzzle.pcf")

PrecacheParticleSystem("swb_pistol_large")
PrecacheParticleSystem("swb_pistol_med")
PrecacheParticleSystem("swb_pistol_small")
PrecacheParticleSystem("swb_rifle_large")
PrecacheParticleSystem("swb_pistol_large")
PrecacheParticleSystem("swb_rifle_small")
PrecacheParticleSystem("swb_shotgun")
PrecacheParticleSystem("swb_silenced")
PrecacheParticleSystem("swb_silenced_small")
PrecacheParticleSystem("swb_sniper")

if CLIENT then
	include("cl_calcview.lua")
	include("cl_playerbindpress.lua")
	include("cl_model.lua")
	include("cl_hud.lua")
	
	SWEP.DrawCrosshair = false
	SWEP.BounceWeaponIcon = false
	SWEP.DrawWeaponInfoBox = false
	SWEP.CurFOVMod = 0
	SWEP.BobScale = 0
	SWEP.SwayScale = 0
	SWEP.ZoomAmount = 15
	SWEP.FadeCrosshairOnAim = true
	SWEP.DrawAmmo = true
	SWEP.DrawTraditionalWorldModel = true
	SWEP.CrosshairEnabled = true
	SWEP.ViewbobEnabled = true
	SWEP.ViewbobIntensity = 1
	SWEP.ReloadViewBobEnabled = true
	SWEP.RVBPitchMod = 1
	SWEP.RVBYawMod = 1
	SWEP.RVBRollMod = 1
	SWEP.BulletDisplay = 0
	SWEP.Shell = "mainshell"
	SWEP.ShellScale = 1
	SWEP.ZoomAmount = 15
	SWEP.CSMuzzleFlashes  = true
	SWEP.ZoomWait = 0
	SWEP.CrosshairParts = {left = false, right = false, upper = false, lower = false}
	SWEP.FireModeDisplayPos = "middle"
	SWEP.SwimPos = Vector(0, 0, -2.461)
	SWEP.SwimAng = Vector(-26.57, 0, 0)
end

SWEP.FadeCrosshairOnAim = true

if SERVER then
	include("sv_hooks.lua")
	SWEP.PlayBackRateSV = 1
end

SWEP.AimMobilitySpreadMod = 0.5
SWEP.PenMod = 1
SWEP.AmmoPerShot = 1
SWEP.SWBWeapon = true
SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 50
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= ""
SWEP.WorldModel		= ""
SWEP.AnimPrefix		= "fist"

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.Primary.ClipSize		= -1					// Size of a clip
SWEP.Primary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Primary.Automatic		= false				// Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1				// Size of a clip
SWEP.Secondary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Secondary.Automatic	= true				// Automatic/Semi Auto
SWEP.Secondary.Ammo			= "none"

SWEP.AddSpread = 0
SWEP.SpreadWait = 0
SWEP.AddSpreadSpeed = 1
SWEP.ReloadWait = 1
SWEP.PlayBackRateHip = 1
SWEP.PlayBackRate = 1
SWEP.ReloadSpeed = 1

SWEP.Chamberable = true
SWEP.UseHands = true
SWEP.CanPenetrate = false
SWEP.CanRicochet = false
SWEP.AddSafeMode = true
SWEP.Suppressable = false
SWEP.SprintingEnabled = true
SWEP.HolsterUnderwater = true
SWEP.HolsterOnLadder = true

SWEP.BurstCooldownMul = 1.75
SWEP.BurstSpreadIncMul = 0.5
SWEP.BurstRecoilMul = 0.85
SWEP.DeployTime = 1
SWEP.Shots = 1
SWEP.FromActionToNormalWait = 0
SWEP.ShotgunReloadState = 0

SWB_IDLE = 0
SWB_RUNNING = 1
SWB_AIMING = 2
SWB_ACTION = 3

SWEP.FireModeNames = {["auto"] = {display = "Автоматический режим", auto = true, burstamt = 0, buldis = 5},
	["semi"] = {display = "Полу-автоматический режим", auto = false, burstamt = 0, buldis = 1},
	["double"] = {display = "Режим дуплета", auto = false, burstamt = 0, buldis = 1},
	["bolt"] = {display = "Одиночный", auto = false, burstamt = 0, buldis = 1},
	["pump"] = {display = "Помповый", auto = false, burstamt = 0, buldis = 1},
	["break"] = {display = "ПРЕРЫВНОЕ", auto = false, burstamt = 0, buldis = 1},
	["2burst"] = {display = "2-й выстрел", auto = true, burstamt = 2, buldis = 2},
	["3burst"] = {display = "3-й выстрел", auto = true, burstamt = 3, buldis = 3},
	["safe"] = {display = "Предохранитель", auto = false, burstamt = 0, buldis = 0}}

local math = math

function SWEP:IsEquipment() -- I have no idea what I'm doing, help
	return WEPS.IsEquipment(self)
end

function SWEP:CalculateEffectiveRange()
	self.EffectiveRange = self.CaseLength * 10 - self.BulletDiameter * 5 -- setup realistic base effective range
	self.EffectiveRange = self.EffectiveRange * 39.37 -- convert meters to units
	self.EffectiveRange = self.EffectiveRange * 0.25
	self.DamageFallOff = (100 - (self.CaseLength - self.BulletDiameter)) / 200
	self.PenStr = (self.BulletDiameter * 0.5 + self.CaseLength * 0.35) * (self.PenAdd and self.PenAdd or 1)
	self.PenetrativeRange = self.EffectiveRange * 0.5
end

local tbl, tbl2

function SWEP:Initialize()
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS_TRIGGER)
	self:SetHoldType(self.NormalHoldType)
	self:CalculateEffectiveRange()
	self.CHoldType = self.NormalHoldType
	
	if self.AddSafeMode then
		table.insert(self.FireModes, #self.FireModes + 1, "safe")
	end
	
	t = self.FireModes[1]
	self.FireMode = t
	t = self.FireModeNames[t]
	
	self.Primary.Auto = t.auto
	self.BurstAmount = t.burstamt
	
	self.CurCone = self.HipSpread
	self.Primary.ClipSize_Orig = self.Primary.ClipSize
	
	if CLIENT then
		self.ViewModelFOV_Orig = self.ViewModelFOV
		self.BulletDisplay = t.buldis
		self.FireModeDisplay = t.display
		
		if self.WM then
			self.WMEnt = ClientsideModel(self.WM, RENDERGROUP_BOTH)
			self.WMEnt:SetNoDraw(true)
		end
	end
end

function SWEP:SetupDataTables()
	self:NetworkVar("Int", 0, "State")
	self:NetworkVar("Int", 1, "Shots")
	self:NetworkVar("Bool", 0, "Suppressed")
	self:NetworkVar("Bool", 1, "Safe")
end

local vm, CT, aim, cone, vel, CT, tr
local td = {}

function SWEP:Deploy()
	if self.dt.Suppressed then
		self:SendWeaponAnim(ACT_VM_DRAW_SILENCED)
	else
		self:SendWeaponAnim(ACT_VM_DRAW)
	end
			
	self.dt.State = SWB_IDLE
	CT = CurTime()
	
	self:SetNextSecondaryFire(CT + self.DeployTime)
	self:SetNextPrimaryFire(CT + self.DeployTime)
	return true
end

function SWEP:Holster()
	--[[
	if self.ReloadDelay then
		return false
	end
	]]
	
	self.ShotgunReloadState = 0
	self.ReloadDelay = nil
	self.dt.State = SWB_IDLE
	return true
end

local mag

local reload_male = {
	Sound("vo/npc/male01/youdbetterreload01.wav"),
	Sound("vo/npc/male01/coverwhilereload01.wav"),
	Sound("vo/npc/male01/coverwhilereload02.wav"),
	Sound("vo/npc/male01/gottareload01.wav"),
}
local reload_female = {
	Sound("vo/npc/female01/youdbetterreload01.wav"),
	Sound("vo/npc/Alyx/youreload01.wav"),
	Sound("vo/npc/Alyx/youreload02.wav"),
}

function SWEP:Reload()
	CT = CurTime()
--[[
	if	SERVER
		and
		(self:Clip1() + self:GetOwner():GetAmmoCount(self.Primary.Ammo)) < self:GetMaxClip1()
		and
		fn.Head(fn.Filter(function(x) return x.ammoType == self.Primary.Ammo end, GAMEMODE.AmmoTypes))
	then
		DarkRP.chatCommands.buyammo.callback(self:GetOwner(), self.Primary.Ammo)
	end
--]]	
	if self.ReloadDelay or CT < self.ReloadWait or self.dt.State == SWB_ACTION or self.ShotgunReloadState != 0 then
		return
	end
	
	if self:GetOwner():KeyDown(IN_USE) and self.dt.State != SWB_RUNNING then
		self:CycleFiremodes()
		return
	end
	
	mag = self:Clip1()
	
	if (self.Chamberable and mag >= self.Primary.ClipSize + 1) or (not self.Chamberable and mag >= self.Primary.ClipSize) or self:GetOwner():GetAmmoCount(self.Primary.Ammo) == 0 then
		return
	end
	
	if self.dt.State != SWB_RUNNING then
		self.dt.State = SWB_IDLE
	end
	
	if self.ShotgunReload then
		self.ShotgunReloadState = 1
		self:SendWeaponAnim(ACT_SHOTGUN_RELOAD_START)
		self.ReloadDelay = CT + self.ReloadStartWait
	else
		if self.Chamberable then
			if mag == 0 then
				self.Primary.ClipSize = self.Primary.ClipSize_Orig
			else
				self.Primary.ClipSize = self.Primary.ClipSize_Orig + 1
			end
		end
		
		if self.dt.Suppressed then
			self:DefaultReload(ACT_VM_RELOAD_SILENCED)
		else
			self:DefaultReload(ACT_VM_RELOAD)
		end
		
	end
	if SERVER then
		if self:Clip1() < self.Primary.ClipSize then
			if self:GetOwner():IsPlayer() then
				self:GetOwner():SetAnimation(PLAYER_RELOAD)
			else 
				self:GetOwner():SetAnimation(PLAYER_RELOAD)
			end
		end
	end
	--[[self:SendWeaponAnim(ACT_VM_RELOAD)
	
	vm = self:GetOwner():GetViewModel() 
	vm:SetPlaybackRate(self.ReloadSpeed)
	dur = vm:SequenceDuration() / self.ReloadSpeed
	
	self.ReloadDelay = CT + dur]]--
	--self:SetNextPrimaryFire(CT + dur)
	--self:SetNextSecondaryFire(CT + dur)
end

function SWEP:CycleFiremodes()
	t = self.FireModes
	
	if not t.last then
		t.last = 2
	else
		if not t[t.last + 1] then
			t.last = 1
		else
			t.last = t.last + 1
		end
	end
	
	if self.dt.State == SWB_AIMING then
		if self.FireModes[t.last] == "safe" then
			t.last = 1
		end
	end
	
	if self.FireMode != self.FireModes[t.last] and self.FireModes[t.last] then
		CT = CurTime()
		self:SelectFiremode(self.FireModes[t.last])
		self:SetNextPrimaryFire(CT + 0.25)
		self:SetNextSecondaryFire(CT + 0.25)
		self.ReloadWait = CT + 0.25
	end
end
if SERVER then 
	util.AddNetworkString("SWB_FIREMODE")
end
function SWEP:SelectFiremode(n)
	if CLIENT then
		return
	end
		t = self.FireModeNames[n]
		self.Primary.Automatic = t.auto
		self.FireMode = n
		self.BurstAmount = t.burstamt
		
		if self.FireMode == "safe" then
			self.dt.Safe = true -- more reliable than umsgs
		else
			self.dt.Safe = false
		end
	if SERVER then
		net.Start("SWB_FIREMODE")
			net.WriteEntity(self:GetOwner())
			net.WriteString(n)
		net.Broadcast()
	end
end

local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local GetAimVector = reg.Player.GetAimVector

function SWEP:CalculateSpread(vel)
	aim = GetAimVector(self:GetOwner())
	CT = CurTime()
	
	if not self:GetOwner().LastView then
		self:GetOwner().LastView = aim
		self:GetOwner().ViewAff = 0
	else
		self:GetOwner().ViewAff = Lerp(0.25, self:GetOwner().ViewAff, (aim - self:GetOwner().LastView):Length() * 0.5)
		self:GetOwner().LastView = aim
	end
	
	if self.dt.State == SWB_AIMING then
		self.BaseCone = self.AimSpread
		
		if self:GetOwner().Expertise then
			self.BaseCone = self.BaseCone * (1 - self:GetOwner().Expertise["steadyaim"].val * 0.0015)
		end
	else
		self.BaseCone = self.HipSpread
		
		if self:GetOwner().Expertise then
			self.BaseCone = self.BaseCone * (1 - self:GetOwner().Expertise["wepprof"].val * 0.0015)
		end
	end
	
	if self:GetOwner():Crouching() then
		self.BaseCone = self.BaseCone * (self.dt.State == SWB_AIMING and 0.9 or 0.75)
	end
	
	self.CurCone = math.Clamp(self.BaseCone + self.AddSpread + (vel / 10000 * self.VelocitySensitivity) * (self.dt.State == SWB_AIMING and self.AimMobilitySpreadMod or 1) + self:GetOwner().ViewAff, 0, 0.09 + self.MaxSpreadInc)
	
	if CT > self.SpreadWait then
		self.AddSpread = math.Clamp(self.AddSpread - 0.005 * self.AddSpreadSpeed, 0, self.MaxSpreadInc)
		self.AddSpreadSpeed = math.Clamp(self.AddSpreadSpeed + 0.05, 0, 1)
	end
end

local SP = game.SinglePlayer()

local mag, ammo

function SWEP:IndividualThink()
	if (SP and SERVER) or not SP then
		if self.dt.State == SWB_AIMING then
			if not self:GetOwner():OnGround() or Length(GetVelocity(self:GetOwner())) >= self:GetOwner():GetWalkSpeed() * 1.35 or not self:GetOwner():KeyDown(IN_ATTACK2)  then
				CT = CurTime()
				self.dt.State = SWB_IDLE
				self:SetNextSecondaryFire(CT + 0.2)
			end
		end
	end
end

local IFTP
local wl, ws

function SWEP:Think()
	if self.IndividualThink then
		self:IndividualThink()
	end

	if (not IsValid(self:GetOwner())) then return end
	
	vel = Length(GetVelocity(self:GetOwner()))
	IFTP = IsFirstTimePredicted()
	
	if (not SP and IFTP) or SP then
		self:CalculateSpread(vel)
	end
	
	CT = CurTime()
	wl = self:GetOwner():WaterLevel()

	if self:GetOwner():OnGround() then
		if wl >= 3 and self.HolsterUnderwater then
			if self.ShotgunReloadState == 1 then
				self.ShotgunReloadState = 2
			end
			
			self.dt.State = SWB_ACTION
			self.FromActionToNormalWait = CT + 0.3
		else
			ws = self:GetOwner():GetWalkSpeed()
			
			if ((vel > ws * 1.2 and self:GetOwner():KeyDown(IN_SPEED)) or vel > ws * 3 or (self.ForceRunStateVelocity and vel > self.ForceRunStateVelocity)) and self.SprintingEnabled and !self:GetOwner():GetNW2Bool("donate_upgrade_runngun",false) then
				self.dt.State = SWB_RUNNING
			else
				if self.dt.State != SWB_AIMING then
					if CT > self.FromActionToNormalWait then
						if self.dt.State != SWB_IDLE then
							self.dt.State = SWB_IDLE
							self:SetNextPrimaryFire(CT + 0.3)
							self:SetNextSecondaryFire(CT + 0.3)
							self.ReloadWait = CT + 0.3
						end
					end
				end
			end
		end
	else
		if (wl > 1 and self.HolsterUnderwater) or (self:GetOwner():GetMoveType() == MOVETYPE_LADDER and self.HolsterOnLadder) then
			if self.ShotgunReloadState == 1 then
				self.ShotgunReloadState = 2
			end
			
			self.dt.State = SWB_ACTION
			self.FromActionToNormalWait = CT + 0.3
		else
			if CT > self.FromActionToNormalWait then
				if self.dt.State != SWB_IDLE then
					self.dt.State = SWB_IDLE
					self:SetNextPrimaryFire(CT + 0.3)
					self:SetNextSecondaryFire(CT + 0.3)
					self.ReloadWait = CT + 0.3
				end
			end
		end
	end
	
	if self.dt.Shots > 0 then
		if not self:GetOwner():KeyDown(IN_ATTACK) then
			if self.BurstAmount and self.BurstAmount > 0 then
				self.dt.Shots = 0
				self:SetNextPrimaryFire(CT + self.FireDelay * self.BurstCooldownMul)
				self.ReloadWait = CT + self.FireDelay * self.BurstCooldownMul
			end
		end
	end
	
	if IFTP then
		if self.ShotgunReloadState == 1 then
			if self:GetOwner():KeyPressed(IN_ATTACK) then
				self.ShotgunReloadState = 2
			end
			
			if CT > self.ReloadDelay then
				self:SendWeaponAnim(ACT_VM_RELOAD)
				
				if SERVER then
					self:GetOwner():SetAnimation(PLAYER_RELOAD)
				end
				
				mag, ammo = self:Clip1(), self:GetOwner():GetAmmoCount(self.Primary.Ammo)
				
				if SERVER then
					self:SetClip1(mag + 1)
					self:GetOwner():SetAmmo(ammo - 1, self.Primary.Ammo)
				end
				
				self.ReloadDelay = CT + self.ReloadShellInsertWait
				
				if mag + 1 == self.Primary.ClipSize or ammo - 1 == 0 then
					self.ShotgunReloadState = 2
				end
			end
		elseif self.ShotgunReloadState == 2 then
			if CT > self.ReloadDelay then
				self:SendWeaponAnim(ACT_SHOTGUN_RELOAD_FINISH)
				self.ShotgunReloadState = 0
				self:SetNextPrimaryFire(CT + self.ReloadFinishWait)
				self:SetNextSecondaryFire(CT + self.ReloadFinishWait)
				self.ReloadWait = CT + self.ReloadFinishWait
				self.ReloadDelay = nil
			end
		end
	end
	
	if SERVER then
		if self.dt.Safe then
			if self.CHoldType != self.RunHoldType then
				self:SetHoldType(self.RunHoldType)
				self.CHoldType = self.RunHoldType
			end
		else
			if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION then
				if self.CHoldType != self.RunHoldType then
					self:SetHoldType(self.RunHoldType)
					self.CHoldType = self.RunHoldType
				end
			else
				if self.CHoldType != self.NormalHoldType then
					self:SetHoldType(self.NormalHoldType)
					self.CHoldType = self.NormalHoldType
				end
			end
		end
	end
	
	if self.CustomThink then
        self:CustomThink()
    end

	--[[if self.ReloadDelay and CT >= self.ReloadDelay then
		mag, ammo = self:Clip1(), self:GetOwner():GetAmmoCount(self.Primary.Ammo)
		
		if self.ReloadAmount then
			if SERVER then
				self:SetClip1(math.Clamp(mag + self.ReloadAmount, 0, self.Primary.ClipSize))
				self:GetOwner():RemoveAmmo(self.ReloadAmount, self.Primary.Ammo)
			end
		else
			if mag > 0 then
				if ammo >= self.Primary.ClipSize - mag then
					if SERVER then
						self:SetClip1(math.Clamp(self.Primary.ClipSize, 0, self.Primary.ClipSize))
						self:GetOwner():RemoveAmmo(self.Primary.ClipSize - mag, self.Primary.Ammo)
					end
				else
					if SERVER then
						self:SetClip1(math.Clamp(mag + ammo, 0, self.Primary.ClipSize))
						self:GetOwner():RemoveAmmo(ammo, self.Primary.Ammo)
					end
				end
			else
				if ammo >= self.Primary.ClipSize then
					if SERVER then
						self:SetClip1(math.Clamp(self.Primary.ClipSize, 0, self.Primary.ClipSize))
						self:GetOwner():RemoveAmmo(self.Primary.ClipSize, self.Primary.Ammo)
					end
				else
					if SERVER then
						self:SetClip1(math.Clamp(ammo, 0, self.Primary.ClipSize))
						self:GetOwner():RemoveAmmo(ammo, self.Primary.Ammo)
					end
				end
			end
		end
		
		self.ReloadDelay = nil
	end]]--
end

local mul

function SWEP:PrimaryAttack()
	if self.ShotgunReloadState != 0 then
		return
	end
	
	if self.ReloadDelay then
		return
	end
	
	if self.dt.Safe then
		self:CycleFiremodes()
		return
	end
	
	mag = self:Clip1()
	
	if mag == 0 then
		self:EmitSound("SWB_Empty", 100, 100)
		self:SetNextPrimaryFire(CT + 0.25)
		return
	end
	
	if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION then
		return
	end
	
	if self.BurstAmount and self.BurstAmount > 0 then
		if self.dt.Shots >= self.BurstAmount then
			return
		end
		
		self.dt.Shots = self.dt.Shots + 1
	end
	
	
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	CT = CurTime()
	
	if self.dt.Suppressed then
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED)
	else
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	end
	
	if self.FireAnimFunc then
		self:FireAnimFunc()
	else
		if self.dt.State == SWB_AIMING then
			if mag - self.AmmoPerShot <= 0 and self.DryFire then
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_DRYFIRE_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_DRYFIRE)
				end
			else
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
				end
			end
			
			if self.FadeCrosshairOnAim then
				if SP then
					if SERVER then
						self:GetOwner():GetViewModel():SetPlaybackRate(self.PlayBackRate or 1)
					end
				else
					if SERVER then
						self:GetOwner():GetViewModel():SetPlaybackRate(self.PlayBackRateSV or 1)
					else
						self:GetOwner():GetViewModel():SetPlaybackRate(self.PlayBackRate or 1)
					end
				end
			end
		else
			if mag - self.AmmoPerShot <= 0 and self.DryFire then
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_DRYFIRE_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_DRYFIRE)
				end
			else
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
				end
			end
			
			if self.FadeCrosshairOnAim then
				self:GetOwner():GetViewModel():SetPlaybackRate(self.PlayBackRateHip or 1)
			end
		end
	end
	
	if IsFirstTimePredicted() then
		if self.CustomFire then
			self:CustomFire()
		else
			if self.dt.Suppressed then
				self:EmitSound(self.FireSoundSuppressed, 105, 100)
			else
				self:EmitSound(self.FireSound, 105, 100)
			end
			
			self:FireBullet(self.Damage * (self.dt.Suppressed and 0.9 or 1), self.CurCone, self.Shots)
			self:MakeRecoil()
			
			self.SpreadWait = CT + self.SpreadCooldown
			mul = 1
		
			if self:GetOwner():Crouching() then
				mul = mul * 0.75
			end
			
			if self:GetOwner().Expertise then
				mul = mul * (1 - self:GetOwner().Expertise["wepprof"].val * 0.002)
				
				if SERVER then
					if self.dt.State == SWB_AIMING then
						self:GetOwner():ProgressStat("steadyaim", self.Recoil * 1.5)
						self:GetOwner():ProgressStat("wepprof", self.Recoil * 0.5)
					else
						self:GetOwner():ProgressStat("wepprof", self.Recoil * 1.5)
					end
					
					self:GetOwner():ProgressStat("rechandle", self.Recoil)
				end
			end
			
			if self.BurstAmount > 0 then
				self.AddSpread = math.Clamp(self.AddSpread + self.SpreadPerShot * self.BurstSpreadIncMul * mul, 0, self.MaxSpreadInc)
			else
				self.AddSpread = math.Clamp(self.AddSpread + self.SpreadPerShot * mul, 0, self.MaxSpreadInc)
			end
			
			self.AddSpreadSpeed = math.Clamp(self.AddSpreadSpeed - 0.2, 0, 1)
			
			if CLIENT then
				if self.dt.State == SWB_AIMING then
					self.FireMove = 1
				else
					self.FireMove = 0.4
				end
			end
			
			if SP and SERVER then
				//SendUserMessage("SWB_Recoil", self:GetOwner())
			end
		end
	end
	
	self:TakePrimaryAmmo(self.AmmoPerShot)
	self:SetNextPrimaryFire(CT + self.FireDelay)
	self:SetNextSecondaryFire(CT + self.FireDelay)
	self.ReloadWait = CT + (self.WaitForReloadAfterFiring and self.WaitForReloadAfterFiring or self.FireDelay)
end

local ang

function SWEP:MakeRecoil(mod)
	mod = mod and mod or 1
	
	if self:GetOwner():Crouching() then
		mod = mod * 0.75
	end
	
	if self.dt.State == SWB_AIMING then
		mod = mod * 0.85
	end
	
	if self.dt.Suppressed then
		mod = mod * 0.85
	end
	
	if self.BurstAmount > 0 then
		mod = mod * self.BurstRecoilMul
	end
	
	if self:GetOwner().Expertise then
		mod = mod * (1 - self:GetOwner().Expertise["rechandle"].val * 0.0015)
	end
	
	if (SP and SERVER) or (not SP and CLIENT) then
		ang = self:GetOwner():EyeAngles()
		ang.p = ang.p - self.Recoil * 0.5 * mod
		ang.y = ang.y + math.random(-1, 1) * self.Recoil * 0.5 * mod
	
		self:GetOwner():SetEyeAngles(ang)
	end
	
	self:GetOwner():ViewPunch(Angle(-self.Recoil * 1.25 * mod, 0, 0))
end

function SWEP:SecondaryAttack()
	if self.ShotgunReloadState != 0 then
		return
	end
	
	if self.ReloadDelay then
		return
	end
	
	if self.dt.Safe then
		self:CycleFiremodes()
		return
	end
	
	if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION or self.dt.State == SWB_AIMING then
		return
	end
	
	if self.Suppressable and self:GetOwner():KeyDown(IN_USE) then
		self:ToggleSuppressor()
		return
	end
	
	if not self:GetOwner():OnGround() or Length(GetVelocity(self:GetOwner())) >= self:GetOwner():GetWalkSpeed() * 1.2 then
		return
	end
	
	CT = CurTime()
	
	self.dt.State = SWB_AIMING 
	
	if IsFirstTimePredicted() then
		self.AimTime = UnPredictedCurTime() + 0.25
		
		if self.PreventQuickScoping then
			self.AddSpread = math.Clamp(self.AddSpread + 0.03, 0, self.MaxSpreadInc)
			self.SpreadWait = CT + 0.3
		end
	end
	
	if SP and SERVER then
		//SendUserMessage("SWB_AimTime", self:GetOwner())
	end
	
	self:SetNextSecondaryFire(CT + 0.1)
end

function SWEP:ToggleSuppressor()
	if self.dt.Suppressed then
		self:SendWeaponAnim(ACT_VM_DETACH_SILENCER)
	else
		self:SendWeaponAnim(ACT_VM_ATTACH_SILENCER)
	end
	
	vm = self:GetOwner():GetViewModel()
	dur = vm:SequenceDuration()
	CT = CurTime()
	
	self:SetNextPrimaryFire(CT + dur)
	self:SetNextSecondaryFire(CT + dur)
	self.ReloadWait = CT + dur
	self.dt.Suppressed = ! self.dt.Suppressed
end

function SWEP:Equip()
end

if CLIENT then
	local EP, EA2, FT
	
	function SWEP:ViewModelDrawn()
		EP, EA2, FT = EyePos(), EyeAngles(), FrameTime()
		
		if IsValid(self.Hands) then
			self.Hands:SetRenderOrigin(EP)
			self.Hands:SetRenderAngles(EA2)
			self.Hands:FrameAdvance(FT)
			self.Hands:SetupBones()
			self.Hands:SetParent(self:GetOwner():GetViewModel())
			self.Hands:DrawModel()
		end
	end
	
	local wm, pos, ang
	local GetBonePosition = debug.getregistry().Entity.GetBonePosition
	
	local ply, wep

	local function SWB_ReceiveFireMode(len, ply)
		local ply = net.ReadEntity()
		local Mode = net.ReadString()
		
		if IsValid(ply) then
			wep = ply:GetActiveWeapon()
			wep.FireMode = Mode
			
			if IsValid(ply) and IsValid(wep) and wep.SWBWeapon then
				if wep.FireModeNames then
					t = wep.FireModeNames[Mode]
					
					wep.Primary.Automatic = t.auto
					wep.BurstAmount = t.burstamt
					wep.FireModeDisplay = t.display
					wep.BulletDisplay = t.buldis
					wep.CheckTime = CurTime() + 2
					
					if ply == LocalPlayer() then
						ply:EmitSound("weapons/smg1/switch_single.wav", 70, math.random(92, 112))
					end
				end
			end
		end
	end

	net.Receive("SWB_FIREMODE", SWB_ReceiveFireMode)
end

--addons/module_css2/lua/weapons/swb_base/sh_ammotypes.lua:
--[[ 
function SWB_AddAmmoType(name)
	game.AddAmmoType({name = name,
	dmgtype = DMG_BULLET})
	
	if CLIENT then
		language.Add(name .. "_ammo", name .. " Ammo")
	end
end

SWB_AddAmmoType("Rifle")
SWB_AddAmmoType("Sniper Rifle")
--]] 
--addons/module_css2/lua/weapons/swb_base/sh_sounds.lua:
--[[ 
function SWB_RegisterSound(n, s, l, pstart, pend)
	local tbl = {channel = CHAN_STATIC,
		volume = 1,
		level = l,
		name = n,
		sound = s,
		pitchstart = pstart,
		pitchend = pend}
	
	sound.Add(tbl)
end

SWB_RegisterSound("SWB_Empty", "weapons/shotgun/shotgun_empty.wav", 60, 95, 112)
SWB_RegisterSound("SWB_Knife_Hit", {"weapons/knife/knife_hit1.wav", "weapons/knife/knife_hit2.wav", "weapons/knife/knife_hit3.wav", "weapons/knife/knife_hit4.wav"}, 70, 92, 122)
SWB_RegisterSound("SWB_Knife_HitElse", "weapons/knife/knife_hitwall1.wav", 70, 92, 122)
SWB_RegisterSound("SWB_Knife_Swing", {"weapons/knife/knife_slash1.wav", "weapons/knife/knife_slash2.wav"}, 65, 92, 122)
--]] 
--addons/module_css2/lua/weapons/swb_base/cl_model.lua:
local cvar_shells = CreateClientConVar('swb_enable_shells', '1', true)
local cvar_addfov = CreateClientConVar('swb_viewmodel_addfov', 0, true)
local cvar_offset_x = CreateClientConVar('swb_viewmodel_offset_x', 0, true)
local cvar_offset_y = CreateClientConVar('swb_viewmodel_offset_y', 0, true)
local cvar_offset_z = CreateClientConVar('swb_viewmodel_offset_z', 0, true)

SWEP.BlendPos = Vector(0, 0, 0)
SWEP.BlendAng = Vector(0, 0, 0)
SWEP.OldDelta = Angle(0, 0, 0)
SWEP.AngleDelta = Angle(0, 0, 0)
SWEP.FireMove = 0
SWEP.ViewModelMovementScale = 1
SWEP.Sequence = ""
SWEP.Cycle = 0
SWEP.NoStockShells = true
SWEP.NoStockMuzzle = true

local Vec0 = Vector(0, 0, 0)
local TargetPos, TargetAng, cos1, sin1, tan, ws, rs, mod, EA, delta, sin2, mul, vm, muz, muz2, tr, att
local td = {}

local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local Right = reg.Angle.Right
local Up = reg.Angle.Up
local Forward = reg.Angle.Forward
local RotateAroundAxis = reg.Angle.RotateAroundAxis

function SWEP:GetTracerOrigin()
	if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
		return self.CenterPos
	end
end

function SWEP:CreateShell(sh)
	if not cvar_shells:GetBool() then return end
	if not IsValid(self:GetOwner()) or self:GetOwner():ShouldDrawLocalPlayer() or self.NoShells then
		return
	end
	
	sh = self.Shell or sh
	vm = self:GetOwner():GetViewModel()
	
	if not IsValid(vm) then
		return
	end

	att = vm:GetAttachment(2)
	
	if att then
		if self.InvertShellEjectAngle then
			dir = -att.Ang:Forward()
		else
			dir = att.Ang:Forward()
		end
		
		SWB_MakeFakeShell(sh, att.Pos + dir, EyeAngles(), dir * 200, 0.6, 10, self.ShellScale)
	end
end

function SWEP:CreateMuzzle(pos, ang)
	if self:GetOwner():ShouldDrawLocalPlayer() then
		return
	end

	vm = self:GetOwner():GetViewModel()
	
	if IsValid(vm) then
		vm:StopParticles()

		muz = vm:LookupAttachment("1")
		
		if muz then
			muz2 = vm:GetAttachment(muz)
			
			if muz2 then
				EA = EyeAngles()
				
				if self.MuzzlePosMod then
					pos = pos + EA:Right() * self.MuzzlePosMod.x + EA:Forward() * self.MuzzlePosMod.y + EA:Up() * self.MuzzlePosMod.z
				end
				
				if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
					pos = self:GetOwner():GetShootPos() + EA:Forward() * 15 - EA:Up() * 6
					self.CenterPos = pos
				end
				
				if self.dt.Suppressed then
					if self.MuzzleEffectSupp then
						if not self.NoSilMuz then
							if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
								ParticleEffect(self.MuzzleEffectSupp, pos + self:GetOwner():GetVelocity() * 0.03, EA, vm)
							else
								if self.PosBasedMuz then
									ParticleEffect(self.MuzzleEffectSupp, pos + self:GetOwner():GetVelocity() * 0.03, EA, vm) -- using velocity to add to the position 'simulates' attaching it to a control point
								else
									ParticleEffectAttach(self.MuzzleEffectSupp, PATTACH_POINT_FOLLOW, vm, muz)
								end
							end
						end
					end
				else
					if self.MuzzleEffect then
						if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
							ParticleEffect(self.MuzzleEffect, pos + self:GetOwner():GetVelocity() * 0.03, EA, vm)
						else
							if self.PosBasedMuz then
								ParticleEffect(self.MuzzleEffect, pos + self:GetOwner():GetVelocity() * 0.03, EA, vm)
							else
								ParticleEffectAttach(self.MuzzleEffect, PATTACH_POINT_FOLLOW, vm, muz)
							end
						end
					end
					
					dlight = DynamicLight(self:EntIndex())
					
					dlight.r = 255 
					dlight.g = 218
					dlight.b = 74
					dlight.Brightness = 4
					dlight.Pos = pos + self:GetOwner():GetAimVector() * 3
					dlight.Size = 96
					dlight.Decay = 128
					dlight.DieTime = CurTime() + FrameTime()
				end
			end
		end
	end
end

SWBShells = {}
SWBShells["mainshell"] = {m = "models/weapons/rifleshell.mdl", s = {"player/pl_shell1.wav", "player/pl_shell2.wav", "player/pl_shell3.wav"}}
SWBShells["shotshell"] = {m = "models/weapons/Shotgun_shell.mdl", s = {"weapons/fx/tink/shotgun_shell1.wav", "weapons/fx/tink/shotgun_shell2.wav", "weapons/fx/tink/shotgun_shell3.wav"}}
SWBShells["smallshell"] = {m = "models/weapons/shell.mdl", s = {"player/pl_shell1.wav", "player/pl_shell2.wav", "player/pl_shell3.wav"}}

function SWB_MakeFakeShell(shell, pos, ang, vel, time, removetime, shellscale)
	if not shell or not pos or not ang then
		return
	end

	local t = SWBShells[shell]
	
	if not t then
		return
	end
	
	vel = vel or Vector(0, 0, -100)
	vel = vel + VectorRand() * 5
	time = time or 0.5
	removetime = removetime or 5
	shellscale = shellscale or 1
	
	local ent = ClientsideModel(t.m, RENDERGROUP_BOTH) 
	ent:SetPos(pos)
	ent:PhysicsInitBox(Vector(-0.5, -0.15, -0.5), Vector(0.5, 0.15, 0.5))
	ent:SetAngles(ang)
	ent:SetModelScale(shellscale, 0)
	ent:SetMoveType(MOVETYPE_VPHYSICS) 
	ent:SetSolid(SOLID_VPHYSICS) 
	ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	
	local phys = ent:GetPhysicsObject()
	phys:SetMaterial("gmod_silent")
	phys:SetMass(10)
	phys:SetVelocity(vel)

	timer.Simple(time, function()
		if t.s then
			--ent:EmitSound(table.Random(t.s), 35, 100)
		end
	end)
	
	SafeRemoveEntityDelayed(ent, removetime)
end

function SWEP:FireAnimationEvent(pos, ang, ev, name)
	if ev == 5001 then
		if self.MuzzleEffect then
			self:CreateMuzzle(pos, ang)
		end
		
		if self.NoStockMuzzle then
			return true
		end
		
		return self.dt.Suppressed
	end
	
	if ev == 20 then
		if self.Shell then
			self:CreateShell()
		end
		
		return self.NoStockShells
	end
end

SWEP.ApproachSpeed = 10
local SP = game.SinglePlayer() 
local PosMod, AngMod = Vector(0, 0, 0), Vector(0, 0, 0)
local CurPosMod, CurAngMod = Vector(0, 0, 0), Vector(0, 0, 0)
local veldepend = {pitch = 0, yaw = 0, roll = 0}
local mod2 = 0
local EA2

function SWEP:PreDrawViewModel()
	CT = UnPredictedCurTime()
	vm = self:GetOwner():GetViewModel()
	
	self.Sequence = vm:GetSequenceName(vm:GetSequence())
	if self.ForceVMSequences then
		local fallback = self.ForceVMSequences[vm:GetSequence()]
		if fallback then
			self.Sequence = vm:GetSequenceName(fallback)
			vm:SendViewModelMatchingSequence(fallback)
		end
	end

	self.IsReloading = self.Sequence:find("reload")
	
	if not self.IsReloading then
		self.IsReloading = self.Sequence:find("insert")
	end
	
	if not self.IsReloading then
		self.IsFiddlingWithSuppressor = self.Sequence:find("silencer")
	end
	
	self.Cycle = vm:GetCycle()
	
	EA = EyeAngles()
	FT = FrameTime()
	
	delta = Angle(EA.p, EA.y, 0) - self.OldDelta
	delta.p = math.Clamp(delta.p, -10, 10)
		
	self.OldDelta = Angle(EA.p, EA.y, 0)
	self.AngleDelta = LerpAngle(math.Clamp(FT * 10, 0, 1), self.AngleDelta, delta)
	self.AngleDelta.y = math.Clamp(self.AngleDelta.y, -10, 10)

	vel = GetVelocity(self:GetOwner())
	len = Length(vel)
	ws = self:GetOwner():GetWalkSpeed()
	
	PosMod, AngMod = Vec0 * 1, Vec0 * 1
	mod2 = 1
	
	veldepend.roll = math.Clamp((vel:Dot(EA:Right()) * 0.04) * len / ws, -5, 5)
	
	if self.dt.State == SWB_AIMING then
		mod2 = 0.2
		TargetPos, TargetAng = self.AimPos * 1, self.AimAng * 1
		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 8, FT * 100)
	elseif self.dt.State == SWB_ACTION then
		TargetPos, TargetAng = self.SwimPos * 1, self.SwimAng * 1
		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 5, FT * 100)
	elseif self.dt.State == SWB_RUNNING or (((len > ws * 1.2 and self:GetOwner():KeyDown(IN_SPEED)) or len > ws * 3 or (self.ForceRunStateVelocity and len > self.ForceRunStateVelocity)) and self:GetOwner():OnGround()) and !self:GetOwner():GetNW2Bool("donate_upgrade_runngun",false)then
		if self.IsReloading and self.Cycle < 0.9 then
			TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
		else
			if self.SprintingEnabled then
				TargetPos, TargetAng = self.SprintPos * 1, self.SprintAng * 1
			else
				TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
			end
		end
		
		rs = self:GetOwner():GetRunSpeed()
		mod = 7 + math.Clamp(rs / 100, 0, 6)
		mul = math.Clamp(len / rs, 0, 1)
		sin1 = math.sin(CT * mod) * mul
		cos1 = math.cos(CT * mod) * mul
		tan1 = math.tan(sin1 * cos1) * mul
		
		if (self.IsReloading or self.IsFiddlingWithSuppressor) and self.Cycle <= 0.9 then
			AngMod.x = AngMod.x + tan1 * 0.2 * self.ViewModelMovementScale * mul
			AngMod.y = AngMod.y - cos1 * 1.5 * self.ViewModelMovementScale * mul
			AngMod.z = AngMod.z + cos1 * 3 * self.ViewModelMovementScale * mul
			PosMod.x = PosMod.x - sin1 * 1.2 * self.ViewModelMovementScale * mul
			PosMod.y = PosMod.y + tan1 * 3 * self.ViewModelMovementScale * mul
			PosMod.z = PosMod.z + tan1 * 1.5 * self.ViewModelMovementScale * mul
			
			self.ApproachSpeed = math.Approach(self.ApproachSpeed, 4, FT * 100)
		else
			AngMod.x = AngMod.x + tan1 * 0.2 * self.ViewModelMovementScale * mul
			AngMod.y = AngMod.y - cos1 * 1.5 * self.ViewModelMovementScale * mul
			AngMod.z = AngMod.z + cos1 * 3 * self.ViewModelMovementScale * mul
			PosMod.x = PosMod.x - sin1 * 1.2 * self.ViewModelMovementScale * mul
			PosMod.y = PosMod.y + tan1 * 3 * self.ViewModelMovementScale * mul
			PosMod.z = PosMod.z + tan1 * 1.5 * self.ViewModelMovementScale * mul
			
			self.ApproachSpeed = math.Approach(self.ApproachSpeed, 6, FT * 100)
		end
	else
		if self.dt.Safe then
			TargetPos, TargetAng = self.SprintPos * 1, self.SprintAng * 1
		else
			TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
		end

		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 10, FT * 100)
		
		td.start = self:GetOwner():GetShootPos()
		td.endpos = td.start + self:GetOwner():EyeAngles():Forward() * 30
		td.filter = self:GetOwner()
		
		tr = util.TraceLine(td)
		
		if tr.Hit then
			self.NearWall = true
			TargetPos.y = TargetPos.y - math.Clamp(30 * (1 - tr.Fraction), 0, 15)
		end
	end
	
	if len < 10 or not self:GetOwner():OnGround() then
		if self.dt.State != SWB_AIMING then
			cos1, sin1 = math.cos(CT), math.sin(CT)
			tan = math.atan(cos1 * sin1, cos1 * sin1)
			
			AngMod.x = AngMod.x + tan * 1.15
			AngMod.y = AngMod.y + cos1 * 0.4
			AngMod.z = AngMod.z + tan
			
			PosMod.y = PosMod.y + tan * 0.2 * mod2
		end
	elseif len > 10 and len < ws * 1.2 then
		mod = 6 + ws / 130
		mul = math.Clamp(len / ws, 0, 1)
		sin1 = math.sin(CT * mod) * mul
		cos1 = math.cos(CT * mod) * mul
		tan1 = math.tan(sin1 * cos1) * mul
		
		AngMod.x = AngMod.x + tan1 * self.ViewModelMovementScale * mod2
		AngMod.y = AngMod.y - cos1 * self.ViewModelMovementScale * mod2
		AngMod.z = AngMod.z + cos1 * self.ViewModelMovementScale * mod2
		PosMod.x = PosMod.x - sin1 * 0.4 * self.ViewModelMovementScale * mod2
		PosMod.y = PosMod.y + tan1 * 1 * self.ViewModelMovementScale * mod2
		PosMod.z = PosMod.z + tan1 * 0.5 * self.ViewModelMovementScale * mod2
	end
	
	FT = FrameTime()
	
	TargetAng.z = TargetAng.z + veldepend.roll
	self.BlendPos = LerpVector(FT * self.ApproachSpeed, self.BlendPos, TargetPos)
	self.BlendAng = LerpVector(FT * self.ApproachSpeed, self.BlendAng, TargetAng)
	
	CurPosMod = LerpVector(FT * 10, CurPosMod, PosMod)
	CurAngMod = LerpVector(FT * 10, CurAngMod, AngMod)
	
	self.FireMove = Lerp(FT * 15, self.FireMove, 0)
end

function SWEP:GetViewModelPosition(pos, ang)
	CT = UnPredictedCurTime()
	
	if self.InstantDissapearOnAim and self.dt.State == SWB_AIMING then
		self.ViewModelFOV = 90
		pos = pos - ang:Forward() * 100
		return pos, ang
	end
	
	if self.MoveWepAwayWhenAiming and CT > self.AimTime and self.dt.State == SWB_AIMING then
		self.ViewModelFOV = 90
		pos = pos - ang:Forward() * 100
		return pos, ang
	end
	
	self.ViewModelFOV = self.ViewModelFOV_Orig + cvar_addfov:GetInt()
	
	RotateAroundAxis(ang, Right(ang), CurAngMod.x + self.BlendAng.x + self.AngleDelta.p * mod2)
	
	if not self.ViewModelFlip then
		RotateAroundAxis(ang, Up(ang), CurAngMod.y + self.BlendAng.y + self.AngleDelta.y * 0.3 * mod2)
		RotateAroundAxis(ang, Forward(ang), CurAngMod.z + self.BlendAng.z + self.AngleDelta.y * 0.3 * mod2)
	else
		RotateAroundAxis(ang, Up(ang), CurAngMod.y + self.BlendAng.y - self.AngleDelta.y * 0.3 * mod2)
		RotateAroundAxis(ang, Forward(ang), CurAngMod.z - self.BlendAng.z - self.AngleDelta.y * 0.3 * mod2)
	end

	if not self.ViewModelFlip then
		pos = pos + (CurPosMod.x + self.BlendPos.x + self.AngleDelta.y * 0.1 * mod2) * Right(ang)
	else
		pos = pos + (CurPosMod.x + self.BlendPos.x - self.AngleDelta.y * 0.1 * mod2) * Right(ang)
	end
	
	pos = pos + (CurPosMod.y + self.BlendPos.y - self.FireMove) * Forward(ang)
	pos = pos + (CurPosMod.z + self.BlendPos.z - self.AngleDelta.p * 0.1) * Up(ang)

	if self.dt.State ~= SWB_AIMING then
		pos = pos + (cvar_offset_x:GetFloat()*2) * Right(ang)
		pos = pos + (cvar_offset_y:GetFloat()*2) * Forward(ang)
		pos = pos + (cvar_offset_z:GetFloat()*2) * Up(ang)
	end
	
	return pos, ang
end

local wm, pos, ang

function SWEP:DrawWorldModel()
	if self.dt.Safe then
		if self.CHoldType != self.RunHoldType then
			self:SetHoldType(self.RunHoldType)
			self.CHoldType = self.RunHoldType
		end
	else
		if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION then
			if self.CHoldType != self.RunHoldType then
				self:SetHoldType(self.RunHoldType)
				self.CHoldType = self.RunHoldType
			end
		else
			if self.CHoldType != self.NormalHoldType then
				self:SetHoldType(self.NormalHoldType)
				self.CHoldType = self.NormalHoldType
			end
		end
	end
				
	if self.DrawTraditionalWorldModel then
		self:DrawModel()
	else
		wm = self.WMEnt
		
		if IsValid(wm) then
			if IsValid(self:GetOwner()) then
				pos, ang = GetBonePosition(self:GetOwner(), self:GetOwner():LookupBone("ValveBiped.Bip01_R_Hand"))
				
				if pos and ang then
					RotateAroundAxis(ang, Right(ang), self.WMAng[1])
					RotateAroundAxis(ang, Up(ang), self.WMAng[2])
					RotateAroundAxis(ang, Forward(ang), self.WMAng[3])

					pos = pos + self.WMPos[1] * Right(ang) 
					pos = pos + self.WMPos[2] * Forward(ang)
					pos = pos + self.WMPos[3] * Up(ang)
					
					wm:SetRenderOrigin(pos)
					wm:SetRenderAngles(ang)
					wm:DrawModel()
				end
			else
				wm:SetRenderOrigin(self:GetPos())
				wm:SetRenderAngles(self:GetAngles())
				wm:DrawModel()
				wm:DrawShadow()
			end
		else
			self:DrawModel()
		end
	end
end
--addons/weapon_melee/lua/weapons/weapon_hl2pickaxe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Кирка"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing  - Secondary attack : Push"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Толкнуть"},
}
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pickaxe.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pickaxe.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 72
SWEP.HitRadius			= 16
SWEP.HitPushback		= 1000
SWEP.HitRate			= 1.35
SWEP.MinDamage			= 50
SWEP.MaxDamage			= 80

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local ply = self:GetOwner()

	local vm = ply:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*50,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		self:EmitSound(PushSoundBody)

		if hithuman then
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * 500)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/weapon_melee/lua/weapons/weapon_hl2pipe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Труба"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary  attack: Swing"
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pipe.mdl" )
SWEP.WorldModel				= Model( "models/props_canal/mattpipe.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 64
SWEP.HitRadius			= 12
SWEP.HitPushback		= 400
SWEP.HitRate			= 1.10
SWEP.MinDamage			= 50
SWEP.MaxDamage			= 70

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()
	return true
end

function SWEP:OnDrop()
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/weapon_vape/lua/weapons/weapon_vape_cigarette.lua:
if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Сигарета"
SWEP.Category  = "Запрещено"
SWEP.Instructions = ""

SWEP.VapeID = 10

SWEP.ViewModel = "models/mordeciga/mordes/oldcigshib.mdl"
SWEP.WorldModel = "models/mordeciga/mordes/oldcigshib.mdl"

SWEP.ObjectPos = Vector(-7.1, -2.401, 23.377)
SWEP.ObjectAng = Angle(111.039, 10.519, 0)
-- lighter.wav звук подкуривания
--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--addons/weapon_vape/lua/weapons/weapon_vape_medicinal.lua:
-- weapon_vape_medicinal.lua
-- Defines a vape that heals the player

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Medicinal Vape"
SWEP.Category  = "Разрешено"
SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis healthy, organic juice has amazing healing abilities."

SWEP.VapeID = 3

SWEP.VapeAccentColor = Vector(0,1,0.5)
SWEP.VapeTankColor = Vector(0,0.5,0.25)

-- note: healing functionality is in weapon_vape/init.lua
--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/weapon_vape/lua/weapons/weapon_vape_wayzer.lua:
-- weapon_vape_medicinal.lua
-- Defines a vape that heals the player

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "WayZer Vape"
SWEP.Category  = "Премиум"
SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis healthy, organic juice has amazing healing abilities."

SWEP.VapeID = 2

local r = 228/200
local g = 110/200
local b = 67/200

SWEP.VapeAccentColor = Vector(r,g,b)
SWEP.VapeTankColor = Vector(r,g,b)

SWEP.Unbreakable = true

-- note: healing functionality is in weapon_vape/init.lua
--addons/module_css2/lua/weapons/wrp_weapon_csg/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-4.48, -9.5, 4.1)
	SWEP.AimAng = Vector(0.74, 0.04, 0)

	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "B"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "CSG-12 Drum"

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/tak/f3/c_combatshotgun.mdl"
SWEP.WorldModel = "models/tak/f3/w_combat_shotgun.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 12
SWEP.Primary.DefaultClip = 36
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "buckshot"

SWEP.FireDelay = 0.25
SWEP.FireSound = Sound("tak/weapons/fallout/combat_shotgun/fire_mono.wav")
SWEP.Recoil = 1.5

SWEP.HipSpread = 0.01
SWEP.AimSpread = 0.001
SWEP.ClumpSpread = 0.04
SWEP.VelocitySensitivity = 4
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 8
SWEP.Damage = 15
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/wrp_weapon_dbshotgun/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true

	SWEP.AimPos = Vector(-3, -10, 2.8)
	SWEP.AimAng = Vector(1.2, 0.02, 0)
		
	SWEP.SprintPos = Vector(3.957, -4.112, 1.013)
	SWEP.SprintAng = Vector(-8.613, 32.743, 0)

	SWEP.FadeCrosshairOnAim = true
	SWEP.ZoomAmount = 30
	SWEP.ViewModelMovementScale = 0.3
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "B"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "Двуствольный дробовик"

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_box_buckshot_ttt"

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/tak/f3/c_double-barrel_shotgun.mdl"
SWEP.WorldModel = "models/tak/f3/w_double-barrel_shotgun.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 2
SWEP.Primary.DefaultClip = 12
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "buckshot"

SWEP.FireDelay = 0.8
SWEP.FireSound = Sound("tak/weapons/fallout/dbshotgun/fire_mono.wav")
SWEP.Recoil = 2
SWEP.Chamberable = false

SWEP.HipSpread = 0.01
SWEP.AimSpread = 0.001
SWEP.ClumpSpread = 0.05
SWEP.VelocitySensitivity = 4
SWEP.MaxSpreadInc = 0.001
SWEP.SpreadPerShot = 0.001
SWEP.SpreadCooldown = 0.5
SWEP.Shots = 16
SWEP.Damage = 16
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/wrp_weapon_huckleberry/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-4.98, -10, 0.32)
	SWEP.AimAng = Vector(0.74, 0.04, 0)

	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "B"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "Huckleberry"

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Премиум"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/huckleberry/c_huckleberry.mdl"
SWEP.WorldModel = "models/weapons/huckleberry/w_huckleberry.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 12
SWEP.Primary.DefaultClip = 36
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "buckshot"

SWEP.FireDelay = 0.137
SWEP.FireSound = Sound("weapons/hucklefire1.wav")
SWEP.Recoil = 1

SWEP.HipSpread = 0.01
SWEP.AimSpread = 0.001
SWEP.ClumpSpread = 0.015
SWEP.VelocitySensitivity = 4
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 5
SWEP.Damage = 12
SWEP.DeployTime = 1

hook.Add("EntityTakeDamage", "Huckleberry_Freeze", function(target, dmginfo)
	if not target:IsPlayer() then return end
	
	local attacker = dmginfo:GetAttacker()
	if not attacker:IsPlayer() then return end

	local wep = attacker:GetActiveWeapon()
	if not IsValid(wep) then return end
	if not wep.SWBWeapon then return end

	if wep:GetClass() == "wrp_weapon_huckleberry" then
		target:MoveModifier('huckleberry_slow', {walkmul = 0.60, runmul = 0.60})
		
		timer.Simple(1, function()
			if not IsValid(target) then return end
			target:MoveModifier('huckleberry_slow')
		end)
	end
end)
--addons/module_css2/lua/weapons/wrp_weapon_huntrifle/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-3.6, -8, 3)
	SWEP.AimAng = Vector(1.5, 0, 0)

	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 40
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "Охотничья винтовка"

SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 2
SWEP.PlayBackRateSV = 2
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 7.62
SWEP.CaseLength = 39

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/tak/f3/c_hunting_rifle.mdl"
SWEP.WorldModel = "models/tak/f3/w_hunting_rifle.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 5
SWEP.Primary.DefaultClip = 15
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.85
SWEP.FireSound = Sound("tak/weapons/fallout/hunting_rifle/fire_mono.wav")
SWEP.Recoil = 1.5

SWEP.HipSpread = 0.004
SWEP.AimSpread = 0.001
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 125
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/wrp_weapon_mauser/shared.lua:
AddCSLuaFile()

if CLIENT then
    
    SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-3.799, -1.5, 1.95)
	SWEP.AimAng = Vector(1.7, 0.02, 1.9)
	
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.FadeCrosshairOnAim = true
	SWEP.ZoomAmount = 30
	SWEP.ViewModelMovementScale = 0.3
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "c"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "C96 Mauser"

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"3burst", "auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/tak/f3/c_mauser.mdl"
SWEP.WorldModel = "models/tak/f3/w_mauser.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 10
SWEP.Primary.DefaultClip = 30
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "pistol"
SWEP.Chamberable = false

SWEP.FireDelay = 0.06
SWEP.FireSound = Sound("tak/weapons/fallout/mauser/fire_mono.wav")
SWEP.Recoil = 0.6
SWEP.DryFire = true

SWEP.HipSpread = 0.025
SWEP.AimSpread = 0.0125
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 32
SWEP.DeployTime = 0
SWEP.BurstCooldownMul = 2
--addons/module_css2/lua/weapons/wrp_weapon_python/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = false
	
	SWEP.AimPos = Vector(-4.921, -7, 2.559)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(1.185, -15.796, -14.254)
	SWEP.SprintAng = Vector(64.567, 0, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 40
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 40
	SWEP.MaxZoom = 60
	
	SWEP.IconLetter = "f"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "Colt Python"

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 12
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 33

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"double", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/tak/f3/c_44magnum.mdl"
SWEP.WorldModel = "models/tak/f3/w_44magnum.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 6
SWEP.Primary.DefaultClip = 18
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"
SWEP.Chamberable = false

SWEP.FireDelay = 0.357
SWEP.FireSound = Sound("tak/weapons/fallout/magnum/fire_mono.wav")
SWEP.Recoil = 2

SWEP.HipSpread = 0.0015
SWEP.AimSpread = 0.0005
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 100
SWEP.DeployTime = 0
--addons/module_css2/lua/weapons/wrp_weapon_thompson/shared.lua:
AddCSLuaFile()


if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-4.528, -1, 1.73)
	SWEP.AimAng = Vector(0.54, -0.0, -0)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 3)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"

	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "M1A1 Thompson"

SWEP.FadeCrosshairOnAim = true

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 20
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 22.8

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_thompson.mdl"
SWEP.WorldModel = "models/weapons/w_thompson.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 20
SWEP.Primary.DefaultClip = 60
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.06
SWEP.FireSound = Sound("weapons/thompson_shoot.wav")
SWEP.Recoil = 0.65

SWEP.HipSpread = 0.015
SWEP.AimSpread = 0.002
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 40
SWEP.DeployTime = 1
--addons/module_bank/lua/entities/bank_car/cl_init.lua:
include('shared.lua')
--addons/module_bank/lua/entities/bank_vent/cl_init.lua:
include('shared.lua')
--addons/ent_bitcoinpc/lua/entities/bit_case/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

surface.CreateFont( "BitCoinFont", {
	font = "TargetID", 
	size = 15,
	weight = 500,
	antialias = true
} )

surface.CreateFont( "BitCoinFont2", {
	font = "TargetID", 
	size = 8,
	weight = 499,
	antialias = false
} )

local load1 = Material("materials/bit/load1.png")	
local load2 = Material("materials/bit/load2.png")	
local load3 = Material("materials/bit/load3.png")
local load4 = Material("materials/bit/load4.png")
local load5 = Material("materials/bit/load5.png")
local load6 = Material("materials/bit/window1.png")
local load7 = Material("materials/bit/window2.png")
local load8 = Material("materials/bit/window3.png")

function ENT:Draw()

	self:DrawModel()
	
	if self:GetPos():DistToSqr(EyePos()) > 160000 then return end
	
	local ang = self:GetAngles()
	local pos = self:GetPos()
	local spin = CurTime() * 180
	
	ang:RotateAroundAxis(self:GetAngles():Up(), 450)
	ang:RotateAroundAxis(self:GetAngles():Right(), 274)
	ang:RotateAroundAxis(self:GetAngles():Up(), 360)
	
	cam.Start3D2D(pos + ang:Up() * 12.65, ang, 0.11)	
	
		
	if (self:GetCornet()) then
	
		if (self:GetLoad() == 1) then
		
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load1 )
			surface.DrawTexturedRect( -88,-100,177,145 )	
		
		elseif (self:GetLoad() == 2) then
	
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load2 )
			surface.DrawTexturedRect( -88,-100,177,145 )	
		
		elseif (self:GetLoad() == 3) then		
		
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load3 )
			surface.DrawTexturedRect( -88,-100,177,145 )	
		
		elseif (self:GetLoad() == 4) then	
		
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load4 )
			surface.DrawTexturedRect( -88,-100,177,145 )		
		
		elseif (self:GetLoad() == 5) then	
		
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load5 )
			surface.DrawTexturedRect( -88,-100,177,145 )	
		
			draw.SimpleText("Bitcoins collected: "..self:GetBitCoin(), "BitCoinFont", -70,-90, color_white,0,1) 
			draw.SimpleText("GB Used: "..self:GetGBused().."/"..self:GetHarddisk(), "BitCoinFont", -70,-70, color_white,0,1) 
			draw.SimpleText("Power Output: "..self:GetPowerSupply().."W", "BitCoinFont", -70,-50, color_white,0,1) 	
			draw.SimpleText("Power Usage: "..self:GetReqPowerSupply().."W", "BitCoinFont", -70,-30, color_white,0,1) 
			draw.SimpleText("Ram: "..self:GetRam().."GB", "BitCoinFont", -70,-10, color_white,0,1)		
			draw.SimpleText("GPU: "..self:GetGraphiccard().."* Amd 240x", "BitCoinFont", -70,10, color_white,0,1)	
			draw.SimpleText("CPU: Intel Celeron 2.4GHz", "BitCoinFont", -70,30, color_white,0,1)
		
		else	
			local whitecolor, whiteleft = color_white, -67
			
			draw.RoundedBox(0,-88,-100,177,145,color_black)
			draw.SimpleText("Insert parts & press E.: ", "BitCoinFont", whiteleft,-86, whitecolor,0,1) 
			
			if (self:GetGraphiccard() == 0) then
				draw.SimpleText("Insert GPU: ", "BitCoinFont", whiteleft,-66, whitecolor,0,1)
			end
			
			if !(self:GetCPU()) then
				draw.SimpleText("Insert CPU: ", "BitCoinFont", whiteleft,-56, whitecolor,0,1)	
			end
			
			if (self:GetRam() == 0) then			
				draw.SimpleText("Insert RAM: ", "BitCoinFont", whiteleft,-46, whitecolor,0,1)
			end
			
			if (self:GetPowerSupply() == 0) then
				draw.SimpleText("Insert PSU: ", "BitCoinFont", whiteleft,-36, whitecolor,0,1)		
			end
			
			if !(self:GetMotherboard()) then
				draw.SimpleText("Insert MOBO: ", "BitCoinFont", whiteleft,-26, whitecolor,0,1)
			end
			
			if (self:GetHarddisk() == 0) then
				draw.SimpleText("Insert HARDDISK: ", "BitCoinFont", whiteleft,-16, whitecolor,0,1)	
			end
			
		end
		
	elseif (self:GetWindow()) then
	
		if (self:GetLoad() > 0 and self:GetLoad() <= 3) then
		
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load6 )
			surface.DrawTexturedRect( -88,-100,177,145 )
			
		elseif (self:GetLoad() == 4) then
		
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load7 )
			surface.DrawTexturedRect( -88,-100,177,145 )
			
		elseif (self:GetLoad() == 5) then
		
			surface.SetDrawColor( color_white )
			surface.SetMaterial( load8 )
			surface.DrawTexturedRect( -88,-100,177,145 )
			
			draw.SimpleText("Bitcoins collected: "..self:GetBitCoin(), "BitCoinFont2", -6,-73, color_black,0,1) 
			draw.SimpleText("GB Used: "..self:GetGBused().."/"..self:GetHarddisk(), "BitCoinFont2", -6,-63, color_black,0,1) 
			draw.SimpleText("Power Output: "..self:GetPowerSupply().."W", "BitCoinFont2", -6,-53, color_black,0,1) 	
			draw.SimpleText("Power Usage: "..self:GetReqPowerSupply().."W", "BitCoinFont2", -6,-43, color_black,0,1) 
			draw.SimpleText("Ram: "..self:GetRam().."GB", "BitCoinFont2", -6,-33, color_black,0,1)		
			draw.SimpleText("GPU: "..self:GetGraphiccard().."* Amd 240x", "BitCoinFont2", -6,-23, color_black,0,1)	
			draw.SimpleText("CPU: Celeron 2.4GHz", "BitCoinFont2", -6,-13, color_black,0,1)
			
		else
		
			local whitecolor, whiteleft = color_white, -67
			
			draw.RoundedBox(0,-88,-100,177,145,color_black)
			draw.SimpleText("Insert parts & press E.: ", "BitCoinFont", whiteleft,-86, whitecolor,0,1) 
			
			if (self:GetGraphiccard() == 0) then
				draw.SimpleText("Insert GPU: ", "BitCoinFont", whiteleft,-66, whitecolor,0,1)
			end
			
			if !(self:GetCPU()) then
				draw.SimpleText("Insert CPU: ", "BitCoinFont", whiteleft,-56, whitecolor,0,1)	
			end
			
			if (self:GetRam() == 0) then			
				draw.SimpleText("Insert RAM: ", "BitCoinFont", whiteleft,-46, whitecolor,0,1)
			end
			
			if (self:GetPowerSupply() == 0) then
				draw.SimpleText("Insert PSU: ", "BitCoinFont", whiteleft,-36, whitecolor,0,1)		
			end
			
			if !(self:GetMotherboard()) then
				draw.SimpleText("Insert MOBO: ", "BitCoinFont", whiteleft,-26, whitecolor,0,1)
			end
			
			if (self:GetHarddisk() == 0) then
				draw.SimpleText("Insert HARDDISK: ", "BitCoinFont", whiteleft,-16, whitecolor,0,1)	
			end 
			
		end		
	end
		
	cam.End3D2D()	
end		


--addons/ent_bitcoinpc/lua/entities/bit_motherboard/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Motherboard"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end
--addons/ent_bitcoinpc/lua/entities/bit_ram/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Ram"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end
--addons/ent_bitcoinpc/lua/entities/bit_windows/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_bitminers2/lua/entities/bm2_bitminer_rack/shared.lua:
ENT.Type = "anim"

ENT.PrintName = "Bitminer Rack"
ENT.Spawnable = true
ENT.Category = "Запрещено"

ENT.upgrades = {
	CPU = {name = "Overclocks all server by +256MHz", cost = {2000,4000,8000,16000,32000, 64000, 128000}, amountPerUpgrade = 0.256},
	CORES = {name = "Adds an extra core", cost = {}} //Altough were not using it, by having an empty table it will prevent errors
}

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "HasPower" )
	self:NetworkVar( "Bool", 2, "IsOn")
	self:NetworkVar( "Bool", 3, "IsMining")
	self:NetworkVar( "Float", 1, "BitcoinAmount")
	self:NetworkVar( "Int", 1, "CPUUpgrade")
	self:NetworkVar( "Int", 2, "CoreUpgrade")  
	self:NetworkVar( "Float", 3, "ClockSpeed")
	self:NetworkVar( "Int", 4, "CoreCount")
	//A string table of all the updates that have been purchased.
	self:NetworkVar( "String", 1, "Updates") 
	self:NetworkVar( "String", 2, "ConnectedServers")
	self:NetworkVar("Entity", 0, "owning_ent")
end


--addons/module_bitminers2_extras/lua/entities/bm2_extra_fuel_line/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end  

--addons/module_bitminers2_extras/lua/entities/bm2_extra_fuel_tank/cl_init.lua:
include("shared.lua")

local fuelMaterial = Material("materials/bitminers2/ui/fuel.png", "noclamp smooth")
local outputMaterial = Material("materials/bitminers2/ui/output.png", "noclamp smooth")
local warningMaterial = Material("materials/bitminers2/ui/warning.png", "noclamp smooth")

function ENT:DrawTranslucent()
	self:DrawModel()

	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 122500 then
		self.cam2d3dAng = LerpAngle(7 * FrameTime(), self.cam2d3dAng ~= nil and self.cam2d3dAng or Angle(0,0,0), Angle(0,LocalPlayer():GetAngles().y - 90,90))

		--Cam 2D3D for drawing infomation
		local ang = self:GetAngles()
		local pos = self:GetPos() + Vector(0,0,40) + (ang:Up() * 22)

		local alpha = 1 - math.Clamp(LocalPlayer():GetPos():DistToSqr(self:GetPos()) / (350 * 350), 0, 1)

		local color1 = Color(0,0,0,100 * alpha)
		local color2 = Color(0,0,0,255 * alpha)
		local color3 = Color(255,255,255,255 * alpha)
		local color4 = Color(255,165,0, 255 * alpha)

		cam.Start3D2D(pos, self.cam2d3dAng, 0.05)
			draw.RoundedBox(8,-200, -10 , 410, 80, color1)

			surface.SetMaterial(fuelMaterial)
			surface.SetDrawColor(color4)
			surface.DrawTexturedRect(-196,4, 56, 56)

			draw.RoundedBox(4, -130, 4 , 330, 52, Color(36,36,36,  255 * alpha))
			draw.RoundedBox(2, -128, 6 , 326, 48, Color(15,15,15, 255 * alpha))
			draw.RoundedBox(2, -128, 6 , 326 * (self:GetFuelLevel()/ BM2EXTRACONFIG.ExtraFuelTankSize), 48, color4)
			draw.SimpleText(self:GetFuelLevel().."/"..BM2EXTRACONFIG.ExtraFuelTankSize.." L", "BM2GeneratorFont", 45, 30, color2, 1, 1)
			draw.SimpleText(self:GetFuelLevel().."/"..BM2EXTRACONFIG.ExtraFuelTankSize.." L", "BM2GeneratorFont", 44, 29, color3, 1, 1)
		cam.End3D2D()
	end
end  

--addons/module_bitminers2_extras/lua/entities/bm2_extra_fuel_tank/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Fuel Tank"
ENT.Spawnable = true
ENT.Category = "Запрещено"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 3, "ShowNoFuelWarning")
	self:NetworkVar("Int",0, "FuelLevel")
end
--addons/module_bitminers2/lua/entities/bm2_generator/cl_init.lua:
include("shared.lua")

surface.CreateFont( "BM2GeneratorFont", {
	font = "Roboto Lt", 
	extended = false,
	size = 40,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local fuelMaterial = Material("materials/bitminers2/ui/fuel.png", "noclamp smooth")
local outputMaterial = Material("materials/bitminers2/ui/output.png", "noclamp smooth")
local warningMaterial = Material("materials/bitminers2/ui/warning.png", "noclamp smooth")

local function __round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end

function ENT:DrawTranslucent()
	self:DrawModel()

	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then return end
	
	if self.cam2d3dAng == nil then
		self.cam2d3dAng = Angle(0,LocalPlayer():GetAngles().y - 90,90)
	else
		self.cam2d3dAng = LerpAngle(7 * FrameTime(),self.cam2d3dAng, Angle(0,LocalPlayer():GetAngles().y - 90,90))
	end
	--Cam 2D3D for drawing infomation
	local ang = self:GetAngles()
	local pos = self:GetPos() + Vector(0,0,40) - (ang:Forward() * 5) + (ang:Up() * 20)

	local alpha = 1 - math.Clamp((LocalPlayer():GetPos():Distance(self:GetPos()) / 350) * 1.1, 0, 1)

	cam.Start3D2D(pos, self.cam2d3dAng, 0.05)
		if not self:GetShowToMuchPowerWarning() then
			if not self:GetShowNoFuelWarning() then
				draw.RoundedBox(8,-200, -10 , 410, (70 * 2) + 10,Color(0,0,0,100 * alpha))

				surface.SetMaterial(outputMaterial)
				surface.SetDrawColor(Color(200,200,0, 255 * alpha))
				surface.DrawTexturedRect(-200 + 4, 4, 64 - 8, 64 - 8)

				surface.SetMaterial(fuelMaterial)
				surface.SetDrawColor(Color(255,165,0, 255 * alpha))
				surface.DrawTexturedRect(-200 + 4,70 + 4, 64 - 8, 64 - 8)

				//Draw power ussage bar
				draw.RoundedBox(4, -200 + 70, 4, 400 - 70, 60-8, Color(36,36,36, 255 * alpha))
				draw.RoundedBox(2, -200 + 70 + 2, 4 + 2, 400 - 70 - 4, 60-8 - 4, Color(15,15,15, 255 * alpha))
				if self:GetPowerConsumpsion() > 0 then
					draw.RoundedBox(2, -200 + 70 + 2, 4 + 2, (400 - 70 - 4) * (self:GetPowerConsumpsion()/ BM2CONFIG.GeneratorPowerOutput), 60-8 - 4, Color(200,200,0, 255 * alpha))
				end
				
				local powerLevel = __round(self:GetPowerConsumpsion(), 2)

				draw.SimpleText((powerLevel*100).."/"..(BM2CONFIG.GeneratorPowerOutput * 100).."W", "BM2GeneratorFont", 45, ((60-8-4)/2) + 6, Color(0,0,0, 255 * alpha), 1, 1)
				draw.SimpleText((powerLevel*100).."/"..(BM2CONFIG.GeneratorPowerOutput * 100).."W", "BM2GeneratorFont", 44, ((60-8-4)/2) + 5, Color(255,255,255, 255 * alpha), 1, 1)

				draw.RoundedBox(4, -200 + 70, 4 + 70, 400 - 70, 60-8, Color(36,36,36,  255 * alpha))
				draw.RoundedBox(2, -200 + 70 + 2, 4 + 2 + 70, 400 - 70 - 4, 60-8 - 4, Color(15,15,15, 255 * alpha))
				draw.RoundedBox(2, -200 + 70 + 2, 4 + 2 + 70, (400 - 70 - 4) * (self:GetFuelLevel()/ 1000), 60-8 - 4, Color(255,165,0,  255 * alpha))
				draw.SimpleText(self:GetFuelLevel().."/1000 L", "BM2GeneratorFont", 45, ((60-8-4)/2) + 6 + 70, Color(0,0,0, 255 * alpha), 1, 1)
				draw.SimpleText(self:GetFuelLevel().."/1000 L", "BM2GeneratorFont", 44, ((60-8-4)/2) + 5 + 70, Color(255,255,255, 255 * alpha), 1, 1)
			else
				surface.SetMaterial(warningMaterial)
				surface.SetDrawColor(Color(255,80,80, 255))
				surface.DrawTexturedRect(-80, -20, 160, 160)

				draw.SimpleText("Out of fuel!", "BM2GeneratorFont", 0, 170, Color(0,0,0, 255), 1, 1)
				draw.SimpleText("Out of fuel!", "BM2GeneratorFont", -1, 170 - 1, Color(255,255,255, 255), 1, 1)

				draw.SimpleText("Please purchase some fuel.", "BM2GeneratorFont", 0, 170 + 35, Color(0,0,0, 255), 1, 1)
				draw.SimpleText("Please purchase some fuel.", "BM2GeneratorFont", -1, 170 - 1 + 35, Color(255,255,255, 255), 1, 1)

			end
		else
			surface.SetMaterial(warningMaterial)
			surface.SetDrawColor(Color(255,255,255, 255))
			surface.DrawTexturedRect(-80, -20, 160, 160)

			draw.SimpleText("You are using to much power!", "BM2GeneratorFont", 0, 170, Color(0,0,0, 255), 1, 1)
			draw.SimpleText("You are using to much power!", "BM2GeneratorFont", -1, 170 - 1, Color(255,255,255, 255), 1, 1)

			draw.SimpleText("Please disconnect some devices or find anouther power source.", "BM2GeneratorFont", 0, 170 + 35, Color(0,0,0, 255), 1, 1)
			draw.SimpleText("Please disconnect some devices or find anouther power source.", "BM2GeneratorFont", -1, 170 - 1 + 35, Color(255,255,255, 255), 1, 1)

		end
	cam.End3D2D()
end
--addons/module_bitminers2_extras/lua/entities/bm2_large_fuel/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2/lua/entities/bm2_power_lead/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

end

function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2/lua/entities/bm2_power_lead/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Power Lead"
ENT.Spawnable = true
ENT.Category = "Запрещено"


--addons/module_bitminers2_extras/lua/entities/bm2_solar_cable_otherend/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"

ENT.PrintName = "Solar Cable Other End"
ENT.Spawnable = false
ENT.Category = "Запрещено"

function ENT:SetupDataTables()

end
--addons/module_bitminers2_extras/lua/entities/bm2_solarconverter/cl_init.lua:
include("shared.lua")

surface.CreateFont( "BM2GeneratorFont", {
	font = "Roboto Lt", 
	extended = false,
	size = 40,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local solarMaterial = Material("materials/bitminers2/ui/solar-panel.png", "noclamp smooth")
local outputMaterial = Material("materials/bitminers2/ui/output.png", "noclamp smooth")
local warningMaterial = Material("materials/bitminers2/ui/warning.png", "noclamp smooth")

local white = Color(255,255,255,255)
local black = Color(0,0,0,255)

function ENT:DrawPowerWarning()
	--Draw the warning
	surface.SetMaterial(warningMaterial)
	surface.SetDrawColor(white)
	surface.DrawTexturedRect(-80, -300, 160, 160)

	draw.SimpleText("Can't Outout enough power!", "BM2GeneratorFont", 0, -110, black, 1, 1)
	draw.SimpleText("Can't Outout enough power!", "BM2GeneratorFont", -1, -111, white, 1, 1)

	draw.SimpleText("Connect more solar panels or disconnect some bitminers!", "BM2GeneratorFont", 0, -75, black, 1, 1)
	draw.SimpleText("Connect more solar panels or disconnect some bitminers!", "BM2GeneratorFont", -1, -76, white, 1, 1)
end

function ENT:DrawSolarWarning()
	surface.SetMaterial(warningMaterial)
	surface.SetDrawColor(white)
	surface.DrawTexturedRect(-80, -60, 160, 160)

	draw.SimpleText("No connected solar panels!", "BM2GeneratorFont", 0, 170, black, 1, 1)
	draw.SimpleText("No connected solar panels!", "BM2GeneratorFont", -1, 171, white, 1, 1)

	draw.SimpleText("Please connect some solar panels.", "BM2GeneratorFont", 0, 170 - 35, black, 1, 1)
	draw.SimpleText("Please connect some solar panels.", "BM2GeneratorFont", -1, 170 - 34, white, 1, 1)
end

function ENT:DrawPowerUsed(amountUsed, maximum, color, alpha)
	surface.SetMaterial(outputMaterial)
	surface.SetDrawColor(Color(255,165,0, 255 * alpha))
	surface.DrawTexturedRect(-196,74, 56, 56)

	draw.RoundedBox(4, -130, 74, 330, 52, Color(36,36,36,  255 * alpha))
	draw.RoundedBox(2, -128, 76, 326, 52 - 4, Color(15,15,15, 255 * alpha))
	draw.RoundedBox(2, -128, 76, 326 * math.Clamp(maximum > 0 and amountUsed/maximum or 0, 0.0, 1.0), 52 - 4, color)
	draw.SimpleText(amountUsed.."/"..maximum.."W", "BM2GeneratorFont", 45, 24 + 76, Color(0,0,0, 255 * alpha), 1, 1)
	draw.SimpleText(amountUsed.."/"..maximum.."W", "BM2GeneratorFont", 44, 24 + 75, Color(255,255,255, 255 * alpha), 1, 1)
end

function ENT:DrawConnectedSolarPanels(alpha)
	surface.SetMaterial(solarMaterial)
	surface.SetDrawColor(Color(255,165,0, 255 * alpha))
	surface.DrawTexturedRect(-200 + 4,4, 56, 56)

	draw.RoundedBox(4, -130, 4 , 330, 52, Color(36,36,36,  255 * alpha))
	draw.RoundedBox(2, -128, 6 , 326, 52 - 4, Color(15,15,15, 255 * alpha))
	draw.RoundedBox(2, -128, 6 , 326 * (self:GetConnectedPanels()/10), 52 - 4, Color(255,165,0,  255 * alpha))
	draw.SimpleText(self:GetConnectedPanels().."/10", "BM2GeneratorFont", 45, 24 + 6, Color(0,0,0, 255 * alpha), 1, 1)
	draw.SimpleText(self:GetConnectedPanels().."/10", "BM2GeneratorFont", 44, 24 + 5, Color(255,255,255, 255 * alpha), 1, 1)
end

function ENT:DrawTranslucent()
	self:DrawModel()

	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 122500 then
		self.cam2d3dAng = LerpAngle(7 * FrameTime(), self.cam2d3dAng ~= nil and self.cam2d3dAng or Angle(0,0,0), Angle(0,LocalPlayer():GetAngles().y - 90,90))

		--Cam 2D3D for drawing infomation
		local ang = self:GetAngles()
		local pos = self:GetPos() + Vector(0,0,35)

		local alpha = 1 - math.Clamp((LocalPlayer():GetPos():DistToSqr(self:GetPos()) / (350 * 350)) * 1.21, 0, 1)

		cam.Start3D2D(pos, self.cam2d3dAng, 0.05)
			if not self:GetShowNoConnectedSolarWarning() then
				draw.RoundedBox(8,-200, -10 , 410, 75 * 2 ,Color(0,0,0,100 * alpha))

				self:DrawConnectedSolarPanels(alpha)

				local powerUsed = self:GetPowerConsumpsion()
				local powerAvailable = self:GetMaxPowerConsumpsion()

				local color = powerUsed > powerAvailable and Color(255,40,20,255 * alpha) or Color(255,165,0,255*alpha)

				self:DrawPowerUsed(powerUsed, powerAvailable, color, alpha)

				if powerUsed > powerAvailable then
					self:DrawPowerWarning()
				end
			else
				self:DrawSolarWarning()
			end
		cam.End3D2D()
	end
end
--addons/ent_ammobox/lua/entities/box_armor/cl_init.lua:
include("shared.lua")

local color_bright = Color(50,50,50)

function ENT:Draw()

    local ply = LocalPlayer()
    local distSqr = 160000
    local entpos = self:GetPos()
    
    if ply:GetPos():DistToSqr( entpos ) > distSqr then return end

	self:DrawModel()
	
	local pos, ang = LocalToWorld(Vector(16, -15, 30), Angle(0, 90, 90), entpos, self:GetAngles())
	
	cam.Start3D2D(pos, ang, 0.3)	

	draw.RoundedBox(4,-3,-9,100,20,color_bright)
	draw.SimpleText("Снаряжение", "Trebuchet18", 0, 0, color_white,0,1) 

	cam.End3D2D()	
end
--addons/module_bank/lua/entities/clicker_safe_bank.lua:
AddCSLuaFile()

ENT.Type = 'anim'
ENT.Base = 'clicker_safe'
ENT.PrintName = 'Хранилище банкира'
ENT.Author = 'WayZer\'s Role Play'
ENT.Category = 'Запрещено'
ENT.Freeze = true
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:IsOwnedBy(ply)
    return ply:Team() == TEAM_BANK
end
--addons/ent_drugz/lua/entities/durgz_cocaine/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Кокаин"
ENT.Category = "Разрешено"
ENT.Model = "models/cocn.mdl"
--addons/ent_drugz/lua/entities/durgz_mushroom/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Грибы"
ENT.Category = "Запрещено"
ENT.Model = "models/cocn.mdl"
--addons/ent_drugz/lua/entities/durgz_water/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Вода"
ENT.Category = "Запрещено"
ENT.Model = "models/drug_mod/the_bottle_of_water.mdl"
--addons/module_meth/lua/entities/eml_gas/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont1", {
	font = "Arial",
	size = 15,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
	self.emitTime = CurTime();
	self.gasPlace = ParticleEmitter(self:GetPos());
end;

local dist = 250000

function ENT:Think()
	local ply = LocalPlayer()
	local selfpos = self:GetPos()

	if ply:GetPos():DistToSqr(selfpos) > dist then 
		self:SetNextClientThink(CurTime() + 1)
		return true
	end

	local gasPos = selfpos+(self:GetUp()*28), selfpos+(self:GetUp()*42);
	if (self:GetMethAmount()>0) then
		if (self.emitTime < CurTime()) then
			if (self:GetOpen()) then
				local smoke = self.gasPlace:Add("particle/smokesprites_000"..math.random(1,9), gasPos);
				smoke:SetVelocity(self:GetUp()*128);
				smoke:SetDieTime(math.Rand(0.6, 1.3));
				smoke:SetStartAlpha(math.Rand(150, 200));
				smoke:SetEndAlpha(0);
				smoke:SetStartSize(math.random(0, 5));
				smoke:SetEndSize(math.random(16, 18));
				smoke:SetRoll(math.Rand(180, 480));
				smoke:SetRollDelta(math.Rand(-3, 3));
				smoke:SetColor(255, 255, 255);
				smoke:SetGravity(Vector(0, 0, 10));
				smoke:SetAirResistance(256);
				self.emitTime = CurTime() + .1;
			end;
		end;			
	end;

	self:SetNextClientThink(CurTime() + 0.3)
	return true
end;

local laser = Material("cable/cable")
function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end

	local ang = self:GetAngles()

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), 0);
	ang:RotateAroundAxis(ang:Right(), -90);
	
	local gasColor = Color(255, 222, 0, 100);
	
	if (!self:GetOpen()) then
		gasColor = Color(255, 222, 0, 100);
	else
		gasColor = Color(255, 94, 0, 100);
	end;
	
	if ply:GetPos():Distance(pos) < EML_DrawDistance then
		render.SetMaterial(laser);
		render.DrawBeam(pos+(self:GetUp()*28), pos+(self:GetUp()*42), 1, 1, 1, Color(255, 255, 255, 255));
	
		cam.Start3D2D(pos+ang:Up()*4.75, ang, 0.1)
				surface.SetDrawColor(Color(0, 0, 0, 200));
				surface.DrawRect(-176, -12, 450, 24)
			
				surface.SetDrawColor(gasColor);
				surface.DrawRect(-173, -9, math.Round((self:GetMethAmount()*444)/self:GetMaxAmount()), 18)	
				draw.SimpleTextOutlined(math.Round((self:GetMethAmount()*100)/self:GetMaxAmount()).."% ("..self:GetMethAmount().."/"..self:GetMaxAmount()..")", "methFont1", -170, -7, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1, Color(25, 25, 25, 200));
	
		cam.End3D2D()	
	end;
end;

--addons/module_meth/lua/entities/eml_iodine/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Йод";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
end
--addons/module_meth/lua/entities/eml_jar/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Бутылка";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
    self:NetworkVar("Int", 2, "Macid")
    self:NetworkVar("Int", 3, "Iodine")
    self:NetworkVar("Int", 4, "Water")
    self:NetworkVar("Int", 5, "Progress")
    self:NetworkVar("Int", 6, "IntStatus")
    self:NetworkVar("String", 0, "Status")
end
--addons/module_meth/lua/entities/eml_pot/cl_init.lua:
include("shared.lua");

function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end

	local ang = self:GetAngles()
	local macidColor = Color(160, 221, 99, 255);
	local sulfurColor = Color(243, 213, 19, 255);
	
	local potTime = "Time: "..self:GetTime().."s";
	
	if (self:GetIntStatus() == 0) then
		potTime = "Time: "..self:GetTime().."s";
	elseif (self:GetIntStatus() == 1) then	
		potTime = "Ready! Use to extract!";
	end;
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.10)
			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-64, -38, 128, 96);		
		cam.End3D2D();
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.055)
			draw.SimpleTextOutlined("Красный фосфор", "methFont", 0, -56, Color(175, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, -54, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-104, -32, 204, 24);			
			surface.SetDrawColor(Color(175, 0, 0, 200));
			surface.DrawRect(-101.5, -30, math.Round((self:GetTime()*198)/self:GetMaxTime()), 20);		
			
			draw.SimpleTextOutlined("Ингридиенты", "methFont", -101, 8, Color(175, 0, 0, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, 10, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			if (self:GetMacid()==0) then
				macidColor = Color(100, 100, 100, 255);
			else
				macidColor = Color(160, 221, 99, 255);
			end;
			
			if (self:GetSulfur()==0) then
				sulfurColor = Color(100, 100, 100, 255);
			else
				sulfurColor = Color(243, 213, 19, 255);
			end;			
			draw.SimpleTextOutlined("Соляная кислота ("..self:GetMacid()..")", "methFont", -101, 38, macidColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Жидкий сульфур ("..self:GetSulfur()..")", "methFont", -101, 68, sulfurColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));				
		cam.End3D2D();	
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.035)		
			draw.SimpleTextOutlined(potTime, "methFont", -152, -32, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));		
		cam.End3D2D();		
		
	end;
end;


--addons/module_meth/lua/entities/eml_stove/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Печь";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 1, "GasStorage")
    self:NetworkVar("Int", 2, "GasStorageMax")
    self:NetworkVar("Bool", 0, "Explode")
    self:NetworkVar("Bool", 1, "FirePlace1")
    self:NetworkVar("Bool", 2, "FirePlace2")
    self:NetworkVar("Bool", 3, "FirePlace3")
    self:NetworkVar("Bool", 4, "FirePlace4")
end
--addons/module_meth/lua/entities/eml_water/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	local waterColor = EML_Water_Color;
	
	if (self:GetMethAmount()>0) then
		waterColor = EML_Water_Color;
	else
		waterColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos+ang:Up()*3.25, ang, 0.06)
			draw.SimpleTextOutlined("Вода", "methFont", 0, 0, waterColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetMethAmount().."l", "methFont", 0, 24, waterColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*3.25, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-96, -8, 152, 16);
			
			surface.SetDrawColor(EML_Water_Color);
			surface.DrawRect(-94, -6, math.Round((self:GetMethAmount()*148)/self:GetMaxAmount()), 12);				
		cam.End3D2D();
	end;
		
end;
--addons/module_meth/lua/entities/eml_water/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Вода";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;


function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
end
--addons/weapon_paint/lua/entities/ent_graffiti/cl_init.lua:
include('shared.lua')
local a = Vector(-48, -48, 0)
local b = Vector(48, -48, 0)
local c = Vector(48, 48, 0)
local d = Vector(-48, 48, 0)
local e
local f = 0

local tocolor = function(s)
    s = s:gsub("#", "")
    local r, g, b = tonumber("0x" .. s:sub(1, 2)), tonumber("0x" .. s:sub(3, 4)), tonumber("0x" .. s:sub(5, 6))
    if r and g and b then return r, g, b end
end

local coltostring = function(c)
    local col = string.format("%x", (c.r * 0x10000) + (c.g * 0x100) + c.b):upper()

    if string.len(col) ~= 6 then
        for k = 1, 6 - string.len(col) do
            col = col .. '0'
        end
    end

    return col
end

function ENT:Initialize()
    timer.Simple(1, function()
        self.LocalPlayerOwned = FPP.entGetOwner(self) == LocalPlayer()
    end)

    self:SetRenderMode(RENDERMODE_TRANSCOLOR)
    self:SetNoDraw(true)
    self:SetColor(Color(255, 255, 255, 0))

    self.fitiMesh = Mesh()
    mesh.Begin(self.fitiMesh, MATERIAL_QUADS, 1)
    mesh.Quad(a, b, c, d)
    mesh.End()

    self:CreateCanvas()
    self.Received = false
    self.Pixels = {}
end

graffitiPool = graffitiPool or {}

function ENT:OnRemove()
    timer.Simple(0, function()
        if IsValid(self) then return end

        if e == self then
            e = nil
        end

        graffitiPool[#graffitiPool + 1] = self.canvas
    end)
end

function ENT:CreateCanvas()
    if #graffitiPool == 0 then
        local g = self:GetPos()
        local h = tostring(math.floor(SysTime() * 1000)) .. tostring(self:EntIndex())
        local i = "Graffiti:" .. h
        local j = GetRenderTarget(i, 256, 256, true)

        local k = CreateMaterial(i, "VertexLitGeneric", {
            ["$translucent"] = 1,
            ["$vertexcolor"] = 1,
            ["$vertexalpha"] = 1,
            ["$basetexture"] = j:GetName(),
            ["$flashlightnolambert"] = 1
        })

        self.canvas = {
            rt = j,
            mat = k,
            name = i
        }
    else
        self.canvas = graffitiPool[#graffitiPool]
        graffitiPool[#graffitiPool] = nil
    end

    render.PushRenderTarget(self.canvas.rt)
    render.Clear(0, 0, 0, 0)
    render.PopRenderTarget()
end

local function InSight(ent)
    if ent:GetPos():DistToSqr(LocalPlayer():GetPos()) < 250000 then return LocalPlayer():IsLineOfSightClear(ent:GetPos()) end
    return false
end

local K = Material("color", "smooth")

function ENT:Draw()
    if not InSight(self) then return end
    render.OverrideDepthEnable(true, false)
    render.OverrideColorWriteEnable(true, false)
    self:DrawModel()
    render.OverrideColorWriteEnable(false, false)
    render.OverrideDepthEnable(false, false)

    if LocalPlayer().HoveredGraffiti == self or LocalPlayer().Placing then
        render.SetColorMaterial()
        render.DrawQuadEasy(self:GetPos(), self:GetAngles():Up() * -1, 96, 96, Color(255, 255, 255, 15), 0)
    end

    local B = self:GetCanvas().mat
    render.SuppressEngineLighting(true)
    cam.PushModelMatrix(self:GetWorldTransformMatrix())
    render.SetMaterial(B)
    self.fitiMesh:Draw()
    cam.PopModelMatrix()
    render.SuppressEngineLighting(false)
    local C = LocalPlayer().HoveredGraffiti == self

    if C and LocalPlayer():KeyDown(IN_SPEED) then
        C = SysTime() % 0.6 > 0.3
        D = 1
    end

    if C then
        render.SetColorMaterial()
        render.DrawSphere(LocalPlayer().HoveredGraffitiTrace.HitPos, .5, 6, 6, tocolor(self.CurrentColor), 1)
    end
end

local function E(F, G)
    local H = F.name .. SysTime()

    hook.Add('PostRender', H, function()
        hook.Remove('PostRender', H)
        local I = ScrW()
        local J = ScrH()
        render.PushRenderTarget(F.rt)
        render.ClearDepth()
        render.SetViewPort(0, 0, F.mat:Width(), F.mat:Height())
        cam.Start2D()
        G(F.mat:Width(), F.mat:Height())
        cam.End2D()
        render.SetViewPort(0, 0, I, J)
        render.PopRenderTarget()
    end)
end

function ENT:Paint(L, M, N)
    if self.lastPaint then
        if self.lastPaint[1] == L and self.lastPaint[2] == M and self.lastPaint[3] == N then return end
    end

    self.lastPaint = {L, M, N}

    local F = self:GetCanvas()

    E(F, function(O, P)
        surface.SetMaterial(K)
        surface.SetDrawColor(tocolor(N))
        surface.DrawTexturedRect(L - 2, M - 2, 4, 4)
    end)

    if not F.sendTimeout then
        F.sendTimeout = CurTime()
    end

    if not F.sendData then
        F.sendData = {}
    end

    F.sendData[#F.sendData + 1] = {M * 256 + L, N}

    self:SavePixels(L, M, N, 5)
    self:TickSend()
end

function ENT:Erase(L, M)
    local F = self:GetCanvas()

    if not F.sendTimeout then
        F.sendTimeout = CurTime()
    end

    if not F.sendData then
        F.sendData = {}
    end

    F.sendData[#F.sendData + 1] = {M * 256 + L}

    E(F, function(O, P)
        local Q = L
        local R = M
        local S = 5
        local T = math.floor((S - 1) / 2)

        for L = Q - T, Q + T do
            for M = R - T, R + T do
                local U = M * 256 + L
                if U < 1 or U > 65535 then continue end
                self.Pixels[U - 1] = nil

                if (L - Q) ^ 2 + (M - R) ^ 2 <= (S / 2) ^ 2 then
                    render.SetViewPort(L, M, 1, 1)
                    render.Clear(0, 0, 0, 0)
                    render.SetViewPort(0, 0, O, P)
                end
            end
        end
    end)

    self:TickSend()
end

function ENT:Load(h)
    local q = 'graffiti/' .. h
    local r = {}
    local n = file.Open(q, "r", "DATA")
    local parts = n:Read()
    local raw = string.Split(parts, '|')
    local colors = util.JSONToTable(raw[2])

    for k, v in pairs(string.Split(raw[1], ' ')) do
        if v ~= '' then
            r[k] = v
        end
    end

    n:Close()
    net.Start('graffiti.PreLoadColors')
    net.WriteEntity(self)
    net.WriteTable(colors)
    net.SendToServer()
    net.Start("graffiti.Load")
    net.WriteEntity(self)

    for o = 1, 256 * 256 do
        if r[o] then
            net.WriteUInt(1, 2)
            net.WriteUInt(r[o], 5)
        else
            net.WriteUInt(0, 2)
        end
    end

    net.SendToServer()
end

net.Receive('graffiti.PreLoadColors', function()
    local ent = net.ReadEntity()
    ent.PreLoadColors = net.ReadTable()
end)

net.Receive('graffiti.Load', function()
    local ent = net.ReadEntity()
    local _ = {}

    for k = 1, 256 * 256 do
        local a = net.ReadUInt(2)
        local b

        if tobool(a) then
            b = net.ReadUInt(5)

            _[#_ + 1] = {k, ent.PreLoadColors and ent.PreLoadColors[b] or 'FFFFFF'}
        end
    end

    ent:NetPaint(_)
end)

local function save(h, m)
    if not file.IsDir("graffiti", "DATA") then
        file.CreateDir("graffiti")
    end

    local colors = {}
    local n = file.Open("graffiti/" .. h .. ".txt", "w", "DATA")
    local revertColors = {}

    for o = 1, 256 * 256 do
        if m[o] then
            if not colors[m[o]] then
                colors[m[o]] = table.insert(revertColors, m[o])
            end

            n:Write(colors[m[o]])
            n:Write(' ')
        else
            n:Write(' ')
        end
    end

    n:Write('|' .. util.TableToJSON(revertColors))
    n:Close()
end

function ENT:Save(h)
    save(h, self.Pixels)
end

function ENT:NetPaint(V, W)
    if self.Pixels == nil then
        self.Pixels = {}
    end

    local F = self:GetCanvas()

    E(F, function(O, P)
        if not self.Pixels then
            self.Pixels = {}
        end

        surface.SetMaterial(K)

        if W then
            render.Clear(0, 0, 0, 0)
            self.Pixels = {}
        end

        for z, A in ipairs(V) do
            self.Pixels[A[1]] = #A == 2 and A[2] or nil
            local L = A[1] % 256
            local M = math.floor(A[1] / 256)

            if #A == 2 then
                if tocolor(A[2]) then
                    surface.SetDrawColor(tocolor(A[2]))
                end

                surface.DrawTexturedRect(L - 2, M - 2, 4, 4)
            else
                local Q = L
                local R = M
                local S = 5
                local T = math.floor((S - 1) / 2)

                for L = Q - T, Q + T do
                    for M = R - T, R + T do
                        local U = M * 256 + L
                        if U < 1 or U > 65535 then continue end

                        if (L - Q) ^ 2 + (M - R) ^ 2 <= (S / 2) ^ 2 then
                            render.SetViewPort(L, M, 1, 1)
                            render.Clear(0, 0, 0, 0)
                            render.SetViewPort(0, 0, O, P)
                        end
                    end
                end
            end
        end
    end)
end

function ENT:Think()
    if not self.Received and not IsValid(e) and f <= CurTime() then
        e = self
        net.Start("graffiti.FullUpdate")
        net.WriteEntity(self)
        net.SendToServer()
    end

    self:TickSend()
end

function ENT:TickSend()
    local F = self:GetCanvas()
    if not F.sendTimeout then return end

    if CurTime() - F.sendTimeout > 1 or #F.sendData == 128 then
        net.Start("graffiti.DeltaUpdate")
        net.WriteEntity(self)
        net.WriteUInt(#F.sendData - 1, 8)
        local lastColor

        for z, A in ipairs(F.sendData) do
            net.WriteUInt(A[1], 16)

            if #A == 2 then
                net.WriteUInt(A[2] ~= lastColor and 1 or 2, 2)

                if A[2] ~= lastColor then
                    net.WriteString(A[2])
                end

                lastColor = A[2]
            else
                net.WriteUInt(0, 2)
            end
        end

        net.SendToServer()
        F.sendTimeout = nil
        F.sendData = nil
    end
end

function ENT:SavePixels(Q, R, N, S)
    local T = math.floor((S - 1) / 2)

    for L = Q - T, Q + T do
        for M = R - T, R + T do
            local U = M * 256 + L
            if U < 1 or U > 65535 then continue end

            if (L - Q) ^ 2 + (M - R) ^ 2 <= (S / 2) ^ 2 then
                self.Pixels[U] = N
            end
        end
    end
end

net.Receive("graffiti.FullUpdate", function(X)
    local Y = net.ReadEntity()
    if not IsValid(Y) or Y:GetClass() ~= "ent_graffiti" then return end
    Y.LocalPlayerOwned = net.ReadBool()
    Y.Received = true

    if e == Y then
        e = nil
    end

    local _ = {}

    for o = 1, 256 * 256 do
        local a = net.ReadBool()

        if a then
            local b = net.ReadUInt(5)

            _[#_ + 1] = {o, Y.PreLoadColors and Y.PreLoadColors[b]}
        end
    end

    Y:NetPaint(_, true)
    f = CurTime() + 1
end)

net.Receive("graffiti.DeltaUpdate", function(X)
    local Y = net.ReadEntity()
    if not IsValid(Y) or Y:GetClass() ~= "ent_graffiti" then return end
    local _ = {}
    local a0 = net.ReadUInt(8) + 1
    local lastColor

    for o = 1, a0 do
        local pixel = net.ReadUInt(16)
        local a1 = net.ReadUInt(2) -- Есть ли пиксель
        local a2

        if a1 == 1 then
            a2 = (a1 ~= 0 and a1 ~= 2) and net.ReadString()
            lastColor = a2
        elseif a1 == 2 then
            a2 = lastColor
        end

        _[#_ + 1] = {pixel, a2 and a2 or nil}
    end

    Y:NetPaint(_)
end)

concommand.Add("reloadGraffiti", function(a3, a4, a5)
    if LocalPlayer():GetUserGroup() ~= 'superadmin' then return end
    local Y = a3:GetEyeTrace().Entity

    if IsValid(Y) and Y:GetClass() == "ent_graffiti" then
        e = Y
        net.Start("graffiti.FullUpdate")
        net.WriteEntity(Y)
        net.SendToServer()
    end
end)

net.Receive('graffiti.OpenMenu', function()
    local ent = net.ReadEntity()

    if ent.OpenSettings then
        ent:OpenSettings()
    end
end)

local function ColorToCMYK(col)
    local K = math.max(col.r, col.g, col.b)
    local k = 255 - K

    return (K - col.r) / K, (K - col.g) / K, (K - col.b) / K, k
end

local color_formats = {
    ["rgb"] = {
        tostring = function(c)
            return string.format("%s, %s, %s", c.r, c.g, c.b)
        end,
        tocolor = function(s)
            local r, g, b = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)")
            if r and g and b then return Color(r, g, b) end
        end
    },
    ["hex"] = {
        tostring = function(c)
            return string.format("%x", (c.r * 0x10000) + (c.g * 0x100) + c.b):upper()
        end,
        tocolor = function(s)
            s = s:gsub("#", "")
            local r, g, b = tonumber("0x" .. s:sub(1, 2)), tonumber("0x" .. s:sub(3, 4)), tonumber("0x" .. s:sub(5, 6))
            if r and g and b then return Color(r, g, b) end
        end
    },
    ["hsl"] = {
        tostring = function(c)
            local h, s, l = ColorToHSL(c)

            return string.format("%s, %s, %s", math.Round(h, 2), math.Round(s, 2), math.Round(l, 2))
        end,
        tocolor = function(s)
            local h, s, l = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)")
            if h and s and l then return HSLToColor(h, s, l) end
        end
    },
    ["hsv"] = {
        tostring = function(c)
            local h, s, v = ColorToHSV(c)

            return string.format("%s, %s, %s", math.Round(h, 2), math.Round(s, 2), math.Round(v, 2))
        end,
        tocolor = function(s)
            local h, s, v = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)")
            if h and s and v then return HSVToColor(h, s, v) end
        end
    },
    ["cmyk"] = {
        tostring = function(c)
            local c, m, y, k = ColorToCMYK(c)

            return string.format("%s, %s, %s, %s", math.Round(c, 1), math.Round(m, 1), math.Round(y, 1), math.Round(k, 1))
        end,
        tocolor = function(s)
            local c, m, y, k = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)[ ,]+([-x.%x]+)")
            if not (c and m and y and k) then return end
            local mk = 1 - k
            local r = 255 * (1 - c) * mk
            local g = 255 * (1 - m) * mk
            local b = 255 * (1 - y) * mk

            return Color(r, g, b)
        end
    }
}

function ENT:OpenSettings()
    local ent = self

    if IsValid(self.settingsFrame) then
        self.settingsFrame:Remove()
    end

    self.whitelistIDs = self.whitelistIDs or {}
    local players = self.whitelistIDs or {}
    local frame = vgui.Create('DFrame')
    frame:SetSize(400, 600)
    frame:MakePopup()
    frame:Center()
    frame:SetTitle('Настройки')
    frame:SetDraggable(false)
    frame:SetSizable(false)
    frame:SetIcon('icon16/wrench.png')
    local sheet = vgui.Create('DPropertySheet', frame)
    sheet:Dock(FILL)
    local sett = vgui.Create('Panel', sheet)
    sett:Dock(FILL)
    local panentry = vgui.Create("DScrollPanel", sett)

    function panentry:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 80))
    end

    panentry:Dock(FILL)
    panentry:SetTall(370)

    local function fillentry()
        panentry:Clear()

        if #file.Find('graffiti/*.txt', 'DATA') == 0 then
            local lable = vgui.Create('DLabel', panentry)
            lable:Dock(TOP)
            lable:SetText('Здесь должны быть сохранённые граффити, но их нет :(')
            lable:SetContentAlignment(5)

            return
        end

        for k, v in pairs(file.Find('graffiti/*.txt', 'DATA')) do
            local btn = vgui.Create('DButton', panentry)
            btn:Dock(TOP)
            btn:DockMargin(0, 0, 0, 6)
            btn:SetText(string.Replace(v, '.txt', ''))

            function btn:DoClick()
                ent:Load(v)
            end

            function btn:DoRightClick()
                local Menu = DermaMenu()

                Menu:AddOption("Удалить?", function()
                    Derma_Query('Вы точно хотите удалить?', '', 'Да', function()
                        file.Delete('graffiti/' .. v, 'DATA')
                        fillentry()
                    end, 'Нет')
                end)

                Menu:Open()
            end
        end
    end

    fillentry()
    local savepan = vgui.Create('Panel', sett)
    savepan:Dock(BOTTOM)
    savepan:SetTall(40)
    savepan:DockMargin(0, 10, 0, 0)
    local text = vgui.Create('DTextEntry', savepan)
    text:Dock(TOP)
    text:SetPlaceholderText('Введите название сохранения')

    text.AllowInput = function(s, char)
        return not ('1234567890qwertyuiopasdfghjklzxcvbnm-_()'):find(char)
    end

    local sav = vgui.Create('DButton', savepan)
    sav:Dock(TOP)
    sav:SetText('Сохранить')

    function sav:DoClick()
        if #text:GetValue() < 1 then
            notification.AddLegacy('Длина названия должна быть больше одного символа', NOTIFY_ERROR, 4)

            return
        end

        ent:Save(text:GetValue())
        fillentry()
    end

    sheet:AddSheet('Настройки полотна', sett, 'icon16/wrench.png')
    local lists = vgui.Create('Panel', sheet)
    local pList = vgui.Create('DCategoryList', lists)
    pList:Dock(FILL)
    local confirm = vgui.Create('DButton', lists)
    confirm:Dock(BOTTOM)
    confirm:SetTall(25)
    confirm:SetText('Подтвердить')
    confirm:SetIcon('icon16/accept.png')

    confirm.DoClick = function()
        net.Start('graffiti.UpdateShare')
        net.WriteEntity(self)
        net.WriteTable(players)
        net.SendToServer()
        self.whitelistIDs = players
        frame:Close()
    end

    local plys = {}

    for _, v in player.Iterator() do
        local t = v:GetNetVar('disguised') and v:GetNetVar('disguise_team') or v:Team()
        plys[t] = plys[t] or {}
        table.insert(plys[t], v)
    end

    for _, cat in pairs(DarkRP.getCategories().jobs) do
        for _, job in pairs(cat.members) do
            local id = job.team
            if not plys[id] then continue end
            local collapsible = pList:Add(job.name)
            local main = vgui.Create('DListLayout')
            collapsible:SetContents(main)

            for _, ply in ipairs(plys[id]) do
                local pan = vgui.Create('DButton')
                pan:SetText('')

                pan.Paint = function(s, w, h)
                    if s.selected then
                        draw.RoundedBox(2, 0, 0, w, h, Color(0, 150, 0))
                    end
                end

                pan:SetTall(40)

                if self.whitelistIDs[ply:SteamID()] == true then
                    pan.selected = true
                end

                pan.DoClick = function()
                    if pan.selected then
                        players[ply:SteamID()] = nil
                        pan.selected = false
                    else
                        players[ply:SteamID()] = true
                        pan.selected = true
                    end
                end

                local icon = vgui.Create('SpawnIcon', pan)
                icon:Dock(LEFT)
                icon:SetWide(40)
                icon:SetModel(ply:GetModel())
                icon.DoClick = pan.DoClick
                local label = vgui.Create('DLabel', pan)
                label:Dock(FILL)
                label:SetFont('Trebuchet24')
                label:SetText(ply:Name())
                main:Add(pan)
            end
        end
    end

    sheet:AddSheet('Доступ к полотну', lists, 'icon16/user.png')
    self.settingsFrame = frame
end

net.Receive('graffiti.UpdateShare', function()
    local ent = net.ReadEntity()
    local access = net.ReadTable()
    ent.LocalPlayerOwned = access[LocalPlayer():SteamID()]
end)
--addons/module_css2/lua/entities/ent_smokegrenade/shared.lua:

//ENT.Base = "base_entity"
ENT.Type = "anim"

ENT.PrintName		= "SMOKE GRENADE"
ENT.Author			= "WORSHIPPER"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions		= ""


/*---------------------------------------------------------
Remove
---------------------------------------------------------*/
function ENT:OnRemove()
end

/*---------------------------------------------------------
PhysicsUpdate
---------------------------------------------------------*/
function ENT:PhysicsUpdate()
end

/*---------------------------------------------------------
PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data,phys)
	if data.Speed > 150 then
		self.Entity:EmitSound(Sound("SmokeGrenade.Bounce"))
	end
	
	local impulse = -data.Speed * data.HitNormal * .2 + (data.OurOldVelocity * -.4)
	phys:ApplyForceCenter(impulse)
end

--addons/tool_duplicator/lua/entities/gmod_contr_spawner/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
	self.BaseClass.Draw(self)
	self.Entity:DrawModel()
end

--addons/weapon_cracker/lua/entities/keypad_cracker_ent/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.PrintName = "KeyPad Cracker - Entity"
ENT.Author = "\\sqdAva"
ENT.Category = "Запрещённое"
ENT.Model = Model("models/weapons/w_c4.mdl")

function ENT:SetupDataTables()
    self:NetworkVar('Bool', 0, 'IsCracking')
end
--addons/tool_keypad/lua/entities/keypad_pattern/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Pattern Keypad"
ENT.Author = "Metamist"
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = Model("models/props_lab/keypad.mdl")
ENT.IsKeypad = true

ENT.STATUS_NONE = 0
ENT.STATUS_GRANTED = 1
ENT.STATUS_DENIED = 2

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "Status")
    self:NetworkVar("Int", 1, "GridWidth")
    self:NetworkVar("Int", 2, "GridHeight")
    self:NetworkVar("Int", 3, "Price")

    self:NetworkVar("String", 0, "Colors")

    if SERVER then
        self:SetGridWidth(3)
        self:SetGridHeight(3)
    end
end

function ENT:CanOpen(ply)
    local owner = FPP.entGetOwner(self)
    if owner == ply then return true end

    --if owner and owner.Buddies and owner.Buddies[ply] then return true end

    local whitelist = self:GetWhitelist()
    if whitelist.players[ply] or whitelist.teams[ply:Team()] then return true end

    return false
end

function ENT:InitializeShared()
    self.boxMax = self:OBBMaxs() * Vector(1, 1.25, 1)
    self.boxMin = self:OBBMins() * Vector(1, 1.25, 1)
end

function ENT:GetWhitelist()
    return self:GetNetVar('KeypadWhitelist') or {players = {}, teams = {}}
end

nw.Register('KeypadWhitelist')
    :Write(function(d)
        local send = {}
        for k, v in pairs(d.players) do
            if not IsValid(k) then continue end
            send[#send+1] = k
        end
        net.WriteUInt(#send, 8)
        for _, v in ipairs(send) do
            net.WriteEntity(v)
        end

        send = {}
        for k, v in pairs(d.teams) do
            if not RPExtraTeams[k] then continue end
            send[#send+1] = k
        end
        net.WriteUInt(#send, 7)
        for _, v in ipairs(send) do
            net.WriteUInt(v, 7)
        end
    end)
    :Read(function()
        local a = {
            players = {},
            teams = {},
        }

        for i=1, net.ReadUInt(8) do
            a.players[net.ReadEntity()] = true
        end
        for i=1, net.ReadUInt(7) do
            a.teams[net.ReadUInt(7)] = true
        end

        return a
    end)
--addons/module_phone/lua/entities/krede_wd_battery/shared.lua:
ENT.Type = "anim"
ENT.PrintName			= "Battery"
ENT.Author			= "Krede"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions			= ""
ENT.Category        = "Запрещено"
ENT.Spawnable = true

/*---------------------------------------------------------
OnRemove
---------------------------------------------------------*/
function ENT:OnRemove()
end

/*---------------------------------------------------------
PhysicsUpdate
---------------------------------------------------------*/
function ENT:PhysicsUpdate()
end
--addons/module_chocolate/lua/entities/lucid_choc_cocoa.lua:
--Made by ThatCatGuy
--https://github.com/ThatCatGuy
--https://steamcommunity.com/sharedfiles/filedetails/?id=2195413561
--Stupidly rewritten by OverlordAkise (has alzheimers)

AddCSLuaFile()
ENT.Type = 'anim'
 
ENT.PrintName = "Cocoa"
ENT.Category = "Chocolate Maker"
ENT.Author = "OverlordAkise"
ENT.Purpose = "Make Chocolate"
ENT.Instructions = "N/A"
ENT.Model = "models/props_junk/garbage_glassbottle001a.mdl"

ENT.Spawnable = true
ENT.AdminSpawnable = true

if SERVER then 
  function ENT:Initialize()
    self:SetModel(self.Model)
    self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
    self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
    self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    local phys = self:GetPhysicsObject()
    if (phys:IsValid()) then
      phys:Wake()
    end
  end
  
else
  --CLIENT
  function ENT:Draw()
      self:DrawModel() 
  end

end
--addons/module_samogon/lua/entities/mn_dirt/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Земля"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/module_samogon/lua/entities/mn_ggrain/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_ggrain/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Урожай пшеницы"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/weapon_hover/lua/entities/modulus_hoverboard_hull/cl_init.lua:

include( "shared.lua" )

function ENT:Draw()

	self:DrawModel()

end

--addons/weapon_hover/lua/entities/modulus_hoverboard_hull/shared.lua:

ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.Spawnable = false

--addons/ent_moneyclickers/lua/entities/money_clicker/cl_init.lua:
include("shared.lua")

local base_gmodentity = scripted_ents.Get("base_anim")

local function createFont(name, size)
    surface.CreateFont(name, {
        font = "Roboto",
        antialias = true,
        size = size,
        weight = 500,
    })
end

createFont("MoneyClickerTitle", 48)
createFont("MoneyClickerTooltip", 35)
createFont("MoneyClickerMoney", 75)
createFont("MoneyClickerMoneySmall", 50)
createFont("MoneyClickerPoints", 75)
createFont("MoneyClickerPointsSmall", 50)
createFont("MoneyClickerMoneySide", 30)
createFont("MoneyClickerPointsSide", 30)
createFont("MoneyClickerName", 40)
createFont("MoneyClickerNameSide", 30)

createFont("MoneyClickerHealth", 30)
createFont("MoneyClickerHealthSide", 30)

local matHeat = Material("moneyclickers/heat")
local matWithdraw = Material("moneyclickers/creditcard")
local matHealth = Material("moneyclickers/health")
local matRepair = Material("moneyclickers/repair")
local matUpgradeAutoClick = Material("moneyclickers/upgrade_autoclick")
local matUpgradeClickPower = Material("moneyclickers/upgrade_clickpower")
local matUpgradeCooling = Material("moneyclickers/upgrade_cooling")
local matUpgradeStorage = Material("moneyclickers/upgrade_storage")

local surface_SetDrawColor = surface.SetDrawColor
local surface_DrawRect = surface.DrawRect
local surface_DrawTexturedRect = surface.DrawTexturedRect
local draw_DrawText = draw.DrawText

local table_insert = table.insert
local sin = math.sin
local cos = math.cos
local abs = math.abs
local max = math.max
local rad = math.rad
local floor = math.floor


local cvar_sound = CreateClientConVar('wrp_clickers_sound', '1', true)
waySettings.registerVar('wrp_clickers_sound', 'Включить звук кликеров', 'Игра', 'bool'):SetConVar('wrp_clickers_sound', TYPE_BOOL)
local function playSound(...)
    if not cvar_sound:GetBool() then return end

    surface.PlaySound(...)
end


local function lerpColor(a, b, x)
    a.r = a.r + (b.r - a.r) * x
    a.g = a.g + (b.g - a.g) * x
    a.b = a.b + (b.b - a.b) * x
    a.a = a.a + (b.a - a.a) * x

    return a
end

local function processFormattedTextData(data)
    local lines = {}
    local currLine = 1
    lines[currLine] = {}
    for j = 1, #data do
        local v = data[j]

        if v == nil then continue end

        if type(v) == "table" then
            lines[currLine] = lines[currLine] or {}
            lines[currLine][#lines[currLine] + 1] = v
        else
            local split = string.Explode("\n", tostring(v))
            for i, str in ipairs(split) do
                lines[currLine] = lines[currLine] or {}

                if #str > 0 then
                    lines[currLine][#lines[currLine] + 1] = str
                end

                if i ~= #split then
                    currLine = currLine + 1
                end
            end
        end
    end

    return lines
end

local function drawFormattedTextData(data, x, y, alpha, alignment)
    local tCurY = y
    local _, lineHeight = surface.GetTextSize("\n")
    local currColor = Color(255, 255, 255)
    for _, line in ipairs(data) do
        local totalStr = ""
        for _, dat in ipairs(line) do
            if type(dat) == "string" then
                totalStr = totalStr .. dat
            end
        end

        local tSubWidth, tSubHeight = surface.GetTextSize(totalStr)
        if alignment == TEXT_ALIGN_CENTER then
            surface.SetTextPos(x - tSubWidth / 2, tCurY)
        elseif alignment == TEXT_ALIGN_RIGHT then
            surface.SetTextPos(x - tSubWidth, tCurY)
        else
            surface.SetTextPos(x, tCurY)
        end

        for _, dat in ipairs(line) do
            if type(dat) == "string" then
                surface.SetTextColor(ColorAlpha(currColor, alpha))
                surface.DrawText(dat)
            else
                currColor = dat
            end
        end

        tCurY = tCurY + lineHeight / 2
    end
end

-- Thanks to Bobbleheadbob for the arc code, slightly modified to suit my needs.
local function precacheArc(cx,cy,radius,thickness,startang,endang,roughness)
    local triarc = {}
    -- local deg2rad = math.pi / 180

    -- Define step
    local roughness = max(roughness or 1, 1)
    local step = roughness

    -- Correct start/end ang
    local startang,endang = startang or 0, endang or 0

    if startang > endang then
        step = abs(step) * -1
    end

    -- Create the inner circle's points.
    local inner = {}
    local r = radius - thickness
    for deg=startang, endang, step do
        local rad = -rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx+(cos(rad)*r), cy+(-sin(rad)*r)
        table_insert(inner, {
            x=ox,
            y=oy,
            u=(ox-cx)/radius + .5,
            v=(oy-cy)/radius + .5,
        })
    end


    -- Create the outer circle's points.
    local outer = {}
    for deg=startang, endang, step do
        local rad = -rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx+(cos(rad)*radius), cy+(-sin(rad)*radius)
        table_insert(outer, {
            x=ox,
            y=oy,
            u=(ox-cx)/radius + .5,
            v=(oy-cy)/radius + .5,
        })
    end


    -- Triangulize the points.
    for tri=1,#inner*2 do -- twice as many triangles as there are degrees.
        local p1,p2,p3
        p1 = outer[floor(tri/2)+1]
        p3 = inner[floor((tri+1)/2)+1]
        if tri%2 == 0 then --if the number is even use outer.
            p2 = outer[floor((tri+1)/2)]
        else
            p2 = inner[floor((tri+1)/2)]
        end

        table_insert(triarc, {p3,p2,p1})
    end

    -- Return a table of triangles to draw.
    return triarc
end

-- Draws an arc on your screen.
-- startang and endang are in degrees,
-- radius is the total radius of the outside edge to the center.
-- cx, cy are the x,y coordinates of the center of the arc.
-- roughness determines how many triangles are drawn. Number between 1-360; 2 or 3 is a good number.
local function drawArc(cx,cy,radius,thickness,startang,endang,roughness,color)
    surface_SetDrawColor(color)
    local arc = precacheArc(cx,cy,radius,thickness,startang,endang,roughness)

    for k,v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

local function drawCircle(x, y, radius, seg, color)
    local cir = {}

    table_insert(cir, { x = x, y = y, u = 0.5, v = 0.5 })
    for i = 0, 360, seg do
        local a = rad(-i)
        table_insert(cir, { x = x + sin(a) * radius, y = y + cos(a) * radius, u = sin(a) / 2 + 0.5, v = cos(a) / 2 + 0.5 })
    end

    local a = rad(0) -- This is need for non absolute segment counts
    table_insert(cir, { x = x + sin(a) * radius, y = y + cos(a) * radius, u = sin(a) / 2 + 0.5, v = cos(a) / 2 + 0.5 })

    surface_SetDrawColor(color)
    surface.DrawPoly(cir)
end

local function rayPlaneIntersection(start, dir, pos, normal)
    local a = normal:Dot(dir)

    -- Check if the ray is aiming towards the plane
    -- (fail if it origin behind the plane, but that is checked later)
    if a < 0 then
        local b = normal:Dot(pos - start)

        --Check if the ray origin in front of plane
        if b < 0 then
            return start + dir * (b / a)
        end

    --Check if the ray is parallel to the plane
    elseif a == 0 then
        --Check if the ray origin inside the plane
        if normal:Dot(pos - start) == 0 then
            return start
        end
    end

    return false
end

local function buildTooltipData(...)
    local tooltip = { ... }
    local tooltipData = processFormattedTextData(tooltip)
    local tooltipString = ""
    for _, dat in ipairs(tooltip) do
        if type(dat) == "string" then
            tooltipString = tooltipString .. dat
        end
    end

    return {
        data = tooltipData,
        text = tooltipString
    }
end


local buttonMeta = {}
buttonMeta.__index = buttonMeta

buttonMeta.clicked = false
buttonMeta.clickX = 0
buttonMeta.clickY = 0
buttonMeta.alpha = 1
buttonMeta.hoverTime = 0
buttonMeta.clickTime = 0
buttonMeta.clickDuration = 0.3
buttonMeta.tooltipTime = 0
buttonMeta.showTooltip = true
buttonMeta.disabled = false

function buttonMeta:GetRadius()
    return math.sqrt((self.width * self.width / 4) + (self.height * self.height / 4))
end

function buttonMeta:SetTooltip(...)
    self.tooltipData = buildTooltipData(...)
end

function buttonMeta:OnClick() end

function buttonMeta:Think()
    if self.disabled then
        self.hovering = false
        return
    end

    local cx = self.x + self.width / 2
    local cy = self.y + self.height / 2

    local hovering = Vector(self.entity.cursorX, self.entity.cursorY, 0):Distance(Vector(self.x + self.width / 2, self.y + self.height / 2, 0)) < self:GetRadius() + 16
    if hovering and not self.hovering then
        playSound(MCLICKERS.SOUND_UI_HOVER)
    end
    self.hovering = hovering

    if hovering and LocalPlayer():KeyDown(IN_USE) and not self.oldUseDown then
        self.clicked = true
        self.clickTime = CurTime()
        self.clickX = self.entity.cursorX
        self.clickY = self.entity.cursorY

        playSound(MCLICKERS.SOUND_UI_CLICK)

        self:OnClick(self.clickX, self.clickY)
    end

    self.oldUseDown = LocalPlayer():KeyDown(IN_USE)
end

function buttonMeta:Paint(w, h) end

function buttonMeta:PaintOver(w, h)
    local cx = self.x + self.width / 2
    local cy = self.y + self.height / 2

    if self.hovering then
        self.hoverTime = self.hoverTime + (1 - self.hoverTime) * 0.05
    else
        self.hoverTime = self.hoverTime + (0 - self.hoverTime) * 0.05
    end

    if self.hoverTime > 0.01 then
        drawCircle(cx, cy, self:GetRadius() + 16, 16, Color(255, 255, 255, self.alpha * 20 * self.hoverTime))
    end

    if self.clicked then
        local clickFract = math.Clamp((CurTime() - self.clickTime) / self.clickDuration, 0, 1)
        local animX = self.clickX + (cx - self.clickX) * clickFract
        local animY = self.clickY + (cy - self.clickY) * clickFract
        drawCircle(animX, animY, (self:GetRadius() + 16) * clickFract, 24, Color(255, 255, 255, self.alpha * 50 * (1 - max(clickFract * 2 - 1, 0))))

        if CurTime() - self.clickTime >= self.clickDuration then
            self.clicked = false
            self.clickTime = 1
        end
    end

    if self.tooltipData and self.hovering and self.showTooltip then
        self.tooltipTime = self.tooltipTime + (1 - self.tooltipTime) * 0.05
    else
        self.tooltipTime = self.tooltipTime + (0 - self.tooltipTime) * 0.05
    end

    if self.tooltipTime > 0.01 then
        self.entity:DrawOverlayTooltip(self.x + self.width / 2, self.y + self.height / 2 + 10, "MoneyClickerTooltip", self.tooltipData, self.tooltipTime * self.alpha, TEXT_ALIGN_CENTER)
    end
end

function ENT:Initialize()
    base_gmodentity.Initialize(self)

    self.buttons = {}

    self.menuX = 0
    self.menuOpened = false
    self.menuTime = 0
    self.menuContentAlpha = 0

    self.guiPos = Vector()
    self.guiAng = Angle()

    self.guiWorldPos = Vector()
    self.guiWorldAng = Angle()

    self.cursorX = 0
    self.cursorY = 0

    self.guiWidth = 0
    self.guiHeight = 0

    self.guiTopWidth = 614
    self.guiTopHeight = 616

    self.guiSideWidth = 624
    self.guiSideHeight = 223

    self.guiTopAng = Angle(0, 90, 0)
    self.guiTopPos = Vector(-16.35, -15.15, 10.7)

    self.guiSideAng = Angle(0, 90, 90)
    self.guiSidePos = Vector(16.86, -15.405, 11.025)

    local obbSize = self:OBBMaxs() - self:OBBMins()
    self.boundsTopWidth = obbSize.x / 1.09879
    self.boundsTopHeight = obbSize.y / 1.034

    self.boundsSideWidth = obbSize.x / 1.08
    self.boundsSideHeight = obbSize.z / 1.052

    self.boundsWidth = self.boundsTopWidth
    self.boundsHeight = self.boundsTopHeight

    self.side = false
    self.sideAnimTime = 1

    self.clickTopRadius = self.guiTopWidth / 2 - 110
    self.clickTopCenterX = self.guiTopWidth / 2
    self.clickTopCenterY = self.guiTopHeight / 2 + 70


    self.clickSideRadius = 40
    self.clickSideCenterX = 80
    self.clickSideCenterY = self.guiSideHeight / 2 + 40

    self.colPrimary = Color(0, 0, 0, 0)
    self.colSecondary = Color(0, 0, 0, 0)
    self.colText = Color(0, 0, 0, 0)
    self.colHealth = Color(0, 0, 0, 0)

    self.colorR = self.colPrimary.r
    self.colorG = self.colPrimary.g
    self.colorB = self.colPrimary.b

    -- Buttons
    self.buttonMenu = self:AddButton(30, 68, 40, 34)
    self.buttonMenu.OnClick = function()
        self.menuOpened = not self.menuOpened
        self.menuTime = CurTime() + 0.5
    end
    self.buttonMenu.Paint = function(btn, w, h)
        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * 255))
        surface_DrawRect(btn.x, btn.y, w, 6)
        surface_DrawRect(btn.x, btn.y + 14, w, 6)
        surface_DrawRect(btn.x, btn    .y + 28, w, 6)
    end
    self.buttonMenu:SetTooltip(MCLICKERS.language.textUpgrades)

    self.buttonWithdraw = self:AddButton(self.guiTopWidth - 40 - 30, 60, 40, 40)
    local buttonWithdrawThink = self.buttonWithdraw.Think
    self.buttonWithdraw.Think = function(btn)
        buttonWithdrawThink(btn)

        if MCLICKERS.stealing and self:GetClickerOwner() ~= LocalPlayer() and self.stealing then
            if CurTime() >= self.stealStartTime + MCLICKERS.stealHoldTime + 0.5 then
                net.Start("money_clicker_steal")
                    net.WriteEntity(self)
                    net.WriteBool(false)
                net.SendToServer()

                self.stealing = false
            end

            if not btn.hovering or not LocalPlayer():KeyDown(IN_USE) then
                self.stealing = false
            end
        end
    end
    self.buttonWithdraw.OnClick = function(btn)
        if not MCLICKERS.stealing or self:GetClickerOwner() == LocalPlayer() or LocalPlayer():Team() == TEAM_BANK then
            net.Start("money_clicker_withdraw")
                net.WriteEntity(self)
            net.SendToServer()
        elseif not LocalPlayer():isCP() then
            self.stealing = true
            self.stealStartTime = CurTime()
            btn.stealCircleAng = 0

            net.Start("money_clicker_steal")
            net.WriteEntity(self)
            net.WriteBool(true)
            net.SendToServer()
        end
    end
    self.buttonWithdraw.stealCircleAlpha = 0
    self.buttonWithdraw.stealCircleAng = 0
    self.buttonWithdraw.Paint = function(btn, w, h)
        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * 255))
        surface.SetMaterial(matWithdraw)
        surface_DrawTexturedRect(btn.x - 5, btn.y - 5, w + 10, h + 10)
        draw.NoTexture()

        btn.showTooltip = not self.stealing
        if self.stealing then
            local fract = 1 - math.Clamp((self.stealStartTime + MCLICKERS.stealHoldTime - CurTime()) / MCLICKERS.stealHoldTime, 0, 1)
            btn.stealCircleAlpha = btn.stealCircleAlpha + (1 - btn.stealCircleAlpha) * 2 * FrameTime()
            btn.stealCircleAng = btn.stealCircleAng + (fract * 360 - btn.stealCircleAng) * 5 * FrameTime()
        else
            btn.stealCircleAlpha = btn.stealCircleAlpha + (0 - btn.stealCircleAlpha) * 2 * FrameTime()
            if btn.stealCircleAng > 320 then
                btn.stealCircleAng = btn.stealCircleAng + (360 - btn.stealCircleAng) * 5 * FrameTime()
            end
        end


        if btn.stealCircleAlpha > 0.01 then
            drawArc(btn.x + w / 2, btn.y + h / 2, w / 1, 6, -90, -90 + math.ceil((btn.stealCircleAng + 2) * 10) / 10, 10, ColorAlpha(self.colSecondary, btn.stealCircleAlpha * 255))
        end
    end

    self.buttonEject = self:AddButton(self.guiTopWidth - 40 - 90, 60, 40, 40)
    self.buttonEject.Paint = function(btn, w, h)
        if not self:InSafe() then return end
        
        surface_SetDrawColor(color_white)
        surface.SetMaterial(matWithdraw)
        surface_DrawTexturedRect(btn.x-5, btn.y-5, w+10, h+10)
    end
    self.buttonEject.OnClick = function()
        net.Start("money_clicker_eject")
            net.WriteEntity(self)
        net.SendToServer()
    end

    self.buttonHealth = self:AddButton(self.guiTopWidth - 80 - 30, self.guiTopHeight - 80 - 30, 80, 80)
    self.buttonHealth.OnClick = function()
        if self.info.indestructible then return end

        net.Start("money_clicker_repair")
            net.WriteEntity(self)
            net.WriteString("health")
        net.SendToServer()
    end
    self.buttonHealth.iconFade = 0
    self.buttonHealth.manualPainting = true
    self.buttonHealth.Paint = function(btn, w, h)
        if btn.hovering and not self.info.indestructible then
            btn.iconFade = btn.iconFade + (1 - btn.iconFade) * 0.05
        else
            btn.iconFade = btn.iconFade + (0 - btn.iconFade) * 0.05
        end

        local pulse = math.max(sin(CurTime() * 5), 0) * (self.smoothSide and 4 or 14)
        local progress = 1
        if not self.info.indestructible then
            progress = self.smoothHealth / self:GetMaxHealth()
        end
        local col = lerpColor(Color(0, 0, 0, 40), self.colHealth, math.Clamp(progress + sin(CurTime() * 5) / 10, 0, 1))
        surface_SetDrawColor(ColorAlpha(col, btn.alpha * (1 - btn.iconFade) * col.a))
        surface.SetMaterial(matHealth)
        surface_DrawTexturedRect(btn.x - pulse / 2, btn.y - pulse / 2, w + pulse, h + pulse)
        draw.NoTexture()

        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * btn.iconFade * 255))
        surface.SetMaterial(matRepair)
        surface_DrawTexturedRect(btn.x + 7, btn.y + 7, w - 14, h - 14)
        draw.NoTexture()

        local health = math.Round(self.smoothHealth)
        if self.info.indestructible then health = "∞" end

        if self.smoothSide then
            draw.DrawText(health, "MoneyClickerHealthSide", btn.x - 8, btn.y + h / 2 - 15, ColorAlpha(self.colText, btn.alpha * 255), TEXT_ALIGN_RIGHT)
        else
            draw.DrawText(health, "MoneyClickerHealth", btn.x + w / 2, btn.y + h - 8, ColorAlpha(self.colText, btn.alpha * 255), TEXT_ALIGN_CENTER)
        end
    end

    self.buttonRepair = self:AddButton(
        self.clickTopCenterX - self.clickTopRadius,
        self.clickTopCenterY - self.clickTopRadius,
        self.clickTopRadius * 2, self.clickTopRadius * 2)
    self.buttonRepair.OnClick = function()
        if self:GetBroken() and CurTime() >= self:GetRepairWaitTime() then
            net.Start("money_clicker_repair")
                net.WriteEntity(self)
                net.WriteString("broken")
            net.SendToServer()
        end
    end
    self.buttonRepair.manualPainting = true
    self.buttonRepair.alpha = 0
    self.buttonRepair.disabled = true
    self.buttonRepair.Paint = function(btn, w, h)
        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * 255))
        surface.SetMaterial(matRepair)
        surface_DrawTexturedRect(btn.x - 5, btn.y - 5, w + 10, h + 10)
        draw.NoTexture()
    end

    local function SendUpgradeMessage(update)
        net.Start("money_clicker_upgrade")
            net.WriteEntity(self)
            net.WriteString(update)
        net.SendToServer()
    end

    self.buttonUpg1 = self:AddButton(80, 160, 150, 150)
    self.buttonUpg1.alpha = 0
    self.buttonUpg1.Paint = function(btn, w, h)
        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * 255))
        surface.SetMaterial(matUpgradeAutoClick)
        surface_DrawTexturedRect(btn.x, btn.y, w, h)
        draw.NoTexture()
    end
    self.buttonUpg1.OnClick = function()
        SendUpgradeMessage("autoClick")
    end

    self.buttonUpg2 = self:AddButton(self.guiTopWidth - 80 - 150, 160, 150, 150)
    self.buttonUpg2.alpha = 0
    self.buttonUpg2.Paint = function(btn, w, h)
        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * 255))
        surface.SetMaterial(matUpgradeClickPower)
        surface_DrawTexturedRect(btn.x, btn.y, w, h)
        draw.NoTexture()
    end
    self.buttonUpg2.OnClick = function()
        SendUpgradeMessage("clickPower")
    end

    self.buttonUpg3 = self:AddButton(self.guiTopWidth / 2 - 75, self.guiHeight - 50 - 150, 150, 150)
    self.buttonUpg3.alpha = 0
    self.buttonUpg3.Paint = function(btn, w, h)
        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * 255))
        surface.SetMaterial(matUpgradeCooling)
        surface_DrawTexturedRect(btn.x, btn.y, w, h)
        draw.NoTexture()
    end
    self.buttonUpg3.OnClick = function()
        SendUpgradeMessage("cooling")
    end

    self.buttonUpg4 = self:AddButton(self.guiTopWidth / 2 - 75, self.guiHeight - 50 - 150, 150, 150)
    self.buttonUpg4.alpha = 0
    self.buttonUpg4.Paint = function(btn, w, h)
        surface_SetDrawColor(Color(255, 255, 255, btn.alpha * 255))
        surface.SetMaterial(matUpgradeStorage)
        surface_DrawTexturedRect(btn.x, btn.y, w, h)
        draw.NoTexture()
    end
    self.buttonUpg4.OnClick = function()
        SendUpgradeMessage("storage")
    end

    self.upgradeButtons = {
        self.buttonUpg1,
        self.buttonUpg2,
        self.buttonUpg3,
        self.buttonUpg4,
    }

    self.clicks = {}

    self.smoothProgress = 0
    self.smoothHeat = 0
    self.smoothHeatColor = Color(0, 0, 0, 40)
    self.smoothMoney = 0
    self.smoothPoints = 0
    self.smoothXP = 0
    self.smoothHealth = self:Health()
    self.smoothBroken = 0
    self.smoothLookAway = 0

    self.tooltipLookAway = buildTooltipData(Color(255, 150, 0), "Please look away once\nbefore clicking any further.")

    net.Start("money_clicker_info")
    net.WriteEntity(self)
    net.SendToServer()
end

function ENT:InitializeInfo(info)
    self.info = info

    self.colPrimary = self.info.colorPrimary
    self.colSecondary = self.info.colorSecondary
    self.colText = self.info.colorText
    self.colHealth = self.info.colorHealth

    self.colorR = self.colPrimary.r
    self.colorG = self.colPrimary.g
    self.colorB = self.colPrimary.b

    if not self.info.enableHeat then
        table.remove(self.upgradeButtons, 3)
    end
end

net.Receive("money_clicker_info", function(len)
    local ent = net.ReadEntity()
    if not IsValid(ent) then return end

    ent:InitializeInfo(net.ReadTable())
end)

function ENT:BuildUpgradeTooltip(upgrade, current, statStr, prefix, suffix)
    if not self.info then return end

    local data = self:GetUpgradeData(upgrade)
    local stat = data.stats[current]
    local price = data.prices[current]
    local priceLabel = (price == nil) and MCLICKERS.language.textUpgradeMaxed or (MCLICKERS.formatPoints(price))

    return {
        data.name, "\n",
        Color(0, 255, 0), prefix or "", stat, suffix or "",
        Color(255, 255, 255), " ", statStr, "\n",
        Color(100, 200, 255), priceLabel, "\n",
        Color(0, 255, 0), current .. " / " .. #data.stats
    }
end

function ENT:UpdateTooltips()
    if not self.info then return end

    self.buttonUpg1:SetTooltip(unpack(self:BuildUpgradeTooltip("autoClick", self:GetUpgradeAutoClick(), MCLICKERS.language.unitAutoClick)))
    self.buttonUpg2:SetTooltip(unpack(self:BuildUpgradeTooltip("clickPower", self:GetUpgradeClickPower(), MCLICKERS.language.unitClickPower)))
    self.buttonUpg3:SetTooltip(unpack(self:BuildUpgradeTooltip("cooling", self:GetUpgradeCooling(), MCLICKERS.language.unitCooling, "-")))
    self.buttonUpg4:SetTooltip(unpack(self:BuildUpgradeTooltip("storage", self:GetUpgradeStorage(), MCLICKERS.language.unitStorage, nil, "x")))

    if not MCLICKERS.stealing or self:GetClickerOwner() == LocalPlayer() or LocalPlayer():Team() == TEAM_BANK then
        self.buttonWithdraw:SetTooltip(MCLICKERS.language.textWithdraw, "\n", Color(0, 255, 0), "+" .. DarkRP.formatMoney(self:GetMoney()))
    else
        self.buttonWithdraw:SetTooltip(Color(255, 100, 0), MCLICKERS.language.textSteal, "\n", Color(100, 200, 255), string.format(MCLICKERS.language.textStealHold, MCLICKERS.stealHoldTime))
    end

    self.buttonEject:SetTooltip('Извлечь')

    if not self.info.indestructible then
        local repairPrice = math.ceil(self.info.repairHealthCost * (1 - (self:Health() / self:GetMaxHealth())))
        self.buttonHealth:SetTooltip(MCLICKERS.language.textRepair, "\n", Color(255, 100, 0), MCLICKERS.formatPoints(repairPrice))
    end

    if self:GetBroken() then
        local data = { MCLICKERS.language.textRepair .. "\n" }
        if CurTime() < self:GetRepairWaitTime() then
            data[#data + 1] = Color(100, 200, 255)
            data[#data + 1] = string.format(MCLICKERS.language.textRepairWait, math.ceil(self:GetRepairWaitTime() - CurTime())) .. "\n"
        end

        data[#data + 1] = Color(255, 100, 0)
        data[#data + 1] = DarkRP.formatMoney(self.info.repairBrokenCost)

        self.buttonRepair:SetTooltip(unpack(data))
    end
end

function ENT:GetCursorPosition()
    local lp = LocalPlayer()
    local trace = util.TraceLine({
        start = lp:EyePos(),
        endpos = lp:EyePos() + LocalPlayer():GetAimVector() * MCLICKERS.clickRange,
        filter = lp
    })
    if trace.Entity ~= self then return 0, 0 end

    local rayVec = util.IntersectRayWithPlane(lp:EyePos(), lp:GetAimVector(), self.guiWorldPos, self.guiWorldAng:Up())
    if not rayVec then return 0, 0 end

    local dist = lp:EyePos():Distance(rayVec)
    if dist > MCLICKERS.clickRange then return 0, 0 end

    local localRayVec = WorldToLocal(rayVec, Angle(), self.guiWorldPos, self.guiWorldAng)

    local cursorFractX = localRayVec.x / self.boundsWidth
    local cursorFractY = -localRayVec.y / self.boundsHeight

    if cursorFractX < 0 or cursorFractX > 1 or cursorFractY < 0 or cursorFractY > 1 then
        return -1, -1
    end

    return cursorFractX * self.guiWidth, cursorFractY * self.guiHeight
end

function ENT:AddButton(x, y, width, height)
    self.buttons = self.buttons or {}

    local button = setmetatable({
        x = x,
        y = y,
        width = width,
        height = height,
        entity = self
    }, buttonMeta)

    self.buttons[#self.buttons + 1] = button

    return button
end

local lastClick
function ENT:SendClick()
    if self:GetLookAway() then return end

    if lastClick then
        if CurTime() - lastClick < MCLICKERS.clickDelay then
            return false
        end
    end
    lastClick = CurTime()

    net.Start("money_clicker_click")
        net.WriteEntity(self)
    net.SendToServer()

    return true
end

function ENT:Think()
    
    local ply = LocalPlayer()
    local distSqr = 10000
    
    if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr or not self:IsUsable() then 
        self:SetNextClientThink( CurTime() + 1 )
        return true
    end
    
    base_gmodentity.Think(self)

    if not self.lastThink then self.lastThink = CurTime() end
    local elapsed = CurTime() - self.lastThink
    self.lastThink = CurTime()

    local cursorX, cursorY = self:GetCursorPosition()
    self.cursorX = cursorX
    self.cursorY = cursorY

    for _, button in ipairs(self.buttons) do
        if button.alpha < 0.01 then continue end
        button:Think()
    end

    if self.menuOpened then
        if self.menuX > self.guiWidth - 0.01 then
            self.menuX = self.guiWidth
        else
            self.menuX = self.menuX + (self.guiWidth - self.menuX) * 5 * elapsed
        end

        self.colorR = self.colorR + (self.colSecondary.r - self.colorR) * 1.5 * elapsed
        self.colorG = self.colorG + (self.colSecondary.g - self.colorG) * 1.5 * elapsed
        self.colorB = self.colorB + (self.colSecondary.b - self.colorB) * 1.5 * elapsed
    else
        if CurTime() > self.menuTime then
            if self.menuX < 0.01 then
                self.menuX = 0
            else
                self.menuX = self.menuX + (0 - self.menuX) * 5 * elapsed
            end

            self.colorR = self.colorR + (self.colPrimary.r - self.colorR) * 1.5 * elapsed
            self.colorG = self.colorG + (self.colPrimary.g - self.colorG) * 1.5 * elapsed
            self.colorB = self.colorB + (self.colPrimary.b - self.colorB) * 1.5 * elapsed
        end
    end

    if self.menuOpened then
        if self.menuX > self.guiWidth - 10 then
            self.menuContentAlpha = self.menuContentAlpha + (1.0 - self.menuContentAlpha) * 2 * elapsed
        end
    else
        self.menuContentAlpha = self.menuContentAlpha + (0.0 - self.menuContentAlpha) * 8 * elapsed
    end

    for _, btn in ipairs(self.upgradeButtons) do
        btn.disabled = not self.menuOpened
        btn.alpha = self.menuContentAlpha
    end

    local color = self:GetColor()
    if floor(abs(self.colorR - color.r)) ~= 0 or floor(abs(self.colorG - color.g)) ~= 0 or floor(abs(self.colorB - color.b)) ~= 0 then
        self:SetColor(Color(self.colorR, self.colorG, self.colorB))
    end

    if not self.menuOpened then
        if LocalPlayer():KeyDown(IN_USE) and not self.oldClickDown and not self:GetOverheating() and not self:GetBroken() then
            local cx = self.clickTopCenterX
            local cy = self.clickTopCenterY
            local radius = self.clickTopRadius

            if self.side then
                cx = self.clickSideCenterX
                cy = self.clickSideCenterY
                radius = self.clickSideRadius
            end

            local dx = cx - cursorX
            local dy = cy - cursorY
            local dist = math.sqrt((dx * dx) + (dy * dy))

            if dist <= radius then
                if not self:GetLookAway() then
                    if self:SendClick() then
                        self.clicks[#self.clicks + 1] = {
                            x = cursorX,
                            y = cursorY,
                            time = CurTime(),
                            duration = 0.3
                        }

                        playSound(MCLICKERS.SOUND_CLICK)
                    end
                end
            end
        end
    end

    self.oldClickDown = LocalPlayer():KeyDown(IN_USE)

    if self.lastTooltipUpdate == nil or CurTime() - self.lastTooltipUpdate >= 0.5 then
        self:UpdateTooltips()
        self.lastTooltipUpdate = CurTime()
    end

    self:SetNextClientThink(CurTime())
    return true
end

function ENT:DrawOverlayTooltip(x, y, font, tooltipData, alpha, alignment)
    if x == nil or y == nil or not tooltipData then return end

    alpha = alpha or 1
    alignment = alignment or TEXT_ALIGN_LEFT
    if alpha < 0.01 then return end

    surface.SetFont(font)
    local tw, th = surface.GetTextSize(tooltipData.text)
    surface_SetDrawColor(0, 0, 0, 200 * alpha)

    local offX = alignment == TEXT_ALIGN_LEFT and 0 or (alignment == TEXT_ALIGN_RIGHT and tw or (tw / 2))
    local tx = math.Clamp(x - offX - 15, 0, self.guiWidth - tw - 30)
    local ty = math.Clamp(y - th / 2, 0, self.guiHeight - th - 5)
    surface_DrawRect(tx, ty, tw + 30, th + 5)

    drawFormattedTextData(tooltipData.data, tx + tw / 2 + 15, ty, 255 * alpha, TEXT_ALIGN_CENTER)
end

function ENT:DrawOverlay()
    local ply = LocalPlayer()
    local distSqr = 10000
    
    if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
    local elapsed = FrameTime()

    if not self.info then return end

    if not self:IsUsable() then return end

    cam.Start3D2D(self.guiWorldPos, self.guiWorldAng, 0.05)
        local w, h = self.guiWidth, self.guiHeight

        draw.NoTexture()

        local headerBar = self.smoothSide and 30 or 40
        local clickCenterX = self.smoothSide and self.clickSideCenterX or self.clickTopCenterX
        local clickCenterY = self.smoothSide and self.clickSideCenterY or self.clickTopCenterY
        local clickRadius = self.smoothSide and self.clickSideRadius or self.clickTopRadius


        local progress = self:GetProgress() / 100

        -- Ensure a smooth transition from 1 to 0
        if self.smoothProgress > progress then
            self.smoothProgress = (self.smoothProgress + (1 + progress - self.smoothProgress) * 5 * elapsed) % 1
            if self.smoothProgress >= 0.9999 then self.smoothProgress = 0 end

            if not self.prevCycled then
                playSound(MCLICKERS.SOUND_CYCLE)

                self.prevCycled = true
            end
        else
            self.smoothProgress = self.smoothProgress + math.max(progress - self.smoothProgress, 0) * 5 * elapsed

            self.prevCycled = false
        end

        -- Smooth transition for heat
        self.smoothHeat = self.smoothHeat + (self:GetHeat() - self.smoothHeat) * 5 * elapsed

        -- Smooth transition money and points
        self.smoothMoney = self.smoothMoney + (self:GetMoney() - self.smoothMoney) * 2.5 * elapsed
        self.smoothPoints = self.smoothPoints + (self:GetPoints() - self.smoothPoints) * 2.5 * elapsed
        self.smoothXP = self.smoothXP + (self:GetStoredXP() - self.smoothXP) * 2.5 * elapsed
        self.smoothHealth = self.smoothHealth + (self:Health() - self.smoothHealth) * 2.5 * elapsed
        self.smoothBroken = self.smoothBroken + ((self:GetBroken() and 1 or 0) - self.smoothBroken) * 2.5 * elapsed

        if self:GetOverheating() then
            lerpColor(self.smoothHeatColor, ColorAlpha(self.colSecondary, 255), 2.5 * elapsed)
        else
            lerpColor(self.smoothHeatColor, Color(0, 0, 0, 40), 2.5 * elapsed)
        end

        local money = math.Round(self.smoothMoney)
        local points = math.Round(self.smoothPoints)
        local xp = math.Round(self.smoothXP)


        if math.Round(self.menuX) < w then
            surface_SetDrawColor(self.colPrimary)
            surface_DrawRect(0, 0, w, h)
        end

        if math.Round(self.menuX) < w then

            local heatFract = self.smoothHeat / 100
            if heatFract > 0 then
                local heat = {}
                local heatCenterX = clickCenterX
                local heatCenterY = clickCenterY
                local heatRadius = clickRadius - 2
                local heatSeg = 12
                local angDiff = 90 - 180 * heatFract


                local a = rad(-90 + angDiff)
                table_insert(heat, {
                    x = heatCenterX + sin(a) * heatRadius,
                    y = heatCenterY + cos(a) * heatRadius,
                    u = sin(a) / 2 + 0.5, v = cos(a) / 2 + 0.5 })

                for i = -90 + angDiff, 90 - angDiff, heatSeg do
                    local a = rad(-i)
                    table_insert(heat, {
                        x = heatCenterX + sin(a) * heatRadius,
                        y = heatCenterY + cos(a) * heatRadius,
                        u = sin(a) / 2 + 0.5, v = cos(a) / 2 + 0.5 })
                end

                local a = rad(90 - angDiff)
                table_insert(heat, {
                    x = heatCenterX + sin(a) * heatRadius,
                    y = heatCenterY + cos(a) * heatRadius,
                    u = sin(a) / 2 + 0.5, v = cos(a) / 2 + 0.5 })

                surface_SetDrawColor(self.smoothHeatColor)
                surface.DrawPoly(heat)

                surface_SetDrawColor(self.colPrimary)
                surface.SetMaterial(matHeat)
                surface_DrawTexturedRect(heatCenterX - heatRadius, heatCenterY - heatRadius, heatRadius * 2, heatRadius * 2)
                draw.NoTexture()
            end

            self.buttonRepair.alpha = self.smoothBroken
            self.buttonRepair.disabled = self.smoothBroken < 0.01
            self.buttonRepair.width = clickRadius
            self.buttonRepair.height = clickRadius
            self.buttonRepair.x = clickCenterX - self.buttonRepair.width / 2
            self.buttonRepair.y = clickCenterY - self.buttonRepair.height / 2

            self.buttonEject.disabled = not self:InSafe()

            if self.smoothSide then
                local leftOffset = clickRadius * 2 + 70
                local rightOffset = 40
                local barWidth = self.smoothProgress * (self.guiWidth - rightOffset - leftOffset)
                surface_SetDrawColor(Color(0, 0, 0, 40))
                surface_DrawRect(leftOffset, clickCenterY - 3, self.guiWidth - rightOffset - leftOffset, 6)

                surface_SetDrawColor(self.colSecondary)
                surface_DrawRect(leftOffset, clickCenterY - 3, barWidth, 6)

                drawCircle(leftOffset + barWidth, clickCenterY, 12, 24, self.colSecondary)

                drawArc(clickCenterX, clickCenterY, clickRadius + 5, 4, 0, 360, 6, Color(0, 0, 0, 40))

                draw_DrawText(DarkRP.formatMoney(money), "MoneyClickerMoneySide", leftOffset + 16, clickCenterY - 46, self.colText, TEXT_ALIGN_LEFT)
                draw_DrawText(MCLICKERS.formatPoints(points), "MoneyClickerPointsSide", leftOffset + 16, clickCenterY + 16, self.colText, TEXT_ALIGN_LEFT)

                if self.info.xpPerCycle and LevelSystemConfiguration then
                    draw_DrawText(xp .. " XP", "MoneyClickerPointsSide", (leftOffset + 16 + self.guiWidth - rightOffset - 16) / 2, clickCenterY + 16, self.colText, TEXT_ALIGN_CENTER)
                end

                draw_DrawText(self:GetOwnerName(), "MoneyClickerNameSide", self.guiWidth - rightOffset - 16, clickCenterY - 46, self.colText, TEXT_ALIGN_RIGHT)
            else
                local ang = self.smoothProgress * 360
                local radius = w / 2 - 100
                local thickness = 10
                local cx = w / 2
                local cy = h / 2 + 70
                drawArc(cx, cy, radius + thickness / 2, thickness, 0, 360, 6, Color(0, 0, 0, 40))
                drawArc(cx, cy, radius + thickness / 2, thickness, -90, -90 + math.ceil((ang + 2) * 10) / 10, 6, self.colSecondary)

                local radAng = rad(-90 + ang)
                local dotX = cos(radAng) * radius
                local dotY = sin(radAng) * radius
                drawCircle(cx + dotX, cy + dotY, 16, 24, self.colSecondary)

                local xpOffset = 0

                if self.info.xpPerCycle and LevelSystemConfiguration then
                    xpOffset = 20
                    draw_DrawText(xp .. " XP", "MoneyClickerMoneySmall", w / 2, h / 2 + 180, self.colText, TEXT_ALIGN_CENTER)
                end

                local textCol = ColorAlpha(self.colText, (1 - self.smoothBroken) * 255)
                draw_DrawText(MCLICKERS.language.textMoney, "MoneyClickerMoney", w / 2, h / 2 - 70 - xpOffset, textCol, TEXT_ALIGN_CENTER)
                draw_DrawText(DarkRP.formatMoney(money), "MoneyClickerMoneySmall", w / 2, h / 2 - xpOffset, textCol, TEXT_ALIGN_CENTER)

                draw_DrawText(MCLICKERS.language.textPoints, "MoneyClickerPoints", w / 2, h / 2 + 80 - xpOffset * 2, textCol, TEXT_ALIGN_CENTER)
                draw_DrawText(MCLICKERS.formatPoints(points), "MoneyClickerPointsSmall", w / 2, h / 2 + 150 - xpOffset * 2, textCol, TEXT_ALIGN_CENTER)

                draw_DrawText(self:GetOwnerName(), "MoneyClickerName", self.guiWidth / 2, headerBar + 60, self.colText, TEXT_ALIGN_CENTER)
            end

            draw.NoTexture()
            for i = #self.clicks, 1, -1 do
                local click = self.clicks[i]
                local fract = math.Clamp((CurTime() - click.time) / click.duration, 0, 1)

                drawCircle(
                    click.x + (clickCenterX - click.x) * fract,
                    click.y + (clickCenterY - click.y) * fract,
                    fract * clickRadius, 12, Color(255, 255, 255, 50 * (1 - fract)))

                if CurTime() - click.time >= click.duration then
                    table.remove(self.clicks, i)
                end
            end
        end

        self.buttonHealth:Paint(self.buttonHealth.width, self.buttonHealth.height)
        self.buttonHealth:PaintOver(self.buttonHealth.width, self.buttonHealth.height)

        self.buttonRepair:Paint(self.buttonRepair.width, self.buttonRepair.height)
        self.buttonRepair:PaintOver(self.buttonRepair.width, self.buttonRepair.height)

        surface_SetDrawColor(self.colSecondary)
        surface_DrawRect(0, 0, self.menuX, h)

        surface_SetDrawColor(Color(0, 0, 0, 80))
        surface_DrawRect(0, 0, w, headerBar)

        if self.smoothSide then
            draw_DrawText(MCLICKERS.language.textPoints .. ": " .. MCLICKERS.formatPoints(points), "MoneyClickerPointsSide", w / 2, headerBar + 70, ColorAlpha(self.colText, 255 * self.menuContentAlpha), TEXT_ALIGN_CENTER)
        else
            draw_DrawText(MCLICKERS.language.textPoints .. ": " .. MCLICKERS.formatPoints(points), "MoneyClickerPointsSide", w / 2, headerBar + 80, ColorAlpha(self.colText, 255 * self.menuContentAlpha), TEXT_ALIGN_CENTER)
        end

        draw_DrawText(self:GetClickerName(), "MoneyClickerTitle", 96, headerBar + 17, self.colText, TEXT_ALIGN_LEFT)
        self.buttonMenu.y = headerBar + 23
        self.buttonWithdraw.y = headerBar + 23
        self.buttonEject.y = headerBar + 23

        if self.smoothSide then
            for i, btn in ipairs(self.upgradeButtons) do
                btn.x = 80 + (self.guiWidth - 80) / #self.upgradeButtons * (i - 1)
                btn.y = 150

                btn.width = 50
                btn.height = 50
            end

            self.buttonHealth.width = 36
            self.buttonHealth.height = 36
            self.buttonHealth.x = self.guiWidth - self.buttonHealth.width - 50
            self.buttonHealth.y = self.guiHeight - self.buttonHealth.height - 22
        else
            local bx = 1
            local by = 1
            for i, btn in ipairs(self.upgradeButtons) do
                local maxRow = math.min(#self.upgradeButtons - (by - 1) * 2, 2)
                btn.x = self.guiWidth / (maxRow * 2) * (-(i % 2) * 2 + 3) - 75
                btn.y = by * 250 - 60

                if i % 2 == 0 then
                    by = by + 1
                end

                btn.width = 150
                btn.height = 150
            end

            self.buttonHealth.width = 80
            self.buttonHealth.height = 80
            self.buttonHealth.x = self.guiWidth - self.buttonHealth.width - 30
            self.buttonHealth.y = self.guiHeight - self.buttonHealth.height - 30
        end

        for _, button in ipairs(self.buttons) do
            if button.alpha < 0.01 then continue end
            if button.manualPainting then continue end

            button:Paint(button.width, button.height)
        end

        for _, button in ipairs(self.buttons) do
            if button.alpha < 0.01 then continue end
            if button.manualPainting then continue end

            button:PaintOver(button.width, button.height)
        end

        if self:GetLookAway() then
            self.smoothLookAway = self.smoothLookAway + (1 - self.smoothLookAway) * 2.5 * elapsed
        else
            self.smoothLookAway = self.smoothLookAway + (0 - self.smoothLookAway) * 2.5 * elapsed
        end
        self:DrawOverlayTooltip(clickCenterX, clickCenterY, "MoneyClickerTooltip", self.tooltipLookAway, self.smoothLookAway, TEXT_ALIGN_CENTER)

    cam.End3D2D()
end

local distSqr = 250000

function ENT:Draw(flags)
    local ply = LocalPlayer()
    
    if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
    if not self.info then return end

    render.SuppressEngineLighting(true)
    base_gmodentity.Draw(self, flags)
    local lp = LocalPlayer()

    local dist = LocalPlayer():GetPos():Distance(self:GetPos())
    if dist > 150 then
        render.SuppressEngineLighting(false)
        surface.SetAlphaMultiplier(1)
        return
    end

    local trigger
    if self:InSafe() then
        trigger = true
    else
        local upDot = (lp:EyePos() - self:LocalToWorld(self.guiTopPos)):GetNormalized():Dot(self:GetUp())
        local forwardDot = (lp:EyePos() - self:LocalToWorld(self.guiSidePos)):GetNormalized():Dot(self:GetForward())
        trigger = upDot < 0.2 and forwardDot > 0
        if not trigger then
            local upTrace = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() + self:GetUp() * 15,
                filter = self
            })
            trigger = upTrace.Hit
            if trigger and IsValid(upTrace.Entity) and upTrace.Entity:IsPlayer() then
                trigger = false
            end
        end

        if not trigger then
            local downTrace = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() - self:GetUp() * 5,
                filter = self
            })
            if IsValid(downTrace.Entity) and downTrace.Entity:GetClass() == "money_clicker" then
                trigger = true
            end
        end
    end

    if self.side ~= trigger then
        self.side = trigger
        self.sideAnimTime = 0
    end
    self.sideAnimTime = math.min(self.sideAnimTime + 0.01, 1)

    if self.sideAnimTime > 0.5 then
        self.smoothSide = self.side

        if self.side then
            self.guiWidth = self.guiSideWidth
            self.guiHeight = self.guiSideHeight

            self.boundsWidth = self.boundsSideWidth
            self.boundsHeight = self.boundsSideHeight

            self.guiAng = self.guiSideAng
            self.guiPos = self.guiSidePos
        else
            self.guiWidth = self.guiTopWidth
            self.guiHeight = self.guiTopHeight

            self.boundsWidth = self.boundsTopWidth
            self.boundsHeight = self.boundsTopHeight

            self.guiAng = self.guiTopAng
            self.guiPos = self.guiTopPos
        end
    end

    self.guiWorldPos = self:LocalToWorld(self.guiPos)
    self.guiWorldAng = self:LocalToWorldAngles(self.guiAng)

    surface.SetAlphaMultiplier((1 - math.Clamp((dist - 125) / 25, 0, 1)) * (1 - sin(math.pi * self.sideAnimTime)))

    local dot = (lp:EyePos() - self.guiWorldPos):Dot(self.guiWorldAng:Up())
    if dot > 0 then
        self:DrawOverlay()
    end

    render.SuppressEngineLighting(false)

    surface.SetAlphaMultiplier(1)
end

--addons/module_picture/lua/entities/painting_3.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Квадратная рамка"
ENT.Category = "Fun + Games"
ENT.Author = "xyester"

ENT.Spawnable = true
ENT.DoNotDuplicate = true
ENT.Owned = false

if SERVER then
	function ENT:Use(caller)
    	if caller == self:Getowning_ent() then
    		net.Start("URLPaint Menu")
    			net.WriteEntity(self)
    		net.Send(caller)
    	end
	end

	function ENT:Initialize()
		self:SetModel("models/props/cs_office/offcertificatea.mdl")

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)

		self:SetUseType(SIMPLE_USE)
		self:CPPISetOwner(self:Getowning_ent())
	end

	function ENT:OnRemove()
		if URLPaint.List[self] then
			URLPaint.List[self] = nil
		end
    end

    function ENT:OnTakeDamage(damageInfo)
        if damageInfo:GetAttacker() == self:Getowning_ent() then
            self:Remove()
        end
    end
else
	function ENT:Initialize()
		self:SetModel("models/props/cs_office/offcertificatea.mdl")

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
	end

	local distSqr = 202500

	function ENT:Draw()
	    
        local ply = LocalPlayer()
        local png = self.image
        
		self:DrawModel()
		
        if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
	    

		if GetConVar('urlpaint_enabled'):GetInt() <= 0 then return end

		if self:GetPicID() == "" then
			return
		end

		if png == nil then return end

		if png:IsError() then return end

		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 180)
		ang:RotateAroundAxis(ang:Forward(), 90)

		cam.Start3D2D(self:GetPos() + (self:GetUp() * 6.5) + (self:GetRight() * (self:OBBMaxs().y - 1.5)), ang, 0.0345)
			surface.SetDrawColor(color_white)
			surface.SetMaterial(png)
			surface.DrawTexturedRect(-320, -125, 635, 635)
		cam.End3D2D()
	end
end

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("String", 0, "PicURL")
    self:NetworkVar("String", 1, "PicID")
end
--addons/module_media/lua/entities/radio.lua:
AddCSLuaFile()
ENT.Base = "media_base"
ENT.Type = "anim"
ENT.PrintName = "Радио"
ENT.Category = "Разрешено"
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Model = 'models/props/cs_office/radio.mdl'
--ENT.Activated = true
--addons/module_weed/lua/entities/sent_pot.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"
ENT.Size = Vector(0,30,30)
ENT.PrintName		= "Емкость"
ENT.Author			= "Gonzo"
ENT.Spawnable 		= false
ENT.Category		= "Drugs"
ENT.AdminOnly 		= true

local function IsLookingAt( a, b, nor, dis, targetVec )
	return nor:Dot( (a:GetPos() - b:GetPos()) ) / (a:GetPos() - b:GetPos()):Length() < -1.8
end

function ENT:SpawnFunction( ply, tr, ClassName )

	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos

	local ent = ents.Create( ClassName )
	ent:SetPos( SpawnPos )
	ent:Spawn()
	ent:Activate()
	ent:SetPersistent()
	ent.Owner = ply

	return ent

end

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/pot1.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end

		self:SetHealth(0)
		self:SetWaterAmount(0)
		self:SetLight(0)
		self:SetSeed(0)
		self:SetLevel(1)
		self:SetWeedQuality(0)

	end
end

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "WaterAmount")
	self:NetworkVar("Int", 1, "Light")
	self:NetworkVar("Int", 2, "Seed")
	self:NetworkVar("Int", 3, "Level")
	self:NetworkVar("Int", 4, "Progress")
	self:NetworkVar("Int", 5, "WeedQuality")
	self:NetworkVar("Int", 6, "MaxWater")
	self:NetworkVar("Int", 7, "Extra")
	self:NetworkVar("Int", 8, "Seed")
	self:NetworkVar("Int", 9, "Soil")
	self:NetworkVar("Bool", 0, "MultiplePot")
	self:NetworkVar("Float", 0, "LightFloat")
	self:NetworkVar("String", 0, "SeedName")
	self:NetworkVar("Entity", 0, "WeedA")
	self:NetworkVar("Entity", 1, "WeedB")
	self:NetworkVar("Entity", 2, "WeedC")
	self:NetworkVar("Entity", 3, "WeedGhost")
end

function ENT:SetPot(x)

	self:SetModel( "models/gonzo/weedb/pot"..x..".mdl" )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )

	local phys = self:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:Wake()
	end

	if(x==1) then
		self:SetMaxWater(90)
		self:SetExtra(0)
	end
	if(x==2) then
		self:SetMaxWater(100)
		self:SetExtra(1)
	end
	if(x==3) then
		self:SetMaxWater(140)
		self:SetExtra(3)
	end
	if(x==4) then
		self:SetMaxWater(100)
		self:SetExtra(2)
		self:SetMultiplePot(true)
	end

end

ENT.OldSeed = 0
ENT.SeedWater = 0
ENT.SeedEx = 0
ENT.NSeed = 0

function ENT:Touch(entity)
	if(self:GetSoil() > 0 && self:GetSeed() == 0 && entity:GetClass() == "sent_seed" && !self:GetMultiplePot()) then
		self:SetWeedQuality(entity.Quality)
		self:SetSeed(1)
		self:SetWaterAmount(50)
		self:SetHealth(100)
		self:SetLevel(1)
		self:SetProgress(1)

		self:SetSeedName(entity:GetHUDName());
		entity:Remove()

		local ent = ents.Create("prop_dynamic")
		ent:SetModel("models/gonzo/weed_shared.mdl")
		ent:SetPos(self:GetPos() + self:GetUp()*16)
		ent:SetAngles(self:GetAngles())
		ent:Spawn()
		ent:SetParent(self)
		self:SetWeedGhost(ent)
		self.Weed = ent

		if(entity:GetClass() != "sent_seed") then
			self:SetMaxWater(self:GetMaxWater()+entity.Waterizer)
			self:SetExtra(self:GetExtra()+entity.Extra)
		else
			self:SetMaxWater(self:GetMaxWater()+entity.Waterizer)
			self:SetExtra(self:GetExtra()+entity.Extra)
			self.SeedWater = entity.Waterizer
			self.SeedEx = entity.Extra
		end
	end

	if(self.NSeed < CurTime() && self:GetSoil() > 0 && entity:GetClass() == "sent_seed" && self:GetMultiplePot() && self:GetSeed() < 3) then
		self.NSeed = CurTime()+1
		if(self:GetSeed() == 0) then
			self:SetWeedQuality(entity.Quality)
			self:SetMaxWater(self:GetMaxWater()+entity.Waterizer)
			self:SetExtra(self:GetExtra()+entity.Extra)
			self.SeedWater = entity.Waterizer
			self.SeedEx = entity.Extra
			entity:Remove()
			self:SetSeed(self:GetSeed()+1)
		elseif(entity.Waterizer == self.SeedWater && entity.Extra == self.SeedEx && self:GetSeed() != 3) then
			self:SetSeedName(entity:GetHUDName());
			entity:Remove()
			self:SetSeed(self:GetSeed()+1)
			if(self:GetSeed()==3) then
				self:SetWaterAmount(50)
				self:SetLevel(1)
				self:SetProgress(1)
				self:SetHealth(50)
				self.Weed = {}
				for k=1,3 do
					local ent = ents.Create("prop_dynamic")
					ent:SetModel("models/gonzo/weed_shared.mdl")
					ent:SetPos(self:GetPos() + self:GetUp()*24 - self:GetRight()*38*2 + self:GetRight()*k*38)
					ent:SetAngles(self:GetAngles())
					ent:Spawn()
					ent:SetParent(self)
					self.Weed[k] = ent
				end
				self:SetWeedA(self.Weed[1])
				self:SetWeedB(self.Weed[2])
				self:SetWeedC(self.Weed[3])
			end
		end
	end
end


// XP boost in % depending on seed type.
local seedXPBonus = {
	["Haze Berry"] 	= 20,
	["Amnesia Haze"] 	= 40,
	["Bubble Kush"] 	= 60,
	["O.G. Kush"]	= 80
}

function ENT:Use(act)
	if(self:GetLevel() >= 7) then
		self:SetSeed(0)
		self:SetProgress(0)
		self:SetLevel(0)
		-- If you change your mind later...
		act.notificationType = { "Harvested Weed", ""}

		if(act.addEXP) then
			local xp = Either(self:GetMultiplePot(),5000,1500)
			xp = xp * ((seedXPBonus[self:GetSeedName()] or 20) / 100 + 1) // adds x% based on seed type.
			act:addEXP( xp );
		end

		if(!self:GetMultiplePot()) then
			self.Weed:Remove()
			local ent = ents.Create("sent_weed_bag")
			ent:SetPos(self:GetPos() + Vector(0,0,64))
			ent:Spawn()
			ent:SetWeedQuality(self:GetWeedQuality())
			--ent:SetHUDName("Weed - "..self:GetWeedQuality().."%")
		else
			for k,v in pairs(self.Weed) do
				local ent = ents.Create("sent_weed_bag")
				ent:SetPos(self:GetPos() + Vector(0,0,64) - self:GetRight()*38*2 + self:GetRight()*k*38)
				ent:Spawn()
				ent:SetWeedQuality(self:GetWeedQuality())
				--ent:SetHUDName("Weed - "..self:GetWeedQuality().."%")
				v:Remove()
			end
		end

		self:SetMaxWater(self:GetMaxWater()-self.SeedWater)
		self:SetExtra(self:GetExtra()-self.SeedEx)
		self.SeedWater = 0
		self.SeedEx = 0

	end
end

function ENT:Think()
	if SERVER then
		local a = self:GetSeed() > 0 && !self:GetMultiplePot()
		local b = self:GetMultiplePot() && self:GetSeed()==3
		if((a || b)&& self:GetLevel() < 7) then

			if(!WEED_CONFIG.Demo) then
				if(WEED_CONFIG.WaterLossChance >= math.random(1,100) && (self.Watered or 0) <= CurTime()) then
					local m = math.random(WEED_CONFIG.WaterLoss[1],WEED_CONFIG.WaterLoss[2])
					self:SetWaterAmount(math.Clamp(self:GetWaterAmount()-m,0,self:GetMaxWater()))
				end

				if(self:GetWaterAmount() < self:GetMaxWater()*0.25) then
					self:SetHealth(self:Health()-3-(self:GetWaterAmount()/self:GetMaxWater()*0.25)*3)
				end
				if(self:GetLight() < 40) then
					self:SetHealth(self:Health()-2-(self:GetLight()/50)*2.5)
				end
			end

			if(WEED_CONFIG.Demo) then
				self:SetProgress(self:GetProgress()+50)
			else
				self:SetProgress(self:GetProgress()+math.random(1,5)+math.max(0,self:GetExtra()))
			end

			if(self:GetProgress() >= 100) then
				self:SetProgress(0)
				self:SetLevel(self:GetLevel()+1)
				self:SetWaterAmount(math.max(self:GetWaterAmount(), self:GetMaxWater()*0.5))
				if(!istable(self.Weed)) then
					self.Weed:SetBodygroup(1,math.Clamp(self:GetLevel(),0,7)-1)
				else
					for k,v in pairs(self.Weed) do
						v:SetBodygroup(1,math.Clamp(self:GetLevel(),0,7)-1)
					end
				end

			end

			self.Machine = nil

			for k,v in pairs(ents.FindByClass("sent_light")) do
				if(!(v.IsRadial or false)) then
					local a = IsLookingAt(v,self,v:GetForward() + v:GetForward(),-172)
					if(v:GetPos():Distance(self:GetPos()) < 192 && a && self:GetLightFloat() < 100 && v:GetCharge() > 0 && v:GetOn()) then
						self.Machine = v
					end
				elseif(v:GetPos():Distance(self:GetPos()) < 192/2 && self:GetLightFloat() < 100 && v:GetCharge() > 0 && v:GetOn()) then
					self.Machine = v
				end
			end
			//76561198136465722
			if(IsValid(self.Machine)) then
				self:SetLight(math.Clamp(self:GetLight()+(20-self.Machine:GetPos():Distance(self:GetPos())/14.2),0,100))
			else
				self:SetLight(math.Clamp(self:GetLight()-10,0,100))
			end

			if(self:Health() <= 0) then
				self:SetSeed(0)
				self:SetProgress(0)
				self:SetLevel(0)
				if(isentity(self.Weed)) then
					self.Weed:Remove()
				elseif(istable(self.Weed)) then
					for k,v in pairs(self.Weed) do
						v:Remove()
					end
				end

				self:SetMaxWater(self:GetMaxWater()-self.SeedWater)
				self:SetExtra(self:GetExtra()-self.SeedEx)
				self.SeedWater = 0
				self.SeedEx = 0
			end

		end

		self:NextThink( CurTime() + math.random(1,3) )

		return true
	end
end

if CLIENT then


function ENT:PostDraw()
  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end


	if(!self:GetMultiplePot() && IsValid(self:GetWeedGhost())) then
		prop = self:GetWeedGhost()
		mat = Matrix()
		mat:Scale( Vector(1,1,1)*(self:GetLevel()/7+(self:GetProgress()/100)*(1/7))*1.2)
		prop:EnableMatrix( "RenderMultiply", mat )
	elseif(IsValid(self:GetWeedA())) then
		
		local func = {
			["A"] = self:GetWeedA(),
			["B"] = self:GetWeedB(),
			["C"] = self:GetWeedC(),
		}

		for k=1,3 do
			prop = func[Either(k==1,"A",Either(k==2,"B","C"))]
			mat = Matrix()
			mat:Scale( Vector(1,1,1)*(self:GetLevel()/7+(self:GetProgress()/100)*(1/7))*1.2)
			prop:EnableMatrix( "RenderMultiply", mat )
		end
	end
end

local water = surface.GetTextureID("gui/water")
local light = surface.GetTextureID("gui/light")

local emotes = {"dead","bad","neutral","regular","happy"}
local hl = {Color(231, 76, 60),Color(230, 126, 34),Color(241, 196, 15),Color(46, 204, 113)}
local em_tex = {}
for k,v in pairs(emotes) do
	em_tex[k] = surface.GetTextureID("gui/"..v)
end

local rope = Material("gui/rope")
local triangle = {}
local a,b,c,d,ang

function surface.DrawTexturedRectUVRotated(px,py,pw,ph,pu,pv,eu,ev,rot)

	ang = Angle(0,rot,0)
	a = Vector(-pw/2,-ph/2,0)
	a:Rotate(ang)
	b = Vector(pw/2,-ph/2,0)
	b:Rotate(ang)
	c = Vector(pw/2,ph/2,0)
	c:Rotate(ang)
	d = Vector(-pw/2,ph/2,0)
	d:Rotate(ang)

	triangle[1] = {x=px+a.x,y=py+a.y,u=pu,v=pv}
	triangle[2] = {x=px+b.x,y=py+b.y,u=eu,v=pv}
	triangle[3] = {x=px+c.x,y=py+c.y,u=eu,v=ev}
	triangle[4] = {x=px+d.x,y=py+d.y,u=pu,v=ev}

	surface.DrawPoly(triangle)

end

function ENT:DoInfo(pos)
  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end

	
  surface.SetDrawColor(50,50,50,150)
  surface.DrawRect(16,-64,272,128+16)

	surface.SetTexture(water)
	surface.SetDrawColor(hl[math.Clamp(math.ceil((self:GetWaterAmount())/25)+1,1,4)])
	surface.DrawTexturedRect(30,0,64,64)

	surface.SetTexture(light)
	surface.SetDrawColor(hl[math.Clamp(math.ceil((self:GetLight())/33)+1,1,4)])
	surface.DrawTexturedRect(214,0,64,64)

	if((self:GetMultiplePot() && self:GetSeed() >= 3) || (!self:GetMultiplePot() && self:GetSeed() > 0) && self:GetLevel() < 7) then
		for k,v in pairs(em_tex) do
			surface.SetTexture(v)
			surface.SetDrawColor(255,255,255,Either(math.ceil((self:Health())/25)+1==(k) or (k==1&&self:Health()==0),255,25))
			surface.DrawTexturedRect(-20+50*k,-52,48,48)
		end
	else
		if(self:GetLevel() < 7) then
			if(self:GetSoil() > 0) then
				draw.SimpleTextOutlined(Either(self:GetMultiplePot(),"Семена -"..(3-self:GetSeed()),""),"MainWeedFont",152,-28,Color(255,150,50,250),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,1,Color(75,75,75))
			else
				draw.SimpleTextOutlined("Грунт - 1","MainWeedFont",152,-28,Color(255,150,50,250),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,1,Color(75,75,75))
			end
		else
			draw.SimpleTextOutlined("Prepare me","MainWeedFont",152,-28,Color(100,255,50,250),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,1,Color(75,75,75))
		end
	end
	//76561198044940228
	draw.SimpleTextOutlined("%"..self:GetProgress(),"MainWeedFont",152,32,Color(255,255,255,100),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,1,Color(75,75,75))
	//draw.SimpleTextOutlined("HP "..self:Health().." Water "..self:GetWaterAmount(), "MainWeedFont",152,-128,Color(255,255,255,100),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,1,Color(75,75,75))

	surface.SetMaterial(rope)
	surface.SetDrawColor(255,255,255,255)
	surface.DrawTexturedRectUV( 14, -64, 8, 128+16, 0, 0, 1, 1 )

	surface.DrawTexturedRectUVRotated(153, -68, 8, 278, 0, 0, 1, 2 ,90)
	surface.DrawTexturedRectUVRotated(14+270+4, 0, 8, 128+16, 0, 0, 1, 1 ,180)
	surface.DrawTexturedRectUVRotated(153, 80, 8, 278, 0, 0, 1, 2 ,270)
end

end

--addons/module_slotmachine/lua/entities/slot_fifty_fifty/cl_init.lua:
include('shared.lua')

surface.CreateFont('Trebuchet_Slots', {
    font = 'Trebuchet MS',
    size = 48
})

function ENT:Initialize()
    self.Seed2 = 0
    self.Seed1 = 0
end

local back = Material('slot_fifty_fifty.png')

function ENT:DrawScreen(x, y)
    self.Seed1 = Lerp(.05, self.Seed1, self:GetSeed1())
    self.Seed2 = Lerp(.05, self.Seed2, self:GetSeed2())
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(back)
    surface.DrawTexturedRect(x, y + 2, 500, 380)
    draw.SimpleText(string.Comma(self:GetPrice(), '.') .. '$', 'Trebuchet24', 0, -950, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    draw.SimpleText(math.Round(self.Seed1), 'Trebuchet_Slots', -125, -1055, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    draw.SimpleText(math.Round(self.Seed2), 'Trebuchet_Slots', 120, -1055, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
end
--addons/module_slotmachine/lua/entities/slot_slots/shared.lua:
ENT.Type = "anim"
ENT.Base = "slot_base"
ENT.PrintName = "Слоты"
ENT.Spawnable = true
ENT.Category = "WaySlots"

ENT.Seeds = {
    [0] = Material('materials/icon72/8ball.png'), -- Эта херь, это первоначальные иконки, дальше они роли не играют 😊
    [1] = Material('materials/icon72/eggplant.png'),
    [2] = Material('materials/icon72/avocado.png'),
    [3] = Material('materials/icon72/gem.png'),
    [4] = Material('materials/icon72/grapes.png'),
    [5] = Material('materials/icon72/kiwi.png'),
    [6] = Material('materials/icon72/lemon.png'),
    [7] = Material('materials/icon72/mango.png'),
}

function ENT:SetupDataTables()
    self.BaseClass.SetupDataTables(self)
    self:NetworkVar('Int', 0, 'Seed1')
    self:NetworkVar('Int', 1, 'Seed2')
    self:NetworkVar('Int', 2, 'Seed3')
end
--gamemodes/darkrp/entities/entities/spawned_food/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

--gamemodes/darkrp/entities/entities/spawned_weapon/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Spawned Weapon"
ENT.Author = "Rickster"
ENT.Spawnable = false
ENT.IsSpawnedWeapon = true

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "amount")
    self:NetworkVar("String", 0, "WeaponClass")
end

--addons/module_tech/lua/entities/technician_heater.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "technician_base"

ENT.Name = "Heater"
ENT.PrintName = "Heater"
ENT.Author = "OverlordAkise"
ENT.Category = "Запрещено"
ENT.Purpose = "Press E to repair!"
ENT.Instructions = "N/A"
ENT.Model = "models/props/cs_assault/ACUnit02.mdl"

ENT.Spawnable = true

--addons/_smallscripts/lua/entities/trash_dumpster/cl_init.lua:
include('shared.lua')

local color_bright = Color(236, 113, 71)
local color_dark = Color(43, 49, 54)
local color_other = Color(77, 75, 77, 70)
local dx = Vector(20,-5,10)
local da = Angle(0,90,95)
local scale = 0.1

function ENT:Draw()
	self:DrawModel()
	
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 62500 then return end

	cam.Start3D2D(self:LocalToWorld(dx), self:LocalToWorldAngles(da), scale)
		draw.RoundedBox(0,-110,10,310,80, color_dark)
		draw.RoundedBox( 0,-110,10,310,28, color_bright)
		surface.SetDrawColor( color_other )
		draw.SimpleText( "Контейнер с мусором", "Trebuchet24", -60, 23, color_white, 0, 1 )
		draw.SimpleText( "Нажми E чтобы обыскать", "Trebuchet24", 40, 50, color_white, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--addons/weapon_chainsaw/lua/effects/bloodstream.lua:

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
///////////////////////Bloodstream effect////////////////
////////////Made by Archemyde////////////////////////////
////For Realistic Chainsaw///////////////////////////////
/////////////////////////////////////////////////////////





util.PrecacheSound("physics/flesh/flesh_bloody_impact_hard1.wav")
util.PrecacheSound("physics/flesh/flesh_squishy_impact_hard1.wav")
util.PrecacheSound("physics/flesh/flesh_squishy_impact_hard2.wav")
util.PrecacheSound("physics/flesh/flesh_squishy_impact_hard3.wav")
util.PrecacheSound("physics/flesh/flesh_squishy_impact_hard4.wav")

local function CollideCallback(particle, hitpos, hitnormal)
	if not particle.HitAlready then
		particle.HitAlready = true

		local pos = hitpos + hitnormal
		
		util.Decal("Blood", pos, hitpos - hitnormal)

		particle:SetDieTime(0)
	end
end

function EFFECT:Init(data)
	local Pos = data:GetOrigin() + Vector(0,0,10)

	local emitter = ParticleEmitter(Pos)
	for i=1, data:GetMagnitude() do
		local particle = emitter:Add("decals/blood"..math.random(1,8), Pos + VectorRand() * 8)
		particle:SetDieTime(math.Rand(3, 6))
		particle:SetStartAlpha(230)
		particle:SetEndAlpha(230)
		particle:SetStartSize(math.Rand(10, 14))
		particle:SetEndSize(10)
		particle:SetRoll(math.Rand(0, 360))
		particle:SetRollDelta(math.Rand(-20, 20))
		particle:SetAirResistance(5)
		particle:SetBounce(0)
		particle:SetGravity(Vector(0, 0, -600))
		particle:SetCollide(true)
		particle:SetCollideCallback(CollideCallback)
		particle:SetLighting(true)
		particle:SetColor(255, 0, 0)
	end
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/weapon_knifecsgo/lua/effects/csgo_knifeimpact.lua:
function EFFECT:Init( data )
  local vOffset = data:GetOrigin() -- + Vector( 0, 0, 0.2 )
  -- local vAngle = data:GetAngles()
  local emitter = ParticleEmitter( vOffset ) -- there was false
    for i=0, 5 do
      local particle = emitter:Add( "particle/particle_smokegrenade", vOffset )
      if particle then
        -- particle:SetAngles( vAngle )
        particle:SetVelocity( math.random(12,16) * math.sqrt(i) * data:GetNormal() * 3 + 2 * VectorRand() )
        particle:SetColor( 135, 135, 135 )
        particle:SetLifeTime( 0 )
        particle:SetDieTime( math.Rand( 0.5, 1.5 ) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand( 5, 8 ) *math.Clamp(i,1,4) * 0.166 )
        --particle:SetStartLength( 1 )
        particle:SetEndSize( math.Rand( 16, 24 ) * math.sqrt(math.Clamp(i,1,4)) * 0.166 )
        --particle:SetEndLength( 4 )
        particle:SetRoll( math.Rand( -25, 25 ) )
        particle:SetRollDelta( math.Rand( -0.05, 0.05 ) )
      end
    end
  emitter:Finish()
end

function EFFECT:Think()
  return false
end

function EFFECT:Render()
end
--addons/weapon_melee/lua/effects/darkclouds/init.lua:
function EFFECT:Init( data )
	
	self.Pos = data:GetStart()
	self.Ent = data:GetEntity()

	local ent = self.Ent
	local pos = self.Pos
	
	local emitter = ParticleEmitter( pos )
		
	if IsValid(ent) then
		for i=1, 5 do
		
			local particle = emitter:Add( "particles/smokey", pos + ent:GetForward() * i * math.Rand(1.5,2.6) )

			particle:SetVelocity(ent:GetForward() * math.Rand(150,300) + VectorRand()*math.Rand(50,100) + Vector(0,0,-2*i))
			particle:SetDieTime(math.Rand(3,6))
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( math.Rand( 10, 20 ) )
			particle:SetStartSize( math.Rand(5,15) )
			particle:SetEndSize( math.Rand( 60, 100 ) )
			particle:SetRoll( math.Rand( 0, 360 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor( 0, 0, 0 )
			particle:SetCollide( true )
            particle:SetBounce( 0.2 )
			particle:SetGravity(Vector(0,0,-4*i))
			
	    end
	end

	emitter:Finish()
	
end

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
	
end




--addons/module_itemstore/lua/itemstore/items/base_darkrp.lua:
ITEM.Name = "DarkRP Item Base"
ITEM.Model = "models/error.mdl"
ITEM.Base = "base_entity"

function ITEM:CanPickup( pl, ent )
	if not ent.dt or not ent.dt.owning_ent then return true end

	if not itemstore.config.IgnoreOwner and ent:Getowning_ent() ~= pl then
		pl:ChatPrint( "You can't pick that up, it's not your's!" )
		return false
	end

	return true
end
--addons/module_itemstore/lua/itemstore/items/craft_electronics.lua:
ITEM.Name = 'Электроника'
ITEM.Model = 'models/props/cs_office/projector_p6.mdl'
ITEM.Stackable = true
ITEM.MaxStack = 4
ITEM.DropStack = false
--addons/module_itemstore/lua/itemstore/items/craft_scrap.lua:
ITEM.Name = 'Металлолом'
ITEM.Model = 'models/props_debris/metal_panelchunk02d.mdl'
ITEM.Stackable = true
ITEM.MaxStack = 4
ITEM.DropStack = false
--addons/module_itemstore/lua/itemstore/items/drug_lab.lua:
ITEM.Name = itemstore.Translate( "druglab_name" )
ITEM.Description = itemstore.Translate( "druglab_desc" )
ITEM.Model = "models/props_lab/crematorcase.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Factories
ITEM.Base = "base_darkrp"

function ITEM:SaveData( ent )
	self:SetData( "Price", ent:Getprice() )
	self:SetData( "Owner", ent:Getowning_ent() )
end

function ITEM:LoadData( ent )
	ent:Setprice( self:GetData( "Price" ) )
	
	local owner = self:GetData( "Owner" )
	if not IsValid( owner ) then
		owner = player.GetAll()[ 1 ]
	end

	ent:Setowning_ent( owner )
end
--addons/module_itemstore/lua/itemstore/items/eml_meth.lua:
ITEM.Name = 'Кристализированный метамфетамин'
ITEM.Description = 'На 99,1% чистый и светло-голубого цвета метамфетамин'
ITEM.Model = 'models/props_junk/rock001a.mdl'
ITEM.Color = Color(1, 241, 249, 255)
ITEM.Material = 'models/shiny'
ITEM.Base = 'base_entity'
ITEM.Stackable = true
ITEM.DropStack = true
ITEM.MaxStack = 16
ITEM.IsIllegal = true

ITEM:CreateMutator('Price')
ITEM.Price = 12000

function ITEM:SaveData(ent)
	self:SetAmount(ent:GetMethAmount())
end

function ITEM:LoadData( ent )
    ent:SetMethAmount(self:GetAmount())
    ent:SetMaxAmount(self:GetAmount())
    ent:SetValue(self:GetAmount())
end

function ITEM:CreateEntity( pos )
	local ent = ents.Create( self.Class )
	ent:SetPos( pos )
	ent:Spawn()
    self:LoadData(ent)
	ent:Activate()

	return ent
end
--addons/module_itemstore/lua/itemstore/items/hobo_trash.lua:
ITEM.Name = 'Мусор'
ITEM.Model = 'models/error.mdl'
ITEM.Stackable = false
ITEM.DropStack = true

ITEM:CreateMutator('Price')

function ITEM:GenerateHoboTrash(data)
    local item = itemstore.Item(self:GetClass())

    item:SetName(data.name)
    item:SetDescription(data.desc)
    item:SetModel(data.model)
    item:SetPrice(data.price)

    return item
end
--addons/module_itemstore/lua/itemstore/items/microwave.lua:
ITEM.Name = itemstore.Translate( "microwave_name" )
ITEM.Description = itemstore.Translate( "microwave_desc" )
ITEM.Model = "models/props/cs_office/microwave.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Factories
ITEM.Base = "base_darkrp"

function ITEM:SaveData( ent )
	self:SetData( "Price", ent:Getprice() )
	self:SetData( "Owner", ent:Getowning_ent() )
end

function ITEM:LoadData( ent )
	ent:Setprice( self:GetData( "Price" ) )

	local owner = self:GetData( "Owner" )
	if not IsValid( owner ) then
		owner = player.GetAll()[ 1 ]
	end

	ent:Setowning_ent( owner )
end
--addons/module_itemstore/lua/itemstore/items/prop_physics.lua:
ITEM.Name = itemstore.Translate( "prop_name" )
ITEM.Description = itemstore.Translate( "prop_desc" )
ITEM.Base = "base_auto"

function ITEM:CanPickup( pl, ent )
	if CPPI then
		if ent:CPPIGetOwner() ~= pl then
			return false
		end
	end

	return true
end
--addons/module_itemstore/lua/itemstore/items/sent_weed_bag.lua:
ITEM.Name = 'Марихуана'
ITEM.Model = 'models/gonzo/weedb/bag/bag.mdl'
ITEM.Base = 'base_entity'
ITEM.Stackable = true
ITEM.DropStack = true
ITEM.MaxStack = 60
ITEM.IsIllegal = true

ITEM:CreateMutator('Quality', 0)

function ITEM:SaveData(ent)
    self:SetAmount(ent:GetWeedAmount())
	self:SetQuality(ent:GetWeedQuality())
end

function ITEM:LoadData(ent)
    ent:SetModel(self:GetModel())
    ent:SetWeedAmount(self:GetAmount())
    ent:SetWeedQuality(self:GetQuality())
end

function ITEM:CreateEntity( pos )
	local ent = ents.Create( self.Class )
	ent:SetPos( pos )
	ent:Spawn()
    self:LoadData(ent)
	ent:Activate()

	return ent
end

function ITEM:Use(ply)
    if self:GetAmount() == 1 then
        DarkRP.notify(ply, 0, 5, 'Ты получил косяк с 1г марихуаны. Скури его чтобы получить эффект')
    
        if ply:HasWeapon('weapon_vape_cigarette') then ply:StripWeapon('weapon_vape_cigarette') end
        local wep = ply:Give('weapon_vape_cigarette')
        if not IsValid(wep) then return end

        wep:SetVar('restricted_to_drop', true)
        wep:SetBreakCallback(function()
            ply:AddWeed(1, self:GetQuality(), math.Clamp(WEED_CONFIG.Duration * 1/WEED_CONFIG.AmountToRaskumar, 0, WEED_CONFIG.Duration))
            local max = ply:GetMaxHealth()
            if max > 100 then
                ply:SetHealth(math.floor(max+(100*1/60)))
            else
                ply:SetHealth(math.floor(max+(max*1/60)))
            end
        end)

        return true
    else
        wlib.requests.send(ply, {
            {
                type = 'numslider',
                name = 'Кол-во грамм',
                default = 1,
                min = 1,
                max = self:GetAmount(),
                decimals = 0,
            },
        }, function(res)
            if not IsValid(self) then return end
            local con = self:GetContainer()
    
            local amount = math.Clamp(math.floor(res[1]), 1, self:GetAmount())
            if self:GetAmount() < amount then return end
    
            self:SetAmount(self:GetAmount()-amount)
            if self:GetAmount() <= 0 then
                con:SetItem(self:GetSlot(), nil)
            end
            con:QueueSync()
            ply:QueueInventorySave()
    
            DarkRP.notify(ply, 0, 5, 'Ты получил косяк с '..amount..'г марихуаны. Скури его чтобы получить эффект')
    
            if ply:HasWeapon('weapon_vape_cigarette') then ply:StripWeapon('weapon_vape_cigarette') end
            local wep = ply:Give('weapon_vape_cigarette')
            if not IsValid(wep) then return end
    
            wep:SetVar('restricted_to_drop', true)
            wep:SetBreakCallback(function()
                ply:AddWeed(1, self:GetQuality(), math.Clamp(WEED_CONFIG.Duration * amount/WEED_CONFIG.AmountToRaskumar, 0, WEED_CONFIG.Duration))
                local max = ply:GetMaxHealth()
                if max > 100 then
                    ply:SetHealth(math.floor(max+(100*amount/60)))
                else
                    ply:SetHealth(math.floor(max+(max*amount/60)))
                end
            end)
        end)
    end
end

local oldCanMerge = ITEM.CanMerge
function ITEM:CanMerge(item)
    return oldCanMerge(self, item) and (self:GetQuality() == item:GetQuality())
end

function ITEM:GetPrice()
    return (1000 / 100 * self:GetQuality()) + 1000
end

local str = 'Кол-во: %sг\nКачество: %s%%'
function ITEM:GetDescription()
    return str:format(self:GetAmount(), self:GetQuality())
end

local mdls = {
    'models/gonzo/weedb/bag/bag.mdl',
    'models/gonzo/weedb/bag/jar.mdl',
    'models/gonzo/weedb/bag/brick.mdl',
}
function ITEM:GetModel()
    local border = math.floor(self.MaxStack/#mdls)
    return mdls[math.Clamp(math.floor(self:GetAmount()/border)+1, 1, #mdls)]
end
--addons/module_itemstore/lua/itemstore/items/spawned_food.lua:
ITEM.Name = itemstore.Translate( "food_name" )
ITEM.Description = itemstore.Translate( "food_desc" )
ITEM.Model = "models/props_junk/watermelon01.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Consumables
ITEM.Base = "base_darkrp"

ITEM.Foods = {
	[ "models/props_junk/watermelon01.mdl" ] = itemstore.Translate( "food_melon" ),
	[ "models/props/cs_italy/orange.mdl" ] = itemstore.Translate( "food_orange" ),
	[ "models/props/cs_italy/bananna_bunch.mdl" ] = itemstore.Translate( "food_bananas" ),
	[ "models/props/cs_italy/bananna.mdl" ] = itemstore.Translate( "food_banana" ),
	[ "models/props_junk/glassbottle01a.mdl" ] = itemstore.Translate( "food_glassbottle" ),
	[ "models/props_junk/popcan01a.mdl" ] = itemstore.Translate( "food_soda" ),
	[ "models/props_junk/garbage_milkcarton002a.mdl" ] = itemstore.Translate( "food_milk" ),
	[ "models/props_junk/garbage_glassbottle002a.mdl" ] = itemstore.Translate( "food_beer" ),
	[ "models/props_junk/garbage_plasticbottle003a.mdl" ] = itemstore.Translate( "food_twolitresoda" ),
	[ "models/props_junk/garbage_glassbottle001a.mdl" ] = itemstore.Translate( "food_onelitresoda" ),
	[ "models/props_junk/garbage_glassbottle003a.mdl" ] = itemstore.Translate( "food_glassbottle" )
}

function ITEM:GetName()
	local name = self.Name

	if self.Foods[ self:GetModel() ] then
		name = self.Foods[ self:GetModel() ]
	end

	return self:GetData( "Name", name )
end

function ITEM:GetDescription()
	return self:GetData( "Description", string.format( self.Description, self:GetData( "Nutrition", 1 ) ) )
end

function ITEM:Use( pl )
	local energy = pl:GetNetVar( "Energy" ) + self:GetData( "Nutrition", 1 )
	pl:SetNetVar( "Energy", math.Clamp( energy, 0, 100 ) )

	umsg.Start( "AteFoodIcon", pl ) umsg.End()

	pl:EmitSound( "npc/barnacle/barnacle_crunch2.wav" )

	return self:TakeOne()
end

function ITEM:SaveData( ent )
	self:SetData( "Owner", ent:Getowning_ent() )
	self:SetData( "Nutrition", ent.FoodEnergy )
	self:SetModel( ent:GetModel() )
end

function ITEM:LoadData( ent )
	ent:Setowning_ent( self:GetData( "Owner" ) )
	ent:SetModel( self:GetModel() )
	ent.FoodEnergy = self:GetData( "Nutrition" )

	-- One day fptje is gonna have some feces mailed to his house or something, christ
	for k, v in ipairs( FoodItems ) do
		if v.model == self:GetModel() then
			ent.foodItem = v
			break
		end
	end
end

--addons/module_itemstore/lua/itemstore/cl_gui.lua:
include( "skins/" .. itemstore.config.Skin .. ".lua" )

for _, filename in ipairs( file.Find( "itemstore/vgui/*.lua", "LUA" ) ) do
	include( "vgui/" .. filename )
end

itemstore.ContextInventory = nil

function itemstore.CreateContextInventory()
	if not itemstore.config.ContextInventory then return end
	if not IsValid( g_ContextMenu ) then return end

	local inv = vgui.Create( "ItemStoreContainerWindow", g_ContextMenu )
	inv:SetTitle( itemstore.Translate( "inventory" ) )
	inv:SetIcon("icon72/school_satchel.png")
	inv:SetContainerID( LocalPlayer().InventoryID )
	inv:ShowCloseButton( false )
	inv:SetDraggable( false )
	inv:InvalidateLayout( true )
	function inv:OnRemove()
		if IsValid(self.CraftFrame) then self.CraftFrame:Remove() end
	end

	local side = itemstore.config.ContextInventoryPosition

	if side == "bottom" then
		inv:SetPos( ScrW() / 2 - inv:GetWide() / 2, ScrH() - inv:GetTall() )
	elseif side == "bottomleft" then
		inv:SetPos( 0, ScrH() - inv:GetTall() )
	elseif side == "bottomright" then
		inv:SetPos( ScrW() - inv:GetWide(), ScrH() - inv:GetTall() )
	elseif side == "top" then
		inv:SetPos( ScrW() / 2 - inv:GetWide() / 2, 0 )
	elseif side == "topleft" then
		inv:SetPos( 0, 0 )
	elseif side == "topright" then
		inv:SetPos( ScrW() - inv:GetWide(), 0 )
	elseif side == "left" then
		inv:SetPos( 0, ScrH() / 2 - inv:GetTall() / 2 )
	elseif side == "right" then
		inv:SetPos( ScrW() - inv:GetWide(), ScrH() / 2 - inv:GetTall() / 2 )
	end

	itemstore.ContextInventory = inv
end

hook.Add( "Tick", "ItemStoreHideContextInventory", function()
	if not IsValid( LocalPlayer() ) then return end

	if IsValid( itemstore.ContextInventory ) then 
		local canuse = LocalPlayer():CanUseInventory()
		if IsValid(itemstore.ContextInventory.CraftFrame) then itemstore.ContextInventory.CraftFrame:SetVisible(canuse) end
		itemstore.ContextInventory:SetVisible(canuse)
	else
		if LocalPlayer().InventoryID then
			itemstore.CreateContextInventory()
		end
	end
end )

hook.Add( "ContextMenuCreated", "ItemStoreInventory", function( context )
	if not IsValid( context ) then return end
	
	context:Receiver( "ItemStore", function( receiver, droppable, dropped )
		if not dropped then return end
		
		LocalPlayer():DropItem( droppable[ 1 ]:GetContainerID(), droppable[ 1 ]:GetSlot() )
	end )
end )

--addons/module_itemstore/lua/itemstore/vgui/containerwindow.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSkin( "itemstore" )

	self.Container = vgui.Create( "ItemStoreContainer", self )
	self.Container:SizeToContents()
end

function PANEL:PerformLayout()
	self:SetSize( self.Container:GetWide() + 10, self.Container:GetTall() + 32 )
	self.Container:SetPos( 5, 27 )

	self.BaseClass.PerformLayout( self )
end

function PANEL:Refresh()
	self.Container:Refresh()
end

function PANEL:SetContainerID( id )
	self.Container:SetContainerID( id )
end

function PANEL:GetContainerID()
	return self.Container:GetContainerID()
end

vgui.Register( "ItemStoreContainerWindow", PANEL, "DFrame" )

--addons/module_itemstore/lua/itemstore/vgui/itemtooltip.lua:
DEFINE_BASECLASS( "DListLayout" )

local PANEL = {}

AccessorFunc( PANEL, "ContainerID", "ContainerID", FORCE_NUMBER )
AccessorFunc( PANEL, "Slot", "Slot", FORCE_NUMBER )
AccessorFunc( PANEL, "Item", "Item" )

function PANEL:Init()
	self:SetWide( 200 )
	self:SetDrawOnTop( true )
	self:DockPadding( 5, 5, 5, 5 )

	self.Name = self:Add( "DLabel" )
	self.Name:SetFont( "DermaDefaultBold" )
	self.Name:SetWrap( true )

	self.Model = self:Add( "DModelPanel" )
	self.Model:SetSize( 125, 125 )

	self.Description = self:Add( "DLabel" )
	self.Description:SetWrap( true )
end

PANEL.Blur = Material( "pp/blurscreen" )
function PANEL:Paint( w, h )
	self.Blur:SetFloat( "$blur", 8 )
	self.Blur:Recompute()
	render.UpdateScreenEffectTexture()

	local x, y = self:LocalToScreen( 0, 0 )

	surface.SetDrawColor( 255, 255, 255 )
	surface.SetMaterial( self.Blur )
	surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )

	surface.SetDrawColor( Color( 30, 30, 30, 200 ) )
	surface.DrawRect( 0, 0, w, h )
end

function PANEL:PerformLayout()
	self.Name:SizeToContents()
	self.Description:SizeToContents()

	BaseClass.PerformLayout( self )
end

function PANEL:Refresh()
	local item = self:GetItem()

	if not item then
		self.Model.Entity:Remove()
		self.Name:SetText( "" )
		self.Description:SetText( "" )

		return
	end

	local name = item:GetName()
	local desc = item:GetDescription() or ""

	if item:GetAmount() > 1 then
		name = name .. " x" .. item:GetAmount()
	end

	if self:GetSlot() then
		desc = desc .. "\n\n" .. itemstore.Translate( "dragtomove" )
		desc = desc .. "\n" .. itemstore.Translate( "shiftclicktomove" )
		desc = desc .. "\n" .. itemstore.Translate( "mclicktodrop" )
		desc = desc .. "\n" .. itemstore.Translate( "rclickforoptions" )

		if item.Use then
			desc = desc .. "\n" .. itemstore.Translate( "dclicktouse" )
		end
	end

	self.Name:SetText( name )
	self.Name:SizeToContents()

	self.Description:SetText( desc )
	self.Description:SizeToContents()

	self.Model:SetModel( item:GetModel() )

	self.Model.Entity:SetMaterial( item:GetMaterial() )
	self.Model:SetColor( item:GetColor() or color_white )

	min, max = self.Model.Entity:GetRenderBounds()

	self.Model:SetCamPos( Vector( 0.55, 0.55, 0.55 ) * min:Distance( max ) )
	self.Model:SetLookAt( ( min + max ) / 2 )

	self:InvalidateLayout( true )
end

vgui.Register( "ItemStoreTooltip", PANEL, "DListLayout" )

--addons/module_logs/lua/plogs_hooks/fadmin.lua:
plogs.Register('FAdmin', true, Color(200,0,0))

local ignoredCommands = {
    ['message'] = true,
    --['bring'] = true,
    --['goto'] = true,
    --['tp'] = true,
    --['teleport'] = true,
    ['tptopos'] = true,
    ['spectate'] = true,
    ['freeze'] = true,
    ['unfreeze'] = true,
    ['ban'] = true,
    ['unban'] = true,
}

local drpCommands = {
    ['forcerpname'] = true,
}

plogs.AddHook('FAdmin', 'FAdmin_OnCommandExecuted', function (ply, cmd, args, res)
    if ignoredCommands[cmd] then return end
    if not res[1] then return end

    if istable(res[2]) then
        local tar = {}
        for _, v in ipairs(res[2]) do
            tar[#tar+1] = isstring(v) and v or (v:IsBot() and tostring(v) or v:SteamID())
        end
        args[1] = table.concat(tar, ';')
    elseif isentity(res[2]) and res[2]:IsPlayer() then
        local p = res[2]
    	args[1] = p:IsBot() and tostring(p) or p:SteamID()
    end

    plogs.PlayerLog(ply, 'FAdmin', (ply:IsPlayer() and ply:NameID() or 'Сервер') .. ' использовал FAdmin-команду (' .. cmd .. ') с аргументами "' .. table.concat(args or {}, ', ') .. '"', {
        ['Ник'] = ply:IsPlayer() and ply:LogsName() or 'Console',
        ['SteamID'] = ply:IsPlayer() and ply:LogsSteamID() or 'Console',
    })
end)

plogs.AddHook('FAdmin', 'onChatCommand', function(ply, cmd, arg)
    if not drpCommands[cmd] then return end

    plogs.PlayerLog(ply, 'FAdmin', (ply:IsPlayer() and ply:NameID() or 'Сервер') .. ' использовал DarkRP-команду (' .. cmd .. ') с аргументами "' .. table.concat(istable(arg) and arg or string.Explode(' ', arg), ', ') .. '"', {
        ['Ник'] = ply:IsPlayer() and ply:LogsName() or 'Console',
        ['SteamID'] = ply:IsPlayer() and ply:LogsSteamID() or 'Console',
    })
end)
--addons/module_outfitter/lua/outfitter/sh.lua:
--